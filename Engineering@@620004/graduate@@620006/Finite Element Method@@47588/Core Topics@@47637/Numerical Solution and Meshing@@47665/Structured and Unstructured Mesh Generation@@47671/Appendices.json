{"hands_on_practices": [{"introduction": "The foundation of any reliable finite element analysis lies in the quality of the underlying mesh. Before we can improve a mesh or understand its impact on a simulation, we must first be able to quantify its quality. This practice guides you through the process of implementing key geometric quality metrics for 3D tetrahedral elements from first principles, including aspect ratio, skewness, and the Jacobian determinant. By programming these evaluators, you will gain a concrete understanding of how to diagnose common mesh issues such as distortion, anisotropy, and element inversion [@problem_id:2412640].", "problem": "You are given the task of designing and implementing a complete, runnable program that evaluates three geometric quality metrics for elements of an unstructured three-dimensional mesh of linear tetrahedra. The mesh is defined by node coordinates in three-dimensional Euclidean space $\\mathbb{R}^3$ and element connectivity. Your implementation must start from first principles of linear mappings and Euclidean geometry, and it must compute the following for each tetrahedral element and then aggregate them at the mesh level: aspect ratio, skewness, and the Jacobian determinant of the isoparametric mapping. All computations are to be performed with dimensionless quantities; no physical units are involved.\n\nFoundational definitions and assumptions:\n\n- A linear tetrahedral element is defined by four distinct nodes with coordinates $\\mathbf{x}_1,\\mathbf{x}_2,\\mathbf{x}_3,\\mathbf{x}_4 \\in \\mathbb{R}^3$. The corresponding affine map from the reference tetrahedron to the physical tetrahedron is\n$$\n\\mathbf{x}(\\boldsymbol{\\xi}) \\;=\\; \\mathbf{x}_1 \\;+\\; J \\,\\boldsymbol{\\xi},\n$$\nwhere $J \\in \\mathbb{R}^{3 \\times 3}$ is the Jacobian matrix with columns $J = \\begin{bmatrix} \\mathbf{x}_2-\\mathbf{x}_1 & \\mathbf{x}_3-\\mathbf{x}_1 & \\mathbf{x}_4-\\mathbf{x}_1 \\end{bmatrix}$ and $\\boldsymbol{\\xi}\\in\\mathbb{R}^3$ lies in the reference tetrahedron. For a linear tetrahedron, $J$ is constant over the element. The signed volume $V$ of the element satisfies $V = \\det(J)/6$.\n\n- The Euclidean norm of a vector $\\mathbf{v}\\in\\mathbb{R}^3$ is $\\lVert \\mathbf{v}\\rVert_2 = \\sqrt{\\mathbf{v}^\\top \\mathbf{v}}$.\n\n- The Singular Value Decomposition (SVD) writes $J = U \\Sigma V^\\top$ with $U,V\\in\\mathbb{R}^{3\\times 3}$ orthogonal and $\\Sigma = \\operatorname{diag}(\\sigma_1,\\sigma_2,\\sigma_3)$ with singular values $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$. The determinant satisfies $\\det(J) = \\sigma_1 \\sigma_2 \\sigma_3 \\cdot \\det(U)\\det(V)$, and the absolute value is $\\lvert \\det(J)\\rvert = \\sigma_1 \\sigma_2 \\sigma_3$.\n\nElement-level quality metrics to compute from first principles:\n\n1. Aspect ratio. Let the six edge lengths be $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j\\rVert_2$ for the index pairs $(i,j)\\in\\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\\}$. Define the element aspect ratio by\n$$\n\\mathrm{AR} \\;=\\; \\frac{\\max l_{ij}}{\\min l_{ij}}.\n$$\nIf any $l_{ij} = 0$ (degenerate edge), define $\\mathrm{AR}$ to be $+\\infty$.\n\n2. Skewness. Using the singular values of $J$, define the skewness by\n$$\n\\mathrm{SK} \\;=\\; 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} \\;=\\; 1 - \\frac{\\sigma_3}{\\sigma_1}.\n$$\nIf $\\sigma_1 = 0$ (fully degenerate), define $\\mathrm{SK} = 1$. This measure lies in $[0,1]$ for nondegenerate elements, with $\\mathrm{SK}=0$ indicating isotropy of the mapping columns and values close to $1$ indicating severe anisotropy or near-degeneracy.\n\n3. Jacobian determinant. For each element, compute the signed Jacobian determinant\n$$\n\\mathrm{JAC} \\;=\\; \\det(J).\n$$\nNegative values indicate inverted orientation. The element volume is $V = \\mathrm{JAC}/6$.\n\nMesh-level aggregation:\n\n- For a given mesh, define its worst aspect ratio as the maximum $\\mathrm{AR}$ over all elements.\n- Define its worst skewness as the maximum $\\mathrm{SK}$ over all elements.\n- Define its minimum Jacobian determinant as the minimum $\\mathrm{JAC}$ over all elements.\n\nProgram requirements:\n\n- Implement a parser for a simple in-memory mesh description format representing an unstructured tetrahedral mesh. Each mesh comprises a set of nodes and a set of tetrahedral elements referencing those nodes. Your program must embed the meshes internally as string constants; it must not read external files or require user input. The format is:\n  - A line \"NODES $N$\" followed by $N$ lines each containing \"$\\text{id}\\; x\\; y\\; z$\" with integer $\\text{id}$ and real coordinates $x,y,z$.\n  - A line \"ELEMENTS $M$\" followed by $M$ lines each containing \"$\\text{id}\\; n_1\\; n_2\\; n_3\\; n_4$\" with integer $\\text{id}$ and integer node indices $n_k$.\n\n- For each tetrahedral element, compute $\\mathrm{AR}$, $\\mathrm{SK}$, and $\\mathrm{JAC}$ as defined above using only the fundamental operations and definitions provided.\n\n- Aggregate per mesh as specified to produce three values per mesh: worst aspect ratio, worst skewness, and minimum Jacobian determinant.\n\nTest suite to be embedded and evaluated by your program:\n\n- Test mesh A (well-shaped, equilateral-like). Nodes:\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (1,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{2},\\,0\\right)$,\n  - $\\mathbf{x}_4 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{6},\\,\\tfrac{\\sqrt{6}}{3}\\right)$.\n  One element with connectivity $(1,2,3,4)$.\n\n- Test mesh B (near-degenerate sliver with very small volume). Nodes:\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (2,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = (0,\\,2,\\,0)$,\n  - $\\mathbf{x}_4 = (1,\\,1,\\,10^{-6})$.\n  One element with connectivity $(1,2,3,4)$.\n\n- Test mesh C (inverted orientation). Same node coordinates as Test mesh A, but the single element connectivity is $(1,3,2,4)$ so that the mapping orientation is inverted.\n\nRequired final output format:\n\n- Your program must produce a single line of output containing a list of three lists, one per test mesh, in the exact order A, B, C. Each inner list must contain three floating-point numbers in the order $[\\mathrm{AR}_\\text{worst}, \\mathrm{SK}_\\text{worst}, \\mathrm{JAC}_\\text{min}]$ for that mesh. Round each number to six decimal places. The overall output format must be exactly\n$$\n\\big[ [a_1,s_1,j_1], [a_2,s_2,j_2], [a_3,s_3,j_3] \\big]\n$$\nwith numeric entries rendered as decimals rounded to six places and no additional text. For example, an admissible structure is\n$[[1.000000,0.375000,0.707107],[\\dots],[\\dots]]$.", "solution": "The problem requires the design and implementation of a program to evaluate three fundamental geometric quality metrics for a three-dimensional tetrahedral mesh: aspect ratio, skewness, and the Jacobian determinant of the isoparametric mapping. The evaluation must be performed for several test meshes, and the results aggregated at the mesh level.\n\nThe core of the task is to analyze the geometry of each tetrahedral element. A linear tetrahedron is defined by four nodes, $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$. The geometry is characterized by the affine transformation that maps a canonical reference tetrahedron to the physical element in $\\mathbb{R}^3$. This mapping is given by $\\mathbf{x}(\\boldsymbol{\\xi}) = \\mathbf{x}_1 + J \\boldsymbol{\\xi}$, where $\\boldsymbol{\\xi}$ are the coordinates in the reference space and $J \\in \\mathbb{R}^{3 \\times 3}$ is the Jacobian matrix of the transformation. For a linear tetrahedron, this Jacobian is constant throughout the element.\n\nThe standard reference tetrahedron in computational mechanics has vertices at coordinate tuples $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, and $(0,0,1)$. The affine map is constructed such that these reference vertices map to the physical nodes $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$, respectively. This leads to the definition of the Jacobian matrix columns as the vectors spanning the edges of the physical tetrahedron originating from the first node, $\\mathbf{x}_1$:\n$$\nJ = \\begin{bmatrix} (\\mathbf{x}_2 - \\mathbf{x}_1) & (\\mathbf{x}_3 - \\mathbf{x}_1) & (\\mathbf{x}_4 - \\mathbf{x}_1) \\end{bmatrix}.\n$$\nThis matrix, $J$, and the set of the element's edge lengths are the foundational quantities from which all required metrics are derived.\n\nThe computational procedure is structured as follows:\n1.  Parse the provided mesh data, which is given in a specific string format, to establish node coordinates and element connectivity.\n2.  For each element in the mesh, retrieve the coordinates of its four defining nodes.\n3.  Compute the three specified element-level quality metrics: Aspect Ratio (AR), Skewness (SK), and Jacobian determinant (JAC).\n4.  Aggregate these metrics across all elements in the mesh to find the worst aspect ratio, worst skewness, and minimum Jacobian determinant.\n5.  Repeat for all test meshes and format the final results as required.\n\nWe now detail the calculation of each metric.\n\n1.  **Aspect Ratio ($\\mathrm{AR}$)**\n    The aspect ratio is a measure of how distorted an element is compared to an ideal shape (e.g., an equilateral tetrahedron). It is defined based on the lengths of the element's six edges. For a tetrahedron with nodes $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$, the six edge lengths are $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2$ for index pairs $(i,j)$ in $\\{(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)\\}$. The Euclidean norm $\\lVert \\mathbf{v} \\rVert_2$ of a vector $\\mathbf{v} = (v_x, v_y, v_z)$ is $\\sqrt{v_x^2 + v_y^2 + v_z^2}$.\n    The aspect ratio is then the ratio of the longest edge to the shortest edge:\n    $$\n    \\mathrm{AR} = \\frac{\\max_{i,j} l_{ij}}{\\min_{i,j} l_{ij}}.\n    $$\n    An ideal equilateral tetrahedron has an $\\mathrm{AR}$ of $1$. Higher values indicate greater distortion. If any edge has zero length, meaning $\\min l_{ij} = 0$, the element is degenerate, and its aspect ratio is defined as infinite ($\\infty$).\n\n2.  **Jacobian Determinant ($\\mathrm{JAC}$)**\n    The determinant of the Jacobian matrix, $\\mathrm{JAC} = \\det(J)$, is directly related to the element's volume. The signed volume of the tetrahedron is $V = \\det(J)/6$.\n    -   A positive determinant, $\\det(J) > 0$, indicates that the element's node ordering (connectivity) preserves the orientation of the reference element. This is the standard for a valid mesh.\n    -   A negative determinant, $\\det(J) < 0$, signifies an inverted or \"inside-out\" element, which is geometrically and physically invalid for most simulation purposes.\n    -   A zero determinant, $\\det(J) = 0$, implies a degenerate element with zero volume (e.g., all four nodes are coplanar).\n\n3.  **Skewness ($\\mathrm{SK}$)**\n    Skewness measures the degree of anisotropy of the affine mapping from the reference to the physical element. It is defined using the singular values of the Jacobian matrix, $J$. The Singular Value Decomposition (SVD) of $J$ is $J = U \\Sigma V^\\top$, where $\\Sigma = \\operatorname{diag}(\\sigma_1, \\sigma_2, \\sigma_3)$ and $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$ are the singular values. These values represent the scaling factors of the transformation along principal directions.\n    The skewness is defined as:\n    $$\n    \\mathrm{SK} = 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} = 1 - \\frac{\\sigma_3}{\\sigma_1}.\n    $$\n    This metric ranges from $0$ to $1$. A value of $\\mathrm{SK}=0$ occurs when $\\sigma_1=\\sigma_2=\\sigma_3$, corresponding to a purely isotropic scaling (although not necessarily an equilateral tetrahedron, as the reference element itself is not equilateral). A value approaching $1$ indicates severe anisotropy or near-degeneracy (i.e., $\\sigma_3 \\ll \\sigma_1$). If $\\sigma_1 = 0$, the element is fully degenerate, and $\\mathrm{SK}$ is defined as $1$.\n\nThe implementation will utilize the `numpy` library for efficient vector and matrix operations, including the calculation of norms, determinants, and singular value decomposition, which are standard numerical implementations of these first principles.\n\nFinally, for each mesh, the element-wise metrics are aggregated:\n-   Worst Aspect Ratio: $\\mathrm{AR}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{AR}$.\n-   Worst Skewness: $\\mathrm{SK}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{SK}$.\n-   Minimum Jacobian: $\\mathrm{JAC}_{\\text{min}} = \\min_{\\text{elements}} \\mathrm{JAC}$.\n\nThese three aggregated values provide a concise summary of the quality of the entire mesh.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, process, and evaluate the quality of test meshes.\n    \"\"\"\n    \n    # Test suite to be embedded and evaluated.\n    mesh_A_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_B_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 2.0 0.0 0.0\n    3 0.0 2.0 0.0\n    4 1.0 1.0 0.000001\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_C_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 3 2 4\n    \"\"\"\n    \n    test_cases = [mesh_A_string, mesh_B_string, mesh_C_string]\n\n    all_results = []\n    for mesh_data in test_cases:\n        result = process_mesh(mesh_data)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    list_of_lists_str = []\n    for res in all_results:\n        # Format each number to 6 decimal places.\n        formatted_res = [f\"{x:.6f}\" for x in res]\n        list_of_lists_str.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output_str = f\"[{','.join(list_of_lists_str)}]\"\n    print(final_output_str)\n\ndef parse_mesh(mesh_string: str) -> (dict, list):\n    \"\"\"\n    Parses a mesh description from a string into node and element data structures.\n    \n    Args:\n        mesh_string: A multiline string containing the mesh definition.\n        \n    Returns:\n        A tuple containing:\n        - A dictionary of nodes {node_id: np.array([x, y, z])}.\n        - A list of element connectivities [(n1, n2, n3, n4), ...].\n    \"\"\"\n    lines = mesh_string.strip().split('\\n')\n    nodes = {}\n    elements = []\n    \n    mode = None # \"NODES\" or \"ELEMENTS\"\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        \n        parts = line.split()\n        if parts[0] == \"NODES\":\n            mode = \"NODES\"\n            continue\n        elif parts[0] == \"ELEMENTS\":\n            mode = \"ELEMENTS\"\n            continue\n\n        if mode == \"NODES\":\n            node_id = int(parts[0])\n            coords = np.array([float(p) for p in parts[1:]])\n            nodes[node_id] = coords\n        elif mode == \"ELEMENTS\":\n            # Element ID is ignored as per logic, only connectivity matters\n            node_ids = tuple(int(p) for p in parts[1:])\n            elements.append(node_ids)\n            \n    return nodes, elements\n\ndef compute_aspect_ratio(node_coords: list) -> float:\n    \"\"\"\n    Computes the aspect ratio for a single tetrahedral element.\n    Aspect Ratio = max_edge_length / min_edge_length.\n    \"\"\"\n    points = [np.array(c) for c in node_coords]\n    \n    edge_indices = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n    edge_lengths = [np.linalg.norm(points[i] - points[j]) for i, j in edge_indices]\n        \n    min_len = min(edge_lengths)\n    max_len = max(edge_lengths)\n    \n    if min_len < 1e-12: # Treat very small lengths as zero to handle degeneracy\n        return np.inf\n    \n    return max_len / min_len\n\ndef compute_jacobian_metrics(node_coords: list) -> (float, float):\n    \"\"\"\n    Computes the Jacobian determinant and skewness for a single tetrahedral element.\n    \"\"\"\n    x1, x2, x3, x4 = [np.array(c) for c in node_coords]\n    \n    # Construct the Jacobian matrix J = [x2-x1, x3-x1, x4-x1], where each\n    # difference vector is a column.\n    J = np.vstack((x2 - x1, x3 - x1, x4 - x1)).T\n    \n    # Compute the signed Jacobian determinant.\n    jac_det = np.linalg.det(J)\n    \n    # Compute singular values for skewness. np.linalg.svd returns them sorted.\n    singular_values = np.linalg.svd(J, compute_uv=False)\n    \n    sigma_max = singular_values[0]\n    sigma_min = singular_values[-1]\n    \n    if sigma_max < 1e-12:\n        skewness = 1.0\n    else:\n        skewness = 1.0 - (sigma_min / sigma_max)\n        \n    return jac_det, skewness\n\ndef process_mesh(mesh_string: str) -> list:\n    \"\"\"\n    Processes a mesh, computes quality metrics for all its elements,\n    and returns the aggregated mesh-level quality indicators.\n    \n    Args:\n        mesh_string: The string defining the mesh.\n        \n    Returns:\n        A list containing [worst_aspect_ratio, worst_skewness, min_jacobian_determinant].\n    \"\"\"\n    nodes, elements = parse_mesh(mesh_string)\n    \n    worst_ar = 0.0\n    worst_sk = 0.0\n    min_jac = np.inf\n    \n    for elem_node_ids in elements:\n        # Node IDs in the mesh file are 1-based.\n        node_coords = [nodes[nid] for nid in elem_node_ids]\n        \n        # 1. Aspect Ratio\n        ar = compute_aspect_ratio(node_coords)\n        if ar > worst_ar:\n            worst_ar = ar\n\n        # 2. Jacobian Determinant and 3. Skewness\n        jac, sk = compute_jacobian_metrics(node_coords)\n        if sk > worst_sk:\n            worst_sk = sk\n        if jac < min_jac:\n            min_jac = jac\n            \n    return [worst_ar, worst_sk, min_jac]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2412640"}, {"introduction": "Understanding how to measure mesh quality is crucial, but the ultimate question is: how does it affect the solution? This hands-on exercise directly connects mesh topology to simulation results in a tangible way. You will investigate how two different, yet geometrically valid, triangulations of a simple quadrilateral domain can produce different displacement fields in a linear elasticity problem [@problem_id:2412649]. By implementing and comparing these scenarios, you will develop an intuition for the \"stiffness\" bias introduced by element orientation and appreciate why an arbitrary valid mesh is not always a good mesh.", "problem": "You are to implement and analyze a minimal linear elastic finite element model for a single convex quadrilateral discretized by two different triangulation choices. The goal is to quantify how these different triangulations affect the solution by measuring the difference in the computed displacement fields. The setting is planar, linear, isotropic elasticity under plane stress, using three-node linear triangular elements with constant strain.\n\nFundamental base:\n- Use the principle of minimum potential energy and the principle of virtual work to derive the discrete equations. The principle of virtual work states that for any virtual displacement field, the internal virtual work equals the external virtual work at equilibrium.\n- Use Hooke’s law for linear isotropic materials under plane stress: the stress-strain relation is linear with a constitutive matrix mapping strain to stress.\n- Use the standard Finite Element Method (FEM) with Constant Strain Triangle (CST) elements, where the strain-displacement matrix is constant within each triangular element.\n\nTask requirements:\n- Domain: A single convex quadrilateral with vertices labeled in counterclockwise order as nodes $0$, $1$, $2$, $3$.\n- Two triangulations must be considered:\n  - Triangulation A: use diagonal $\\overline{0-2}$ to form triangles $(0,1,2)$ and $(0,2,3)$.\n  - Triangulation B: use diagonal $\\overline{1-3}$ to form triangles $(0,1,3)$ and $(1,2,3)$.\n- Material model: Linear isotropic elasticity under plane stress with Young’s modulus $E$ (in Pascals), Poisson’s ratio $\\nu$ (dimensionless), and uniform thickness $t$ (in meters).\n- Loads and boundary conditions:\n  - Apply a uniform surface traction vector $\\mathbf{p}$ (in Pascals) on the right edge $\\overline{1-2}$. Assume $\\mathbf{p}$ is constant over the edge and acts on the edge of the two-dimensional body of thickness $t$.\n  - Impose homogeneous Dirichlet boundary conditions (zero displacement) on both displacement components at nodes $0$ and $3$ to eliminate rigid body modes.\n- Discretization and assembly:\n  - Derive and implement the element stiffness matrix for a three-node linear triangle from the principle of virtual work, using the constant strain-displacement matrix and the appropriate constitutive matrix for plane stress.\n  - Compute and assemble consistent equivalent nodal loads for the uniform traction on the boundary edge $\\overline{1-2}$. For a straight edge of length $L$ with constant traction $\\mathbf{p}$ and thickness $t$, distribute the load to the two edge nodes based on the standard consistent load derivation from shape functions along the edge.\n  - Assemble the global stiffness matrix and global force vector for each triangulation and solve the resulting linear system for nodal displacements.\n- Comparison metric:\n  - For each test case, compute the Euclidean norm of the difference between the full displacement vectors (including both $x$- and $y$-components for all four nodes) produced by Triangulation A and Triangulation B. Report this scalar norm in meters.\n\nUnits and numerical outputs:\n- All geometric coordinates are in meters.\n- Young’s modulus $E$ is in Pascals.\n- Poisson’s ratio $\\nu$ is dimensionless.\n- Thickness $t$ is in meters.\n- Traction vector components are in Pascals.\n- The comparison metric (norm of displacement difference) must be reported in meters as floating-point values.\n- Express the output values rounded to $9$ significant digits.\n\nTest suite:\nImplement your program to run the following three cases. For each case, the right edge is the segment between nodes $1$ and $2$, and the left boundary condition is applied at nodes $0$ and $3$.\n\n- Case $1$ (general convex quadrilateral):\n  - Coordinates (meters): $\\left[(0,0),\\ (2,0),\\ (2,1),\\ (0.2,1.2)\\right]$\n  - Material: $E = 7.0 \\times 10^{10}\\ \\text{Pa}$, $\\nu = 0.33$, $t = 0.01\\ \\text{m}$\n  - Traction on $\\overline{1-2}$: $\\mathbf{p} = (1.0 \\times 10^{6},\\ 0)$ Pa\n- Case $2$ (axis-aligned rectangle):\n  - Coordinates (meters): $\\left[(0,0),\\ (1,0),\\ (1,1),\\ (0,1)\\right]$\n  - Material: $E = 1.0 \\times 10^{7}\\ \\text{Pa}$, $\\nu = 0.25$, $t = 0.05\\ \\text{m}$\n  - Traction on $\\overline{1-2}$: $\\mathbf{p} = (5.0 \\times 10^{4},\\ 0)$ Pa\n- Case $3$ (slender convex quadrilateral with high Poisson’s ratio):\n  - Coordinates (meters): $\\left[(0,0),\\ (3,0),\\ (3,0.1),\\ (0,0.2)\\right]$\n  - Material: $E = 2.0 \\times 10^{9}\\ \\text{Pa}$, $\\nu = 0.49$, $t = 0.01\\ \\text{m}$\n  - Traction on $\\overline{1-2}$: $\\mathbf{p} = (1.0 \\times 10^{4},\\ 0)$ Pa\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}\\right]$ with no spaces. Each $\\text{result}_{i}$ is the Euclidean norm of the displacement difference between the two triangulation choices for case $i$, in meters, rounded to $9$ significant digits.\n- The program must be self-contained, require no input, and run as-is.\n\nNotes:\n- Use the first appearance of any acronym with its full name, for example, Finite Element Method (FEM) and Constant Strain Triangle (CST).\n- Ensure scientific realism by using consistent units and stable boundary conditions.", "solution": "The problem requires an analysis of the effect of mesh topology on the solution of a linear elastic problem using the Finite Element Method (FEM). Specifically, we are to compute the displacement field for a single convex quadrilateral domain subjected to a surface traction and fixed boundary conditions. The domain is meshed in two different ways, and the Euclidean norm of the difference between the resulting displacement vectors is calculated. The analysis is based on the theory of linear elasticity for a plane stress condition, discretized using three-node Constant Strain Triangle (CST) elements.\n\nThe solution proceeds in several steps: derivation of the element stiffness matrix, calculation of consistent nodal loads, assembly of the global system of equations, application of boundary conditions, solution for nodal displacements, and finally, comparison of the results from the two triangulations.\n\n**1. Finite Element Formulation for a Constant Strain Triangle (CST)**\n\nWe consider a single triangular element with three nodes, indexed $i, j, k$, in a counter-clockwise order. The displacement field $\\mathbf{u}(x, y)$ within the element is approximated using linear shape functions $N_i, N_j, N_k$:\n$$ \\mathbf{u}(x, y) = \\begin{Bmatrix} u_x(x,y) \\\\ u_y(x,y) \\end{Bmatrix} = \\sum_{m=i,j,k} N_m(x,y) \\begin{Bmatrix} u_m \\\\ v_m \\end{Bmatrix} $$\nwhere $(u_m, v_m)$ are the displacement components at node $m$. This can be written in matrix form as $\\mathbf{u} = \\mathbf{N} \\mathbf{d}^e$, where $\\mathbf{d}^e = \\{u_i, v_i, u_j, v_j, u_k, v_k\\}^T$ is the element's nodal displacement vector and $\\mathbf{N}$ is the shape function matrix:\n$$ \\mathbf{N} = \\begin{bmatrix} N_i & 0 & N_j & 0 & N_k & 0 \\\\ 0 & N_i & 0 & N_j & 0 & N_k \\end{bmatrix} $$\nThe strain vector for a 2D problem is $\\boldsymbol{\\epsilon} = \\{\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}\\}^T$. Strains are derived from displacements as:\n$$ \\epsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\quad \\epsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x} $$\nThis relationship is expressed as $\\boldsymbol{\\epsilon} = \\mathbf{L} \\mathbf{u}$, where $\\mathbf{L}$ is the differential operator matrix. Substituting the FEM approximation for $\\mathbf{u}$, we get the strain-displacement relationship:\n$$ \\boldsymbol{\\epsilon} = (\\mathbf{L} \\mathbf{N}) \\mathbf{d}^e = \\mathbf{B} \\mathbf{d}^e $$\nFor a CST element, the resulting strain-displacement matrix $\\mathbf{B}$ is constant over the element. It is given by:\n$$ \\mathbf{B} = \\frac{1}{2A_e} \\begin{bmatrix} y_{jk} & 0 & y_{ki} & 0 & y_{ij} & 0 \\\\ 0 & x_{kj} & 0 & x_{ik} & 0 & x_{ji} \\\\ x_{kj} & y_{jk} & x_{ik} & y_{ki} & x_{ji} & y_{ij} \\end{bmatrix} $$\nwhere $(x_m, y_m)$ are the coordinates of node $m$, $x_{pq} = x_p - x_q$, $y_{pq} = y_p - y_q$, and $A_e$ is the area of the element, calculated as $A_e = \\frac{1}{2} |x_i(y_j - y_k) + x_j(y_k - y_i) + x_k(y_i - y_j)|$.\n\nThe stress vector $\\boldsymbol{\\sigma} = \\{\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}\\}^T$ is related to the strain vector by Hooke's Law, $\\boldsymbol{\\sigma} = \\mathbf{C} \\boldsymbol{\\epsilon}$, where $\\mathbf{C}$ is the constitutive matrix. For an isotropic material under plane stress, $\\mathbf{C}$ is:\n$$ \\mathbf{C} = \\frac{E}{1 - \\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} $$\nHere, $E$ is the Young's modulus and $\\nu$ is the Poisson's ratio.\n\nThe element stiffness matrix, $\\mathbf{k}^e$, is derived from the principle of virtual work, which leads to the integral:\n$$ \\mathbf{k}^e = \\int_{V_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, dV $$\nAssuming a uniform thickness $t$ and constant matrices $\\mathbf{B}$ and $\\mathbf{C}$, the integral simplifies to:\n$$ \\mathbf{k}^e = t \\cdot A_e \\cdot \\mathbf{B}^T \\mathbf{C} \\mathbf{B} $$\nThis yields a $6 \\times 6$ symmetric matrix for each element.\n\n**2. Consistent Nodal Loads**\n\nA uniform surface traction vector $\\mathbf{p} = \\{p_x, p_y\\}^T$ is applied to the edge $\\overline{1-2}$. The work-equivalent nodal forces are computed by integrating the traction multiplied by the shape functions over the loaded edge. For a straight edge of length $L$ between two nodes with linear shape functions, the total force $L \\cdot t \\cdot \\mathbf{p}$ is distributed equally to the two nodes. The force vector applied to node $m$ on the edge is:\n$$ \\mathbf{f}_m = \\frac{L \\cdot t}{2} \\mathbf{p} $$\nIn this problem, the load is on edge $\\overline{1-2}$, so nodes $1$ and $2$ each receive half of the total force.\n\n**3. Global System Assembly and Solution**\n\nThe domain consists of four nodes, so there are $4 \\times 2 = 8$ degrees of freedom (DOFs). The global stiffness matrix $\\mathbf{K}$ ($8 \\times 8$) and global force vector $\\mathbf{F}$ ($8 \\times 1$) are assembled by summing the contributions from each element. For each of the two triangles in a given triangulation, its element stiffness matrix $\\mathbf{k}^e$ is computed and its entries are added to the corresponding locations in $\\mathbf{K}$ based on the global node indices of the element.\n\nThe global system of equations is $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U}$ is the global vector of nodal displacements. Homogeneous Dirichlet boundary conditions are applied at nodes $0$ and $3$, meaning $u_{0x} = u_{0y} = u_{3x} = u_{3y} = 0$. These correspond to DOFs $0, 1, 6, 7$. These conditions are enforced by partitioning the system into free and fixed DOFs. The system is reduced to:\n$$ \\mathbf{K}_{ff} \\mathbf{U}_f = \\mathbf{F}_f $$\nwhere the subscript $f$ denotes the free DOFs, which are the $x$ and $y$ displacements at nodes $1$ and $2$ (DOFs $2, 3, 4, 5$). $\\mathbf{K}_{ff}$ is a $4 \\times 4$ submatrix of $\\mathbf{K}$. This reduced system is solved for the unknown displacements $\\mathbf{U}_f$. The full displacement vector $\\mathbf{U}$ is then constructed by combining $\\mathbf{U}_f$ with the zero displacements at the fixed nodes.\n\n**4. Triangulation and Comparison**\n\nThis procedure is performed for two separate triangulations of the quadrilateral domain with vertices $(0,1,2,3)$:\n- **Triangulation A:** The domain is divided by the diagonal $\\overline{0-2}$ into triangles $(0,1,2)$ and $(0,2,3)$.\n- **Triangulation B:** The domain is divided by the diagonal $\\overline{1-3}$ into triangles $(0,1,3)$ and $(1,2,3)$.\n\nThis yields two full displacement vectors, $\\mathbf{U}_A$ and $\\mathbf{U}_B$. The difference between the two solutions is quantified by the Euclidean norm of the difference vector:\n$$ \\text{Difference} = ||\\mathbf{U}_A - \\mathbf{U}_B||_2 = \\sqrt{\\sum_{i=0}^{7} (U_{A,i} - U_{B,i})^2} $$\nThis scalar value represents the aggregate difference in the computed displacement fields due to the choice of the internal diagonal, which is a fundamental aspect of mesh generation affecting solution quality. The entire process is repeated for each of the three test cases provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"coords\": np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 1.0], [0.2, 1.2]]),\n            \"material\": {\"E\": 7.0e10, \"nu\": 0.33, \"t\": 0.01},\n            \"traction\": {\"edge_nodes\": (1, 2), \"p\": np.array([1.0e6, 0.0])},\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"material\": {\"E\": 1.0e7, \"nu\": 0.25, \"t\": 0.05},\n            \"traction\": {\"edge_nodes\": (1, 2), \"p\": np.array([5.0e4, 0.0])},\n        },\n        {\n            \"coords\": np.array([[0.0, 0.0], [3.0, 0.0], [3.0, 0.1], [0.0, 0.2]]),\n            \"material\": {\"E\": 2.0e9, \"nu\": 0.49, \"t\": 0.01},\n            \"traction\": {\"edge_nodes\": (1, 2), \"p\": np.array([1.0e4, 0.0])},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        coords = case[\"coords\"]\n        \n        # Triangulation A: diagonal 0-2 -> triangles (0,1,2) and (0,2,3)\n        triangles_A = [np.array([0, 1, 2]), np.array([0, 2, 3])]\n        U_A = compute_displacements(coords, triangles_A, case[\"material\"], case[\"traction\"])\n\n        # Triangulation B: diagonal 1-3 -> triangles (0,1,3) and (1,2,3)\n        triangles_B = [np.array([0, 1, 3]), np.array([1, 2, 3])]\n        U_B = compute_displacements(coords, triangles_B, case[\"material\"], case[\"traction\"])\n\n        # Compute the Euclidean norm of the difference vector\n        norm_diff = np.linalg.norm(U_A - U_B)\n        results.append(norm_diff)\n\n    formatted_results = [f\"{res:.9g}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_displacements(coords, triangles, material, traction):\n    \"\"\"\n    Computes the nodal displacements for a given mesh, material, and loading.\n\n    Args:\n        coords (np.ndarray): Nodal coordinates, shape (num_nodes, 2).\n        triangles (list of np.ndarray): List of triangles, each defined by 3 node indices.\n        material (dict): Dictionary with keys 'E', 'nu', 't'.\n        traction (dict): Dictionary with keys 'edge_nodes', 'p'.\n\n    Returns:\n        np.ndarray: The global displacement vector of shape (num_nodes*2,).\n    \"\"\"\n    num_nodes = coords.shape[0]\n    num_dofs = num_nodes * 2\n    K_global = np.zeros((num_dofs, num_dofs))\n    F_global = np.zeros(num_dofs)\n\n    # Material properties\n    E, nu, t = material['E'], material['nu'], material['t']\n\n    # Constitutive matrix for plane stress\n    C = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n\n    # Assemble global stiffness matrix\n    for tri_nodes in triangles:\n        n1, n2, n3 = tri_nodes\n        c1, c2, c3 = coords[n1], coords[n2], coords[n3]\n        \n        # Calculate element area (ensuring counter-clockwise ordering)\n        area = 0.5 * np.linalg.det(np.array([[1, c1[0], c1[1]], [1, c2[0], c2[1]], [1, c3[0], c3[1]]]))\n        \n        # Strain-displacement matrix (B)\n        y23 = c2[1] - c3[1]\n        y31 = c3[1] - c1[1]\n        y12 = c1[1] - c2[1]\n        x32 = c3[0] - c2[0]\n        x13 = c1[0] - c3[0]\n        x21 = c2[0] - c1[0]\n\n        B = (1 / (2 * area)) * np.array([\n            [y23, 0,   y31, 0,   y12, 0  ],\n            [0,   x32, 0,   x13, 0,   x21],\n            [x32, y23, x13, y31, x21, y12]\n        ])\n\n        # Element stiffness matrix\n        k_elem = t * area * (B.T @ C @ B)\n\n        # Assemble into global matrix\n        dof_map = np.array([2*n1, 2*n1+1, 2*n2, 2*n2+1, 2*n3, 2*n3+1])\n        for i in range(6):\n            for j in range(6):\n                K_global[dof_map[i], dof_map[j]] += k_elem[i, j]\n\n    # Assemble global force vector from traction\n    node_a_idx, node_b_idx = traction['edge_nodes']\n    p_vec = traction['p']\n    \n    coord_a = coords[node_a_idx]\n    coord_b = coords[node_b_idx]\n    edge_length = np.linalg.norm(coord_b - coord_a)\n    \n    # Consistent nodal forces (split equally for linear edge)\n    force_on_node = (edge_length * t / 2) * p_vec\n    \n    F_global[2*node_a_idx : 2*node_a_idx+2] += force_on_node\n    F_global[2*node_b_idx : 2*node_b_idx+2] += force_on_node\n\n    # Apply boundary conditions (nodes 0 and 3 are fixed)\n    fixed_dofs = [0, 1, 6, 7]\n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n\n    # Solve the reduced system K_ff * U_f = F_f\n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    F_f = F_global[free_dofs]\n    \n    try:\n        U_f = np.linalg.solve(K_ff, F_f)\n    except np.linalg.LinAlgError:\n        print(\"Error: The stiffness matrix is singular.\")\n        return np.zeros(num_dofs)\n\n    # Reconstruct full displacement vector\n    U_global = np.zeros(num_dofs)\n    U_global[free_dofs] = U_f\n\n    return U_global\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2412649"}, {"introduction": "Having learned to measure mesh quality and appreciate its impact, the next logical step is to actively improve it. This advanced practice introduces a powerful, modern approach: variational mesh optimization. You will formulate mesh smoothing as an energy minimization problem, where the energy functional is based on an element quality metric [@problem_id:2604559]. The core of this exercise involves deriving the gradient of this energy with respect to nodal positions and implementing a gradient-based optimization step, providing hands-on experience with the algorithms that underpin state-of-the-art mesh generation software.", "problem": "You are given a two-dimensional triangular mesh with node coordinates and element connectivity. Define an energy functional based on a per-element mean-ratio quality metric for triangles and minimize it with respect to the free node coordinates using a gradient-based method with a line-search step. Your task is to derive the gradient of this energy with respect to node coordinates from first principles and implement a single line-search step that reduces the energy while holding boundary nodes fixed.\n\nFundamental base and core definitions:\n- A triangular mesh consists of nodes with positions $\\mathbf{p}_i \\in \\mathbb{R}^2$ and triangular elements with connectivity triplets $(i,j,k)$ indexing nodes.\n- For a single triangle with vertices $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$, define the oriented area\n$$\nA = \\frac{1}{2} \\left( (\\mathbf{p}_2 - \\mathbf{p}_1) \\times (\\mathbf{p}_3 - \\mathbf{p}_1) \\right),\n$$\nwhere the scalar cross product in two dimensions is defined by $\\mathbf{u} \\times \\mathbf{v} = u_x v_y - u_y v_x$.\n- Define edge vectors $\\mathbf{e}_1 = \\mathbf{p}_2 - \\mathbf{p}_3$, $\\mathbf{e}_2 = \\mathbf{p}_3 - \\mathbf{p}_1$, and $\\mathbf{e}_3 = \\mathbf{p}_1 - \\mathbf{p}_2$, and the sum of squared edge lengths\n$$\nS = \\lVert \\mathbf{e}_1 \\rVert^2 + \\lVert \\mathbf{e}_2 \\rVert^2 + \\lVert \\mathbf{e}_3 \\rVert^2.\n$$\n- The mean-ratio quality metric squared for a triangle is defined as $g = \\frac{48 A^2}{S^2}$, which satisfies $0 \\le g \\le 1$, with $g=1$ for an equilateral triangle. Based on this, define the per-element energy $\\phi = 1 - g = 1 - \\frac{48 A^2}{S^2}$.\n- The global energy functional for a mesh with $M$ triangles is $E(\\mathbf{P}) = \\sum_{e=1}^{M} \\phi_e$, where $\\mathbf{P}$ stacks all node coordinates.\n\nDerivation tasks:\n1. From the above definitions, derive the gradient of the per-element energy $\\phi$ with respect to the node coordinates $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$. Use only the definitions of area, edge lengths, and standard rules of differentiation as your starting point. In particular, use the facts that $A = \\tfrac{1}{2}(\\mathbf{p}_2 - \\mathbf{p}_1)^T \\mathbf{Z} (\\mathbf{p}_3 - \\mathbf{p}_1)$ with $\\mathbf{Z}=\\begin{bmatrix}0 & -1 \\\\ 1 & 0\\end{bmatrix}$, and that $\\nabla_{\\mathbf{x}} \\lVert \\mathbf{x} - \\mathbf{a} \\rVert^2 = 2(\\mathbf{x} - \\mathbf{a})$. Do not assume any shortcut formulas beyond these core definitions.\n2. Assemble the global gradient $\\nabla E(\\mathbf{P})$ by summing contributions from all elements. Treat some nodes as fixed (boundary nodes) and the others as free; the update is only applied to free nodes.\n3. Implement a single backtracking line-search step with the Armijo condition to select the step length $\\alpha$ along the steepest descent direction restricted to free nodes. Specifically, for a given initial step $\\alpha_0$, reduction factor $\\beta$ with $0<\\beta<1$, and Armijo parameter $c_1$ with $0<c_1<1$, choose the largest $\\alpha$ in the sequence $\\{\\alpha_0, \\beta \\alpha_0, \\beta^2 \\alpha_0, \\dots\\}$ such that\n$$\nE(\\mathbf{P} + \\alpha \\mathbf{d}) \\le E(\\mathbf{P}) + c_1 \\alpha \\nabla E(\\mathbf{P})^T \\mathbf{d},\n$$\nwhere $\\mathbf{d}$ is the search direction equal to the negative gradient on free nodes and zero on fixed nodes.\n\nNumerical tasks to implement:\n- Implement functions to compute per-element energy $\\phi$ and its gradient with respect to $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ using the derived expressions.\n- Implement functions to assemble global energy and gradient for an arbitrary mesh given node coordinates and triangular connectivity.\n- Implement a single Armijo backtracking line-search step to update free node coordinates.\n\nTest suite and required outputs:\nYour program must run the following four test cases and aggregate their results into a single line of output as a comma-separated list enclosed in square brackets:\n\n- Test case $1$ (analytic gradient verification on a single triangle): For the triangle with nodes $\\mathbf{p}_1=(0,0)$, $\\mathbf{p}_2=(1,0)$, $\\mathbf{p}_3=(0.1,0.9)$, compute the analytic gradient of $\\phi$ and compare to a finite-difference approximation with a symmetric difference step of $h=10^{-6}$ applied to each coordinate of the stacked vector $(x_1,y_1,x_2,y_2,x_3,y_3)$. Report as a single float the relative error defined by\n$$\n\\frac{\\lVert \\mathbf{g}_{\\text{analytic}} - \\mathbf{g}_{\\text{finite-diff}} \\rVert_2}{\\lVert \\mathbf{g}_{\\text{analytic}} \\rVert_2 + 10^{-12}}.\n$$\n\n- Test case $2$ (structured mesh energy decrease): Construct a structured mesh on the unit square $[0,1]\\times[0,1]$ with a $3\\times 3$ grid of nodes at integer multiples of $\\frac{1}{2}$, triangulated by splitting each square cell with the diagonal from its bottom-left to its top-right corner. Perturb the interior node at index corresponding to $(1,1)$ by adding $(0.2,-0.1)$ to its coordinates. Treat boundary nodes as fixed and the interior node(s) as free. Perform one Armijo backtracking line-search step with initial step $\\alpha_0 = 0.1$, reduction factor $\\beta=0.5$, and $c_1 = 10^{-4}$. Report a boolean indicating whether the total energy strictly decreases.\n\n- Test case $3$ (unstructured fan mesh energy decrease): Consider nodes $\\mathbf{p}_0=(0,0)$, $\\mathbf{p}_1=(1,0)$, $\\mathbf{p}_2=(0.2,1.1)$, $\\mathbf{p}_3=(-0.1,0.8)$, and an interior node $\\mathbf{p}_4=(0.5,0.5)$. Triangles are $(0,1,4)$, $(1,2,4)$, $(2,3,4)$, $(3,0,4)$. Treat $\\mathbf{p}_4$ as free and the others as fixed. Perform one Armijo backtracking line-search step with initial step $\\alpha_0 = 0.5$, $\\beta=0.5$, and $c_1=10^{-4}$. Report a boolean indicating whether the total energy strictly decreases.\n\n- Test case $4$ (near-optimal element stability): For the equilateral triangle with nodes $\\mathbf{p}_1=(0,0)$, $\\mathbf{p}_2=(1,0)$, $\\mathbf{p}_3=\\left(0.5,\\frac{\\sqrt{3}}{2}\\right)$, compute the total energy before and after one line-search step with initial step $\\alpha_0 = 0.2$, $\\beta=0.5$, and $c_1=10^{-4}$ when all nodes are treated as free. Report the absolute energy change as a float.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). The four results must be, respectively, a float for test case $1$, a boolean for test case $2$, a boolean for test case $3$, and a float for test case $4$. No physical units are involved in this problem, and all angles, if any, are irrelevant and not used.", "solution": "The primary task is to derive the gradient of the per-element energy functional $\\phi_e$ with respect to the coordinates of its vertices. The per-element energy for a triangle with vertices $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3 \\in \\mathbb{R}^2$ is given by\n$$\n\\phi = 1 - g = 1 - \\frac{48 A^2}{S^2}\n$$\nwhere $A$ is the triangle's oriented area and $S$ is the sum of its squared edge lengths. Our goal is to compute $\\nabla_{\\mathbf{p}_k} \\phi$ for $k \\in \\{1, 2, 3\\}$.\n\nUsing the chain rule, the gradient of $\\phi$ is:\n$$\n\\nabla_{\\mathbf{p}_k} \\phi = - \\nabla_{\\mathbf{p}_k} g = -48 \\, \\nabla_{\\mathbf{p}_k} \\left( \\frac{A^2}{S^2} \\right)\n$$\nApplying the quotient rule for vector differentiation, where $u = A^2$ and $v = S^2$:\n$$\n\\nabla_{\\mathbf{p}_k} \\left( \\frac{A^2}{S^2} \\right) = \\frac{(\\nabla_{\\mathbf{p}_k} A^2) S^2 - A^2 (\\nabla_{\\mathbf{p}_k} S^2)}{S^4}\n$$\nWe have $\\nabla_{\\mathbf{p}_k} A^2 = 2A \\nabla_{\\mathbf{p}_k} A$ and $\\nabla_{\\mathbf{p}_k} S^2 = 2S \\nabla_{\\mathbf{p}_k} S$. Substituting these gives:\n$$\n\\nabla_{\\mathbf{p}_k} \\left( \\frac{A^2}{S^2} \\right) = \\frac{(2A \\nabla_{\\mathbf{p}_k} A) S^2 - A^2 (2S \\nabla_{\\mathbf{p}_k} S)}{S^4} = \\frac{2AS(S \\nabla_{\\mathbf{p}_k} A - A \\nabla_{\\mathbf{p}_k} S)}{S^4} = 2A \\frac{S \\nabla_{\\mathbf{p}_k} A - A \\nabla_{\\mathbf{p}_k} S}{S^3}\n$$\nThus, the gradient of the energy functional $\\phi$ is:\n$$\n\\nabla_{\\mathbf{p}_k} \\phi = -96A \\frac{S (\\nabla_{\\mathbf{p}_k} A) - A (\\nabla_{\\mathbf{p}_k} S)}{S^3}\n$$\nTo complete the derivation, we must find the gradients of the area $A$ and the sum of squared edge lengths $S$.\n\nFirst, we derive the gradient of the area, $A$. The problem provides the expression $A = \\frac{1}{2}(\\mathbf{p}_2 - \\mathbf{p}_1)^T \\mathbf{Z} (\\mathbf{p}_3 - \\mathbf{p}_1)$, where $\\mathbf{Z} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$. Let us compute $\\nabla_{\\mathbf{p}_1} A$. Using the product rule for matrix calculus and the identity $\\mathbf{Z}^T = -\\mathbf{Z}$, the derivative of $f(\\mathbf{x}) = (\\mathbf{a}-\\mathbf{x})^T \\mathbf{M} (\\mathbf{b}-\\mathbf{x})$ with respect to $\\mathbf{x}$ is $\\nabla_{\\mathbf{x}} f = -(\\mathbf{M}(\\mathbf{b}-\\mathbf{x}) + \\mathbf{M}^T(\\mathbf{a}-\\mathbf{x}))$. For $A$, we have $\\mathbf{x}=\\mathbf{p}_1, \\mathbf{a}=\\mathbf{p}_2, \\mathbf{b}=\\mathbf{p}_3$, and $\\mathbf{M}=\\frac{1}{2}\\mathbf{Z}$.\n$$\n\\nabla_{\\mathbf{p}_1} A = -\\left( \\frac{1}{2}\\mathbf{Z}(\\mathbf{p}_3 - \\mathbf{p}_1) + \\frac{1}{2}\\mathbf{Z}^T(\\mathbf{p}_2 - \\mathbf{p}_1) \\right) = -\\frac{1}{2}\\left( \\mathbf{Z}(\\mathbf{p}_3 - \\mathbf{p}_1) - \\mathbf{Z}(\\mathbf{p}_2 - \\mathbf{p}_1) \\right) = -\\frac{1}{2}\\mathbf{Z}(\\mathbf{p}_3 - \\mathbf{p}_2) = \\frac{1}{2}\\mathbf{Z}(\\mathbf{p}_2 - \\mathbf{p}_3)\n$$\nBy cyclic permutation or similar derivations, we find the gradients for all three vertices. Using the edge vector definitions $\\mathbf{e}_1 = \\mathbf{p}_2 - \\mathbf{p}_3$, $\\mathbf{e}_2 = \\mathbf{p}_3 - \\mathbf{p}_1$, and $\\mathbf{e}_3 = \\mathbf{p}_1 - \\mathbf{p}_2$:\n$$\n\\nabla_{\\mathbf{p}_1} A = \\frac{1}{2}\\mathbf{Z}\\mathbf{e}_1 \\quad, \\quad \\nabla_{\\mathbf{p}_2} A = \\frac{1}{2}\\mathbf{Z}\\mathbf{e}_2 \\quad, \\quad \\nabla_{\\mathbf{p}_3} A = \\frac{1}{2}\\mathbf{Z}\\mathbf{e}_3\n$$\nSecond, we derive the gradient of $S = \\lVert \\mathbf{e}_1 \\rVert^2 + \\lVert \\mathbf{e}_2 \\rVert^2 + \\lVert \\mathbf{e}_3 \\rVert^2$.\n$$\nS = \\lVert \\mathbf{p}_2 - \\mathbf{p}_3 \\rVert^2 + \\lVert \\mathbf{p}_3 - \\mathbf{p}_1 \\rVert^2 + \\lVert \\mathbf{p}_1 - \\mathbf{p}_2 \\rVert^2\n$$\nUsing the identity $\\nabla_{\\mathbf{x}} \\lVert \\mathbf{x} - \\mathbf{a} \\rVert^2 = 2(\\mathbf{x} - \\mathbf{a})$, we compute the gradient of $S$ with respect to $\\mathbf{p}_1$:\n$$\n\\nabla_{\\mathbf{p}_1} S = \\nabla_{\\mathbf{p}_1} \\lVert \\mathbf{p}_2 - \\mathbf{p}_3 \\rVert^2 + \\nabla_{\\mathbf{p}_1} \\lVert \\mathbf{p}_3 - \\mathbf{p}_1 \\rVert^2 + \\nabla_{\\mathbf{p}_1} \\lVert \\mathbf{p}_1 - \\mathbf{p}_2 \\rVert^2\n$$\n$$\n\\nabla_{\\mathbf{p}_1} S = 0 + 2(\\mathbf{p}_1 - \\mathbf{p}_3) + 2(\\mathbf{p}_1 - \\mathbf{p}_2) = 4\\mathbf{p}_1 - 2\\mathbf{p}_2 - 2\\mathbf{p}_3\n$$\nBy cyclic permutation, the gradients with respect to all vertices are:\n$$\n\\nabla_{\\mathbf{p}_1} S = 4\\mathbf{p}_1 - 2\\mathbf{p}_2 - 2\\mathbf{p}_3 \\\\\n\\nabla_{\\mathbf{p}_2} S = 4\\mathbf{p}_2 - 2\\mathbf{p}_3 - 2\\mathbf{p}_1 \\\\\n\\nabla_{\\mathbf{p}_3} S = 4\\mathbf{p}_3 - 2\\mathbf{p}_1 - 2\\mathbf{p}_2\n$$\nSubstituting these expressions for $\\nabla_{\\mathbf{p}_k} A$ and $\\nabla_{\\mathbf{p}_k} S$ into the formula for $\\nabla_{\\mathbf{p}_k} \\phi$ yields the final analytical gradient expressions required for implementation. Let $\\mathbf{g}_{A,k} = \\nabla_{\\mathbf{p}_k} A$ and $\\mathbf{g}_{S,k} = \\nabla_{\\mathbf{p}_k} S$. The gradient of the energy for vertex $\\mathbf{p}_k$ is:\n$$\n\\nabla_{\\mathbf{p}_k} \\phi = -96 A \\frac{S \\, \\mathbf{g}_{A,k} - A \\, \\mathbf{g}_{S,k}}{S^3}\n$$\nThe global gradient $\\nabla E(\\mathbf{P})$ is assembled by summing the contributions of $\\nabla_{\\mathbf{p}_k} \\phi_e$ from each element $e$ to its corresponding global node $k$.\n\nFor the optimization step, a backtracking line search is used. The search direction $\\mathbf{d}$ is the negative of the global gradient, restricted to free nodes: $\\mathbf{d}_i = -\\nabla_{\\mathbf{p}_i} E$ if node $i$ is free, and $\\mathbf{d}_i = \\mathbf{0}$ if fixed. The Armijo condition is used to find a suitable step length $\\alpha$:\n$$\nE(\\mathbf{P} + \\alpha \\mathbf{d}) \\le E(\\mathbf{P}) + c_1 \\alpha \\nabla E(\\mathbf{P})^T \\mathbf{d}\n$$\nfor some constant $c_1 \\in (0,1)$. Starting with an initial $\\alpha_0$, $\\alpha$ is decreased by a factor $\\beta \\in (0,1)$ until this condition is met.", "answer": "```python\nimport numpy as np\n\ndef element_energy_and_grad(p1, p2, p3):\n    \"\"\"\n    Computes the energy and gradient for a single triangular element.\n\n    Args:\n        p1 (np.ndarray): Coordinates of vertex 1.\n        p2 (np.ndarray): Coordinates of vertex 2.\n        p3 (np.ndarray): Coordinates of vertex 3.\n\n    Returns:\n        tuple: A tuple containing the element energy (float) and a (3, 2) numpy\n               array of gradients with respect to each vertex.\n    \"\"\"\n    p = np.array([p1, p2, p3], dtype=float)\n    \n    # Edge vectors as defined in the problem: e_i is opposite p_i\n    e1_vec = p[1, :] - p[2, :]\n    e2_vec = p[2, :] - p[0, :]\n    e3_vec = p[0, :] - p[1, :]\n    \n    # Sum of squared edge lengths, S\n    S = np.sum(e1_vec**2) + np.sum(e2_vec**2) + np.sum(e3_vec**2)\n    \n    # Handle case of coincident points\n    if S < 1e-14:\n        return 1.0, np.zeros((3, 2))\n\n    # Oriented area, A\n    A = 0.5 * (p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n    \n    # Handle degenerate triangle (zero area)\n    if abs(A) < 1e-14:\n        # For A=0, g=0, phi=1. The gradient of g is zero, so grad of phi is also zero.\n        return 1.0, np.zeros((3, 2))\n\n    # Per-element energy, phi\n    g = 48.0 * A**2 / S**2\n    phi = 1.0 - g\n    \n    # Gradient of Area, grad(A) w.r.t. p1, p2, p3\n    Z = np.array([[0, -1], [1, 0]])\n    grad_A_p1 = 0.5 * (Z @ e1_vec)\n    grad_A_p2 = 0.5 * (Z @ e2_vec)\n    grad_A_p3 = 0.5 * (Z @ e3_vec)\n    \n    # Gradient of S, grad(S) w.r.t. p1, p2, p3\n    grad_S_p1 = 4*p[0] - 2*p[1] - 2*p[2]\n    grad_S_p2 = 4*p[1] - 2*p[0] - 2*p[2]\n    grad_S_p3 = 4*p[2] - 2*p[0] - 2*p[1]\n    \n    # Gradient of phi, grad(phi)\n    common_factor = -96.0 * A / S**3\n    \n    grad_phi_p1 = common_factor * (S * grad_A_p1 - A * grad_S_p1)\n    grad_phi_p2 = common_factor * (S * grad_A_p2 - A * grad_S_p2)\n    grad_phi_p3 = common_factor * (S * grad_A_p3 - A * grad_S_p3)\n    \n    grads = np.array([grad_phi_p1, grad_phi_p2, grad_phi_p3])\n    \n    return phi, grads\n\ndef global_energy(nodes, triangles):\n    \"\"\"Computes the total energy of the mesh.\"\"\"\n    total_energy = 0.0\n    for tri in triangles:\n        p1, p2, p3 = nodes[tri[0]], nodes[tri[1]], nodes[tri[2]]\n        phi, _ = element_energy_and_grad(p1, p2, p3)\n        total_energy += phi\n    return total_energy\n\ndef global_energy_and_grad(nodes, triangles):\n    \"\"\"Computes the total energy and its gradient for the mesh.\"\"\"\n    total_energy = 0.0\n    global_grad = np.zeros_like(nodes, dtype=float)\n    \n    for tri_indices in triangles:\n        idx1, idx2, idx3 = tri_indices\n        p1, p2, p3 = nodes[idx1], nodes[idx2], nodes[idx3]\n        \n        phi, element_grads = element_energy_and_grad(p1, p2, p3)\n        \n        total_energy += phi\n        global_grad[idx1] += element_grads[0]\n        global_grad[idx2] += element_grads[1]\n        global_grad[idx3] += element_grads[2]\n        \n    return total_energy, global_grad\n\ndef line_search_step(nodes, triangles, free_nodes_mask, alpha0, beta, c1):\n    \"\"\"Performs a single backtracking line search step.\"\"\"\n    E_initial, grad = global_energy_and_grad(nodes, triangles)\n    \n    d = -grad\n    d[~free_nodes_mask] = 0.0\n    \n    m = np.sum(grad * d)\n    \n    if abs(m) < 1e-14:\n        return nodes, False\n\n    alpha = alpha0\n    for _ in range(20):\n        nodes_new = nodes + alpha * d\n        E_new = global_energy(nodes_new, triangles)\n        \n        if E_new <= E_initial + c1 * alpha * m:\n            return nodes_new, bool(E_new < E_initial - 1e-12)\n            \n        alpha *= beta\n        \n    return nodes, False\n\ndef solve():\n    \"\"\"Runs all test cases and prints the results.\"\"\"\n\n    # Test Case 1: Analytic vs Finite Difference Gradient\n    p1 = np.array([0.0, 0.0]); p2 = np.array([1.0, 0.0]); p3 = np.array([0.1, 0.9])\n    _, g_analytic_parts = element_energy_and_grad(p1, p2, p3)\n    g_analytic = g_analytic_parts.flatten()\n    g_fd = np.zeros(6)\n    h = 1e-6\n    points = np.array([p1, p2, p3])\n    for i in range(3):\n        for j in range(2):\n            points_p = points.copy(); points_p[i, j] += h / 2\n            phi_p, _ = element_energy_and_grad(points_p[0], points_p[1], points_p[2])\n            points_m = points.copy(); points_m[i, j] -= h / 2\n            phi_m, _ = element_energy_and_grad(points_m[0], points_m[1], points_m[2])\n            g_fd[i*2 + j] = (phi_p - phi_m) / h\n    result1 = np.linalg.norm(g_analytic - g_fd) / (np.linalg.norm(g_analytic) + 1e-12)\n\n    # Test Case 2: Structured Mesh Energy Decrease\n    nodes_tc2 = np.array([[c/2.0, r/2.0] for r in range(3) for c in range(3)], dtype=float)\n    nodes_tc2[4] += np.array([0.2, -0.1])\n    triangles_tc2 = np.array([[0, 1, 4], [0, 4, 3], [1, 2, 5], [1, 5, 4],\n                              [3, 4, 7], [3, 7, 6], [4, 5, 8], [4, 8, 7]], dtype=int)\n    free_mask_tc2 = np.array([i == 4 for i in range(9)], dtype=bool)\n    _, result2 = line_search_step(\n        nodes_tc2, triangles_tc2, free_mask_tc2, alpha0=0.1, beta=0.5, c1=1e-4)\n\n    # Test Case 3: Unstructured Fan Mesh Energy Decrease\n    nodes_tc3 = np.array([[0.0, 0.0], [1.0, 0.0], [0.2, 1.1], [-0.1, 0.8], [0.5, 0.5]])\n    triangles_tc3 = np.array([[0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4]], dtype=int)\n    free_mask_tc3 = np.array([i == 4 for i in range(5)], dtype=bool)\n    _, result3 = line_search_step(\n        nodes_tc3, triangles_tc3, free_mask_tc3, alpha0=0.5, beta=0.5, c1=1e-4)\n\n    # Test Case 4: Near-Optimal Element Stability\n    nodes_tc4 = np.array([[0.0, 0.0], [1.0, 0.0], [0.5, np.sqrt(3)/2.0]])\n    triangles_tc4 = np.array([[0, 1, 2]], dtype=int)\n    free_mask_tc4 = np.ones(3, dtype=bool)\n    E_initial_tc4 = global_energy(nodes_tc4, triangles_tc4)\n    nodes_new_tc4, _ = line_search_step(\n        nodes_tc4, triangles_tc4, free_mask_tc4, alpha0=0.2, beta=0.5, c1=1e-4)\n    E_final_tc4 = global_energy(nodes_new_tc4, triangles_tc4)\n    result4 = abs(E_final_tc4 - E_initial_tc4)\n    \n    results = [result1, result2, result3, result4]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2604559"}]}