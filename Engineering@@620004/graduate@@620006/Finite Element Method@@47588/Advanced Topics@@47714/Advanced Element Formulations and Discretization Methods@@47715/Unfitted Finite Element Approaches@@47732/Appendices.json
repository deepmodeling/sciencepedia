{"hands_on_practices": [{"introduction": "The power of unfitted finite element methods lies in their ability to handle complex geometries without the need for mesh conformity. At the heart of this capability are robust geometric algorithms for processing elements cut by an interface. This first practice [@problem_id:2609382] guides you through the implementation of these foundational components, from clipping a background element to form a sub-polygon to constructing a suitable integration mesh and assembling local matrices, providing an essential toolkit for any unfitted method.", "problem": "Consider an unfitted finite element discretization of a scalar diffusion problem on a background two-dimensional simplicial mesh. Let the background cell be the fixed parent triangle $T$ with vertices $x_{0} = (0,0)$, $x_{1} = (1,0)$, and $x_{2} = (0,1)$. Define a level-set function $\\phi(x,y) = a\\,x + b\\,y + c$ and the physical subdomain $T^{-} = \\{(x,y) \\in T \\mid \\phi(x,y) \\le 0\\}$. This setting models a cut cell. On $T$, use the standard piecewise linear nodal basis (the unique affine shape functions) $\\{N_{i}\\}_{i=1}^{3}$ satisfying $N_{i}(x_{j-1}) = \\delta_{ij}$ for $i,j \\in \\{1,2,3\\}$.\n\nYour task is to implement, from first principles, the following components that are fundamental to unfitted finite element approaches:\n\n$1.$ Clipping: Compute the intersection polygon $P = T \\cap \\{(x,y)\\mid \\phi(x,y) \\le 0\\}$ by clipping the triangle $T$ with the half-plane defined by $\\phi(x,y) \\le 0$. Interpret points with $\\phi(x,y) \\le \\varepsilon$ as inside, where $\\varepsilon = 10^{-12}$ is a numerical tolerance. If the resulting set has zero area (for example, due to degeneracy when the half-plane intersects $T$ at a single point or a line segment), treat $P$ as empty with area $A = 0$ and centroid $(c_{x}, c_{y}) = (0,0)$.\n\n$2.$ Integration mesh: Construct a triangulation of $P$ by first computing a centroid of $P$ and then forming a fan triangulation connecting this centroid to each polygon edge to obtain an integration mesh $\\mathcal{T}_{\\mathrm{int}}(P)$ of non-overlapping triangles whose union is $P$. If $P$ has fewer than $3$ vertices or has area less than $\\varepsilon$, set $\\mathcal{T}_{\\mathrm{int}}(P)$ to be empty and its triangle count $n_{\\triangle} = 0$.\n\n$3.$ Local mass matrix on a cut cell: Define the local consistent mass matrix $M \\in \\mathbb{R}^{3\\times 3}$ on $T^{-}$ by\n$$\nM_{ij} = \\int_{T^{-}} N_{i}(x,y)\\,N_{j}(x,y)\\,\\mathrm{d}A,\\quad i,j \\in \\{1,2,3\\}.\n$$\nAssemble $M$ by exact polynomial integration on $\\mathcal{T}_{\\mathrm{int}}(P)$ using a quadrature rule that is exact for polynomials up to total degree $2$ on each triangle. Evaluate the basis functions $N_{i}$ pointwise in physical coordinates using their affine definition with respect to the parent triangle $T$. If $P$ is empty, set $M$ to the zero matrix. Report the Frobenius norm $\\lVert M \\rVert_{F} = \\sqrt{\\sum_{i=1}^{3}\\sum_{j=1}^{3} M_{ij}^{2}}$.\n\n$4.$ Geometric properties: Compute the area $A$ and centroid $(c_{x}, c_{y})$ of $P$. Use the standard polygon area and centroid formulas for non-self-intersecting polygons; if $P$ is empty, use $(A,c_{x},c_{y}) = (0,0,0)$.\n\nDesign and implement robust data structures that hold $P$ as an ordered list of its vertices and $\\mathcal{T}_{\\mathrm{int}}(P)$ as a list of triangles, where each triangle is represented by its three vertex coordinates in physical space. Your algorithm must correctly handle non-cut, fully cut-away, and degenerate boundary-aligned cases.\n\nTest Suite. For each parameter triple $(a,b,c)$ below, with the fixed parent triangle $T$ as specified above, compute:\n- the area $A$ of $P$,\n- the centroid coordinates $(c_{x}, c_{y})$ of $P$,\n- the number of triangles $n_{\\triangle}$ in the integration mesh $\\mathcal{T}_{\\mathrm{int}}(P)$, and\n- the Frobenius norm $\\lVert M \\rVert_{F}$ of the local mass matrix on $T^{-}$.\n\nUse the following $5$ test cases:\n- Case $1$: $(a,b,c) = (0,0,-1)$, a fully inside case.\n- Case $2$: $(a,b,c) = (0,0,1)$, a fully outside case.\n- Case $3$: $(a,b,c) = (1,0.3,-0.2)$, a typical cut case.\n- Case $4$: $(a,b,c) = (1,1,0)$, a vertex-touching degenerate case.\n- Case $5$: $(a,b,c) = (1,0,0)$, an edge-aligned degenerate case.\n\nFinal Output Format. Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with no spaces. For each case, output a list $[A,c_{x},c_{y},n_{\\triangle},\\lVert M\\rVert_{F}]$. The final output must therefore have the form\n$[[A_{1},c_{x,1},c_{y,1},n_{\\triangle,1},\\lVert M\\rVert_{F,1}],[A_{2},c_{x,2},c_{y,2},n_{\\triangle,2},\\lVert M\\rVert_{F,2}],\\dots,[A_{5},c_{x,5},c_{y,5},n_{\\triangle,5},\\lVert M\\rVert_{F,5}]]$.", "solution": "The problem statement is subjected to validation before any solution is attempted.\n\n### Step 1: Extract Givens\n\n-   **Domain**: A fixed parent triangle $T$ with vertices $x_{0} = (0,0)$, $x_{1} = (1,0)$, and $x_{2} = (0,1)$.\n-   **Level-Set Function**: $\\phi(x,y) = a\\,x + b\\,y + c$.\n-   **Physical Subdomain**: $T^{-} = \\{(x,y) \\in T \\mid \\phi(x,y) \\le 0\\}$.\n-   **Numerical Tolerance**: $\\varepsilon = 10^{-12}$. Points with $\\phi(x,y) \\le \\varepsilon$ are considered inside the physical subdomain.\n-   **Basis Functions**: Piecewise linear nodal basis functions $\\{N_{i}\\}_{i=1}^{3}$ defined on $T$ such that $N_{i}(x_{j-1}) = \\delta_{ij}$ for $i,j \\in \\{1,2,3\\}$.\n-   **Task 1 (Clipping)**: Compute the intersection polygon $P = T^{-}$. For degenerate cases with zero area, $P$ is treated as empty.\n-   **Task 2 (Integration Mesh)**: Triangulate $P$ into $\\mathcal{T}_{\\mathrm{int}}(P)$ using a fan triangulation from its centroid. If $P$ has fewer than $3$ vertices or its area is less than $\\varepsilon$, $\\mathcal{T}_{\\mathrm{int}}(P)$ is empty and its triangle count $n_{\\triangle} = 0$.\n-   **Task 3 (Mass Matrix)**: Compute the local mass matrix $M_{ij} = \\int_{T^{-}} N_{i}(x,y)\\,N_{j}(x,y)\\,\\mathrm{d}A$ using a quadrature rule exact for polynomials up to degree $2$. Report the Frobenius norm $\\lVert M \\rVert_{F}$. If $P$ is empty, $M$ is the zero matrix.\n-   **Task 4 (Geometric Properties)**: Compute the area $A$ and centroid $(c_{x}, c_{y})$ of $P$. If $P$ is empty, these are $(0,0,0)$.\n-   **Test Cases**: The parameters $(a,b,c)$ are given for $5$ specific cases: $(0,0,-1)$, $(0,0,1)$, $(1,0.3,-0.2)$, $(1,1,0)$, and $(1,0,0)$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the established validation criteria.\n\n-   **Scientifically Grounded**: The problem is rooted in the finite element method, specifically in the context of unfitted mesh techniques (e.g., XFEM, CutFEM). All components—level-set methods, polygon clipping, numerical quadrature, and basis functions—are standard and rigorous concepts in numerical analysis and computational geometry.\n-   **Well-Posed**: The problem is well-posed. The intersection of a convex polygon (the triangle $T$) with a half-plane is a well-defined convex polygon. The subsequent steps of computing geometric properties, creating a fan triangulation, and performing numerical integration are algorithmically specified. The instructions for handling degenerate cases are clear and remove ambiguity, ensuring a unique solution for each test case.\n-   **Objective**: The problem is stated using precise, objective mathematical language, free from any subjective or biased terminology.\n-   **Complete and Consistent**: The problem is self-contained. All necessary data, including the domain geometry, basis function definitions (implicitly, via their nodal property), level-set form, numerical tolerance, and algorithms for triangulation and integration, are provided. There are no contradictions in the setup.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It represents a standard, well-posed task in computational science that is free from scientific flaws, ambiguity, or missing information. A reasoned solution will be provided.\n\n### Solution Methodology\n\nThe solution requires the implementation of a computational pipeline to handle the geometry and integration on a cut-cell. The procedure is organized into four main stages, as specified in the problem.\n\n**Basis Functions**\nThe standard affine basis functions $\\{N_i\\}_{i=1}^3$ for the parent triangle $T$ with vertices $x_0=(0,0)$, $x_1=(1,0)$, and $x_2=(0,1)$ are determined by the nodal property $N_i(x_{j-1}) = \\delta_{ij}$ for $i,j \\in \\{1,2,3\\}$. This yields the following explicit expressions:\n-   $N_1(x,y) = 1 - x - y$ (associated with vertex $x_0=(0,0)$)\n-   $N_2(x,y) = x$ (associated with vertex $x_1=(1,0)$)\n-   $N_3(x,y) = y$ (associated with vertex $x_2=(0,1)$)\n\n**1. Clipping Algorithm**\nThe intersection polygon $P = T \\cap \\{(x,y) \\mid \\phi(x,y) \\le \\varepsilon\\}$ is computed by clipping the triangle $T$ against the half-plane defined by the level-set function. A variant of the Sutherland-Hodgman algorithm is employed. The three edges of $T$ are processed sequentially. For each edge connecting vertices $u$ and $v$:\n-   The level-set function $\\phi$ is evaluated at both endpoints, $\\phi_u$ and $\\phi_v$.\n-   If both endpoints are inside ($\\phi_u \\le \\varepsilon$ and $\\phi_v \\le \\varepsilon$), the second vertex $v$ is added to the output polygon's vertex list.\n-   If the edge crosses from inside to outside ($\\phi_u \\le \\varepsilon, \\phi_v > \\varepsilon$), the intersection point $I$ is computed and added to the list.\n-   If the edge crosses from outside to inside ($\\phi_u > \\varepsilon, \\phi_v \\le \\varepsilon$), the intersection point $I$ and the vertex $v$ are added to the list.\n-   If both endpoints are outside, no vertex is added.\n\nThe intersection point $I$ on the segment between $u$ and $v$ is parametrized as $I(t) = u + t(v-u)$. The parameter $t$ is found by solving $\\phi(I(t))=0$. Due to the linearity of $\\phi$, this gives $t = \\phi_u / (\\phi_u - \\phi_v)$. The resulting ordered list of vertices defines the polygon $P$. Redundant vertices arising in degenerate cases are removed.\n\n**2. Geometric Properties and Integration Mesh**\nFor a non-degenerate polygon $P$ with $n$ vertices $(x_0, y_0), \\dots, (x_{n-1}, y_{n-1})$ in order, the area $A$ and centroid $(c_x, c_y)$ are computed using the shoelace formula:\n$$ A = \\frac{1}{2} \\left| \\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n$$ c_x = \\frac{1}{6A} \\sum_{i=0}^{n-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n$$ c_y = \\frac{1}{6A} \\sum_{i=0}^{n-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\nwhere $(x_n, y_n) = (x_0, y_0)$.\n\nIf the polygon $P$ is not degenerate (i.e., has at least $3$ vertices and area $A \\ge \\varepsilon$), an integration mesh $\\mathcal{T}_{\\mathrm{int}}(P)$ is constructed. A fan triangulation is formed by creating triangles connecting the computed centroid $C = (c_x, c_y)$ to each edge of $P$. The number of triangles, $n_{\\triangle}$, is equal to the number of vertices of $P$.\n\n**3. Local Mass Matrix Assembly**\nThe local mass matrix $M \\in \\mathbb{R}^{3 \\times 3}$ is assembled by computing the integrals $M_{ij} = \\int_P N_i N_j dA$. The total integral is the sum of integrals over each triangle $T_k \\in \\mathcal{T}_{\\mathrm{int}}(P)$:\n$$ M_{ij} = \\sum_{T_k \\in \\mathcal{T}_{\\mathrm{int}}(P)} \\int_{T_k} N_i(x,y) N_j(x,y) \\,dA $$\nEach integral over a subtriangle $T_k$ is approximated using a numerical quadrature rule that is exact for polynomials of total degree $2$. The 3-point midpoint rule is used, which satisfies this requirement. For a triangle $T_k$ with area $A_k$ and edge midpoints $m_1, m_2, m_3$:\n$$ \\int_{T_k} f(x,y) \\,dA \\approx \\frac{A_k}{3} \\sum_{l=1}^3 f(m_l) $$\nThe integrand is $f(x,y) = N_i(x,y) N_j(x,y)$. The contribution from each quadrature point is accumulated into the corresponding entry $M_{ij}$. Finally, the Frobenius norm $\\lVert M \\rVert_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$ is calculated.\n\n**4. Degeneracy Handling**\nThe algorithm incorporates robust handling of degenerate cases as stipulated:\n- If the clipping process results in a polygon $P$ with fewer than $3$ unique vertices or an area $A < \\varepsilon$, the case is considered degenerate.\n- For such cases, the output values are set to $A=0$, $(c_x, c_y) = (0,0)$, $n_{\\triangle}=0$, and $M$ is the zero matrix, leading to $\\lVert M \\rVert_F = 0$. This correctly handles scenarios where the physical domain $T^-$ is empty, a single point, or a line segment.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        (0.0, 0.0, -1.0),  # Case 1: Fully inside\n        (0.0, 0.0, 1.0),   # Case 2: Fully outside\n        (1.0, 0.3, -0.2),  # Case 3: Typical cut\n        (1.0, 1.0, 0.0),   # Case 4: Vertex-touching degenerate\n        (1.0, 0.0, 0.0),   # Case 5: Edge-aligned degenerate\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n    \n    # Format the final output string exactly as required\n    formatted_sublists = []\n    for r in results:\n        str_items = [str(item) for item in r]\n        formatted_sublists.append(f\"[{','.join(str_items)}]\")\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output)\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case for the given level-set parameters.\n    \"\"\"\n    a, b, c = params\n    epsilon = 1e-12\n    T_verts = [np.array([0., 0.]), np.array([1., 0.]), np.array([0., 1.])]\n\n    # 1. Clipping\n    P_verts = clip_triangle(T_verts, a, b, c, epsilon)\n\n    # Handle case with fewer than 3 unique vertices\n    if len(P_verts) < 3:\n        return [0.0, 0.0, 0.0, 0, 0.0]\n\n    # 2. Geometric properties\n    area = polygon_area(P_verts)\n    \n    # Handle degenerate case (zero area)\n    if area < epsilon:\n        return [0.0, 0.0, 0.0, 0, 0.0]\n\n    centroid = polygon_centroid(P_verts, area)\n\n    # 3. Integration mesh\n    integration_triangles = fan_triangulate(P_verts, centroid)\n    n_triangles = len(integration_triangles)\n\n    # 4. Local mass matrix\n    mass_matrix = compute_mass_matrix(integration_triangles)\n    norm_M = np.linalg.norm(mass_matrix, 'fro')\n\n    return [area, centroid[0], centroid[1], n_triangles, norm_M]\n\ndef clip_triangle(T_verts, a, b, c, epsilon):\n    \"\"\"\n    Clips a triangle against the half-plane phi(x,y) <= epsilon using a\n    Sutherland-Hodgman-like algorithm.\n    \"\"\"\n    def phi(p):\n        return a * p[0] + b * p[1] + c\n\n    phi_vals = [phi(v) for v in T_verts]\n    \n    clipped_verts = []\n    \n    for i in range(3):\n        u = T_verts[i]\n        v = T_verts[(i + 1) % 3]\n        phi_u = phi_vals[i]\n        phi_v = phi_vals[(i + 1) % 3]\n\n        u_is_inside = phi_u <= epsilon\n        v_is_inside = phi_v <= epsilon\n\n        if u_is_inside and v_is_inside:\n            clipped_verts.append(v)\n        elif u_is_inside and not v_is_inside:\n            # edge from in to out, add intersection\n            t = phi_u / (phi_u - phi_v)\n            intersection = u + t * (v - u)\n            clipped_verts.append(intersection)\n        elif not u_is_inside and v_is_inside:\n            # edge from out to in, add intersection then v\n            t = phi_u / (phi_u - phi_v)\n            intersection = u + t * (v - u)\n            clipped_verts.append(intersection)\n            clipped_verts.append(v)\n        # if both outside, do nothing\n\n    # Remove duplicate vertices that can appear in degenerate cuts\n    if not clipped_verts:\n        return []\n\n    unique_verts = []\n    for v in clipped_verts:\n        is_duplicate = False\n        for uv in unique_verts:\n            if np.linalg.norm(v - uv) < epsilon:\n                is_duplicate = True\n                break\n        if not is_duplicate:\n            unique_verts.append(v)\n    \n    return unique_verts\n\ndef polygon_area(verts):\n    \"\"\"\n    Computes the area of a polygon using the shoelace formula.\n    \"\"\"\n    n = len(verts)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += verts[i][0] * verts[j][1]\n        area -= verts[j][0] * verts[i][1]\n    return abs(area) / 2.0\n\ndef polygon_centroid(verts, area):\n    \"\"\"\n    Computes the centroid of a polygon.\n    \"\"\"\n    n = len(verts)\n    cx, cy = 0.0, 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        common_factor = verts[i][0] * verts[j][1] - verts[j][0] * verts[i][1]\n        cx += (verts[i][0] + verts[j][0]) * common_factor\n        cy += (verts[i][1] + verts[j][1]) * common_factor\n    return np.array([cx, cy]) / (6.0 * area)\n\ndef fan_triangulate(P_verts, centroid):\n    \"\"\"\n    Creates a fan triangulation of a polygon from its centroid.\n    \"\"\"\n    n = len(P_verts)\n    triangles = []\n    for i in range(n):\n        v1 = P_verts[i]\n        v2 = P_verts[(i + 1) % n]\n        triangles.append([centroid, v1, v2])\n    return triangles\n\ndef compute_mass_matrix(triangles):\n    \"\"\"\n    Computes the local mass matrix by integrating over the provided triangulation.\n    \"\"\"\n    M = np.zeros((3, 3))\n    \n    # Nodal basis functions for the parent triangle T\n    N1 = lambda p: 1.0 - p[0] - p[1]\n    N2 = lambda p: p[0]\n    N3 = lambda p: p[1]\n    basis_funcs = [N1, N2, N3]\n\n    for tri_verts in triangles:\n        p1, p2, p3 = tri_verts[0], tri_verts[1], tri_verts[2]\n        \n        # Area of the integration subtriangle\n        area_k = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area_k < 1e-15:\n            continue\n            \n        # 3-point quadrature rule (midpoints of edges)\n        q1 = (p1 + p2) / 2.0\n        q2 = (p2 + p3) / 2.0\n        q3 = (p3 + p1) / 2.0\n        quad_points = [q1, q2, q3]\n        \n        # Quadrature weight\n        w = area_k / 3.0\n        \n        # Accumulate matrix contributions from each quadrature point\n        for qp in quad_points:\n            N_vals = np.array([f(qp) for f in basis_funcs])\n            M += w * np.outer(N_vals, N_vals)\n            \n    return M\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2609382"}, {"introduction": "With the geometric fundamentals in hand, we can now apply unfitted methods to solve physically meaningful problems, a key application of which is in multiphase systems where interfaces introduce special physics like surface tension. In this exercise [@problem_id:2609391], you will derive and implement a complete unfitted solver for a one-dimensional problem modeling the Laplace–Young law. This will teach you how to incorporate interface flux jumps directly into the variational formulation and how to rigorously verify your code against an analytical solution.", "problem": "Consider the one-dimensional model problem for a two-phase steady diffusion/pressure field with surface tension effects. Let the computational domain be the interval $\\Omega = (0,1)$, and let the fluid–fluid interface be the point $\\Gamma = \\{\\alpha\\}$ with $\\alpha \\in (0,1)$. The unknown field $u : \\Omega \\to \\mathbb{R}$ satisfies the following strong form: find $u$ such that\n- in each subdomain $\\Omega^{-} = (0,\\alpha)$ and $\\Omega^{+} = (\\alpha,1)$, the equation $- (k u')' = 0$ holds, where $k$ is piecewise constant with $k = k_0$ in $\\Omega^{-}$ and $k = k_1$ in $\\Omega^{+}$;\n- the solution is continuous across the interface, i.e., $[u]_{\\Gamma} = 0$;\n- the diffusive flux jump across the interface follows a Laplace–Young type relation $[k u']_{\\Gamma} = g$, where the scalar $g$ represents the product of surface tension $\\gamma$ and curvature $\\kappa$, i.e., $g = \\gamma \\kappa$;\n- homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$ are prescribed.\n\nHere $[\\,\\cdot\\,]_{\\Gamma}$ denotes the jump across the interface $\\Gamma$, defined as the trace from $\\Omega^{+}$ minus the trace from $\\Omega^{-}$. This setting is a one-dimensional analog of multiphase problems with surface tension in higher dimensions, where the jump condition is induced by the Laplace–Young law. The goal is to design and implement an unfitted finite element approximation that respects the interface location independently of the mesh.\n\nYou are to proceed from fundamental definitions to derive and implement a consistent unfitted finite element method:\n1. Begin from the weak (variational) formulation based on the standard Sobolev space $H_0^1(0,1)$: derive a bilinear form and a linear functional that enforce the piecewise diffusion and incorporate the flux jump at the interface as a distributional source term. Do not assume any pre-packaged unfitted scheme; derive the interface contribution from first principles (integration by parts on subdomains and the Laplace–Young jump).\n2. Use a uniform mesh of $N$ intervals on $\\Omega$ with nodes independent of the interface location $\\alpha$ (an unfitted mesh). Use continuous, piecewise linear basis functions. For elements fully in $\\Omega^{-}$ or $\\Omega^{+}$, use the corresponding constant diffusion coefficient. For the single cut element that contains $\\alpha$, integrate the bilinear form exactly by splitting the element at $\\alpha$. Incorporate the interface contribution in the linear functional explicitly as a point evaluation weighted by $g$.\n3. The exact solution is piecewise linear. Derive it from the strong form and interface/boundary conditions to enable quantitative error assessment.\n\nAlgorithmic task. Implement a complete program that:\n- Assembles the global stiffness matrix and load vector for the unfitted mesh using exact subelement integration in the cut element and includes the interface-induced point load.\n- Imposes the homogeneous Dirichlet boundary conditions.\n- Solves the resulting linear system for the nodal coefficients.\n- Computes both the $L^2$-norm error and the energy semi-norm error with piecewise exact integration, comparing the numerical solution to the exact solution you derived.\n\nPrecise mathematical requirements:\n- The weak form should read: find $u \\in H_0^1(0,1)$ such that\n$$\n\\int_{0}^{\\alpha} k_0\\, u'(x)\\, v'(x)\\, dx + \\int_{\\alpha}^{1} k_1\\, u'(x)\\, v'(x)\\, dx = g\\, v(\\alpha)\n\\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n- The exact solution has the form $u(x) = a_0 x + b_0$ on $(0,\\alpha)$ and $u(x) = a_1 x + b_1$ on $(\\alpha,1)$ with constants determined by the interface and boundary conditions.\n\nYour program must solve the problem for the following test suite of parameter tuples $(N,\\alpha,k_0,k_1,\\gamma,\\kappa)$:\n- Case $1$: $(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (8,\\, 0.3,\\, 1.0,\\, 3.0,\\, 2.5,\\, 1.2)$, so $g = \\gamma \\kappa = 3.0$.\n- Case $2$: $(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (10,\\, 0.000001,\\, 5.0,\\, 1.0,\\, 1.0,\\, 2.0)$, so $g = 2.0$.\n- Case $3$: $(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (5,\\, 0.5,\\, 1.0,\\, 1.0,\\, 1.0,\\, 1.0)$, so $g = 1.0$.\n- Case $4$: $(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (12,\\, 0.37,\\, 1.0,\\, 7.0,\\, 0.0,\\, 3.0)$, so $g = 0.0$.\n\nFor each case, your program must output a pair of floating-point numbers:\n- the $L^2$-norm of the error $\\|u - u_h\\|_{L^2(0,1)}$;\n- the energy semi-norm error $\\left(\\int_{0}^{\\alpha} k_0\\, |u' - u_h'|^2\\, dx + \\int_{\\alpha}^{1} k_1\\, |u' - u_h'|^2\\, dx \\right)^{1/2}$.\n\nFinal output format:\n- Print a single line that is a list of pairs, one pair per test case, using the format\n$$\n[[e_{L^2}^{(1)}, e_{E}^{(1)}],[e_{L^2}^{(2)}, e_{E}^{(2)}],[e_{L^2}^{(3)}, e_{E}^{(3)}],[e_{L^2}^{(4)}, e_{E}^{(4)}]]\n$$\nwhere each float is rounded to exactly $8$ decimal places.\n- No additional text should be printed.\n\nClarifications:\n- This problem focuses on unfitted finite element approaches where the mesh is independent of the interface. You should not remesh to conform to $\\Gamma$. While methods such as the Cut Finite Element Method (CutFEM) or the Extended Finite Element Method (XFEM) exist for higher-dimensional problems, the present one-dimensional setting admits an exact interface quadrature and a point-load representation of the surface-tension-induced flux jump $g$.", "solution": "The problem statement has been analyzed and is deemed valid. It is a well-posed, one-dimensional elliptic boundary value problem with discontinuous coefficients and an interface condition, which is a standard model in computational physics. It is scientifically grounded, self-contained, and contains no ambiguities or contradictions. We proceed with the solution.\n\nThe solution is developed in four parts: first, the derivation of the weak (variational) formulation from the strong form; second, the derivation of the analytical exact solution; third, the formulation of the unfitted finite element method; and fourth, the methodology for computing the error norms.\n\n**1. Weak Formulation**\n\nThe strong form of the problem is given by:\n$$\n- (k u')' = 0 \\quad \\text{in } \\Omega^{-} \\cup \\Omega^{+} = (0,\\alpha) \\cup (\\alpha,1)\n$$\nwith boundary conditions $u(0)=0$, $u(1)=0$, and interface conditions $[u]_{\\Gamma}=0$, $[k u']_{\\Gamma}=g$. The jump is defined as $[\\cdot]_{\\Gamma} = (\\cdot)|_{\\alpha^+} - (\\cdot)|_{\\alpha^-}$.\n\nTo derive the weak form, we multiply the equation by a test function $v \\in H_0^1(0,1)$ and integrate over the domain $\\Omega = (0,1)$. The integral is split at the interface $\\alpha$:\n$$\n- \\int_{0}^{\\alpha} (k_0 u')' v \\, dx - \\int_{\\alpha}^{1} (k_1 u')' v \\, dx = 0\n$$\nApplying integration by parts to each integral yields:\n$$\n\\int_{0}^{\\alpha} k_0 u' v' \\, dx - [ (k_0 u') v ]_{0}^{\\alpha} + \\int_{\\alpha}^{1} k_1 u' v' \\, dx - [ (k_1 u') v ]_{\\alpha}^{1} = 0\n$$\nSubstituting the limits of integration:\n$$\n\\left( \\int_{0}^{\\alpha} k_0 u' v' \\, dx - k_0 u'(\\alpha^-) v(\\alpha) + k_0 u'(0^+) v(0) \\right) + \\left( \\int_{\\alpha}^{1} k_1 u' v' \\, dx - k_1 u'(1^-) v(1) + k_1 u'(\\alpha^+) v(\\alpha) \\right) = 0\n$$\nSince $v \\in H_0^1(0,1)$, the boundary terms $v(0)$ and $v(1)$ are zero. The expression simplifies to:\n$$\n\\int_{0}^{\\alpha} k_0 u' v' \\, dx + \\int_{\\alpha}^{1} k_1 u' v' \\, dx + (k_1 u'(\\alpha^+) - k_0 u'(\\alpha^-)) v(\\alpha) = 0\n$$\nUsing the flux jump condition $[k u']_{\\Gamma} = k_1 u'(\\alpha^+) - k_0 u'(\\alpha^-) = g$, we obtain the final weak formulation: find $u \\in H_0^1(0,1)$ such that\n$$\n\\int_{0}^{\\alpha} k_0 u'(x) v'(x) \\, dx + \\int_{\\alpha}^{1} k_1 u'(x) v'(x) \\, dx = g v(\\alpha) \\quad \\forall v \\in H_0^1(0,1)\n$$\nThis defines the bilinear form $a(u,v) = \\int_0^1 k(x) u' v' dx$ and the linear functional $L(v) = g v(\\alpha)$.\n\n**2. Exact Solution**\n\nIn each subdomain, the equation $u''=0$ implies that the solution is piecewise linear.\nLet $u(x) = c_0 x + d_0$ for $x \\in (0,\\alpha)$ and $u(x) = c_1 x + d_1$ for $x \\in (\\alpha,1)$.\nApplying the four conditions:\n1.  $u(0) = 0 \\implies c_0(0) + d_0 = 0 \\implies d_0 = 0$.\n2.  $u(1) = 0 \\implies c_1(1) + d_1 = 0 \\implies d_1 = -c_1$.\n3.  $[u]_{\\Gamma} = 0 \\implies c_1 \\alpha + d_1 = c_0 \\alpha \\implies c_1 \\alpha - c_1 = c_0 \\alpha$.\n4.  $[k u']_{\\Gamma} = g \\implies k_1 c_1 - k_0 c_0 = g$.\n\nFrom condition 3, we have $c_0 = c_1 (\\alpha-1)/\\alpha$. Substituting this into condition 4 gives:\n$k_1 c_1 - k_0 c_1 \\frac{\\alpha-1}{\\alpha} = g \\implies c_1 \\left(k_1 - k_0 \\frac{\\alpha-1}{\\alpha}\\right) = g \\implies c_1 \\frac{k_1\\alpha - k_0\\alpha + k_0}{\\alpha} = g$.\nSolving for $c_1$ and $c_0$:\n$$\nc_1 = \\frac{g \\alpha}{(k_1 - k_0)\\alpha + k_0}, \\qquad c_0 = \\frac{g (\\alpha-1)}{(k_1 - k_0)\\alpha + k_0}\n$$\nThe exact solution is therefore:\n$$\nu(x) =\n\\begin{cases}\nc_0 x & \\text{if } 0 \\le x \\le \\alpha \\\\\nc_1 (x-1) & \\text{if } \\alpha < x \\le 1\n\\end{cases}\n$$\nThe denominator $(k_1-k_0)\\alpha+k_0 = k_1\\alpha+k_0(1-\\alpha)$ is a convex combination of positive diffusion coefficients and is thus strictly positive for $\\alpha \\in(0,1)$, ensuring the solution is well-defined.\n\n**3. Unfitted Finite Element Method**\n\nWe discretize the domain $\\Omega=(0,1)$ with a uniform mesh of $N$ elements and size $h=1/N$. The nodes are $x_i=ih$ for $i=0, \\dots, N$. We use standard continuous piecewise linear (P1) basis functions $\\phi_i(x)$ satisfying $\\phi_i(x_j)=\\delta_{ij}$. The approximate solution is $u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)$, where $U_j$ are the unknown nodal values at interior nodes, as $U_0=U_N=0$ from the Dirichlet conditions.\n\nThe discrete system is a linear system $A \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U} = (U_1, \\dots, U_{N-1})^T$, and for $i,j \\in \\{1,\\dots,N-1\\}$:\n$$\nA_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 k(x) \\phi_j'(x) \\phi_i'(x) \\, dx, \\quad F_i = L(\\phi_i) = g \\phi_i(\\alpha)\n$$\nThe matrix $A$ is tridiagonal. Its entries are computed from the derivatives $\\phi_i'(x) = 1/h$ on $(x_{i-1}, x_i)$ and $\\phi_i'(x) = -1/h$ on $(x_i, x_{i+1})$.\nThe diagonal and off-diagonal entries (for the matrix of size $N-1$) are, for $i=1, \\dots, N-1$:\n$$\nA_{i-1,i-1} = \\frac{1}{h^2} \\left( \\int_{x_{i-1}}^{x_i} k(x) dx + \\int_{x_i}^{x_{i+1}} k(x) dx \\right)\n$$\n$$\nA_{i-1,i} = A_{i,i-1} = -\\frac{1}{h^2} \\int_{x_i}^{x_{i+1}} k(x) dx \\quad (\\text{for } i<N-1)\n$$\nThe integrals depend on the position of $\\alpha$. Let $m=\\lfloor \\alpha/h \\rfloor$. For an element $(x_j, x_{j+1})$:\n- if $j \\ne m$, $\\int_{x_j}^{x_{j+1}} k(x) dx = k_{\\text{elem}} h$, where $k_{\\text{elem}}$ is $k_0$ if $x_{j+1} \\le \\alpha$ and $k_1$ if $x_j \\ge \\alpha$.\n- if $j = m$ (the cut element), $\\int_{x_m}^{x_{m+1}} k(x) dx = k_0(\\alpha - x_m) + k_1(x_{m+1} - \\alpha)$.\n\nThe load vector $\\mathbf{F}$ is assembled from $F_i = g \\phi_i(\\alpha)$. Since $\\phi_i(\\alpha)$ is non-zero only if $\\alpha \\in (x_{i-1}, x_{i+1})$, only nodes adjacent to the interface receive a load. For the cut element $(x_m, x_{m+1})$:\n$$\nF_{m-1} = g \\phi_m(\\alpha) = g \\frac{x_{m+1} - \\alpha}{h} \\quad (\\text{if } m > 0)\n$$\n$$\nF_{m} = g \\phi_{m+1}(\\alpha) = g \\frac{\\alpha - x_m}{h} \\quad (\\text{if } m+1 < N)\n$$\nThe linear system is then solved for the nodal values $\\mathbf{U}$.\n\n**4. Error Computation**\n\nThe error norms are computed by integrating the error functions exactly over each element. The error $e(x) = u(x) - u_h(x)$ is piecewise linear on sub-intervals defined by the mesh nodes and the interface point $\\alpha$.\nLet an integration interval be $[a,b]$.\nThe $L^2$-norm error is $\\|e\\|_{L^2(0,1)} = \\left( \\int_0^1 e(x)^2 dx \\right)^{1/2}$. On any sub-interval $[a,b]$ where $e(x)$ is linear, its integral is given by $\\int_a^b e(x)^2 dx = \\frac{b-a}{3}(e(a)^2 + e(a)e(b) + e(b)^2)$.\nThe energy semi-norm error is $\\|e\\|_E = \\left( \\int_0^1 k(x) (e'(x))^2 dx \\right)^{1/2}$. On a sub-interval $[a,b]$, $u'(x)$ is constant and $u_h'(x)$ is constant, so $e'(x)$ is constant. The integral is simply $k(x) (e')^2 (b-a)$.\n\nThe total error is found by summing the contributions from each sub-interval. The cut element $(x_m, x_{m+1})$ is split into $(x_m, \\alpha)$ and $(\\alpha, x_{m+1})$ for this purpose.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D two-phase diffusion problem with an interface flux jump\n    using an unfitted finite element method for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (8, 0.3, 1.0, 3.0, 2.5, 1.2),\n        (10, 0.000001, 5.0, 1.0, 1.0, 2.0),\n        (5, 0.5, 1.0, 1.0, 1.0, 1.0),\n        (12, 0.37, 1.0, 7.0, 0.0, 3.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, alpha, k0, k1, gamma, kappa = case\n        g = gamma * kappa\n\n        # 1. Analytically derive exact solution parameters\n        denom = (k1 - k0) * alpha + k0\n        c0 = g * (alpha - 1) / denom if denom != 0 else 0\n        c1 = g * alpha / denom if denom != 0 else 0\n\n        def u_exact(x):\n            if isinstance(x, (int, float)):\n                return c0 * x if x <= alpha else c1 * (x - 1)\n            else: # numpy array\n                res = np.zeros_like(x, dtype=float)\n                mask0 = x <= alpha\n                mask1 = ~mask0\n                res[mask0] = c0 * x[mask0]\n                res[mask1] = c1 * (x[mask1] - 1)\n                return res\n        \n        # 2. Set up mesh and system for internal nodes\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n        num_unknowns = N - 1\n        \n        # 3. Assemble Stiffness Matrix A\n        def get_k_integral(x_start, x_end):\n            if x_end <= alpha:\n                return k0 * (x_end - x_start)\n            elif x_start >= alpha:\n                return k1 * (x_end - x_start)\n            else:  # cut element\n                return k0 * (alpha - x_start) + k1 * (x_end - alpha)\n\n        diag = np.zeros(num_unknowns)\n        off_diag = np.zeros(num_unknowns-1)\n\n        for i in range(1, N):  # Loop over internal nodes 1 to N-1\n            idx = i - 1\n            integral_left = get_k_integral(nodes[i - 1], nodes[i])\n            integral_right = get_k_integral(nodes[i], nodes[i + 1])\n            diag[idx] = (integral_left + integral_right) / h**2\n            if i < N - 1:\n                off_diag[idx] = -integral_right / h**2\n        \n        # Banded matrix format for scipy solver: ab[0,:]=super-diag, ab[1,:]=main-diag, ab[2,:]=sub-diag\n        ab = np.zeros((3, num_unknowns))\n        ab[0, 1:] = off_diag\n        ab[1, :] = diag\n        ab[2, :-1] = off_diag\n\n        # 4. Assemble Load Vector F\n        F = np.zeros(num_unknowns)\n        m = int(np.floor(alpha / h))  # Index of the left node of the cut element\n        \n        # Contribution at node m (if internal)\n        if m > 0:\n            F[m - 1] += g * (nodes[m + 1] - alpha) / h\n            \n        # Contribution at node m+1 (if internal)\n        if m + 1 < N:\n            F[m] += g * (alpha - nodes[m]) / h\n\n        # 5. Solve linear system and construct full solution vector\n        U_internal = solve_banded((1, 1), ab, F)\n        \n        U_h = np.zeros(N + 1)\n        U_h[1:-1] = U_internal\n        \n        # 6. Compute error norms with exact piecewise integration\n        l2_err_sq = 0.0\n        energy_err_sq = 0.0\n\n        for i in range(N):  # Loop over elements\n            x_i, x_i1 = nodes[i], nodes[i + 1]\n            u_hi, u_hi1 = U_h[i], U_h[i + 1]\n            u_h_prime_val = (u_hi1 - u_hi) / h\n            \n            sub_intervals = []\n            if x_i1 <= alpha:\n                sub_intervals.append((x_i, x_i1, k0, c0))\n            elif x_i >= alpha:\n                sub_intervals.append((x_i, x_i1, k1, c1))\n            else:  # Cut element\n                sub_intervals.append((x_i, alpha, k0, c0))\n                sub_intervals.append((alpha, x_i1, k1, c1))\n\n            for a, b, k_val, c_val in sub_intervals:\n                # Energy semi-norm contribution\n                e_prime = c_val - u_h_prime_val\n                energy_err_sq += k_val * e_prime**2 * (b - a)\n\n                # L2-norm contribution\n                def u_h_local(x):\n                    return u_hi * (x_i1 - x) / h + u_hi1 * (x - x_i) / h\n                \n                e_a = u_exact(a) - u_h_local(a)\n                e_b = u_exact(b) - u_h_local(b)\n                \n                l2_err_sq += ((b - a) / 3.0) * (e_a**2 + e_a * e_b + e_b**2)\n\n        l2_error = np.sqrt(l2_err_sq)\n        energy_error = np.sqrt(energy_err_sq)\n\n        all_results.append(f\"[{l2_error:.8f},{energy_error:.8f}]\")\n    \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2609391"}, {"introduction": "A numerical solution is only useful if its accuracy can be trusted, making error analysis a cornerstone of computational science. This final practice [@problem_id:2609385] delves into a posteriori error estimation, a critical tool for assessing solution quality and driving adaptive mesh refinement in unfitted methods. By deriving a residual-based error indicator and investigating its behavior as the interface moves, you will gain crucial insight into the stability and robustness challenges that are unique to unfitted discretizations.", "problem": "Consider the one-dimensional stationary diffusion model with a material interface, posed on the open interval $\\Omega=(0,1)$. Let the diffusion coefficient be piecewise constant with a jump across the interface point $\\Gamma=\\{x=s\\}$ where $s\\in(0,1)$, given by $\\alpha(x)=\\alpha^{-}$ for $x<s$ and $\\alpha(x)=\\alpha^{+}$ for $x>s$, with $\\alpha^{-}>0$ and $\\alpha^{+}>0$. The strong form reads $-(\\alpha u')'=f$ in $\\Omega\\setminus\\Gamma$, together with continuity of $u$ and flux continuity $\\llbracket \\alpha u' \\rrbracket_{\\Gamma}=0$ at the interface $\\Gamma$, and homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$. An unfitted finite element approach (for example, a Nitsche-type method on a background mesh independent of $\\Gamma$) imposes the interface conditions weakly by adding consistent and stabilizing terms that penalize the displacement jump and control the flux jump across $\\Gamma$, using a symmetric penalty with a stabilization parameter that scales with the diffusion coefficient. \n\nDefine a uniform mesh of $N$ elements on $\\Omega$, with nodes $x_i=i/N$ for $i=0,1,\\dots,N$, and element size $h=1/N$. Let $u_h$ be the continuous, piecewise affine nodal interpolant of the function $g(x)=\\sin(\\pi x)$ on this mesh, so that $u_h(0)=u_h(1)=0$. Let the right-hand side be $f(x)\\equiv 1$. For a fixed interface location $s\\in(0,1)$ that does not coincide with a mesh node, consider the following conceptual components of a residual-based a posteriori error indicator designed for an unfitted, Nitsche-stabilized discretization in one space dimension:\n- An element-wise bulk residual that measures the $L^2$-magnitude of the strong residual over each element, scaled by an appropriate power of the local mesh size.\n- Interior node contributions that measure flux jumps $\\llbracket \\alpha u_h' \\rrbracket$ across mesh nodes (treated as interior faces in one dimension), scaled by an appropriate power of the local mesh size.\n- Interface contributions at the cut location $x=s$ that combine a penalty on the displacement jump and a penalty on the flux jump, scaled in a way that mirrors the symmetric Nitsche imposition of interface conditions, with a stabilization parameter $\\beta>0$ chosen proportionally to the maximal diffusion to achieve robustness with respect to diffusion contrast and interface position.\n\nStarting from the weak formulation with Nitsche-type interface terms and the definition of the residual distribution for continuous, piecewise affine functions, derive a fully discrete expression for the global indicator $\\eta(s)$ in one dimension that only depends on the mesh, the piecewise constant coefficients $\\alpha^{-}$ and $\\alpha^{+}$, the stabilization parameter $\\beta$, the right-hand side $f$, and the piecewise constant element derivatives of $u_h$. Your derivation must use only fundamental definitions of residual-based indicators and the symmetric penalty scaling consistent with weak imposition of interface conditions, without relying on undocumented shortcuts.\n\nThen, implement a program that evaluates the robustness of this indicator under small perturbations of the interface location. Specifically, let $N=8$, $h=1/N$, $u_h$ be the nodal interpolant of $g(x)=\\sin(\\pi x)$, and $f(x)\\equiv 1$. For each test case below, you are given values $\\alpha^{-}$, $\\alpha^{+}$, a stabilization parameter $\\beta$, a baseline interface location $s_0$, and three perturbations collected in the set $\\Delta=\\{\\delta_1,\\delta_2,\\delta_3\\}$. For each $\\delta\\in\\Delta$, set $s=s_0+\\delta$ and compute the global indicator $\\eta(s)$ using your derived expression. Define the robustness ratios $\\rho(\\delta)=\\eta(s_0+\\delta)/\\eta(s_0)$. For each test case, also compute a boolean flag that is true if and only if all ratios lie in a prescribed bound interval $[L,U]$ (inclusive).\n\nTest suite:\n- Case A (happy path within one cut element): $N=8$, $(\\alpha^{-},\\alpha^{+})=(5,1)$, $\\beta=5$, $s_0=0.31$, $\\Delta=\\{-0.02,0.00,0.02\\}$, bounds $[L,U]=[0.95,1.05]$.\n- Case B (high-contrast robustness with stabilization scaled to the maximal diffusion): $N=8$, $(\\alpha^{-},\\alpha^{+})=(1000,0.1)$, $\\beta=1000$, $s_0=0.43$, $\\Delta=\\{-0.02,0.00,0.02\\}$, bounds $[L,U]=[0.95,1.05]$.\n- Case C (perturbation that crosses a mesh node, changing the cut element): $N=8$, $(\\alpha^{-},\\alpha^{+})=(2,7)$, $\\beta=7$, $s_0=0.44$, $\\Delta=\\{-0.02,0.00,0.08\\}$, bounds $[L,U]=[0.5,1.5]$.\n- Case D (interface near the boundary, remaining within the first element under perturbation): $N=8$, $(\\alpha^{-},\\alpha^{+})=(3,1)$, $\\beta=3$, $s_0=0.06$, $\\Delta=\\{-0.02,0.00,0.02\\}$, bounds $[L,U]=[0.95,1.05]$.\n\nYour program must construct $u_h$ from $g(x)=\\sin(\\pi x)$ on the uniform mesh, treat $f(x)\\equiv 1$ as a constant, and for each case compute the list $[\\rho(\\delta_1),\\rho(\\delta_2),\\rho(\\delta_3),\\text{flag}]$. The final output must be a single line containing a list with one entry per test case, where each entry is the list described above. For example, the output format must be a single line like $[[r_{A,1},r_{A,2},r_{A,3},b_A],[r_{B,1},r_{B,2},r_{B,3},b_B],[r_{C,1},r_{C,2},r_{C,3},b_C],[r_{D,1},r_{D,2},r_{D,3},b_D]]$ where each $r_{\\cdot,\\cdot}$ is a floating-point number and each $b_{\\cdot}$ is a boolean. No physical units are involved in this problem. All angles, if any appear, must be measured in radians, but none are required here. Round floating-point values to a reasonable number of decimal places for display if desired; maintain internal precision to avoid spurious rounding effects. Your program must not read any input and must not write any auxiliary text besides the single required output line.", "solution": "The problem requires the derivation and implementation of a residual-based a posteriori error indicator $\\eta(s)$ for a one-dimensional diffusion problem with a material interface. The derivation will be based on the conceptual components specified.\n\nThe problem is posed on the domain $\\Omega=(0,1)$ with a uniform mesh of $N$ elements, size $h=1/N$, and nodes $x_i=i/N$ for $i=0, \\dots, N$. The approximate solution $u_h$ is the continuous, piecewise affine nodal interpolant of $g(x)=\\sin(\\pi x)$. The strong form is $-(\\alpha u')'=f$ on $\\Omega \\setminus \\Gamma$, where $\\Gamma=\\{s\\}$ is the interface location. The diffusion coefficient is $\\alpha(x)=\\alpha^{-}$ for $x<s$ and $\\alpha(x)=\\alpha^{+}$ for $x>s$. The right-hand side is $f(x) \\equiv 1$.\n\nThe global error indicator $\\eta(s)$ is constructed as the sum of local contributions. The squared indicator is the sum of squared local indicators:\n$$ \\eta(s)^2 = \\eta_R^2 + \\eta_F^2 + \\eta_I^2 $$\nThese terms correspond to the element (bulk) residuals, the interior face (node) residuals, and the specific interface residual, respectively. We derive each component.\n\n**1. Element Bulk Residual Contribution ($\\eta_R^2$)**\n\nThe element bulk residual for an element $T$ is based on the strong residual $R_T(x) = -(\\alpha(x) u_h'(x))' - f(x)$. The function $u_h$ is piecewise affine, so its derivative $u_h'$ is piecewise constant. Let $u_h'(x) = u'_{h,i}$ for $x \\in T_i = (x_{i-1}, x_i)$.\nFor any element $T_i$ that is not cut by the interface $s$, the coefficient $\\alpha(x)$ is constant. Thus, $(\\alpha(x) u_h'(x))' = (\\text{const} \\cdot \\text{const})' = 0$. The residual is $R_{T_i}(x) = -f(x) = -1$.\nFor the single element $T_k$ cut by the interface, $\\alpha(x)$ has a jump. The derivative $(\\alpha u_h')'$ is a Dirac distribution centered at $s$, which is formally $u'_{h,k} (\\alpha^+ - \\alpha^-) \\delta(x-s)$. In residual-based indicators for unfitted methods, this distributional part is naturally incorporated into the interface jump term. The bulk residual within the element parts $(x_{k-1},s)$ and $(s,x_k)$ is still just $-f(x)=-1$.\nTherefore, for all elements $T_i$, the $L^2$ integrand for the bulk residual is simply $f(x)^2 = 1^2 = 1$.\nA standard residual indicator scales the squared $L^2$ norm of the bulk residual by the square of the element size $h$. The contribution from an element $T_i$ is:\n$$ \\eta_{R,i}^2 = h^2 \\int_{T_i} f(x)^2 \\, dx = h^2 \\int_{x_{i-1}}^{x_i} 1 \\, dx = h^2 \\cdot h = h^3 $$\nSumming over all $N$ elements of the mesh gives the total bulk contribution:\n$$ \\eta_R^2 = \\sum_{i=1}^{N} \\eta_{R,i}^2 = \\sum_{i=1}^{N} h^3 = N h^3 = (1/h) h^3 = h^2 $$\n\n**2. Interior Node Residual Contribution ($\\eta_F^2$)**\n\nThis term penalizes the jumps in the flux $\\alpha u_h'$ across interior mesh nodes $x_j$ for $j=1, \\dots, N-1$. The jump at a node $x_j$ is defined as $\\llbracket \\alpha u_h' \\rrbracket_{x_j} = (\\alpha u_h')(x_j^+) - (\\alpha u_h')(x_j^-)$.\nAt a node $x_j$, which by hypothesis does not coincide with $s$, the coefficient $\\alpha$ is continuous, i.e., $\\alpha(x_j^+) = \\alpha(x_j^-) = \\alpha(x_j)$. The derivative $u_h'$ is constant on adjacent elements, taking values $u'_{h,j}$ on $T_j=(x_{j-1},x_j)$ and $u'_{h,j+1}$ on $T_{j+1}=(x_j,x_{j+1})$.\nThe flux jump is therefore:\n$$ \\llbracket \\alpha u_h' \\rrbracket_{x_j} = \\alpha(x_j) u'_{h,j+1} - \\alpha(x_j) u'_{h,j} = \\alpha(x_j) (u'_{h,j+1} - u'_{h,j}) $$\nThe value of $\\alpha(x_j)$ depends on whether $x_j < s$ (giving $\\alpha^-$) or $x_j > s$ (giving $\\alpha^+$).\nThe squared indicator for a face (a node in 1D) is scaled by the face measure, which is taken to be the element size $h$. The total contribution from all interior nodes is:\n$$ \\eta_F^2 = \\sum_{j=1}^{N-1} h \\left( \\llbracket \\alpha u_h' \\rrbracket_{x_j} \\right)^2 = \\sum_{j=1}^{N-1} h \\left( \\alpha(x_j) (u'_{h,j+1} - u'_{h,j}) \\right)^2 $$\n\n**3. Interface Residual Contribution ($\\eta_I^2$)**\n\nThis term arises from the weak imposition of interface conditions in a Nitsche-type method. It penalizes the non-satisfaction of the continuity of displacement, $[u]_s = 0$, and continuity of flux, $\\llbracket \\alpha u' \\rrbracket_s = 0$. The symmetric Nitsche formulation suggests a composite penalty term. A standard form for the corresponding indicator contribution is:\n$$ \\eta_{I,s}^2 = \\frac{\\beta}{h} [u_h]_s^2 + \\frac{h}{\\beta} \\llbracket \\alpha u_h' \\rrbracket_s^2 $$\nwhere $\\beta$ is a positive stabilization parameter, and $h$ is the size of the element containing the interface.\nThe problem specifies that $u_h$ is a continuous, piecewise affine function. By this construction, the displacement jump at any point $s$ is identically zero:\n$$ [u_h]_s = u_h(s^+) - u_h(s^-) = 0 $$\nTherefore, the first term in $\\eta_{I,s}^2$ vanishes.\nThe second term involves the flux jump at the physical interface $s$. Let $T_k=(x_{k-1}, x_k)$ be the element containing $s$. The derivative $u_h'$ is constant on this element, $u_h'(x) = u'_{h,k}$ for $x \\in T_k$. The coefficient $\\alpha$ jumps from $\\alpha^-$ to $\\alpha^+$ at $s$. The flux jump is:\n$$ \\llbracket \\alpha u_h' \\rrbracket_s = (\\alpha u_h')(s^+) - (\\alpha u_h')(s^-) = \\alpha^+ u'_{h,k} - \\alpha^- u'_{h,k} = u'_{h,k} (\\alpha^+ - \\alpha^-) $$\nThe interface contribution to the indicator thus simplifies to:\n$$ \\eta_{I,s}^2 = \\frac{h}{\\beta} \\left( u'_{h,k} (\\alpha^+ - \\alpha^-) \\right)^2 $$\n\n**4. Final Expression for the Global Indicator**\n\nCombining the three components gives the final expression for the squared global indicator $\\eta(s)^2$:\n$$ \\eta(s)^2 = N h^3 + \\sum_{j=1}^{N-1} h \\left( \\alpha(x_j) (u'_{h,j+1} - u'_{h,j}) \\right)^2 + \\frac{h}{\\beta} \\left( u'_{h,k} (\\alpha^+ - \\alpha^-) \\right)^2 $$\nTo implement this formula, we need the following discrete quantities:\n- Mesh parameters: $N$ and $h = 1/N$.\n- Derivatives of $u_h$: On each element $T_i=(x_{i-1}, x_i)$, the derivative is constant and given by\n  $$ u'_{h,i} = \\frac{u_h(x_i) - u_h(x_{i-1})}{h} = \\frac{\\sin(\\pi i/N) - \\sin(\\pi(i-1)/N)}{h} $$\n  for $i=1, \\dots, N$.\n- Coefficient values at nodes: For a given interface location $s$, $\\alpha(x_j) = \\alpha^-$ if $j/N < s$, and $\\alpha(x_j) = \\alpha^+$ if $j/N > s$.\n- Cut element index: For a given $s$, the index $k$ of the cut element $T_k$ is found such that $x_{k-1} < s < x_k$. For a uniform mesh, this is $k = \\lfloor s/h \\rfloor + 1 = \\lfloor sN \\rfloor + 1$. The derivative required is $u'_{h,k}$.\n\nThe implementation will evaluate this expression for the parameters specified in each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and implementing an a posteriori error indicator for an \n    unfitted finite element method, and testing its robustness.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path\n        {'N': 8, 'alpha_m': 5, 'alpha_p': 1, 'beta': 5, 's0': 0.31, \n         'Delta': [-0.02, 0.00, 0.02], 'bounds': [0.95, 1.05]},\n        # Case B: High-contrast\n        {'N': 8, 'alpha_m': 1000, 'alpha_p': 0.1, 'beta': 1000, 's0': 0.43, \n         'Delta': [-0.02, 0.00, 0.02], 'bounds': [0.95, 1.05]},\n        # Case C: Node crossing\n        {'N': 8, 'alpha_m': 2, 'alpha_p': 7, 'beta': 7, 's0': 0.44, \n         'Delta': [-0.02, 0.00, 0.08], 'bounds': [0.5, 1.5]},\n        # Case D: Interface near boundary\n        {'N': 8, 'alpha_m': 3, 'alpha_p': 1, 'beta': 3, 's0': 0.06, \n         'Delta': [-0.02, 0.00, 0.02], 'bounds': [0.95, 1.05]},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case['N']\n        alpha_m = case['alpha_m']\n        alpha_p = case['alpha_p']\n        beta = case['beta']\n        s0 = case['s0']\n        Delta = case['Delta']\n        L, U = case['bounds']\n\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        # Pre-compute derivatives u_h' on each element\n        u_h_nodes = np.sin(np.pi * nodes)\n        u_h_prime = (u_h_nodes[1:] - u_h_nodes[:-1]) / h\n\n        def compute_eta_squared(s):\n            # 1. Bulk residual contribution\n            eta_R_sq = N * h**3\n\n            # 2. Interior node residual contribution\n            eta_F_sq = 0.0\n            for j in range(1, N):\n                node_j = nodes[j]\n                alpha_at_node = alpha_m if node_j < s else alpha_p\n                # Derivatives are on T_j and T_{j+1}, corresponding to indices j-1 and j\n                u_h_prime_jump = u_h_prime[j] - u_h_prime[j-1]\n                flux_jump_sq = (alpha_at_node * u_h_prime_jump)**2\n                eta_F_sq += h * flux_jump_sq\n\n            # 3. Interface residual contribution\n            # Cut element index k (1-based) is floor(s/h) + 1\n            # 0-based index for u_h_prime is k-1 = floor(s/h)\n            k_idx = int(s // h)\n            # Ensure index is within bounds [0, N-1]\n            k_idx = min(max(k_idx, 0), N - 1)\n            \n            u_h_prime_k = u_h_prime[k_idx]\n            flux_jump_s_sq = (u_h_prime_k * (alpha_p - alpha_m))**2\n            eta_I_sq = (h / beta) * flux_jump_s_sq\n            \n            return eta_R_sq + eta_F_sq + eta_I_sq\n\n        eta_s0 = np.sqrt(compute_eta_squared(s0))\n        \n        ratios = []\n        is_robust = True\n        for delta in Delta:\n            s_perturbed = s0 + delta\n            # Ensure s is within (0,1) but not exactly on a node for validity\n            # (though the formula works, this reflects problem constraints).\n            # Small epsilon shift if s lands on a node.\n            if any(np.isclose(s_perturbed, nodes[1:-1])):\n                s_perturbed += 1e-9\n\n            eta_s = np.sqrt(compute_eta_squared(s_perturbed))\n            \n            ratio = eta_s / eta_s0 if eta_s0 != 0 else 0\n            ratios.append(ratio)\n            \n            if not (L <= ratio <= U):\n                is_robust = False\n        \n        case_result = ratios + [is_robust]\n        all_results.append(case_result)\n        \n    # Format floating-point numbers for consistent output\n    formatted_results = []\n    for res_list in all_results:\n        float_vals = res_list[:-1]\n        bool_val = res_list[-1]\n        formatted_floats = [f\"{v:.8f}\" for v in float_vals]\n        formatted_results.append(f\"[{','.join(formatted_floats)},{str(bool_val)}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2609385"}]}