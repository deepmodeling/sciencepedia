{"hands_on_practices": [{"introduction": "Before using a finite element for analysis, we must first understand its fundamental approximation capabilities. This exercise challenges you to verify a crucial property of the hierarchical quadratic element: its ability to exactly represent linear displacement fields, a concept known as linear completeness. You will then go further by quantifying the element's performance for a non-linear field, providing a concrete measure of its approximation error [@problem_id:2538578].", "problem": "Consider a single one-dimensional bar finite element of length $L$, occupying the interval $x \\in [0,L]$. Let the reference coordinate be $\\xi \\in [-1,1]$ with the affine map $x(\\xi) = \\frac{L}{2}(1+\\xi)$. A hierarchical quadratic approximation space is defined by the three shape functions\n$$\nN_{1}(\\xi) = \\frac{1-\\xi}{2}, \n\\quad\nN_{2}(\\xi) = \\frac{1+\\xi}{2}, \n\\quad\nN_{3}(\\xi) = 1 - \\xi^{2},\n$$\nwhere $N_{1}$ and $N_{2}$ span the linear subspace and $N_{3}$ is a quadratic bubble that vanishes at the element endpoints. The interpolation operator acts on a sufficiently smooth scalar field $u(x)$ via\n$$\nI_{h}u(x) \\;=\\; u(0)\\,N_{1}(\\xi(x)) \\;+\\; u(L)\\,N_{2}(\\xi(x)) \\;+\\; \\Big(u\\!\\left(\\tfrac{L}{2}\\right) - \\tfrac{u(0)+u(L)}{2}\\Big)\\,N_{3}(\\xi(x)),\n$$\nso that the approximation matches $u$ at $x=0$, $x=L/2$, and $x=L$.\n\nTasks:\n1) Using only the properties of the shape functions and the definition of the interpolation operator $I_{h}$, show that any affine function $u(x) = a + b x$ with constants $a$ and $b$ is reproduced exactly by this hierarchical quadratic set, i.e., $I_{h}u(x) \\equiv u(x)$ on $[0,L]$.\n\n2) For the cubic function $u(x) = x^{3}$, derive the pointwise interpolation error\n$$\ne(x) \\;=\\; u(x) - I_{h}u(x)\n$$\non $[0,L]$, and then quantify the error by computing the squared $L^{2}$ norm\n$$\n\\|e\\|_{L^{2}(0,L)}^{2} \\;=\\; \\int_{0}^{L} \\big(e(x)\\big)^{2}\\,dx\n$$\nas a closed-form analytic expression in terms of $L$ only.\n\nProvide your final answer as the exact analytic expression for $\\|e\\|_{L^{2}(0,L)}^{2}$ in terms of $L$. No rounding is required.", "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information for a unique solution. It is a standard exercise in the finite element method concerning interpolation theory and error analysis. Therefore, a solution will be provided.\n\nThe problem is divided into two parts. The first part is to demonstrate that the given hierarchical quadratic interpolation operator exactly reproduces any affine function. The second part is to compute the squared $L^2$ norm of the interpolation error for the cubic function $u(x) = x^3$.\n\nPart 1: Exactness for affine functions.\nLet the affine function be $u(x) = a + bx$ for some constants $a, b \\in \\mathbb{R}$. We must show that its interpolant $I_h u(x)$ is identical to $u(x)$ for all $x \\in [0,L]$.\n\nThe interpolation operator is defined as:\n$$\nI_{h}u(x) = u(0)N_{1}(\\xi(x)) + u(L)N_{2}(\\xi(x)) + \\left(u\\left(\\frac{L}{2}\\right) - \\frac{u(0)+u(L)}{2}\\right)N_{3}(\\xi(x))\n$$\nFirst, we evaluate the function $u(x)$ at the interpolation points $x=0$, $x=L/2$, and $x=L$:\n$$u(0) = a + b(0) = a$$\n$$u(L) = a + bL$$\n$$u\\left(\\frac{L}{2}\\right) = a + b\\frac{L}{2}$$\n\nNext, we compute the coefficient of the hierarchical bubble function $N_3(\\xi)$. This coefficient is given by $c_3 = u(\\frac{L}{2}) - \\frac{u(0)+u(L)}{2}$.\nSubstituting the values from above:\n$$\nc_3 = \\left(a + \\frac{bL}{2}\\right) - \\frac{a + (a+bL)}{2} = \\left(a + \\frac{bL}{2}\\right) - \\frac{2a+bL}{2} = \\left(a + \\frac{bL}{2}\\right) - \\left(a + \\frac{bL}{2}\\right) = 0\n$$\nSince the coefficient of $N_3(\\xi)$ is zero for any affine function, the interpolation operator simplifies to:\n$$\nI_h u(x) = u(0) N_1(\\xi(x)) + u(L) N_2(\\xi(x))\n$$\nSubstituting the expressions for $u(0)$, $u(L)$, $N_1(\\xi)$, and $N_2(\\xi)$:\n$$\nI_h u(x) = a \\left(\\frac{1-\\xi}{2}\\right) + (a+bL) \\left(\\frac{1+\\xi}{2}\\right)\n$$\nWe expand and simplify this expression:\n$$\nI_h u(x) = \\frac{a - a\\xi + a + a\\xi + bL + bL\\xi}{2} = \\frac{2a + bL + bL\\xi}{2} = a + \\frac{bL}{2}(1+\\xi)\n$$\nNow, we use the given affine mapping $x(\\xi) = \\frac{L}{2}(1+\\xi)$. Substituting this into our expression for $I_h u(x)$:\n$$\nI_h u(x) = a + b \\left(\\frac{L}{2}(1+\\xi)\\right) = a + bx\n$$\nSince $u(x) = a + bx$, we have demonstrated that $I_h u(x) = u(x)$ for any affine function. The interpolation scheme is exact for polynomials of degree at most $1$.\n\nPart 2: Error analysis for a cubic function.\nLet the function be $u(x) = x^3$. We need to find the interpolation error $e(x) = u(x) - I_h u(x)$ and compute its squared $L^2$ norm, $\\|e\\|_{L^2(0,L)}^2$.\n\nFirst, we evaluate $u(x)=x^3$ at the interpolation points:\n$$u(0) = 0^3 = 0$$\n$$u(L) = L^3$$\n$$u\\left(\\frac{L}{2}\\right) = \\left(\\frac{L}{2}\\right)^3 = \\frac{L^3}{8}$$\n\nNext, we compute the coefficients for the interpolation operator $I_h u(x)$:\nThe coefficient for $N_1(\\xi)$ is $u(0) = 0$.\nThe coefficient for $N_2(\\xi)$ is $u(L) = L^3$.\nThe coefficient for $N_3(\\xi)$ is $c_3 = u(\\frac{L}{2}) - \\frac{u(0)+u(L)}{2}$:\n$$\nc_3 = \\frac{L^3}{8} - \\frac{0 + L^3}{2} = \\frac{L^3}{8} - \\frac{4L^3}{8} = -\\frac{3L^3}{8}\n$$\nThe interpolated function is therefore:\n$$\nI_h u(x) = (0)N_1(\\xi) + (L^3)N_2(\\xi) + \\left(-\\frac{3L^3}{8}\\right)N_3(\\xi) = L^3\\left(\\frac{1+\\xi}{2}\\right) - \\frac{3L^3}{8}\\left(1-\\xi^2\\right)\n$$\nTo find the error, it is most convenient to express $u(x)$ in terms of the reference coordinate $\\xi$. Using the map $x(\\xi) = \\frac{L}{2}(1+\\xi)$:\n$$\nu(x) = x^3 = \\left( \\frac{L}{2}(1+\\xi) \\right)^3 = \\frac{L^3}{8}(1+\\xi)^3\n$$\nThe error function $e(x)$ can be written as a function of $\\xi$:\n$$\ne(\\xi) = u(\\xi) - I_h u(\\xi) = \\frac{L^3}{8}(1+\\xi)^3 - \\left[ L^3\\left(\\frac{1+\\xi}{2}\\right) - \\frac{3L^3}{8}\\left(1-\\xi^2\\right) \\right]\n$$\nFactoring out $\\frac{L^3}{8}$:\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1+\\xi)^3 - 4(1+\\xi) + 3(1-\\xi^2) \\right]\n$$\nExpanding the terms inside the brackets:\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1+3\\xi+3\\xi^2+\\xi^3) - (4+4\\xi) + (3-3\\xi^2) \\right]\n$$\nCombining like powers of $\\xi$:\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1-4+3) + (3-4)\\xi + (3-3)\\xi^2 + \\xi^3 \\right] = \\frac{L^3}{8} (\\xi^3 - \\xi)\n$$\nNow we compute the squared $L^2$ norm, $\\|e\\|_{L^2(0,L)}^2 = \\int_0^L (e(x))^2 dx$. We transform the integral to the reference domain $\\xi \\in [-1,1]$. The differential element transforms as $dx = \\frac{dx}{d\\xi}d\\xi = \\frac{L}{2}d\\xi$.\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\int_{-1}^{1} (e(\\xi))^2 \\frac{L}{2} d\\xi = \\int_{-1}^{1} \\left( \\frac{L^3}{8}(\\xi^3-\\xi) \\right)^2 \\frac{L}{2} d\\xi\n$$\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\left(\\frac{L^3}{8}\\right)^2 \\frac{L}{2} \\int_{-1}^{1} (\\xi^3-\\xi)^2 d\\xi = \\frac{L^6}{64} \\frac{L}{2} \\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = \\frac{L^7}{128} \\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi\n$$\nThe integrand is an even function, so the integral is twice the integral from $0$ to $1$:\n$$\n\\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = 2 \\int_{0}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = 2 \\left[ \\frac{\\xi^7}{7} - \\frac{2\\xi^5}{5} + \\frac{\\xi^3}{3} \\right]_0^1\n$$\n$$\n= 2 \\left( \\frac{1}{7} - \\frac{2}{5} + \\frac{1}{3} \\right) = 2 \\left( \\frac{15 - 42 + 35}{105} \\right) = 2 \\left( \\frac{8}{105} \\right) = \\frac{16}{105}\n$$\nFinally, we substitute this result back into the expression for the norm:\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\frac{L^7}{128} \\cdot \\frac{16}{105} = \\frac{L^7}{8 \\cdot 105} = \\frac{L^7}{840}\n$$\nThe squared $L^2$ norm of the interpolation error is $\\frac{L^7}{840}$.", "answer": "$$\n\\boxed{\\frac{L^{7}}{840}}\n$$", "id": "2538578"}, {"introduction": "The accuracy of a finite element solution depends critically on the precise computation of element matrices, which are defined by integrals. This practice focuses on the element stiffness matrix, guiding you to determine the minimum numerical quadrature order required for its exact integration [@problem_id:2538587]. Mastering this analysis is essential for creating finite element codes that are both computationally efficient and numerically exact.", "problem": "Consider a one-dimensional bar finite element with quadratic hierarchical shape functions defined on the reference interval $\\left[-1,1\\right]$. Let the hierarchical basis be chosen as the two linear end functions and a single interior enrichment (bubble) function,\n$$\nN_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2},\\quad \\xi\\in\\left[-1,1\\right].\n$$\nAssume constant Young’s modulus $E$, constant cross-sectional area $A$, and a linear isoparametric geometry mapping from the reference coordinate $\\xi$ to the physical coordinate $x$, so that the Jacobian $J=\\frac{dx}{d\\xi}$ is constant over the element. The element stiffness matrix entries are defined by\n$$\nk_{ij}=\\int_{\\Omega_{e}} B_{i}(x)\\,E\\,A\\,B_{j}(x)\\,dx,\\quad B_{i}(x)=\\frac{dN_{i}}{dx},\\quad i,j\\in\\{1,2,3\\}.\n$$\nUsing these definitions as the only starting point, and without assuming any specific numerical quadrature formula a priori, determine the smallest integer number of Gauss–Legendre quadrature points $n$ on $\\left[-1,1\\right]$ required so that all stiffness entries $k_{ij}$ for this element are integrated exactly under the stated assumptions. Provide the final answer as a single integer with no units.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and self-contained. It is a standard problem in the finite element method. The validation is successful.\n\nThe objective is to determine the smallest integer number of Gauss-Legendre quadrature points, denoted by $n$, required for the exact integration of all stiffness matrix entries $k_{ij}$. A Gauss-Legendre quadrature scheme with $n$ points on the reference interval $\\left[-1,1\\right]$ can exactly integrate any polynomial of a degree $p$ up to $p = 2n-1$. Therefore, the problem reduces to finding the maximum polynomial degree of the integrand function used to compute the stiffness entries.\n\nThe stiffness matrix entry $k_{ij}$ is defined by the integral over the physical element domain $\\Omega_{e}$:\n$$\nk_{ij}=\\int_{\\Omega_{e}} B_{i}(x)\\,E\\,A\\,B_{j}(x)\\,dx\n$$\nHere, $E$ is the Young’s modulus and $A$ is the cross-sectional area, both assumed to be constant. The strain-displacement matrix component $B_{i}(x)$ is the derivative of the shape function $N_{i}$ with respect to the physical coordinate $x$:\n$$\nB_{i}(x) = \\frac{dN_{i}}{dx}\n$$\nTo evaluate the integral, we must transform it from the physical coordinate $x$ to the reference coordinate $\\xi \\in \\left[-1,1\\right]$. The problem states a linear isoparametric mapping is used, which means the Jacobian of the transformation, $J = \\frac{dx}{d\\xi}$, is constant. The differential length element transforms as $dx = J\\,d\\xi$.\n\nUsing the chain rule, the derivative with respect to $x$ is related to the derivative with respect to $\\xi$ as:\n$$\n\\frac{dN_{i}}{dx} = \\frac{dN_{i}}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J}\\frac{dN_{i}}{d\\xi}\n$$\nSubstituting these expressions into the integral for $k_{ij}$:\n$$\nk_{ij} = \\int_{-1}^{1} \\left(\\frac{1}{J}\\frac{dN_{i}}{d\\xi}\\right) E A \\left(\\frac{1}{J}\\frac{dN_{j}}{d\\xi}\\right) (J\\,d\\xi)\n$$\nSince $E$, $A$, and $J$ are constants, we can simplify this expression:\n$$\nk_{ij} = \\frac{EA}{J} \\int_{-1}^{1} \\left(\\frac{dN_{i}}{d\\xi}\\right) \\left(\\frac{dN_{j}}{d\\xi}\\right) d\\xi\n$$\nThe constant pre-factor $\\frac{EA}{J}$ does not influence the polynomial degree of the function being integrated. The integrand is $I_{ij}(\\xi) = \\left(\\frac{dN_{i}}{d\\xi}\\right) \\left(\\frac{dN_{j}}{d\\xi}\\right)$. We must find the maximum polynomial degree of $I_{ij}(\\xi)$ for all $i,j \\in \\{1, 2, 3\\}$.\n\nFirst, we compute the derivatives of the given hierarchical shape functions with respect to $\\xi$:\n$$\nN_{1}(\\xi)=\\frac{1-\\xi}{2} \\implies \\frac{dN_{1}}{d\\xi} = -\\frac{1}{2}\n$$\n$$\nN_{2}(\\xi)=\\frac{1+\\xi}{2} \\implies \\frac{dN_{2}}{d\\xi} = \\frac{1}{2}\n$$\n$$\nN_{3}(\\xi)=1-\\xi^{2} \\implies \\frac{dN_{3}}{d\\xi} = -2\\xi\n$$\nThese derivatives are polynomials of degree $0$, $0$, and $1$, respectively. Let $P[f(\\xi)]$ denote the polynomial degree of a function $f(\\xi)$.\n\nNow, we determine the degree of the integrand $I_{ij}(\\xi)$ for all unique pairs $(i,j)$:\n- For $(i,j) = (1,1)$: $I_{11}(\\xi) = (-\\frac{1}{2})(-\\frac{1}{2}) = \\frac{1}{4}$. The degree is $P[I_{11}] = 0$.\n- For $(i,j) = (1,2)$: $I_{12}(\\xi) = (-\\frac{1}{2})(\\frac{1}{2}) = -\\frac{1}{4}$. The degree is $P[I_{12}] = 0$.\n- For $(i,j) = (1,3)$: $I_{13}(\\xi) = (-\\frac{1}{2})(-2\\xi) = \\xi$. The degree is $P[I_{13}] = 1$.\n- For $(i,j) = (2,2)$: $I_{22}(\\xi) = (\\frac{1}{2})(\\frac{1}{2}) = \\frac{1}{4}$. The degree is $P[I_{22}] = 0$.\n- For $(i,j) = (2,3)$: $I_{23}(\\xi) = (\\frac{1}{2})(-2\\xi) = -\\xi$. The degree is $P[I_{23}] = 1$.\n- For $(i,j) = (3,3)$: $I_{33}(\\xi) = (-2\\xi)(-2\\xi) = 4\\xi^{2}$. The degree is $P[I_{33}] = 2$.\n\nThe maximum polynomial degree, $p_{\\text{max}}$, found among all integrands $I_{ij}(\\xi)$ is $2$, which occurs for the $k_{33}$ term.\n\nTo integrate a polynomial of degree $p_{\\text{max}}$ exactly, the number of Gauss-Legendre quadrature points $n$ must satisfy the condition:\n$$\n2n - 1 \\ge p_{\\text{max}}\n$$\nSubstituting $p_{\\text{max}} = 2$:\n$$\n2n - 1 \\ge 2\n$$\nSolving for $n$:\n$$\n2n \\ge 3\n$$\n$$\nn \\ge 1.5\n$$\nSince the number of quadrature points $n$ must be an integer, the smallest integer value that satisfies this inequality is $n=2$. Thus, $2$ Gauss-Legendre quadrature points are required to integrate all entries of the stiffness matrix exactly.", "answer": "$$\\boxed{2}$$", "id": "2538587"}, {"introduction": "One of the primary benefits of hierarchical shape functions is that they facilitate advanced solution techniques like static condensation. This hands-on programming exercise tasks you with implementing and verifying this method, where internal \"bubble\" degrees of freedom are eliminated at the element level [@problem_id:2538553]. Completing this practice will demonstrate how a thoughtful choice of basis functions yields a smaller, more efficient global system without compromising the accuracy of the nodal solution.", "problem": "Implement a one-dimensional finite element solver for an axially loaded bar using a quadratic hierarchical element on each mesh interval. Each element has two end-node degrees of freedom and one internal hierarchical bubble degree of freedom with a shape function that vanishes at the element ends. Starting from the principle of virtual work, the definitions of shape functions on the parent domain, and linear elasticity for small strains, construct the element stiffness matrix and the consistent element load vector. Then assemble the global system in two ways: (i) a full system that includes all end-node and internal bubble unknowns, and (ii) a statically condensed system where the internal bubble unknowns are eliminated at the element level by exact Schur complement elimination. Solve both global systems under the same boundary conditions and loading, and verify that the end-node displacements and end-node nodal force residuals match to within a specified tolerance for a suite of test cases.\n\nFundamental base:\n- The principle of virtual work states that, for an elastic bar in axial deformation, the discrete equilibrium is obtained by requiring that the internal virtual work equals the external virtual work for all virtual displacements, which yields the linear system $$\\mathbf{K}\\,\\mathbf{u}=\\mathbf{F},$$ where $$\\mathbf{K}$$ is the global stiffness matrix assembled from element contributions, $$\\mathbf{u}$$ is the global displacement vector, and $$\\mathbf{F}$$ is the global load vector assembled from body forces and tractions.\n- On a parent coordinate $$\\xi\\in[-1,1]$$ mapped affinely to a physical element of length $$L$$ with Jacobian $$J=L/2,$$ use the hierarchical shape functions\n  $$N_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2},$$\n  where $$N_{3}(\\pm 1)=0$$ so that the associated degree of freedom is internal to the element. The axial strain is $$\\varepsilon=\\mathrm{d}u/\\mathrm{d}x,$$ with $$u(x)=\\sum_{a=1}^{3}N_{a}(\\xi(x))\\,d_{a}.$$\n- The element stiffness and consistent load follow from\n  $$\\mathbf{K}^{e}=\\int_{-1}^{1}\\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\!T} E A \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) J\\,\\mathrm{d}\\xi,\\qquad \\mathbf{f}^{e}=\\int_{-1}^{1}\\mathbf{N}^{T} b\\, J\\,\\mathrm{d}\\xi,$$\n  where $$E$$ is Young’s modulus, $$A$$ is cross-sectional area, and $$b$$ is the body force density per unit length. End tractions are included as nodal forces at boundary nodes upon global assembly.\n- Static condensation eliminates the internal bubble degree of freedom of each element exactly by applying the Schur complement of the element-level partition corresponding to primary (end-node) and internal (bubble) unknowns, producing a condensed element contribution to the global nodal system without loss of accuracy in the nodal solution.\n\nYour program must:\n- Derive and implement the element matrices using the above hierarchical shape functions and an exact numerical quadrature for the resulting polynomials on $$\\xi\\in[-1,1].$$\n- Assemble and solve both the full global system (including internal bubble unknowns) and the condensed global system (with bubbles eliminated elementwise) for each test case.\n- Enforce essential boundary conditions by directly prescribing displacement values at specified nodes.\n- Compute nodal force residuals $$\\mathbf{r}=\\mathbf{K}\\mathbf{u}-\\mathbf{F}$$ on the global system for both formulations. For constrained nodes, these residuals coincide with reactions; for free nodes, they should be numerically zero at equilibrium.\n- Verify, for each test case, that the end-node displacements and the end-node nodal residuals at the two domain ends are identical between the full and condensed systems within a relative tolerance of $$10^{-9}$$ and an absolute tolerance of $$10^{-12}.$$\n\nPhysical and numerical units:\n- All inputs are in the International System of Units (SI): length in meters ($$m$$), Young’s modulus in Pascals ($$Pa$$), area in square meters ($$m^{2}$$), body force density in Newtons per meter ($$N/m$$), nodal loads in Newtons ($$N$$), and displacements in meters ($$m$$).\n- The final output consists solely of boolean values, so no unit is required for the output.\n\nTest suite:\nFor each case, the bar is partitioned into $$n_{e}$$ elements with given element lengths, material properties, and distributed body forces. Nodal loads act on global nodes and essential boundary conditions specify nodal displacements. Use the data below.\n\n- Case $$1$$ (happy path, mixed loading, right end free):\n  - Element count $$n_{e}=3.$$\n  - Element lengths $$\\{0.4,\\,0.3,\\,0.3\\}~m.$$\n  - Young’s modulus per element $$\\{2.10\\times 10^{11},\\,2.10\\times 10^{11},\\,2.10\\times 10^{11}\\}~Pa.$$\n  - Areas $$\\{5.0\\times 10^{-4},\\,5.0\\times 10^{-4},\\,5.0\\times 10^{-4}\\}~m^{2}.$$\n  - Body forces $$\\{1.0\\times 10^{3},\\,1.0\\times 10^{3},\\,1.0\\times 10^{3}\\}~N/m.$$\n  - Nodal point loads on the $$4$$ global nodes: $$\\{0,\\,0,\\,0,\\,1.0\\times 10^{5}\\}~N.$$\n  - Essential boundary conditions: left end displacement $$u(0)=0~m.$$\n\n- Case $$2$$ (boundary case, both ends fixed, negative body force):\n  - Element count $$n_{e}=1.$$\n  - Element lengths $$\\{2.0\\}~m.$$\n  - Young’s modulus $$\\{7.0\\times 10^{10}\\}~Pa.$$\n  - Areas $$\\{1.0\\times 10^{-3}\\}~m^{2}.$$\n  - Body forces $$\\{-5.0\\times 10^{2}\\}~N/m.$$\n  - Nodal point loads on the $$2$$ global nodes: $$\\{0,\\,0\\}~N.$$\n  - Essential boundary conditions: $$u(0)=0~m,$$ and $$u(2.0)=0~m.$$\n\n- Case $$3$$ (heterogeneous material and area, prescribed right displacement, internal nodal load):\n  - Element count $$n_{e}=4.$$\n  - Element lengths $$\\{0.25,\\,0.25,\\,0.25,\\,0.25\\}~m.$$\n  - Young’s modulus $$\\{2.0\\times 10^{11},\\,1.5\\times 10^{11},\\,1.0\\times 10^{11},\\,1.2\\times 10^{11}\\}~Pa.$$\n  - Areas $$\\{8.0\\times 10^{-4},\\,1.2\\times 10^{-3},\\,1.0\\times 10^{-3},\\,9.0\\times 10^{-4}\\}~m^{2}.$$\n  - Body forces $$\\{0,\\,5.0\\times 10^{3},\\,-3.0\\times 10^{3},\\,2.0\\times 10^{3}\\}~N/m.$$\n  - Nodal point loads on the $$5$$ global nodes: $$\\{0,\\,0,\\,2.0\\times 10^{3},\\,0,\\,0\\}~N.$$\n  - Essential boundary conditions: $$u(0)=0~m,$$ and $$u(1.0)=1.0\\times 10^{-4}~m.$$\n\n- Case $$4$$ (strong heterogeneity, mixed boundary, nonzero traction sign):\n  - Element count $$n_{e}=2.$$\n  - Element lengths $$\\{0.5,\\,1.5\\}~m.$$\n  - Young’s modulus $$\\{1.0\\times 10^{11},\\,5.0\\times 10^{10}\\}~Pa.$$\n  - Areas $$\\{7.0\\times 10^{-4},\\,7.0\\times 10^{-4}\\}~m^{2}.$$\n  - Body forces $$\\{1.0\\times 10^{2},\\,0\\}~N/m.$$\n  - Nodal point loads on the $$3$$ global nodes: $$\\{0,\\,0,\\,-1.0\\times 10^{4}\\}~N.$$\n  - Essential boundary conditions: $$u(0)=0~m.$$\n\nAlgorithmic requirements:\n- Use a Gauss–Legendre quadrature of at least three points on $$\\xi\\in[-1,1]$$ to evaluate element integrals exactly for the given polynomial fields.\n- Assemble the global matrices for both the full and condensed systems.\n- Enforce essential boundary conditions by partitioning the system into free and fixed sets and solving the reduced linear system.\n- Compute the global nodal residual vector $$\\mathbf{r}=\\mathbf{K}\\mathbf{u}-\\mathbf{F}$$ for both formulations.\n- For each case, compare the two formulations at the left and right end nodes on:\n  - Displacements, and\n  - Nodal residuals (which equal reactions where displacements are prescribed).\n- A test case passes if both end-node displacements and both end-node nodal residuals match within the specified relative tolerance $$10^{-9}$$ and absolute tolerance $$10^{-12}.$$\n\nFinal output format:\n- Your program should produce a single line of output containing the boolean results for the four test cases as a comma-separated list enclosed in square brackets (for example, $$[true,false,true,true]$$ but with Python boolean capitalization). The order must be case $$1$$, case $$2$$, case $$3$$, case $$4$$.", "solution": "The problem presented is a well-posed and scientifically sound exercise in the finite element method, based on established principles of linear elasticity and computational mechanics. It is complete, consistent, and all provided data are physically realistic. The problem is validated and a solution can be constructed.\n\nThe objective is to implement a one-dimensional finite element solver for an axially loaded bar using a specific quadratic hierarchical element. We must construct and solve the global system in two ways: a full system containing all degrees of freedom (DOFs), and a statically condensed system where internal DOFs are eliminated at the element level. The consistency of the two methods will be verified.\n\nFirst, we derive the element stiffness matrix $\\mathbf{K}^e$ and the element consistent load vector $\\mathbf{f}^e$. The analysis is performed on a parent element domain $\\xi \\in [-1, 1]$, which is mapped to a physical element of length $L$. The Jacobian of this mapping is $J = L/2$.\n\nThe hierarchical shape functions are given as:\n$$N_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2}$$\nwhere $N_1$ and $N_2$ are associated with the element's start and end nodes, and $N_3$ is the \"bubble\" function associated with an internal DOF that has no value at the element's ends ($N_3(\\pm 1) = 0$).\n\nThe axial displacement field $u$ within the element is interpolated as $u(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}^e$, where $\\mathbf{N} = [N_1, N_2, N_3]$ and $\\mathbf{d}^e = [d_1, d_2, d_3]^T$ are the elemental nodal displacements.\n\nThe axial strain $\\varepsilon = du/dx$ is related to the parent coordinate derivatives via the chain rule:\n$$\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J}\\frac{d}{d\\xi}$$\nThe derivatives of the shape functions with respect to $\\xi$ are:\n$$\\frac{dN_1}{d\\xi} = -\\frac{1}{2}, \\quad \\frac{dN_2}{d\\xi} = \\frac{1}{2}, \\quad \\frac{dN_3}{d\\xi} = -2\\xi$$\nThe strain-displacement matrix $\\mathbf{B}$ is thus:\n$$\\mathbf{B}(\\xi) = \\frac{d\\mathbf{N}}{dx} = \\frac{1}{J} \\frac{d\\mathbf{N}}{d\\xi} = \\frac{1}{J} \\begin{bmatrix} -1/2 & 1/2 & -2\\xi \\end{bmatrix}$$\n\nThe element stiffness matrix $\\mathbf{K}^e$ is given by the formula:\n$$\\mathbf{K}^{e}=\\int_{0}^{L} \\mathbf{B}^T E A \\mathbf{B} \\,dx = \\int_{-1}^{1} \\mathbf{B}(\\xi)^T E A \\mathbf{B}(\\xi) J \\,d\\xi$$\nAssuming Young's modulus $E$ and area $A$ are constant within the element:\n$$\\mathbf{K}^e = EAJ \\int_{-1}^{1} \\left(\\frac{1}{J^2}\\right) \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right)^T \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right) \\,d\\xi = \\frac{EA}{J} \\int_{-1}^{1} \\begin{bmatrix} -1/2 \\\\ 1/2 \\\\ -2\\xi \\end{bmatrix} \\begin{bmatrix} -1/2 & 1/2 & -2\\xi \\end{bmatrix} \\,d\\xi$$\n$$\\mathbf{K}^e = \\frac{EA}{J} \\int_{-1}^{1} \\begin{bmatrix} 1/4 & -1/4 & \\xi \\\\ -1/4 & 1/4 & -\\xi \\\\ \\xi & -\\xi & 4\\xi^2 \\end{bmatrix} \\,d\\xi$$\nThe integrals of the polynomial terms are $\\int_{-1}^1 1 \\,d\\xi = 2$, $\\int_{-1}^1 \\xi \\,d\\xi = 0$, and $\\int_{-1}^1 \\xi^2 \\,d\\xi = 2/3$. Using these results:\n$$\\mathbf{K}^e = \\frac{EA}{J} \\begin{bmatrix} 1/2 & -1/2 & 0 \\\\ -1/2 & 1/2 & 0 \\\\ 0 & 0 & 8/3 \\end{bmatrix} = \\frac{2EA}{L} \\begin{bmatrix} 1/2 & -1/2 & 0 \\\\ -1/2 & 1/2 & 0 \\\\ 0 & 0 & 8/3 \\end{bmatrix} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & 0 & 16/3 \\end{bmatrix}$$\nA critical observation is that the stiffness matrix is block-diagonal. The linear nodal DOFs ($d_1, d_2$) are uncoupled from the internal hierarchical DOF ($d_3$). This occurs because the integral of the cross-term derivative products, e.g., $\\frac{dN_1}{d\\xi}\\frac{dN_3}{d\\xi} = \\xi$, is zero over the symmetric domain $[-1, 1]$.\n\nThe consistent element load vector $\\mathbf{f}^e$ due to a constant body force $b$ is:\n$$\\mathbf{f}^{e} = \\int_{0}^{L} \\mathbf{N}^T b \\,dx = \\int_{-1}^{1} \\mathbf{N}(\\xi)^T b J \\,d\\xi$$\n$$\\mathbf{f}^e = bJ \\int_{-1}^{1} \\begin{bmatrix} (1-\\xi)/2 \\\\ (1+\\xi)/2 \\\\ 1-\\xi^2 \\end{bmatrix} d\\xi = b \\frac{L}{2} \\begin{bmatrix} 1 \\\\ 1 \\\\ 4/3 \\end{bmatrix}$$\nThese integrals will be computed numerically using a $3$-point Gauss-Legendre quadrature, which is exact for polynomials up to degree $5$, sufficient for our integrands of degree at most $2$.\n\nFor the **full system**, we assemble the $3 \\times 3$ element matrices into a global system. The total number of DOFs will be $n_{nodes} + n_{elements}$. The first $n_{nodes}$ DOFs correspond to the physical nodes, and the subsequent $n_{elements}$ DOFs correspond to the internal bubble mode of each element.\n\nFor the **statically condensed system**, we eliminate the internal DOF $d_3$ at the element level. An element system is partitioned into primary (p) and internal (i) DOFs:\n$$ \\begin{bmatrix} \\mathbf{K}_{pp} & \\mathbf{K}_{pi} \\\\ \\mathbf{K}_{ip} & K_{ii} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{d}_p \\\\ d_i \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{f}_p \\\\ f_i \\end{Bmatrix} $$\nThe condensed (Schur complement) system for the primary DOFs $\\mathbf{d}_p$ is $\\mathbf{K}_{cond}^e \\mathbf{d}_p = \\mathbf{f}_{cond}^e$, where:\n$$\\mathbf{K}_{cond}^e = \\mathbf{K}_{pp} - \\mathbf{K}_{pi} K_{ii}^{-1} \\mathbf{K}_{ip}$$\n$$\\mathbf{f}_{cond}^e = \\mathbf{f}_p - \\mathbf{K}_{pi} K_{ii}^{-1} f_i$$\nDue to the uncoupled nature of our $\\mathbf{K}^e$, we have $\\mathbf{K}_{pi} = \\mathbf{0}$ and $\\mathbf{K}_{ip} = \\mathbf{0}^T$. The equations simplify to:\n$$\\mathbf{K}_{cond}^e = \\mathbf{K}_{pp} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$$\n$$\\mathbf{f}_{cond}^e = \\mathbf{f}_p = \\frac{bL}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$$\nThis reveals that the condensed system is equivalent to a standard finite element analysis using linear bar elements. The bubble functions do not alter the nodal displacement solution when material properties are constant within elements.\n\nThe implementation will proceed as follows:\n1.  For each test case, the parameters are defined.\n2.  A loop iterates through each element to compute its stiffness matrix and load vector using numerical quadrature.\n3.  The full global system matrices $(\\mathbf{K}_{full}, \\mathbf{F}_{full})$ are assembled. This system size is $(n_{nodes} + n_{elements}) \\times (n_{nodes} + n_{elements})$.\n4.  The condensed global system matrices $(\\mathbf{K}_{cond}, \\mathbf{F}_{cond})$ are assembled by first performing static condensation on each element. This system size is $n_{nodes} \\times n_{nodes}$.\n5.  Nodal point loads are added to the respective global force vectors.\n6.  Essential boundary conditions (prescribed displacements) are enforced by partitioning each system into free and fixed DOFs and solving the reduced system for the free DOFs.\n7.  The full displacement vectors $(\\mathbf{u}_{full}, \\mathbf{u}_{cond})$ are reconstructed.\n8.  The global nodal residual vectors $(\\mathbf{r}_{full}, \\mathbf{r}_{cond})$ are computed using the formula $\\mathbf{r} = \\mathbf{K}\\mathbf{u} - \\mathbf{F}$.\n9.  Finally, the end-node displacements and end-node residuals from both solutions are compared using the specified tolerances ($rtol=10^{-9}, atol=10^{-12}$). A boolean result indicates if all comparisons for a test case pass.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the 1D hierarchical FEA solver.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            \"n_e\": 3,\n            \"lengths\": [0.4, 0.3, 0.3],\n            \"E\": [2.10e11, 2.10e11, 2.10e11],\n            \"A\": [5.0e-4, 5.0e-4, 5.0e-4],\n            \"b\": [1.0e3, 1.0e3, 1.0e3],\n            \"nodal_loads\": [0.0, 0.0, 0.0, 1.0e5],\n            \"bcs\": {0: 0.0}\n        },\n        { # Case 2\n            \"n_e\": 1,\n            \"lengths\": [2.0],\n            \"E\": [7.0e10],\n            \"A\": [1.0e-3],\n            \"b\": [-5.0e2],\n            \"nodal_loads\": [0.0, 0.0],\n            \"bcs\": {0: 0.0, 1: 0.0} \n        },\n        { # Case 3\n            \"n_e\": 4,\n            \"lengths\": [0.25, 0.25, 0.25, 0.25],\n            \"E\": [2.0e11, 1.5e11, 1.0e11, 1.2e11],\n            \"A\": [8.0e-4, 1.2e-3, 1.0e-3, 9.0e-4],\n            \"b\": [0.0, 5.0e3, -3.0e3, 2.0e3],\n            \"nodal_loads\": [0.0, 0.0, 2.0e3, 0.0, 0.0],\n            \"bcs\": {0: 0.0, 4: 1.0e-4}\n        },\n        { # Case 4\n            \"n_e\": 2,\n            \"lengths\": [0.5, 1.5],\n            \"E\": [1.0e11, 5.0e10],\n            \"A\": [7.0e-4, 7.0e-4],\n            \"b\": [1.0e2, 0.0],\n            \"nodal_loads\": [0.0, 0.0, -1.0e4],\n            \"bcs\": {0: 0.0}\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        results.append(run_case(case_data))\n\n    # Python's booleans are capitalized, so direct str() conversion is correct.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_element_matrices(L, E, A, b):\n    \"\"\"\n    Computes element stiffness matrix and load vector using 3-point Gauss quadrature.\n    \"\"\"\n    Ke = np.zeros((3, 3))\n    fe = np.zeros(3)\n    J = L / 2.0\n\n    # 3-point Gauss-Legendre quadrature\n    gauss_points = [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)]\n    gauss_weights = [5.0 / 9.0, 8.0 / 9.0, 5.0 / 9.0]\n\n    for xi, w in zip(gauss_points, gauss_weights):\n        # Shape functions N(xi)\n        N = np.array([(1.0 - xi) / 2.0, (1.0 + xi) / 2.0, 1.0 - xi**2])\n        # Derivatives of shape functions w.r.t. xi\n        dN_dxi = np.array([-0.5, 0.5, -2.0 * xi])\n        # B matrix (derivatives of N w.r.t. x)\n        B = dN_dxi / J\n\n        Ke += np.outer(B, B) * E * A * J * w\n        fe += N * b * J * w\n        \n    return Ke, fe\n\ndef solve_system(K, F, bcs, n_dof):\n    \"\"\"\n    Applies boundary conditions and solves the linear system.\n    \"\"\"\n    dof_fixed = np.array(list(bcs.keys()), dtype=int)\n    dof_all = np.arange(n_dof)\n    dof_free = np.setdiff1d(dof_all, dof_fixed)\n\n    u = np.zeros(n_dof)\n    for dof, val in bcs.items():\n        u[dof] = val\n\n    if len(dof_free) > 0:\n        K_ff = K[np.ix_(dof_free, dof_free)]\n        K_fd = K[np.ix_(dof_free, dof_fixed)]\n        F_f = F[dof_free]\n        u_d = u[dof_fixed]\n\n        F_eff = F_f - K_fd @ u_d\n        u[dof_free] = np.linalg.solve(K_ff, F_eff)\n    \n    return u\n\ndef run_case(case):\n    \"\"\"\n    Runs a single test case for both full and condensed systems and compares results.\n    \"\"\"\n    n_e = case[\"n_e\"]\n    n_nodes = n_e + 1\n    \n    # --- Full System ---\n    n_dof_full = n_nodes + n_e\n    K_full = np.zeros((n_dof_full, n_dof_full))\n    F_full = np.zeros(n_dof_full)\n\n    # --- Condensed System ---\n    n_dof_cond = n_nodes\n    K_cond = np.zeros((n_dof_cond, n_dof_cond))\n    F_cond = np.zeros(n_dof_cond)\n\n    for i in range(n_e):\n        L, E, A, b = case[\"lengths\"][i], case[\"E\"][i], case[\"A\"][i], case[\"b\"][i]\n        Ke, fe = get_element_matrices(L, E, A, b)\n        \n        # Assembly for full system\n        node_indices = [i, i + 1]\n        bubble_index = n_nodes + i\n        full_dof_map = np.array([node_indices[0], node_indices[1], bubble_index])\n        K_full[np.ix_(full_dof_map, full_dof_map)] += Ke\n        F_full[full_dof_map] += fe\n\n        # Static condensation and assembly for condensed system\n        K_pp = Ke[:2, :2]\n        K_pi = Ke[:2, 2:3]\n        K_ip = Ke[2:3, :2]\n        K_ii = Ke[2, 2]\n        f_p = fe[:2]\n        f_i = fe[2]\n        \n        K_cond_e = K_pp - (K_pi @ K_ip) / K_ii\n        f_cond_e = f_p - (K_pi.flatten() * f_i) / K_ii\n\n        cond_dof_map = np.array(node_indices)\n        K_cond[np.ix_(cond_dof_map, cond_dof_map)] += K_cond_e\n        F_cond[cond_dof_map] += f_cond_e\n\n    # Add nodal loads\n    F_full[:n_nodes] += case[\"nodal_loads\"]\n    F_cond += case[\"nodal_loads\"]\n\n    # Solve systems\n    bcs_full = case[\"bcs\"]\n    u_full = solve_system(K_full, F_full, bcs_full, n_dof_full)\n    \n    # Remap BCs for condensed system, as they only affect nodes\n    bcs_cond = {k: v for k, v in bcs_full.items() if k  n_nodes}\n    u_cond = solve_system(K_cond, F_cond, bcs_cond, n_dof_cond)\n\n    # Calculate residuals\n    r_full = K_full @ u_full - F_full\n    r_cond = K_cond @ u_cond - F_cond\n\n    # Extract nodal values from full system for comparison\n    u_full_nodes = u_full[:n_nodes]\n    r_full_nodes = r_full[:n_nodes]\n\n    # Comparison\n    rtol, atol = 1e-9, 1e-12\n    \n    disp_left_ok = np.isclose(u_full_nodes[0], u_cond[0], rtol=rtol, atol=atol)\n    disp_right_ok = np.isclose(u_full_nodes[-1], u_cond[-1], rtol=rtol, atol=atol)\n    \n    res_left_ok = np.isclose(r_full_nodes[0], r_cond[0], rtol=rtol, atol=atol)\n    res_right_ok = np.isclose(r_full_nodes[-1], r_cond[-1], rtol=rtol, atol=atol)\n    \n    return all([disp_left_ok, disp_right_ok, res_left_ok, res_right_ok])\n\n# The problem description requires calling a function to produce the output.\n# If this script is run directly, we call solve().\nif __name__ == '__main__':\n    solve()\n```", "id": "2538553"}]}