{"hands_on_practices": [{"introduction": "A cornerstone of computational homogenization is the ability to accurately compute volume averages of microscopic fields, such as stress $\\boldsymbol{\\sigma}$, to obtain their macroscopic counterparts $\\langle \\boldsymbol{\\sigma} \\rangle$. This exercise provides essential practice in this fundamental post-processing step. You will derive the standard quadrature-based formula used in finite element codes, starting from the continuous definition of the volume average, and justify the critical need for consistent numerical integration of both the field and the domain's volume to ensure the method's robustness and accuracy [@problem_id:2546266].", "problem": "Consider a Representative Volume Element (RVE) in computational homogenization, denoted by the bounded domain $\\Omega_{\\mu} \\subset \\mathbb{R}^{d}$ with volume $|\\Omega_{\\mu}|$. The microscopic Cauchy stress field is $\\boldsymbol{\\sigma}(\\boldsymbol{x})$, assumed sufficiently smooth and obtained from a finite element computation. The finite element mesh partitions $\\Omega_{\\mu}$ into elements indexed by $e \\in \\mathcal{E}$. On each element $e$, an isoparametric mapping $\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})$ from the reference element $\\widehat{\\Omega}$ to the physical element $\\Omega_{e}$ is used, with Jacobian determinant $J_{e}(\\boldsymbol{\\xi}) = \\det\\left(\\partial \\boldsymbol{x}^{(e)}/\\partial \\boldsymbol{\\xi}\\right)$. A standard Gauss quadrature with points $\\{\\boldsymbol{\\xi}^{(e)}_{q}\\}_{q=1}^{Q_{e}}$ and positive weights $\\{w_{q}\\}_{q=1}^{Q_{e}}$ is used on each element to assemble quantities, and the stress evaluated at the Gauss points is denoted $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$.\n\nStarting from the fundamental definition of the macroscopic (volume) average of stress,\n$$\\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\Omega_{\\mu}|} \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V,$$\nderive a quadrature-based finite element expression for $\\langle \\boldsymbol{\\sigma} \\rangle$ purely in terms of the Gauss-point stresses $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$, the Jacobian determinants $J_{e}(\\boldsymbol{\\xi}^{(e)}_{q})$, and the reference-element weights $w_{q}$.\n\nThen, using first principles, justify how to choose the normalization in your discrete formula so that the resulting average is invariant with respect to mesh partitioning in the following precise sense: for any two meshes of $\\Omega_{\\mu}$ using the same element type and the same quadrature rule, the computed average coincides for any elementwise constant stress field. Your reasoning should rely only on basic properties of Gauss quadrature and isoparametric mappings, not on special features of any particular code.\n\nYour final answer must be a single closed-form analytical expression involving only sums over elements and Gauss points, $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$, $J_{e}(\\boldsymbol{\\xi}^{(e)}_{q})$, and $w_{q}$. Do not include any other symbols. No numerical evaluation is required, and no units are needed. Express only the final formula as your answer.", "solution": "The problem statement is scientifically grounded, well-posed, objective, and self-contained. It presents a standard task in the post-processing of finite element solutions within the framework of computational homogenization. We will proceed with a rigorous derivation.\n\nThe objective is to derive a discrete, quadrature-based expression for the macroscopic average stress, defined as:\n$$ \\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\Omega_{\\mu}|} \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V $$\n\nThe derivation proceeds in three logical steps: spatial discretization of the integral, numerical approximation using Gauss quadrature, and consistent normalization.\n\nFirst, the integral over the entire Representative Volume Element (RVE) domain $\\Omega_{\\mu}$ is decomposed into a sum of integrals over the non-overlapping finite elements $\\Omega_e$ that constitute the mesh $\\mathcal{E}$. The domain is the union of its elements, $\\Omega_{\\mu} = \\bigcup_{e \\in \\mathcal{E}} \\Omega_e$. Thus, the integral becomes:\n$$ \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V = \\sum_{e \\in \\mathcal{E}} \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V $$\n\nSecond, each integral over a physical element $\\Omega_e$ is transformed into an integral over the standard reference element $\\widehat{\\Omega}$ by using the given isoparametric mapping $\\boldsymbol{x} = \\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})$. The differential volume element transforms according to $\\mathrm{d}V = J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V}$, where $J_{e}(\\boldsymbol{\\xi}) = \\det(\\partial \\boldsymbol{x}^{(e)}/\\partial \\boldsymbol{\\xi})$ is the determinant of the Jacobian of the mapping. The integral over element $e$ is then:\n$$ \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V = \\int_{\\widehat{\\Omega}} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})) J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} $$\n\nThis integral over the reference element is then approximated numerically using the specified Gauss quadrature rule, which is defined by a set of $Q_e$ quadrature points $\\{\\boldsymbol{\\xi}^{(e)}_{q}\\}_{q=1}^{Q_{e}}$ in the reference element and corresponding positive weights $\\{w_{q}\\}_{q=1}^{Q_{e}}$. It is standard for the quadrature rule (points and weights) to be fixed for a given element type, so the subscript and superscript on $Q_e$ and $\\boldsymbol{\\xi}^{(e)}_q$ could be dropped, but we will retain the problem's notation for strictness. The approximation is:\n$$ \\int_{\\widehat{\\Omega}} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})) J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} \\approx \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\nUsing the shorthand notation provided, $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) \\equiv \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}))$, we can write the discrete approximation for the integral over element $e$ as:\n$$ \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V \\approx \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\nSumming over all elements in the mesh gives the numerical approximation for the total stress integral:\n$$ \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n\nThird, we address the normalization factor $|\\Omega_{\\mu}|$. A naive approach might use an exact or analytically known volume. However, for the discrete formula to be consistent, the normalization factor must be computed using the exact same numerical scheme as the numerator. The volume $|\\Omega_{\\mu}|$ is the integral of the function $f(\\boldsymbol{x})=1$ over the domain:\n$$ |\\Omega_{\\mu}| = \\int_{\\Omega_{\\mu}} 1 \\, \\mathrm{d}V $$\nApplying the same discretization and quadrature procedure to this integral yields the numerically computed volume:\n$$ |\\Omega_{\\mu}| \\approx \\sum_{e \\in \\mathcal{E}} \\int_{\\Omega_e} 1 \\, \\mathrm{d}V = \\sum_{e \\in \\mathcal{E}} \\int_{\\widehat{\\Omega}} J_e(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_e(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\nThe consistently normalized expression for the average stress is therefore the ratio of the two numerically computed quantities:\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} $$\n\nWe must now justify this choice of normalization based on the required invariance property. The problem asks for the computed average to be invariant to mesh partitioning for \"any elementwise constant stress field.\" We interpret this in the context of the fundamental consistency requirement for any averaging scheme, known as the zeroth-order patch test: the scheme must exactly reproduce constants.\nConsider a globally constant stress field, $\\boldsymbol{\\sigma}(\\boldsymbol{x}) = \\boldsymbol{\\sigma}_0$. The true average is trivially $\\langle\\boldsymbol{\\sigma}\\rangle = \\boldsymbol{\\sigma}_0$. Our numerical formula must yield this result, regardless of the mesh used. For such a field, the stress at every Gauss point is also $\\boldsymbol{\\sigma}_0$, i.e., $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) = \\boldsymbol{\\sigma}_0$ for all $e$ and $q$.\nSubstituting this into our derived formula:\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}_0 J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} $$\nSince $\\boldsymbol{\\sigma}_0$ is a constant tensor, it can be factored out of the summations in the numerator:\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\boldsymbol{\\sigma}_0 \\left( \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} \\right) = \\boldsymbol{\\sigma}_0 $$\nThe expression simplifies to $\\boldsymbol{\\sigma}_0$ exactly, because the numerator and denominator become identical except for the factor of $\\boldsymbol{\\sigma}_0$. This result is independent of the mesh $\\mathcal{E}$, thereby satisfying the specified invariance condition for the crucial case of a constant field. This demonstrates that computing the volume (the normalization factor) with the same quadrature rule as the stress integral is not merely a choice, but a requirement for the fundamental consistency of the numerical average.\nTherefore, the final formula is uniquely determined by these principles.", "answer": "$$ \\boxed{ \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} } $$", "id": "2546266"}, {"introduction": "Periodic Boundary Conditions (PBCs) are fundamental to Representative Volume Element (RVE) modeling, as they enforce that the RVE behaves as if it were part of an infinite, repeating medium. This practice focuses on the crucial task of correctly implementing and verifying PBCs for the microscopic fluctuation displacement field $\\widetilde{\\boldsymbol{u}}$. You will implement the constraints and then perform two essential numerical checks: verifying that the volume average of the fluctuation field is zero and confirming the anti-periodicity of tractions on opposite RVE faces, thereby building confidence in your numerical framework [@problem_id:2546317].", "problem": "Consider a two-dimensional representative volume element on the unit square domain $\\Omega = [0,1] \\times [0,1]$ for a linear elastic, small-strain, heterogeneous solid under a prescribed macroscopic pure shear deformation. The total displacement field is decomposed as $u(x) = \\overline{u}(x) + \\widetilde{u}(x)$, where $\\overline{u}(x)$ is the macroscopic displacement and $\\widetilde{u}(x)$ is the microscopic fluctuation displacement. The macroscopic strain is prescribed as a uniform pure shear given by the symmetric small-strain tensor $\\overline{\\varepsilon} = \\begin{bmatrix} 0 & \\gamma/2 \\\\ \\gamma/2 & 0 \\end{bmatrix}$, with engineering shear $\\gamma \\in \\mathbb{R}$. The microscopic fluctuation displacement $\\widetilde{u}(x)$ is required to be periodic on $\\partial \\Omega$, and to have zero volumetric average over $\\Omega$.\n\nThe material is isotropic and heterogeneous: inside a circular inclusion of radius $r = 0.2$ centered at $(0.5, 0.5)$, the Young’s modulus is $E_{\\text{in}}$, and outside the inclusion it is $E_{\\text{out}}$. The Poisson’s ratio is $\\nu$ everywhere. Plane strain kinematics is assumed. The constitutive equation is $\\sigma(x) = \\mathbb{C}(x):\\varepsilon(u(x))$, where $\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^{\\top})$ and $\\mathbb{C}(x)$ is the spatially varying fourth-order elasticity tensor for plane strain. The balance of linear momentum in the absence of body forces is $\\nabla \\cdot \\sigma = 0$ in $\\Omega$.\n\nYou must discretize the fluctuation problem with the finite element method using a structured mesh of bilinear quadrilateral elements ($Q4$) with $n_x = 8$ elements along $x$ and $n_y = 8$ elements along $y$. Use $2 \\times 2$ Gauss quadrature in the interior and $2$-point Gauss quadrature on element edges. Represent the spatial variation of $\\mathbb{C}(x)$ by evaluating the inclusion indicator at each quadrature point.\n\nFormulate the fluctuation problem by substituting $u(x) = \\overline{u}(x) + \\widetilde{u}(x)$ with $\\varepsilon(\\overline{u}) = \\overline{\\varepsilon}$ constant, and solve for $\\widetilde{u}$ subject to:\n- Periodic boundary conditions on $\\widetilde{u}$ across opposite faces of $\\Omega$.\n- Zero-mean constraint $\\int_{\\Omega} \\widetilde{u}(x) \\, \\mathrm{d}V = 0$.\n\nImplement the constraints via Lagrange multipliers, and assemble the corresponding saddle-point linear system. Express all quantities in dimensionless form; no physical units are required.\n\nVerification objectives for a correct periodic boundary condition implementation under pure shear macroscopic loading:\n1. The volume-average of the fluctuation displacement must be the zero vector, i.e., $\\frac{1}{|\\Omega|}\\int_{\\Omega} \\widetilde{u}(x) \\, \\mathrm{d}V = (0,0)$.\n2. The tractions on opposite boundary faces must be equal and opposite when computed with outward unit normals, i.e., if $t(x) = \\sigma(x)\\,n(x)$ and $x^{+}$ and $x^{-}$ are corresponding points on opposite faces with outward normals $n^{+}$ and $n^{-} = -n^{+}$, then $t(x^{+}) + t(x^{-}) = 0$.\n\nNumerically verify (2) by evaluating tractions at $2$-point Gauss locations on each boundary edge, pairing corresponding edges on opposite faces, and computing the $L^{2}$-type relative mismatch\n$$\n\\eta = \\frac{\\left( \\sum \\| t^{+} + t^{-} \\|^{2}\\, \\mathrm{d}\\Gamma \\right)^{1/2}}{\\max\\left( \\left( \\sum (\\| t^{+}\\|^{2} + \\| t^{-}\\|^{2})\\, \\mathrm{d}\\Gamma \\right)^{1/2},\\, 10^{-30}\\right)}.\n$$\n\nUse the following plane strain elasticity tensor expressed in Voigt notation with engineering shear:\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}, \\quad\n\\mathbb{C} = \\begin{bmatrix} \\lambda + 2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda + 2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}.\n$$\n\nFinite element formulation requirements:\n- Let $\\varepsilon_{0} = [0,\\, 0,\\, \\gamma]^{\\top}$ represent the macroscopic engineering strain vector in Voigt notation. The stress at any quadrature point is $\\sigma = \\mathbb{C}(\\varepsilon(\\widetilde{u}) + \\varepsilon_{0})$.\n- The assembled linear system for the nodal fluctuation unknowns $\\widetilde{u}$ has the form\n$$\n\\begin{bmatrix}\nK & G^{\\top} \\\\\nG & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n\\mathbf{0}\n\\end{bmatrix},\n$$\nwhere $K = \\int_{\\Omega} B^{\\top}\\mathbb{C} B \\,\\mathrm{d}V$, $\\mathbf{f} = -\\int_{\\Omega} B^{\\top}\\mathbb{C} \\varepsilon_{0}\\,\\mathrm{d}V$, $B$ is the standard $Q4$ strain-displacement matrix in plane strain, and $G$ encodes both the periodic constraints on opposite boundary nodes and the two zero-mean constraints on the fluctuation displacement components using consistent nodal integration weights.\n\nTest suite:\n- Case $1$: $\\gamma = 0.0$, $E_{\\text{in}} = 5.0$, $E_{\\text{out}} = 1.0$, $\\nu = 0.3$.\n- Case $2$: $\\gamma = 0.02$, $E_{\\text{in}} = 5.0$, $E_{\\text{out}} = 1.0$, $\\nu = 0.3$.\n- Case $3$: $\\gamma = 0.05$, $E_{\\text{in}} = 10.0$, $E_{\\text{out}} = 1.0$, $\\nu = 0.3$.\n- Case $4$: $\\gamma = 0.02$, $E_{\\text{in}} = 1.0$, $E_{\\text{out}} = 5.0$, $\\nu = 0.3$.\n\nAcceptance tolerances:\n- Mean fluctuation displacement norm: $\\left\\|\\frac{1}{|\\Omega|}\\int_{\\Omega} \\widetilde{u}\\,\\mathrm{d}V\\right\\|_{2} \\le 10^{-10}$.\n- Traction anti-periodicity relative mismatch: $\\eta \\le 10^{-8}$.\n\nYour program must:\n- Assemble and solve the finite element system for each test case.\n- Compute the average fluctuation displacement using consistent nodal weights.\n- Compute $\\eta$ by pairing left-right and top-bottom boundaries with outward normals and $2$-point Gauss quadrature along edges.\n- For each test case, return a boolean that is true if and only if both verification criteria are satisfied.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$). No additional text should be printed.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of continuum mechanics and the finite element method, specifically for computational homogenization. The problem is well-posed, providing a complete and consistent set of data, governing equations, boundary conditions, and numerical specifications required to formulate and solve for the unknown fluctuation displacement field. The language used is objective and mathematically precise. There are no contradictions, ambiguities, or physically unrealistic assumptions. The task is to implement a standard, albeit non-trivial, numerical procedure for which a unique solution is expected.\n\nThe solution proceeds as follows: First, we establish the variational formulation for the fluctuation problem. Second, we detail the finite element discretization using bilinear quadrilateral elements. Third, we formulate the periodic and zero-mean constraints using Lagrange multipliers, leading to the specified saddle-point linear system. Fourth, we outline the algorithm for assembling and solving this system. Finally, we describe the post-processing steps to compute the required verification quantities.\n\n**1. Variational Formulation**\n\nThe problem addresses a linear elastic solid governed by the balance of linear momentum, $\\nabla \\cdot \\sigma = 0$, in the absence of body forces. The total displacement $u(x)$ is additively decomposed into a macroscopic part $\\overline{u}(x)$ and a periodic microscopic fluctuation part $\\widetilde{u}(x)$:\n$$\nu(x) = \\overline{u}(x) + \\widetilde{u}(x)\n$$\nThe macroscopic displacement corresponds to a prescribed uniform strain $\\overline{\\varepsilon}$, such that $\\nabla \\overline{u} = \\overline{\\varepsilon}$ (assuming $\\overline{u}(0)=0$). The total strain $\\varepsilon(u)$ is thus:\n$$\n\\varepsilon(u) = \\varepsilon(\\overline{u} + \\widetilde{u}) = \\overline{\\varepsilon} + \\varepsilon(\\widetilde{u})\n$$\nThe constitutive relation is $\\sigma(x) = \\mathbb{C}(x) : \\varepsilon(u)$, where $\\mathbb{C}(x)$ is the heterogeneous elasticity tensor.\n\nThe weak form of the equilibrium equation is obtained by multiplying by a suitable test function $v(x)$ and integrating over the domain $\\Omega$. The test function $v$ must belong to the space of kinematically admissible fluctuations, i.e., it must be periodic.\n$$\n\\int_{\\Omega} \\nabla v : \\sigma \\, \\mathrm{d}V = 0\n$$\nSubstituting the constitutive relation and strain decomposition:\n$$\n\\int_{\\Omega} \\nabla v : \\mathbb{C}(x) : (\\varepsilon(\\widetilde{u}) + \\overline{\\varepsilon}) \\, \\mathrm{d}V = 0\n$$\nSince this must hold for any admissible test function $v$, we can rearrange it to find the fluctuation field $\\widetilde{u}$:\n$$\n\\int_{\\Omega} \\nabla v : \\mathbb{C}(x) : \\varepsilon(\\widetilde{u}) \\, \\mathrm{d}V = - \\int_{\\Omega} \\nabla v : \\mathbb{C}(x) : \\overline{\\varepsilon} \\, \\mathrm{d}V\n$$\nThis is a standard variational problem for $\\widetilde{u}$.\nThe left-hand side defines a bilinear form $a(\\widetilde{u}, v)$ and the right-hand side defines a linear functional $L(v)$.\n\n**2. Finite Element Discretization**\n\nWe discretize the domain $\\Omega = [0,1] \\times [0,1]$ with a structured mesh of $n_x \\times n_y = 8 \\times 8$ bilinear quadrilateral ($Q4$) elements. The displacement fluctuation field $\\widetilde{u}(x)$ within an element is interpolated from the nodal values $\\mathbf{u}^e$ using shape functions $N_i(x)$:\n$$\n\\widetilde{u}(x) \\approx \\sum_{i=1}^{4} N_i(x) \\mathbf{u}_i^e, \\quad \\text{where } \\mathbf{u}_i^e = [\\widetilde{u}_{x,i}, \\widetilde{u}_{y,i}]^\\top\n$$\nThe strain-displacement relationship in the discrete setting is $\\varepsilon(\\widetilde{u}) = B \\mathbf{u}$, where $B$ is the strain-displacement matrix and $\\mathbf{u}$ is the global vector of nodal unknowns. For plane strain and a single node $i$ with shape function $N_i$, the $B_i$ matrix is:\n$$\nB_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\nThe full element $B$ matrix is formed by concatenating the $B_i$ matrices for all four nodes of the element.\nSubstituting the finite element approximations into the weak form yields the linear system:\n$$\nK \\mathbf{u} = \\mathbf{f}\n$$\nwhere $\\mathbf{u}$ is the global vector of nodal fluctuation displacements. The stiffness matrix $K$ and force vector $\\mathbf{f}$ are assembled from element contributions:\n$$\nK = \\int_{\\Omega} B^{\\top} \\mathbb{C} B \\, \\mathrm{d}V \\quad \\text{and} \\quad \\mathbf{f} = -\\int_{\\Omega} B^{\\top} \\mathbb{C} \\overline{\\varepsilon}_v \\, \\mathrm{d}V\n$$\nHere, $\\overline{\\varepsilon}_v$ is the macroscopic strain in Voigt notation, $[0, 0, \\gamma]^\\top$. The integrals are computed numerically using $2 \\times 2$ Gauss quadrature within each element. At each quadrature point, the material's constitutive tensor $\\mathbb{C}(x)$ is evaluated based on whether the point lies inside or outside the specified circular inclusion.\n\n**3. Constraint Formulation**\n\nThe periodic problem for $\\widetilde{u}$ has a kernel corresponding to rigid-body translations (constant displacement vectors). To ensure a unique solution, we must impose constraints.\n\n*   **Periodic Boundary Conditions (PBCs)**: The fluctuation $\\widetilde{u}$ must be periodic. For the discrete problem, this means nodal displacements on opposite boundaries must be equal. For a node $j$ on a \"master\" boundary (e.g., $x=0$) and its corresponding node $k$ on the \"slave\" boundary (e.g., $x=1$), the constraint is $\\mathbf{u}_j - \\mathbf{u}_k = \\mathbf{0}$. We enforce these constraints using Lagrange multipliers. For each scalar degree of freedom (DOF) pair $(d_m, d_s)$, the constraint $d_m - d_s = 0$ is added to the system. On the $8 \\times 8$ mesh, we have $(n_y+1)=9$ node pairs on the left/right boundaries and $n_x=8$ node pairs on the top/bottom boundaries (excluding the corner already constrained by the left/right rule). This gives $(9 \\times 2) + (8 \\times 2) = 18 + 16 = 34$ scalar PBC constraints.\n\n*   **Zero-Mean Constraint**: The problem statement requires the average of the fluctuation field to be zero: $\\int_{\\Omega} \\widetilde{u}(x) \\, dV = \\mathbf{0}$. This provides two additional scalar constraints to remove the constant displacement mode. In discretized form, this is:\n$$\n\\int_{\\Omega} \\sum_{I} N_I(x) \\mathbf{u}_I \\, dV = \\sum_{I} \\left(\\int_{\\Omega} N_I(x) \\, dV\\right) \\mathbf{u}_I = \\mathbf{0}\n$$\nThe terms $w_I = \\int_{\\Omega} N_I(x) \\, dV$ are nodal integration weights, which can be pre-calculated by summing contributions from all elements adjacent to node $I$. The two constraints are $\\sum_I w_I u_{x,I} = 0$ and $\\sum_I w_I u_{y,I} = 0$.\n\nThese $34+2=36$ constraints are incorporated into a global constraint matrix $G$, where each row defines one linear constraint on the nodal DOF vector $\\mathbf{u}$. The final system is the saddle-point problem:\n$$\n\\begin{bmatrix}\nK & G^{\\top} \\\\\nG & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\nwhere $\\boldsymbol{\\lambda}$ is the vector of Lagrange multipliers. The total size of this system is $(N_{dof} + N_{con}) \\times (N_{dof} + N_{con})$, which for this problem is $(162 + 36) \\times (162 + 36) = 198 \\times 198$.\n\n**4. Verification Procedure**\n\nOnce the system is solved for the nodal fluctuations $\\mathbf{u}$, two verification checks are performed.\n\n*   **Mean Fluctuation Displacement**: The volume average of the fluctuation displacement is computed using the previously calculated nodal weights $w_I$:\n$$\n\\langle \\widetilde{u} \\rangle = \\frac{1}{|\\Omega|} \\int_{\\Omega} \\widetilde{u} \\, \\mathrm{d}V \\approx \\frac{1}{|\\Omega|} \\sum_{I} w_I \\mathbf{u}_I\n$$\nSince $|\\Omega|=1$, this is simply $\\sum_I w_I \\mathbf{u}_I$. The L2-norm of this vector is compared against the tolerance $10^{-10}$. In an exact implementation, this should be satisfied to machine precision as it is an explicitly enforced constraint.\n\n*   **Traction Anti-Periodicity**: The traction vector is $t(x) = \\sigma(x) n(x)$, where $\\sigma(x) = \\mathbb{C}(x) : (\\varepsilon(\\widetilde{u}(x)) + \\overline{\\varepsilon})$. The property of anti-periodicity, $t(x^+) + t(x^-) = \\mathbf{0}$, must hold for corresponding points $x^+$ and $x^-$ on opposite boundaries. We verify this numerically by computing the relative mismatch $\\eta$.\nThe calculation involves looping over pairs of corresponding boundary edges (left/right, top/bottom). On each edge, $2$-point Gauss quadrature is used. For each pair of corresponding Gauss points $(gp^+, gp^-)$:\n    1.  The full stress tensor $\\sigma$ is computed at $gp^+$ and $gp^-$. This involves evaluating the strain from the FE solution $\\mathbf{u}$, adding the macroscopic strain $\\overline{\\varepsilon}$, and applying the local constitutive law $\\mathbb{C}$.\n    2.  The tractions $t^+ = \\sigma^+ n^+$ and $t^- = \\sigma^- n^-$ are computed using the appropriate outward normal vectors.\n    3.  The squared norms $\\|t^+ + t^-\\|^2$ and $\\|t^+\\|^2 + \\|t^-\\|^2$ are computed and multiplied by the differential boundary element length (quadrature weight times Jacobian).\n    4.  These values are summed over all Gauss point pairs to form the numerator and denominator of $\\eta$. The final value of $\\eta$ is compared against the tolerance $10^{-8}$.\n\nThis comprehensive procedure allows for a rigorous verification of the implemented periodic boundary conditions.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Test suite from the problem statement\n    test_cases = [\n        # (gamma, E_in, E_out, nu)\n        (0.0, 5.0, 1.0, 0.3),\n        (0.02, 5.0, 1.0, 0.3),\n        (0.05, 10.0, 1.0, 0.3),\n        (0.02, 1.0, 5.0, 0.3),\n    ]\n\n    results = []\n    # Tolerances from the problem statement\n    mean_disp_tol = 1e-10\n    traction_mismatch_tol = 1e-8\n\n    for case in test_cases:\n        avg_disp_norm, eta = run_fem_case(*case)\n        is_valid = (avg_disp_norm = mean_disp_tol) and (eta = traction_mismatch_tol)\n        results.append(is_valid)\n    \n    # Format and print the final output exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_case(gamma, E_in, E_out, nu):\n    \"\"\"\n    Performs the full Finite Element Method simulation for a single test case.\n    \"\"\"\n    # 1. MESH and FEM PARAMETERS\n    nx, ny = 8, 8\n    num_nodes_x, num_nodes_y = nx + 1, ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_elements = nx * ny\n    num_dofs = 2 * num_nodes\n\n    # Domain and element dimensions\n    domain_L, domain_H = 1.0, 1.0\n    el_w, el_h = domain_L / nx, domain_H / ny\n\n    # Inclusion parameters\n    r_incl, center_incl = 0.2, np.array([0.5, 0.5])\n\n    # Gauss Quadrature (2x2 for area, 2-pt for edge)\n    gp_coords_1d = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\n    gp_weights_1d = np.array([1.0, 1.0])\n    \n    gp_coords_2d = np.array([[xi, eta] for xi in gp_coords_1d for eta in gp_coords_1d])\n    gp_weights_2d = np.array([w1 * w2 for w1 in gp_weights_1d for w2 in gp_weights_1d])\n\n    # 2. ASSEMBLE STIFFNESS MATRIX K AND FORCE VECTOR f\n    K = np.zeros((num_dofs, num_dofs))\n    f = np.zeros(num_dofs)\n    \n    # Macroscopic strain in Voigt notation [exx, eyy, gxy]\n    eps0 = np.array([0.0, 0.0, gamma])\n\n    def get_C_matrix(E, nu):\n        lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        mu = E / (2.0 * (1.0 + nu))\n        C = np.zeros((3, 3))\n        C[0, 0] = C[1, 1] = lam + 2 * mu\n        C[0, 1] = C[1, 0] = lam\n        C[2, 2] = mu\n        return C\n\n    C_in = get_C_matrix(E_in, nu)\n    C_out = get_C_matrix(E_out, nu)\n\n    def shape_functions(xi, eta):\n        N = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n        # Derivatives wrt xi, eta\n        dN_dxi = 0.25 * np.array([-(1-eta), (1-eta), (1+eta), -(1+eta)])\n        dN_deta = 0.25 * np.array([-(1-xi), -(1+xi), (1+xi), (1-xi)])\n        return N, dN_dxi, dN_deta\n\n    node_coords = np.array([[i * el_w, j * el_h] for j in range(num_nodes_y) for i in range(num_nodes_x)])\n\n    for el_y in range(ny):\n        for el_x in range(nx):\n            el_idx = el_y * nx + el_x\n            \n            # Node indices for the current element\n            node_idx_map = [\n                el_y * num_nodes_x + el_x,          # bottom-left\n                el_y * num_nodes_x + el_x + 1,      # bottom-right\n                (el_y + 1) * num_nodes_x + el_x + 1,  # top-right\n                (el_y + 1) * num_nodes_x + el_x       # top-left\n            ]\n            dof_idx_map = []\n            for n_idx in node_idx_map:\n                dof_idx_map.extend([2 * n_idx, 2 * n_idx + 1])\n\n            el_coords = node_coords[node_idx_map]\n\n            Ke = np.zeros((8, 8))\n            fe = np.zeros(8)\n            \n            for i in range(len(gp_coords_2d)):\n                xi, eta = gp_coords_2d[i]\n                weight = gp_weights_2d[i]\n\n                N, dN_dxi, dN_deta = shape_functions(xi, eta)\n                \n                # Jacobian matrix\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n                J_inv = np.linalg.inv(J)\n                \n                dN_dx = J_inv[0, 0] * dN_dxi + J_inv[0, 1] * dN_deta\n                dN_dy = J_inv[1, 0] * dN_dxi + J_inv[1, 1] * dN_deta\n\n                # Strain-displacement matrix B\n                B = np.zeros((3, 8))\n                for j in range(4):\n                    B[0, 2*j] = dN_dx[j]\n                    B[1, 2*j+1] = dN_dy[j]\n                    B[2, 2*j] = dN_dy[j]\n                    B[2, 2*j+1] = dN_dx[j]\n\n                # Determine material at GP\n                gp_global_coords = N @ el_coords\n                if np.linalg.norm(gp_global_coords - center_incl) = r_incl:\n                    C = C_in\n                else:\n                    C = C_out\n\n                Ke += B.T @ C @ B * weight * detJ\n                fe -= B.T @ C @ eps0 * weight * detJ\n\n            # Assemble into global matrices\n            K[np.ix_(dof_idx_map, dof_idx_map)] += Ke\n            f[dof_idx_map] += fe\n\n    # 3. CONSTRUCT CONSTRAINT MATRIX G\n    pbc_constraints = []\n    # Right-Left PBCs\n    for j in range(num_nodes_y):\n        master_node = j * num_nodes_x\n        slave_node = j * num_nodes_x + nx\n        pbc_constraints.append((2*master_node, 2*slave_node)) # u_x\n        pbc_constraints.append((2*master_node+1, 2*slave_node+1)) # u_y\n    # Top-Bottom PBCs\n    for i in range(nx): # Exclude top-right corner\n        master_node = i\n        slave_node = ny * num_nodes_x + i\n        pbc_constraints.append((2*master_node, 2*slave_node))\n        pbc_constraints.append((2*master_node+1, 2*slave_node+1))\n\n    num_pbc_con = len(pbc_constraints)\n    num_constraints = num_pbc_con + 2 # +2 for zero-mean\n    G = np.zeros((num_constraints, num_dofs))\n\n    for i, (m_dof, s_dof) in enumerate(pbc_constraints):\n        G[i, m_dof] = 1.0\n        G[i, s_dof] = -1.0\n\n    # Zero-mean constraints\n    nodal_weights = np.zeros(num_nodes)\n    for el_y in range(ny):\n        for el_x in range(nx):\n            node_idx_map = [el_y*num_nodes_x+el_x, el_y*num_nodes_x+el_x+1, (el_y+1)*num_nodes_x+el_x+1, (el_y+1)*num_nodes_x+el_x]\n            el_area = el_w * el_h\n            for n_idx in node_idx_map:\n                nodal_weights[n_idx] += el_area / 4.0\n\n    for i in range(num_nodes):\n        G[num_pbc_con, 2*i] = nodal_weights[i]\n        G[num_pbc_con+1, 2*i+1] = nodal_weights[i]\n\n    # 4. SOLVE THE SADDLE-POINT SYSTEM\n    system_size = num_dofs + num_constraints\n    A = np.zeros((system_size, system_size))\n    b = np.zeros(system_size)\n\n    A[:num_dofs, :num_dofs] = K\n    A[:num_dofs, num_dofs:] = G.T\n    A[num_dofs:, :num_dofs] = G\n    b[:num_dofs] = f\n\n    sol = np.linalg.solve(A, b)\n    u_tilde = sol[:num_dofs]\n\n    # 5. VERIFICATION\n    # Verification 1: Mean fluctuation displacement\n    avg_disp_x = np.sum(u_tilde[0::2] * nodal_weights)\n    avg_disp_y = np.sum(u_tilde[1::2] * nodal_weights)\n    avg_disp_norm = np.sqrt(avg_disp_x**2 + avg_disp_y**2)\n\n    # Verification 2: Traction anti-periodicity mismatch eta\n    num_mismatch_sq = 0.0\n    den_mismatch_sq = 0.0\n\n    def get_stress_at(point, u_tilde_vec):\n        # Find element containing the point\n        el_x = int(point[0] / el_w) if point[0]  1.0 else nx - 1\n        el_y = int(point[1] / el_h) if point[1]  1.0 else ny - 1\n        \n        node_idx_map = [\n            el_y * num_nodes_x + el_x, el_y * num_nodes_x + el_x + 1,\n            (el_y + 1) * num_nodes_x + el_x + 1, (el_y + 1) * num_nodes_x + el_x]\n        el_coords = node_coords[node_idx_map]\n        \n        dof_idx_map = []\n        for n_idx in node_idx_map:\n            dof_idx_map.extend([2 * n_idx, 2 * n_idx + 1])\n            \n        u_el = u_tilde_vec[dof_idx_map]\n\n        # Convert global coords to local coords (xi, eta)\n        center_el = np.mean(el_coords, axis=0)\n        xi = 2 * (point[0] - center_el[0]) / el_w\n        eta = 2 * (point[1] - center_el[1]) / el_h\n\n        N, dN_dxi, dN_deta = shape_functions(xi, eta)\n        J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n        J_inv = np.linalg.inv(J)\n        dN_dx = J_inv[0, 0] * dN_dxi + J_inv[0, 1] * dN_deta\n        dN_dy = J_inv[1, 0] * dN_dxi + J_inv[1, 1] * dN_deta\n        \n        B = np.zeros((3, 8))\n        for j in range(4):\n            B[0, 2*j] = dN_dx[j]\n            B[1, 2*j+1] = dN_dy[j]\n            B[2, 2*j] = dN_dy[j]\n            B[2, 2*j+1] = dN_dx[j]\n        \n        eps_tilde = B @ u_el\n        eps_total = eps_tilde + eps0\n        \n        C = C_in if np.linalg.norm(point - center_incl) = r_incl else C_out\n\n        sigma_voigt = C @ eps_total # [s_xx, s_yy, t_xy]\n        sigma_tensor = np.array([[sigma_voigt[0], sigma_voigt[2]], [sigma_voigt[2], sigma_voigt[1]]])\n        return sigma_tensor\n\n    # Left/Right boundaries\n    n_left, n_right = np.array([-1.0, 0.0]), np.array([1.0, 0.0])\n    for j in range(ny):\n        y_center = (j + 0.5) * el_h\n        dl = el_h\n        for i in range(len(gp_coords_1d)):\n            y_gp = y_center + gp_coords_1d[i] * dl / 2.0\n            w_gp = gp_weights_1d[i]\n            \n            p_left = np.array([0.0, y_gp])\n            p_right = np.array([1.0, y_gp])\n            \n            sigma_left = get_stress_at(p_left, u_tilde)\n            sigma_right = get_stress_at(p_right, u_tilde)\n\n            t_left = sigma_left @ n_left\n            t_right = sigma_right @ n_right\n\n            num_mismatch_sq += np.sum((t_right + t_left)**2) * w_gp * dl / 2.0\n            den_mismatch_sq += (np.sum(t_right**2) + np.sum(t_left**2)) * w_gp * dl / 2.0\n\n    # Bottom/Top boundaries\n    n_bottom, n_top = np.array([0.0, -1.0]), np.array([0.0, 1.0])\n    for i in range(nx):\n        x_center = (i + 0.5) * el_w\n        dl = el_w\n        for j in range(len(gp_coords_1d)):\n            x_gp = x_center + gp_coords_1d[j] * dl / 2.0\n            w_gp = gp_weights_1d[j]\n\n            p_bottom = np.array([x_gp, 0.0])\n            p_top = np.array([x_gp, 1.0])\n\n            sigma_bottom = get_stress_at(p_bottom, u_tilde)\n            sigma_top = get_stress_at(p_top, u_tilde)\n\n            t_bottom = sigma_bottom @ n_bottom\n            t_top = sigma_top @ n_top\n\n            num_mismatch_sq += np.sum((t_top + t_bottom)**2) * w_gp * dl / 2.0\n            den_mismatch_sq += (np.sum(t_top**2) + np.sum(t_bottom**2)) * w_gp * dl / 2.0\n\n    eta = np.sqrt(num_mismatch_sq) / max(np.sqrt(den_mismatch_sq), 1e-30)\n    \n    return avg_disp_norm, eta\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2546317"}, {"introduction": "This exercise integrates key concepts into a complete workflow for calculating the effective elastic properties of a composite material from its microstructure. Here, you will apply Kinematically Uniform Boundary Conditions (KUBCs) by prescribing specific macroscopic average strains $\\overline{\\boldsymbol{\\varepsilon}}$ on a two-dimensional RVE. By solving the microscale problem for two independent load cases and computing the resulting average stresses, you will assemble the effective stiffness matrix $\\mathbf{C}^{\\mathrm{H}}$ and subsequently determine the material's effective Poisson's ratios, gaining hands-on experience in the end-to-end process of computational homogenization [@problem_id:2546256].", "problem": "Consider a two-dimensional ($2$D) Representative Volume Element (RVE) of a linearly elastic heterogeneous medium under plane stress, to be analyzed by the Finite Element Method (FEM). The RVE is the unit square with coordinates $(x,y)\\in[0,1]\\times[0,1]$. The microstructure consists of a compliant matrix containing two orthogonal families of stiff inclusions modeled as periodic stripes aligned with the coordinate axes. A point $(x,y)$ lies in the stiff phase if either $(x \\bmod p_x)  t_x$ or $(y \\bmod p_y)  t_y$, where $p_x0$ and $p_y0$ are the stripe pitches and $t_x\\in[0,p_x]$, $t_y\\in[0,p_y]$ are the stripe thicknesses. Otherwise, the point is in the matrix phase. All material parameters are nondimensional.\n\nUse the following fundamental base:\n- Small-strain linear elasticity in plane stress: the strain tensor is $\\boldsymbol{\\varepsilon}=\\tfrac{1}{2}(\\nabla\\mathbf{u}+\\nabla\\mathbf{u}^{\\mathsf{T}})$, the Cauchy stress is $\\boldsymbol{\\sigma}=\\mathbb{C}(\\mathbf{x}):\\boldsymbol{\\varepsilon}$, and static equilibrium (no body forces) satisfies $\\nabla\\cdot\\boldsymbol{\\sigma}=\\mathbf{0}$.\n- Plane stress constitutive law for an isotropic phase with Young’s modulus $E$ and Poisson’s ratio $\\nu$ in Voigt notation $(\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy})$:\n$$\n\\mathbf{D}(E,\\nu)\\;=\\;\\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\tfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\nwith $\\boldsymbol{\\sigma}=\\mathbf{D}\\,\\boldsymbol{\\varepsilon}$, where $\\gamma_{xy}=2\\varepsilon_{xy}$ is the engineering shear strain.\n- Hill–Mandel macro-homogeneity condition and volume averaging: the macroscopic average stress $\\overline{\\boldsymbol{\\sigma}}$ and macroscopic strain $\\overline{\\boldsymbol{\\varepsilon}}$ are defined by\n$$\n\\overline{\\boldsymbol{\\sigma}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\\quad\n\\overline{\\boldsymbol{\\varepsilon}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\varepsilon}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\n$$\nand they are energetically conjugate, i.e., $\\overline{\\boldsymbol{\\sigma}}:\\overline{\\boldsymbol{\\varepsilon}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega$.\n- Under kinematically uniform boundary conditions (KUBC), imposing the affine displacement $\\mathbf{u}(\\mathbf{x})=\\overline{\\boldsymbol{\\varepsilon}}\\,\\mathbf{x}$ on the boundary $\\partial\\Omega$ ensures $\\overline{\\boldsymbol{\\varepsilon}}$ equals the imposed macroscopic strain, and permits computation of $\\overline{\\boldsymbol{\\sigma}}$ by volume averaging.\n\nTask. Starting from these principles, implement a plane-stress computational homogenization procedure on a structured bilinear quadrilateral mesh to compute the effective Poisson ratios of the heterogeneous medium by:\n- Applying two independent macroscopic strain states via KUBC,\n- Solving the equilibrium in the heterogeneous RVE by FEM for each load case,\n- Averaging the resulting microscopic stress fields to obtain the first two columns of the effective stiffness matrix $\\mathbf{C}^{\\mathrm{H}}$,\n- Inverting the normal sub-block to obtain the effective compliance sub-block $\\mathbf{S}^{\\mathrm{H}}$,\n- Extracting the macroscopic Poisson ratios.\n\nPrescribe the two independent macroscopic strain states in Voigt form as:\n- Load case $\\mathcal{A}$: $\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{A}}=[\\varepsilon_{0},\\,0,\\,0]^{\\mathsf{T}}$,\n- Load case $\\mathcal{B}$: $\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{B}}=[0,\\,\\varepsilon_{0},\\,0]^{\\mathsf{T}}$,\nwith a given small strain amplitude $\\varepsilon_{0}0$. Impose KUBC by prescribing boundary displacements\n$$\nu_x(x,y)=\\overline{\\varepsilon}_{xx}\\,x+\\tfrac{1}{2}\\,\\overline{\\gamma}_{xy}\\,y,\\quad\nu_y(x,y)=\\tfrac{1}{2}\\,\\overline{\\gamma}_{xy}\\,x+\\overline{\\varepsilon}_{yy}\\,y\n$$\non $\\partial\\Omega$ for each load case.\n\nLet $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{A}}$ and $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{B}}$ denote the volume averages of the microscopic stress fields computed from the corresponding FEM solutions. Construct the effective in-plane normal stiffness sub-matrix\n$$\n\\mathbf{C}^{\\mathrm{H}}_{nn}=\n\\begin{bmatrix}\nC^{\\mathrm{H}}_{11}  C^{\\mathrm{H}}_{12}\\\\\nC^{\\mathrm{H}}_{21}  C^{\\mathrm{H}}_{22}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\overline{\\sigma}^{\\mathcal{A}}_{xx}/\\varepsilon_{0}  \\overline{\\sigma}^{\\mathcal{B}}_{xx}/\\varepsilon_{0}\\\\\n\\overline{\\sigma}^{\\mathcal{A}}_{yy}/\\varepsilon_{0}  \\overline{\\sigma}^{\\mathcal{B}}_{yy}/\\varepsilon_{0}\n\\end{bmatrix},\n$$\nthen invert it to obtain the effective in-plane compliance\n$$\n\\mathbf{S}^{\\mathrm{H}}_{nn}=(\\mathbf{C}^{\\mathrm{H}}_{nn})^{-1}=\n\\begin{bmatrix}\nS^{\\mathrm{H}}_{11}  S^{\\mathrm{H}}_{12}\\\\\nS^{\\mathrm{H}}_{21}  S^{\\mathrm{H}}_{22}\n\\end{bmatrix}.\n$$\nDefine the effective Poisson ratios (under plane stress) by\n$$\n\\nu^{\\mathrm{H}}_{xy}=-\\frac{S^{\\mathrm{H}}_{21}}{S^{\\mathrm{H}}_{11}},\\qquad\n\\nu^{\\mathrm{H}}_{yx}=-\\frac{S^{\\mathrm{H}}_{12}}{S^{\\mathrm{H}}_{22}}.\n$$\n\nNumerical discretization requirements:\n- Mesh: a structured tensor-product grid with $n_x\\times n_y$ bilinear quadrilateral elements covering $[0,1]\\times[0,1]$. Use standard $2\\times 2$ Gauss integration.\n- Material: matrix phase with $(E_m,\\nu_m)$ and inclusion phase with $(E_s,\\nu_s)$, assigned at integration points by the stripe criterion above.\n- Boundary conditions: KUBC as stated, with no body forces and no tractions.\n- Unknowns: two displacement components at each node.\n- Post-processing: compute volume-averaged stresses by Gauss integration and form $\\mathbf{C}^{\\mathrm{H}}_{nn}$ and $\\mathbf{S}^{\\mathrm{H}}_{nn}$.\n\nTest suite. Your program must run the following four cases and report the pair $[\\nu^{\\mathrm{H}}_{xy},\\nu^{\\mathrm{H}}_{yx}]$ for each, rounded to $6$ decimals:\n- Case $\\#1$ (happy path, moderate contrast): $(n_x,n_y)=(12,12)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(100.0,0.30)$, $(p_x,p_y)=(0.25,0.25)$, $(t_x,t_y)=(0.05,0.05)$, $\\varepsilon_0=0.01$.\n- Case $\\#2$ (matrix only, boundary case): $(n_x,n_y)=(10,10)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(100.0,0.30)$, $(p_x,p_y)=(0.25,0.25)$, $(t_x,t_y)=(0.0,0.0)$, $\\varepsilon_0=0.01$.\n- Case $\\#3$ (high contrast, thin stripes): $(n_x,n_y)=(16,16)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(10000.0,0.30)$, $(p_x,p_y)=(0.2,0.2)$, $(t_x,t_y)=(0.02,0.02)$, $\\varepsilon_0=0.005$.\n- Case $\\#4$ (anisotropic stripe thickness): $(n_x,n_y)=(14,10)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(1000.0,0.30)$, $(p_x,p_y)=(0.25,0.25)$, $(t_x,t_y)=(0.02,0.12)$, $\\varepsilon_0=0.01$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, in the order of the test suite, for example\n$$\n[[\\nu^{\\mathrm{H}}_{xy,\\#1},\\nu^{\\mathrm{H}}_{yx,\\#1}],[\\nu^{\\mathrm{H}}_{xy,\\#2},\\nu^{\\mathrm{H}}_{yx,\\#2}],[\\nu^{\\mathrm{H}}_{xy,\\#3},\\nu^{\\mathrm{H}}_{yx,\\#3}],[\\nu^{\\mathrm{H}}_{xy,\\#4},\\nu^{\\mathrm{H}}_{yx,\\#4}]],\n$$\nwith each float rounded to $6$ decimals, and no additional text. For example, a valid output skeleton is\n$$\n[[0.123456,0.123456],[0.123456,0.123456],[0.123456,0.123456],[0.123456,0.123456]].\n$$", "solution": "The problem presented is a well-posed exercise in computational homogenization for a linearly elastic composite material. The objective is to compute the effective in-plane Poisson's ratios of a heterogeneous medium using the Finite Element Method (FEM) on a Representative Volume Element (RVE). The procedure is scientifically sound and follows standard practices in computational solid mechanics.\n\nThe foundation of the Finite Element Method for this static linear elasticity problem is the principle of virtual work, which is the weak form of the equilibrium equation $\\nabla\\cdot\\boldsymbol{\\sigma}=\\mathbf{0}$. For a body $\\Omega$ with boundary $\\partial\\Omega$ and no body forces, the principle states that for any kinematically admissible virtual displacement field $\\delta\\mathbf{u}$ that vanishes on the part of the boundary with prescribed displacements, the internal virtual work equals the external virtual work:\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\mathbf{t}\\cdot\\delta\\mathbf{u}\\,\\mathrm{d}S\n$$\nwhere $\\boldsymbol{\\varepsilon}$ is the strain tensor corresponding to the displacement field $\\mathbf{u}$, $\\delta\\boldsymbol{\\varepsilon}$ is the virtual strain tensor, $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor, and $\\mathbf{t}$ is the prescribed traction on the boundary portion $\\partial\\Omega_t$. In this problem, displacements are prescribed on the entire boundary $\\partial\\Omega$, so $\\partial\\Omega_t=\\emptyset$ and the right-hand side is zero.\n\nThe solution domain, the unit square RVE $\\Omega = [0,1]\\times[0,1]$, is discretized into a structured mesh of $n_x \\times n_y$ bilinear quadrilateral elements. Within each element $\\Omega_e$, the displacement field $\\mathbf{u}(\\mathbf{x})$ is approximated by interpolating the nodal displacements $\\mathbf{U}^e$ using shape functions $N_i$:\n$$\n\\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{4} N_i(\\mathbf{x}) \\mathbf{u}_i^e\n$$\nwhere $\\mathbf{u}_i^e$ is the displacement vector at the $i$-th node of the element. The strain field within the element is then related to the nodal displacements via the strain-displacement matrix $\\mathbf{B}(\\mathbf{x})$:\n$$\n\\boldsymbol{\\varepsilon}(\\mathbf{x}) = \\sum_{i=1}^{4} \\mathbf{B}_i(\\mathbf{x}) \\mathbf{u}_i^e = \\mathbf{B}(\\mathbf{x}) \\mathbf{U}^e\n$$\nHere, for plane stress in Voigt notation, $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$, and the matrix $\\mathbf{B}_i$ for node $i$ is:\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\partial N_i / \\partial x  0 \\\\ 0  \\partial N_i / \\partial y \\\\ \\partial N_i / \\partial y  \\partial N_i / \\partial x \\end{bmatrix}\n$$\nThe linear constitutive relation $\\boldsymbol{\\sigma} = \\mathbf{D}(\\mathbf{x})\\boldsymbol{\\varepsilon}$ links strain to stress, where $\\mathbf{D}(\\mathbf{x})$ is the material stiffness matrix, which is position-dependent due to the microstructure.\n\nSubstituting the FE approximations into the weak form yields a linear system of algebraic equations $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$, where $\\mathbf{U}$ is the global vector of nodal displacements, $\\mathbf{K}$ is the global stiffness matrix, and $\\mathbf{F}$ is the global force vector. The global stiffness matrix is assembled from element stiffness matrices $\\mathbf{k}^e$:\n$$\n\\mathbf{k}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\mathsf{T}}(\\mathbf{x}) \\mathbf{D}(\\mathbf{x}) \\mathbf{B}(\\mathbf{x}) \\,\\mathrm{d}\\Omega\n$$\nThis integral is computed numerically using $2 \\times 2$ Gauss quadrature. At each Gauss point, the coordinates $(x,y)$ are calculated to determine whether the point lies in the stiff phase or the matrix phase according to the rule $(x \\bmod p_x)  t_x$ or $(y \\bmod p_y)  t_y$. The corresponding material properties $(E_s, \\nu_s)$ or $(E_m, \\nu_m)$ are used to construct the $\\mathbf{D}$ matrix for that point.\n\nKinematically Uniform Boundary Conditions (KUBC) are imposed by prescribing the displacement of all nodes on the boundary $\\partial\\Omega$ according to the affine transformation $\\mathbf{u}(\\mathbf{x}) = \\overline{\\boldsymbol{\\varepsilon}}\\cdot\\mathbf{x}$, where $\\overline{\\boldsymbol{\\varepsilon}}$ is the prescribed macroscopic strain tensor. This requires partitioning the global system of equations. The global displacement vector $\\mathbf{U}$ is split into unknown displacements of interior nodes, $\\mathbf{U}_I$, and known displacements of boundary nodes, $\\mathbf{U}_B$. The system $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ is partitioned as:\n$$\n\\begin{bmatrix} \\mathbf{K}_{II}  \\mathbf{K}_{IB} \\\\ \\mathbf{K}_{BI}  \\mathbf{K}_{BB} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{U}_I \\\\ \\mathbf{U}_B \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{F}_I \\\\ \\mathbf{F}_B \\end{Bmatrix}\n$$\nWith no body forces, the forces on interior nodes $\\mathbf{F}_I$ are zero. The unknown interior displacements are found by solving the reduced system:\n$$\n\\mathbf{K}_{II} \\mathbf{U}_I = -\\mathbf{K}_{IB} \\mathbf{U}_B\n$$\nOnce $\\mathbf{U}_I$ is computed, the full displacement field is known.\n\nThe next step is to compute the volume-averaged stress tensor $\\overline{\\boldsymbol{\\sigma}}$. Because the RVE has unit area ($|\\Omega|=1$), this is simply the integral of the microscopic stress over the domain:\n$$\n\\overline{\\boldsymbol{\\sigma}} = \\int_{\\Omega} \\boldsymbol{\\sigma}(\\mathbf{x}) \\,\\mathrm{d}\\Omega = \\sum_{e} \\int_{\\Omega_e} \\mathbf{D}(\\mathbf{x}) \\mathbf{B}(\\mathbf{x}) \\mathbf{U}^e \\,\\mathrm{d}\\Omega\n$$\nThis is also evaluated numerically via Gauss quadrature over all elements.\n\nThis entire procedure is performed twice for two independent macroscopic strain states:\n1.  Load Case $\\mathcal{A}$: $\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{A}} = [\\varepsilon_0, 0, 0]^{\\mathsf{T}}$ (uniaxial strain in $x$-direction). The FEM solution yields the average stress vector $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{A}} = [\\overline{\\sigma}^{\\mathcal{A}}_{xx}, \\overline{\\sigma}^{\\mathcal{A}}_{yy}, \\overline{\\sigma}^{\\mathcal{A}}_{xy}]^{\\mathsf{T}}$.\n2.  Load Case $\\mathcal{B}$: $\\overline{\\boldsymbolvarepsilon}}^{\\mathcal{B}} = [0, \\varepsilon_0, 0]^{\\mathsf{T}}$ (uniaxial strain in $y$-direction). The FEM solution yields $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{B}} = [\\overline{\\sigma}^{\\mathcal{B}}_{xx}, \\overline{\\sigma}^{\\mathcal{B}}_{yy}, \\overline{\\sigma}^{\\mathcal{B}}_{xy}]^{\\mathsf{T}}$.\n\nFrom the relationship $\\overline{\\boldsymbol{\\sigma}} = \\mathbf{C}^{\\mathrm{H}}\\overline{\\boldsymbol{\\varepsilon}}$, the first two columns of the effective stiffness matrix $\\mathbf{C}^{\\mathrm{H}}$ are determined. The in-plane normal sub-matrix is constructed as specified:\n$$\n\\mathbf{C}^{\\mathrm{H}}_{nn} = \\begin{bmatrix} C^{\\mathrm{H}}_{11}  C^{\\mathrm{H}}_{12}\\\\ C^{\\mathrm{H}}_{21}  C^{\\mathrm{H}}_{22} \\end{bmatrix} = \\frac{1}{\\varepsilon_0} \\begin{bmatrix} \\overline{\\sigma}^{\\mathcal{A}}_{xx}  \\overline{\\sigma}^{\\mathcal{B}}_{xx}\\\\ \\overline{\\sigma}^{\\mathcal{A}}_{yy}  \\overline{\\sigma}^{\\mathcal{B}}_{yy} \\end{bmatrix}\n$$\nThe corresponding effective compliance sub-matrix $\\mathbf{S}^{\\mathrm{H}}_{nn}$ is found by inversion: $\\mathbf{S}^{\\mathrm{H}}_{nn} = (\\mathbf{C}^{\\mathrm{H}}_{nn})^{-1}$.\n\nFinally, the effective Poisson's ratios are extracted from the compliance matrix. By definition, $\\nu_{ij} = -\\varepsilon_{jj}/\\varepsilon_{ii}$ under uniaxial stress $\\sigma_{ii}$. In terms of compliance components, this translates to:\n$$\n\\nu^{\\mathrm{H}}_{xy} = -\\frac{S^{\\mathrm{H}}_{21}}{S^{\\mathrm{H}}_{11}}, \\qquad \\nu^{\\mathrm{H}}_{yx} = -\\frac{S^{\\mathrm{H}}_{12}}{S^{\\mathrm{H}}_{22}}\n$$\nThis completes the computational homogenization procedure. The implemented code will follow these steps for each test case provided.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the computational homogenization for all test cases.\n    \"\"\"\n    test_cases = [\n        {'nx': 12, 'ny': 12, 'mat_m': (1.0, 0.30), 'mat_s': (100.0, 0.30), 'geo': (0.25, 0.25, 0.05, 0.05), 'eps0': 0.01},\n        {'nx': 10, 'ny': 10, 'mat_m': (1.0, 0.30), 'mat_s': (100.0, 0.30), 'geo': (0.25, 0.25, 0.0, 0.0), 'eps0': 0.01},\n        {'nx': 16, 'ny': 16, 'mat_m': (1.0, 0.30), 'mat_s': (10000.0, 0.30), 'geo': (0.2, 0.2, 0.02, 0.02), 'eps0': 0.005},\n        {'nx': 14, 'ny': 10, 'mat_m': (1.0, 0.30), 'mat_s': (1000.0, 0.30), 'geo': (0.25, 0.25, 0.02, 0.12), 'eps0': 0.01}\n    ]\n\n    all_results = []\n\n    # Gauss quadrature points and weights for a 2x2 scheme\n    gauss_points = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_weights = np.array([1.0, 1.0])\n\n    for case in test_cases:\n        nx, ny = case['nx'], case['ny']\n        (E_m, nu_m) = case['mat_m']\n        (E_s, nu_s) = case['mat_s']\n        (px, py, tx, ty) = case['geo']\n        eps0 = case['eps0']\n\n        def get_D_matrix(E, nu):\n            factor = E / (1 - nu**2)\n            return factor * np.array([[1, nu, 0], [nu, 1, 0], [0, 0, (1 - nu)/2]])\n\n        D_m = get_D_matrix(E_m, nu_m)\n        D_s = get_D_matrix(E_s, nu_s)\n\n        def is_stiff(x, y):\n            if tx > 0 and (np.fmod(x, px)  tx):\n                return True\n            if ty > 0 and (np.fmod(y, py)  ty):\n                return True\n            return False\n\n        def get_fem_solution(macro_strain_voigt):\n            macro_eps_xx, macro_eps_yy, macro_gamma_xy = macro_strain_voigt\n            \n            hx, hy = 1.0/nx, 1.0/ny\n            num_nodes = (nx + 1) * (ny + 1)\n            num_dofs = 2 * num_nodes\n            \n            K = lil_matrix((num_dofs, num_dofs))\n            \n            node_coords = np.zeros(((nx + 1) * (ny + 1), 2))\n            for i in range(nx + 1):\n                for j in range(ny + 1):\n                    node_idx = i * (ny + 1) + j\n                    node_coords[node_idx] = [i * hx, j * hy]\n\n            for el_i in range(nx):\n                for el_j in range(ny):\n                    node_indices = [\n                        el_i * (ny + 1) + el_j,          # bottom-left\n                        (el_i + 1) * (ny + 1) + el_j,    # bottom-right\n                        (el_i + 1) * (ny + 1) + (el_j + 1),# top-right\n                        el_i * (ny + 1) + (el_j + 1)       # top-left\n                    ]\n                    dof_indices = []\n                    for idx in node_indices:\n                        dof_indices.extend([2 * idx, 2 * idx + 1])\n                    \n                    el_coords = node_coords[node_indices]\n                    ke = np.zeros((8, 8))\n\n                    for i, xi in enumerate(gauss_points):\n                        for j, eta in enumerate(gauss_points):\n                            # Shape functions and their derivatives in master coords\n                            N_deriv_master = 0.25 * np.array([\n                                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n                            ])\n                            \n                            J = N_deriv_master @ el_coords\n                            detJ = np.linalg.det(J)\n                            invJ = np.linalg.inv(J)\n                            \n                            N_deriv_physical = invJ @ N_deriv_master\n                            \n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = N_deriv_physical[0, k]\n                                B[1, 2*k+1] = N_deriv_physical[1, k]\n                                B[2, 2*k] = N_deriv_physical[1, k]\n                                B[2, 2*k+1] = N_deriv_physical[0, k]\n\n                            # Material properties at Gauss point\n                            N_shape = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                            gp_coord = N_shape @ el_coords\n                            D = D_s if is_stiff(gp_coord[0], gp_coord[1]) else D_m\n\n                            ke += B.T @ D @ B * detJ * gauss_weights[i] * gauss_weights[j]\n\n                    for r in range(8):\n                        for c in range(8):\n                            K[dof_indices[r], dof_indices[c]] += ke[r, c]\n            \n            K = K.tocsc()\n            \n            boundary_dofs = []\n            for i in range(nx + 1):\n                for j in range(ny + 1):\n                    if i == 0 or i == nx or j == 0 or j == ny:\n                        node_idx = i * (ny + 1) + j\n                        boundary_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n            \n            all_dofs = np.arange(num_dofs)\n            interior_dofs = np.setdiff1d(all_dofs, boundary_dofs)\n            \n            U_b = np.zeros(len(boundary_dofs))\n            for i, dof in enumerate(boundary_dofs):\n                node_idx = dof // 2\n                coord = node_coords[node_idx]\n                if dof % 2 == 0: # x-displacement\n                    U_b[i] = macro_eps_xx * coord[0] + 0.5 * macro_gamma_xy * coord[1]\n                else: # y-displacement\n                    U_b[i] = 0.5 * macro_gamma_xy * coord[0] + macro_eps_yy * coord[1]\n\n            K_II = K[interior_dofs, :][:, interior_dofs]\n            K_IB = K[interior_dofs, :][:, boundary_dofs]\n            \n            F_eff = -K_IB @ U_b\n            \n            U_I = spsolve(K_II, F_eff)\n            \n            U = np.zeros(num_dofs)\n            U[interior_dofs] = U_I\n            U[boundary_dofs] = U_b\n\n            # Post-processing: stress averaging\n            avg_stress = np.zeros(3)\n            for el_i in range(nx):\n                for el_j in range(ny):\n                    node_indices = [el_i*(ny+1)+el_j, (el_i+1)*(ny+1)+el_j, (el_i+1)*(ny+1)+el_j+1, el_i*(ny+1)+el_j+1]\n                    dof_indices = []\n                    for idx in node_indices:\n                        dof_indices.extend([2 * idx, 2 * idx + 1])\n\n                    el_coords = node_coords[node_indices]\n                    el_U = U[dof_indices]\n                    \n                    for i, xi in enumerate(gauss_points):\n                        for j, eta in enumerate(gauss_points):\n                            N_deriv_master = 0.25 * np.array([ [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)], [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)] ])\n                            J = N_deriv_master @ el_coords\n                            detJ = np.linalg.det(J)\n                            invJ = np.linalg.inv(J)\n                            N_deriv_physical = invJ @ N_deriv_master\n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = N_deriv_physical[0, k]; B[1, 2*k+1] = N_deriv_physical[1, k]; B[2, 2*k] = N_deriv_physical[1, k]; B[2, 2*k+1] = N_deriv_physical[0, k]\n\n                            N_shape = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                            gp_coord = N_shape @ el_coords\n                            D = D_s if is_stiff(gp_coord[0], gp_coord[1]) else D_m\n\n                            strain = B @ el_U\n                            stress = D @ strain\n                            avg_stress += stress * detJ * gauss_weights[i] * gauss_weights[j]\n            return avg_stress\n\n        # Load Case A: Uniaxial strain in x\n        avg_stress_A = get_fem_solution([eps0, 0.0, 0.0])\n        # Load Case B: Uniaxial strain in y\n        avg_stress_B = get_fem_solution([0.0, eps0, 0.0])\n\n        C_H_11 = avg_stress_A[0] / eps0\n        C_H_21 = avg_stress_A[1] / eps0\n        C_H_12 = avg_stress_B[0] / eps0\n        C_H_22 = avg_stress_B[1] / eps0\n\n        C_H_nn = np.array([[C_H_11, C_H_12], [C_H_21, C_H_22]])\n        S_H_nn = np.linalg.inv(C_H_nn)\n\n        nu_H_xy = -S_H_nn[1, 0] / S_H_nn[0, 0]\n        nu_H_yx = -S_H_nn[0, 1] / S_H_nn[1, 1]\n        \n        all_results.append(f\"[{nu_H_xy:.6f},{nu_H_yx:.6f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2546256"}]}