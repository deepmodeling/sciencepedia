{"hands_on_practices": [{"introduction": "Cohesive Zone Models are powerful but require accurate parameters to be predictive. This practice demonstrates a fundamental process in computational fracture mechanics: calibrating a cohesive law using experimental data. By analyzing hypothetical measurements from a Double Cantilever Beam (DCB) test, you will apply principles from beam theory and fracture mechanics to determine the critical fracture energy $G_{Ic}$ and peak traction $\\sigma_c$ for a triangular cohesive law, bridging the gap between physical experiments and numerical models [@problem_id:2544709].", "problem": "A Double Cantilever Beam (DCB) test is performed on a symmetric laminate with a precrack along a weak interface to characterize a Mode I cohesive zone law for delamination. The objective is to identify parameters of a triangular traction–separation law in normal opening for a cohesive zone model (CZM): the critical energy release rate $G_{I c}$, the peak normal traction $\\sigma_{c}$, the final separation $\\delta_{f}$, and the initial penalty stiffness $K$ (normal mode). Assume linear elasticity, small strains, negligible shear deformation, and negligible root rotation. Use Euler–Bernoulli beam theory and the Irwin–Kies relation for energy release rate. Two identical arms of thickness $h$ and width $b$ are made of an isotropic linear elastic solid with Young’s modulus $E$. The applied load $P$ is the force applied to each arm, and the measured opening $\\delta$ is the relative opening between the two load points.\n\nGiven data:\n- Geometry and material: $E = 70 \\times 10^{9}$, $b = 0.020$, $h = 0.003$.\n- Crack length at the onset of crack growth: $a = 0.050$.\n- Measured load and opening at the onset of growth: $P_{\\text{on}} = 60$, $\\delta_{\\text{on}} = 0.0018$.\n- Measured initial (pre-damage) linear response at the same crack length: $P_{\\ell} = 30$, $\\delta_{\\ell} = 0.00090$.\n- Final separation at complete decohesion from digital image correlation: $\\delta_{f} = 20 \\times 10^{-6}$.\n- For matching initial slope to determine the penalty $K$, approximate the interface contribution by an effective linear spring of length $L_{\\text{eff}} = 0.010$ acting in series with the bending compliance of the uncracked arms.\n\nTasks:\n1) Using the Irwin–Kies relation for Mode I, $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$, together with Euler–Bernoulli beam theory for two identical cantilevers, derive a closed-form expression for $G_{I}$ in terms of $P$, $\\delta$, $b$, and $a$, and evaluate $G_{I c}$ at the onset condition.\n2) For a triangular traction–separation law in Mode I, use the area condition $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$ to compute $\\sigma_{c}$.\n3) Determine the penalty stiffness $K$ by matching the initial slope: model the intact structure as the series combination of the bending compliance of the DCB arms at crack length $a$ and an effective cohesive spring of stiffness $k_{c} = b K L_{\\text{eff}}$. Use the measured initial compliance $C_{\\exp} = \\delta_{\\ell}/P_{\\ell}$ to solve for $K$.\n\nReport the ordered triple $\\left(G_{I c},\\,\\sigma_{c},\\,K\\right)$ rounded to three significant figures, expressing $G_{I c}$ in $\\text{J}\\,\\text{m}^{-2}$, $\\sigma_{c}$ in $\\text{MPa}$, and $K$ in $\\text{N}\\,\\text{mm}^{-3}$. Do not include units in your final boxed answer; the order of entries must follow the order specified here.", "solution": "The problem statement is first subjected to a rigorous validation.\n\nStep 1: Extracted Givens.\n- Material property: Young’s modulus $E = 70 \\times 10^{9}$.\n- Geometric properties: beam width $b = 0.020$, beam thickness (single arm) $h = 0.003$.\n- Crack length at onset of growth: $a = 0.050$.\n- Measured data at onset of growth: load $P_{\\text{on}} = 60$, opening $\\delta_{\\text{on}} = 0.0018$.\n- Measured data in the linear elastic regime for the same crack length: load $P_{\\ell} = 30$, opening $\\delta_{\\ell} = 0.00090$.\n- Final separation at complete failure: $\\delta_{f} = 20 \\times 10^{-6}$.\n- Effective length for penalty stiffness calculation: $L_{\\text{eff}} = 0.010$.\n- Governing relations: Irwin–Kies relation $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$, Euler–Bernoulli beam theory, triangular cohesive law area $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$, and series compliance model for initial stiffness $C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$ where $k_{c} = \\frac{1}{C_{\\text{coh}}} = b K L_{\\text{eff}}$.\n- Assumptions: linear elasticity, small strains, negligible shear deformation, negligible root rotation. All numerical values are assumed to be in base SI units (meters, Newtons, Pascals) unless specified otherwise.\n\nStep 2: Validation.\nThe problem is scientifically grounded, employing standard principles of linear elastic fracture mechanics and beam theory to analyze a Double Cantilever Beam (DCB) test, a common experimental procedure. The provided data are self-consistent; for instance, the compliance calculated from the linear response point, $C_{\\ell} = \\delta_{\\ell} / P_{\\ell} = 0.00090 / 30 = 3 \\times 10^{-5}$, is identical to the compliance at the onset point, $C_{\\text{on}} = \\delta_{\\text{on}} / P_{\\text{on}} = 0.0018 / 60 = 3 \\times 10^{-5}$, which is physically correct as the onset of growth marks the end of the linear regime. The problem is well-posed, objective, and contains sufficient information for a unique solution. It does not violate any of the specified invalidity criteria.\n\nStep 3: Verdict.\nThe problem is valid. A solution will be furnished.\n\nThe solution proceeds by addressing the three specified tasks in order.\n\nTask 1: Derivation of $G_{I}$ and calculation of $G_{I c}$.\nAccording to Euler-Bernoulli beam theory, the deflection $w$ at the end of a single cantilever beam of length $a$ under a load $P$ is given by:\n$$w = \\frac{Pa^{3}}{3EI}$$\nwhere $E$ is the Young's modulus and $I$ is the second moment of area of the beam's cross-section. For a rectangular cross-section of width $b$ and thickness $h$, $I = \\frac{bh^{3}}{12}$. The DCB specimen consists of two such beams, so the total opening $\\delta$ at the load points is twice the deflection of a single arm:\n$$\\delta = 2w = \\frac{2Pa^{3}}{3EI} = \\frac{2Pa^{3}}{3E \\left( \\frac{bh^{3}}{12} \\right)} = \\frac{8Pa^{3}}{Ebh^{3}}$$\nThe compliance, $C$, of the specimen is defined as the ratio of opening to load, $C = \\delta/P$.\n$$C(a) = \\frac{8a^{3}}{Ebh^{3}}$$\nThe problem specifies using the Irwin–Kies relation for the Mode I energy release rate, $G_{I}$:\n$$G_{I} = \\frac{P^{2}}{2b} \\frac{dC}{da}$$\nWe compute the derivative of the compliance with respect to the crack length $a$:\n$$\\frac{dC}{da} = \\frac{d}{da} \\left( \\frac{8a^{3}}{Ebh^{3}} \\right) = \\frac{24a^{2}}{Ebh^{3}}$$\nSubstituting this derivative into the Irwin–Kies relation gives an expression for $G_{I}$:\n$$G_{I} = \\frac{P^{2}}{2b} \\left( \\frac{24a^{2}}{Ebh^{3}} \\right) = \\frac{12P^{2}a^{2}}{b^{2}Eh^{3}}$$\nTo express $G_{I}$ in terms of $P$, $\\delta$, $b$, and $a$ as requested, we use the compliance relation $C = \\delta/P$ and note that $\\frac{dC}{da} = 3 \\frac{C}{a}$. Thus:\n$$G_{I} = \\frac{P^{2}}{2b} \\left( 3 \\frac{C}{a} \\right) = \\frac{3P^{2}}{2ab} \\left( \\frac{\\delta}{P} \\right) = \\frac{3P\\delta}{2ab}$$\nThis is the required closed-form expression. The critical energy release rate, $G_{I c}$, is evaluated at the onset of crack growth using the provided data: $P_{\\text{on}} = 60\\,\\text{N}$, $\\delta_{\\text{on}} = 0.0018\\,\\text{m}$, $a = 0.050\\,\\text{m}$, and $b = 0.020\\,\\text{m}$.\n$$G_{I c} = \\frac{3 P_{\\text{on}} \\delta_{\\text{on}}}{2ab} = \\frac{3 \\times 60 \\times 0.0018}{2 \\times 0.050 \\times 0.020} = \\frac{0.324}{0.002} = 162\\,\\text{J}\\,\\text{m}^{-2}$$\n\nTask 2: Computation of the peak normal traction $\\sigma_{c}$.\nFor a triangular traction-separation law, the fracture energy $G_{I c}$ is the area of the triangle defined by the peak traction $\\sigma_{c}$ and the final separation $\\delta_{f}$:\n$$G_{I c} = \\frac{1}{2} \\sigma_{c} \\delta_{f}$$\nSolving for $\\sigma_{c}$:\n$$\\sigma_{c} = \\frac{2G_{I c}}{\\delta_{f}}$$\nUsing the calculated value $G_{I c} = 162\\,\\text{J}\\,\\text{m}^{-2}$ and the given final separation $\\delta_{f} = 20 \\times 10^{-6}\\,\\text{m}$:\n$$\\sigma_{c} = \\frac{2 \\times 162}{20 \\times 10^{-6}} = \\frac{324}{20 \\times 10^{-6}} = 16.2 \\times 10^{6}\\,\\text{Pa}$$\nAs $1\\,\\text{MPa} = 10^{6}\\,\\text{Pa}$, the peak traction is $\\sigma_{c} = 16.2\\,\\text{MPa}$.\n\nTask 3: Determination of the penalty stiffness $K$.\nThe initial response of the specimen is modeled as the series combination of the beam bending compliance, $C_{\\text{beam}}$, and an effective cohesive compliance, $C_{\\text{coh}}$. The total measured compliance, $C_{\\exp}$, is the sum of these two:\n$$C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$$\nThe experimental compliance is determined from the linear response data:\n$$C_{\\exp} = \\frac{\\delta_{\\ell}}{P_{\\ell}} = \\frac{0.00090}{30} = 3.0 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\nThe beam bending compliance is given by the theoretical expression derived previously:\n$$C_{\\text{beam}} = \\frac{8a^{3}}{Ebh^{3}} = \\frac{8 \\times (0.050)^{3}}{(70 \\times 10^{9}) \\times 0.020 \\times (0.003)^{3}} = \\frac{1 \\times 10^{-3}}{37.8} \\approx 2.6455 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\nThe cohesive compliance is found by subtraction:\n$$C_{\\text{coh}} = C_{\\exp} - C_{\\text{beam}} = (3.0 \\times 10^{-5}) - (2.6455 \\times 10^{-5}) = 0.3545 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\nThe cohesive compliance is related to the penalty stiffness $K$ through an effective spring stiffness $k_c = 1/C_{\\text{coh}}$. This spring represents the integrated effect of the penalty stiffness over an effective area $A_{\\text{eff}} = b L_{\\text{eff}}$. The stiffness of the cohesive zone is given as $k_{c} = b K L_{\\text{eff}}$. Therefore:\n$$C_{\\text{coh}} = \\frac{1}{b K L_{\\text{eff}}}$$\nSolving for $K$:\n$$K = \\frac{1}{b L_{\\text{eff}} C_{\\text{coh}}} = \\frac{1}{0.020 \\times 0.010 \\times (0.3545 \\times 10^{-5})} = \\frac{1}{7.09 \\times 10^{-10}} \\approx 1.4104 \\times 10^{9}\\,\\text{N}\\,\\text{m}^{-3}$$\nThe result must be converted to $\\text{N}\\,\\text{mm}^{-3}$. The conversion factor is $1\\,\\text{N}\\,\\text{m}^{-3} = 1\\,\\text{N}\\,(1000\\,\\text{mm})^{-3} = 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3}$.\n$$K = (1.4104 \\times 10^{9}) \\times 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3} \\approx 1.4104\\,\\text{N}\\,\\text{mm}^{-3}$$\nRounding to three significant figures, $K = 1.41\\,\\text{N}\\,\\text{mm}^{-3}$.\n\nThe final ordered triple $(G_{I c}, \\sigma_{c}, K)$, with values rounded to three significant figures, is $(162\\,\\text{J}\\,\\text{m}^{-2}, 16.2\\,\\text{MPa}, 1.41\\,\\text{N}\\,\\text{mm}^{-3})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 162 & 16.2 & 1.41 \\end{pmatrix}\n}\n$$", "id": "2544709"}, {"introduction": "A robust cohesive element must behave physically under all loading conditions, including compression where crack faces cannot interpenetrate. This exercise tackles the crucial implementation detail of unilateral contact using a penalty method, a common technique in finite element analysis. You will implement a compressive penalty traction and investigate the fundamental trade-off between numerical accuracy (minimizing penetration) and system conditioning, providing insight into the practical challenges of developing stable and reliable cohesive elements [@problem_id:2544699].", "problem": "Consider a one-dimensional small-strain linear elastic bar cut into two subdomains and coupled by a unilateral normal-cohesive interface that penalizes only compression via a penalty traction. The goal is to implement the compressive penalty traction and study the effect of the penalty stiffness on interpenetration and on the conditioning of the linearized system matrix assembled by the Finite Element Method (FEM; Finite Element Method).\n\nStart from the following fundamental base:\n- Conservation of linear momentum in quasistatics reduces to stationarity of the total potential energy, which for a linear bar reduces to the weak form of equilibrium: the internal virtual work equals the external virtual work.\n- For a linear elastic one-dimensional bar of Young's modulus $E$ and cross-sectional area $A$, with displacement field $u(x)$ in the axial direction, the internal virtual work reads $\\int_0^L E A \\, \\varepsilon \\, \\delta \\varepsilon \\, dx$, where $\\varepsilon = du/dx$.\n- Discretization by the Finite Element Method with linear elements yields the standard element stiffness matrix $k_e = E A / \\ell_e$ multiplied by the canonical $2 \\times 2$ matrix $\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$, where $\\ell_e$ is the element length.\n- A cohesive interface with normal gap $\\delta_n$ that penalizes compression is modeled by a traction $t_n = k_p \\, \\delta_n^-$ with $\\delta_n^- = \\max(0,-\\delta_n)$ and $k_p \\ge 0$ a penalty stiffness. The tangent stiffness in the normal direction equals $k_p$ if $\\delta_n<0$ (compression) and $0$ if $\\delta_n \\ge 0$ (opening). In tension (opening), take $t_n = 0$.\n\nSet up the following boundary value problem:\n- Geometry: a bar of total length $L$ split into two equal halves, each of length $L/2$. The left half occupies $x \\in [0,L/2]$ and the right half occupies $x \\in [L/2,L]$.\n- Material: both halves have the same Young's modulus $E$ and cross-sectional area $A$.\n- Discretization: each half is discretized by $N_e$ uniform linear elements of length $\\ell_e = (L/2)/N_e$. Treat the two halves as having independent node sets; the interface between them is represented by a pair of coincident nodes, one from the left half and one from the right half, coupled only by the cohesive penalty law in the normal direction.\n- Kinematics: let $u_L$ be the displacement of the interface node on the left half and $u_R$ the displacement of the interface node on the right half. Define the scalar normal gap as $\\delta_n = u_R - u_L$.\n- Boundary conditions: impose $u(0) = 0$ at the left end and $u(L) = -u_0$ at the right end, with $u_0 > 0$ prescribed, so that the interface is driven into compression.\n- Cohesive interface law in compression: $t_n = k_p \\, \\delta_n^-$ with $\\delta_n^- = \\max(0,-\\delta_n)$. The corresponding consistent tangent contribution to the global stiffness matrix at the interface degrees of freedom is $k_{\\text{int}} = k_p$ if $\\delta_n < 0$ and $k_{\\text{int}}=0$ otherwise, assembled as the $2\\times 2$ block $k_{\\text{int}} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ at the interface node pair.\n\nTasks:\n1. Derive from the total potential energy and the discretization above the linear system for a given active set (compression active or not) and explain how to assemble the global stiffness matrix by superposition of element contributions and the interface tangent contribution determined by the sign of $\\delta_n$.\n2. Because the contact law is unilateral, devise a simple fixed-point active-set iteration: assume an initial interface state (compression active), assemble and solve; then update the active set by checking the sign of $\\delta_n$; reassemble and resolve if the active set changed. Iterate until the active set is consistent. The right-hand side consists only of contributions due to Dirichlet boundary conditions, with no external forces.\n3. For each test case, compute:\n   - The penetration $P = \\delta_n^- = \\max(0,-\\delta_n)$ expressed in meters and rounded to six significant digits.\n   - The condition number $\\kappa$ of the reduced tangent stiffness matrix (after imposing Dirichlet boundary conditions), measured in the spectral $2$-norm and rounded to three significant digits.\n\nUse the following test suite parameters (physical units are indicated explicitly and must be used consistently):\n- Material and geometry: $E = 70 \\times 10^9$ Pa, $A = 10^{-4}$ m$^2$, $L = 1$ m, $N_e = 10$, $u_0 = 10^{-4}$ m.\n- Penalty stiffness values for separate runs:\n  - Case $1$ (no penalty): $k_p = 0$ N/m.\n  - Case $2$ (weak penalty): $k_p = 10^6$ N/m.\n  - Case $3$ (moderate penalty): $k_p = 10^8$ N/m.\n  - Case $4$ (strong penalty): $k_p = 10^{10}$ N/m.\n\nRequired output:\n- For each case, return the pair $[P,\\kappa]$ as a list of two floats, with $P$ in meters and $\\kappa$ unitless, rounded as specified.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[P1,kappa1],[P2,kappa2],...]\").\n\nAll numerical constants in the statement are to be interpreted in the International System of Units, and all angles, if any were to appear, would be in radians. No percentages must be used; express fractional quantities as decimals if relevant.", "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Model**: One-dimensional, small-strain, linear elastic bar in quasistatics.\n- **Governing Equation**: Stationarity of total potential energy, equivalent to the weak form of equilibrium (internal virtual work = external virtual work).\n- **Internal Virtual Work (Elastic)**: $\\int_0^L E A \\, \\varepsilon \\, \\delta \\varepsilon \\, dx$, where $\\varepsilon = du/dx$.\n- **FEM Discretization**: Linear elements. Element stiffness matrix $k_e = E A / \\ell_e$ times $\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n- **Geometry**: Bar of length $L$, split at $x=L/2$ into two subdomains of length $L/2$.\n- **Material**: Young's modulus $E$, cross-sectional area $A$ are uniform.\n- **Discretization Details**: Each half is meshed with $N_e$ uniform linear elements. $\\ell_e = (L/2)/N_e$. The interface at $x=L/2$ is represented by a pair of coincident nodes, one for the left subdomain ($u_L$) and one for the right ($u_R$).\n- **Interface Kinematics**: Normal gap $\\delta_n = u_R - u_L$.\n- **Interface Constitutive Law**: Compressive penalty traction (force) $t_n = k_p \\, \\delta_n^-$ where $\\delta_n^- = \\max(0,-\\delta_n)$ and $k_p \\ge 0$. In tension ($t_n=0$).\n- **Interface Tangent Stiffness**: The contribution to the global stiffness matrix is a $2 \\times 2$ block $k_{\\text{int}} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ coupling the interface degrees of freedom, where $k_{\\text{int}} = k_p$ if $\\delta_n < 0$ and $k_{\\text{int}}=0$ otherwise.\n- **Boundary Conditions**: $u(0) = 0$ and $u(L) = -u_0$, with $u_0 > 0$.\n- **Tasks**:\n    1. Derive the linear system and explain the assembly of the global stiffness matrix.\n    2. Devise a fixed-point active-set iteration to handle the unilateral contact.\n    3. Compute penetration $P = \\max(0,-\\delta_n)$ and the condition number $\\kappa$ of the reduced tangent stiffness matrix.\n- **Test Parameters**:\n    - Material/Geometry: $E = 70 \\times 10^9$ Pa, $A = 10^{-4}$ m$^2$, $L = 1$ m, $N_e = 10$, $u_0 = 10^{-4}$ m.\n    - Penalty stiffness $k_p$: Case 1: $0$ N/m; Case 2: $10^6$ N/m; Case 3: $10^8$ N/m; Case 4: $10^{10}$ N/m.\n- **Required Output**: For each case, $[P, \\kappa]$ rounded to six and three significant digits, respectively.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is examined for validity.\n- **Scientifically Grounded**: The problem is formulated within the established framework of continuum mechanics, the Finite Element Method, and penalty methods for contact. All principles are standard in computational solid mechanics. It is scientifically sound.\n- **Well-Posed**: The problem is a well-defined boundary value problem. For any $k_p \\ge 0$, the governing equations combined with boundary conditions lead to a solvable system. The case $k_p=0$ represents a degenerate but physically meaningful limit where the two subdomains are mechanically disconnected. The proposed active-set algorithm is a standard procedure for this class of nonlinear problems. A unique solution for the displacements is expected.\n- **Objective**: The problem is stated using precise mathematical and physical terminology, free from ambiguity or subjective content.\n- **Flaw Checklist**:\n    1.  **Scientific/Factual Unsoundness**: None.\n    2.  **Non-Formalizable/Irrelevant**: The problem is a standard, formalizable problem in the specified field.\n    3.  **Incomplete/Contradictory Setup**: All necessary parameters are provided. There are no contradictions.\n    4.  **Unrealistic/Infeasible**: The physical parameters are realistic for common engineering materials like aluminum. The setup is a standard academic benchmark.\n    5.  **Ill-Posed/Poorly Structured**: The problem is well-structured. For $k_p > 0$, the stiffness matrix of the constrained system is positive definite, guaranteeing a unique solution. For $k_p=0$, the system matrix is non-singular after application of boundary conditions, also yielding a unique solution.\n    6.  **Pseudo-Profound/Trivial**: The problem requires a correct FEM implementation and understanding of numerical analysis concepts (condition number), making it non-trivial.\n    7.  **Outside Scientific Verifiability**: The results are computationally verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n---\n\nThe problem requires the finite element implementation and analysis of a one-dimensional bar with a unilateral cohesive interface. The solution proceeds according to the specified tasks.\n\n### Task 1: Derivation of the Linear System and Assembly\n\nThe governing principle is the stationarity of the total potential energy, $\\Pi$. For a discretized system, this is equivalent to the vector of nodal internal forces balancing the vector of external forces. The total potential energy is the sum of the elastic strain energy $U_{\\text{elastic}}$ and the energy stored in the cohesive interface $\\Phi_{\\text{int}}$.\n\n$\\Pi(\\mathbf{d}) = U_{\\text{elastic}}(\\mathbf{d}) + \\Phi_{\\text{int}}(\\mathbf{d})$\n\nThe elastic strain energy for the entire bar is the sum of energies of all elements:\n$U_{\\text{elastic}}(\\mathbf{d}) = \\frac{1}{2} \\mathbf{d}^T \\mathbf{K}_{\\text{elastic}} \\mathbf{d}$, where $\\mathbf{d}$ is the global vector of nodal displacements and $\\mathbf{K}_{\\text{elastic}}$ is the global elastic stiffness matrix assembled from element contributions. For a linear bar element of length $\\ell_e$, the element stiffness matrix is $\\mathbf{k}_e = \\frac{EA}{\\ell_e} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n\nThe potential energy of the compressive penalty interface is given by:\n$\\Phi_{\\text{int}}(\\delta_n) = \\frac{1}{2} k_p (\\delta_n^-)^2 = \\frac{1}{2} k_p (\\max(0, -\\delta_n))^2$.\nWith the gap defined as $\\delta_n = u_R - u_L$, and considering the case of compression where $\\delta_n < 0$ (so $u_L > u_R$), we have $\\delta_n^- = -\\delta_n = u_L - u_R$. The potential becomes:\n$\\Phi_{\\text{int}}(u_L, u_R) = \\frac{1}{2} k_p (u_L - u_R)^2$.\n\nThe stationarity condition $\\nabla_{\\mathbf{d}} \\Pi(\\mathbf{d}) = \\mathbf{0}$ yields the nonlinear system of equations $\\mathbf{R}(\\mathbf{d}) = \\mathbf{F}_{\\text{int}}(\\mathbf{d}) - \\mathbf{F}_{\\text{ext}} = \\mathbf{0}$, where the internal force vector $\\mathbf{F}_{\\text{int}}$ is the gradient of the potential energy. In our problem with prescribed displacements and no external forces, $\\mathbf{F}_{\\text{ext}} = \\mathbf{0}$, and the system is solved for the unknown displacements.\n\nThe internal force vector $\\mathbf{F}_{\\text{int}}(\\mathbf{d})$ has contributions from the elastic bar and the interface.\n$\\mathbf{F}_{\\text{int}}(\\mathbf{d}) = \\mathbf{K}_{\\text{elastic}} \\mathbf{d} + \\mathbf{f}_{\\text{int}}(\\mathbf{d})$, where $\\mathbf{f}_{\\text{int}}$ is the internal force vector from the interface. It is computed as the gradient of $\\Phi_{\\text{int}}$ with respect to the relevant degrees of freedom, $u_L$ and $u_R$:\n$f_{\\text{int}, L} = \\frac{\\partial \\Phi_{\\text{int}}}{\\partial u_L} = k_p(u_L - u_R)$\n$f_{\\text{int}, R} = \\frac{\\partial \\Phi_{\\text{int}}}{\\partial u_R} = -k_p(u_L - u_R)$\nIn matrix form, the force contribution on the interface DOFs is:\n$\\mathbf{f}_{\\text{int}} \\big|_{\\{u_L, u_R\\}} = \\begin{pmatrix} f_{\\text{int}, L} \\\\ f_{\\text{int}, R} \\end{pmatrix} = k_p \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} \\begin{pmatrix} u_L \\\\ u_R \\end{pmatrix}$\n\nThe active-set method, a specialized form of Newton-Raphson for this class of problem, solves the system by iteratively linearizing it: $\\mathbf{K}_T \\Delta\\mathbf{d} = -\\mathbf{R}(\\mathbf{d})$. The tangent stiffness matrix $\\mathbf{K}_T$ is the Jacobian of the residual $\\mathbf{R}(\\mathbf{d})$:\n$\\mathbf{K}_T = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{d}} = \\frac{\\partial \\mathbf{F}_{\\text{int}}}{\\partial \\mathbf{d}} = \\mathbf{K}_{\\text{elastic}} + \\mathbf{K}_{\\text{int}}$\nThe interface contribution to the tangent, $\\mathbf{K}_{\\text{int}}$, is the Jacobian of $\\mathbf{f}_{\\text{int}}$:\n$\\mathbf{K}_{\\text{int}} = \\frac{\\partial \\mathbf{f}_{\\text{int}}}{\\partial \\{u_L, u_R\\}} = k_p \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ (for $\\delta_n < 0$)\nThis result matches the matrix form given in the problem statement. If the interface is not in compression ($\\delta_n \\ge 0$), $\\Phi_{\\text{int}} = 0$ and thus $\\mathbf{K}_{\\text{int}} = \\mathbf{0}$.\n\nThe assembly of the global stiffness matrix $\\mathbf{K}$ proceeds by standard finite element assembly procedures:\n1. Initialize a global matrix $\\mathbf{K}$ of size $N_{\\text{dof}} \\times N_{\\text{dof}}$ to zeros, where $N_{\\text{dof}} = 2(N_e+1)$ is the total number of nodal degrees of freedom.\n2. For each of the $2N_e$ bar elements, compute the element stiffness matrix $\\mathbf{k}_e$ and add its entries to the corresponding locations in $\\mathbf{K}$.\n3. Based on the current interface state (compression active or not), add the interface tangent matrix $\\mathbf{K}_{\\text{int}}$ to the global matrix $\\mathbf{K}$ at the rows and columns corresponding to the interface degrees of freedom, $u_L$ and $u_R$.\n\n### Task 2: Active-Set Iteration\n\nThe unilateral nature of the contact law requires an iterative solution strategy. A fixed-point active-set algorithm is suitable.\n1. **Initialization**: Assume an initial state for the interface. Given the boundary conditions $u(0)=0$ and $u(L)=-u_0 < 0$, the bar is under global compression. It is therefore logical to assume the interface is in compression. Set a state flag, `compression_active = True`.\n2. **Iteration Loop**:\n   a. **Assemble and Solve**: Construct the tangent stiffness matrix $\\mathbf{K}_T$ based on the current `compression_active` flag. This involves assembling the elastic stiffness and adding the interface contribution $\\mathbf{K}_{\\text{int}} = k_p \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ if `compression_active` is true. Apply the Dirichlet boundary conditions $u_0 = 0$ and $u_{2N_e+1} = -u_0$ to form a reduced system $\\mathbf{K}_{uu} \\mathbf{d}_u = \\mathbf{b}$, where $\\mathbf{d}_u$ are the unknown displacements and $\\mathbf{b}$ is the force vector arising from the prescribed displacements. Solve this linear system for $\\mathbf{d}_u$.\n   b. **Update State**: Reconstruct the full displacement vector $\\mathbf{d}$. Calculate the interface gap $\\delta_n = u_R - u_L$. Determine the new state: `new_compression_active = (delta_n < 0)`.\n   c. **Check Convergence**: Compare the new state with the previous one. If `new_compression_active == compression_active`, the assumed state is consistent with the solution. The algorithm has converged. Terminate the loop.\n   d. **Update and Reiterate**: If the state has changed, update `compression_active = new_compression_active` and repeat from step 2a.\n\nFor this specific problem, the initial assumption of compression will be confirmed by the first solution, and the algorithm is expected to converge in a single iteration.\n\n### Task 3: Computation of Penetration and Condition Number\n\nUpon convergence of the active-set algorithm, the final displacement field $\\mathbf{d}$ is known.\n- **Penetration ($P$)**: The interpenetration at the interface is calculated as $P = \\delta_n^- = \\max(0, -\\delta_n) = \\max(0, -(u_R - u_L))$. The value is reported in meters, rounded to six significant digits.\n- **Condition Number ($\\kappa$)**: The conditioning of the linear system is measured by the spectral condition number of the **reduced** tangent stiffness matrix $\\mathbf{K}_{uu}$ that was solved. The spectral ($2$-norm) condition number is defined as $\\kappa(\\mathbf{K}_{uu}) = ||\\mathbf{K}_{uu}||_2 ||\\mathbf{K}_{uu}^{-1}||_2$. For a symmetric positive-definite matrix, this is the ratio of the largest to the smallest eigenvalue, $\\kappa = \\lambda_{\\max} / \\lambda_{\\min}$. This value is unitless and will be computed using library functions and rounded to three significant digits. As $k_p$ increases, the disparity in stiffness between the penalty spring and the bar elements is expected to grow, leading to a higher condition number and a numerically stiffer system.\n\nThe procedure is now implemented for the given test cases.", "answer": "```python\nimport numpy as np\n\ndef round_to_significant_figures(value, sf):\n    \"\"\"\n    Rounds a number to a specified number of significant figures.\n    \"\"\"\n    if value == 0:\n        return 0.0\n    # The format specifier 'g' handles scientific notation and significant figures.\n    return float(f\"{value:.{sf}g}\")\n\ndef solve():\n    \"\"\"\n    Solves the 1D bar problem with a compressive penalty interface\n    for different penalty stiffness values.\n    \"\"\"\n    # Test suite parameters\n    E = 70e9  # Pa\n    A = 1e-4  # m^2\n    L = 1.0   # m\n    Ne_half = 10  # Number of elements per half-bar\n    u0 = 1e-4 # m\n\n    test_cases_kp = [\n        0.0,      # Case 1: No penalty\n        1e6,      # Case 2: Weak penalty\n        1e8,      # Case 3: Moderate penalty\n        1e10,     # Case 4: Strong penalty\n    ]\n\n    results = []\n\n    # Derived parameters\n    le = (L / 2.0) / Ne_half\n    kel = E * A / le\n    k_elem_mat = kel * np.array([[1, -1], [-1, 1]])\n    \n    # Node and DOF details\n    # Left bar: nodes 0 to Ne_half. Right bar: nodes Ne_half+1 to 2*Ne_half+1\n    # Total nodes = 2 * (Ne_half + 1). Total DOFs are the same.\n    num_dofs = 2 * (Ne_half + 1)\n    \n    # Interface nodes are Ne_half (left) and Ne_half+1 (right)\n    interface_node_L = Ne_half\n    interface_node_R = Ne_half + 1\n    \n    # Boundary conditions\n    bc_dofs = [0, num_dofs - 1]\n    bc_values = [0, -u0]\n    unknown_dofs = [i for i in range(num_dofs) if i not in bc_dofs]\n    num_unknowns = len(unknown_dofs)\n\n    for kp in test_cases_kp:\n        compression_active = None\n        d = np.zeros(num_dofs)\n        \n        # --- Active-set iteration ---\n        # For this problem, starting with compression_active=True will converge in one step.\n        for _ in range(5): # Max 5 iterations as a safeguard\n            \n            new_compression_active_guess = True if compression_active is None else (d[interface_node_R]  d[interface_node_L])\n            \n            if new_compression_active_guess == compression_active:\n                break # Active set has converged\n            \n            compression_active = new_compression_active_guess\n\n            # --- Assembly of the global tangent stiffness matrix K ---\n            K = np.zeros((num_dofs, num_dofs))\n\n            # Assemble elastic stiffness for the left bar (elements 0 to Ne_half-1)\n            for i in range(Ne_half):\n                nodes = [i, i + 1]\n                K[np.ix_(nodes, nodes)] += k_elem_mat\n\n            # Assemble elastic stiffness for the right bar (elements Ne_half to 2*Ne_half-1)\n            # The nodes are from Ne_half+1 to 2*Ne_half+1\n            for i in range(Ne_half):\n                nodes = [interface_node_R + i, interface_node_R + i + 1]\n                K[np.ix_(nodes, nodes)] += k_elem_mat\n\n            # Assemble interface stiffness\n            if compression_active:\n                k_int_mat = kp * np.array([[1, -1], [-1, 1]])\n                interface_dofs = [interface_node_L, interface_node_R]\n                K[np.ix_(interface_dofs, interface_dofs)] += k_int_mat\n\n            # --- Partitioning and Solving ---\n            K_uu = K[np.ix_(unknown_dofs, unknown_dofs)]\n            K_uk = K[np.ix_(unknown_dofs, bc_dofs)]\n            \n            d_k = np.array(bc_values)\n            \n            # The RHS comes from the prescribed displacements\n            b = -K_uk @ d_k\n            \n            # Solve the reduced system K_uu * d_u = b\n            try:\n                d_u = np.linalg.solve(K_uu, b)\n                # Reconstruct full displacement vector\n                d[unknown_dofs] = d_u\n                d[bc_dofs] = d_k\n            except np.linalg.LinAlgError:\n                # This should not happen for this problem as K_uu is non-singular.\n                # It is a good practice to handle it for more general cases.\n                d.fill(np.nan) # Mark solution as failed\n                break\n\n        # --- Post-processing ---\n        if not np.any(np.isnan(d)):\n            # Calculate penetration P\n            delta_n = d[interface_node_R] - d[interface_node_L]\n            penetration = max(0, -delta_n)\n            \n            # Calculate condition number kappa of the reduced matrix\n            # For the kp=0 case, K_uu is non-singular after applying BCs.\n            condition_number = np.linalg.cond(K_uu, p=2)\n        else:\n            # Fallback if solver fails\n            penetration = np.nan\n            condition_number = np.nan\n\n        # Round results to specified significant figures\n        P_rounded = round_to_significant_figures(penetration, 6)\n        kappa_rounded = round_to_significant_figures(condition_number, 3)\n\n        results.append([P_rounded, kappa_rounded])\n\n    # Format the final output as a string\n    output_str = \"[\" + \",\".join([f\"[{p},{k}]\" for p, k in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2544699"}, {"introduction": "To capture the complex, irreversible processes that occur during fracture, cohesive laws can be enhanced with features like plasticity. This advanced practice guides you through the development of a return-mapping algorithm for a cohesive interface with rate-independent associative plasticity, a cornerstone of modern computational inelasticity. Deriving and implementing this algorithm, including the consistent tangent operator, will equip you with the skills to model sophisticated material behavior and ensure the quadratic convergence of nonlinear finite element simulations [@problem_id:2544669].", "problem": "You are tasked with developing and implementing a robust return-mapping algorithm for an interface with rate-independent associative plasticity in the context of a cohesive zone formulation. The interface traction $\\mathbf{t} \\in \\mathbb{R}^2$ (with components corresponding to the normal and shear directions) is related to the displacement jump $\\boldsymbol{\\delta} \\in \\mathbb{R}^2$ and the plastic displacement jump $\\boldsymbol{\\delta}^{\\mathrm{p}} \\in \\mathbb{R}^2$ through a linear elastic relation. The yield condition and the associative flow rule act in jump space. Your program must compute the updated traction and the algorithmic consistent tangent for several test cases.\n\nBegin from the following fundamental laws and definitions of rate-independent associative plasticity and linear elasticity:\n- The elastic constitutive relation for the interface is $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$, where $\\mathbf{K} \\in \\mathbb{R}^{2 \\times 2}$ is a symmetric positive-definite interface stiffness.\n- The yield function is convex and given by\n$$\nf(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0,\n$$\nwhere $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$ is symmetric positive-definite and $t_c  0$.\n- The Kuhn–Tucker conditions for plastic admissibility are\n$$\nf(\\mathbf{t}) \\le 0,\\quad \\Delta\\gamma \\ge 0,\\quad \\Delta\\gamma\\,f(\\mathbf{t}) = 0,\n$$\nwhere $\\Delta\\gamma \\ge 0$ is the plastic multiplier increment.\n- The associative flow rule in jump space is\n$$\n\\Delta \\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma\\,\\frac{\\partial f}{\\partial \\mathbf{t}}(\\mathbf{t}).\n$$\n\nYou must derive a return-mapping algorithm that, given the elastic predictor and the yield function above, computes the updated traction $\\mathbf{t}_{n+1}$ and the consistent algorithmic tangent $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$ to ensure quadratic convergence of a Newton method at the global level. Use only the fundamental statements above as your starting point, and do not assume any specialized shortcut formulas.\n\nSpecifically, proceed as follows:\n1. Given $\\boldsymbol{\\delta}_{n+1}$ and $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n}$, form the elastic predictor (trial state)\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big)\n$$\nand test yield admissibility via $f(\\mathbf{t}^{\\mathrm{tr}})$.\n2. If $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$, the step is elastic: set $\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}$ and $\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{K}$.\n3. If $f(\\mathbf{t}^{\\mathrm{tr}})  0$, enforce consistency by returning to the yield surface using a Lagrange multiplier $\\lambda \\ge 0$ associated with the constraint $f(\\mathbf{t}_{n+1}) = 0$ and the stationarity of the incremental potential. Show that the stationarity conditions lead to the nonlinear system\n$$\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - \\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0},\\quad f(\\mathbf{t}_{n+1}) = 0,\n$$\nwhich you must solve for $\\mathbf{t}_{n+1}$ and $\\lambda$. Demonstrate that this reduces to a one-dimensional root-finding problem in $\\lambda$.\n4. Derive the exact consistent algorithmic tangent $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$ by linearizing the above system with respect to $\\boldsymbol{\\delta}_{n+1}$, assuming perfect plasticity (no hardening). Your final expression must be obtained by eliminating $\\mathrm{d}\\lambda$ from the linearized equations so that $\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{C}_{\\mathrm{alg}}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$.\n\nAll quantities are nondimensional; no physical units are required.\n\nYour program must implement this return-mapping algorithm and produce the requested outputs for the following test suite. Each test case provides $\\mathbf{K}$, $\\mathbf{A}$, $t_c$, $\\boldsymbol{\\delta}_{n+1}$, and $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$. For each test, compute:\n- The updated traction components $\\mathbf{t}_{n+1} = [t_n,\\, t_s]^\\mathsf{T}$.\n- The consistent tangent matrix $\\mathbf{C}_{\\mathrm{alg}} \\in \\mathbb{R}^{2\\times 2}$, reported as its entries $C_{11}, C_{12}, C_{21}, C_{22}$.\n\nTest suite:\n- Test $1$ (elastic, diagonal $\\mathbf{K}$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.002 \\\\ 0.002 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $2$ (plastic, diagonal $\\mathbf{K}$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $3$ (on the yield surface, treat as elastic if $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} \\frac{3}{1000\\sqrt{2}} \\\\ \\frac{2}{500\\sqrt{2}} \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $4$ (plastic, coupled $\\mathbf{K}$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1200  200 \\\\ 200  800 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $5$ (elastic with nonzero prior plastic jump):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.006 \\\\ 0.0 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0.004 \\\\ 0.0 \\end{bmatrix}$.\n\nProgram output specification:\n- For each test, output the list $[t_n, t_s, C_{11}, C_{12}, C_{21}, C_{22}]$, where all entries are rounded to six decimal places.\n- Your program should produce a single line of output containing the results for all tests as a comma-separated list of these lists, enclosed in square brackets, for example:\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$.", "solution": "The problem requires the derivation and implementation of a return-mapping algorithm for rate-independent associative plasticity of a cohesive interface. We must compute the updated traction vector $\\mathbf{t}_{n+1}$ and the consistent algorithmic tangent matrix $\\mathbf{C}_{\\mathrm{alg}}$ for a given set of material parameters and prescribed final displacement jump $\\boldsymbol{\\delta}_{n+1}$. The derivation must proceed from first principles.\n\nLet us begin by formalizing the problem. The state at the beginning of the time increment is known, characterized by the plastic displacement jump $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$. The total displacement jump at the end of the increment, $\\boldsymbol{\\delta}_{n+1}$, is given.\n\nThe governing equations are:\n1.  Elastic Law: $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$\n2.  Yield Function: $f(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0$\n3.  Flow Rule (backward Euler discretization): $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} + \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}$ with $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma \\left. \\frac{\\partial f}{\\partial \\mathbf{t}} \\right|_{\\mathbf{t}_{n+1}}$\n4.  Kuhn-Tucker Loading/Unloading Conditions: $\\Delta\\gamma \\ge 0$, $f(\\mathbf{t}_{n+1}) \\le 0$, $\\Delta\\gamma\\,f(\\mathbf{t}_{n+1}) = 0$\n\nThe gradient of the yield function is:\n$$\n\\frac{\\partial f}{\\partial \\mathbf{t}} = \\frac{\\mathbf{A}\\,\\mathbf{t}}{\\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}}}\n$$\nDuring plastic loading, we have $f(\\mathbf{t}_{n+1}) = 0$, which implies $\\sqrt{\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}} = t_c$. The flow rule thus simplifies to:\n$$\n\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\frac{\\Delta\\gamma}{t_c} \\mathbf{A}\\,\\mathbf{t}_{n+1} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\nwhere we define the scaled (and non-negative) plastic multiplier $\\lambda = \\Delta\\gamma/t_c \\ge 0$.\n\nThe return-mapping algorithm proceeds in two main steps: an elastic trial step followed by a plastic corrector step if necessary.\n\n**Step 1: Elastic Predictor (Trial State)**\nFirst, we assume the entire step is elastic, meaning $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\mathbf{0}$. The trial traction, $\\mathbf{t}^{\\mathrm{tr}}$, is computed using the elastic law:\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n})\n$$\nWe then check for plastic yielding by evaluating the yield function at this trial state:\n$$\nf(\\mathbf{t}^{\\mathrm{tr}}) = \\sqrt{(\\mathbf{t}^{\\mathrm{tr}})^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}^{\\mathrm{tr}}} - t_c\n$$\nIf $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$, the assumption of elasticity is correct. The state is updated as:\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\n$$\n\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\nThe response is purely elastic, so the consistent tangent is simply the elastic stiffness matrix:\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}} = \\frac{\\partial}{\\partial \\boldsymbol{\\delta}_{n+1}} \\left[ \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) \\right] = \\mathbf{K}\n$$\n\n**Step 2: Plastic Corrector (Return Mapping)**\nIf $f(\\mathbf{t}^{\\mathrm{tr}})  0$, the trial state lies outside the elastic domain, and a plastic correction is required. The final state $(\\mathbf{t}_{n+1}, \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1})$ must satisfy the constitutive equations and the consistency condition $f(\\mathbf{t}_{n+1}) = 0$.\n\nThe updated traction is related to the trial state by:\n$$\n\\mathbf{t}_{n+1} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1}) = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} - \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}) = \\mathbf{t}^{\\mathrm{tr}} - \\mathbf{K}\\,\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}\n$$\nSubstituting the flow rule $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}$:\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}} - \\lambda\\,\\mathbf{K}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\nRearranging for $\\mathbf{t}_{n+1}$ gives:\n$$\n(\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\nPre-multiplying by $\\mathbf{K}^{-1}$, we obtain:\n$$\n(\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathbf{t}^{\\mathrm{tr}} = \\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\nThis leads to the expression for $\\mathbf{t}_{n+1}$ as a function of the unknown multiplier $\\lambda$:\n$$\n\\mathbf{t}_{n+1}(\\lambda) = (\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})^{-1}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) = (\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})^{-1}\\,\\mathbf{t}^{\\mathrm{tr}}\n$$\nThe system of equations to solve for the plastic step, as given in the problem, consists of this relation and the consistency condition:\n$$\n\\begin{cases}\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - (\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0} \\\\\nf(\\mathbf{t}_{n+1}) = 0\n\\end{cases}\n$$\nTo solve this system, we substitute the expression for $\\mathbf{t}_{n+1}(\\lambda)$ into the consistency condition $f(\\mathbf{t}_{n+1})=0$, which is equivalent to $\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} - t_c^2 = 0$. This yields a scalar nonlinear residual equation for $\\lambda$:\n$$\nR(\\lambda) = \\sqrt{\\mathbf{t}_{n+1}(\\lambda)^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}(\\lambda)} - t_c = 0\n$$\nThis one-dimensional root-finding problem for $\\lambda  0$ can be solved efficiently using numerical methods such as Newton-Raphson. Once $\\lambda$ is determined, the updated traction $\\mathbf{t}_{n+1}$ is computed.\n\n**Step 3: Derivation of the Consistent Algorithmic Tangent**\nThe consistent tangent operator $\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$ is required for the quadratic convergence of global Newton-Raphson solvers in a finite element context. It is derived by taking the total differential of the system of equations governing the plastic state. We linearize the system:\n1.  $(\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\mathbf{t}^{\\mathrm{tr}}$\n2.  $f(\\mathbf{t}_{n+1}) = 0$\n\nRecalling that $\\mathbf{t}^{\\mathrm{tr}}$ depends on $\\boldsymbol{\\delta}_{n+1}$ via $\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$, we differentiate the first equation:\n$$\n\\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} + (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\,\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}^{-1}\\,(\\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}) = \\mathrm{d}\\boldsymbol{\\delta}_{n+1}\n$$\nLet us define $\\mathbf{H}_{\\lambda}^{-1} = \\mathbf{K}^{-1} + \\lambda\\mathbf{A}$. Solving for $\\mathrm{d}\\mathbf{t}_{n+1}$:\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1})\n$$\nNext, we differentiate the consistency condition $f(\\mathbf{t}_{n+1})=0$, which implies that any variation must lie in the tangent plane of the yield surface:\n$$\n\\mathrm{d}f = \\left(\\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}}\\right)^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0\n$$\nLet $\\mathbf{m} = \\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}} = \\frac{\\mathbf{A}\\,\\mathbf{t}_{n+1}}{t_c}$. The condition is $\\mathbf{m}^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0$.\nSubstituting the expression for $\\mathrm{d}\\mathbf{t}_{n+1}$:\n$$\n\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) = 0\n$$\nWe solve this equation for the differential of the multiplier, $\\mathrm{d}\\lambda$:\n$$\n\\mathrm{d}\\lambda = \\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\nThis expression relates the increment in the plastic multiplier to the increment in the total displacement jump. Finally, we substitute $\\mathrm{d}\\lambda$ back into the expression for $\\mathrm{d}\\mathbf{t}_{n+1}$ to eliminate the dependency on $\\mathrm{d}\\lambda$:\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\\,\\left(\\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\\right)\n$$\nUsing the outer product notation $(\\mathbf{u} \\otimes \\mathbf{v}) \\mathbf{w} = \\mathbf{u} (\\mathbf{v}^\\mathsf{T} \\mathbf{w})$, we can identify the operator mapping $\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$ to $\\mathrm{d}\\mathbf{t}_{n+1}$:\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{H}_{\\lambda} - \\frac{(\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) \\otimes (\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda})}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\nwhere $\\mathbf{H}_{\\lambda} = (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})^{-1}$ and $\\mathbf{m} = \\mathbf{A}\\,\\mathbf{t}_{n+1} / t_c$. This is the exact consistent algorithmic tangent for the plastic step.\n\nThe implementation will now follow this derived algorithm for the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the cohesive zone plasticity problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (elastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.002, 0.002]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 2 (plastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 3 (on the yield surface)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([3.0 / (1000.0 * np.sqrt(2.0)), 2.0 / (500.0 * np.sqrt(2.0))]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 4 (plastic, coupled K)\n        {\n            'K': np.array([[1200.0, 200.0], [200.0, 800.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 5 (elastic with prior plastic jump)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.006, 0.0]),\n            'delta_p_n': np.array([0.004, 0.0])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K = case['K']\n        A = case['A']\n        tc = case['tc']\n        delta_n1 = case['delta']\n        delta_p_n = case['delta_p_n']\n\n        # Step 1: Elastic Predictor\n        delta_e_tr = delta_n1 - delta_p_n\n        t_tr = K @ delta_e_tr\n        \n        # Check yield condition\n        f_tr_val_sq = t_tr.T @ A @ t_tr\n        f_tr = np.sqrt(f_tr_val_sq) - tc\n\n        if f_tr = 1e-12:  # Using tolerance for floating point comparison\n            # Elastic step\n            t_n1 = t_tr\n            C_alg = K\n        else:\n            # Plastic step: return mapping\n            \n            # Formulate the residual function for lambda\n            K_inv = np.linalg.inv(K)\n            \n            def residual(lam):\n                # Using the expression t_n1 = (I + lambda*K*A)^-1 * t_tr\n                # Inversion is expensive, so it's better to solve the linear system\n                # (I + lam*K@A) @ t_n1 = t_tr\n                M = np.eye(2) + lam * K @ A\n                t_n1_lam = np.linalg.solve(M, t_tr)\n                yield_val_sq = t_n1_lam.T @ A @ t_n1_lam\n                return np.sqrt(yield_val_sq) - tc\n\n            # Solve for lambda using a root-finding algorithm\n            sol = root_scalar(residual, bracket=[0, 1e-2], method='brentq')\n            lam = sol.root\n            \n            # Update traction vector\n            M_final = np.eye(2) + lam * K @ A\n            t_n1 = np.linalg.solve(M_final, t_tr)\n            \n            # Calculate consistent tangent\n            H_lam = np.linalg.inv(K_inv + lam * A)\n            m = (A @ t_n1) / tc\n            \n            numerator_vec1 = H_lam @ A @ t_n1\n            numerator_vec2_T = m.T @ H_lam\n            \n            denominator = m.T @ H_lam @ A @ t_n1\n            \n            C_alg = H_lam - np.outer(numerator_vec1, numerator_vec2_T) / denominator\n\n        # Format output\n        tn, ts = t_n1[0], t_n1[1]\n        C11, C12 = C_alg[0, 0], C_alg[0, 1]\n        C21, C22 = C_alg[1, 0], C_alg[1, 1]\n        \n        results.append(\n            f\"[{tn:.6f},{ts:.6f},{C11:.6f},{C12:.6f},{C21:.6f},{C22:.6f}]\"\n        )\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2544669"}]}