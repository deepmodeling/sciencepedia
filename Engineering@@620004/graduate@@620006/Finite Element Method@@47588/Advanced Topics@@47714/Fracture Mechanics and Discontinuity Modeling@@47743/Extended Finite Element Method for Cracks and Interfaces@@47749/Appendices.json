{"hands_on_practices": [{"introduction": "The Extended Finite Element Method (XFEM) enhances the standard finite element approximation by incorporating special functions that capture discontinuities and singularities. A critical first step in an XFEM analysis is to identify which nodes require this special treatment and what type of enrichment is appropriate. This exercise [@problem_id:2557355] provides hands-on practice in applying the topological rules for selecting nodes for Heaviside (discontinuity) and near-tip (singularity) enrichment, and then quantifying the resulting increase in the problem size by counting the additional degrees of freedom.", "problem": "Consider two-dimensional plane strain linear elasticity discretized with bilinear quadrilateral finite elements over the rectangular domain $\\Omega = [0,3] \\times [0,2]$. The mesh has $3 \\times 2$ elements with nodes at integer grid points. Number the nodes row-wise from the bottom-left corner so that the nodal coordinates are\n$(x,y)$ at\nnode $1:(0,0)$, node $2:(1,0)$, node $3:(2,0)$, node $4:(3,0)$,\nnode $5:(0,1)$, node $6:(1,1)$, node $7:(2,1)$, node $8:(3,1)$,\nnode $9:(0,2)$, node $10:(1,2)$, node $11:(2,2)$, node $12:(3,2)$.\nLet the six elements have the following node connectivities (counterclockwise): $e_1=[1,2,6,5]$, $e_2=[2,3,7,6]$, $e_3=[3,4,8,7]$, $e_4=[5,6,10,9]$, $e_5=[6,7,11,10]$, $e_6=[7,8,12,11]$.\n\nA straight crack $\\Gamma_c$ of zero thickness is embedded in the domain. The crack is modeled with the extended finite element method (XFEM) using the Heaviside enrichment to represent the displacement jump across the crack faces and the near-tip asymptotic branch enrichments to capture the singular fields near the crack tip. The crack is defined as the line segment from $\\mathbf{x}_A=(0.2,0.9)$ to the tip $\\mathbf{x}_T=(2.4,0.9)$ (coordinates in the same units as the mesh), and it does not pass through any node or coincide with any element edge.\n\nAssume the following enrichment selection rules:\n\n(1) Heaviside enrichment: A node is Heaviside-enriched if at least one element attached to it is intersected by the interior of $\\Gamma_c$ and the node does not belong to the near-tip enriched set.\n\n(2) Near-tip enrichment: Let $e_t$ be the unique element containing the crack tip $\\mathbf{x}_T$. The near-tip enriched set consists of all nodes belonging to the union of $e_t$ and all elements that share an edge with $e_t$.\n\nAssume the standard displacement approximation has $2$ translational degrees of freedom per node. In the XFEM enrichment:\n- Each Heaviside-enriched node carries one vector-valued enriched coefficient associated with the scalar Heaviside function (that is, $2$ additional degrees of freedom per Heaviside-enriched node).\n- Each near-tip-enriched node carries four vector-valued enriched coefficients associated with the four standard two-dimensional near-tip branch functions (that is, $8$ additional degrees of freedom per near-tip-enriched node).\n\nStarting from these definitions and the standard notion of a nodal support in the finite element method, determine the total number of additional degrees of freedom introduced by the enrichment relative to the standard finite element model for this mesh and crack configuration. Justify which nodes are Heaviside-enriched and which nodes are near-tip-enriched based on the stated rules. Express your final answer as an integer with no units.", "solution": "We begin from the foundational finite element concepts: a bilinear quadrilateral element associates each node with a scalar shape function whose support is the union of elements that contain the node. In two-dimensional linear elasticity, the displacement field has two components, so each node possesses $2$ standard degrees of freedom. In the extended finite element method (XFEM), the partition of unity provided by the standard shape functions is multiplied by enrichment functions to represent features such as displacement jumps and crack-tip singularities. Each scalar enrichment function at a node introduces a vector-valued enriched coefficient with $2$ additional degrees of freedom.\n\nWe apply the provided enrichment selection rules:\n\nStep $1$: Identify the elements intersected by the interior of $\\Gamma_c$ and the element containing the crack tip.\n\nThe crack $\\Gamma_c$ is the segment from $\\mathbf{x}_A=(0.2,0.9)$ to $\\mathbf{x}_T=(2.4,0.9)$, i.e., a horizontal line at $y=0.9$ from $x=0.2$ to $x=2.4$. The element extents are:\n- $e_1=[1,2,6,5]$ spans $x \\in [0,1]$, $y \\in [0,1]$,\n- $e_2=[2,3,7,6]$ spans $x \\in [1,2]$, $y \\in [0,1]$,\n- $e_3=[3,4,8,7]$ spans $x \\in [2,3]$, $y \\in [0,1]$,\n- $e_4=[5,6,10,9]$ spans $x \\in [0,1]$, $y \\in [1,2]$,\n- $e_5=[6,7,11,10]$ spans $x \\in [1,2]$, $y \\in [1,2]$,\n- $e_6=[7,8,12,11]$ spans $x \\in [2,3]$, $y \\in [1,2]$.\n\nBecause $y=0.9 \\in (0,1)$, the crack lies within the bottom row of elements ($e_1$, $e_2$, $e_3$). The $x$-interval of the crack is $[0.2,2.4]$, which intersects:\n- $e_1$ for $x \\in [0.2,1]$ (interior intersection),\n- $e_2$ for $x \\in [1,2]$ (interior intersection),\n- $e_3$ for $x \\in [2,2.4]$ (interior intersection up to the tip).\n\nThe crack tip point $\\mathbf{x}_T=(2.4,0.9)$ satisfies $2<2.4<3$ and $0<0.9<1$, hence the tip element is $e_t=e_3$.\n\nStep $2$: Construct the near-tip enriched node set according to rule $(2)$.\n\nBy rule $(2)$, the near-tip enriched set consists of the nodes of $e_t$ and of all elements sharing an edge with $e_t$. The edge-adjacent neighbors of $e_3$ are:\n- Left neighbor $e_2$ (shared vertical edge along $x=2$),\n- Top neighbor $e_6$ (shared horizontal edge along $y=1$),\nand there is no right neighbor (domain boundary at $x=3$) nor bottom neighbor (domain boundary at $y=0$).\n\nThus, the near-tip patch is the union of elements $\\{e_2,e_3,e_6\\}$ with node sets:\n- $e_2$ has nodes $\\{2,3,7,6\\}$,\n- $e_3$ has nodes $\\{3,4,8,7\\}$,\n- $e_6$ has nodes $\\{7,8,12,11\\}$.\n\nTaking the union, the near-tip enriched node set is\n$\\mathcal{N}_{\\text{tip}}=\\{2,3,4,6,7,8,11,12\\}$.\n\nBy the stated approximation, each near-tip-enriched node introduces $4$ scalar branch functions, each with a $2$-component vector coefficient, for $8$ additional degrees of freedom per node.\n\nStep $3$: Construct the Heaviside enriched node set according to rule $(1)$.\n\nFirst list elements intersected by the interior of $\\Gamma_c$ excluding the tip element: these are $e_1$ and $e_2$. Their node sets are:\n- $\\mathcal{N}(e_1)=\\{1,2,6,5\\}$,\n- $\\mathcal{N}(e_2)=\\{2,3,7,6\\}$.\n\nThe union of nodes belonging to elements cut by the crack interior and not including the tip element is\n$\\{1,2,3,5,6,7\\}$.\n\nPer rule $(1)$, remove nodes that are in the near-tip enriched set $\\mathcal{N}_{\\text{tip}}$ to avoid double enrichment. Since $\\mathcal{N}_{\\text{tip}}=\\{2,3,4,6,7,8,11,12\\}$, the remaining Heaviside-enriched nodes are\n$\\mathcal{N}_{H}=\\{1,5\\}$.\n\nEach Heaviside-enriched node introduces a single scalar Heaviside function with a $2$-component vector coefficient, for $2$ additional degrees of freedom per node.\n\nStep $4$: Count the additional degrees of freedom.\n\n- Heaviside contribution: $|\\mathcal{N}_{H}| \\times 2 = 2 \\times 2 = 4$ additional degrees of freedom.\n- Near-tip contribution: $|\\mathcal{N}_{\\text{tip}}| \\times 8 = 8 \\times 8 = 64$ additional degrees of freedom.\n\nTotal additional degrees of freedom introduced by the enrichment relative to the standard finite element model is\n$4 + 64 = 68$.\n\nStep $5$: Justification of the selection.\n\nThe Heaviside enrichment is assigned to nodes whose nodal supports are intersected by the interior of the crack segment, ensuring the partition of unity can represent a displacement jump across the crack faces in elements cut by the crack away from the tip. Excluding nodes in the near-tip patch from Heaviside enrichment avoids overlapping discontinuous and singular enrichments on the same nodes, which can cause ill-conditioning and linear dependence.\n\nThe near-tip enrichment is assigned to the tip element and its edge-adjacent neighbors to capture the square-root singularity and angular variation of the stress and displacement fields near the crack tip using the four standard two-dimensional branch functions. Extending the tip enrichment to the one-ring of edge-adjacent elements provides sufficient support to represent the asymptotic fields while maintaining a compact enriched region. This division of enriched sets is consistent with the extended finite element methodâ€™s partition of unity framework and leverages the local nature of the crack-tip singular fields while separately handling the displacement jump away from the tip.\n\nTherefore, the total number of additional degrees of freedom is $68$.", "answer": "$$\\boxed{68}$$", "id": "2557355"}, {"introduction": "A defining feature of XFEM is the presence of basis functions that are discontinuous within a finite element. This invalidates standard Gaussian quadrature rules, which are designed for smooth integrands. This practice problem [@problem_id:2557298] explores a fundamental technique to overcome this challenge: the element is partitioned into sub-triangles that do not cross the discontinuity, and a suitable quadrature rule is applied to each sub-domain. Solving this problem builds intuition for the careful geometric and numerical procedures required to accurately form the system of equations in XFEM.", "problem": "In the extended finite element method (XFEM), cut cells are integrated by decomposing the parent element into subdomains separated by the discontinuity and then applying exact area-based quadrature on each subdomain. Consider the triangular finite element with vertices $A=(0,0)$, $B=(3,0)$, and $C=(0,2)$. A straight crack intersects the element along the vertical line $x=1$, from the point $D=(1,0)$ on edge $\\overline{AB}$ to the point $E=\\left(1,\\frac{4}{3}\\right)$ on edge $\\overline{BC}$. This crack splits the element into two polygonal subdomains: the left subdomain with $x<1$ and the right subdomain with $x\\ge 1$.\n\nDefine the piecewise linear integrand $g:\\mathbb{R}^{2}\\to\\mathbb{R}$ by\n- on the left subdomain $\\{(x,y)\\,:\\,x<1\\}$, $g(x,y)=1+x+y$,\n- on the right subdomain $\\{(x,y)\\,:\\,x\\ge 1\\}$, $g(x,y)=2-x+3y$.\n\nUsing exact area decomposition suitable for XFEM subcell integration:\n- partition the two polygons induced by the crack into non-overlapping triangles with vertices among $\\{A,B,C,D,E\\}$ so that their union equals the original element,\n- for each triangle, construct a single quadrature point at its centroid with a weight equal to its area, and\n- use these quadrature points and weights to evaluate the integral\n$$\nI \\;=\\; \\iint_{T} g(x,y)\\,\\mathrm{d}A,\n$$\nwhere $T=\\mathrm{conv}\\{A,B,C\\}$ is the original triangle.\n\nState the final value of $I$ as a single exact rational number (no rounding). Do not include units in your final answer. If you need to choose a value on the crack itself (where $x=1$), justify that your choice does not affect the integral.", "solution": "The integral $I$ over the triangle $T$ can be decomposed into the sum of integrals over the two subdomains created by the crack at $x=1$. Let $T_{left}$ be the part of $T$ where $x<1$ and $T_{right}$ be the part where $x>1$. The integral over the line $x=1$ itself is zero, as a line segment is a set of measure zero in $\\mathbb{R}^2$. Thus, the choice of using the definition for $x\\ge 1$ on the crack line does not affect the final value of the integral.\n$$\nI = \\iint_{T} g(x,y)\\,\\mathrm{d}A = \\iint_{T_{left}} (1+x+y)\\,\\mathrm{d}A + \\iint_{T_{right}} (2-x+3y)\\,\\mathrm{d}A\n$$\nThe subdomain $T_{left}$ is the quadrilateral with vertices $A(0,0)$, $D(1,0)$, $E\\left(1, \\frac{4}{3}\\right)$, and $C(0,2)$. The subdomain $T_{right}$ is the triangle with vertices $D(1,0)$, $B(3,0)$, and $E\\left(1, \\frac{4}{3}\\right)$.\n\nFollowing the problem's instructions, we partition the quadrilateral $T_{left}$ into two triangles. We choose the diagonal $\\overline{AE}$, which decomposes $T_{left}$ into $\\triangle ADE$ and $\\triangle ACE$. Thus, the original triangle $T$ is decomposed into three sub-triangles:\n1.  $T_1 = \\triangle ADE$\n2.  $T_2 = \\triangle ACE$\n3.  $T_3 = \\triangle DBE$ (this is the same as $T_{right}$)\n\nThe specified numerical integration scheme evaluates the integral over a sub-triangle by multiplying its area by the value of the integrand at its centroid. For a linear integrand $f(x,y)$ over a triangle $\\Delta$, this method is exact: $\\iint_{\\Delta} f(x,y)\\,\\mathrm{d}A = \\text{Area}(\\Delta) \\cdot f(x_c, y_c)$, where $(x_c, y_c)$ is the centroid of $\\Delta$. Since our integrand $g(x,y)$ is piecewise linear, and each sub-triangle lies entirely within a region where $g$ is linear, this procedure will yield the exact value of the integral.\n\nWe now calculate the contribution from each sub-triangle.\n\n**1. Sub-triangle $T_1 = \\triangle ADE$**\n-   Vertices: $A(0,0)$, $D(1,0)$, $E\\left(1, \\frac{4}{3}\\right)$.\n-   This triangle is in the $x<1$ region (except for the edge $\\overline{DE}$). We use $g(x,y) = 1+x+y$.\n-   Area: $A_1 = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times (1-0) \\times \\frac{4}{3} = \\frac{2}{3}$.\n-   Centroid: $C_1 = \\left(\\frac{0+1+1}{3}, \\frac{0+0+\\frac{4}{3}}{3}\\right) = \\left(\\frac{2}{3}, \\frac{4}{9}\\right)$.\n-   Integrand value at centroid: $g(C_1) = 1 + \\frac{2}{3} + \\frac{4}{9} = \\frac{9}{9} + \\frac{6}{9} + \\frac{4}{9} = \\frac{19}{9}$.\n-   Integral contribution: $I_1 = A_1 \\cdot g(C_1) = \\frac{2}{3} \\cdot \\frac{19}{9} = \\frac{38}{27}$.\n\n**2. Sub-triangle $T_2 = \\triangle ACE$**\n-   Vertices: $A(0,0)$, $C(0,2)$, $E\\left(1, \\frac{4}{3}\\right)$.\n-   This triangle is in the $x<1$ region (except for vertex $E$). We use $g(x,y) = 1+x+y$.\n-   Area (using the shoelace formula): $A_2 = \\frac{1}{2} |(0 \\cdot 2 + 0 \\cdot \\frac{4}{3} + 1 \\cdot 0) - (0 \\cdot 0 + 2 \\cdot 1 + \\frac{4}{3} \\cdot 0)| = \\frac{1}{2} |0 - 2| = 1$.\n-   Centroid: $C_2 = \\left(\\frac{0+0+1}{3}, \\frac{0+2+\\frac{4}{3}}{3}\\right) = \\left(\\frac{1}{3}, \\frac{\\frac{10}{3}}{3}\\right) = \\left(\\frac{1}{3}, \\frac{10}{9}\\right)$.\n-   Integrand value at centroid: $g(C_2) = 1 + \\frac{1}{3} + \\frac{10}{9} = \\frac{9}{9} + \\frac{3}{9} + \\frac{10}{9} = \\frac{22}{9}$.\n-   Integral contribution: $I_2 = A_2 \\cdot g(C_2) = 1 \\cdot \\frac{22}{9} = \\frac{22}{9}$.\n\n**3. Sub-triangle $T_3 = \\triangle DBE$**\n-   Vertices: $D(1,0)$, $B(3,0)$, $E\\left(1, \\frac{4}{3}\\right)$.\n-   This triangle is in the $x \\ge 1$ region. We use $g(x,y) = 2-x+3y$.\n-   Area: $A_3 = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times (3-1) \\times \\frac{4}{3} = \\frac{1}{2} \\cdot 2 \\cdot \\frac{4}{3} = \\frac{4}{3}$.\n-   Centroid: $C_3 = \\left(\\frac{1+3+1}{3}, \\frac{0+0+\\frac{4}{3}}{3}\\right) = \\left(\\frac{5}{3}, \\frac{4}{9}\\right)$.\n-   Integrand value at centroid: $g(C_3) = 2 - \\frac{5}{3} + 3\\left(\\frac{4}{9}\\right) = 2 - \\frac{5}{3} + \\frac{4}{3} = 2 - \\frac{1}{3} = \\frac{5}{3}$.\n-   Integral contribution: $I_3 = A_3 \\cdot g(C_3) = \\frac{4}{3} \\cdot \\frac{5}{3} = \\frac{20}{9}$.\n\n**Total Integral**\nThe total integral $I$ is the sum of the contributions from the three sub-triangles:\n$$\nI = I_1 + I_2 + I_3 = \\frac{38}{27} + \\frac{22}{9} + \\frac{20}{9}\n$$\nTo sum these fractions, we find a common denominator, which is $27$.\n$$\nI = \\frac{38}{27} + \\frac{22 \\cdot 3}{27} + \\frac{20 \\cdot 3}{27} = \\frac{38 + 66 + 60}{27}\n$$\n$$\nI = \\frac{104 + 60}{27} = \\frac{164}{27}\n$$\nAs a check, the sum of ares is $A_1+A_2+A_3 = \\frac{2}{3} + 1 + \\frac{4}{3} = \\frac{6}{3}+1 = 2+1=3$. The area of the original triangle $T$ with vertices $(0,0)$, $(3,0)$, $(0,2)$ is $\\frac{1}{2} \\times 3 \\times 2 = 3$. The area decomposition is correct. The final result is the exact value of the integral.", "answer": "$$\n\\boxed{\\frac{164}{27}}\n$$", "id": "2557298"}, {"introduction": "After implementing the novel features of a numerical method, it is crucial to verify that the code behaves as expected. This practice [@problem_id:2557321] introduces the Method of Manufactured Solutions (MMS), a rigorous verification technique, to validate the core capability of an XFEM implementation: representing a displacement discontinuity. You will compute the displacement jump predicted by a simple XFEM model and compare it against a known, \"manufactured\" analytical solution, allowing you to assess the accuracy of the implementation and understand its interpolation properties.", "problem": "You are tasked with validating an implementation concept of the extended finite element method (XFEM) for a straight crack in two dimensions by using a manufactured solution. Consider a single four-node bilinear element in two dimensions with a straight internal crack represented by a signed distance level set. You will compute the crack-face displacement jump from the XFEM Heaviside enrichment and compare it against the analytical jump induced by the manufactured solution. You must implement the required computations in a complete, runnable program.\n\nStart from the following fundamental definitions and facts:\n\n- In small-strain linearized kinematics with an internal discontinuity represented by a level set, the crack surface is given by the zero isocontour of a level set function $\\phi(\\boldsymbol{x})$, where $\\phi(\\boldsymbol{x}) = \\boldsymbol{n} \\cdot (\\boldsymbol{x} - \\boldsymbol{x}_0)$ with unit normal $\\boldsymbol{n}$ and a point $\\boldsymbol{x}_0$ on the crack line. The sides are denoted by $\\phi(\\boldsymbol{x}) > 0$ (the positive side) and $\\phi(\\boldsymbol{x}) &lt; 0$ (the negative side).\n- In the extended finite element method (XFEM) with a Heaviside enrichment function for a strong displacement discontinuity, the discrete displacement field over a single element $\\Omega_e$ is\n$$\n\\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{a}_i \\;+\\; H(\\phi(\\boldsymbol{x})) \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{b}_i,\n$$\nwhere $N_i(\\boldsymbol{x})$ are the standard bilinear shape functions, $\\boldsymbol{a}_i$ are the standard degrees of freedom, $\\boldsymbol{b}_i$ are the enriched degrees of freedom associated with the Heaviside enrichment, and $H(\\cdot)$ is the sign Heaviside function with $H(\\phi) \\in \\{-1,+1\\}$ and $H(\\phi) = \\mathrm{sign}(\\phi)$.\n- The crack-face displacement jump is defined as\n$$\n[\\![\\boldsymbol{u}]\\!](\\boldsymbol{x}) \\equiv \\lim_{\\epsilon \\to 0^+} \\left( \\boldsymbol{u}(\\boldsymbol{x}+\\epsilon \\boldsymbol{n}) - \\boldsymbol{u}(\\boldsymbol{x}-\\epsilon \\boldsymbol{n}) \\right)\n$$\nfor $\\boldsymbol{x}$ on the crack set $\\{\\phi(\\boldsymbol{x}) = 0\\}$. The continuous part of the field cancels in this limit, while the discontinuous part contributes through the Heaviside function.\n\nManufactured-solution validation protocol:\n\n- Consider a manufactured displacement of the form\n$$\n\\boldsymbol{u}^{\\star}(\\boldsymbol{x}) = \\boldsymbol{u}_{\\mathrm{cont}}(\\boldsymbol{x}) + H(\\phi(\\boldsymbol{x}))\\,\\boldsymbol{F}(\\boldsymbol{x}),\n$$\nwhere $\\boldsymbol{u}_{\\mathrm{cont}}(\\boldsymbol{x})$ is any continuous function over the element (it does not affect the jump), and $\\boldsymbol{F}(\\boldsymbol{x})$ is a prescribed vector-valued function. The analytical jump induced by this manufactured solution is\n$$\n[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}) = 2\\,\\boldsymbol{F}(\\boldsymbol{x}) \\quad \\text{for } \\phi(\\boldsymbol{x})=0.\n$$\n- Emulate the XFEM representation by setting the enriched degrees of freedom at element nodes $\\boldsymbol{x}_i$ to the nodal evaluations of the manufactured half-jump,\n$$\n\\boldsymbol{b}_i = \\boldsymbol{F}(\\boldsymbol{x}_i), \\quad i \\in \\{1,2,3,4\\}.\n$$\nWith this choice, the discrete jump recovered from XFEM along the crack segment inside the element reduces to\n$$\n[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}) = 2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x})\\,\\boldsymbol{b}_i \\quad \\text{for } \\phi(\\boldsymbol{x})=0.\n$$\nWhen $\\boldsymbol{F}(\\boldsymbol{x})$ is bilinear in $(x,y)$, the above equals the exact jump everywhere in the element. When $\\boldsymbol{F}(\\boldsymbol{x})$ is not bilinear, this produces a consistent bilinear interpolation error.\n\nGeometric setting and shape functions:\n\n- Use a single axis-aligned rectangular bilinear element with nodes ordered counterclockwise as $\\boldsymbol{x}_1=(x_L,y_B)$, $\\boldsymbol{x}_2=(x_R,y_B)$, $\\boldsymbol{x}_3=(x_R,y_T)$, $\\boldsymbol{x}_4=(x_L,y_T)$. Let the element center be $(x_C,y_C)=\\left(\\frac{x_L+x_R}{2},\\frac{y_B+y_T}{2}\\right)$, width $w = x_R-x_L$, and height $h = y_T-y_B$. The isoparametric coordinates $(\\xi,\\eta)\\in[-1,1]^2$ corresponding to a physical point $(x,y)$ are\n$$\n\\xi = \\frac{2(x-x_C)}{w}, \\qquad \\eta = \\frac{2(y-y_C)}{h}.\n$$\nThe bilinear shape functions are\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n\nLine segment of the crack inside the element:\n\n- The crack is the infinite line $\\{\\boldsymbol{x}:\\phi(\\boldsymbol{x})=0\\}$ with $\\phi(\\boldsymbol{x}) = \\boldsymbol{n}\\cdot(\\boldsymbol{x}-\\boldsymbol{x}_0)$, which cuts the element into two subdomains. The crack segment inside the element is the intersection of this line with the element boundary. Numerically, locate the two intersection points by examining sign changes of $\\phi$ across each element edge and interpolating linearly along edges. Deduplicate coincident intersections with a small tolerance. Parameterize the segment as $\\boldsymbol{x}(s) = \\boldsymbol{x}_A + s(\\boldsymbol{x}_B - \\boldsymbol{x}_A)$ with $s \\in [0,1]$, where $\\boldsymbol{x}_A$ and $\\boldsymbol{x}_B$ are the segment endpoints, and its length is $L = \\|\\boldsymbol{x}_B - \\boldsymbol{x}_A\\|_2$.\n\nValidation metrics to compute for each test case:\n\n- The discrete jump along the crack is\n$$\n[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s)) = 2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x}(s)) \\,\\boldsymbol{b}_i,\n$$\nand the analytical jump is $[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s)) = 2\\,\\boldsymbol{F}(\\boldsymbol{x}(s))$.\n- Compute the $L^2$-norm of the vector jump error along the segment by Gaussian quadrature with three points,\n$$\ne_{\\mathrm{vec}} = \\left( \\int_{0}^{1} \\left\\| [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s)) - [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s)) \\right\\|_2^2 \\, L \\,\\mathrm{d}s \\right)^{1/2},\n$$\nusing the standard $3$-point Gauss rule on $[-1,1]$ with abscissae $[-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}]$ and weights $[5/9,\\,8/9,\\,5/9]$ mapped to $[0,1]$.\n- Compute the $L^2$-norm of the magnitude error,\n$$\ne_{\\mathrm{mag}} = \\left( \\int_{0}^{1} \\left( \\left\\| [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s)) \\right\\|_2 - \\left\\| [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s)) \\right\\|_2 \\right)^2 \\, L \\,\\mathrm{d}s \\right)^{1/2}.\n$$\n- Determine the sign of the computed normal opening at the segment midpoint $s = 1/2$,\n$$\n\\mathrm{sign}_h = \\mathrm{sign}\\left( \\boldsymbol{n} \\cdot [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(1/2)) \\right),\n$$\nand verify that it matches the analytical sign\n$$\n\\mathrm{sign}_{\\star} = \\mathrm{sign}\\left( \\boldsymbol{n} \\cdot [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(1/2)) \\right).\n$$\nRecord a boolean $\\mathrm{sign\\_ok}$ indicating equality of these signs.\n\nTest suite:\n\nFor each case, define the rectangular element nodes $\\{\\boldsymbol{x}_i\\}_{i=1}^{4}$, unit crack normal $\\boldsymbol{n}$, a point on the crack $\\boldsymbol{x}_0$, and the manufactured half-jump $\\boldsymbol{F}(\\boldsymbol{x})$.\n\n- Case $1$:\n    - $\\boldsymbol{x}_1=(0,0)$, $\\boldsymbol{x}_2=(1,0)$, $\\boldsymbol{x}_3=(1,1)$, $\\boldsymbol{x}_4=(0,1)$.\n    - $\\boldsymbol{n}=(0,1)$, $\\boldsymbol{x}_0=(0,0.3)$.\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} 0.2 + 0.5 x + 0.1 y - 0.1 x y \\\\ 0.3 + 0.2 x + 0.05 y + 0.0 x y \\end{bmatrix}$.\n- Case $2$:\n    - $\\boldsymbol{x}_1=(0,-1)$, $\\boldsymbol{x}_2=(2,-1)$, $\\boldsymbol{x}_3=(2,1)$, $\\boldsymbol{x}_4=(0,1)$.\n    - $\\boldsymbol{n}=(1,0)$, $\\boldsymbol{x}_0=(0.5,0)$.\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} -0.4 - 0.3 x + 0.2 y + 0.1 x y \\\\ 0.1 - 0.1 x + 0.05 y - 0.02 x y \\end{bmatrix}$.\n- Case $3$:\n    - $\\boldsymbol{x}_1=(-1,-1)$, $\\boldsymbol{x}_2=(2,-1)$, $\\boldsymbol{x}_3=(2,2)$, $\\boldsymbol{x}_4=(-1,2)$.\n    - $\\boldsymbol{n}=\\frac{1}{\\sqrt{2}}(1,1)$, $\\boldsymbol{x}_0=(0,0)$.\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} 0.1 + 0.2 x - 0.05 y + 0.03 x y \\\\ -0.2 + 0.4 x + 0.3 y - 0.06 x y \\end{bmatrix}$.\n- Case $4$ (non-bilinear, to generate a nonzero interpolation error):\n    - $\\boldsymbol{x}_1=(0,0)$, $\\boldsymbol{x}_2=(1,0)$, $\\boldsymbol{x}_3=(1,1)$, $\\boldsymbol{x}_4=(0,1)$.\n    - $\\boldsymbol{n}=\\frac{1}{\\sqrt{2}}(1,-1)$, $\\boldsymbol{x}_0=(0.5,0.5)$.\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} 0.1 + x^2 \\\\ 0.2 - y^2 + 0.1 x y \\end{bmatrix}$.\n\nRequired final output format:\n\n- For each case, compute the triple $\\left(e_{\\mathrm{vec}}, e_{\\mathrm{mag}}, \\mathrm{sign\\_ok}\\right)$ as defined above. Aggregate all results into a single list containing the values in order, flattened as\n$$\n[e_{\\mathrm{vec}}^{(1)}, e_{\\mathrm{mag}}^{(1)}, \\mathrm{sign\\_ok}^{(1)}, e_{\\mathrm{vec}}^{(2)}, e_{\\mathrm{mag}}^{(2)}, \\mathrm{sign\\_ok}^{(2)}, e_{\\mathrm{vec}}^{(3)}, e_{\\mathrm{mag}}^{(3)}, \\mathrm{sign\\_ok}^{(3)}, e_{\\mathrm{vec}}^{(4)}, e_{\\mathrm{mag}}^{(4)}, \\mathrm{sign\\_ok}^{(4)}].\n$$\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12}]$.\n\nAngle units are not applicable. There are no physical units to report; this is a purely mathematical validation. All computations must be carried out in double precision.", "solution": "The problem presented is a well-posed and scientifically sound exercise in the verification of a numerical method, specifically the extended finite element method (XFEM) for modeling cracks. It employs the method of manufactured solutions, a standard and rigorous technique for assessing the correctness and convergence of code implementations. All provided definitions, from the XFEM approximation to the geometric setup, are consistent with established literature in computational mechanics. The problem is valid, and a complete solution can be constructed.\n\nThe objective is to compute the discrepancy between an analytical displacement jump across a crack and its numerical approximation obtained from a single bilinear finite element. This is done for several test cases. The core of the task is to implement the specified computational protocol.\n\nFirst, we must recall the fundamental equations. The XFEM displacement approximation for an element intersected by a crack is given by:\n$$\n\\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{a}_i \\;+\\; H(\\phi(\\boldsymbol{x})) \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{b}_i\n$$\nHere, $\\boldsymbol{u}_h(\\boldsymbol{x})$ is the approximated displacement at point $\\boldsymbol{x}$. $N_i(\\boldsymbol{x})$ are the standard bilinear shape functions for a four-node quadrilateral element. The vectors $\\boldsymbol{a}_i$ are the classical nodal degrees of freedom, while the vectors $\\boldsymbol{b}_i$ are the *enriched* degrees of freedom that capture the displacement discontinuity. The function $H(\\phi(\\boldsymbol{x})) = \\mathrm{sign}(\\phi(\\boldsymbol{x}))$, where $\\phi(\\boldsymbol{x}) = \\boldsymbol{n} \\cdot (\\boldsymbol{x}-\\boldsymbol{x}_0)$ is the signed distance function (or level set), models the jump. The crack is located where $\\phi(\\boldsymbol{x})=0$.\n\nThe displacement jump, $[\\![\\boldsymbol{u}]\\!]$, across the crack is defined as the difference in displacement between the positive side ($\\phi > 0$) and the negative side ($\\phi < 0$). Applying the limit definition provided, the jump in the XFEM field is derived as:\n$$\n[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}) = \\lim_{\\epsilon \\to 0^+} \\left( \\boldsymbol{u}_h(\\boldsymbol{x}+\\epsilon \\boldsymbol{n}) - \\boldsymbol{u}_h(\\boldsymbol{x}-\\epsilon \\boldsymbol{n}) \\right) = 2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x})\\,\\boldsymbol{b}_i\n$$\nThe continuous part cancels out, and the jump from the Heaviside function (from $-1$ to $+1$) produces the factor of $2$.\n\nThe verification protocol uses a manufactured solution of the form:\n$$\n\\boldsymbol{u}^{\\star}(\\boldsymbol{x}) = \\boldsymbol{u}_{\\mathrm{cont}}(\\boldsymbol{x}) + H(\\phi(\\boldsymbol{x}))\\,\\boldsymbol{F}(\\boldsymbol{x})\n$$\nThe analytical jump for this solution is $[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}) = 2\\boldsymbol{F}(\\boldsymbol{x})$. To make the discrete and analytical solutions comparable, we set the enriched nodal degrees of freedom $\\boldsymbol{b}_i$ to be the nodal values of the function $\\boldsymbol{F}(\\boldsymbol{x})$, i.e., $\\boldsymbol{b}_i = \\boldsymbol{F}(\\boldsymbol{x}_i)$. With this choice, the XFEM approximation for the jump becomes an interpolation of the analytical jump values at the nodes:\n$$\n[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}) = 2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x})\\,\\boldsymbol{F}(\\boldsymbol{x}_i)\n$$\nThe discrepancy between the interpolated jump $[\\![ \\boldsymbol{u}_h ]\\!]$ and the analytical jump $[\\![ \\boldsymbol{u}^\\star ]\\!]$ is the interpolation error, which should be zero if $\\boldsymbol{F}(\\boldsymbol{x})$ is itself a bilinear function.\n\nThe computational procedure for each test case is as follows:\n\n1.  **Geometric Analysis**: First, we must identify the segment of the crack line that lies within the element boundaries. The crack is the line $\\phi(x,y)=0$. The element is a rectangle defined by four corner nodes. We test each of the four element edges. An edge connecting nodes $\\boldsymbol{p}_1$ and $\\boldsymbol{p}_2$ is intersected by the crack if the level set function $\\phi$ has opposite signs at the endpoints (i.e., $\\phi(\\boldsymbol{p}_1)\\phi(\\boldsymbol{p}_2) < 0$). The precise intersection point is found by linear interpolation. If the crack passes through a node (i.e., $\\phi(\\boldsymbol{p}_i) = 0$), that node itself is an intersection point. This process yields two unique endpoints, $\\boldsymbol{x}_A$ and $\\boldsymbol{x}_B$, defining the crack segment. The segment is parameterized as $\\boldsymbol{x}(s) = \\boldsymbol{x}_A + s(\\boldsymbol{x}_B-\\boldsymbol{x}_A)$ for $s \\in [0,1]$, and its length is $L = \\|\\boldsymbol{x}_B-\\boldsymbol{x}_A\\|_2$.\n\n2.  **Evaluation of Quantities for Integration**: We must compute the error norms using numerical integration. A $3$-point Gaussian quadrature rule is specified for integrals over the crack segment. The quadrature points $s_j$ and weights $W_j$ are derived by mapping the standard Gauss rule on $[-1,1]$ to the interval $[0,1]$. At each quadrature point $\\boldsymbol{x}(s_j)$:\n    *   The physical coordinates $\\boldsymbol{x}(s_j)$ are mapped to isoparametric coordinates $(\\xi_j, \\eta_j)$.\n    *   The bilinear shape functions $N_i(\\xi_j, \\eta_j)$ are evaluated.\n    *   The discrete jump $[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s_j)) = 2 \\sum_i N_i(\\xi_j,\\eta_j)\\boldsymbol{F}(\\boldsymbol{x}_i)$ is computed.\n    *   The analytical jump $[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s_j)) = 2\\boldsymbol{F}(\\boldsymbol{x}(s_j))$ is computed.\n\n3.  **Computation of Validation Metrics**:\n    *   The $L^2$-norm of the vector error, $e_{\\mathrm{vec}}$, is approximated by the quadrature sum:\n        $$\n        e_{\\mathrm{vec}} = \\left( L \\sum_{j=1}^{3} W_j \\left\\| [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s_j)) - [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s_j)) \\right\\|_2^2 \\right)^{1/2}\n        $$\n    *   Similarly, the $L^2$-norm of the magnitude error, $e_{\\mathrm{mag}}$, is computed:\n        $$\n        e_{\\mathrm{mag}} = \\left( L \\sum_{j=1}^{3} W_j \\left( \\left\\| [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s_j)) \\right\\|_2 - \\left\\| [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s_j)) \\right\\|_2 \\right)^2 \\right)^{1/2}\n        $$\n    *   Finally, a sign check is performed at the midpoint of the crack segment, $\\boldsymbol{x}(1/2)$. The boolean $\\mathrm{sign\\_ok}$ is true if the sign of the normal component of the discrete jump, $\\boldsymbol{n} \\cdot [\\![\\boldsymbol{u}_h]\\!]$, matches that of the analytical jump, $\\boldsymbol{n} \\cdot [\\![\\boldsymbol{u}^{\\star}]\\!]$.\n\nThis procedure is systematically applied to each of the four test cases. The first three cases use a bilinear function for $\\boldsymbol{F}(\\boldsymbol{x})$, for which the bilinear interpolation is exact. Therefore, the computed errors $e_{\\mathrm{vec}}$ and $e_{\\mathrm{mag}}$ are expected to be zero within machine precision. The fourth case utilizes a non-bilinear (quadratic) $\\boldsymbol{F}(\\boldsymbol{x})$, which will expose the interpolation error inherent in the bilinear approximation, resulting in non-zero error metrics. This serves as a non-trivial test of the implementation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the XFEM validation problem for all test cases.\n    \"\"\"\n\n    # Gauss quadrature points and weights for the interval [0, 1]\n    # Mapped from [-sqrt(3/5), 0, sqrt(3/5)] and [5/9, 8/9, 5/9] on [-1, 1].\n    s_gauss_pts = [0.5 * (1.0 - np.sqrt(3.0 / 5.0)), 0.5, 0.5 * (1.0 + np.sqrt(3.0 / 5.0))]\n    w_gauss_wts = [5.0 / 18.0, 8.0 / 18.0, 5.0 / 18.0]\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"n\": np.array([0.0, 1.0]),\n            \"x0\": np.array([0.0, 0.3]),\n            \"F\": lambda x, y: np.array([\n                0.2 + 0.5 * x + 0.1 * y - 0.1 * x * y,\n                0.3 + 0.2 * x + 0.05 * y + 0.0 * x * y\n            ]),\n        },\n        {\n            \"nodes\": np.array([[0.0, -1.0], [2.0, -1.0], [2.0, 1.0], [0.0, 1.0]]),\n            \"n\": np.array([1.0, 0.0]),\n            \"x0\": np.array([0.5, 0.0]),\n            \"F\": lambda x, y: np.array([\n                -0.4 - 0.3 * x + 0.2 * y + 0.1 * x * y,\n                0.1 - 0.1 * x + 0.05 * y - 0.02 * x * y\n            ]),\n        },\n        {\n            \"nodes\": np.array([[-1.0, -1.0], [2.0, -1.0], [2.0, 2.0], [-1.0, 2.0]]),\n            \"n\": np.array([1.0 / np.sqrt(2.0), 1.0 / np.sqrt(2.0)]),\n            \"x0\": np.array([0.0, 0.0]),\n            \"F\": lambda x, y: np.array([\n                0.1 + 0.2 * x - 0.05 * y + 0.03 * x * y,\n                -0.2 + 0.4 * x + 0.3 * y - 0.06 * x * y\n            ]),\n        },\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"n\": np.array([1.0 / np.sqrt(2.0), -1.0 / np.sqrt(2.0)]),\n            \"x0\": np.array([0.5, 0.5]),\n            \"F\": lambda x, y: np.array([\n                0.1 + x**2,\n                0.2 - y**2 + 0.1 * x * y\n            ]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        n_crack = case[\"n\"]\n        x0_crack = case[\"x0\"]\n        F_func = case[\"F\"]\n        \n        # --- 1. Find crack segment ---\n        def phi(p):\n            return np.dot(n_crack, p - x0_crack)\n\n        edges = [(nodes[0], nodes[1]), (nodes[1], nodes[2]), \n                 (nodes[2], nodes[3]), (nodes[3], nodes[0])]\n        \n        intersections = []\n        tol = 1e-12\n        for p1, p2 in edges:\n            phi1 = phi(p1)\n            phi2 = phi(p2)\n            if abs(phi1) < tol:\n                intersections.append(p1)\n            if phi1 * phi2 < -tol: # Strict sign change\n                t = phi1 / (phi1 - phi2)\n                intersect_pt = p1 + t * (p2 - p1)\n                intersections.append(intersect_pt)\n\n        # Deduplicate intersections\n        unique_intersections = []\n        if intersections:\n            # Sort to bring close points together\n            sorted_pts = sorted([tuple(p) for p in intersections])\n            unique_intersections.append(np.array(sorted_pts[0]))\n            for i in range(1, len(sorted_pts)):\n                if not np.allclose(sorted_pts[i], sorted_pts[i-1], atol=tol):\n                    unique_intersections.append(np.array(sorted_pts[i]))\n\n        if len(unique_intersections) != 2:\n            # This case should not occur for the given problems.\n            # An element is either uncut (0), cut (2), or grazed (1, not in tests).\n            # A cut through two vertices gives 2 points.\n            raise ValueError(f\"Expected 2 intersection points, found {len(unique_intersections)}\")\n\n        xA, xB = unique_intersections[0], unique_intersections[1]\n        L = np.linalg.norm(xB - xA)\n\n        # --- 2. Element properties and shape functions ---\n        xL, yB = nodes[0]\n        xR, yT = nodes[2]\n        w = xR - xL\n        h = yT - yB\n        xC = (xL + xR) / 2.0\n        yC = (yB + yT) / 2.0\n        \n        def physical_to_iso(x, y):\n            xi = 2.0 * (x - xC) / w\n            eta = 2.0 * (y - yC) / h\n            return xi, eta\n\n        def shape_functions(xi, eta):\n            N1 = 0.25 * (1 - xi) * (1 - eta)\n            N2 = 0.25 * (1 + xi) * (1 - eta)\n            N3 = 0.25 * (1 + xi) * (1 + eta)\n            N4 = 0.25 * (1 - xi) * (1 + eta)\n            return np.array([N1, N2, N3, N4])\n        \n        # --- 3. Compute enriched DOFs ---\n        b_dofs = np.array([F_func(p[0], p[1]) for p in nodes])\n        \n        # --- 4. Numerical integration for error norms ---\n        e_vec_sq_sum = 0.0\n        e_mag_sq_sum = 0.0\n        \n        for s, weight in zip(s_gauss_pts, w_gauss_wts):\n            x_s = xA + s * (xB - xA)\n            \n            xi, eta = physical_to_iso(x_s[0], x_s[1])\n            N_vals = shape_functions(xi, eta)\n            \n            jump_h = 2.0 * np.dot(N_vals, b_dofs)\n            jump_star = 2.0 * F_func(x_s[0], x_s[1])\n            \n            vec_error = jump_h - jump_star\n            e_vec_sq_sum += weight * np.dot(vec_error, vec_error)\n            \n            mag_error = np.linalg.norm(jump_h) - np.linalg.norm(jump_star)\n            e_mag_sq_sum += weight * (mag_error**2)\n\n        e_vec = np.sqrt(L * e_vec_sq_sum)\n        e_mag = np.sqrt(L * e_mag_sq_sum)\n\n        # --- 5. Sign check at midpoint ---\n        s_mid = 0.5\n        x_mid = xA + s_mid * (xB - xA)\n        \n        xi_mid, eta_mid = physical_to_iso(x_mid[0], x_mid[1])\n        N_mid = shape_functions(xi_mid, eta_mid)\n        \n        jump_h_mid = 2.0 * np.dot(N_mid, b_dofs)\n        jump_star_mid = 2.0 * F_func(x_mid[0], x_mid[1])\n        \n        sign_h = np.sign(np.dot(n_crack, jump_h_mid))\n        sign_star = np.sign(np.dot(n_crack, jump_star_mid))\n        \n        sign_ok = int(sign_h == sign_star)\n        \n        results.extend([e_vec, e_mag, sign_ok])\n\n    # Final print statement in the exact required format.\n    # We convert boolean `sign_ok` to integer 1/0.\n    formatted_results = [f\"{val:.15g}\" if isinstance(val, float) else str(val) for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2557321"}]}