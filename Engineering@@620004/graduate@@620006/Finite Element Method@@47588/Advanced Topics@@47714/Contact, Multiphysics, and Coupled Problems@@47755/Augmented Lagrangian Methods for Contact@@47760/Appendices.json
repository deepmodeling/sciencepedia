{"hands_on_practices": [{"introduction": "This first exercise [@problem_id:2541954] provides a tangible introduction to penalty methods, the conceptual foundation of Augmented Lagrangian techniques. By analyzing a simple one-dimensional bar pressing against a wall, you will numerically verify how the penalty parameter enforces a non-penetration constraint. This practice builds intuition by demonstrating how the penalized solution systematically approaches the exact constrained solution as the penalty parameter grows.", "problem": "Consider a one-dimensional, linearly elastic bar discretized by a single two-node linear finite element in the Finite Element Method (FEM). The bar has axial stiffness $k = \\dfrac{EA}{L}$, where $E$ is Young’s modulus, $A$ is cross-sectional area, and $L$ is length. The left node is prescribed a rightward displacement $u_{1} = U$, and the right node $u_{2}$ may come into unilateral, frictionless contact with a rigid wall located at a distance $g_{0}$ from the bar’s undeformed right end. Adopt the sign convention that the scalar normal gap is $g(u_{2}) = g_{0} - u_{2}$ and the unilateral contact constraint is $g(u_{2}) \\ge 0$.\n\nUsing the principle of minimum total potential energy together with the Augmented Lagrangian Method (ALM) for contact, specialize to the first augmented iteration with initial multiplier $\\lambda^{(0)} = 0$ and a fixed penalty parameter $\\varepsilon > 0$. Under this specialization, the stationary problem at the first augmented step reduces to minimizing the elastic energy plus a quadratic penalty on the violation of the non-penetration constraint. Explicitly derive the scalar stationarity condition for $u_{2}$ and solve it in closed form, distinguishing the no-contact and contact-active cases, to obtain $u_{2}(\\varepsilon)$ and the associated reaction $R(\\varepsilon)$ at the right node.\n\nThen, with the following data,\n- $k = 1000\\,\\mathrm{N/m}$,\n- $U = 0.01\\,\\mathrm{m}$,\n- $g_{0} = 0.006\\,\\mathrm{m}$,\nevaluate the contact reaction $R(\\varepsilon)$ for three penalty values $\\varepsilon \\in \\{100\\,\\mathrm{N/m}, 1000\\,\\mathrm{N/m}, 10000\\,\\mathrm{N/m}\\}$ and also determine the limiting constrained reaction $R^{\\star}$ as $\\varepsilon \\to \\infty$. You may assume that the contact-active branch is the relevant one for these data, but you must justify it from your derived conditions.\n\nReport your final result as a single row matrix containing the four forces, in this order:\n$[R(100\\,\\mathrm{N/m}),\\; R(1000\\,\\mathrm{N/m}),\\; R(10000\\,\\mathrm{N/m}),\\; R^{\\star}]$.\nExpress all forces in newtons. Provide exact values (no rounding).", "solution": "We model the bar as a single axial finite element with nodal displacements $u_{1}$ and $u_{2}$. The internal elastic energy for the element is\n$$\n\\Pi_{\\text{int}}(u_{1},u_{2}) = \\frac{1}{2}\\,k\\,(u_{1} - u_{2})^{2}.\n$$\nThere is no external follower force at the right node; the left node displacement is prescribed as $u_{1} = U$. The unilateral, frictionless contact with a rigid wall at the right end is represented by the normal gap\n$$\ng(u_{2}) = g_{0} - u_{2},\n$$\nwith the constraint $g(u_{2}) \\ge 0$ (non-penetration). The Augmented Lagrangian Method (ALM) uses a Lagrange multiplier $\\lambda$ for the constraint and a penalty parameter $\\varepsilon > 0$ to stabilize/improve convergence. At the first augmented step with initial multiplier $\\lambda^{(0)} = 0$, the augmented potential reduces to a penalty regularization of the constraint violation:\n$$\n\\Pi_{\\varepsilon}(u_{2}) \\equiv \\Pi_{\\text{int}}(U,u_{2}) + \\frac{\\varepsilon}{2}\\,\\big\\langle -g(u_{2}) \\big\\rangle_{+}^{2}\n= \\frac{1}{2}\\,k\\,(U - u_{2})^{2} + \\frac{\\varepsilon}{2}\\,\\big\\langle u_{2} - g_{0} \\big\\rangle_{+}^{2},\n$$\nwhere $\\langle x \\rangle_{+} = \\max(x,0)$ is the positive-part function. The minimizer $u_{2}$ satisfies the variational stationarity condition, which we can derive by piecewise differentiation depending on whether the contact is inactive ($u_{2} \\le g_{0}$) or active ($u_{2} > g_{0}$).\n\nCase $1$ (no contact, $u_{2} \\le g_{0}$): Here $\\langle u_{2} - g_{0} \\rangle_{+} = 0$, so\n$$\n\\Pi_{\\varepsilon}(u_{2}) = \\frac{1}{2}\\,k\\,(U - u_{2})^{2}.\n$$\nStationarity $\\dfrac{d\\Pi_{\\varepsilon}}{du_{2}} = 0$ gives\n$$\n-k\\,(U - u_{2}) = 0 \\quad \\Rightarrow \\quad u_{2} = U.\n$$\nThis candidate is admissible in Case $1$ only if $u_{2} \\le g_{0}$, i.e., $U \\le g_{0}$.\n\nCase $2$ (active contact, $u_{2} > g_{0}$): Here $\\langle u_{2} - g_{0} \\rangle_{+} = u_{2} - g_{0}$, and\n$$\n\\Pi_{\\varepsilon}(u_{2}) = \\frac{1}{2}\\,k\\,(U - u_{2})^{2} + \\frac{\\varepsilon}{2}\\,(u_{2} - g_{0})^{2}.\n$$\nStationarity gives\n$$\n-k\\,(U - u_{2}) + \\varepsilon\\,(u_{2} - g_{0}) = 0\n\\quad \\Rightarrow \\quad\n(k + \\varepsilon)\\,u_{2} = k\\,U + \\varepsilon\\,g_{0}\n\\quad \\Rightarrow \\quad\nu_{2}(\\varepsilon) = \\frac{k\\,U + \\varepsilon\\,g_{0}}{k + \\varepsilon}.\n$$\nThis candidate is admissible in Case $2$ if $u_{2}(\\varepsilon) > g_{0}$. Observe that\n$$\nu_{2}(\\varepsilon) - g_{0} = \\frac{k\\,U + \\varepsilon\\,g_{0}}{k + \\varepsilon} - g_{0}\n= \\frac{k\\,(U - g_{0})}{k + \\varepsilon}.\n$$\nTherefore, if $U > g_{0}$ and $\\varepsilon > 0$, then $u_{2}(\\varepsilon) - g_{0} > 0$, so the contact-active case is self-consistent and unique.\n\nFrom the penalty term, the nodal contact reaction at the right node is\n$$\nR(\\varepsilon) = \\varepsilon\\,\\langle u_{2}(\\varepsilon) - g_{0} \\rangle_{+} = \\varepsilon\\,(u_{2}(\\varepsilon) - g_{0})\n= \\varepsilon\\,\\frac{k\\,(U - g_{0})}{k + \\varepsilon}\n= \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0}).\n$$\nEquivalently, by internal equilibrium, the axial force in the bar is\n$$\nN(\\varepsilon) = k\\,(U - u_{2}(\\varepsilon)) = \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0}),\n$$\nwhich matches $R(\\varepsilon)$, as expected.\n\nThe constrained (exact) contact solution corresponds to enforcing $u_{2} = g_{0}$, giving the limiting reaction as $\\varepsilon \\to \\infty$:\n$$\nR^{\\star} = \\lim_{\\varepsilon \\to \\infty} R(\\varepsilon) = \\lim_{\\varepsilon \\to \\infty} \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0})\n= k\\,(U - g_{0}).\n$$\n\nNow substitute the given data $k = 1000\\,\\mathrm{N/m}$, $U = 0.01\\,\\mathrm{m}$, and $g_{0} = 0.006\\,\\mathrm{m}$. First note that $U - g_{0} = 0.004\\,\\mathrm{m} > 0$, so the active-contact branch applies for every $\\varepsilon > 0$:\n$$\nR(\\varepsilon) = \\frac{\\varepsilon \\cdot 1000}{1000 + \\varepsilon} \\cdot 0.004.\n$$\nEvaluate at the requested penalty values:\n- For $\\varepsilon = 100\\,\\mathrm{N/m}$,\n$$\nR(100) = \\frac{100 \\cdot 1000}{1000 + 100} \\cdot 0.004\n= \\frac{100000}{1100} \\cdot 0.004\n= \\frac{1000}{11} \\cdot 0.004\n= \\frac{4}{11}.\n$$\n- For $\\varepsilon = 1000\\,\\mathrm{N/m}$,\n$$\nR(1000) = \\frac{1000 \\cdot 1000}{1000 + 1000} \\cdot 0.004\n= \\frac{1000000}{2000} \\cdot 0.004\n= 500 \\cdot 0.004\n= 2.\n$$\n- For $\\varepsilon = 10000\\,\\mathrm{N/m}$,\n$$\nR(10000) = \\frac{10000 \\cdot 1000}{1000 + 10000} \\cdot 0.004\n= \\frac{10000000}{11000} \\cdot 0.004\n= \\frac{10000}{11} \\cdot 0.004\n= \\frac{40}{11}.\n$$\nFinally, the constrained limit is\n$$\nR^{\\star} = 1000 \\cdot 0.004 = 4.\n$$\n\nThus the requested row matrix, in newtons, is\n$$\n\\big[\\, R(100),\\; R(1000),\\; R(10000),\\; R^{\\star} \\,\\big]\n= \\left[\\, \\frac{4}{11},\\; 2,\\; \\frac{40}{11},\\; 4 \\,\\right].\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{4}{11}  2  \\frac{40}{11}  4\\end{pmatrix}}$$", "id": "2541954"}, {"introduction": "Implicit finite element solvers rely on the Newton-Raphson method, which requires the consistent linearization of all force contributions. This exercise [@problem_id:2541817] dives into this crucial step by having you derive the tangent stiffness for a non-smooth contact constraint treated with an augmented Lagrangian formulation. Mastering this derivation is key to developing numerically efficient and robust contact algorithms with quadratic convergence.", "problem": "Consider a single-node, frictionless, unilateral contact between a deformable body and a rigid obstacle in the Finite Element Method (FEM). Let the kinematic normal gap be the scalar function $g(u) = a\\,u - c$, where $u \\in \\mathbb{R}$ is the nodal normal displacement, $a \\in \\mathbb{R}$ is the constant directional derivative of the gap with respect to $u$ (with $a > 0$), and $c \\in \\mathbb{R}$ is a constant offset. The contact is governed by the Kuhn–Tucker conditions for frictionless contact: $g(u) \\ge 0$, $\\lambda \\ge 0$, and $g(u)\\,\\lambda = 0$, where $\\lambda \\in \\mathbb{R}$ is the normal contact Lagrange multiplier.\n\nAn augmented Lagrangian method (ALM) is used with penalty parameter $\\rho > 0$. The algorithmic multiplier is updated using a projection at Newton iteration $k$:\n$$\n\\tilde{\\lambda}(u) \\equiv P\\!\\left(\\lambda^{k} - \\rho\\,g(u)\\right),\n$$\nwhere $P(y) = \\max(0,y)$ is the projection operator onto $[0,\\infty)$. The contribution of the contact to the global residual of the displacement equilibrium equation is modeled by the derivative of the contact potential, which for this formulation is $r(u) = -a\\,\\tilde{\\lambda}(u)$.\n\nDefine the Heaviside step function $H(y)$ almost everywhere as $H(y)=0$ for $y0$ and $H(y)=1$ for $y0$.\n\nStarting solely from the preceding definitions, derive the consistent linearization (Newton tangent) $k(u) = \\frac{dr}{du}$. Introduce the auxiliary variable $y \\equiv \\lambda^{k} - \\rho\\,g(u)$ and express your final result for $k(u)$ in closed form in terms of $a$, $\\rho$, and $H(y)$. Your final answer must be a single analytic expression. No numerical evaluation is required and no units are involved.", "solution": "The objective is to find the consistent linearization of the contact residual contribution, $r(u)$, which is its derivative with respect to the displacement variable $u$. This derivative is the contact tangent stiffness, denoted $k(u)$.\n$$\nk(u) = \\frac{dr}{du}\n$$\nThe residual contribution is defined as $r(u) = -a\\,\\tilde{\\lambda}(u)$. Since $a$ is a constant, the derivative is:\n$$\nk(u) = -a\\,\\frac{d\\tilde{\\lambda}}{du}\n$$\nThe algorithmic multiplier $\\tilde{\\lambda}(u)$ is a composite function defined as $\\tilde{\\lambda}(u) = P(y(u))$, where $P(y) = \\max(0,y)$ and the auxiliary variable $y(u)$ is given by $y(u) = \\lambda^{k} - \\rho\\,g(u)$. We must apply the chain rule for differentiation:\n$$\n\\frac{d\\tilde{\\lambda}}{du} = \\frac{dP}{dy} \\frac{dy}{du}\n$$\nWe compute each term in the chain rule separately.\n\nFirst, we find the derivative of the projection operator $P(y) = \\max(0,y)$. This is a non-smooth function, and its derivative is defined almost everywhere by the Heaviside step function:\n- For $y  0$, $P(y) = 0$, so $\\frac{dP}{dy} = 0$.\n- For $y > 0$, $P(y) = y$, so $\\frac{dP}{dy} = 1$.\nThis generalized derivative can be written as:\n$$\n\\frac{dP}{dy} = H(y)\n$$\nSecond, we find the derivative of the auxiliary variable $y(u)$ with respect to $u$. The function $y(u)$ is given by:\n$$\ny(u) = \\lambda^{k} - \\rho\\,g(u)\n$$\nSubstituting the definition of the gap function, $g(u) = a\\,u - c$:\n$$\ny(u) = \\lambda^{k} - \\rho(a\\,u - c) = \\lambda^{k} - \\rho\\,a\\,u + \\rho\\,c\n$$\nThe quantities $\\lambda^{k}$, $\\rho$, $a$, and $c$ are constant with respect to the differentiation variable $u$ within the current Newton iteration. Thus, the derivative is:\n$$\n\\frac{dy}{du} = \\frac{d}{du} (\\lambda^{k} - \\rho\\,a\\,u + \\rho\\,c) = -\\rho\\,a\n$$\nNow, we substitute these two derivatives back into the chain rule expression:\n$$\n\\frac{d\\tilde{\\lambda}}{du} = \\frac{dP}{dy} \\frac{dy}{du} = H(y) \\cdot (-\\rho\\,a) = -\\rho\\,a\\,H(y)\n$$\nFinally, we substitute this result into the expression for the tangent stiffness $k(u)$:\n$$\nk(u) = -a\\,\\frac{d\\tilde{\\lambda}}{du} = -a\\,(-\\rho\\,a\\,H(y)) = a^2\\,\\rho\\,H(y)\n$$\nThis is the consistent linearization of the contact residual, which is a positive semi-definite contribution to the system's tangent stiffness matrix, ensuring numerical stability. The result is expressed in the required terms of $a$, $\\rho$, and $H(y)$, where $y \\equiv \\lambda^{k} - \\rho\\,g(u)$.", "answer": "$$\n\\boxed{a^2 \\rho H(y)}\n$$", "id": "2541817"}, {"introduction": "Theory becomes practice in this final challenge, where you will implement a complete algorithmic update for frictional contact [@problem_id:2541924]. You will translate the abstract Karush–Kuhn–Tucker (KKT) conditions and Coulomb's friction law into a concrete predictor-corrector scheme that correctly navigates between separation, stick, and slip regimes. This hands-on coding exercise simulates the core logic found within sophisticated commercial and open-source simulation software.", "problem": "Consider a single two-dimensional node-to-rigid-plane contact element used in the finite element method, with a unit outward normal aligned with the vertical axis. Let the scalar normal gap be denoted by $g_n$. By convention, $g_n > 0$ indicates separation, $g_n = 0$ indicates contact, and a negative gap ($g_n  0$) represents interpenetration that must be corrected by contact forces. Let the tangential relative displacement increment be the vector $\\mathbf{s}_t \\in \\mathbb{R}^2$ lying in the plane tangent to the rigid surface. The contact tractions are represented by Lagrange multipliers: the normal multiplier $\\lambda_n \\ge 0$ (compressive contact pressure) and the tangential multiplier vector $\\boldsymbol{\\lambda}_t \\in \\mathbb{R}^2$. The friction model is Coulomb friction with coefficient $\\mu \\ge 0$. An augmented Lagrangian method uses positive penalty parameters $\\rho_n > 0$ and $\\rho_t > 0$ for the normal and tangential directions, respectively, to update the Lagrange multipliers.\n\nStarting from the fundamental Signorini conditions for unilateral contact, $g_n \\ge 0$, $\\lambda_n \\ge 0$, and $g_n \\lambda_n = 0$, and the Coulomb friction law defined by the friction cone $\\{\\boldsymbol{\\lambda}_t \\in \\mathbb{R}^2 : \\|\\boldsymbol{\\lambda}_t\\| \\le \\mu \\lambda_n\\}$ and the stick/slip rules, derive a principled augmented Lagrangian update that enforces the contact constraints by projecting the unconstrained multiplier updates onto the admissible sets implied by these laws. Your derivation should show how to obtain an algorithmic update for $\\lambda_n$ and $\\boldsymbol{\\lambda}_t$ along with a regime classification into separation, stick, or slip.\n\nThen implement a program that, given previous multipliers $\\lambda_n^{\\text{old}}$ and $\\boldsymbol{\\lambda}_t^{\\text{old}}$, current kinematics $(g_n, \\mathbf{s}_t)$, penalty parameters $(\\rho_n, \\rho_t)$, and friction coefficient $\\mu$, computes:\n- the updated normal multiplier $\\lambda_n^{\\text{new}}$,\n- the updated tangential multiplier $\\boldsymbol{\\lambda}_t^{\\text{new}}$,\n- the contact regime code $r \\in \\{0,1,2\\}$ with $r=0$ denoting separation, $r=1$ denoting stick, and $r=2$ denoting slip.\n\nExpress all quantities as dimensionless real numbers; no physical units are required for this problem. The algorithm must be robust to the edge case where the trial tangential state lies exactly on the friction cone.\n\nUse the following test suite (each case provides $(g_n, \\mathbf{s}_t, \\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}}, \\rho_n, \\rho_t, \\mu)$):\n- Case A (stick): $g_n = -10^{-5}$, $\\mathbf{s}_t = [10^{-7}, 2 \\cdot 10^{-7}]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n- Case B (slip): $g_n = -5 \\cdot 10^{-6}$, $\\mathbf{s}_t = [2 \\cdot 10^{-2}, 0]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n- Case C (separation): $g_n = 10^{-3}$, $\\mathbf{s}_t = [10^{-3}, -10^{-3}]$, $\\lambda_n^{\\text{old}} = 10^{3}$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [1, -1]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n- Case D (on-cone boundary, treat as stick): $g_n = -10^{-6}$, $\\mathbf{s}_t = [6 \\cdot 10^{-7}, 0]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n\nYour program should process the cases in the order A, B, C, D and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case’s result is itself a list of four numbers $[\\lambda_n^{\\text{new}}, \\lambda_{t,x}^{\\text{new}}, \\lambda_{t,y}^{\\text{new}}, r]$. For example, the final output must look like $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ with no additional text. All numbers must be printed in standard decimal form. The contact regime code must be an integer in $\\{0,1,2\\}$.", "solution": "The derivation of the augmented Lagrangian update for frictional contact is an operator split method, often called a predictor-corrector algorithm. This approach first computes a \"trial\" state by ignoring the constraints and then \"corrects\" this state by projecting it onto the physically admissible set of forces.\n\nThe state is defined by the normal gap $g_n$ and tangential slip increment $\\mathbf{s}_t$, with corresponding forces (Lagrange multipliers) $\\lambda_n$ and $\\boldsymbol{\\lambda}_t$.\n\nThe constraints are:\n1.  **Normal Direction (Unilateral Contact):** The Karush-Kuhn-Tucker (KKT) or Signorini conditions require $g_n \\ge 0$ (no penetration), $\\lambda_n \\ge 0$ (compressive pressure only), and $g_n \\lambda_n = 0$ (force exists only at contact).\n2.  **Tangential Direction (Coulomb Friction):** The tangential force magnitude is limited by the normal force, $\\|\\boldsymbol{\\lambda}_t\\| \\le \\mu \\lambda_n$, which defines the friction cone.\n\nThe update algorithm proceeds from the previous state $(\\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}})$ to the new state $(\\lambda_n^{\\text{new}}, \\boldsymbol{\\lambda}_t^{\\text{new}})$ based on current kinematics $(g_n, \\mathbf{s}_t)$.\n\n**Step 1: Normal Multiplier Update (Predictor-Corrector)**\n\nFirst, a \"trial\" normal pressure, $\\lambda_n^{\\text{trial}}$, is computed. This value represents the force needed to close the gap/penetration, augmented by the previous step's pressure. The gap definition ($g_n0$ for penetration) leads to the update:\n$$\n\\lambda_n^{\\text{trial}} = \\lambda_n^{\\text{old}} - \\rho_n g_n\n$$\nThis trial pressure may be negative (tensile), violating the $\\lambda_n \\ge 0$ constraint. We correct it by projecting it onto the set of non-negative numbers:\n$$\n\\lambda_n^{\\text{new}} = \\max(0, \\lambda_n^{\\text{trial}}) = \\max(0, \\lambda_n^{\\text{old}} - \\rho_n g_n)\n$$\nThis single equation enforces the KKT conditions for the normal direction. If $\\lambda_n^{\\text{new}} = 0$, the surfaces are separated. This implies no friction can be transmitted, so $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\mathbf{0}$, and the regime is **separation** ($r=0$). The algorithm terminates for this point.\n\n**Step 2: Tangential Multiplier Update (If in Contact)**\n\nIf $\\lambda_n^{\\text{new}} > 0$, the surfaces are in contact, and we proceed to the tangential update.\nFirst, a \"trial\" tangential traction, $\\boldsymbol{\\lambda}_t^{\\text{trial}}$, is computed assuming a stick condition. This is the force required to prevent the slip increment $\\mathbf{s}_t$:\n$$\n\\boldsymbol{\\lambda}_t^{\\text{trial}} = \\boldsymbol{\\lambda}_t^{\\text{old}} + \\rho_t \\mathbf{s}_t\n$$\nNext, this trial state is checked against the friction cone boundary. The maximum allowable magnitude for the tangential traction is defined by the **updated** normal pressure: $F_{\\text{lim}} = \\mu \\lambda_n^{\\text{new}}$. We check if the trial traction is inside or on the cone:\n$$\n\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| \\le F_{\\text{lim}}\n$$\nTwo cases arise from this check:\n\n**Case 2a: Stick Condition ($\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| \\le F_{\\text{lim}}$)**\nIf the trial traction's magnitude is within the friction limit, the stick assumption is valid. The trial traction is the final updated traction. The regime is **stick** ($r=1$).\n$$\n\\boldsymbol{\\lambda}_t^{\\text{new}} = \\boldsymbol{\\lambda}_t^{\\text{trial}}\n$$\n\n**Case 2b: Slip Condition ($\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| > F_{\\text{lim}}$)**\nIf the trial traction's magnitude exceeds the limit, the stick assumption is invalid, and slip must occur. The final traction must lie on the boundary of the friction cone. We find it by projecting $\\boldsymbol{\\lambda}_t^{\\text{trial}}$ back to the cone boundary along a radial line. This \"radial return\" preserves the direction of the force, which opposes the slip.\n$$\n\\boldsymbol{\\lambda}_t^{\\text{new}} = F_{\\text{lim}} \\frac{\\boldsymbol{\\lambda}_t^{\\text{trial}}}{\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|}\n$$\nThe regime is **slip** ($r=2$).\n\nThis predictor-corrector sequence robustly and efficiently enforces the non-smooth physics of frictional contact within an iterative scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_contact_update(g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu):\n    \"\"\"\n    Computes the updated Lagrange multipliers and contact regime for a single node-to-plane element.\n\n    Args:\n        g_n (float): Normal gap (positive for separation).\n        s_t (np.ndarray): Tangential relative displacement increment vector (shape (2,)).\n        lambda_n_old (float): Normal multiplier from the previous iteration.\n        lambda_t_old (np.ndarray): Tangential multiplier vector from the previous iteration (shape (2,)).\n        rho_n (float): Normal penalty parameter.\n        rho_t (float): Tangential penalty parameter.\n        mu (float): Coefficient of friction.\n\n    Returns:\n        list: A list containing [lambda_n_new, lambda_tx_new, lambda_ty_new, regime_code].\n    \"\"\"\n    # Step 1: Normal Multiplier Update (Predictor-Corrector)\n    # The convention is that g_n  0 represents penetration, so subtracting rho_n*g_n increases the pressure.\n    lambda_n_trial = lambda_n_old - rho_n * g_n\n    lambda_n_new = max(0.0, lambda_n_trial)\n\n    # Step 2: Check for Separation\n    # If the new normal pressure is zero, there is no contact.\n    if lambda_n_new == 0.0:\n        lambda_t_new = np.array([0.0, 0.0])\n        regime_code = 0  # Separation\n    else:\n        # Step 3: Tangential Multiplier Update (If in Contact)\n        # 3a. Compute trial tangential multiplier (stick predictor)\n        lambda_t_trial = lambda_t_old + rho_t * s_t\n\n        # 3b. Calculate its Euclidean norm\n        norm_lambda_t_trial = np.linalg.norm(lambda_t_trial)\n\n        # 3c. Calculate the friction limit based on the *new* normal pressure\n        friction_limit = mu * lambda_n_new\n\n        # 3d. Compare trial state to friction limit and classify (stick/slip)\n        if norm_lambda_t_trial = friction_limit:\n            # Stick condition (including the on-cone boundary case as per problem spec)\n            lambda_t_new = lambda_t_trial\n            regime_code = 1  # Stick\n        else:\n            # Slip condition (radial return projection)\n            # Project the trial traction back onto the friction cone boundary\n            lambda_t_new = friction_limit * (lambda_t_trial / norm_lambda_t_trial)\n            regime_code = 2  # Slip\n\n    return [lambda_n_new, lambda_t_new[0], lambda_t_new[1], regime_code]\n\ndef solve():\n    \"\"\"\n    Processes the test suite and prints the final results in the specified format.\n    \"\"\"\n    # Test suite: (g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu)\n    test_cases = [\n        # Case A (stick)\n        (-1e-5, np.array([1e-7, 2e-7]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n        # Case B (slip)\n        (-5e-6, np.array([2e-2, 0.0]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n        # Case C (separation)\n        (1e-3, np.array([1e-3, -1e-3]), 1e3, np.array([1.0, -1.0]), 1e6, 5e5, 0.3),\n        # Case D (on-cone boundary, stick)\n        (-1e-6, np.array([6e-7, 0.0]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu = case\n        result = compute_contact_update(g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu)\n        results.append(result)\n\n    # Format the final output string as specified: [[r1],[r2],[r3],[r4]]\n    results_str_list = []\n    for res in results:\n        # res = [lambda_n, lambda_tx, lambda_ty, regime]\n        # Format numbers to standard decimal form, regime code as an integer.\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        results_str_list.append(inner_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2541924"}]}