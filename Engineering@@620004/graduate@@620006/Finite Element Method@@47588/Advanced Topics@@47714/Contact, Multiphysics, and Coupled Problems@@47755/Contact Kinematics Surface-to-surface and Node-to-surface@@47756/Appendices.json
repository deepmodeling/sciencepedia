{"hands_on_practices": [{"introduction": "We begin our hands-on exploration with the most fundamental scenario in computational contact mechanics: a single slave node interacting with a flat master surface. This exercise provides a solid foundation by guiding you through the calculation of the normal gap, $g_n$, the cornerstone of contact kinematics. By applying the penalty method, you will then derive the resulting contact force $f_c$ and consistent tangent stiffness $k_c$, directly connecting the geometric configuration to the mechanical reaction forces essential for a finite element simulation [@problem_id:2548022].", "problem": "Consider a point-to-plane (node-to-surface) unilateral contact scenario in the Finite Element Method (FEM), in which a slave node at current position $\\boldsymbol{x}_s \\in \\mathbb{R}^3$ interacts with a planar master surface. The master surface is defined by a point $\\boldsymbol{x}_0 \\in \\mathbb{R}^3$ and a unit normal $\\boldsymbol{n} \\in \\mathbb{R}^3$. Assume small kinematics and a frictionless, purely normal interaction.\n\nStarting from first principles of contact kinematics and the principle of virtual work with a quadratic penalty regularization for unilateral contact, proceed as follows:\n- Define the signed normal gap $g_n$ in terms of $\\boldsymbol{x}_s$, $\\boldsymbol{x}_0$, and $\\boldsymbol{n}$ for a planar master surface, and explain the contact activation condition.\n- From an admissible penalty potential for unilateral normal contact, derive the scalar normal contact force $f_c$ and the associated scalar consistent tangent $k_c := \\partial f_c / \\partial g_n$.\n- Evaluate $g_n$, $f_c$, and $k_c$ for the numerical data given below.\n\nUse the following data:\n- Slave node position $\\boldsymbol{x}_s = \\left(0.3998,\\, -0.1,\\, 0.1998\\right)\\,\\text{m}$,\n- Point on the plane $\\boldsymbol{x}_0 = \\left(0.4,\\, -0.1,\\, 0.2\\right)\\,\\text{m}$,\n- Unit normal to the plane $\\boldsymbol{n} = \\dfrac{1}{3}\\left(1,\\, 2,\\, 2\\right)$,\n- Normal penalty parameter $\\epsilon_n = 3.5 \\times 10^{7}\\,\\text{N/m}$.\n\nAdopt the sign convention that $g_n < 0$ denotes penetration (active contact) and $g_n \\ge 0$ denotes separation (no contact). Express $g_n$ in meters, $f_c$ in Newtons, and $k_c$ in Newtons per meter. Round your final numerical results to four significant figures.\n\nYour final answer must report, in the order $(g_n,\\ f_c,\\ k_c)$, the three values.", "solution": "The problem statement presented is formally examined and found to be valid. It is scientifically grounded in the principles of computational contact mechanics, specifically the penalty method in the Finite Element Method. It is well-posed, providing all necessary data for a unique solution. The language is objective and unambiguous. We may therefore proceed with the solution.\n\nThe problem asks for the evaluation of the contact state between a slave node and a master plane. This requires, first, a precise definition of the geometric relationship (the gap), and second, a constitutive law for the interaction force based on this geometry.\n\nFirst, we define the signed normal gap, $g_n$. For a slave node at position $\\boldsymbol{x}_s$ and a master plane defined by a point $\\boldsymbol{x}_0$ and an outward-pointing unit normal $\\boldsymbol{n}$, the gap is the signed orthogonal distance from the node to the plane. This is computed by projecting the vector connecting a point on the plane to the slave node, $(\\boldsymbol{x}_s - \\boldsymbol{x}_0)$, onto the normal vector $\\boldsymbol{n}$.\n$$g_n = (\\boldsymbol{x}_s - \\boldsymbol{x}_0) \\cdot \\boldsymbol{n}$$\nThe sign convention is given: $g_n < 0$ implies penetration, meaning the slave node has crossed the plane in the direction opposite to $\\boldsymbol{n}$. The condition $g_n \\ge 0$ implies that the node is on or outside the contact surface, resulting in separation. Therefore, the contact activation condition, or Kuhn-Tucker condition for this unilateral constraint, is $g_n < 0$.\n\nSecond, we derive the contact force and tangent stiffness from a penalty potential. The penalty method regularizes the strict non-penetration constraint by allowing for a small, unphysical penetration, which is penalized by a repulsive force proportional to the penetration depth. A standard quadratic penalty potential $\\Pi_p$ for unilateral normal contact is given by:\n$$\\Pi_p(g_n) = \\begin{cases} \\frac{1}{2} \\epsilon_n g_n^2 & \\text{if } g_n < 0 \\\\ 0 & \\text{if } g_n \\ge 0 \\end{cases}$$\nwhere $\\epsilon_n > 0$ is the penalty parameter.\n\nThe scalar normal contact force, which we define as the magnitude of the repulsive force vector $\\boldsymbol{F}_c = f_c \\boldsymbol{n}$, must be non-negative, $f_c \\ge 0$. It is derived from the Karush-Kuhn-Tucker (KKT) conditions, which are approximated in the penalty method as $f_c \\approx \\epsilon_n \\max(0, -g_n)$. This results in:\n$$f_c(g_n) = \\begin{cases} -\\epsilon_n g_n & \\text{if } g_n < 0 \\\\ 0 & \\text{if } g_n \\ge 0 \\end{cases}$$\nFor $g_n < 0 $, the penetration depth is $|g_n| = -g_n$, so the force $f_c = \\epsilon_n |g_n|$ is positive, correctly representing repulsion.\n\nThe associated scalar consistent tangent is defined as $k_c := \\partial f_c / \\partial g_n$. We differentiate the expression for $f_c$:\n$$k_c(g_n) = \\frac{\\partial f_c}{\\partial g_n} = \\begin{cases} \\frac{\\partial}{\\partial g_n}(-\\epsilon_n g_n) & \\text{if } g_n < 0 \\\\ \\frac{\\partial}{\\partial g_n}(0) & \\text{if } g_n \\ge 0 \\end{cases} = \\begin{cases} -\\epsilon_n & \\text{if } g_n < 0 \\\\ 0 & \\text{if } g_n \\ge 0 \\end{cases}$$\nThe negative sign of $k_c$ for an active contact is correct and expected from these definitions. It signifies that an increase in the force magnitude ($df_c > 0$) corresponds to an increase in penetration, which means a decrease in the algebraic value of the gap ($dg_n < 0$).\n\nWe now evaluate these quantities using the provided numerical data:\n- Slave node position $\\boldsymbol{x}_s = \\begin{pmatrix} 0.3998 \\\\ -0.1 \\\\ 0.1998 \\end{pmatrix}\\,\\text{m}$\n- Point on the plane $\\boldsymbol{x}_0 = \\begin{pmatrix} 0.4 \\\\ -0.1 \\\\ 0.2 \\end{pmatrix}\\,\\text{m}$\n- Unit normal to the plane $\\boldsymbol{n} = \\frac{1}{3}\\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix}$\n- Normal penalty parameter $\\epsilon_n = 3.5 \\times 10^{7}\\,\\text{N/m}$\n\nFirst, we compute the vector from $\\boldsymbol{x}_0$ to $\\boldsymbol{x}_s$:\n$$\\boldsymbol{x}_s - \\boldsymbol{x}_0 = \\begin{pmatrix} 0.3998 - 0.4 \\\\ -0.1 - (-0.1) \\\\ 0.1998 - 0.2 \\end{pmatrix} = \\begin{pmatrix} -0.0002 \\\\ 0 \\\\ -0.0002 \\end{pmatrix}\\,\\text{m}$$\n\nNext, we calculate the signed normal gap $g_n$:\n$$g_n = (\\boldsymbol{x}_s - \\boldsymbol{x}_0) \\cdot \\boldsymbol{n} = \\begin{pmatrix} -0.0002 \\\\ 0 \\\\ -0.0002 \\end{pmatrix} \\cdot \\left(\\frac{1}{3}\\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix}\\right)$$\n$$g_n = \\frac{1}{3} \\left( (-0.0002)(1) + (0)(2) + (-0.0002)(2) \\right) = \\frac{1}{3} (-0.0002 - 0.0004) = \\frac{-0.0006}{3}$$\n$$g_n = -0.0002\\,\\text{m}$$\nRounding to four significant figures gives $g_n = -2.000 \\times 10^{-4}\\,\\text{m}$.\n\nSince $g_n < 0$, the contact is active (penetration). We proceed to calculate the force $f_c$ and stiffness $k_c$.\nFor active contact:\n$$f_c = -\\epsilon_n g_n = -(3.5 \\times 10^{7}\\,\\text{N/m})(-0.0002\\,\\text{m})$$\n$$f_c = (3.5 \\times 10^{7})(2 \\times 10^{-4})\\,\\text{N} = 7 \\times 10^{3}\\,\\text{N}$$\n$$f_c = 7000\\,\\text{N}$$\nRounding to four significant figures gives $f_c = 7.000 \\times 10^{3}\\,\\text{N}$.\n\nFor active contact, the tangent stiffness is:\n$$k_c = -\\epsilon_n = -3.5 \\times 10^{7}\\,\\text{N/m}$$\nRounding to four significant figures gives $k_c = -3.500 \\times 10^{7}\\,\\text{N/m}$.\n\nThe final results are $(g_n, f_c, k_c)$.", "answer": "$$\\boxed{\\begin{pmatrix} -2.000 \\times 10^{-4} & 7.000 \\times 10^{3} & -3.500 \\times 10^{7} \\end{pmatrix}}$$", "id": "2548022"}, {"introduction": "Having established the basic force-gap relationship, we now tackle the central geometric challenge in surface-to-surface contact: finding the closest point of projection. This practice moves beyond simple planar geometries and asks you to implement a single step of the Gauss-Newton algorithm, a powerful iterative method for solving the nonlinear equations that define contact between two general surfaces. This exercise is crucial for understanding how contact pairs are numerically established in advanced simulations [@problem_id:2548007].", "problem": "You are given two isoparametric bilinear quadrilateral patches in three-dimensional Euclidean space, a slave patch and a master patch, each defined by four nodes and the standard bilinear shape functions over the reference square. The goal is to compute the normal gap for surface-to-surface contact at a specified slave Gauss point by solving for the master closest-point parametric coordinates using a single Gaussâ€“Newton step starting from a given initial guess.\n\nUse the following fundamental base and definitions:\n\n- The slave surface mapping is given by the isoparametric bilinear map\n$$\\mathbf{x}_s(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_{s,i},$$\nand the master surface mapping\n$$\\mathbf{x}_m(\\hat{\\xi},\\hat{\\eta}) = \\sum_{i=1}^{4} N_i(\\hat{\\xi},\\hat{\\eta})\\,\\mathbf{X}_{m,i},$$\nwhere the bilinear shape functions over the parametric domain $[-1,1]\\times[-1,1]$ are\n$$N_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad N_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),$$\n$$N_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad N_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta).$$\n- The master surface tangent vectors are\n$$\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})=\\frac{\\partial \\mathbf{x}_m}{\\partial \\xi}(\\hat{\\xi},\\hat{\\eta}),\\quad \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})=\\frac{\\partial \\mathbf{x}_m}{\\partial \\eta}(\\hat{\\xi},\\hat{\\eta}).$$\n- The master unit normal (following the right-hand rule of the parametrization) is\n$$\\mathbf{n}(\\hat{\\xi},\\hat{\\eta})=\\frac{\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})\\times \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})}{\\|\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})\\times \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})\\|}.$$\n- For a given slave point $\\mathbf{x}_s(\\xi_s,\\eta_s)$, the closest-point projection onto the master surface seeks $\\hat{\\boldsymbol{\\xi}}=[\\hat{\\xi},\\hat{\\eta}]^\\top$ such that the residual\n$$\\mathbf{R}(\\hat{\\xi},\\hat{\\eta})=\\mathbf{x}_m(\\hat{\\xi},\\hat{\\eta})-\\mathbf{x}_s(\\xi_s,\\eta_s)$$\nis orthogonal to the local tangent space, that is,\n$$\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})\\cdot \\mathbf{R}(\\hat{\\xi},\\hat{\\eta})=0,\\quad \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})\\cdot \\mathbf{R}(\\hat{\\xi},\\hat{\\eta})=0.$$\n- The Gaussâ€“Newton update for these conditions, from an initial guess $\\hat{\\boldsymbol{\\xi}}_0$, solves\n$$\\mathbf{G}(\\hat{\\boldsymbol{\\xi}}_0)\\,\\Delta \\hat{\\boldsymbol{\\xi}} = -\\mathbf{b}(\\hat{\\boldsymbol{\\xi}}_0),$$\nwith\n$$\\mathbf{G}=\n\\begin{bmatrix}\n\\mathbf{t}_\\xi\\cdot \\mathbf{t}_\\xi & \\mathbf{t}_\\xi\\cdot \\mathbf{t}_\\eta\\\\\n\\mathbf{t}_\\eta\\cdot \\mathbf{t}_\\xi & \\mathbf{t}_\\eta\\cdot \\mathbf{t}_\\eta\n\\end{bmatrix},\\quad\n\\mathbf{b}=\n\\begin{bmatrix}\n\\mathbf{t}_\\xi\\cdot \\mathbf{R}\\\\\n\\mathbf{t}_\\eta\\cdot \\mathbf{R}\n\\end{bmatrix},$$\nwhere all quantities are evaluated at $\\hat{\\boldsymbol{\\xi}}_0$. The one-step update is $\\hat{\\boldsymbol{\\xi}}_1=\\hat{\\boldsymbol{\\xi}}_0+\\Delta \\hat{\\boldsymbol{\\xi}}$.\n- The normal gap at the slave point is defined as\n$$g_n(\\xi_s,\\eta_s) = \\mathbf{n}(\\hat{\\boldsymbol{\\xi}}_1)\\cdot\\left(\\mathbf{x}_s(\\xi_s,\\eta_s)-\\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_1)\\right).$$\n\nAll coordinates are in meters; the normal gap must be reported in meters. Use the above definitions without introducing any additional modeling assumptions. Do not clamp the updated parametric coordinates $\\hat{\\boldsymbol{\\xi}}_1$ to the reference square; evaluate $\\mathbf{n}$ and $\\mathbf{x}_m$ at the updated value as-is.\n\nCompute $g_n(\\xi_s,\\eta_s)$ for the following test suite. In each case, use the same slave Gauss point and the same initial guess for the master parametric coordinates:\n- Slave Gauss point parameters: $(\\xi_s,\\eta_s)=\\left(\\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}}\\right)$.\n- Initial guess for the master projection: $\\hat{\\boldsymbol{\\xi}}_0=[0,0]^\\top$.\n\nTest cases:\n\n- Case $1$ (parallel planes, constant offset):\n  - Master nodes $(\\mathbf{X}_{m,1},\\mathbf{X}_{m,2},\\mathbf{X}_{m,3},\\mathbf{X}_{m,4})$:\n    $$\\left[(-1,-1,0),\\ (1,-1,0),\\ (1,1,0),\\ (-1,1,0)\\right].$$\n  - Slave nodes $(\\mathbf{X}_{s,1},\\mathbf{X}_{s,2},\\mathbf{X}_{s,3},\\mathbf{X}_{s,4})$:\n    $$\\left[(-1,-1,0.2),\\ (1,-1,0.2),\\ (1,1,0.2),\\ (-1,1,0.2)\\right].$$\n\n- Case $2$ (tilted master about the $x$-axis by $10$ degrees, slave parallel plane at constant height):\n  - Let $\\theta=\\frac{\\pi}{18}$ (radians). Start from the square in the plane $z=0$ with nodes\n    $$\\left[(-1,-1,0),\\ (1,-1,0),\\ (1,1,0),\\ (-1,1,0)\\right]$$\n    and rotate each node about the $x$-axis by angle $\\theta$ using the standard rotation\n    $$y' = y\\cos\\theta - z\\sin\\theta,\\quad z' = y\\sin\\theta + z\\cos\\theta.$$\n    The rotated coordinates define $(\\mathbf{X}_{m,i})$.\n  - Slave nodes:\n    $$\\left[(-1,-1,0.2),\\ (1,-1,0.2),\\ (1,1,0.2),\\ (-1,1,0.2)\\right].$$\n\n- Case $3$ (twisted master, slave offset plane):\n  - Master nodes:\n    $$\\left[(-1,-1,0.0),\\ (1,-1,0.1),\\ (1,1,0.0),\\ (-1,1,-0.1)\\right].$$\n  - Slave nodes:\n    $$\\left[(-1,-1,0.05),\\ (1,-1,0.05),\\ (1,1,0.05),\\ (-1,1,0.05)\\right].$$\n\n- Case $4$ (slave point outside the master span, smaller master patch):\n  - Master nodes:\n    $$\\left[(-0.5,-0.5,0.0),\\ (0.5,-0.5,0.0),\\ (0.5,0.5,0.0),\\ (-0.5,0.5,0.0)\\right].$$\n  - Slave nodes:\n    $$\\left[(-1,-1,0.1),\\ (1,-1,0.1),\\ (1,1,0.1),\\ (-1,1,0.1)\\right].$$\n\nRequirements and output specification:\n\n- Implement the evaluation of the bilinear shape functions and their parametric derivatives exactly as defined above.\n- Implement the Gaussâ€“Newton linear system for a single update from $\\hat{\\boldsymbol{\\xi}}_0$ to $\\hat{\\boldsymbol{\\xi}}_1$ using the matrix $\\mathbf{G}$ and right-hand side $\\mathbf{b}$ defined above.\n- For each case, compute the slave point $\\mathbf{x}_s(\\xi_s,\\eta_s)$, update $\\hat{\\boldsymbol{\\xi}}$ once, compute the master unit normal at the updated parametric location, and then compute $g_n(\\xi_s,\\eta_s)$.\n- Express the final normal gaps in meters, rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ to $4$, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$.", "solution": "The problem posed is a well-defined exercise in computational contact mechanics, specifically concerning the surface-to-surface contact formulation within the finite element method. All provided definitions, initial conditions, and test cases are scientifically sound, mathematically consistent, and complete. The problem is therefore valid and permits a direct, unambiguous solution.\n\nThe objective is to compute the normal gap, $g_n$, between a slave surface and a master surface at a specific slave point. This computation involves a single Gauss-Newton iteration to approximate the closest point on the master surface. The entire procedure will be executed for four distinct test cases.\n\nLet us begin by formalizing the required mathematical components. The position vector of a point on an isoparametric bilinear quadrilateral patch is given by\n$$\n\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_{i}\n$$\nwhere $\\mathbf{X}_{i}$ are the coordinates of the four corner nodes, and $N_i(\\xi,\\eta)$ are the bilinear shape functions defined on the parametric domain $[-1,1]\\times[-1,1]$:\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta) &= \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi,\\eta) &= \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi,\\eta) &= \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi,\\eta) &= \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThe tangent vectors to the surface are found by differentiating the position vector with respect to the parametric coordinates, $\\xi$ and $\\eta$.\n$$\n\\begin{aligned}\n\\mathbf{t}_\\xi(\\xi,\\eta) &= \\frac{\\partial \\mathbf{x}}{\\partial \\xi}(\\xi,\\eta) = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi}(\\xi,\\eta)\\,\\mathbf{X}_{i} \\\\\n\\mathbf{t}_\\eta(\\xi,\\eta) &= \\frac{\\partial \\mathbf{x}}{\\partial \\eta}(\\xi,\\eta) = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta}(\\xi,\\eta)\\,\\mathbf{X}_{i}\n\\end{aligned}\n$$\nThe necessary partial derivatives of the shape functions are:\n$$\n\\begin{aligned}\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta) \\\\\n\\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi), \\quad \\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n\\end{aligned}\n$$\nThe procedure for computing the normal gap $g_n$ for each case is as follows.\n\nStep $1$: Compute the position of the specified slave point.\nThe slave Gauss point is given by $(\\xi_s, \\eta_s) = (\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}})$. The slave point in $3$D space, $\\mathbf{x}_s$, is computed using the slave surface mapping:\n$$\n\\mathbf{x}_s = \\mathbf{x}_s(\\xi_s, \\eta_s) = \\sum_{i=1}^{4} N_i(\\xi_s,\\eta_s)\\,\\mathbf{X}_{s,i}\n$$\n\nStep $2$: Perform one Gauss-Newton iteration to find the projected master coordinates.\nWe start with the initial guess for the master parametric coordinates, $\\hat{\\boldsymbol{\\xi}}_0 = [\\hat{\\xi}_0, \\hat{\\eta}_0]^\\top = [0, 0]^\\top$. We must solve the linear system $\\mathbf{G}(\\hat{\\boldsymbol{\\xi}}_0)\\,\\Delta \\hat{\\boldsymbol{\\xi}} = -\\mathbf{b}(\\hat{\\boldsymbol{\\xi}}_0)$ for the update $\\Delta \\hat{\\boldsymbol{\\xi}} = [\\Delta\\hat{\\xi}, \\Delta\\hat{\\eta}]^\\top$.\n\nFirst, evaluate all quantities at $\\hat{\\boldsymbol{\\xi}}_0$.\nThe master point is $\\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_0)$. The residual vector is $\\mathbf{R}(\\hat{\\boldsymbol{\\xi}}_0) = \\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_0) - \\mathbf{x}_s$. The master tangent vectors are $\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_0)$ and $\\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_0)$.\n\nNext, assemble the $2 \\times 2$ matrix $\\mathbf{G}$ and the $2 \\times 1$ vector $\\mathbf{b}$:\n$$\n\\mathbf{G}(\\hat{\\boldsymbol{\\xi}}_0) =\n\\begin{bmatrix}\n\\mathbf{t}_\\xi \\cdot \\mathbf{t}_\\xi & \\mathbf{t}_\\xi \\cdot \\mathbf{t}_\\eta \\\\\n\\mathbf{t}_\\eta \\cdot \\mathbf{t}_\\xi & \\mathbf{t}_\\eta \\cdot \\mathbf{t}_\\eta\n\\end{bmatrix}_{\\hat{\\boldsymbol{\\xi}}_0}\n\\quad\n\\mathbf{b}(\\hat{\\boldsymbol{\\xi}}_0) =\n\\begin{bmatrix}\n\\mathbf{t}_\\xi \\cdot \\mathbf{R} \\\\\n\\mathbf{t}_\\eta \\cdot \\mathbf{R}\n\\end{bmatrix}_{\\hat{\\boldsymbol{\\xi}}_0}\n$$\nSolving the linear system yields the update $\\Delta \\hat{\\boldsymbol{\\xi}}$. For a $2 \\times 2$ system, this is straightforward using Cramer's rule or matrix inversion.\n\nStep $3$: Update the master parametric coordinates.\nThe updated master coordinates are $\\hat{\\boldsymbol{\\xi}}_1 = \\hat{\\boldsymbol{\\xi}}_0 + \\Delta \\hat{\\boldsymbol{\\xi}}$. The problem specifies not to clamp these values to the domain $[-1,1]^2$.\n\nStep $4$: Compute the normal gap.\nThe final step is to evaluate the normal gap $g_n$ using the updated coordinates $\\hat{\\boldsymbol{\\xi}}_1 = [\\hat{\\xi}_1, \\hat{\\eta}_1]^\\top$.\nFirst, calculate the master point $\\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_1)$ and the master tangent vectors $\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_1)$ and $\\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_1)$ at the new location.\nThen, compute the master unit normal vector:\n$$\n\\mathbf{n}(\\hat{\\boldsymbol{\\xi}}_1) = \\frac{\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_1) \\times \\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_1)}{\\|\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_1) \\times \\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_1)\\|}\n$$\nThe normal gap is the signed distance from the projected master point to the slave point, measured along the master normal:\n$$\ng_n = \\mathbf{n}(\\hat{\\boldsymbol{\\xi}}_1) \\cdot (\\mathbf{x}_s - \\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_1))\n$$\nThis procedure is repeated for all four test cases provided.\n\nFor Case $2$, the master nodes must first be computed. Starting from the nodes $\\mathbf{X}_{i}^{(0)} = (x_i, y_i, 0)$ of a square in the $z=0$ plane, we apply a rotation by $\\theta = \\pi/18$ radians about the $x$-axis. The transformation is given by:\n$$\nx' = x, \\quad y' = y\\cos\\theta - z\\sin\\theta, \\quad z' = y\\sin\\theta + z\\cos\\theta\n$$\nFor a point $(x, y, 0)$, this simplifies to $(x, y\\cos\\theta, y\\sin\\theta)$. The resulting coordinates $\\mathbf{X}_{m,i} = (x_i, y_i\\cos\\theta, y_i\\sin\\theta)$ are then used in the general algorithm.\n\nThe implementation will follow these steps precisely for each case, using numerical arrays to represent vectors and matrices and employing standard linear algebra operations for dot products, cross products, and solving the linear system. The final results are rounded to six decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the contact kinematics problem for four test cases.\n    \"\"\"\n\n    # --- Utilities for Bilinear Quadrilateral Patches ---\n\n    def eval_shape_functions(xi, eta):\n        \"\"\"\n        Evaluates the 4 bilinear shape functions at a given parametric point.\n        \"\"\"\n        N1 = 0.25 * (1.0 - xi) * (1.0 - eta)\n        N2 = 0.25 * (1.0 + xi) * (1.0 - eta)\n        N3 = 0.25 * (1.0 + xi) * (1.0 + eta)\n        N4 = 0.25 * (1.0 - xi) * (1.0 + eta)\n        return np.array([N1, N2, N3, N4])\n\n    def eval_shape_derivatives(xi, eta):\n        \"\"\"\n        Evaluates the parametric derivatives of the 4 bilinear shape functions.\n        Returns two arrays: dN/d_xi and dN/d_eta.\n        \"\"\"\n        dN_dxi = np.array([\n            -0.25 * (1.0 - eta),\n             0.25 * (1.0 - eta),\n             0.25 * (1.0 + eta),\n            -0.25 * (1.0 + eta)\n        ])\n        dN_deta = np.array([\n            -0.25 * (1.0 - xi),\n            -0.25 * (1.0 + xi),\n             0.25 * (1.0 + xi),\n             0.25 * (1.0 - xi)\n        ])\n        return dN_dxi, dN_deta\n\n    def eval_position(xi, eta, nodes):\n        \"\"\"\n        Computes the position vector x for a given parametric point.\n        \"\"\"\n        N = eval_shape_functions(xi, eta)\n        return N @ nodes\n\n    def eval_tangents(xi, eta, nodes):\n        \"\"\"\n        Computes the tangent vectors t_xi and t_eta.\n        \"\"\"\n        dN_dxi, dN_deta = eval_shape_derivatives(xi, eta)\n        t_xi = dN_dxi @ nodes\n        t_eta = dN_deta @ nodes\n        return t_xi, t_eta\n\n    # --- Problem Parameters ---\n\n    xi_s, eta_s = 1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)\n    xi_hat_0 = np.array([0.0, 0.0])\n\n    # --- Test Case Definitions ---\n\n    # Case 1: Parallel planes\n    Xm1 = np.array([\n        [-1.0, -1.0, 0.0],\n        [ 1.0, -1.0, 0.0],\n        [ 1.0,  1.0, 0.0],\n        [-1.0,  1.0, 0.0]\n    ])\n    Xs1 = np.array([\n        [-1.0, -1.0, 0.2],\n        [ 1.0, -1.0, 0.2],\n        [ 1.0,  1.0, 0.2],\n        [-1.0,  1.0, 0.2]\n    ])\n\n    # Case 2: Tilted master plane\n    theta = np.pi / 18.0\n    rot_matrix = np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, np.cos(theta), -np.sin(theta)],\n        [0.0, np.sin(theta), np.cos(theta)]\n    ])\n    # Base nodes are same as Xm1\n    Xm2 = np.array([\n        [-1.0, -1.0 * np.cos(theta), -1.0 * np.sin(theta)],\n        [ 1.0, -1.0 * np.cos(theta), -1.0 * np.sin(theta)],\n        [ 1.0,  1.0 * np.cos(theta),  1.0 * np.sin(theta)],\n        [-1.0,  1.0 * np.cos(theta),  1.0 * np.sin(theta)]\n    ])\n    Xs2 = np.array([\n        [-1.0, -1.0, 0.2],\n        [ 1.0, -1.0, 0.2],\n        [ 1.0,  1.0, 0.2],\n        [-1.0,  1.0, 0.2]\n    ])\n\n    # Case 3: Twisted master\n    Xm3 = np.array([\n        [-1.0, -1.0,  0.0],\n        [ 1.0, -1.0,  0.1],\n        [ 1.0,  1.0,  0.0],\n        [-1.0,  1.0, -0.1]\n    ])\n    Xs3 = np.array([\n        [-1.0, -1.0, 0.05],\n        [ 1.0, -1.0, 0.05],\n        [ 1.0,  1.0, 0.05],\n        [-1.0,  1.0, 0.05]\n    ])\n\n    # Case 4: Slave point outside master span\n    Xm4 = np.array([\n        [-0.5, -0.5, 0.0],\n        [ 0.5, -0.5, 0.0],\n        [ 0.5,  0.5, 0.0],\n        [-0.5,  0.5, 0.0]\n    ])\n    Xs4 = np.array([\n        [-1.0, -1.0, 0.1],\n        [ 1.0, -1.0, 0.1],\n        [ 1.0,  1.0, 0.1],\n        [-1.0,  1.0, 0.1]\n    ])\n\n    test_cases = [\n        (Xm1, Xs1),\n        (Xm2, Xs2),\n        (Xm3, Xs3),\n        (Xm4, Xs4),\n    ]\n\n    results = []\n\n    for master_nodes, slave_nodes in test_cases:\n        # Step 1: Compute slave point\n        x_s = eval_position(xi_s, eta_s, slave_nodes)\n\n        # Step 2: Perform one Gauss-Newton step\n        # Evaluate quantities at initial guess xi_hat_0\n        xi0, eta0 = xi_hat_0\n        x_m_0 = eval_position(xi0, eta0, master_nodes)\n        t_xi_0, t_eta_0 = eval_tangents(xi0, eta0, master_nodes)\n        R_0 = x_m_0 - x_s\n\n        # Assemble Gauss-Newton system\n        G_matrix = np.array([\n            [np.dot(t_xi_0, t_xi_0), np.dot(t_xi_0, t_eta_0)],\n            [np.dot(t_eta_0, t_xi_0), np.dot(t_eta_0, t_eta_0)]\n        ])\n        b_vector = np.array([np.dot(t_xi_0, R_0), np.dot(t_eta_0, R_0)])\n\n        # Solve for the update\n        delta_xi_hat = np.linalg.solve(G_matrix, -b_vector)\n\n        # Step 3: Update master parametric coordinates\n        xi_hat_1 = xi_hat_0 + delta_xi_hat\n\n        # Step 4: Compute normal gap\n        xi1, eta1 = xi_hat_1\n        \n        # Evaluate quantities at updated coordinates xi_hat_1\n        x_m_1 = eval_position(xi1, eta1, master_nodes)\n        t_xi_1, t_eta_1 = eval_tangents(xi1, eta1, master_nodes)\n\n        # Compute master normal\n        normal_vec = np.cross(t_xi_1, t_eta_1)\n        norm_of_normal = np.linalg.norm(normal_vec)\n        if norm_of_normal > 1e-12: # Avoid division by zero for degenerate cases\n            unit_normal = normal_vec / norm_of_normal\n        else:\n            # Fallback for degenerate normal, though not expected in these cases\n            unit_normal = np.array([0.0, 0.0, 1.0])\n\n        # Compute final gap\n        gap_vector = x_s - x_m_1\n        g_n = np.dot(unit_normal, gap_vector)\n        \n        results.append(g_n)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2548007"}, {"introduction": "The final piece of our practical study involves translating distributed contact pressure into the discrete nodal forces required by the finite element framework. In this exercise, you will implement the integration of a penalty-based pressure field over a slave element's surface using Gauss quadrature, a standard numerical technique. This step bridges the gap between continuous contact mechanics theory and the discrete algebraic system that the computer ultimately solves, completing your understanding of a full surface-to-surface implementation [@problem_id:2548018].", "problem": "You are given a single isoparametric bilinear quadrilateral slave surface element in contact with a rigid plane. The element has four nodes with standard parent coordinates at $(-1,-1)$, $(+1,-1)$, $(+1,+1)$, $(-1,+1)$ and uses the standard bilinear shape functions $N_I(\\xi,\\eta)$ for $I=1,\\dots,4$ on the square parent domain $[-1,1]\\times[-1,1]$. The rigid plane is defined by a point $\\mathbf{x}_0$ on the plane and a unit normal vector $\\mathbf{n}$ pointing from the plane into the slave body. The normal gap field at a surface point with physical position $\\mathbf{x}(\\xi,\\eta)$ is defined as $g_n(\\xi,\\eta)=\\mathbf{n}\\cdot\\left(\\mathbf{x}(\\xi,\\eta)-\\mathbf{x}_0\\right)$. A penalty contact law is used with normal Lagrange multiplier (contact pressure) $\\lambda_n(\\xi,\\eta)=k_p\\,\\langle -g_n(\\xi,\\eta)\\rangle_+$, where $k_p$ is the penalty stiffness and $\\langle\\cdot\\rangle_+=\\max(0,\\cdot)$ denotes the Macaulay bracket. Contact is active only at quadrature points where $g_n(\\xi,\\eta)<0$. The element contact force vector is defined by the surface-to-surface weak form\n$$\n\\mathbf{f}_e=\\int_{\\mathcal{A}_c} \\mathbf{N}^T(\\xi,\\eta)\\,\\lambda_n(\\xi,\\eta)\\,\\mathbf{n}\\, \\mathrm{d}A,\n$$\nwhere $\\mathbf{N}^T(\\xi,\\eta)=\\operatorname{diag}\\left(N_1(\\xi,\\eta),N_1(\\xi,\\eta),N_1(\\xi,\\eta),\\dots,N_4(\\xi,\\eta),N_4(\\xi,\\eta),N_4(\\xi,\\eta)\\right)$ distributes the scalar pressure to the three translational components of each node, and $\\mathcal{A}_c$ is the active contact area subset. The surface differential $\\mathrm{d}A$ is computed via isoparametric mapping with $\\mathrm{d}A=\\left\\|\\mathbf{a}_1(\\xi,\\eta)\\times\\mathbf{a}_2(\\xi,\\eta)\\right\\|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$, where the covariant base vectors are $\\mathbf{a}_1=\\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial \\xi}\\,\\mathbf{X}_I$ and $\\mathbf{a}_2=\\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial \\eta}\\,\\mathbf{X}_I$ in terms of the physical nodal coordinates $\\mathbf{X}_I$. Approximate the integral using $2\\times 2$ Gauss quadrature with points at $(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3})$ and weight $w=1$ per point. Use only the active Gauss points for assembly.\n\nImplement a program that, for each specified test case below, computes the $12$-component element contact force vector $\\mathbf{f}_e=\\left[f_{1x},f_{1y},f_{1z},f_{2x},f_{2y},f_{2z},f_{3x},f_{3y},f_{3z},f_{4x},f_{4y},f_{4z}\\right]$ in Newtons. Follow these conventions:\n- The slave element nodes are ordered physically as $\\mathbf{X}_1=(0,0,z_1)$, $\\mathbf{X}_2=(L_x,0,z_2)$, $\\mathbf{X}_3=(L_x,L_y,z_3)$, $\\mathbf{X}_4=(0,L_y,z_4)$ with given $L_x$ and $L_y$ in meters and given nodal out-of-plane coordinates $z_I$ in meters.\n- The rigid plane has $\\mathbf{x}_0=(0,0,0)$ and $\\mathbf{n}=\\left[0,0,1\\right]^T$.\n- Use penalty stiffness $k_p$ as specified.\n- Use $2\\times 2$ Gauss quadrature with points $(\\xi,\\eta)\\in\\{\\left(-1/\\sqrt{3},-1/\\sqrt{3}\\right),\\left(+1/\\sqrt{3},-1/\\sqrt{3}\\right),\\left(+1/\\sqrt{3},+1/\\sqrt{3}\\right),\\left(-1/\\sqrt{3},+1/\\sqrt{3}\\right)\\}$ and weight $w=1$ for each point.\n- Treat a Gauss point as active if and only if $g_n(\\xi,\\eta)<0$.\n- Express the final nodal force components in Newtons and round each component to exactly $6$ decimal places.\n\nTest suite (all lengths in meters, forces in Newtons):\n- Case A (general active case): $L_x=0.2$, $L_y=0.1$, $k_p=10^9$, $(z_1,z_2,z_3,z_4)=(-0.001,-0.001,-0.001,-0.001)$.\n- Case B (no active points): $L_x=0.2$, $L_y=0.1$, $k_p=10^9$, $(z_1,z_2,z_3,z_4)=(+0.001,+0.001,+0.001,+0.001)$.\n- Case C (mixed active/inactive): $L_x=0.2$, $L_y=0.1$, $k_p=10^9$, $(z_1,z_2,z_3,z_4)=(-0.004,+0.001,+0.001,+0.001)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the three cases as a list of three sublists (one per case), where each sublist is the $12$-component force vector flattened in node-major order described above. The line should contain no spaces, and each float must be rounded to exactly $6$ decimal places. For example, a valid output has the form $[[a_1,a_2,\\dots,a_{12}],[b_1,b_2,\\dots,b_{12}],[c_1,c_2,\\dots,c_{12}]]$ with each $a_i$, $b_i$, $c_i$ a decimal number with exactly $6$ digits after the decimal point.", "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and complete.\n\n### Step 1: Extract Givens\n- **Element**: Isoparametric bilinear quadrilateral slave surface element with parent coordinates for nodes $1-4$ at $(âˆ’1,âˆ’1)$, $(+1,âˆ’1)$, $(+1,+1)$, $(âˆ’1,+1)$.\n- **Shape Functions**: $N_I(\\xi,\\eta)$ for $I=1,\\dots,4$.\n- **Rigid Plane**: Defined by point $\\mathbf{x}_0=(0,0,0)$ and normal $\\mathbf{n}=\\left[0,0,1\\right]^T$.\n- **Normal Gap**: $g_n(\\xi,\\eta)=\\mathbf{n}\\cdot\\left(\\mathbf{x}(\\xi,\\eta)-\\mathbf{x}_0\\right)$.\n- **Contact Law**: Penalty method with pressure $\\lambda_n(\\xi,\\eta)=k_p\\,\\langle -g_n(\\xi,\\eta)\\rangle_+$, where $\\langle\\cdot\\rangle_+=\\max(0,\\cdot)$. Contact is active where $g_n(\\xi,\\eta)<0$.\n- **Element Contact Force**: $\\mathbf{f}_e=\\int_{\\mathcal{A}_c} \\mathbf{N}^T(\\xi,\\eta)\\,\\lambda_n(\\xi,\\eta)\\,\\mathbf{n}\\, \\mathrm{d}A$. The problem statement provides a definition for $\\mathbf{N}^T$ as a diagonal matrix, which is dimensionally inconsistent. However, the text clarifies the intent is to \"distribute the scalar pressure to the three translational components of each node,\" which corresponds to the standard finite element formulation. We shall proceed with the standard interpretation where the force integrand for the $12$ degrees of freedom is the vector $\\lambda_n(\\xi,\\eta) [N_1\\mathbf{n}^T, N_2\\mathbf{n}^T, N_3\\mathbf{n}^T, N_4\\mathbf{n}^T]^T$.\n- **Surface Differential Area**: $\\mathrm{d}A=\\left\\|\\mathbf{a}_1(\\xi,\\eta)\\times\\mathbf{a}_2(\\xi,\\eta)\\right\\|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$, with covariant base vectors $\\mathbf{a}_1=\\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial \\xi}\\,\\mathbf{X}_I$ and $\\mathbf{a}_2=\\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial \\eta}\\,\\mathbf{X}_I$.\n- **Numerical Integration**: $2\\times 2$ Gauss quadrature with points $(\\xi,\\eta)\\in\\{\\left(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3}\\right)\\}$ and weight $w=1$ for each point. The integration is performed only over active Gauss points.\n- **Nodal Coordinates**: $\\mathbf{X}_1=(0,0,z_1)$, $\\mathbf{X}_2=(L_x,0,z_2)$, $\\mathbf{X}_3=(L_x,L_y,z_3)$, $\\mathbf{X}_4=(0,L_y,z_4)$.\n- **Test Cases**:\n    - **A**: $L_x=0.2$, $L_y=0.1$, $k_p=10^9$, $(z_1,z_2,z_3,z_4)=(-0.001,-0.001,-0.001,-0.001)$.\n    - **B**: $L_x=0.2$, $L_y=0.1$, $k_p=10^9$, $(z_1,z_2,z_3,z_4)=(+0.001,+0.001,+0.001,+0.001)$.\n    - **C**: $L_x=0.2$, $L_y=0.1$, $k_p=10^9$, $(z_1,z_2,z_3,z_4)=(-0.004,+0.001,+0.001,+0.001)$.\n- **Output Format**: A $12$-component force vector for each case, with each component rounded to $6$ decimal places.\n\n### Step 2: Validation\nThe problem is scientifically grounded in the theory of computational contact mechanics within the finite element method. It is well-posed, objective, and provides all necessary data to compute a unique solution. The only ambiguity lies in the definition of the matrix $\\mathbf{N}^T$, which, as noted, can be resolved by adhering to the standard, physically consistent formulation that aligns with the problem's descriptive text. The problem is therefore deemed **valid**.\n\n### Step 3: Solution\nThe nodal contact force vector $\\mathbf{f}_e$ is computed by numerically integrating the weak form of the contact virtual work. The integral is approximated by a sum over the $M=4$ Gauss quadrature points:\n$$\n\\mathbf{f}_e \\approx \\sum_{q=1}^{M} w_q \\, \\left( \\lambda_n(\\xi_q, \\eta_q) \\, \\mathbf{F}_{dist}(\\xi_q, \\eta_q) \\, J_A(\\xi_q, \\eta_q) \\right)\n$$\nwhere summation occurs only for active points (where $g_n < 0$). Here, $w_q=1$ is the Gauss weight, $(\\xi_q, \\eta_q)$ are the Gauss point coordinates, $\\lambda_n$ is the penalty pressure, $\\mathbf{F}_{dist}$ is the force distribution vector, and $J_A$ is the magnitude of the cross product of the surface covariant base vectors (surface Jacobian).\n\nThe procedure for each test case is as follows:\n\n1.  **Define Element Geometry and Parameters**: For each case, the nodal coordinates $\\mathbf{X}_I$ are defined based on the given $L_x$, $L_y$, and $z_I$. The penalty stiffness $k_p$ is set.\n\n2.  **Loop over Gauss Points**: We iterate through the four Gauss points $(\\xi_q, \\eta_q) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$.\n\n3.  **Evaluate Gap at each Gauss Point**:\n    - The bilinear shape functions $N_I(\\xi, \\eta)$ are:\n    $$\n    N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta), \\quad N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n    $$\n    $$\n    N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta), \\quad N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n    $$\n    - The physical position at a Gauss point is $\\mathbf{x}(\\xi_q, \\eta_q) = \\sum_{I=1}^4 N_I(\\xi_q, \\eta_q) \\mathbf{X}_I$.\n    - The gap is $g_n = \\mathbf{n} \\cdot (\\mathbf{x} - \\mathbf{x}_0)$. With $\\mathbf{n}=[0,0,1]^T$ and $\\mathbf{x}_0=\\mathbf{0}$, this simplifies to the interpolated z-coordinate: $g_n(\\xi_q, \\eta_q) = x_z(\\xi_q, \\eta_q) = \\sum_{I=1}^4 N_I(\\xi_q, \\eta_q) z_I$.\n\n4.  **Check for Active Contact**: A Gauss point is active if $g_n < 0$. If a point is not active, its contribution to the force vector is zero.\n\n5.  **Calculate Force Contribution from Active Points**: For each active Gauss point:\n    - The contact pressure is $\\lambda_n = k_p \\langle -g_n \\rangle_+ = -k_p g_n$.\n    - The derivatives of the shape functions, e.g., $\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta)$, $\\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi)$, etc., are evaluated.\n    - The covariant base vectors are computed: $\\mathbf{a}_1 = \\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial \\xi} \\mathbf{X}_I$ and $\\mathbf{a}_2 = \\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial \\eta} \\mathbf{X}_I$.\n    - The surface Jacobian determinant is calculated: $J_A = \\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|$.\n    - The force distribution vector is $\\mathbf{F}_{dist} = [N_1\\mathbf{n}^T, \\dots, N_4\\mathbf{n}^T]^T$. Since $\\mathbf{n}=[0,0,1]^T$, this vector has non-zero entries only for the z-degrees of freedom: $\\mathbf{F}_{dist} = [0, 0, N_1, 0, 0, N_2, 0, 0, N_3, 0, 0, N_4]^T$.\n    - The force increment from the current Gauss point is $\\Delta\\mathbf{f}_q = w_q \\lambda_n J_A \\mathbf{F}_{dist}$. Since $w_q=1$, this is $\\Delta\\mathbf{f}_q = \\lambda_n J_A \\mathbf{F}_{dist}$.\n\n6.  **Assemble Total Force Vector**: The total element force vector $\\mathbf{f}_e$ is the sum of the increments from all active Gauss points: $\\mathbf{f}_e = \\sum_{\\text{active } q} \\Delta\\mathbf{f}_q$.\n\n7.  **Final Formatting**: The components of the resulting $12$-component vector $\\mathbf{f}_e$ are rounded to $6$ decimal places as required. This process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the element contact force vector for a bilinear quadrilateral element\n    in contact with a rigid plane using a penalty method.\n    \"\"\"\n    test_cases = [\n        # Case A: General active case\n        {'Lx': 0.2, 'Ly': 0.1, 'kp': 1e9, 'z': (-0.001, -0.001, -0.001, -0.001)},\n        # Case B: No active points\n        {'Lx': 0.2, 'Ly': 0.1, 'kp': 1e9, 'z': (0.001, 0.001, 0.001, 0.001)},\n        # Case C: Mixed active/inactive\n        {'Lx': 0.2, 'Ly': 0.1, 'kp': 1e9, 'z': (-0.004, 0.001, 0.001, 0.001)},\n    ]\n\n    # Gauss quadrature points for 2x2 rule\n    alpha = 1.0 / np.sqrt(3.0)\n    gauss_points = [\n        (-alpha, -alpha),\n        (alpha, -alpha),\n        (alpha, alpha),\n        (-alpha, alpha)\n    ]\n    # All weights are 1.0 for 2x2 Gauss quadrature on [-1,1]x[-1,1]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    # Rigid plane definition\n    n_contact = np.array([0.0, 0.0, 1.0])\n    x0_contact = np.array([0.0, 0.0, 0.0])\n\n    all_results = []\n    \n    for case in test_cases:\n        Lx, Ly, kp = case['Lx'], case['Ly'], case['kp']\n        z1, z2, z3, z4 = case['z']\n\n        # Nodal coordinates in physical space (3x4 matrix)\n        X = np.array([\n            [0.0, Lx, Lx, 0.0],\n            [0.0, 0.0, Ly, Ly],\n            [z1,  z2,  z3,  z4]\n        ])\n\n        # Initialize element force vector (12 components)\n        f_e = np.zeros(12)\n\n        for i, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[i]\n\n            # Shape functions N_I(xi, eta)\n            N = 0.25 * np.array([\n                (1-xi)*(1-eta),\n                (1+xi)*(1-eta),\n                (1+xi)*(1+eta),\n                (1-xi)*(1+eta)\n            ])\n\n            # Physical position of the Gauss point\n            x_gp = X @ N\n            \n            # Normal gap calculation\n            g_n = np.dot(n_contact, x_gp - x0_contact)\n\n            # Check for active contact (penetration)\n            if g_n  0:\n                # Penalty pressure\n                lambda_n = -kp * g_n\n\n                # Derivatives of shape functions w.r.t. parent coordinates\n                dN_dxi = 0.25 * np.array([-(1-eta), (1-eta), (1+eta), -(1+eta)])\n                dN_deta = 0.25 * np.array([-(1-xi), -(1+xi), (1+xi), (1-xi)])\n\n                # Covariant base vectors\n                a1 = X @ dN_dxi\n                a2 = X @ dN_deta\n\n                # Surface Jacobian\n                normal_vec = np.cross(a1, a2)\n                J_A = np.linalg.norm(normal_vec)\n                \n                # Force contribution from this Gauss point\n                # The force is in the direction of n_contact\n                # Force on node I is lambda_n * N_I * n_contact * J_A * w\n                force_increment = lambda_n * J_A * w * N\n                \n                # Assemble into 12-component vector (only z-components are non-zero)\n                f_e[2] += force_increment[0]\n                f_e[5] += force_increment[1]\n                f_e[8] += force_increment[2]\n                f_e[11] += force_increment[3]\n\n        all_results.append(f_e.tolist())\n    \n    # Format the output string as specified\n    formatted_results = []\n    for res_list in all_results:\n        formatted_list = [f\"{x:.6f}\" for x in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2548018"}]}