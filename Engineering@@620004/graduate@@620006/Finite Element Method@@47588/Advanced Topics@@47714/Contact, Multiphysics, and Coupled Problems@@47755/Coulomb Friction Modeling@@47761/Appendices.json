{"hands_on_practices": [{"introduction": "A robust numerical model must be built on a foundation of verifiable components. This first practice focuses on a fundamental verification test for any Coulomb friction algorithm: ensuring it correctly reduces to frictionless unilateral contact when the friction coefficient $\\mu$ is zero. Performing this \"zero test\" [@problem_id:2550832] is a critical first step in building confidence in an implementation, as it confirms that the complex frictional logic does not introduce spurious tangential forces in the simplest physical limit.", "problem": "Devise and implement a verification test for a Coulomb friction contact algorithm within the finite element method that reduces to frictionless unilateral contact when the friction coefficient is zero. The objective is to confirm that when the friction coefficient is set to zero, the method produces no tangential tractions and enforces only the unilateral normal contact response. You must derive the governing contact response from first principles and implement it as a complete, runnable program that evaluates a specified test suite.\n\nStart from the following fundamental base:\n- The principle of virtual work for a discrete node in contact with a rigid plane, which yields balance between contact tractions and external actions.\n- The unilateral (Signorini) contact conditions in the normal direction: the normal gap $g_n$ satisfies $g_n \\ge 0$, the normal contact reaction $r_n$ satisfies $r_n \\ge 0$, and the complementarity condition $r_n g_n = 0$.\n- The Coulomb friction model in the tangential plane with friction coefficient $\\mu \\ge 0$, where the tangential traction magnitude is bounded by $\\mu r_n$ during slip and aligned opposite to the tangential relative motion.\n- Penalty regularization for the normal contact that penalizes interpenetration when a trial state violates $g_n \\ge 0$ (that is, when $g_n < 0$).\n\nDiscretization model:\n- Consider a single surface node interacting with a rigid plane with unit outward normal $\\mathbf{n}$ and an orthonormal tangential frame $\\{\\mathbf{t}_1,\\mathbf{t}_2\\}$ at the contact point.\n- Let the signed normal gap be $g_n \\in \\mathbb{R}$, defined positive in separation and negative in penetration. Let the tangential gap vector be $\\mathbf{g}_t \\in \\mathbb{R}^2$, expressed in the local tangential basis. The contact reaction decomposes as $\\mathbf{r} = r_n \\mathbf{n} + \\mathbf{r}_t$, where $r_n \\in \\mathbb{R}$ and $\\mathbf{r}_t \\in \\mathbb{R}^2$.\n- Use a normal penalty stiffness $k_n > 0$ and a tangential penalty stiffness $k_t > 0$ to define trial elastic tractions prior to the frictional projection.\n\nFrom the principle of virtual work and penalty regularization, the normal reaction is obtained from the derivative of the quadratic penalty potential on interpenetration,\n$$\n\\Pi_n(g_n) = \\tfrac{1}{2} k_n \\,\\langle -g_n \\rangle_+^2,\n$$\nwhere $\\langle x \\rangle_+ = \\max(0,x)$. The normal reaction is therefore\n$$\nr_n = \\dfrac{\\partial \\Pi_n}{\\partial g_n} \\cdot (-1) = k_n \\,\\langle -g_n \\rangle_+ = k_n \\max(0,-g_n).\n$$\nIn the tangential plane, define the trial elastic traction\n$$\n\\mathbf{t}^{\\text{trial}} = k_t \\,\\mathbf{g}_t.\n$$\nTo enforce Coulomb friction with coefficient $\\mu \\ge 0$, project $\\mathbf{t}^{\\text{trial}}$ onto the admissible set\n$$\n\\mathcal{C}(r_n) = \\left\\{ \\mathbf{t} \\in \\mathbb{R}^2 \\,:\\, \\|\\mathbf{t}\\| \\le \\mu r_n \\right\\}\n$$\nwhen contact is active. If $r_n = 0$ (no contact), set $\\mathbf{r}_t = \\mathbf{0}$. If $r_n > 0$, then:\n- Stick if $\\|\\mathbf{t}^{\\text{trial}}\\| \\le \\mu r_n$, in which case $\\mathbf{r}_t = \\mathbf{t}^{\\text{trial}}$.\n- Slip if $\\|\\mathbf{t}^{\\text{trial}}\\| > \\mu r_n$, in which case\n$$\n\\mathbf{r}_t = \\mu r_n \\dfrac{\\mathbf{t}^{\\text{trial}}}{\\|\\mathbf{t}^{\\text{trial}}\\|}.\n$$\nWhen the friction coefficient is zero, namely $\\mu = 0$, the admissible set reduces to $\\mathcal{C}(r_n) = \\{\\mathbf{0}\\}$, hence the consistent reduction of the method is $\\mathbf{r}_t = \\mathbf{0}$ for all states, with the normal reaction $r_n$ as above. This must hold without spurious tangential tractions for any choice of $k_t$ and any $\\mathbf{g}_t$.\n\nProgramming task:\n- Implement the above contact law for a single node against a rigid plane, using the penalty-based normal reaction and the Coulomb projection in the tangential plane.\n- Use the International System of Units (SI): length in meters ($\\mathrm{m}$), force in newtons ($\\mathrm{N}$). Internally, all inputs will be provided in SI units. The program’s final outputs are dimensionless booleans indicating pass or fail for each test, so no unit must be printed.\n\nTest suite:\nFor each test case, set the friction coefficient to $\\mu = 0$, compute $(r_n, \\mathbf{r}_t)$, and verify the following conditions with a fixed absolute tolerance $\\varepsilon = 10^{-10}$:\n- No spurious tangential traction: $\\|\\mathbf{r}_t\\| \\le \\varepsilon$.\n- Correct normal reaction: $|r_n - k_n \\max(0,-g_n)| \\le \\varepsilon$.\n- If $g_n \\ge 0$ (separation or touching), then additionally verify $r_n \\le \\varepsilon$.\n\nUse the following five test cases (each tuple is $(g_n, \\mathbf{g}_t, k_n, k_t)$):\n- Case A (happy path in active contact with large tangential slip): $(-10^{-3}\\ \\mathrm{m},\\ [3\\times 10^{-2},\\ -4\\times 10^{-2}]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$.\n- Case B (separation): $(2\\times 10^{-4}\\ \\mathrm{m},\\ [1,\\ -1]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$.\n- Case C (touching boundary): $(0\\ \\mathrm{m},\\ [10^{-1},\\ 10^{-1}]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$.\n- Case D (small penetration with very stiff tangential penalty): $(-5\\times 10^{-5}\\ \\mathrm{m},\\ [5\\times 10^{-1},\\ -5\\times 10^{-1}]\\ \\mathrm{m},\\ 3\\times 10^{8}\\ \\mathrm{N/m},\\ 10^{9}\\ \\mathrm{N/m})$.\n- Case E (penetration with zero tangential gap): $(-2\\times 10^{-4}\\ \\mathrm{m},\\ [0,\\ 0]\\ \\mathrm{m},\\ 4\\times 10^{7}\\ \\mathrm{N/m},\\ 5\\times 10^{6}\\ \\mathrm{N/m})$.\n\nExpected program behavior:\n- For each case, compute $(r_n, \\mathbf{r}_t)$ using the algorithm above with $\\mu = 0$ and $\\varepsilon = 10^{-10}$, then evaluate the three checks as a single pass/fail boolean per case: the case passes if all applicable checks are satisfied.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true1,true2,true3,true4,true5]\"). Use Python boolean literals (\"True\" or \"False\").", "solution": "We derive a consistent discrete contact response for a single node in contact with a rigid plane, using penalty regularization in the normal direction and a return-mapping projection for Coulomb friction in the tangential plane. The derivation begins from the principle of virtual work, which states that the virtual work of internal and contact forces balances the virtual work of external forces. For a single node interacting with a rigid plane, contact forces are the only internal contributions at the interface and are work-conjugate to the gaps.\n\nNormal contact. The unilateral constraint is encoded by the Signorini conditions: $g_n \\ge 0$, $r_n \\ge 0$, $r_n g_n = 0$. To regularize this constraint, we introduce a convex penalty potential acting only on interpenetration,\n$$\n\\Pi_n(g_n) = \\tfrac{1}{2} k_n \\,\\langle -g_n \\rangle_+^2,\n$$\nwith $k_n > 0$ and $\\langle x \\rangle_+ = \\max(0,x)$. The normal contact reaction follows from stationarity of the augmented energy with respect to virtual variations of the gap in the sense of the chain rule,\n$$\n\\delta \\Pi_n = \\dfrac{\\partial \\Pi_n}{\\partial g_n} \\,\\delta g_n, \\quad \\text{and} \\quad \\delta W_n = r_n \\,\\delta g_n,\n$$\nso identification yields $r_n = \\partial \\Pi_n/\\partial g_n \\cdot (-1)$ (the minus sign appears since a positive compressive reaction does negative work for a positive decrease of $g_n$). Differentiation gives\n$$\nr_n = k_n \\,\\langle -g_n \\rangle_+ = k_n \\max(0,-g_n).\n$$\nThis response enforces $r_n = 0$ under separation or touching ($g_n \\ge 0$) and $r_n = k_n (-g_n)$ under penetration ($g_n < 0$), which is consistent with the unilateral constraint in the limit $k_n \\to \\infty$.\n\nTangential contact with Coulomb friction. In the tangential plane, define the elastic trial traction from a quadratic penalty stored energy,\n$$\n\\Pi_t(\\mathbf{g}_t) = \\tfrac{1}{2} k_t \\,\\|\\mathbf{g}_t\\|^2, \\quad \\mathbf{t}^{\\text{trial}} = \\dfrac{\\partial \\Pi_t}{\\partial \\mathbf{g}_t} = k_t \\,\\mathbf{g}_t,\n$$\nwhere $k_t > 0$. Coulomb friction constrains the admissible tangential traction $\\mathbf{r}_t$ to lie within a disk of radius $\\mu r_n$ in the tangential plane when contact is active. This is the closed convex set\n$$\n\\mathcal{C}(r_n) = \\left\\{ \\mathbf{t} \\in \\mathbb{R}^2 \\,:\\, \\|\\mathbf{t}\\| \\le \\mu r_n \\right\\}.\n$$\nWhen $r_n = 0$ (no active contact), no tangential traction is admissible and consistency demands $\\mathbf{r}_t = \\mathbf{0}$. When $r_n > 0$, the consistent algorithm is the orthogonal projection (in the Euclidean norm) of the trial traction onto $\\mathcal{C}(r_n)$:\n- If $\\|\\mathbf{t}^{\\text{trial}}\\| \\le \\mu r_n$ (stick), then $\\mathbf{r}_t = \\mathbf{t}^{\\text{trial}}$.\n- Otherwise (slip), the projection onto the circle of radius $\\mu r_n$ in the direction of $\\mathbf{t}^{\\text{trial}}$ yields\n$$\n\\mathbf{r}_t = \\mu r_n \\,\\dfrac{\\mathbf{t}^{\\text{trial}}}{\\|\\mathbf{t}^{\\text{trial}}\\|}.\n$$\nThis projection is the unique minimizer of $\\|\\mathbf{t} - \\mathbf{t}^{\\text{trial}}\\|$ subject to $\\mathbf{t} \\in \\mathcal{C}(r_n)$ and is the discrete counterpart of the standard return-mapping algorithm used in finite element implementations.\n\nZero friction limit. When $\\mu = 0$, the admissible set reduces to $\\mathcal{C}(r_n) = \\{\\mathbf{0}\\}$ for any $r_n \\ge 0$. Therefore, when $r_n > 0$, both the stick condition and the slip projection collapse to the unique admissible value\n$$\n\\mathbf{r}_t = \\mathbf{0}.\n$$\nWhen $r_n = 0$, by consistency for separation (or touching), we also have $\\mathbf{r}_t = \\mathbf{0}$. Hence, irrespective of the tangential gap $\\mathbf{g}_t$ or the tangential penalty $k_t$, the Coulomb model with $\\mu = 0$ rigorously reduces to frictionless unilateral contact: purely normal reaction with no spurious tangential traction.\n\nVerification checks. To validate the reduction, we verify:\n- No spurious tangential tractions: $\\|\\mathbf{r}_t\\| \\le \\varepsilon$ with a small tolerance $\\varepsilon$.\n- Correct normal reaction: $|r_n - k_n \\max(0,-g_n)| \\le \\varepsilon$.\n- Consistency under separation: if $g_n \\ge 0$, then $r_n \\le \\varepsilon$.\n\nAlgorithmic steps for each test case:\n1. Input $(g_n, \\mathbf{g}_t, k_n, k_t)$ and set $\\mu = 0$ and a tolerance $\\varepsilon$.\n2. Compute $r_n = k_n \\max(0,-g_n)$.\n3. If $r_n = 0$, set $\\mathbf{r}_t = \\mathbf{0}$. Otherwise, compute $\\mathbf{t}^{\\text{trial}} = k_t \\,\\mathbf{g}_t$ and project onto $\\mathcal{C}(r_n)$ with $\\mu = 0$, which yields $\\mathbf{r}_t = \\mathbf{0}$.\n4. Evaluate the three checks and record a boolean pass/fail for the case.\n\nThe provided program implements this algorithm and executes the five specified cases:\n- Case A (penetration with large tangential slip) tests the active-contact regime and ensures that $\\mathbf{r}_t = \\mathbf{0}$ even under large $\\|\\mathbf{g}_t\\|$ and large $k_t$.\n- Case B (separation) tests complementarity: both $r_n$ and $\\|\\mathbf{r}_t\\|$ must be zero within tolerance.\n- Case C (touching boundary) further tests the boundary of the unilateral constraint.\n- Case D (small penetration, very stiff tangential penalty) stresses the projection under extreme trial tangential traction and confirms that it still returns $\\mathbf{0}$.\n- Case E (penetration with zero tangential gap) tests the limit case where the tangential trial traction is exactly zero.\n\nThe output is a single list of five booleans, one per case, which must all be True if the implementation correctly reduces to frictionless contact with no spurious tangential tractions when $\\mu = 0$.", "answer": "```python\nimport numpy as np\n\ndef contact_response(g_n, g_t_vec, k_n, k_t, mu, tol=1e-14):\n    \"\"\"\n    Compute contact reaction for a single node against a rigid plane.\n\n    Parameters:\n        g_n (float): normal gap (m), positive in separation, negative in penetration.\n        g_t_vec (array-like): tangential gap vector (m) in 2D tangential frame.\n        k_n (float): normal penalty stiffness (N/m).\n        k_t (float): tangential penalty stiffness (N/m).\n        mu (float): Coulomb friction coefficient (dimensionless).\n        tol (float): small tolerance for numerical decisions.\n\n    Returns:\n        r_n (float): normal reaction (N), non-negative.\n        r_t (np.ndarray): tangential reaction vector (N) in 2D.\n    \"\"\"\n    g_t = np.array(g_t_vec, dtype=float).reshape(2)\n    # Normal reaction via penalty on interpenetration\n    r_n = k_n * max(0.0, -g_n)\n\n    # If no contact is active, no tangential traction\n    if r_n = tol:\n        return 0.0, np.zeros(2)\n\n    # Trial tangential elastic traction\n    t_trial = k_t * g_t\n    norm_t_trial = np.linalg.norm(t_trial)\n    bound = mu * r_n\n\n    if norm_t_trial = bound + tol:\n        # Stick\n        r_t = t_trial\n    else:\n        # Slip: project onto friction disk\n        if norm_t_trial = tol or bound = tol:\n            r_t = np.zeros(2)\n        else:\n            r_t = (bound / norm_t_trial) * t_trial\n\n    return r_n, r_t\n\n\ndef run_tests():\n    # Frictionless limit\n    mu = 0.0\n    # Tolerances for verification\n    tol_force = 1e-10\n\n    test_cases = [\n        # (g_n, g_t, k_n, k_t)\n        (-1e-3,  [3e-2, -4e-2], 1e7, 2e7),      # Case A: penetration, large tangential slip\n        ( 2e-4,  [1.0,  -1.0],  1e7, 2e7),      # Case B: separation\n        ( 0.0,   [1e-1,  1e-1], 1e7, 2e7),      # Case C: touching boundary\n        (-5e-5,  [5e-1, -5e-1], 3e8, 1e9),      # Case D: small penetration, very stiff kt\n        (-2e-4,  [0.0,   0.0],  4e7, 5e6),      # Case E: penetration, zero tangential gap\n    ]\n\n    results = []\n    for g_n, g_t, k_n, k_t in test_cases:\n        r_n, r_t = contact_response(g_n, g_t, k_n, k_t, mu)\n        # Checks\n        # 1) No spurious tangential traction\n        no_spurious_tan = np.linalg.norm(r_t) = tol_force\n        # 2) Correct normal reaction\n        r_n_expected = k_n * max(0.0, -g_n)\n        correct_normal = abs(r_n - r_n_expected) = tol_force\n        # 3) If separation or touching, r_n must be zero\n        sep_touch_ok = True\n        if g_n >= 0.0:\n            sep_touch_ok = r_n = tol_force\n\n        results.append(bool(no_spurious_tan and correct_normal and sep_touch_ok))\n    return results\n\n\ndef solve():\n    results = run_tests()\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2550832"}, {"introduction": "After verifying the model's basic consistency, the next step is to assess its accuracy and convergence, which are core concerns in the Finite Element Method. This exercise [@problem_id:2550840] guides you through a mesh refinement study for a frictional interface, a standard procedure to evaluate how the numerical solution improves as the mesh becomes finer. By quantifying the error in both the tangential tractions and the predicted stick-slip state, you will gain hands-on experience in the critical process of validating the predictive quality of a computational model.", "problem": "Design and implement a self-contained mesh-refinement study for a one-dimensional interface finite element discretization of a two-dimensional block-on-plane frictional contact problem with Coulomb friction. The goal is to assess the convergence of the computed tangential reaction field and of the stick–slip interface partition as the interface mesh is refined. All quantities are non-dimensional; report all outputs as dimensionless floating-point numbers.\n\nFundamental base and modeling assumptions:\n- The contact interface is the segment $[0,L]$ with length $L>0$.\n- The normal contact pressure is uniform and equal to $p_n0$ along the interface.\n- The tangential friction coefficient is $\\mu0$.\n- The tangential penalty stiffness is $k_t0$.\n- The prescribed relative tangential slip field at full load is $g_t(x)=U_0\\left(\\dfrac{x}{L}\\right)^{\\alpha}$ for $x\\in[0,L]$, where $U_0\\ge 0$ and $\\alpha\\ge 1$ are given.\n- The Coulomb friction law with penalty regularization is enforced pointwise as follows. Define the trial tangential traction $t_{\\mathrm{tr}}(x)=k_t\\,g_t(x)$. The admissible tangential traction is then\n$$\nt(x)=\\begin{cases}\nt_{\\mathrm{tr}}(x),  \\text{if } \\left|t_{\\mathrm{tr}}(x)\\right|\\le \\mu\\,p_n \\quad \\text{(stick)},\\\\\n\\mu\\,p_n\\,\\mathrm{sign}(t_{\\mathrm{tr}}(x)),  \\text{if } \\left|t_{\\mathrm{tr}}(x)\\right|\\mu\\,p_n \\quad \\text{(slip)}.\n\\end{cases}\n$$\nThis local return-mapping enforces the Coulomb bound with the given penalty stiffness.\n- The finite element (FE) approximation of the interface uses $N$ uniformly spaced nodes on $[0,L]$. The discrete nodal values of the relative slip are taken as the exact $g_t(x)$ sampled at the nodes. The FE interpolation of $g_t$ over the interface is the standard piecewise linear interpolation. The approximate tangential traction field $t_h(x)$ is obtained by evaluating the above local return-mapping at the interpolated slip value at each $x$.\n\nDefinitions of reference solution and error norms:\n- A high-resolution reference field is defined by evaluating $t(x)$ on a fine grid of $n_{\\mathrm{ref}}$ uniformly spaced sample points on $[0,L]$ using the exact $g_t(x)$. Denote these sample locations by $\\{x_i\\}_{i=0}^{n_{\\mathrm{ref}}-1}$ with spacing $\\Delta x = \\dfrac{L}{n_{\\mathrm{ref}}-1}$. Let $t_{\\mathrm{ref},i}=t(x_i)$.\n- For a given FE mesh with $N$ nodes, define $t_{h,i}=t_h(x_i)$ by computing the piecewise linear interpolation of $g_t$ on the mesh and applying the same return-mapping at each $x_i$.\n- The relative $L^2$ error in the tangential traction is\n$$\n\\mathcal{E}_{L^2}=\\frac{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{h,i}-t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}}{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}},\n$$\nwhere trapezoidal weights are $w_0=w_{n_{\\mathrm{ref}}-1}=\\dfrac{\\Delta x}{2}$ and $w_i=\\Delta x$ for $i=1,\\dots,n_{\\mathrm{ref}}-2$. If the denominator is zero, define $\\mathcal{E}_{L^2}=0$.\n- The stick–slip partition error is defined by classifying each sample point $x_i$ as stick if $\\left|t_{\\mathrm{tr}}(x_i)\\right|\\le \\mu\\,p_n$ and slip otherwise for the reference field, and analogously using the FE-interpolated slip for the approximate field. Let $s_{\\mathrm{ref},i}\\in\\{0,1\\}$ be $1$ for stick and $0$ for slip, and let $s_{h,i}$ be the corresponding FE-based classification at $x_i$. The partition error is the symmetric-difference fraction\n$$\n\\mathcal{E}_{\\mathrm{part}}=\\frac{1}{n_{\\mathrm{ref}}}\\sum_{i=0}^{n_{\\mathrm{ref}}-1}\\left|s_{h,i}-s_{\\mathrm{ref},i}\\right|.\n$$\n\nAlgorithmic requirements:\n- Implement the above model and error computations for multiple parameter sets. Use the exact $g_t(x)$ for the reference and the FE-interpolated $g_t(x)$ for the discrete approximation.\n- Use $n_{\\mathrm{ref}}=4001$ for the reference grid to numerically approximate the integrals and the partition measure.\n- All computations are non-dimensional. Report $\\mathcal{E}_{L^2}$ and $\\mathcal{E}_{\\mathrm{part}}$ as dimensionless floating-point numbers.\n\nTest suite:\nUse the following fixed parameters for all tests unless specified: $L=1$, $\\mu=0.3$, $p_n=1$, $k_t=50$. Define six test cases covering a happy path, refinement progression, and edge cases:\n- Case $1$: $N=4$, $U_0=0.02$, $\\alpha=1$.\n- Case $2$: $N=8$, $U_0=0.02$, $\\alpha=1$.\n- Case $3$: $N=16$, $U_0=0.02$, $\\alpha=1$.\n- Case $4$: $N=8$, $U_0=0.001$, $\\alpha=1$.\n- Case $5$: $N=8$, $U_0=0.5$, $\\alpha=1$.\n- Case $6$: $N=8$, $U_0=0.02$, $\\alpha=3$.\n\nWhat the program must do:\n- For each case, compute $\\mathcal{E}_{L^2}$ and $\\mathcal{E}_{\\mathrm{part}}$ as defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a two-element list in the form $[\\mathcal{E}_{L^2},\\mathcal{E}_{\\mathrm{part}}]$, so the final output has the form\n\"[[e11,e12],[e21,e22],...[e61,e62]]\" where each $e$ is a floating-point number.", "solution": "This problem requires a mesh-refinement study for a one-dimensional frictional contact problem, which involves comparing a finite element (FE) approximation against a high-resolution reference solution. The core of the task lies in the correct implementation of piecewise linear interpolation for the FE approximation and the non-linear return-mapping algorithm that dictates the frictional response.\n\nFirst, we establish the analytical and numerical framework. The physical domain is the interval $[0,L]$. The prescribed relative slip is $g_t(x) = U_0 (x/L)^\\alpha$. Since the parameters $U_0$ and $\\alpha$ are non-negative, $g_t(x) \\ge 0$ for $x \\in [0,L]$. The trial tangential traction is computed as $t_{\\mathrm{tr}}(x) = k_t g_t(x)$. Since $k_t > 0$ and $g_t(x) \\ge 0$, we have $t_{\\mathrm{tr}}(x) \\ge 0$. The frictional response is governed by the Coulomb condition where the maximum admissible traction, or the friction limit, is $\\tau_{\\mathrm{crit}} = \\mu p_n$. The contact is in a stick state if the trial traction does not exceed this limit, $|t_{\\mathrm{tr}}(x)| \\le \\tau_{\\mathrm{crit}}$, and in a slip state otherwise. Given that $t_{\\mathrm{tr}}(x)$ is non-negative, this return-mapping algorithm simplifies to $t(x) = \\min(t_{\\mathrm{tr}}(x), \\tau_{\\mathrm{crit}})$.\n\nA high-resolution reference grid of $n_{\\mathrm{ref}}=4001$ points, $\\{x_i\\}_{i=0}^{n_{\\mathrm{ref}}-1}$, is defined on $[0,L]$. The reference solution is computed at these points by calculating the exact slip $g_t(x_i)$, the resulting trial traction, and the actual traction $t_{\\mathrm{ref},i} = \\min(k_t g_t(x_i), \\mu p_n)$. The reference stick-slip state $s_{\\mathrm{ref},i}$ (1 for stick, 0 for slip) is also determined.\n\nNext, we construct the FE approximation for a given number of nodes, $N$. The FE mesh consists of $N$ uniformly spaced nodes $\\{z_j\\}_{j=0}^{N-1}$ on $[0,L]$. The exact slip values $g_{j}^{\\mathrm{node}} = g_t(z_j)$ are computed at these nodes. The FE-approximated slip field, $g_h(x)$, is the piecewise linear interpolant of these nodal values. For any point $x$ on the reference grid, its value $g_h(x)$ is found by linear interpolation between the nodal values of the element containing $x$. The approximate solution ($t_{h,i}$ and $s_{h,i}$) is then evaluated on the high-resolution grid using this interpolated slip field.\n\nFinally, we quantify the error. The relative $L^2$ error, $\\mathcal{E}_{L^2}$, is computed via numerical integration using the trapezoidal rule, as specified by the provided formula. A check for a zero-norm reference solution is implemented to avoid division by zero. The partition error, $\\mathcal{E}_{\\mathrm{part}}$, is calculated as the fraction of misclassified points on the reference grid. The algorithm iterates through each test case, applying these steps, calculating the two error metrics, and collecting the results for the final output. The progression from Case 1 to Case 3 ($N=4, 8, 16$) is expected to show convergence, i.e., a decrease in both error norms, as the FE mesh is refined. The other cases explore the sensitivity to the magnitude of slip ($U_0$) and its spatial distribution ($\\alpha$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D frictional contact problem for a suite of test cases.\n    \"\"\"\n\n    # Define the 6 test cases from the problem statement.\n    # Format: (N, U0, alpha)\n    test_cases = [\n        (4, 0.02, 1),\n        (8, 0.02, 1),\n        (16, 0.02, 1),\n        (8, 0.001, 1),\n        (8, 0.5, 1),\n        (8, 0.02, 3),\n    ]\n\n    # Fixed parameters for all tests\n    L = 1.0\n    mu = 0.3\n    p_n = 1.0\n    k_t = 50.0\n    n_ref = 4001\n\n    results = []\n\n    for case in test_cases:\n        N, U0, alpha = case\n\n        # Friction limit (critical traction)\n        tau_crit = mu * p_n\n\n        # --- High-resolution reference solution ---\n\n        # Define the fine reference grid\n        x_ref = np.linspace(0, L, n_ref)\n\n        # Exact prescribed relative slip field g_t(x)\n        g_t = lambda x: U0 * (x / L)**alpha if L > 0 else (U0 if x == 0 else 0)\n        \n        # Evaluate exact slip on the reference grid\n        g_ref = g_t(x_ref)\n\n        # Calculate reference trial traction\n        t_tr_ref = k_t * g_ref\n\n        # Apply return-mapping to get reference traction field t(x)\n        # Since t_tr is non-negative, this is a simple min operation\n        t_ref = np.minimum(t_tr_ref, tau_crit)\n\n        # Determine reference stick-slip partition\n        # s=1 for stick, s=0 for slip\n        s_ref = (t_tr_ref = tau_crit).astype(int)\n\n        # --- Finite Element (FE) approximation ---\n\n        # Define the coarse FE nodal grid\n        x_nodes = np.linspace(0, L, N)\n\n        # Evaluate exact slip at the FE nodes\n        g_nodal = g_t(x_nodes)\n\n        # Compute the piecewise linear interpolation of slip on the reference grid\n        g_h = np.interp(x_ref, x_nodes, g_nodal)\n\n        # Calculate approximate trial traction from interpolated slip\n        t_tr_h = k_t * g_h\n\n        # Apply return-mapping to get approximate traction field t_h(x)\n        t_h = np.minimum(t_tr_h, tau_crit)\n\n        # Determine approximate stick-slip partition\n        s_h = (t_tr_h = tau_crit).astype(int)\n\n        # --- Error computation ---\n\n        # 1. Relative L2 error in tangential traction\n        delta_x = L / (n_ref - 1)\n        weights = np.full(n_ref, delta_x)\n        weights[0] = delta_x / 2.0\n        weights[-1] = delta_x / 2.0\n\n        l2_err_numerator = np.sqrt(np.sum(weights * (t_h - t_ref)**2))\n        l2_norm_ref = np.sqrt(np.sum(weights * t_ref**2))\n        \n        if l2_norm_ref > 1e-15:\n            e_l2 = l2_err_numerator / l2_norm_ref\n        else:\n            e_l2 = 0.0 # As per problem statement\n\n        # 2. Stick-slip partition error\n        e_part = np.mean(np.abs(s_h - s_ref))\n\n        results.append([e_l2, e_part])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly handles the list-of-lists format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2550840"}, {"introduction": "Advanced simulations often involve large rotations, where the principle of objectivity (or material frame-indifference) becomes paramount. This practice [@problem_id:2550801] explores this sophisticated concept using a rotating ring benchmark, a classic test for contact algorithms. You will discover how a seemingly plausible, \"non-objective\" numerical scheme can produce physically incorrect results for path-dependent quantities like frictional work, and how an objective formulation correctly captures the energy dissipation regardless of the reference frame's motion.", "problem": "Consider a thin circular ring of radius $r$ and width $b$ pressed against a rigid plane by a uniform contact pressure $p$ (in $\\mathrm{Pa} = \\mathrm{N}/\\mathrm{m}^2$). The ring lies in the plane $z=0$ and the plane’s outward unit normal is aligned with the global $z$-axis. The ring is subjected to a prescribed relative tangential motion in the plane: at each material point on the ring, the instantaneous relative tangential velocity vector in the plane has constant magnitude $v_s$ (in $\\mathrm{m}/\\mathrm{s}$) and its direction rotates at angular speed $\\omega$ (in $\\mathrm{rad}/\\mathrm{s}$) about the plane normal. This mimics a “rotating ring on a rigid plane” where the slip direction spins with time. Assume a constant Coulomb friction coefficient $\\mu$ (dimensionless). The total normal force is $F_N = p \\cdot (2\\pi r b)$ (in $\\mathrm{N}$). You will study the objectivity of frictional work computations in the context of the Finite Element Method (FEM) by contrasting two discrete algorithms for tangential work over a time horizon $T$ (in $\\mathrm{s}$).\n\nBase your model on the following fundamental laws and core definitions:\n- Coulomb friction law: the magnitude of the friction force is $F_T = \\mu F_N$ when slipping occurs.\n- Mechanical work: the incremental tangential work is $\\mathrm{d}W = \\boldsymbol{F}_T \\cdot \\mathrm{d}\\boldsymbol{u}_t$, where $\\mathrm{d}\\boldsymbol{u}_t$ is the incremental tangential slip vector in the plane.\n- Objectivity (frame invariance): under a superposed rigid body motion (including a rotation of the spatial frame), physically measurable quantities such as the dissipated work must be invariant.\n\nDefine the instantaneous relative tangential velocity as a planar vector $\\boldsymbol{v}_{\\mathrm{rel}}(t)$ with constant magnitude $v_s$ and direction that rotates at angular speed $\\omega$ about the plane normal, i.e., $\\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| = v_s$ for all $t \\in [0,T]$, and its direction is $\\boldsymbol{e}_t(t) = [\\cos(\\omega t), \\sin(\\omega t)]$ in the plane. There is no coupling in the normal direction; contact remains closed with constant $F_N$.\n\nImplement and compare the following two discrete algorithms for the total tangential work $W$ accumulated over $t \\in [0,T]$:\n\n- Objective incremental work accumulation (with objective frame updates):\n  - Partition the interval $[0,T]$ into $M$ uniform substeps of size $\\Delta t = T/M$.\n  - At each substep $k$, compute the incremental tangential slip $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\,\\Delta t$ with the current direction $\\boldsymbol{e}_t(t_k)$, and accumulate the work increment as $\\Delta W_{\\mathrm{obj}}^{(k)} = \\mu F_N \\|\\Delta \\boldsymbol{u}_t^{(k)}\\|$.\n  - The total objective work is $W_{\\mathrm{obj}} = \\sum_{k=1}^{M} \\Delta W_{\\mathrm{obj}}^{(k)}$.\n  - This algorithm updates the tangential frame each step by using the instantaneous direction $\\boldsymbol{e}_t(t_k)$, which preserves objectivity.\n\n- Non-objective accumulation (without objective frame updates):\n  - Partition the interval $[0,T]$ into $M$ uniform substeps of size $\\Delta t = T/M$.\n  - At each substep $k$, compute the incremental tangential slip $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\,\\Delta t$, but accumulate only the planar slip vector in a fixed initial frame: $\\boldsymbol{s} \\leftarrow \\boldsymbol{s} + \\Delta \\boldsymbol{u}_t^{(k)}$, with $\\boldsymbol{s}$ initialized to $\\boldsymbol{0}$ at $t=0$.\n  - At the end, compute $W_{\\mathrm{no}} = \\mu F_N \\|\\boldsymbol{s}\\|$.\n  - This algorithm does not rotate the stored tangential state with the evolving tangential frame, and thus is not objective under a spinning slip direction.\n\nYour task is to implement a program that computes $W_{\\mathrm{obj}}$ and $W_{\\mathrm{no}}$ for the following test suite of four cases. Use angle units in radians, angular speeds in $\\mathrm{rad}/\\mathrm{s}$, lengths in $\\mathrm{m}$, time in $\\mathrm{s}$, forces in $\\mathrm{N}$, pressure in $\\mathrm{Pa}$, and work in $\\mathrm{J}$. For numerical stability and consistency, choose an integer $M \\geq 10^4$ substeps for each case (you may choose any fixed $M$ that provides numerically stable results; since $\\|\\boldsymbol{v}_{\\mathrm{rel}}\\|$ is constant in time, the objective algorithm’s result is independent of $M$).\n\nUse the following parameter sets:\n- Case A (general spinning slip direction):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 2.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.25\\,\\mathrm{s}$.\n- Case B (exactly one full revolution of the slip direction):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 2.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = \\dfrac{2\\pi}{\\omega}\\,\\mathrm{s}$.\n- Case C (very slow frame spin, near-constant slip direction):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 0.001\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$.\n- Case D (no spin, constant slip direction):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 0.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$.\n\nYour program must:\n- Compute $F_N = p \\cdot (2\\pi r b)$ for each case.\n- Compute $W_{\\mathrm{obj}}$ and $W_{\\mathrm{no}}$ as defined above for each case.\n- Express all work values in $\\mathrm{J}$, rounded to six decimal places.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as:\n  - $[W_{\\mathrm{obj}}^{A}, W_{\\mathrm{no}}^{A}, W_{\\mathrm{obj}}^{B}, W_{\\mathrm{no}}^{B}, W_{\\mathrm{obj}}^{C}, W_{\\mathrm{no}}^{C}, W_{\\mathrm{obj}}^{D}, W_{\\mathrm{no}}^{D}]$.\n\nDesign for coverage:\n- Case A represents a generic spinning slip direction with no special symmetry.\n- Case B is a boundary condition where the non-objective accumulation suffers maximal cancellation error.\n- Case C is an edge case where the frame spin is very slow and the two methods nearly coincide.\n- Case D is the limiting case of a constant slip direction where both methods must agree exactly.\n\nDo not read any input; all parameters are fixed as specified above. The output must be deterministic and reproducible.", "solution": "This problem requires a comparison of two numerical methods for computing frictional work to demonstrate the importance of objectivity.\n\nFirst, we establish the fundamental physical quantities. The total normal force $F_N$ is the product of the uniform pressure $p$ and the contact area $A = 2\\pi r b$. Thus, $F_N = 2 \\pi p r b$. The magnitude of the friction force during slip is constant, given by the Coulomb friction law: $F_T = \\mu F_N$.\n\nThe physically correct accumulated frictional work, which represents the total dissipated energy, is the integral of the frictional power over time. The incremental work $\\mathrm{d}W$ is the product of the friction force magnitude $F_T$ and the incremental slip distance $\\mathrm{d}s = \\|\\mathrm{d}\\boldsymbol{u}_t\\|$. Since the velocity magnitude is constant, $\\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| = v_s$, the slip distance over an increment of time $\\mathrm{d}t$ is $\\mathrm{d}s = v_s \\mathrm{d}t$. The total work $W$ is therefore the integral over the path length:\n$$W = \\int_0^T F_T \\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| \\mathrm{d}t = \\int_0^T (\\mu F_N) v_s \\mathrm{d}t = \\mu F_N v_s T$$\nThis expression is the exact analytical solution for the dissipated work.\n\nLet us analyze the two proposed algorithms.\n\n**Objective Incremental Work Accumulation ($W_{\\mathrm{obj}}$)**\nThis algorithm computes the work increment at each step $k$ and sums these scalar increments. The work increment is $\\Delta W_{\\mathrm{obj}}^{(k)} = \\mu F_N \\|\\Delta \\boldsymbol{u}_t^{(k)}\\| = \\mu F_N v_s \\Delta t$. The total objective work is the sum of these increments, which discretizes the integral of power correctly:\n$$W_{\\mathrm{obj}} = \\sum_{k=1}^{M} \\mu F_N v_s \\Delta t = \\mu F_N v_s (M \\Delta t) = \\mu F_N v_s T$$\nThis algorithm correctly captures the path-dependent nature of frictional work and yields the exact physical result, independent of the number of steps $M$.\n\n**Non-Objective Accumulation ($W_{\\mathrm{no}}$)**\nThis algorithm first accumulates the incremental slip vectors in a fixed reference frame and then computes the work based on the magnitude of the final net displacement vector $\\boldsymbol{s}$. The net displacement vector is $\\boldsymbol{s} = \\sum_{k=1}^{M} \\Delta \\boldsymbol{u}_t^{(k)} \\approx \\int_{0}^{T} \\boldsymbol{v}_{\\mathrm{rel}}(t) \\mathrm{d}t$. The work is then calculated as $W_{\\mathrm{no}} = \\mu F_N \\|\\boldsymbol{s}\\|$.\n\nThis algorithm is physically incorrect for any path that is not a straight line ($\\omega \\neq 0$). It computes work based on the shortest distance between the start and end points, ignoring the actual, longer path taken. By the triangle inequality for integrals, $\\|\\int \\boldsymbol{v}(t) \\mathrm{d}t\\| \\le \\int \\|\\boldsymbol{v}(t)\\| \\mathrm{d}t$, which means $W_{\\mathrm{no}} \\le W_{\\mathrm{obj}}$. Equality holds only when the direction of motion is constant ($\\omega = 0$). This failure to respect the path-dependence of frictional work is a direct consequence of not using an objective (corotational) reference frame.\n\nThe numerical implementation will proceed by calculating a common factor $\\mu F_N$. For each case, $W_{\\mathrm{obj}}$ will be computed using its simple analytical formula. $W_{\\mathrm{no}}$ will be computed by numerically implementing the summation of slip vectors over $M=10^5$ steps to ensure high accuracy.\n\n**Test Case Analysis**\n-   **Case A** ($\\omega=2.0$, $T=1.25$): A generic spinning case where $W_{\\mathrm{no}}$ will be significantly smaller than $W_{\\mathrm{obj}}$.\n-   **Case B** ($T=2\\pi/\\omega$): The slip direction completes one full revolution. The net displacement $\\boldsymbol{s}$ is zero, so $W_{\\mathrm{no}}=0$, maximally illustrating the error while $W_{\\mathrm{obj}} > 0$.\n-   **Case C** ($\\omega=0.001$, $T=1.0$): The spin is very slow, so the path is nearly straight. $W_{\\mathrm{no}}$ will be very close to $W_{\\mathrm{obj}}$.\n-   **Case D** ($\\omega=0.0$, $T=1.0$): No spin. The path is a straight line. Both algorithms must yield the exact same result, $W_{\\mathrm{no}} = W_{\\mathrm{obj}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares objective vs. non-objective frictional work for a\n    set of test cases involving a spinning slip direction.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General spinning slip\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 2.0, 'T': 1.25},\n        # Case B: Exactly one full revolution\n        # T is calculated dynamically below.\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 2.0, 'T': -1},\n        # Case C: Very slow spin\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 0.001, 'T': 1.0},\n        # Case D: No spin\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 0.0, 'T': 1.0},\n    ]\n\n    # For numerical stability, choose M >= 10^4. We use M = 100,000.\n    M = 100000\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        r = case['r']\n        b = case['b']\n        p = case['p']\n        mu = case['mu']\n        vs = case['vs']\n        omega = case['omega']\n        T = case['T']\n\n        # Special handling for Case B where T depends on omega\n        if T == -1:\n            if omega == 0.0:\n                # Avoid division by zero, although not applicable for given cases.\n                # In such a scenario, the concept of a revolution is ill-defined.\n                # For this problem set, omega is 2.0.\n                T = np.inf\n            else:\n                T = 2.0 * np.pi / omega\n        \n        # Calculate total normal force\n        F_N = p * (2.0 * np.pi * r * b)\n        \n        # --- Objective Work Calculation (W_obj) ---\n        # The objective work is the integral of the scalar power, which is\n        # mu * F_N * vs. Since vs is constant, the integral is simply\n        # W_obj = mu * F_N * vs * T.\n        # This result is independent of the number of steps M.\n        W_obj = mu * F_N * vs * T\n        \n        # --- Non-Objective Work Calculation (W_no) ---\n        # This method accumulates the slip vector in a fixed frame and then\n        # computes the work from the magnitude of the final net vector.\n        dt = T / M\n        slip_vector = np.array([0.0, 0.0])\n        \n        if omega == 0.0:\n            # For the constant direction case, the velocity vector is constant.\n            # v_rel = [vs, 0]. The sum is trivial.\n            slip_vector[0] = vs * T\n        else:\n            # Vectorized computation for the sum is faster than a Python loop.\n            # Create an array of time points t_k = k * dt for k = 1, ..., M.\n            k_steps = np.arange(1, M + 1)\n            t_k = k_steps * dt\n            \n            # Compute velocity vectors at each time point\n            cos_vals = np.cos(omega * t_k)\n            sin_vals = np.sin(omega * t_k)\n            \n            # Sum the velocity components\n            sum_vx = np.sum(cos_vals)\n            sum_vy = np.sum(sin_vals)\n\n            # Final slip vector s = sum(v_rel * dt)\n            slip_vector[0] = vs * dt * sum_vx\n            slip_vector[1] = vs * dt * sum_vy\n\n        # Calculate the norm of the total slip vector\n        slip_norm = np.linalg.norm(slip_vector)\n        \n        # Calculate The non-objective work\n        W_no = mu * F_N * slip_norm\n        \n        # Append results, rounded to six decimal places\n        results.append(round(W_obj, 6))\n        results.append(round(W_no, 6))\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2550801"}]}