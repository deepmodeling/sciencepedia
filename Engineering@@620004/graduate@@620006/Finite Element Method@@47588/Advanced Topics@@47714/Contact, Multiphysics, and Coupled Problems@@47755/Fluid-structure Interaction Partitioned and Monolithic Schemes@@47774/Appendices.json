{"hands_on_practices": [{"introduction": "To build a solid foundation in partitioned methods, we begin with the fundamental Dirichlet-Neumann (D-N) scheme. This first exercise [@problem_id:2560189] breaks down the coupling process into a single, explicit time step using a simplified one-dimensional piston model. By manually calculating the fluid pressure update and the subsequent structural response, you will gain a concrete, step-by-step understanding of how information is sequentially exchanged between fluid and solid subproblems.", "problem": "A one-dimensional piston-in-tube model is used to study Fluid-Structure Interaction (FSI) in a partitioned setting with the Finite Element Method (FEM). The structure is a rigid piston of mass $m$ attached to a linear spring of stiffness $k$ and a linear dashpot of damping coefficient $c$. The piston closes one end of a straight tube of constant cross-sectional area $A$ filled with a compressible fluid of bulk modulus $K$ and initial column length $L_0$. Let $u_s(t)$ denote the piston displacement into the tube, taken as positive into the fluid. The fluid is assumed to remain spatially uniform in pressure over the time step, and the tube is sealed at its far end. The interface coupling enforces that the piston velocity equals the fluid boundary velocity (kinematic continuity), while the fluid pressure exerts a normal load on the piston (dynamic equilibrium).\n\nYou will apply a partitioned Dirichlet–Neumann (D–N) algorithm over a single time step from $t^n$ to $t^{n+1}=t^n+\\Delta t$ using an explicit staggered update:\n- Fluid substep (Dirichlet): Use the interface velocity at $t^n$ to kinematically predict the interface motion over $\\Delta t$, and then determine the fluid pressure at $t^{n+1}$ from mass conservation and linear compressibility.\n- Structure substep (Neumann): Use Newton’s second law with the fluid pressure at $t^{n+1}$ as the external load to compute the piston acceleration at $t^n$, and then update the piston displacement to $t^{n+1}$ using an explicit second-order kinematic expansion consistent with $v=\\mathrm{d}u/\\mathrm{d}t$ and $a=\\mathrm{d}v/\\mathrm{d}t$.\n\nUse the following data:\n- $m=10\\,\\mathrm{kg}$, $c=1000\\,\\mathrm{N\\,s/m}$, $k=10^6\\,\\mathrm{N/m}$,\n- $A=1.0\\times 10^{-2}\\,\\mathrm{m^2}$, $L_0=1.0\\,\\mathrm{m}$, $K=2.0\\times 10^9\\,\\mathrm{Pa}$,\n- $\\Delta t=1.0\\times 10^{-3}\\,\\mathrm{s}$,\n- initial conditions at $t^n$: $u_s^n=0$, $v_s^n=0.10\\,\\mathrm{m/s}$,\n- gauge reference pressure $p_0=0$,\n- external non-fluid load $F_{\\mathrm{ext}}^n=0$.\n\nBase your derivation on:\n- Kinematics $v=\\mathrm{d}u/\\mathrm{d}t$ and $a=\\mathrm{d}v/\\mathrm{d}t$,\n- Newton’s second law for the piston with the fluid pressure load applied over area $A$ and acting opposite to positive $u_s$,\n- Linear compressibility of the fluid: the pressure increment satisfies $\\Delta p=-K\\,\\Delta V/V_0$, where $V_0=A L_0$ and the volume change due to piston motion is $\\Delta V=-A\\,u_s$.\n\nCompute the updated structural displacement $u_s^{n+1}$ produced by this single D–N step. Round your answer to four significant figures. Express the final answer in meters.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\nFirst, all givens are extracted verbatim.\n- Piston mass: $m=10\\,\\mathrm{kg}$\n- Damping coefficient: $c=1000\\,\\mathrm{N\\,s/m}$\n- Spring stiffness: $k=10^6\\,\\mathrm{N/m}$\n- Tube cross-sectional area: $A=1.0\\times 10^{-2}\\,\\mathrm{m^2}$\n- Initial fluid column length: $L_0=1.0\\,\\mathrm{m}$\n- Fluid bulk modulus: $K=2.0\\times 10^9\\,\\mathrm{Pa}$\n- Time step: $\\Delta t=1.0\\times 10^{-3}\\,\\mathrm{s}$\n- Initial displacement at $t^n$: $u_s^n=0$\n- Initial velocity at $t^n$: $v_s^n=0.10\\,\\mathrm{m/s}$\n- Gauge reference pressure: $p_0=0$\n- External non-fluid load at $t^n$: $F_{\\mathrm{ext}}^n=0$\n- Kinematic relations: $v=\\mathrm{d}u/\\mathrm{d}t$, $a=\\mathrm{d}v/\\mathrm{d}t$\n- Equation of motion for the piston: Newton’s second law with fluid pressure load $-pA$.\n- Fluid compressibility law: $\\Delta p=-K\\,\\Delta V/V_0$, with $V_0=A L_0$ and $\\Delta V=-A\\,u_s$.\n- Algorithm: A specific partitioned Dirichlet–Neumann (D–N) explicit staggered scheme.\n\nThe problem is validated against the required criteria.\n- **Scientifically Grounded and Objective**: The problem describes a standard, simplified model of fluid-structure interaction based on fundamental principles of mechanics (Newton's second law) and fluid dynamics (linear compressibility). The assumptions, such as spatially uniform fluid pressure, are explicitly stated simplifications typical for introductory models and do not constitute a scientific flaw. The problem is posed with objective, unambiguous language.\n- **Well-Posed**: The problem is self-contained and provides all necessary data, initial conditions, and a clearly defined algorithm to compute a unique solution for the specified time step.\n- **Consistent**: All provided data are dimensionally consistent. The model is logically coherent.\n- **Relevance**: The problem is directly relevant to the topic of fluid-structure interaction and the finite element method, specifically addressing partitioned solution schemes.\n\nVerdict: The problem is deemed valid and solvable. A solution will now be derived.\n\nThe solution proceeds by executing a single step of the prescribed partitioned Dirichlet–Neumann algorithm from time $t^n$ to $t^{n+1}$. The algorithm consists of two substeps.\n\n**Substep 1: Fluid Substep (Dirichlet prediction)**\n\nIn this substep, we predict the fluid pressure at time $t^{n+1}$ based on a kinematic prediction of the piston's motion.\nThe pressure-displacement relationship is derived from the linear compressibility law. The problem statement implies a total pressure formulation $p = p_0 + (K/L_0) u_s$. Let us verify this from the incremental form $\\Delta p = -K \\Delta V / V_0$. The change in volume from an initial state $(u_s=0, V=V_0)$ to a state with displacement $u_s$ is $\\Delta V = V - V_0 = A(L_0 - u_s) - A L_0 = -A u_s$. The corresponding change in pressure is $\\Delta p = p - p_0$. Thus, $p - p_0 = -K(-A u_s) / (A L_0) = K u_s / L_0$. With the given gauge reference pressure $p_0=0$, the fluid pressure is directly proportional to the piston displacement:\n$$p(t) = \\frac{K}{L_0} u_s(t)$$\nThe algorithm requires using the interface velocity at $t^n$ to predict the interface motion. We perform a first-order explicit prediction of the displacement at $t^{n+1}$, which we denote $\\tilde{u}_s^{n+1}$:\n$$\\tilde{u}_s^{n+1} = u_s^n + v_s^n \\Delta t$$\nUsing the given initial conditions $u_s^n = 0$, $v_s^n=0.10\\,\\mathrm{m/s}$, and $\\Delta t=1.0\\times 10^{-3}\\,\\mathrm{s}$:\n$$\\tilde{u}_s^{n+1} = 0 + (0.10\\,\\mathrm{m/s}) (1.0\\times 10^{-3}\\,\\mathrm{s}) = 1.0\\times 10^{-4}\\,\\mathrm{m}$$\nThis predicted displacement is used as a Dirichlet boundary condition for the fluid subproblem to find the pressure at $t^{n+1}$:\n$$p^{n+1} = \\frac{K}{L_0} \\tilde{u}_s^{n+1}$$\nSubstituting the values $K=2.0\\times 10^9\\,\\mathrm{Pa}$ and $L_0=1.0\\,\\mathrm{m}$:\n$$p^{n+1} = \\frac{2.0\\times 10^9\\,\\mathrm{Pa}}{1.0\\,\\mathrm{m}} (1.0\\times 10^{-4}\\,\\mathrm{m}) = 2.0\\times 10^5\\,\\mathrm{Pa}$$\nThis pressure will be applied as a load on the structure in the next substep.\n\n**Substep 2: Structure Substep (Neumann update)**\n\nIn this substep, we compute the structural response. The equation of motion for the piston (structure) is given by Newton's second law:\n$$m a_s(t) + c v_s(t) + k u_s(t) = F_{\\mathrm{ext}}(t) - p(t) A$$\nwhere $a_s(t)$ is the acceleration. The algorithm specifies using the fluid pressure $p^{n+1}$ to compute the acceleration at time $t^n$. The state variables of the structure ($u_s^n$, $v_s^n$) are taken at time $t^n$:\n$$m a_s^n = F_{\\mathrm{ext}}^n - p^{n+1} A - c v_s^n - k u_s^n$$\nWe solve for the acceleration $a_s^n$:\n$$a_s^n = \\frac{1}{m} (F_{\\mathrm{ext}}^n - p^{n+1} A - c v_s^n - k u_s^n)$$\nSubstituting the given values: $m=10\\,\\mathrm{kg}$, $F_{\\mathrm{ext}}^n=0$, $p^{n+1}=2.0\\times 10^5\\,\\mathrm{Pa}$, $A=1.0\\times 10^{-2}\\,\\mathrm{m^2}$, $c=1000\\,\\mathrm{N\\,s/m}$, $v_s^n=0.10\\,\\mathrm{m/s}$, $k=10^6\\,\\mathrm{N/m}$, and $u_s^n=0$:\n$$a_s^n = \\frac{1}{10} \\left( 0 - (2.0\\times 10^5)(1.0\\times 10^{-2}) - (1000)(0.10) - (10^6)(0) \\right)$$\n$$a_s^n = \\frac{1}{10} \\left( -2000 - 100 - 0 \\right) = \\frac{-2100}{10} = -210\\,\\mathrm{m/s^2}$$\nNext, we update the piston displacement to $t^{n+1}$ using the specified explicit second-order kinematic expansion, which is a Taylor series expansion of $u_s(t)$ around $t^n$:\n$$u_s^{n+1} = u_s^n + v_s^n \\Delta t + \\frac{1}{2} a_s^n (\\Delta t)^2$$\nSubstituting the known and computed values:\n$$u_s^{n+1} = 0 + (0.10\\,\\mathrm{m/s})(1.0\\times 10^{-3}\\,\\mathrm{s}) + \\frac{1}{2}(-210\\,\\mathrm{m/s^2})(1.0\\times 10^{-3}\\,\\mathrm{s})^2$$\n$$u_s^{n+1} = 1.0\\times 10^{-4} + \\frac{1}{2}(-210)(1.0\\times 10^{-6})$$\n$$u_s^{n+1} = 1.0\\times 10^{-4} - 105 \\times 1.0\\times 10^{-6}$$\n$$u_s^{n+1} = 1.0\\times 10^{-4} - 1.05\\times 10^{-4}$$\n$$u_s^{n+1} = -0.05\\times 10^{-4}\\,\\mathrm{m} = -5.0\\times 10^{-6}\\,\\mathrm{m}$$\nThe problem requires the answer to be rounded to four significant figures.\n$$u_s^{n+1} = -5.000\\times 10^{-6}\\,\\mathrm{m}$$\nThis is the updated structural displacement after one step of the D–N algorithm.", "answer": "$$\n\\boxed{-5.000 \\times 10^{-6}}\n$$", "id": "2560189"}, {"introduction": "While the Dirichlet-Neumann scheme is conceptually simple, it often suffers from numerical instability, particularly in problems with significant added-mass effects. This hands-on exercise [@problem_id:2560166] introduces the use of von Neumann stability analysis to diagnose this issue by computing the spectral radius $\\rho$ of the system's amplification factor. You will implement a comparison between the basic D-N scheme and a stabilized Robin-Robin partitioned scheme, providing direct insight into how more advanced coupling conditions are designed to ensure robustness.", "problem": "Implement a program that computes the linear amplification factor for a simple one-dimensional fluid–structure interaction (FSI) model under two partitioned coupling strategies, and aggregates the results over a specified test suite. The setting is the following simplified and canonical model used to study added-mass effects at an interface:\n\n- A structure is modeled as a point mass of mass $m_s$ attached to a linear spring of stiffness $k$, with displacement $x(t)$ governed by Newton's second law.\n- A fluid column adjacent to the structure is modeled as an incompressible, rigid cross-section column of length $L$ and density $\\rho_f$, producing an added-mass effect that exerts a force $F_f(t)$ on the structure that is proportional to the interface acceleration $a(t) = \\ddot{x}(t)$.\n- The added mass is $m_a = \\rho_f A L$, where $A$ is the cross-sectional area. The fluid force is $F_f(t) = - m_a a(t)$.\n- The exact monolithic ordinary differential equation, obtained by combining structure and fluid in a single equation, is $(m_s + m_a) \\ddot{x}(t) + k x(t) = 0$, which is linearly stable.\n\nTo study partitioned time-integration effects, use a uniform time step $\\Delta t$ and the central difference approximation for acceleration,\n$$ a^n = \\frac{x^{n} - 2 x^{n-1} + x^{n-2}}{\\Delta t^2}, $$\nwhere $x^n \\approx x(t^n)$ and $t^n = n \\Delta t$.\n\nDefine the following nondimensional parameters:\n- The mass ratio $\\mu = \\dfrac{m_a}{m_s}$.\n- The nondimensional structural stiffness $r = \\dfrac{k \\Delta t^2}{m_s}$.\n\nConsider the following two partitioned coupling schemes to advance the structure:\n\n1. Dirichlet–Neumann (DN) explicit added-mass lag:\n   - The structure step uses the fluid force from the previous time level. The discrete structure equation is\n     $$ m_s a^n + k x^{n-1} = F_f^{n-1}, $$\n     while the fluid evaluates $F_f^{n} = - m_a a^n$ after the new displacement is available. The combination of these steps leads to a homogeneous recurrence for $x^n$.\n\n2. Impedance-based Robin–Robin (RR) stabilization with inertial splitting:\n   - Introduce a Robin split parameter $\\alpha \\in [0,1]$ that allocates a portion of the added inertia implicitly to the structure and the remainder explicitly to the fluid lag, giving\n     $$ (m_s + \\alpha m_a) a^n + k x^{n-1} = - (1 - \\alpha) m_a a^{n-1}. $$\n   - For an impedance-based choice that balances structural and fluid inertial effects, set\n     $$ \\alpha^\\star = \\frac{\\mu}{1 + \\mu}. $$\n   - This choice is motivated by matching the inertial impedances so that the implicit portion of the added inertia scales with the fluid-to-structure inertia ratio, mitigating added-mass instabilities.\n\nBy substituting the central difference formula into the DN and RR equations and nondimensionalizing by $m_s$, both schemes reduce to linear homogeneous recurrences of the form\n$$ a_3 g^3 + a_2 g^2 + a_1 g + a_0 = 0, $$\nunder the modal ansatz $x^n = C g^n$, where $g$ is the amplification factor. The coefficients are:\n- For DN (set $\\alpha = 0$):\n  $$ a_3 = 1, \\quad a_2 = -2 + r + \\mu, \\quad a_1 = 1 - 2 \\mu, \\quad a_0 = \\mu. $$\n- For RR with a general $\\alpha$:\n  $$ a_3 = 1 + \\alpha \\mu, \\quad a_2 = -2 + r + \\mu - 3 \\alpha \\mu, \\quad a_1 = 1 - 2 \\mu + 3 \\alpha \\mu, \\quad a_0 = (1 - \\alpha) \\mu. $$\nSet the impedance-based choice $\\alpha = \\alpha^\\star = \\dfrac{\\mu}{1 + \\mu}$ to obtain the RR scheme used in this problem.\n\nYour task is to:\n- Implement a program that, for each test case $(\\mu, r)$ listed below, constructs the corresponding characteristic polynomials for DN and RR, computes all roots $g$, and reports the spectral radius, defined as $\\rho = \\max_i |g_i|$, for each scheme.\n- Use floating-point arithmetic and compute the spectral radius to standard double precision.\n- Output a single line containing a flat list of spectral radii for all test cases in the exact order specified, interleaving DN and RR results per test.\n\nThere are no physical unit outputs in this problem because all parameters are nondimensional by construction. All angles (if any) are not applicable here. All outputs are real-valued floats.\n\nTest suite (four test cases):\n- Case $1$: $\\mu = 0.01$, $r = 0.5$.\n- Case $2$: $\\mu = 5.0$, $r = 0.1$.\n- Case $3$: $\\mu = 10.0$, $r = 0.0$.\n- Case $4$: $\\mu = 1.0$, $r = 3.9$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6,\\text{result}_7,\\text{result}_8$]\"), where for each case you list first the Dirichlet–Neumann spectral radius and then the Robin–Robin spectral radius computed with $\\alpha^\\star = \\dfrac{\\mu}{1 + \\mu}$.", "solution": "The problem presented is a standard von Neumann stability analysis of partitioned time-integration schemes for a canonical one-dimensional fluid-structure interaction (FSI) model. The objective is to compute the spectral radius of the numerical amplification factor for two distinct partitioned schemes: a Dirichlet–Neumann (DN) scheme and a Robin–Robin (RR) scheme. The problem is well-posed, scientifically sound, and internally consistent. We shall proceed with the derivation and solution.\n\nThe system consists of a structural mass $m_s$ on a spring of stiffness $k$, and a fluid with added mass $m_a$. The force exerted by the fluid on the structure is given as $F_f(t) = -m_a \\ddot{x}(t)$. The equation of motion for the structure is $m_s \\ddot{x}(t) + k x(t) = F_f(t)$. For numerical solution, we consider a discrete time $t^n = n \\Delta t$.\n\nThe most general discrete equation provided is for the RR scheme, which we re-write based on a consistent formulation of force partitioning. The total fluid force $F_f$ is split into an implicit part, treated at time level $n$, and an explicit part, lagged at time level $n-1$.\n$F_f \\approx -\\alpha m_a a^n - (1-\\alpha) m_a a^{n-1}$\nThe discretized equation of motion, $m_s a^n = -k x_{discrete} + F_f$, becomes\n$m_s a^n = -k x^{n-1} -\\alpha m_a a^n - (1-\\alpha) m_a a^{n-1}$\nwhere the spring force is also lagged explicitly via $x^{n-1}$. Rearranging terms gives the following linear multistep formula:\n$$ (m_s + \\alpha m_a) a^n + (1-\\alpha) m_a a^{n-1} + k x^{n-1} = 0 $$\nThis form correctly models the inertial splitting and is consistent with the characteristic polynomial coefficients provided. The DN scheme is a special case of this formulation where $\\alpha=0$.\n\nWe perform a von Neumann stability analysis by substituting the central difference approximation for acceleration,\n$$ a^k = \\frac{x^k - 2x^{k-1} + x^{k-2}}{\\Delta t^2} $$\nand the modal ansatz $x^n = C g^n$ into the discrete equation of motion. Here, $g \\in \\mathbb{C}$ is the amplification factor. Substituting the central difference into the rearranged equation yields:\n$$ (m_s + \\alpha m_a) \\frac{x^n - 2x^{n-1} + x^{n-2}}{\\Delta t^2} + (1-\\alpha) m_a \\frac{x^{n-1} - 2x^{n-2} + x^{n-3}}{\\Delta t^2} + k x^{n-1} = 0 $$\nWe divide by $m_s$ and multiply by $\\Delta t^2$, introducing the nondimensional mass ratio $\\mu = m_a/m_s$ and stiffness $r = k \\Delta t^2/m_s$:\n$$ (1 + \\alpha \\mu) (x^n - 2x^{n-1} + x^{n-2}) + (1-\\alpha) \\mu (x^{n-1} - 2x^{n-2} + x^{n-3}) + r x^{n-1} = 0 $$\nNow, we substitute the ansatz $x^k = C g^k$ and divide the entire equation by $C g^{n-3}$:\n$$ (1 + \\alpha \\mu) (g^3 - 2g^2 + g) + (1-\\alpha) \\mu (g^2 - 2g + 1) + r g^2 = 0 $$\nCollecting terms by powers of $g$ yields the characteristic polynomial $a_3 g^3 + a_2 g^2 + a_1 g + a_0 = 0$:\n- $g^3$: $a_3 = 1 + \\alpha \\mu$\n- $g^2$: $a_2 = -2(1 + \\alpha \\mu) + (1-\\alpha)\\mu + r = -2 - 2\\alpha\\mu + \\mu - \\alpha\\mu + r = -2 + r + \\mu - 3\\alpha\\mu$\n- $g^1$: $a_1 = (1 + \\alpha \\mu) - 2(1-\\alpha)\\mu = 1 + \\alpha\\mu - 2\\mu + 2\\alpha\\mu = 1 - 2\\mu + 3\\alpha\\mu$\n- $g^0$: $a_0 = (1-\\alpha)\\mu$\n\nThese coefficients exactly match those provided in the problem statement, confirming the consistency of our formulation. The stability of a scheme is determined by its spectral radius, $\\rho = \\max_i |g_i|$, where $\\{g_i\\}$ are the roots of the characteristic polynomial. A scheme is stable if $\\rho \\le 1$.\n\nThe algorithm to solve the problem is as follows:\n1. For each test case $(\\mu, r)$, we define the two schemes to be analyzed.\n2. The DN scheme corresponds to setting the parameter $\\alpha = 0$. The coefficients of its characteristic polynomial are calculated using the general formulas with this value.\n3. The impedance-based RR scheme uses the specific parameter $\\alpha = \\alpha^\\star = \\dfrac{\\mu}{1 + \\mu}$. The coefficients of its characteristic polynomial are calculated using the general formulas with this value of $\\alpha$.\n4. For each of the two polynomials, we compute its three complex roots, $\\{g_1, g_2, g_3\\}$, using a numerical root-finding algorithm.\n5. The spectral radius $\\rho$ for each scheme is then computed as the maximum of the absolute values of these roots: $\\rho = \\max(|g_1|, |g_2|, |g_3|)$.\n6. The results are aggregated in the specified order: for each case, the DN spectral radius is listed, followed by the RR spectral radius.\n\nThis procedure will be implemented for the four given test cases. All calculations are performed using floating-point arithmetic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral radius for two partitioned FSI coupling schemes\n    over a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (mu, r)\n        (0.01, 0.5),\n        (5.0, 0.1),\n        (10.0, 0.0),\n        (1.0, 3.9),\n    ]\n\n    results = []\n\n    def calculate_spectral_radius(mu, r, alpha):\n        \"\"\"\n        Calculates the spectral radius for a given set of nondimensional\n        parameters (mu, r) and a Robin split parameter (alpha).\n\n        The characteristic polynomial is a_3*g^3 + a_2*g^2 + a_1*g + a_0 = 0.\n        \"\"\"\n        # Coefficients for the general Robin-Robin scheme\n        a3 = 1.0 + alpha * mu\n        a2 = -2.0 + r + mu - 3.0 * alpha * mu\n        a1 = 1.0 - 2.0 * mu + 3.0 * alpha * mu\n        a0 = (1.0 - alpha) * mu\n\n        # The coefficients must be in order of decreasing power for numpy.roots\n        coeffs = [a3, a2, a1, a0]\n        \n        # Find the roots of the characteristic polynomial\n        roots = np.roots(coeffs)\n        \n        # The spectral radius is the maximum of the absolute values of the roots\n        spectral_radius = np.max(np.abs(roots))\n        \n        return spectral_radius\n\n    for mu, r in test_cases:\n        # Case 1: Dirichlet-Neumann (DN) scheme\n        # This is equivalent to the Robin-Robin scheme with alpha = 0\n        alpha_dn = 0.0\n        rho_dn = calculate_spectral_radius(mu, r, alpha_dn)\n        results.append(rho_dn)\n        \n        # Case 2: Impedance-based Robin-Robin (RR) scheme\n        # This uses the specified stabilization parameter alpha_star\n        alpha_rr = mu / (1.0 + mu)\n        rho_rr = calculate_spectral_radius(mu, r, alpha_rr)\n        results.append(rho_rr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2560166"}, {"introduction": "A key challenge in practical partitioned FSI is the transfer of data between independently generated, non-matching meshes at the interface. A naive transfer can violate fundamental physical laws, so a robust scheme must be conservative. This practice [@problem_id:2560143] focuses on implementing a conservative traction transfer method that guarantees the net force on the interface is zero, upholding Newton's third law in the discrete sense. By applying a consistent integration rule over an overlaid grid, you will verify numerically that conservation is maintained even with highly dissimilar meshes.", "problem": "Consider a one-dimensional fluid-structure interaction interface represented by the interval $\\Gamma = [0,1]$. The fluid side provides a prescribed traction field $t_f(s)$ along $\\Gamma$, where $s \\in [0,1]$ is the interface coordinate. The fluid and solid interfaces are discretized independently with piecewise linear finite elements using nonmatching node sets. Let the fluid interface mesh have $n_f$ elements with nodes at $\\{x_i^f\\}_{i=0}^{n_f}$ and the solid interface mesh have $n_s$ elements with nodes at $\\{x_j^s\\}_{j=0}^{n_s}$, with $x_0^f = x_0^s = 0$ and $x_{n_f}^f = x_{n_s}^s = 1$. Each side uses standard linear shape functions on its elements, which satisfy partition of unity on each element.\n\nStarting from the balance of linear momentum and Newton’s third law (action-reaction) at the interface, the physically correct coupling condition is $t_s(s) = -t_f(s)$ on $\\Gamma$, where $t_s$ is the traction acting on the solid. In the finite element method (FEM), the conservative discrete interface load vectors that enforce this balance in a weak sense are defined by the consistent load assembly:\n- For the solid: $\\mathbf{f}_s = \\int_{\\Gamma} \\mathbf{N}_s^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$, where $\\mathbf{N}_s$ collects the solid-side shape functions associated with solid interface nodes.\n- For the fluid: $\\mathbf{f}_f = -\\int_{\\Gamma} \\mathbf{N}_f^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$, where $\\mathbf{N}_f$ collects the fluid-side shape functions associated with fluid interface nodes.\n\nA conservative partitioned transfer on nonmatching meshes requires evaluating these integrals over the exact overlap of fluid and solid elements. A robust way to do this is to partition $\\Gamma$ into the set of subsegments defined by all pairwise intersections of fluid and solid elements and to apply the same Gaussian quadrature on each subsegment when assembling $\\mathbf{f}_s$ and $\\mathbf{f}_f$. Because linear shape functions satisfy partition of unity, conservation of total force is obtained when the same quadrature is used for both sides at each subsegment.\n\nYour task is to implement this conservative traction transfer and verify conservation numerically for several test cases. Specifically:\n\n- Implement the assembly of $\\mathbf{f}_s$ and $\\mathbf{f}_f$ on nonmatching meshes by:\n  - Constructing the overlay of the fluid and solid meshes via their element-wise intersections on $\\Gamma$.\n  - On each nonempty intersection subsegment $[a,b] \\subset \\Gamma$, applying $n_q = 3$ point Gauss–Legendre quadrature with points and weights mapped from $[-1,1]$ to $[a,b]$.\n  - At each quadrature point $s_q \\in [a,b]$, evaluating $t_f(s_q)$ and the active fluid and solid linear shape functions on their respective elements that contain $s_q$.\n  - Accumulating contributions to $\\mathbf{f}_s$ and $\\mathbf{f}_f$ using the same quadrature weights, with signs as specified above.\n\n- Verify conservation by computing the scalar totals $F_s = \\sum_k (\\mathbf{f}_s)_k$ and $F_f = \\sum_\\ell (\\mathbf{f}_f)_\\ell$ and checking whether $|F_s + F_f| \\le \\tau$, where $\\tau$ is a numerical tolerance that represents solver tolerance. Use $\\tau = 10^{-12}$.\n\n- Interpret the case $n_f = n_s$ with matching uniform nodes as a surrogate for a monolithic scheme (shared interface mesh). In this case, the same assembly still applies and should also satisfy conservation to the same tolerance.\n\nUse the following test suite. For each test case, $t_f(s)$ is the scalar traction field prescribed on the fluid side, and the meshes are uniform:\n- Test $1$ (matching meshes, monolithic-like): $n_f = 8$, $n_s = 8$, $t_f(s) = 3.5 + 1.0\\, s$ for $s \\in [0,1]$.\n- Test $2$ (nonmatching meshes, constant traction): $n_f = 5$, $n_s = 7$, $t_f(s) = 5.0$ for $s \\in [0,1]$.\n- Test $3$ (highly nonmatching, coarse-to-fine): $n_f = 2$, $n_s = 19$, $t_f(s) = 2.0 + 3.0\\, s$ for $s \\in [0,1]$.\n- Test $4$ (nonmatching, oscillatory): $n_f = 17$, $n_s = 13$, $t_f(s) = 0.2 + \\sin(6\\pi s)$ for $s \\in [0,1]$.\n- Test $5$ (boundary case, one very coarse side): $n_f = 1$, $n_s = 50$, $t_f(s) = \\sin(2\\pi s)$ for $s \\in [0,1]$.\n\nYour program must:\n- Implement the conservative assembly described above with $n_q = 3$ Gauss–Legendre points on each intersection subsegment.\n- For each test case, compute the boolean result $b = \\left(|F_s + F_f| \\le \\tau\\right)$ with $\\tau = 10^{-12}$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[True,False,True,True,False]\"). No other text should be printed.\n\nThere are no external inputs. All quantities are nondimensional. The output consists only of boolean values; therefore, no physical units are required or permitted in the output.", "solution": "The problem statement presents a task of verifying the numerical conservation of a force transfer scheme between nonmatching meshes in a fluid-structure interaction context. Before proceeding, a critical validation is necessary. The problem is mathematically well-posed and algorithmically specified in sufficient detail. However, there is a minor imprecision in the physical justification provided. The statement \"the physically correct coupling condition is $t_s(s) = -t_f(s)$ on $\\Gamma$, where $t_s$ is the traction acting on the solid\" is contrary to standard convention. If $t_f(s)$ is the traction exerted by the fluid on the interface, then the traction felt by the solid is precisely $t_s(s) = t_f(s)$. The reaction force exerted by the solid on the fluid is then $-t_f(s)$.\n\nFortunately, the subsequent definitions of the discrete force vectors are physically correct and unambiguous:\n- Solid force vector: $\\mathbf{f}_s = \\int_{\\Gamma} \\mathbf{N}_s^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$. This correctly defines the load on the solid as being due to the fluid traction $t_f(s)$.\n- Fluid force vector: $\\mathbf{f}_f = -\\int_{\\Gamma} \\mathbf{N}_f^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$. This correctly defines the load on the fluid as the reaction force $-t_f(s)$.\n\nThese integral definitions provide a sound and sufficient basis for the task. The flawed introductory sentence is noted but does not invalidate the well-defined mathematical problem. We shall proceed based on these correct integral formulations.\n\nThe core principle to be verified is a direct consequence of the partition of unity property of finite element shape functions. The total force acting on the solid interface, $F_s$, is the sum of all nodal forces in $\\mathbf{f}_s$:\n$$ F_s = \\sum_j (\\mathbf{f}_s)_j = \\sum_j \\int_{\\Gamma} N_{s,j}(s) \\, t_f(s) \\, \\mathrm{d}s $$\nBy linearity of the integral, we can interchange summation and integration:\n$$ F_s = \\int_{\\Gamma} \\left( \\sum_j N_{s,j}(s) \\right) t_f(s) \\, \\mathrm{d}s $$\nThe set of all shape functions $\\{N_{s,j}(s)\\}$ for the solid mesh forms a partition of unity, meaning their sum is equal to $1$ at any point $s \\in \\Gamma$. Thus, $\\sum_j N_{s,j}(s) = 1$. The expression for the total force on the solid simplifies to the total applied load:\n$$ F_s = \\int_{\\Gamma} t_f(s) \\, \\mathrm{d}s $$\nA similar derivation for the fluid side gives the total force $F_f$:\n$$ F_f = \\sum_i (\\mathbf{f}_f)_i = \\sum_i \\left( -\\int_{\\Gamma} N_{f,i}(s) \\, t_f(s) \\, \\mathrm{d}s \\right) = - \\int_{\\Gamma} \\left( \\sum_i N_{f,i}(s) \\right) t_f(s) \\, \\mathrm{d}s $$\nThe fluid shape functions also form a partition of unity, $\\sum_i N_{f,i}(s) = 1$, which leads to:\n$$ F_f = - \\int_{\\Gamma} t_f(s) \\, \\mathrm{d}s $$\nAnalytically, the total forces are perfectly balanced: $F_s + F_f = 0$.\n\nThe task is to verify that the proposed numerical scheme preserves this conservation property. The scheme's foundation is the creation of a common computational grid by overlaying the fluid and solid meshes. The interval $\\Gamma = [0,1]$ is decomposed into a set of disjoint subsegments $\\{I_k\\}_{k=1}^M$ where each $I_k = [a_k, b_k]$ is the non-empty intersection of a fluid element and a solid element.\n\nThe integrals for $\\mathbf{f}_s$ and $\\mathbf{f}_f$ are computed by summing the contributions from each subsegment. On each subsegment $I_k$, a $n_q=3$ point Gauss-Legendre quadrature is employed. The quadrature points $\\xi_q$ and weights $w_q$ on the reference interval $[-1,1]$ are mapped to points $s_{q,k}$ and weights $W_{q,k}$ on $I_k$:\n$$ s_{q,k} = \\frac{a_k+b_k}{2} + \\frac{b_k-a_k}{2} \\xi_q, \\quad W_{q,k} = \\frac{b_k-a_k}{2} w_q $$\nThe numerically computed total force on the solid, $F_s^{\\text{num}}$, is the sum of all nodal force components:\n$$ F_s^{\\text{num}} = \\sum_j \\left( \\sum_{k} \\sum_{q} N_{s,j}(s_{q,k}) \\, t_f(s_{q,k}) \\, W_{q,k} \\right) = \\sum_{k,q} \\left( \\sum_j N_{s,j}(s_{q,k}) \\right) t_f(s_{q,k}) \\, W_{q,k} $$\nApplying the partition of unity property, $\\sum_j N_{s,j}(s_{q,k}) = 1$, at each quadrature point yields:\n$$ F_s^{\\text{num}} = \\sum_{k,q} t_f(s_{q,k}) \\, W_{q,k} $$\nSimilarly, the total force on the fluid is:\n$$ F_f^{\\text{num}} = \\sum_i \\left( -\\sum_{k,q} N_{f,i}(s_{q,k}) \\, t_f(s_{q,k}) \\, W_{q,k} \\right) = -\\sum_{k,q} \\left( \\sum_i N_{f,i}(s_{q,k}) \\right) t_f(s_{q,k}) \\, W_{q,k} $$\nUsing the partition of unity for the fluid shape functions, $\\sum_i N_{f,i}(s_{q,k}) = 1$:\n$$ F_f^{\\text{num}} = -\\sum_{k,q} t_f(s_{q,k}) \\, W_{q,k} $$\nThe key to conservation is that the numerical approximation for the total load, $\\sum_{k,q} t_f(s_{q,k}) \\, W_{q,k}$, is identical for both the fluid and solid calculations because the same subsegments and quadrature rule are used. Therefore, we must have $F_s^{\\text{num}} + F_f^{\\text{num}} = 0$ to within the limits of floating-point arithmetic. The specified tolerance $\\tau = 10^{-12}$ serves as a practical threshold to verify this property.\n\nThe implementation will proceed as follows:\n$1$. For each test case, generate the uniform nodal coordinates for the fluid mesh with $n_f$ elements and the solid mesh with $n_s$ elements on the interval $[0,1]$.\n$2$. Initialize zero-valued force vectors $\\mathbf{f}_f$ of size $n_f+1$ and $\\mathbf{f}_s$ of size $n_s+1$.\n$3$. Iterate through each fluid element $e_f^i$ (for $i=0, \\dots, n_f-1$) and each solid element $e_s^j$ (for $j=0, \\dots, n_s-1$).\n$4$. Determine the intersection interval $[a,b] = [x_i^f, x_{i+1}^f] \\cap [x_j^s, x_{j+1}^s]$.\n$5$. If the intersection is non-empty (i.e., $a < b$), perform numerical integration over $[a,b]$ using a $3$-point Gauss-Legendre quadrature.\n$6$. At each quadrature point $s_q$, evaluate the traction $t_f(s_q)$ and the values of the local linear shape functions for both the active fluid element $e_f^i$ and solid element $e_s^j$.\n$7$. Accumulate the weighted contributions $N(s_q) t_f(s_q) W_q$ into the appropriate global entries of $\\mathbf{f}_s$ and, with a negative sign, into $\\mathbf{f}_f$.\n$8$. After iterating through all element pairs, compute the total forces $F_s = \\sum_j (\\mathbf{f}_s)_j$ and $F_f = \\sum_i (\\mathbf{f}_f)_i$.\n$9$. Finally, evaluate the boolean condition $|F_s + F_f| \\le 10^{-12}$ to confirm conservation. This procedure is repeated for all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that executes all test cases for conservative traction transfer.\n    \"\"\"\n    \n    # Define Gauss-Legendre quadrature points and weights for n_q = 3 on [-1, 1].\n    # These are high-precision values for sqrt(3/5).\n    gauss_points_3 = np.array([-0.7745966692414834, 0.0, 0.7745966692414834])\n    gauss_weights_3 = np.array([0.5555555555555556, 0.8888888888888888, 0.5555555555555556])\n    \n    # Numerical tolerance for conservation check.\n    tolerance = 1.0e-12\n\n    def get_gauss_quadrature(a, b, points, weights):\n        \"\"\"Maps Gauss points and weights from the reference interval [-1, 1] to [a, b].\"\"\"\n        mid = (a + b) / 2.0\n        half_len = (b - a) / 2.0\n        quad_points = mid + half_len * points\n        quad_weights = half_len * weights\n        return quad_points, quad_weights\n\n    def linear_shape_functions(s, x1, x2):\n        \"\"\"\n        Evaluates 1D linear shape functions for an element defined by nodes [x1, x2] at a point s.\n        Returns a tuple (N1(s), N2(s)).\n        \"\"\"\n        length = x2 - x1\n        if length <= 0:\n            # Handle degenerate or invalid element lengths.\n            return 0.0, 0.0\n        n1 = (x2 - s) / length\n        n2 = (s - x1) / length\n        return n1, n2\n\n    def solve_one_case(n_f, n_s, t_f_func, tau):\n        \"\"\"\n        Implements the conservative assembly and verification for a single test case.\n        Args:\n            n_f (int): Number of fluid elements.\n            n_s (int): Number of solid elements.\n            t_f_func (callable): The traction function t_f(s).\n            tau (float): The conservation tolerance.\n        Returns:\n            bool: True if conservation is satisfied, False otherwise.\n        \"\"\"\n        # 1. Define uniform meshes on the interval [0, 1].\n        nodes_f = np.linspace(0.0, 1.0, n_f + 1)\n        nodes_s = np.linspace(0.0, 1.0, n_s + 1)\n\n        # Initialize global force vectors to zero.\n        f_f = np.zeros(n_f + 1)\n        f_s = np.zeros(n_s + 1)\n\n        # 2. Loop over all fluid-solid element pairs to find intersections.\n        for i in range(n_f):  # Loop over fluid elements\n            x_f1, x_f2 = nodes_f[i], nodes_f[i + 1]\n            for j in range(n_s):  # Loop over solid elements\n                x_s1, x_s2 = nodes_s[j], nodes_s[j + 1]\n\n                # Find the intersection subsegment [a, b].\n                a = max(x_f1, x_s1)\n                b = min(x_f2, x_s2)\n\n                # 3. Integrate over the non-empty intersection subsegment.\n                if a < b:\n                    # Get Gauss quadrature points and weights for the subsegment [a, b].\n                    quad_points, quad_weights = get_gauss_quadrature(\n                        a, b, gauss_points_3, gauss_weights_3\n                    )\n\n                    # Perform numerical integration.\n                    for q_idx in range(len(quad_points)):\n                        s_q = quad_points[q_idx]\n                        w_q = quad_weights[q_idx]\n\n                        # Evaluate traction at the quadrature point.\n                        t_q = t_f_func(s_q)\n\n                        # Evaluate fluid shape functions for element i at s_q.\n                        nf1_q, nf2_q = linear_shape_functions(s_q, x_f1, x_f2)\n\n                        # Evaluate solid shape functions for element j at s_q.\n                        ns1_q, ns2_q = linear_shape_functions(s_q, x_s1, x_s2)\n                        \n                        # 4. Accumulate forces into global vectors.\n                        # Fluid force vector (action-reaction principle gives a negative sign).\n                        f_f[i]     -= nf1_q * t_q * w_q\n                        f_f[i + 1] -= nf2_q * t_q * w_q\n                        \n                        # Solid force vector (receives the fluid traction).\n                        f_s[j]     += ns1_q * t_q * w_q\n                        f_s[j + 1] += ns2_q * t_q * w_q\n\n        # 5. Verify conversation by summing all nodal forces.\n        f_total_f = np.sum(f_f)\n        f_total_s = np.sum(f_s)\n        \n        residual = abs(f_total_f + f_total_s)\n        return residual <= tau\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 8, lambda s: 3.5 + 1.0 * s),\n        (5, 7, lambda s: 5.0),\n        (2, 19, lambda s: 2.0 + 3.0 * s),\n        (17, 13, lambda s: 0.2 + np.sin(6 * np.pi * s)),\n        (1, 50, lambda s: np.sin(2 * np.pi * s)),\n    ]\n\n    results = []\n    for nf, ns, t_f in test_cases:\n        result = solve_one_case(nf, ns, t_f, tolerance)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2560143"}]}