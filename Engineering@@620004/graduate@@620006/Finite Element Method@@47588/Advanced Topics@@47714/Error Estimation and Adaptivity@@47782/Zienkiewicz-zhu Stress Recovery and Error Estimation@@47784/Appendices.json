{"hands_on_practices": [{"introduction": "The Zienkiewicz-Zhu (ZZ) recovery method seeks to generate a more accurate, continuous stress field from the discontinuous one produced by a standard finite element analysis. A rigorous approach involves finding the $L_2$-projection of the discontinuous stress field onto a continuous function space, though simpler methods like nodal averaging are often used in practice. This exercise provides a foundational, hands-on calculation on a simple two-element patch to illuminate the connection between these approaches, helping you understand why nodal averaging can be a surprisingly effective approximation of the more formal projection [@problem_id:2613001].", "problem": "Consider a two-dimensional linear elastic body under plane stress with isotropic material properties: Young’s modulus $E$ and Poisson’s ratio $\\nu$. The domain is the unit square $[0,1]\\times[0,1]$, discretized by two linear triangular finite elements forming a single square patch. The nodes are $1:(0,0)$, $2:(1,0)$, $3:(0,1)$, and $4:(1,1)$. The triangulation uses elements $T_1:(1,2,4)$ and $T_2:(1,3,4)$, where the notation $(i,j,k)$ denotes the triangle with vertices at nodes $i$, $j$, and $k$.\n\nAssume small strains and linearized kinematics. The nodal displacement field is prescribed as follows: the horizontal displacement $u$ is $u(0,0)=0$, $u(1,0)=0$, $u(0,1)=0$, $u(1,1)=\\alpha$, and the vertical displacement $v$ is zero at all nodes. Thus, $v(0,0)=v(1,0)=v(0,1)=v(1,1)=0$, where $\\alpha$ is a given constant. There are no body forces.\n\n1) Using the definitions of the small strain tensor and the plane stress constitutive relation, compute the constant finite element stress field $\\sigma^{h}$ within each element. In particular, determine the piecewise constant values of the normal stress component $\\sigma_{xx}^{h}$ on $T_1$ and $T_2$.\n\n2) Treat the scalar field $s(\\boldsymbol{x})=\\sigma_{xx}^{h}(\\boldsymbol{x})$ as a piecewise constant function over the mesh. Define the $L_2$-projection of $s$ onto the continuous piecewise-linear finite element space associated with this mesh as the function $s^{\\ast}$ satisfying the standard Galerkin condition $\\int_{\\Omega} \\varphi_i\\, s^{\\ast}\\,\\mathrm{d}\\Omega = \\int_{\\Omega} \\varphi_i\\, s\\,\\mathrm{d}\\Omega$ for all nodal basis functions $\\varphi_i$. Assemble and solve this projection on the given two-element patch to obtain the nodal values of $s^{\\ast}$, and extract the value at node $4$, denoted $s^{\\ast}_4$.\n\n3) Compute the area-weighted nodal average at node $4$ from the elementwise constants, namely $\\overline{s}_4 = \\dfrac{A_1 s|_{T_1} + A_2 s|_{T_2}}{A_1 + A_2}$, where $A_e$ denotes the area of element $T_e$.\n\n4) Relate the $L_2$-projection to nodal averaging in this simple patch in the spirit of the Zienkiewicz and Zhu (ZZ) stress recovery method, and compare $s^{\\ast}_4$ with $\\overline{s}_4$.\n\nTo produce a single scalar result, define the dimensionless difference\n$$\n\\widehat{\\delta} \\;=\\; \\frac{s^{\\ast}_4 - \\overline{s}_4}{S},\n$$\nwhere $S=\\dfrac{E\\,\\alpha}{1-\\nu^2}$. Provide the final value of $\\widehat{\\delta}$ as your answer. No rounding is required. Since $\\widehat{\\delta}$ is dimensionless, do not attach any physical units to the final result.", "solution": "The solution proceeds in four steps as outlined in the problem statement.\n\nStep 1: Computation of the finite element stress field $\\sigma^{h}$.\nThe domain $\\Omega = [0,1]\\times[0,1]$ is discretized into two linear triangular elements, $T_1$ with nodes $(1,2,4)$ and $T_2$ with nodes $(1,3,4)$. The nodal coordinates are $1:(0,0)$, $2:(1,0)$, $3:(0,1)$, and $4:(1,1)$. The area of each triangle is $A_1 = A_2 = \\frac{1}{2}$. The prescribed nodal displacements are $u_1=0$, $u_2=0$, $u_3=0$, $u_4=\\alpha$, and $v_i=0$ for all nodes $i=1,2,3,4$.\nFor a linear triangular element, the strain field is constant. The strain vector $\\boldsymbol{\\varepsilon} = \\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}^T$ is related to the nodal displacement vector $\\boldsymbol{d}^e = \\{u_i, v_i, u_j, v_j, u_k, v_k\\}^T$ by $\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\boldsymbol{d}^e$, where $\\boldsymbol{B}$ is the strain-displacement matrix.\n\nFor element $T_1$ (nodes $1,2,4$), the nodal displacement vector is $\\boldsymbol{d}^1 = \\{0, 0, 0, 0, \\alpha, 0\\}^T$. The coordinates are $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, and $(x_4,y_4)=(1,1)$. The strain-displacement matrix $\\boldsymbol{B}_1$ is:\n$$\n\\boldsymbol{B}_1 = \\frac{1}{2A_1}\n\\begin{pmatrix}\ny_2-y_4 & 0         & y_4-y_1 & 0         & y_1-y_2 & 0 \\\\\n0         & x_4-x_2 & 0         & x_1-x_4 & 0         & x_2-x_1 \\\\\nx_4-x_2 & y_2-y_4 & x_1-x_4 & y_4-y_1 & x_2-x_1 & y_1-y_2\n\\end{pmatrix}\n= \\frac{1}{2(\\frac{1}{2})}\n\\begin{pmatrix}\n-1 & 0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & -1 & 0 & 1 \\\\\n0 & -1 & -1 & 1 & 1 & 0\n\\end{pmatrix}\n$$\nThe strain vector in $T_1$ is:\n$$\n\\boldsymbol{\\varepsilon}^1 = \\boldsymbol{B}_1 \\boldsymbol{d}^1 =\n\\begin{pmatrix}\n-1 & 0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & -1 & 0 & 1 \\\\\n0 & -1 & -1 & 1 & 1 & 0\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\alpha \\\\ 0 \\end{pmatrix}\n= \\begin{pmatrix} 0 \\\\ 0 \\\\ \\alpha \\end{pmatrix}\n$$\nSo, within $T_1$: $\\varepsilon_{xx}^1=0$, $\\varepsilon_{yy}^1=0$, $\\gamma_{xy}^1=\\alpha$.\n\nFor element $T_2$ (nodes $1,3,4$), the nodal displacement vector is $\\boldsymbol{d}^2 = \\{0, 0, 0, 0, \\alpha, 0\\}^T$. The coordinates are $(x_1,y_1)=(0,0)$, $(x_3,y_3)=(0,1)$, and $(x_4,y_4)=(1,1)$. The strain-displacement matrix $\\boldsymbol{B}_2$ is:\n$$\n\\boldsymbol{B}_2 = \\frac{1}{2A_2}\n\\begin{pmatrix}\ny_3-y_4 & 0         & y_4-y_1 & 0         & y_1-y_3 & 0 \\\\\n0         & x_4-x_3 & 0         & x_1-x_4 & 0         & x_3-x_1 \\\\\nx_4-x_3 & y_3-y_4 & x_1-x_4 & y_4-y_1 & x_3-x_1 & y_1-y_3\n\\end{pmatrix}\n= \\frac{1}{2(\\frac{1}{2})}\n\\begin{pmatrix}\n0 & 0 & 1 & 0 & -1 & 0 \\\\\n0 & 1 & 0 & -1 & 0 & 0 \\\\\n1 & 0 & -1 & 1 & 0 & -1\n\\end{pmatrix}\n$$\nThe strain vector in $T_2$ is:\n$$\n\\boldsymbol{\\varepsilon}^2 = \\boldsymbol{B}_2 \\boldsymbol{d}^2 =\n\\begin{pmatrix}\n0 & 0 & 1 & 0 & -1 & 0 \\\\\n0 & 1 & 0 & -1 & 0 & 0 \\\\\n1 & 0 & -1 & 1 & 0 & -1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\alpha \\\\ 0 \\end{pmatrix}\n= \\begin{pmatrix} -\\alpha \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\nSo, within $T_2$: $\\varepsilon_{xx}^2=-\\alpha$, $\\varepsilon_{yy}^2=0$, $\\gamma_{xy}^2=0$.\n\nThe constitutive relation for plane stress is $\\boldsymbol{\\sigma} = \\boldsymbol{D} \\boldsymbol{\\varepsilon}$, with the matrix $\\boldsymbol{D}$ given by:\n$$\n\\boldsymbol{D} = \\frac{E}{1-\\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{pmatrix}\n$$\nFor $T_1$, the stress vector is:\n$$\n\\boldsymbol{\\sigma}^1 = \\boldsymbol{D} \\boldsymbol{\\varepsilon}^1 = \\frac{E}{1-\\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\alpha \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{E\\alpha(1-\\nu)}{2(1-\\nu^2)} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{E\\alpha}{2(1+\\nu)} \\end{pmatrix}\n$$\nThe normal stress component is $\\sigma_{xx}^h|_{T_1} = 0$.\n\nFor $T_2$, the stress vector is:\n$$\n\\boldsymbol{\\sigma}^2 = \\boldsymbol{D} \\boldsymbol{\\varepsilon}^2 = \\frac{E}{1-\\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{pmatrix} \\begin{pmatrix} -\\alpha \\\\ 0 \\\\ 0 \\end{pmatrix} = -\\frac{E\\alpha}{1-\\nu^2} \\begin{pmatrix} 1 \\\\ \\nu \\\\ 0 \\end{pmatrix}\n$$\nThe normal stress component is $\\sigma_{xx}^h|_{T_2} = -\\frac{E\\alpha}{1-\\nu^2}$. Let $S = \\frac{E\\alpha}{1-\\nu^2}$, so $\\sigma_{xx}^h|_{T_2} = -S$.\n\nStep 2: Computation of the $L_2$-projected stress $s^{\\ast}_4$.\nThe field to be projected is the piecewise constant scalar field $s(\\boldsymbol{x}) = \\sigma_{xx}^h(\\boldsymbol{x})$, which is $s|_{T_1}=0$ and $s|_{T_2}=-S$. The projection $s^{\\ast}$ onto the space of continuous piecewise-linear functions is $s^{\\ast}(\\boldsymbol{x}) = \\sum_{j=1}^4 s^{\\ast}_j \\varphi_j(\\boldsymbol{x})$, where $\\varphi_j$ are the nodal basis functions. The Galerkin condition is $\\boldsymbol{M} \\boldsymbol{s}^{\\ast} = \\boldsymbol{f}$, where $\\boldsymbol{s}^{\\ast} = \\{s_1^{\\ast}, s_2^{\\ast}, s_3^{\\ast}, s_4^{\\ast}\\}^T$, $M_{ij} = \\int_{\\Omega} \\varphi_i \\varphi_j d\\Omega$, and $f_i = \\int_{\\Omega} \\varphi_i s d\\Omega$.\n\nThe load vector components are: $f_i = \\int_{T_1} \\varphi_i s|_{T_1} d\\Omega + \\int_{T_2} \\varphi_i s|_{T_2} d\\Omega$.\nSince $s|_{T_1}=0$ and $s|_{T_2}=-S$, and $\\int_{T_e} \\varphi_i d\\Omega = A_e/3$ for a node $i$ of element $e$:\n$f_1 = (-S) \\int_{T_2} \\varphi_1 d\\Omega = (-S) \\frac{A_2}{3} = -S/6$.\n$f_2 = 0$, as node $2$ is not in $T_2$.\n$f_3 = (-S) \\int_{T_2} \\varphi_3 d\\Omega = (-S) \\frac{A_2}{3} = -S/6$.\n$f_4 = (-S) \\int_{T_2} \\varphi_4 d\\Omega = (-S) \\frac{A_2}{3} = -S/6$.\nSo, $\\boldsymbol{f} = \\{-S/6, 0, -S/6, -S/6\\}^T$.\n\nThe consistent mass matrix for a linear triangle is $\\boldsymbol{M}^e = \\frac{A_e}{12}\\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix}$. With $A_1=A_2=1/2$, assembling for the whole patch gives the global mass matrix $\\boldsymbol{M}$:\n$$\n\\boldsymbol{M} = \\frac{1}{24} \\begin{pmatrix} 4 & 1 & 1 & 2 \\\\ 1 & 2 & 0 & 1 \\\\ 1 & 0 & 2 & 1 \\\\ 2 & 1 & 1 & 4 \\end{pmatrix}\n$$\nThe linear system is $\\boldsymbol{M} \\boldsymbol{s}^{\\ast} = \\boldsymbol{f}$:\n$$\n\\frac{1}{24} \\begin{pmatrix} 4 & 1 & 1 & 2 \\\\ 1 & 2 & 0 & 1 \\\\ 1 & 0 & 2 & 1 \\\\ 2 & 1 & 1 & 4 \\end{pmatrix} \\begin{pmatrix} s_1^{\\ast} \\\\ s_2^{\\ast} \\\\ s_3^{\\ast} \\\\ s_4^{\\ast} \\end{pmatrix} = -\\frac{S}{6} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix}\n$$\nMultiplying by $24$ yields the system:\n$1) \\ 4s_1^{\\ast} + s_2^{\\ast} + s_3^{\\ast} + 2s_4^{\\ast} = -4S$\n$2) \\ s_1^{\\ast} + 2s_2^{\\ast} + s_4^{\\ast} = 0$\n$3) \\ s_1^{\\ast} + 2s_3^{\\ast} + s_4^{\\ast} = -4S$\n$4) \\ 2s_1^{\\ast} + s_2^{\\ast} + s_3^{\\ast} + 4s_4^{\\ast} = -4S$\n\nSubtracting equation $(4)$ from $(1)$ gives $2s_1^{\\ast} - 2s_4^{\\ast} = 0$, which implies $s_1^{\\ast} = s_4^{\\ast}$.\nSubstituting $s_1^{\\ast} = s_4^{\\ast}$ into $(2)$ gives $s_4^{\\ast} + 2s_2^{\\ast} + s_4^{\\ast} = 0 \\implies s_2^{\\ast} = -s_4^{\\ast}$.\nSubstituting $s_1^{\\ast} = s_4^{\\ast}$ into $(3)$ gives $s_4^{\\ast} + 2s_3^{\\ast} + s_4^{\\ast} = -4S \\implies s_3^{\\ast} = -2S - s_4^{\\ast}$.\nSubstituting these expressions into $(1)$:\n$4s_4^{\\ast} + (-s_4^{\\ast}) + (-2S - s_4^{\\ast}) + 2s_4^{\\ast} = -4S$\n$4s_4^{\\ast} - 2S = -4S \\implies 4s_4^{\\ast} = -2S \\implies s_4^{\\ast} = -S/2$.\n\nStep 3: Computation of the area-weighted nodal average $\\overline{s}_4$.\nThe formula is $\\overline{s}_4 = \\dfrac{A_1 s|_{T_1} + A_2 s|_{T_2}}{A_1 + A_2}$. Node $4$ is shared by elements $T_1$ and $T_2$.\nUsing the values $A_1=1/2$, $A_2=1/2$, $s|_{T_1}=0$, and $s|_{T_2}=-S$:\n$$\n\\overline{s}_4 = \\frac{(\\frac{1}{2})(0) + (\\frac{1}{2})(-S)}{\\frac{1}{2} + \\frac{1}{2}} = \\frac{-S/2}{1} = -S/2\n$$\n\nStep 4: Relation and final computation.\nThe Zienkiewicz-Zhu (ZZ) recovery method aims to create a more accurate, continuous stress field from the discontinuous element-wise constant (or polynomial) stress field. A common implementation of this method is the $L_2$-projection, as performed in Step 2. A frequent simplification, termed mass lumping, diagonalizes the mass matrix, which effectively reduces the projection to a simple weighted nodal average, as computed in Step 3. For this particular problem, with a patch of two identical right triangles forming a square, the standard $L_2$-projection using a consistent mass matrix and the simplified nodal averaging surprisingly yields an identical result for the corner node $4$ opposite the common diagonal.\nWe have $s^{\\ast}_4 = -S/2$ and $\\overline{s}_4 = -S/2$.\nThe dimensionless difference $\\widehat{\\delta}$ is:\n$$\n\\widehat{\\delta} = \\frac{s^{\\ast}_4 - \\overline{s}_4}{S} = \\frac{(-S/2) - (-S/2)}{S} = \\frac{0}{S} = 0\n$$", "answer": "$$\n\\boxed{0}\n$$", "id": "2613001"}, {"introduction": "After grasping the concept of stress recovery, the next step is to master its computational mechanics. The most common implementation of the ZZ method involves a local least-squares fit of a polynomial to raw stress data within a patch of elements surrounding each node. This practice demystifies this process by having you construct the design matrix, solve the normal equations, and evaluate the recovered stress, sharpening your ability to translate theory into a concrete algorithm [@problem_id:2612978]. Furthermore, it introduces the advanced technique of enforcing physical constraints, such as known boundary tractions, within the recovery framework using Lagrange multipliers.", "problem": "Consider planar linear elasticity and the Zienkiewicz-Zhu stress recovery procedure on a patch of elements surrounding an interior node at spatial position $\\mathbf{x}_{0} = (0,\\,0)$. You are given elementwise constant approximations of the normal stress component $\\sigma_{xx}$ evaluated at four sampling points in the patch:\n$\\mathbf{x}_{1} = (-1,\\,0)$ with $\\sigma_{xx}^{(1)} = -0.9$ (MPa),\n$\\mathbf{x}_{2} = (1,\\,0)$ with $\\sigma_{xx}^{(2)} = 5.2$ (MPa),\n$\\mathbf{x}_{3} = (0,\\,1)$ with $\\sigma_{xx}^{(3)} = 0.8$ (MPa),\n$\\mathbf{x}_{4} = (0,\\,-1)$ with $\\sigma_{xx}^{(4)} = 3.1$ (MPa).\nAssume a linear polynomial ansatz for the recovered stress component on the patch,\n$p(x,y) = a_{0} + a_{1}\\,x + a_{2}\\,y$,\nand use an unweighted least-squares fit over the given sampling points.\n\nTasks:\n(a) Explicitly construct the Vandermonde-like design matrix $A \\in \\mathbb{R}^{4 \\times 3}$ and the data vector $\\mathbf{s} \\in \\mathbb{R}^{4}$ for this patch and basis.\n(b) Starting from the least-squares principle, write the normal equations and solve for the coefficient vector $\\mathbf{a} = (a_{0},\\,a_{1},\\,a_{2})^{\\mathsf{T}}$.\n(c) Evaluate the recovered stress at the interior node, $p(0,0)$, and express your final numerical answer in MPa. Round your final answer to $4$ significant figures.\n(d) Now consider a boundary node patch on a straight boundary segment with known outward unit normal $\\mathbf{n} = (0,\\,1)$ and available boundary traction measurements $\\bar{\\mathbf{t}}(\\mathbf{x}) = (\\bar{t}_{x}(\\mathbf{x}),\\,\\bar{t}_{y}(\\mathbf{x}))$ at a finite set of boundary collocation points $\\{\\mathbf{x}_{b}^{(k)}\\}_{k=1}^{m_{b}}$. Suppose each independent stress component is approximated on the patch by a linear polynomial of the same form as $p$, namely\n$\\sigma_{xx}(x,y) = a_{xx,0} + a_{xx,1}\\,x + a_{xx,2}\\,y$, \n$\\sigma_{yy}(x,y) = a_{yy,0} + a_{yy,1}\\,x + a_{yy,2}\\,y$, \n$\\sigma_{xy}(x,y) = a_{xy,0} + a_{xy,1}\\,x + a_{xy,2}\\,y$.\nExplain, by constructing the constraint matrix explicitly, how to impose the traction conditions $\\sigma(\\mathbf{x})\\,\\mathbf{n} = \\bar{\\mathbf{t}}(\\mathbf{x})$ at the boundary collocation points via Lagrange multipliers, and write down the corresponding augmented Karush–Kuhn–Tucker linear system without solving it.\n\nYour final answer must be the single real value of $p(0,0)$ in MPa, rounded to $4$ significant figures as instructed.", "solution": "This solution addresses each task sequentially.\n\n(a) Explicitly construct the Vandermonde-like design matrix $A \\in \\mathbb{R}^{4 \\times 3}$ and the data vector $\\mathbf{s} \\in \\mathbb{R}^{4}$.\n\nThe recovered stress field is a linear polynomial of the form $p(x,y) = a_{0} + a_{1}x + a_{2}y$. This can be written as a product of a row vector of basis functions and a column vector of coefficients: $p(x,y) = \\begin{pmatrix} 1 & x & y \\end{pmatrix} \\begin{pmatrix} a_{0} \\\\ a_{1} \\\\ a_{2} \\end{pmatrix}$.\nThe least-squares problem seeks to find the coefficient vector $\\mathbf{a} = (a_{0}, a_{1}, a_{2})^{\\mathsf{T}}$ that minimizes the squared error between the polynomial evaluated at the sampling points and the given stress data. The system of equations for the four sampling points is $A\\mathbf{a} \\approx \\mathbf{s}$.\n\nThe design matrix $A$ is constructed by evaluating the basis functions at each of the four sampling points $\\mathbf{x}_{i} = (x_{i}, y_{i})$. The $i$-th row of $A$ is given by $(1, x_{i}, y_{i})$.\nThe given points are $\\mathbf{x}_{1} = (-1,0)$, $\\mathbf{x}_{2} = (1,0)$, $\\mathbf{x}_{3} = (0,1)$, and $\\mathbf{x}_{4} = (0,-1)$.\nThe resulting design matrix $A$ is:\n$$A = \\begin{pmatrix} 1 & -1 & 0 \\\\ 1 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 1 & 0 & -1 \\end{pmatrix}$$\nThe data vector $\\mathbf{s}$ consists of the given stress values $\\sigma_{xx}^{(i)}$ corresponding to each sampling point: $\\sigma_{xx}^{(1)} = -0.9$, $\\sigma_{xx}^{(2)} = 5.2$, $\\sigma_{xx}^{(3)} = 0.8$, and $\\sigma_{xx}^{(4)} = 3.1$.\nThe data vector $\\mathbf{s}$ is:\n$$\\mathbf{s} = \\begin{pmatrix} -0.9 \\\\ 5.2 \\\\ 0.8 \\\\ 3.1 \\end{pmatrix}$$\n\n(b) Starting from the least-squares principle, write the normal equations and solve for the coefficient vector $\\mathbf{a}$.\n\nThe unweighted least-squares principle seeks to minimize the squared Euclidean norm of the residual vector, $J(\\mathbf{a}) = \\|\\mathbf{r}\\|_{2}^{2} = \\|\\mathbf{s} - A\\mathbf{a}\\|_{2}^{2}$. The minimum is found where the gradient of $J$ with respect to $\\mathbf{a}$ is zero: $\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\mathbf{0}$.\nCalculating the gradient:\n$\\nabla_{\\mathbf{a}} \\left( (\\mathbf{s} - A\\mathbf{a})^{\\mathsf{T}} (\\mathbf{s} - A\\mathbf{a}) \\right) = \\nabla_{\\mathbf{a}} \\left( \\mathbf{s}^{\\mathsf{T}}\\mathbf{s} - 2\\mathbf{s}^{\\mathsf{T}}A\\mathbf{a} + \\mathbf{a}^{\\mathsf{T}}A^{\\mathsf{T}}A\\mathbf{a} \\right) = -2A^{\\mathsf{T}}\\mathbf{s} + 2A^{\\mathsf{T}}A\\mathbf{a}$.\nSetting the gradient to zero yields the normal equations:\n$$A^{\\mathsf{T}}A\\mathbf{a} = A^{\\mathsf{T}}\\mathbf{s}$$\nWe compute the matrix $A^{\\mathsf{T}}A$ and the vector $A^{\\mathsf{T}}\\mathbf{s}$.\n$$A^{\\mathsf{T}} = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix}$$\n$$A^{\\mathsf{T}}A = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & -1 & 0 \\\\ 1 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 1 & 0 & -1 \\end{pmatrix} = \\begin{pmatrix} 1+1+1+1 & -1+1+0+0 & 0+0+1-1 \\\\ -1+1+0+0 & 1+1+0+0 & 0+0+0+0 \\\\ 0+0+1-1 & 0+0+0+0 & 0+0+1+1 \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix}$$\nThe orthogonality of the columns in a sense of dot product weighted by the sampling points leads to a diagonal matrix, which simplifies the solution.\n$$A^{\\mathsf{T}}\\mathbf{s} = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} -0.9 \\\\ 5.2 \\\\ 0.8 \\\\ 3.1 \\end{pmatrix} = \\begin{pmatrix} (-0.9) + 5.2 + 0.8 + 3.1 \\\\ -(-0.9) + 5.2 \\\\ 0.8 - 3.1 \\end{pmatrix} = \\begin{pmatrix} 8.2 \\\\ 6.1 \\\\ -2.3 \\end{pmatrix}$$\nThe normal equations are thus:\n$$\\begin{pmatrix} 4 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix} \\begin{pmatrix} a_{0} \\\\ a_{1} \\\\ a_{2} \\end{pmatrix} = \\begin{pmatrix} 8.2 \\\\ 6.1 \\\\ -2.3 \\end{pmatrix}$$\nSolving this diagonal system gives the coefficients:\n$4a_{0} = 8.2 \\implies a_{0} = \\frac{8.2}{4} = 2.05$\n$2a_{1} = 6.1 \\implies a_{1} = \\frac{6.1}{2} = 3.05$\n$2a_{2} = -2.3 \\implies a_{2} = \\frac{-2.3}{2} = -1.15$\nThe coefficient vector is $\\mathbf{a} = (2.05, 3.05, -1.15)^{\\mathsf{T}}$.\n\n(c) Evaluate the recovered stress at the interior node, $p(0,0)$.\n\nThe recovered stress at the node position $\\mathbf{x}_{0} = (0,0)$ is found by evaluating the polynomial $p(x,y)$ at these coordinates.\n$$p(0,0) = a_{0} + a_{1}(0) + a_{2}(0) = a_{0}$$\nFrom the previous step, $a_{0} = 2.05$. The units are Megapascals (MPa). Rounding to $4$ significant figures, the result is $2.050$ MPa.\n\n(d) Explain how to impose traction conditions via Lagrange multipliers.\n\nIn this scenario, we perform a least-squares fit for all three independent stress components ($\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}$) subject to linear constraints imposed by known boundary tractions. Let the complete set of unknown coefficients be $\\mathbf{\\alpha} \\in \\mathbb{R}^{9}$:\n$$\\mathbf{\\alpha} = (a_{xx,0}, a_{xx,1}, a_{xx,2}, \\,\\,\\, a_{yy,0}, a_{yy,1}, a_{yy,2}, \\,\\,\\, a_{xy,0}, a_{xy,1}, a_{xy,2})^{\\mathsf{T}}$$\nThe traction vector $\\mathbf{t}$ on a surface with outward unit normal $\\mathbf{n}$ is given by $\\mathbf{t} = \\sigma \\mathbf{n}$. For $\\mathbf{n} = (0, 1)^{\\mathsf{T}}$, this becomes:\n$$\\mathbf{t} = \\begin{pmatrix} t_{x} \\\\ t_{y} \\end{pmatrix} = \\begin{pmatrix} \\sigma_{xx} & \\sigma_{xy} \\\\ \\sigma_{xy} & \\sigma_{yy} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\sigma_{xy} \\\\ \\sigma_{yy} \\end{pmatrix}$$\nThese tractions must equal the measured tractions $\\bar{\\mathbf{t}}(\\mathbf{x}) = (\\bar{t}_{x}(\\mathbf{x}), \\bar{t}_{y}(\\mathbf{x}))^{\\mathsf{T}}$ at a set of $m_{b}$ boundary collocation points $\\{\\mathbf{x}_{b}^{(k)}\\}_{k=1}^{m_{b}}$. For each point $\\mathbf{x}_{b}^{(k)} = (x_{b}^{(k)}, y_{b}^{(k)})$, we have two linear constraints on $\\mathbf{\\alpha}$:\n$$ \\sigma_{xy}(x_{b}^{(k)}, y_{b}^{(k)}) = a_{xy,0} + a_{xy,1}x_{b}^{(k)} + a_{xy,2}y_{b}^{(k)} = \\bar{t}_{x}(\\mathbf{x}_{b}^{(k)}) $$\n$$ \\sigma_{yy}(x_{b}^{(k)}, y_{b}^{(k)}) = a_{yy,0} + a_{yy,1}x_{b}^{(k)} + a_{yy,2}y_{b}^{(k)} = \\bar{t}_{y}(\\mathbf{x}_{b}^{(k)}) $$\nThese $2m_{b}$ constraints can be written in matrix form $C\\mathbf{\\alpha} = \\mathbf{d}$, where $C$ is a $(2m_{b}) \\times 9$ matrix and $\\mathbf{d}$ is a $(2m_{b}) \\times 1$ vector.\nLet $\\mathbf{p}_{k} = (1, x_{b}^{(k)}, y_{b}^{(k)})$. The pair of rows in $C$ corresponding to point $\\mathbf{x}_{b}^{(k)}$ is:\n$$ C_{(2k-1, \\cdot)} = \\begin{pmatrix} 0 & 0 & 0 & 0 & 0 & 0 & 1 & x_{b}^{(k)} & y_{b}^{(k)} \\end{pmatrix} $$\n$$ C_{(2k, \\cdot)} = \\begin{pmatrix} 0 & 0 & 0 & 1 & x_{b}^{(k)} & y_{b}^{(k)} & 0 & 0 & 0 \\end{pmatrix} $$\nThe right-hand side vector is $\\mathbf{d} = (\\bar{t}_{x}(\\mathbf{x}_{b}^{(1)}), \\bar{t}_{y}(\\mathbf{x}_{b}^{(1)}), \\dots, \\bar{t}_{x}(\\mathbf{x}_{b}^{(m_{b})}), \\bar{t}_{y}(\\mathbf{x}_{b}^{(m_{b})}))^{\\mathsf{T}}$.\nThe optimization problem is to minimize the least-squares functional for the interior sampling points, $\\frac{1}{2}\\|A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full}\\|^{2}$, subject to $C\\mathbf{\\alpha}=\\mathbf{d}$. Using the method of Lagrange multipliers, we introduce a vector of multipliers $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2m_{b}}$ and form the Lagrangian:\n$$ \\mathcal{L}(\\mathbf{\\alpha}, \\boldsymbol{\\lambda}) = \\frac{1}{2}(A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full})^{\\mathsf{T}}(A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full}) + \\boldsymbol{\\lambda}^{\\mathsf{T}}(C\\mathbf{\\alpha} - \\mathbf{d}) $$\nThe Karush-Kuhn-Tucker (KKT) conditions for an optimum are $\\nabla_{\\mathbf{\\alpha}}\\mathcal{L} = \\mathbf{0}$ and $\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L} = \\mathbf{0}$, which yield:\n$$ (A_{full}^{\\mathsf{T}}A_{full})\\mathbf{\\alpha} + C^{\\mathsf{T}}\\boldsymbol{\\lambda} = A_{full}^{\\mathsf{T}}\\mathbf{s}_{full} $$\n$$ C\\mathbf{\\alpha} = \\mathbf{d} $$\nLet $K = A_{full}^{\\mathsf{T}}A_{full}$ and $\\mathbf{f} = A_{full}^{\\mathsf{T}}\\mathbf{s}_{full}$. The augmented KKT linear system is:\n$$ \\begin{pmatrix} K & C^{\\mathsf{T}} \\\\ C & \\mathbf{0} \\end{pmatrix} \\begin{pmatrix} \\mathbf{\\alpha} \\\\ \\boldsymbol{\\lambda} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f} \\\\ \\mathbf{d} \\end{pmatrix} $$\nHere, $K$ is the block-diagonal matrix arising from the unconstrained least-squares fit over the interior element sampling points, and $\\mathbf{f}$ is the corresponding right-hand side vector. This symmetric but indefinite system can be solved for the coefficients $\\mathbf{\\alpha}$ and the multipliers $\\boldsymbol{\\lambda}$.", "answer": "$$\\boxed{2.050}$$", "id": "2612978"}, {"introduction": "The ultimate purpose of an error estimator is to provide a reliable, computable measure of the unknown true error in a finite element solution. The ZZ estimator is validated using the \"effectivity index,\" $\\theta^h$, the ratio of the estimated error to the true error. This coding practice tasks you with implementing a complete finite element analysis for a problem with a known analytical solution, allowing for direct comparison of your implemented ZZ estimator against the true error [@problem_id:2613010]. By computing $\\theta^h$ across successive mesh refinements and for different material properties, you will verify the asymptotic exactness of the ZZ estimator (i.e., $\\theta^h \\to 1$) and assess its robustness, a critical skill for any practitioner of computational mechanics.", "problem": "Consider small-strain, linear, isotropic elasticity in plane strain on the square domain $\\Omega = [0,1] \\times [0,1]$. Let the exact displacement field be prescribed by the manufactured solution\n$$\n\\mathbf{u}^{\\mathrm{ex}}(x,y) = \\begin{bmatrix} \\sin(\\pi x)\\sin(\\pi y) \\\\ \\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nAssume the Lamé parameters $\\lambda$ and $\\mu$ derived from Young’s modulus $E$ and Poisson’s ratio $\\nu$ via\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n$$\nIn plane strain, the Cauchy stress tensor $\\boldsymbol{\\sigma}$ is related to the small strain tensor $\\boldsymbol{\\varepsilon}$ by Hooke’s law\n$$\n\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I},\n$$\nwith $\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$. Let body forces be chosen to enforce equilibrium for the exact displacement, i.e.,\n$$\n\\mathbf{b}(x,y) = (\\lambda + \\mu)\\,\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) + \\mu\\,\\Delta \\mathbf{u}^{\\mathrm{ex}},\n$$\nso that the strong form $-\\nabla \\cdot \\boldsymbol{\\sigma}(\\mathbf{u}) = \\mathbf{b}$ holds exactly for $\\mathbf{u} = \\mathbf{u}^{\\mathrm{ex}}$. Impose Dirichlet boundary conditions $\\mathbf{u} = \\mathbf{u}^{\\mathrm{ex}}$ on $\\partial \\Omega$.\n\nDiscretize $\\Omega$ by a uniform mesh of bilinear quadrilateral elements ($Q_4$), with $n \\times n$ elements, $n \\in \\mathbb{N}$. Let $\\mathbf{u}^h$ denote the finite element solution obtained with $2 \\times 2$ Gauss quadrature for stiffness and load assembly. Construct the Zienkiewicz–Zhu (ZZ) recovered stress field $\\boldsymbol{\\sigma}^*$ as follows:\n- Compute the finite element stress $\\boldsymbol{\\sigma}^h$ at Gauss points in each element.\n- For each mesh node, form a patch consisting of all elements sharing that node. Using all Gauss-point samples $(x_k,y_k,\\boldsymbol{\\sigma}^h(x_k,y_k))$ in the patch, compute, for each stress component, a least-squares fit to a linear polynomial in the spatial coordinates, namely $s(x,y) \\approx a_0 + a_1 x + a_2 y$. Evaluate this fit at the node to obtain the recovered nodal stresses.\n- Interpolate the recovered nodal stresses within each element using the bilinear finite element shape functions to obtain $\\boldsymbol{\\sigma}^*$ at Gauss points.\n\nDefine the energy-norm of the error and the ZZ error estimator by\n$$\n\\| e^h \\|_E^2 = \\int_{\\Omega} \\left( \\boldsymbol{\\sigma}(\\mathbf{u}^{\\mathrm{ex}}) - \\boldsymbol{\\sigma}^h \\right)^{\\top} \\mathbf{D}^{-1} \\left( \\boldsymbol{\\sigma}(\\mathbf{u}^{\\mathrm{ex}}) - \\boldsymbol{\\sigma}^h \\right)\\, \\mathrm{d}\\Omega,\n$$\n$$\n\\eta^h_2 = \\int_{\\Omega} \\left( \\boldsymbol{\\sigma}^* - \\boldsymbol{\\sigma}^h \\right)^{\\top} \\mathbf{D}^{-1} \\left( \\boldsymbol{\\sigma}^* - \\boldsymbol{\\sigma}^h \\right)\\, \\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{D}$ is the plane-strain constitutive matrix in Voigt notation acting on the vector $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^{\\top}$ with $\\gamma_{xy} = 2 \\varepsilon_{xy}$. The effectivity index is\n$$\n\\theta^h = \\frac{\\eta^h}{\\| e^h \\|_E}.\n$$\nYour task is to:\n1. Implement the described finite element method (FEM) and Zienkiewicz–Zhu (ZZ) stress recovery to compute $\\theta^h$ for successive uniform refinements.\n2. Use $E = 1$ and the following test suite of Poisson ratios and mesh resolutions:\n   - Case A (typical compressible): $\\nu = 0.30$, $n \\in \\{2, 4, 8, 16\\}$,\n   - Case B (nearly incompressible): $\\nu = 0.49$, $n \\in \\{4, 8\\}$,\n   - Case C (low Poisson’s ratio): $\\nu = 0.00$, $n \\in \\{4, 8, 16\\}$.\n3. For each pair $(\\nu, n)$, compute the effectivity index $\\theta^h$ using numerical quadrature consistent with the finite element formulation.\n\nThe final program output should be a single line containing a Python-like list of all computed $\\theta^h$ values, ordered as\n$$\n[\\theta^h(\\nu=0.30, n=2), \\theta^h(\\nu=0.30, n=4), \\theta^h(\\nu=0.30, n=8), \\theta^h(\\nu=0.30, n=16), \\theta^h(\\nu=0.49, n=4), \\theta^h(\\nu=0.49, n=8), \\theta^h(\\nu=0.00, n=4), \\theta^h(\\nu=0.00, n=8), \\theta^h(\\nu=0.00, n=16)].\n$$\nAll values must be printed as floating-point numbers in a single list, with no additional text. No physical unit is required for the final output since $\\theta^h$ is dimensionless. Angles, if any, must be in radians.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r_1,r_2,\\dots,r_9]\").", "solution": "We proceed with a formal solution to the problem, which has been validated as scientifically sound and complete.\n\nThe problem requires the implementation of a finite element method (FEM) for $2$-dimensional, linear, isotropic elasticity under plane strain conditions. We are given a manufactured solution for the displacement field $\\mathbf{u}^{\\mathrm{ex}}$ on the unit square domain $\\Omega = [0,1] \\times [0,1]$. This exact solution is\n$$\n\\mathbf{u}^{\\mathrm{ex}}(x,y) = \\begin{bmatrix} u^{\\mathrm{ex}}(x,y) \\\\ v^{\\mathrm{ex}}(x,y) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\pi x)\\sin(\\pi y) \\\\ \\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nThe material is defined by Young's modulus $E$ and Poisson's ratio $\\nu$, from which the Lamé parameters $\\lambda$ and $\\mu$ are derived. The constitutive relation, or Hooke's Law, is given by $\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\boldsymbol{\\varepsilon}$ is the small strain tensor, $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$.\n\nIn Voigt notation, with stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$ and strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$ (where $\\gamma_{xy} = 2\\varepsilon_{xy}$), the constitutive law is $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$. The plane strain constitutive matrix $\\mathbf{D}$ is\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n    \\lambda+2\\mu & \\lambda & 0 \\\\\n    \\lambda & \\lambda+2\\mu & 0 \\\\\n    0 & 0 & \\mu\n\\end{bmatrix}\n= \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n    1-\\nu & \\nu & 0 \\\\\n    \\nu & 1-\\nu & 0 \\\\\n    0 & 0 & (1-2\\nu)/2\n\\end{bmatrix}.\n$$\nThe governing equation is the equilibrium equation $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{b}$, where the body force $\\mathbf{b}$ is specifically chosen to be satisfied by $\\mathbf{u}^{\\mathrm{ex}}$. From the given expression $\\mathbf{b} = (\\lambda + \\mu)\\,\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) + \\mu\\,\\Delta \\mathbf{u}^{\\mathrm{ex}}$, we derive the components of the body force. The divergence of $\\mathbf{u}^{\\mathrm{ex}}$ is $\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}} = \\pi \\sin(\\pi(x+y))$. Its gradient is $\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) = [\\pi^2 \\cos(\\pi(x+y)), \\pi^2 \\cos(\\pi(x+y))]^{\\top}$. The Laplacian of each displacement component is $\\Delta u^{\\mathrm{ex}} = \\Delta v^{\\mathrm{ex}} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$. Thus, the body force vector is\n$$\n\\mathbf{b}(x,y) = \\begin{bmatrix} (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y)) - 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) \\\\ (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y)) - 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nThe domain is discretized into a uniform $n \\times n$ mesh of bilinear quadrilateral ($Q_4$) elements. The finite element solution $\\mathbf{u}^h$ is found by solving the linear system $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$, resulting from the Galerkin weak form of the governing equations. The element stiffness matrix $\\mathbf{K}^e$ and load vector $\\mathbf{F}^e$ are computed via numerical integration using $2 \\times 2$ Gauss quadrature:\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega, \\quad \\mathbf{F}^e = \\int_{\\Omega_e} \\mathbf{N}^{\\top} \\mathbf{b} \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix and $\\mathbf{N}$ is the shape function matrix. Dirichlet boundary conditions $\\mathbf{u}^h = \\mathbf{u}^{\\mathrm{ex}}$ are strongly enforced on all boundaries $\\partial \\Omega$.\n\nAfter obtaining the nodal displacements $\\mathbf{U}$, the finite element stress tensor $\\boldsymbol{\\sigma}^h$ is computed at the Gauss points of each element. The Zienkiewicz-Zhu (ZZ) stress recovery procedure is then applied to obtain a more accurate, continuous stress field $\\boldsymbol{\\sigma}^*$. For each node in the mesh, a patch of elements connected to that node is formed. The stress values $\\boldsymbol{\\sigma}^h$ at all Gauss points within this patch are collected. A least-squares fit to a linear polynomial $s(x,y) = a_0 + a_1 x + a_2 y$ is performed for each stress component. The recovered stress at the node is then the value of this polynomial evaluated at the nodal coordinates. This yields a set of recovered stresses at all nodes. The field $\\boldsymbol{\\sigma}^*$ is then defined within each element by interpolating these recovered nodal values using the same bilinear shape functions.\n\nFinally, we compute the energy norm of the true error, $\\| e^h \\|_E$, and the ZZ error estimator, $\\eta^h$. Their squared values are given by:\n$$\n\\| e^h \\|_E^2 = \\int_{\\Omega} (\\boldsymbol{\\sigma}^{\\mathrm{ex}} - \\boldsymbol{\\sigma}^h)^{\\top} \\mathbf{D}^{-1} (\\boldsymbol{\\sigma}^{\\mathrm{ex}} - \\boldsymbol{\\sigma}^h) \\, \\mathrm{d}\\Omega,\n$$\n$$\n(\\eta^h)^2 = \\int_{\\Omega} (\\boldsymbol{\\sigma}^* - \\boldsymbol{\\sigma}^h)^{\\top} \\mathbf{D}^{-1} (\\boldsymbol{\\sigma}^* - \\boldsymbol{\\sigma}^h) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\boldsymbol{\\sigma}^{\\mathrm{ex}}$ is the exact stress derived from $\\mathbf{u}^{\\mathrm{ex}}$, and the inverse constitutive matrix is\n$$\n\\mathbf{D}^{-1} = \\frac{1+\\nu}{E}\n\\begin{bmatrix}\n    1-\\nu & -\\nu & 0 \\\\\n    -\\nu & 1-\\nu & 0 \\\\\n    0 & 0 & 2\n\\end{bmatrix}.\n$$\nThe integrals for the error and the estimator are computed numerically using the same $2 \\times 2$ Gauss quadrature. The quality of the estimator is assessed by the effectivity index $\\theta^h = \\eta^h / \\| e^h \\|_E$. A value of $\\theta^h$ close to $1$ indicates an effective error estimator. The following implementation carries out this entire procedure for the specified test cases.", "answer": "```python\nimport numpy as np\n\ndef compute_effectivity(n, nu):\n    \"\"\"\n    Computes the effectivity index for a given mesh resolution n and Poisson's ratio nu.\n    \"\"\"\n    E = 1.0\n    PI = np.pi\n\n    # --- 1. Material and Exact Solution Definition ---\n    if np.isclose(nu, 0.5): # Avoid singularity\n        # This case is not in the test suite but is a necessary check.\n        lam = 0.0 # Placeholder, should not be used\n    else:\n        lam = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    D = np.array([\n        [lam + 2 * mu, lam, 0],\n        [lam, lam + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    \n    D_inv = (1 + nu) / E * np.array([\n        [1 - nu, -nu, 0],\n        [-nu, 1 - nu, 0],\n        [0, 0, 2]\n    ])\n\n    def u_exact(x, y):\n        val = np.sin(PI * x) * np.sin(PI * y)\n        return np.array([val, val])\n\n    def strain_exact(x, y):\n        exx = PI * np.cos(PI * x) * np.sin(PI * y)\n        eyy = PI * np.sin(PI * x) * np.cos(PI * y)\n        gxy = PI * np.sin(PI * (x + y))\n        return np.array([exx, eyy, gxy])\n    \n    def body_force(x, y):\n        f_val = (lam + mu) * PI**2 * np.cos(PI * (x + y)) - 2 * mu * PI**2 * np.sin(PI * x) * np.sin(PI * y)\n        return np.array([f_val, f_val])\n\n    # --- 2. Mesh Generation ---\n    num_nodes = (n + 1) * (n + 1)\n    num_elems = n * n\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(n + 1):\n        for i in range(n + 1):\n            node_idx = j * (n + 1) + i\n            node_coords[node_idx] = [i / n, j / n]\n            \n    elem_nodes = np.zeros((num_elems, 4), dtype=int)\n    for j in range(n):\n        for i in range(n):\n            elem_idx = j * n + i\n            n0 = j * (n + 1) + i\n            n1 = j * (n + 1) + i + 1\n            n2 = (j + 1) * (n + 1) + i + 1\n            n3 = (j + 1) * (n + 1) + i\n            elem_nodes[elem_idx] = [n0, n1, n2, n3]\n\n    # --- 3. FEM Assembly ---\n    gp_loc = 1.0 / np.sqrt(3)\n    gauss_points = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    def shape_functions(xi, eta):\n        return 0.25 * np.array([\n            (1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)\n        ])\n\n    def shape_derivatives(xi, eta):\n        return 0.25 * np.array([\n            [-(1-eta),  (1-eta),  (1+eta), -(1+eta)],  # dN/dxi\n            [-(1-xi), -(1+xi),  (1+xi),   (1-xi)]   # dN/deta\n        ])\n\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n\n    # Store Gauss point coordinates and FE stresses for all elements\n    gauss_pt_coords = np.zeros((num_elems, 4, 2))\n    \n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        \n        Ke = np.zeros((8, 8))\n        Fe = np.zeros(8)\n        \n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[gp_idx]\n            N_vec = shape_functions(xi, eta)\n            dN_dxi_eta = shape_derivatives(xi, eta)\n            \n            J = dN_dxi_eta @ el_node_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            dN_dx_dy = invJ @ dN_dxi_eta\n            \n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2*i] = dN_dx_dy[0, i]\n                B[1, 2*i+1] = dN_dx_dy[1, i]\n                B[2, 2*i] = dN_dx_dy[1, i]\n                B[2, 2*i+1] = dN_dx_dy[0, i]\n                \n            Ke += B.T @ D @ B * detJ * w\n            \n            x_gp, y_gp = N_vec @ el_node_coords\n            gauss_pt_coords[e_idx, gp_idx, :] = [x_gp, y_gp]\n            \n            b_vec = body_force(x_gp, y_gp)\n            N_mat = np.zeros((2, 8))\n            for i in range(4):\n                N_mat[0, 2*i] = N_vec[i]\n                N_mat[1, 2*i+1] = N_vec[i]\n            \n            Fe += N_mat.T @ b_vec * detJ * w\n            \n        dof_map = np.array([[2*nid, 2*nid+1] for nid in el_node_ids]).flatten()\n        K[np.ix_(dof_map, dof_map)] += Ke\n        F[dof_map] += Fe\n    \n    # --- 4. Boundary Conditions ---\n    boundary_nodes = []\n    for i in range(n + 1):\n        boundary_nodes.extend([i, i*(n+1), i*(n+1)+n, n*(n+1)+i])\n    boundary_nodes = sorted(list(set(boundary_nodes)))\n\n    boundary_dofs = []\n    u_bc_vals = {}\n    for node_idx in boundary_nodes:\n        x, y = node_coords[node_idx]\n        u, v = u_exact(x, y)\n        dof_x, dof_y = 2 * node_idx, 2 * node_idx + 1\n        boundary_dofs.extend([dof_x, dof_y])\n        u_bc_vals[dof_x] = u\n        u_bc_vals[dof_y] = v\n    boundary_dofs = sorted(list(set(boundary_dofs)))\n\n    active_dofs = list(set(range(num_dofs)) - set(boundary_dofs))\n    \n    F_mod = F[active_dofs] - K[np.ix_(active_dofs, boundary_dofs)] @ [u_bc_vals[d] for d in boundary_dofs]\n    K_mod = K[np.ix_(active_dofs, active_dofs)]\n\n    # --- 5. Solve ---\n    U_h = np.zeros(num_dofs)\n    U_h[active_dofs] = np.linalg.solve(K_mod, F_mod)\n    for dof in boundary_dofs:\n        U_h[dof] = u_bc_vals[dof]\n\n    # --- 6. Compute FE Stresses ---\n    gauss_stresses_h = np.zeros((num_elems, 4, 3))\n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        dof_map = np.array([[2*nid, 2*nid+1] for nid in el_node_ids]).flatten()\n        U_e = U_h[dof_map]\n        \n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            dN_dxi_eta = shape_derivatives(xi, eta)\n            J = dN_dxi_eta @ el_node_coords\n            invJ = np.linalg.inv(J)\n            dN_dx_dy = invJ @ dN_dxi_eta\n            \n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2 * i] = dN_dx_dy[0, i]\n                B[1, 2 * i + 1] = dN_dx_dy[1, i]\n                B[2, 2 * i] = dN_dx_dy[1, i]\n                B[2, 2 * i + 1] = dN_dx_dy[0, i]\n\n            strain_h = B @ U_e\n            stress_h = D @ strain_h\n            gauss_stresses_h[e_idx, gp_idx, :] = stress_h\n\n    # --- 7. Zienkiewicz-Zhu Recovery ---\n    node_patches = [[] for _ in range(num_nodes)]\n    for e_idx, nodes in enumerate(elem_nodes):\n        for node_id in nodes:\n            node_patches[node_id].append(e_idx)\n\n    sigma_star_nodal = np.zeros((num_nodes, 3))\n    for node_idx in range(num_nodes):\n        patch_elems = node_patches[node_idx]\n        patch_coords = []\n        patch_stresses = []\n        for e_idx in patch_elems:\n            patch_coords.extend(gauss_pt_coords[e_idx, :, :])\n            patch_stresses.extend(gauss_stresses_h[e_idx, :, :])\n        \n        patch_coords = np.array(patch_coords)\n        patch_stresses = np.array(patch_stresses)\n        \n        A = np.c_[np.ones(patch_coords.shape[0]), patch_coords]\n        \n        for comp in range(3):\n            s = patch_stresses[:, comp]\n            coeffs = np.linalg.lstsq(A, s, rcond=None)[0]\n            xn, yn = node_coords[node_idx]\n            sigma_star_nodal[node_idx, comp] = coeffs[0] + coeffs[1] * xn + coeffs[2] * yn\n\n    # --- 8. Error and Estimator Calculation ---\n    error_sq_sum = 0.0\n    estimator_sq_sum = 0.0\n    \n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        nodal_sigma_star = sigma_star_nodal[el_node_ids]\n\n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[gp_idx]\n            N_vec = shape_functions(xi, eta)\n            \n            J = shape_derivatives(xi, eta) @ el_node_coords\n            detJ = np.linalg.det(J)\n            \n            x_gp, y_gp = gauss_pt_coords[e_idx, gp_idx]\n            \n            sigma_h = gauss_stresses_h[e_idx, gp_idx, :]\n            \n            strain_ex = strain_exact(x_gp, y_gp)\n            sigma_ex = D @ strain_ex\n            \n            sigma_star = N_vec @ nodal_sigma_star\n            \n            diff_err = sigma_ex - sigma_h\n            diff_est = sigma_star - sigma_h\n            \n            error_sq_sum += (diff_err.T @ D_inv @ diff_err) * detJ * w\n            estimator_sq_sum += (diff_est.T @ D_inv @ diff_est) * detJ * w\n\n    return np.sqrt(estimator_sq_sum) / np.sqrt(error_sq_sum)\n\n\ndef solve():\n    test_cases = [\n        (0.30, 2), (0.30, 4), (0.30, 8), (0.30, 16),\n        (0.49, 4), (0.49, 8),\n        (0.00, 4), (0.00, 8), (0.00, 16)\n    ]\n\n    results = []\n    for nu, n in test_cases:\n        theta_h = compute_effectivity(n, nu)\n        results.append(theta_h)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2613010"}]}