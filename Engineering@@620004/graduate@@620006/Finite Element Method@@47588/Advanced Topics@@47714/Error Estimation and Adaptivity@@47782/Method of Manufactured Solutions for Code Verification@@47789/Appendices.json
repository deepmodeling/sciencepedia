{"hands_on_practices": [{"introduction": "A powerful first step in code verification is to test whether your numerical scheme can exactly represent a simple class of functions. This exercise leverages a key property of the standard second-order finite difference approximation of the Laplacian: it is exact for any quadratic polynomial. By manufacturing a solution that is a quadratic polynomial, you create a test case where the computed numerical solution should match the exact solution to within machine precision [@problem_id:2444972]. This provides an unambiguous check on the fundamental implementation of your solver, as any significant error points directly to a bug.", "problem": "Consider the two-dimensional Poisson problem on the unit square domain $\\Omega = [0,1] \\times [0,1]$ with Dirichlet boundary conditions. You are to apply the method of manufactured solutions for code verification as follows. Let the manufactured solution be the quadratic polynomial\n$$\nu_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,\n$$\nwhere $a$, $b$, $c$, $d$, $e$, and $f$ are real constants. Define the source term $s(x,y)$ so that $u_m$ exactly satisfies the Poisson equation with a negative Laplacian,\n$$\n- \\Delta u(x,y) = s(x,y) \\quad \\text{in } \\Omega,\n$$\ntogether with Dirichlet boundary conditions\n$$\nu(x,y) = u_m(x,y) \\quad \\text{for } (x,y) \\in \\partial \\Omega.\n$$\nDiscretize $- \\Delta$ using the standard second-order central finite difference scheme on a uniform Cartesian grid with $N$ interior nodes in each spatial direction and grid spacing $h = \\frac{1}{N+1}$. Let the interior grid points be $\\{(x_i,y_j)\\}_{i,j=1}^N$ with $x_i = i h$ and $y_j = j h$. The discrete interior equations to be enforced are, for each interior node $(i,j)$,\n$$\n\\frac{-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j}}{h^2} = s(x_i,y_j),\n$$\nwith Dirichlet boundary values prescribed from $u_m$ on $\\partial \\Omega$. Here $u_{i,j}$ denotes the discrete approximation to $u(x_i,y_j)$.\n\nFor each test case below, compute the discrete solution on the full grid including boundary nodes and then report the maximum absolute nodal error\n$$\nE_\\infty = \\max_{0 \\le i \\le N+1,\\; 0 \\le j \\le N+1} \\left| u_{i,j} - u_m(x_i,y_j) \\right|.\n$$\nThere are no physical units involved. All angles, if any arise, must be interpreted in radians, but none are required here.\n\nTest suite (each case is $(N, a, b, c, d, e, f)$):\n- Case $1$: $(\\,10,\\, 1.0,\\, 0.5,\\, 2.0,\\, -1.0,\\, 0.25,\\, -0.75\\,)$\n- Case $2$: $(\\,15,\\, 0.0,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.0\\,)$\n- Case $3$: $(\\,8,\\, 0.0,\\, 0.0,\\, 0.0,\\, -2.0,\\, 1.5,\\, 0.1\\,)$\n- Case $4$: $(\\,12,\\, -0.7,\\, 0.0,\\, 0.4,\\, 0.0,\\, 0.0,\\, 2.0\\,)$\n\nYour program must compute $E_\\infty$ for each case, in the order listed above, and produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example \"[$r_1$,$r_2$,$r_3$,$r_4$]\". Each $r_k$ must be a floating-point number. No other output is permitted.", "solution": "The user has provided a problem in computational engineering that requires the application of the Method of Manufactured Solutions (MMS) for code verification. The task is to compute the maximum nodal error of a finite difference solution to the 2D Poisson equation, where the exact solution is a chosen manufactured polynomial.\n\n**Problem Validation**\n\nFirst, I must subject the problem to rigorous validation.\n\n**Step 1: Extract Givens**\n- **Governing Equation**: 2D Poisson equation $-\\Delta u(x,y) = s(x,y)$ on $\\Omega = [0,1] \\times [0,1]$.\n- **Manufactured Solution**: $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$.\n- **Source Term**: $s(x,y)$ derived from $-\\Delta u_m(x,y)$.\n- **Boundary Conditions**: Dirichlet, $u(x,y) = u_m(x,y)$ on $\\partial \\Omega$.\n- **Discretization**: Second-order central finite difference scheme on a uniform grid.\n- **Grid**: $N$ interior nodes in each direction, spacing $h = 1/(N+1)$. Grid points $(x_i, y_j) = (ih, jh)$.\n- **Discrete Equation**: $\\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = s(x_i,y_j)$ for interior nodes $i,j \\in \\{1, \\dots, N\\}$.\n- **Error Metric**: $E_\\infty = \\max_{0 \\le i,j \\le N+1} | u_{i,j} - u_m(x_i,y_j) |$.\n- **Test Cases**: Four sets of parameters $(N, a, b, c, d, e, f)$ are provided.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is fundamentally sound. It uses the Poisson equation, the Method of Manufactured Solutions, and the finite difference method, all of which are standard concepts in numerical analysis and computational engineering.\n- **Well-Posedness**: The problem is well-posed. The Poisson equation with Dirichlet conditions has a unique solution. The corresponding linear system from the finite difference discretization is non-singular and also has a unique solution. The request to compute the error is a standard procedure in code verification.\n- **Objectivity**: The problem is stated using precise, objective mathematical language, with no ambiguity or subjective elements.\n\nThe problem is self-contained, consistent, and scientifically valid. All necessary information is provided.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the solution.\n\n**Principle-Based Solution Design**\n\nThe core of this problem lies in understanding the truncation error of the finite difference scheme. The method of manufactured solutions is specifically designed to test a code's implementation by providing a problem for which the exact solution is known.\n\n1.  **Derivation of the Source Term**:\n    The manufactured solution is $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$. We must first compute its Laplacian to define the source term $s(x,y) = -\\Delta u_m(x,y)$.\n    The partial derivatives are:\n    $\\frac{\\partial u_m}{\\partial x} = 2ax + by + d$\n    $\\frac{\\partial^2 u_m}{\\partial x^2} = 2a$\n    $\\frac{\\partial u_m}{\\partial y} = bx + 2cy + e$\n    $\\frac{\\partial^2 u_m}{\\partial y^2} = 2c$\n    The Laplacian is $\\Delta u_m = \\frac{\\partial^2 u_m}{\\partial x^2} + \\frac{\\partial^2 u_m}{\\partial y^2} = 2a + 2c$.\n    Therefore, the source term is a constant: $s(x,y) = -(2a + 2c)$.\n\n2.  **Analysis of Truncation Error**:\n    The discrete operator for the negative Laplacian is $L_h u_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}$.\n    The truncation error $\\tau$ of this operator is given by $\\tau = L_h u - (-\\Delta u)$. For a sufficiently smooth function $u$, Taylor series expansions show that $\\tau = -\\frac{h^2}{12}(\\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4}) + \\mathcal{O}(h^4)$.\n    The scheme is second-order accurate. However, for our specific manufactured solution $u_m(x,y)$, which is a quadratic polynomial, all partial derivatives of order three or higher are identically zero.\n    Specifically, $\\frac{\\partial^4 u_m}{\\partial x^4} = 0$ and $\\frac{\\partial^4 u_m}{\\partial y^4} = 0$.\n    This implies that the leading term of the truncation error is zero. In fact, all higher-order terms are also zero. The truncation error for a quadratic polynomial is exactly zero: $\\tau = 0$.\n    This means the finite difference operator exactly reproduces the continuous differential operator when applied to any quadratic polynomial:\n    $$\n    L_h u_m(x_i, y_j) = -\\Delta u_m(x_i, y_j) = s(x_i, y_j)\n    $$\n    This identity is the key to the problem. It demonstrates that the manufactured solution, when evaluated at the grid points, is an exact solution to the discrete system of equations.\n\n3.  **Numerical Implementation Strategy**:\n    The task is to compute the discrete solution $u_{i,j}$ and compare it to the exact solution $u_m(x_i, y_j)$. The procedure is as follows:\n    a.  **Grid Setup**: Define a uniform grid with $(N+2) \\times (N+2)$ points covering the domain $[0,1] \\times [0,1]$.\n    b.  **System Formulation**: Formulate the linear system $A \\mathbf{u} = \\mathbf{b}$ for the $N^2$ unknown values at the interior grid points. The matrix $A$ represents the coefficients of the 5-point stencil ($4$ on the diagonal, $-1$ for neighbors). The vector $\\mathbf{b}$ contains the source term values $h^2 s(x_i,y_j)$ and the known boundary values derived from $u_m$.\n    c.  **System Solution**: Solve the sparse linear system for the vector of interior unknowns $\\mathbf{u}$.\n    d.  **Error Calculation**: Reconstruct the full solution grid $u_{i,j}$ by combining the solved interior values with the prescribed boundary values. Then, compute the maximum absolute difference between this numerical solution and the manufactured solution evaluated on the grid: $E_\\infty = \\max |u_{i,j} - u_m(x_i,y_j)|$.\n\n    Given the zero truncation error, the numerical solution $u_{i,j}$ must be identical to $u_m(x_i,y_j)$ at all grid points, up to the limits of floating-point precision. Therefore, the expected error $E_\\infty$ will be a very small number, on the order of machine epsilon. A non-zero result would indicate an error in the implementation of the linear system solver or the problem setup. The provided code implements this procedure robustly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (N, a, b, c, d, e, f)\n        (10, 1.0, 0.5, 2.0, -1.0, 0.25, -0.75),\n        (15, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0),\n        (8, 0.0, 0.0, 0.0, -2.0, 1.5, 0.1),\n        (12, -0.7, 0.0, 0.4, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b, c, d, e, f = case\n        error = calculate_max_error(N, a, b, c, d, e, f)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_error(N, a, b, c, d, e, f):\n    \"\"\"\n    Calculates the maximum absolute nodal error for a single test case by\n    setting up and solving the discrete Poisson equation.\n    \"\"\"\n    h = 1.0 / (N + 1)\n\n    # 1. Set up the grid and coordinates.\n    # The grid is indexed by (j, i) corresponding to (y, x) for standard\n    # row-major array ordering.\n    x_coords = np.linspace(0.0, 1.0, N + 2)\n    y_coords = np.linspace(0.0, 1.0, N + 2)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # 2. Define manufactured solution and evaluate on the grid.\n    u_m_func = lambda x, y: a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n    u_m_grid = u_m_func(X, Y)\n\n    # The source term s(x,y) = -Laplacian(u_m) = -(2a + 2c) is a constant.\n    s_val = -(2*a + 2*c)\n\n    # 3. Set up the linear system A*u = b for interior nodes.\n    # The N*N unknowns correspond to interior grid points, flattened using\n    # row-major ordering: k = (j-1)*N + (i-1).\n    \n    # Construct the sparse matrix A for the 5-point stencil:\n    # 4*u_ji - u_{j,i-1} - u_{j,i+1} - u_{j-1,i} - u_{j+1,i}\n    \n    d_main = np.full(N*N, 4.0)\n    d_h_off = np.full(N*N - 1, -1.0)\n    d_v_off = np.full(N*N - N, -1.0)\n    \n    # Zero out connections between the end of a grid row and the start of the next.\n    for j in range(1, N):\n        d_h_off[j*N - 1] = 0.0\n    \n    diagonals = [d_main, d_h_off, d_h_off, d_v_off, d_v_off]\n    offsets = [0, -1, 1, -N, N]\n    A = diags(diagonals, offsets, shape=(N*N, N*N), format='csr')\n\n    # 4. Construct the RHS vector b.\n    b = np.zeros(N*N)\n    for j in range(1, N + 1):      # y-index on grid\n        for i in range(1, N + 1):  # x-index on grid\n            k = (j - 1) * N + (i - 1)  # row-major vector index\n            \n            # Source term contribution\n            b[k] = h**2 * s_val\n            \n            # Add contributions from known boundary values\n            if i == 1:   # Left boundary (x=0)\n                b[k] += u_m_grid[j, 0]\n            if i == N:   # Right boundary (x=1)\n                b[k] += u_m_grid[j, N+1]\n            if j == 1:   # Bottom boundary (y=0)\n                b[k] += u_m_grid[0, i]\n            if j == N:   # Top boundary (y=1)\n                b[k] += u_m_grid[N+1, i]\n\n    # 5. Solve the linear system for interior node values.\n    u_interior_vec = spsolve(A, b)\n\n    # 6. Reconstruct the full solution grid.\n    u_discrete = np.zeros((N + 2, N + 2))\n    \n    # Set boundary values from manufactured solution\n    u_discrete[0, :] = u_m_grid[0, :]\n    u_discrete[N+1, :] = u_m_grid[N+1, :]\n    u_discrete[:, 0] = u_m_grid[:, 0]\n    u_discrete[:, N+1] = u_m_grid[:, N+1]\n    \n    # Fill interior with the solved values, reshaped according to row-major order.\n    u_discrete[1:N+1, 1:N+1] = u_interior_vec.reshape((N, N), order='C')\n\n    # 7. Calculate the maximum absolute error over the entire grid.\n    error = np.max(np.abs(u_discrete - u_m_grid))\n    \n    return error\n\nsolve()\n\n```", "id": "2444972"}, {"introduction": "Having confirmed your solver's exactness for polynomials, the next step is to verify its performance for more general functions. This practice applies the Method of Manufactured Solutions to its most common use case: verifying the theoretical convergence rate of a numerical scheme [@problem_id:2444940]. By using a manufactured solution with non-zero higher-order derivatives, you will compute the numerical error on a sequence of refined grids and confirm that it decreases at the expected rate, a critical indicator that your code is implemented correctly.", "problem": "Consider the two-dimensional Poisson equation on the square domain $\\Omega = [0,1] \\times [0,1]$,\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in \\Omega,$$\nwith Dirichlet boundary conditions prescribed by a manufactured solution $u_{m}(x,y)$,\n$$u(x,y)\\big|_{\\partial \\Omega} = u_{m}(x,y),$$\nwhere\n$$u_{m}(x,y) = \\sin(\\pi x)\\,\\cosh(y) + x^2 y^3.$$\nAll trigonometric function arguments must be interpreted in radians.\n\nYour task is to verify a numerical solver for the Poisson equation by the method of manufactured solutions. Specifically:\n- Derive the source term $f(x,y)$ exactly from the manufactured solution $u_{m}(x,y)$ by applying the Laplacian operator $\\nabla^2$.\n- Solve the boundary value problem with the derived $f(x,y)$ on uniform Cartesian grids of size $N \\times N$ nodes that include the boundary, for specified values of $N$.\n- On each grid, enforce the Dirichlet boundary condition exactly by setting $u(x,y)$ equal to $u_{m}(x,y)$ on $\\partial \\Omega$.\n- Compare the computed numerical solution $u_{\\text{num}}$ to the exact manufactured solution $u_{m}$ at the grid nodes to quantify the error.\n\nDefine the following error measures for a grid with $N \\times N$ nodes and uniform spacing $h = 1/(N-1)$:\n- The discrete maximum norm (infinity norm) over all grid nodes,\n$$E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} \\left| u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right|.$$\n- The discrete $L^2$ norm over all grid nodes,\n$$E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right)^2 \\, h^2 \\right)^{1/2}.$$\n\nCompute the observed order of accuracy $p$ between two grids of sizes $N_1$ and $N_2$ (with $N_2 = 2N_1 - 1$ so that the mesh spacing halves) using the discrete $L^2$ error as\n$$p = \\frac{\\log\\left( \\dfrac{E_{2}(N_1)}{E_{2}(N_2)} \\right)}{\\log(2)}.$$\n\nAngle unit specification: All angles are in radians.\n\nTest suite and required outputs:\n- Test case $1$: $N = 3$. Report $E_{\\infty}(3)$.\n- Test case $2$: $N = 9$. Report $E_{2}(9)$.\n- Test case $3$: $N_1 = 17$ and $N_2 = 33$. Report the observed order $p$ computed from $E_{2}(17)$ and $E_{2}(33)$ according to the formula above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[E_{\\infty}(3), E_{2}(9), p]$.\n- Each numeric entry must be formatted as a decimal number with exactly $10$ digits after the decimal point.\n- For example, a valid output line has the form: $[0.1234567890,0.0123456789,1.9876543210]$.", "solution": "The problem as stated constitutes a well-posed, scientifically grounded task for the verification of a numerical method. It adheres to established principles of computational engineering, specifically the method of manufactured solutions for verifying the implementation of a finite difference solver for the Poisson equation. All necessary data, equations, and definitions are provided, and there are no internal contradictions or facts contrary to science. Therefore, the problem is valid, and a solution will be constructed.\n\nThe methodology is comprised of two principal stages: first, the analytical derivation of the source term required by the manufactured solution; second, the numerical solution of the resulting boundary-value problem and the computation of error metrics.\n\nFirst, we derive the source term $f(x,y)$ by applying the Laplacian operator, $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$, to the specified manufactured solution $u_{m}(x,y)$.\nThe manufactured solution is given as:\n$$u_{m}(x,y) = \\sin(\\pi x)\\cosh(y) + x^2 y^3$$\nWe compute the partial derivatives with respect to $x$ and $y$.\nFor the $x$-derivatives:\n$$ \\frac{\\partial u_{m}}{\\partial x} = \\pi \\cos(\\pi x)\\cosh(y) + 2x y^3 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3 $$\nFor the $y$-derivatives:\n$$ \\frac{\\partial u_{m}}{\\partial y} = \\sin(\\pi x)\\sinh(y) + 3x^2 y^2 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial y^2} = \\sin(\\pi x)\\cosh(y) + 6x^2 y $$\nThe source term $f(x,y)$ is the sum of these second derivatives:\n$$ f(x,y) = \\nabla^2 u_{m} = \\frac{\\partial^2 u_{m}}{\\partial x^2} + \\frac{\\partial^2 u_{m}}{\\partial y^2} $$\n$$ f(x,y) = \\left(-\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3\\right) + \\left(\\sin(\\pi x)\\cosh(y) + 6x^2 y\\right) $$\nCombining terms yields the exact source function:\n$$ f(x,y) = (1 - \\pi^2)\\sin(\\pi x)\\cosh(y) + 6x^2 y + 2y^3 $$\n\nSecond, we solve the Poisson equation $\\nabla^2 u(x,y) = f(x,y)$ on a uniform Cartesian grid of $N \\times N$ nodes covering the domain $\\Omega = [0,1] \\times [0,1]$. The grid coordinates are $x_j = j h$ and $y_i = i h$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$, with grid spacing $h = 1/(N-1)$. Let $U_{i,j}$ denote the numerical approximation of $u(y_i, x_j)$. The Laplacian operator is approximated at each interior node $(y_i, x_j)$, where $i,j \\in \\{1, \\dots, N-2\\}$, using a second-order central finite difference scheme:\n$$ \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} + \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} = f(y_i, x_j) $$\nRearranging this stencil gives a linear equation for each interior node:\n$$ U_{i,j-1} + U_{i,j+1} + U_{i-1,j} + U_{i+1,j} - 4U_{i,j} = h^2 f(y_i, x_j) $$\nThis set of $(N-2)^2$ equations for the $(N-2)^2$ unknown interior node values forms a linear system of the form $A \\mathbf{u} = \\mathbf{b}$. The vector $\\mathbf{u}$ contains the unknown values $U_{i,j}$ ordered, for example, in a row-major sequence. The matrix $A$ is a sparse, block-tridiagonal matrix representing the connectivity of the finite difference stencil. The right-hand-side vector $\\mathbf{b}$ contains the values of $h^2 f(y_i, x_j)$ adjusted for the known boundary conditions. For an interior node $(y_i, x_j)$ adjacent to a boundary, the corresponding term in the stencil (e.g., $U_{0,j}$ if $i=1$) is a known value from the Dirichlet condition, $u_m(y_0, x_j)$, and is moved to the right-hand side of the equation.\n\nThe complete numerical solution $u_{\\text{num}}$ is assembled by solving this linear system for the interior values and combining them with the exact boundary values prescribed by $u_m(x,y)$.\n\nThe error is quantified using the specified discrete norms. The discrete maximum norm, $E_{\\infty}(N)$, is calculated as:\n$$ E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} | u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) | $$\nThe discrete $L^2$ norm, $E_{2}(N)$, is calculated as:\n$$ E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} ( u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) )^2 h^2 \\right)^{1/2} $$\nThe observed order of accuracy $p$ is then computed by comparing the $L^2$ error on two successively refined grids, $N_1$ and $N_2=2N_1-1$, which corresponds to halving the mesh spacing $h$:\n$$ p = \\frac{\\log( E_{2}(N_1) / E_{2}(N_2) )}{\\log(2)} $$\nThis value is expected to be approximately $2$, consistent with the second-order accuracy of the finite difference scheme.\n\nThe implementation will construct and solve the linear system for the specified values of $N$ ($N=3, 9, 17, 33$) to compute the requested error metrics.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    \n    # Define PI for use in trigonometric functions.\n    PI = np.pi\n\n    def u_m(x, y):\n        \"\"\"\n        Computes the manufactured solution u_m(x,y).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        return np.sin(PI * x) * np.cosh(y) + x**2 * y**3\n\n    def f_source(x, y):\n        \"\"\"\n        Computes the source term f(x,y) derived from grad^2(u_m).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        term1 = (1.0 - PI**2) * np.sin(PI * x) * np.cosh(y)\n        term2 = 6.0 * x**2 * y\n        term3 = 2.0 * y**3\n        return term1 + term2 + term3\n\n    def solve_poisson(N):\n        \"\"\"\n        Solves the Poisson equation on an N x N grid using finite differences.\n        \n        Args:\n            N (int): The number of nodes along one dimension of the grid.\n\n        Returns:\n            tuple: A tuple containing:\n                - u_num (np.ndarray): The N x N numerical solution array.\n                - u_exact (np.ndarray): The N x N exact manufactured solution array.\n                - h (float): The grid spacing.\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Grid size N must be at least 2.\")\n        if N == 2: # No interior points\n            h = 1.0\n            x = np.linspace(0.0, 1.0, N)\n            y = np.linspace(0.0, 1.0, N)\n            xx, yy = np.meshgrid(x, y, indexing='xy')\n            u_exact = u_m(xx, yy)\n            return u_exact, u_exact, h\n\n        # 1. Grid setup\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # 2. Evaluate exact solution and source term\n        u_exact = u_m(xx, yy)\n        f_vals = f_source(xx, yy)\n\n        # 3. Setup linear system Ax = b for interior points\n        num_interior_nodes_1d = N - 2\n        num_unknowns = num_interior_nodes_1d**2\n        \n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # The mapping from 2D interior grid index (i_int, j_int) to 1D vector index k\n        # is row-major: k = i_int * num_interior_nodes_1d + j_int\n        # This corresponds to full grid index (i, j) where i = i_int + 1, j = j_int + 1\n        for k in range(num_unknowns):\n            i_int = k // num_interior_nodes_1d\n            j_int = k % num_interior_nodes_1d\n            \n            i = i_int + 1\n            j = j_int + 1\n\n            # Main diagonal coefficient for -4*U_ij\n            A[k, k] = -4.0\n\n            # Right-hand side from source term f(y_i, x_j)\n            b[k] = h**2 * f_vals[i, j]\n\n            # Neighbor contribution (x-direction, j-1)\n            if j == 1:\n                b[k] -= u_exact[i, 0]\n            else:\n                A[k, k - 1] = 1.0\n\n            # Neighbor contribution (x-direction, j+1)\n            if j == N - 2:\n                b[k] -= u_exact[i, N - 1]\n            else:\n                A[k, k + 1] = 1.0\n\n            # Neighbor contribution (y-direction, i-1)\n            if i == 1:\n                b[k] -= u_exact[0, j]\n            else:\n                A[k, k - num_interior_nodes_1d] = 1.0\n\n            # Neighbor contribution (y-direction, i+1)\n            if i == N - 2:\n                b[k] -= u_exact[N - 1, j]\n            else:\n                A[k, k + num_interior_nodes_1d] = 1.0\n\n        # 4. Solve the linear system\n        u_interior_flat = np.linalg.solve(A, b)\n        u_interior = u_interior_flat.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n\n        # 5. Construct the full numerical solution grid\n        u_num = np.copy(u_exact)  # Initialize with correct boundary values\n        u_num[1:N-1, 1:N-1] = u_interior\n\n        return u_num, u_exact, h\n\n    # Test case 1: N = 3, compute E_infinity\n    u_num_3, u_exact_3, _ = solve_poisson(N=3)\n    e_inf_3 = np.max(np.abs(u_num_3 - u_exact_3))\n\n    # Test case 2: N = 9, compute E_2\n    u_num_9, u_exact_9, h_9 = solve_poisson(N=9)\n    e_2_9 = np.sqrt(np.sum((u_num_9 - u_exact_9)**2) * h_9**2)\n\n    # Test case 3: N1=17, N2=33, compute order of accuracy p\n    # Compute E_2 for N=17\n    u_num_17, u_exact_17, h_17 = solve_poisson(N=17)\n    e_2_17 = np.sqrt(np.sum((u_num_17 - u_exact_17)**2) * h_17**2)\n    \n    # Compute E_2 for N=33\n    u_num_33, u_exact_33, h_33 = solve_poisson(N=33)\n    e_2_33 = np.sqrt(np.sum((u_num_33 - u_exact_33)**2) * h_33**2)\n    \n    # Compute order of accuracy p\n    p = np.log(e_2_17 / e_2_33) / np.log(2.0)\n    \n    # Compile and format results\n    results = [e_inf_3, e_2_9, p]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10f}' for x in results)}]\")\n\nsolve()\n```", "id": "2444940"}, {"introduction": "Real-world engineering problems rarely fit on simple Cartesian grids, requiring finite element codes to handle complex, curvilinear geometries. This practice extends the Method of Manufactured Solutions to the verification of such advanced codes, where the differential operators involve geometric terms like the Jacobian and metric tensors [@problem_id:2576815]. You will construct a test case with a non-trivial 3D coordinate mapping to ensure that your implementation correctly handles the transformation of the diffusion operator, a common and critical source of error in sophisticated simulation software.", "problem": "Consider verification of a mapped-element diffusion operator in three dimensions using the Method of Manufactured Solutions (MMS) within the Finite Element Method (FEM). Let the physical domain be represented by a trilinear-curvilinear mapping from the reference cube with coordinates $(\\xi,\\eta,\\zeta)\\in[0,1]^3$ to physical coordinates $(x,y,z)$ via\n$$\n\\begin{aligned}\nx(\\xi,\\eta,\\zeta) = \\xi + a \\sin(\\pi \\xi)\\sin(\\pi \\eta) + b\\,\\zeta^2,\\\\\ny(\\xi,\\eta,\\zeta) = \\eta + c\\,\\xi\\,\\eta + d \\sin(\\pi \\zeta),\\\\\nz(\\xi,\\eta,\\zeta) = \\zeta + e\\,\\xi\\,\\zeta + f\\,\\eta\\,\\zeta,\n\\end{aligned}\n$$\nwhere $a,b,c,d,e,f$ are real parameters. All trigonometric arguments are in radians. Denote the Jacobian matrix by $X_{i\\alpha}=\\partial x_i/\\partial \\xi_\\alpha$ with $i\\in\\{1,2,3\\}$ corresponding to $(x,y,z)$ and $\\alpha\\in\\{1,2,3\\}$ corresponding to $(\\xi,\\eta,\\zeta)$. Let $J=\\det(X)$ be the Jacobian determinant, $G=X^\\top X$ the covariant metric tensor, and $g=G^{-1}$ the contravariant metric tensor with entries $g^{\\alpha\\beta}$.\n\nWe seek a manufactured solution $u_m(\\xi,\\eta,\\zeta)$ such that it strongly couples with the metric terms in three-dimensional curvilinear elements, ensuring that all mapping components and mixed derivatives are exercised. Consider the following $u_m$:\n$$\n\\begin{aligned}\nu_m(\\xi,\\eta,\\zeta) = \\sin\\!\\Big(\\pi(\\xi + 0.2\\,\\eta)\\Big)\\,\\cos\\!\\Big(\\pi(\\zeta + 0.1\\,\\xi\\,\\eta)\\Big) \\\\\n\\quad + \\xi^2 \\eta + \\eta^2 \\zeta + \\zeta^2 \\xi + \\xi \\eta \\zeta.\n\\end{aligned}\n$$\nLet the steady diffusion equation in physical space be\n$$\n- \\nabla \\cdot (k \\nabla u) = f,\n$$\nwith constant conductivity $k0$. When expressed in reference coordinates using the standard transformation identities for curvilinear coordinates, the physical-space Laplacian of a scalar $u(\\xi,\\eta,\\zeta)$ is given by\n$$\n\\Delta u = \\frac{1}{J} \\,\\partial_\\alpha\\!\\left(J\\, g^{\\alpha\\beta}\\, \\partial_\\beta u\\right),\n$$\nwhere $\\partial_\\alpha$ denotes partial differentiation with respect to the reference coordinate $\\xi_\\alpha\\in\\{\\xi,\\eta,\\zeta\\}$ and the Einstein summation convention applies over repeated Greek indices. Therefore, the manufactured source is\n$$\nf(\\xi,\\eta,\\zeta) = -k\\,\\Delta u_m(\\xi,\\eta,\\zeta) = -\\frac{k}{J} \\,\\partial_\\alpha\\!\\left(J\\, g^{\\alpha\\beta}\\, \\partial_\\beta u_m\\right).\n$$\n\nTask:\n1. Implement the mapping and compute $X$, $J$, $G$, and $g$ at any $(\\xi,\\eta,\\zeta)$ for given $(a,b,c,d,e,f)$. Explicitly compute all first derivatives of $u_m$ with respect to $(\\xi,\\eta,\\zeta)$ analytically. For the divergence $\\partial_\\alpha\\!\\left(J\\, g^{\\alpha\\beta}\\, \\partial_\\beta u_m\\right)$, use a centered finite difference with a stepsize $h = 1\\times 10^{-6}$ in the corresponding reference coordinate, holding the other two fixed, that is,\n$$\n\\partial_\\xi Q_\\xi \\approx \\frac{Q_\\xi(\\xi+h,\\eta,\\zeta)-Q_\\xi(\\xi-h,\\eta,\\zeta)}{2h},\\quad Q_\\xi = J\\,g^{\\xi\\beta}\\,\\partial_\\beta u_m,\n$$\nand analogously for $\\partial_\\eta Q_\\eta$ and $\\partial_\\zeta Q_\\zeta$. Use the formula\n$$\n\\Delta u_m(\\xi,\\eta,\\zeta) \\approx \\frac{1}{J(\\xi,\\eta,\\zeta)}\\left[\\partial_\\xi Q_\\xi + \\partial_\\eta Q_\\eta + \\partial_\\zeta Q_\\zeta\\right].\n$$\n2. For each specified parameter set and conductivity, evaluate $f(\\xi,\\eta,\\zeta)$ at the sample points listed below and report the root-mean-square (RMS) value over these points:\n$$\n\\text{RMS}(f) = \\sqrt{\\frac{1}{N}\\sum_{n=1}^N f(\\xi_n,\\eta_n,\\zeta_n)^2},\\quad N=4,\n$$\nwith the sample points\n$$\n(\\xi,\\eta,\\zeta)\\in\\Big\\{(0.33,0.27,0.41),\\,(0.73,0.19,0.87),\\,(0.51,0.61,0.29),\\,(0.23,0.47,0.79)\\Big\\}.\n$$\n3. Use the following test suite of parameter sets $(a,b,c,d,e,f)$ and conductivities $k$:\n- Case A (affine boundary condition check): $(a,b,c,d,e,f)=(0,0,0,0,0,0)$ and $k=2.0$.\n- Case B (moderate curvature): $(a,b,c,d,e,f)=(0.1,0.05,0.2,0.07,0.15,0.12)$ and $k=1.0$.\n- Case C (stronger curvature): $(a,b,c,d,e,f)=(0.2,0.1,0.3,0.15,0.25,0.22)$ and $k=0.7$.\n\nAll trigonometric function arguments must be in radians. There are no physical units to report. Angles are in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$), where $r_i$ is the RMS value defined above for the $i$-th parameter set in the test suite, in the order A, B, C. Each $r_i$ must be a floating-point number. The program must be self-contained and use no external input.", "solution": "The problem statement has been rigorously validated and is found to be scientifically grounded, well-posed, and complete. It describes a standard, albeit computationally intensive, procedure in the field of computational mechanics for the verification of numerical codes using the Method of Manufactured Solutions. We will proceed to construct the solution.\n\nThe objective is to compute the manufactured source term $f(\\xi, \\eta, \\zeta)$ corresponding to a prescribed manufactured solution $u_m(\\xi, \\eta, \\zeta)$ under a curvilinear coordinate transformation. The governing equation is the steady-state diffusion equation, $- \\nabla \\cdot (k \\nabla u) = f$.\n\nThe fundamental relationship between the Laplacian operator in physical space $(x, y, z)$ and reference space $(\\xi, \\eta, \\zeta)$ is given by\n$$\n\\Delta u = \\frac{1}{J} \\frac{\\partial}{\\partial \\xi^\\alpha} \\left( J g^{\\alpha\\beta} \\frac{\\partial u}{\\partial \\xi^\\beta} \\right)\n$$\nwhere summation over repeated indices $\\alpha, \\beta \\in \\{1, 2, 3\\}$ is implied. The quantities $J$ and $g^{\\alpha\\beta}$ are the Jacobian determinant and the contravariant metric tensor components, respectively, derived from the coordinate mapping $x_i(\\xi_\\alpha)$.\n\nThe procedure is as follows:\n1.  Analytically derive the components of the Jacobian matrix $X_{i\\alpha} = \\partial x_i / \\partial \\xi_\\alpha$.\n2.  Analytically derive the components of the gradient of the manufactured solution in the reference frame, $\\partial_\\alpha u_m = \\partial u_m / \\partial \\xi_\\alpha$.\n3.  For any point $(\\xi, \\eta, \\zeta)$, numerically compute the geometric tensors and the flux vector in the reference frame.\n4.  Numerically approximate the divergence of the flux vector using a second-order centered finite difference scheme to compute $\\Delta u_m$.\n5.  Calculate the manufactured source $f = -k \\Delta u_m$.\n6.  Finally, compute the root-mean-square (RMS) of $f$ over the specified sample points for each test case.\n\n**1. Jacobian Matrix Derivation**\nThe mapping is given by:\n$$\n\\begin{aligned}\nx(\\xi,\\eta,\\zeta) = \\xi + a \\sin(\\pi \\xi)\\sin(\\pi \\eta) + b\\,\\zeta^2 \\\\\ny(\\xi,\\eta,\\zeta) = \\eta + c\\,\\xi\\,\\eta + d \\sin(\\pi \\zeta) \\\\\nz(\\xi,\\eta,\\zeta) = \\zeta + e\\,\\xi\\,\\zeta + f\\,\\eta\\,\\zeta\n\\end{aligned}\n$$\nThe Jacobian matrix $X$ with components $X_{i\\alpha} = \\partial x_i / \\partial \\xi_\\alpha$ (where $x_1=x, x_2=y, x_3=z$ and $\\xi_1=\\xi, \\xi_2=\\eta, \\xi_3=\\zeta$) is:\n$$\nX = \\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial x}{\\partial \\zeta} \\\\\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\zeta} \\\\\n\\frac{\\partial z}{\\partial \\xi}  \\frac{\\partial z}{\\partial \\eta}  \\frac{\\partial z}{\\partial \\zeta}\n\\end{pmatrix}\n$$\nThe individual components are:\n$$\n\\begin{aligned}\n\\frac{\\partial x}{\\partial \\xi} = 1 + a \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta) \\\\\n\\frac{\\partial x}{\\partial \\eta} = a \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) \\\\\n\\frac{\\partial x}{\\partial \\zeta} = 2 b \\zeta \\\\\n\\frac{\\partial y}{\\partial \\xi} = c \\eta \\\\\n\\frac{\\partial y}{\\partial \\eta} = 1 + c \\xi \\\\\n\\frac{\\partial y}{\\partial \\zeta} = d \\pi \\cos(\\pi \\zeta) \\\\\n\\frac{\\partial z}{\\partial \\xi} = e \\zeta \\\\\n\\frac{\\partial z}{\\partial \\eta} = f \\zeta \\\\\n\\frac{\\partial z}{\\partial \\zeta} = 1 + e \\xi + f \\eta\n\\end{aligned}\n$$\n\n**2. Manufactured Solution Gradient Derivation**\nThe manufactured solution is:\n$$\nu_m(\\xi,\\eta,\\zeta) = \\sin\\Big(\\pi(\\xi + 0.2\\eta)\\Big)\\cos\\Big(\\pi(\\zeta + 0.1\\xi\\eta)\\Big) + \\xi^2 \\eta + \\eta^2 \\zeta + \\zeta^2 \\xi + \\xi \\eta \\zeta\n$$\nIts partial derivatives with respect to the reference coordinates are:\n$$\n\\begin{aligned}\n\\frac{\\partial u_m}{\\partial \\xi} = \\ \\pi \\cos\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\cos\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n- 0.1\\pi\\eta \\sin\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\sin\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n+ 2\\xi\\eta + \\zeta^2 + \\eta\\zeta \\\\\n\\\\\n\\frac{\\partial u_m}{\\partial \\eta} = \\ 0.2\\pi \\cos\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\cos\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n- 0.1\\pi\\xi \\sin\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\sin\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) \\\\\n+ \\xi^2 + 2\\eta\\zeta + \\xi\\zeta \\\\\n\\\\\n\\frac{\\partial u_m}{\\partial \\zeta} = \\ -\\pi \\sin\\Big(\\pi(\\xi+0.2\\eta)\\Big) \\sin\\Big(\\pi(\\zeta+0.1\\xi\\eta)\\Big) + \\eta^2 + 2\\zeta\\xi + \\xi\\eta\n\\end{aligned}\n$$\n\n**3. Numerical Computation of the Source Term**\nFor a given point $(\\xi, \\eta, \\zeta)$, we define a flux-related vector $Q$ with components:\n$$\nQ_\\alpha = J g^{\\alpha\\beta} \\frac{\\partial u_m}{\\partial \\xi^\\beta}\n$$\nThese components are explicitly:\n$$\n\\begin{aligned}\nQ_\\xi = J \\left( g^{\\xi\\xi} \\frac{\\partial u_m}{\\partial \\xi} + g^{\\xi\\eta} \\frac{\\partial u_m}{\\partial \\eta} + g^{\\xi\\zeta} \\frac{\\partial u_m}{\\partial \\zeta} \\right) \\\\\nQ_\\eta = J \\left( g^{\\eta\\xi} \\frac{\\partial u_m}{\\partial \\xi} + g^{\\eta\\eta} \\frac{\\partial u_m}{\\partial \\eta} + g^{\\eta\\zeta} \\frac{\\partial u_m}{\\partial \\zeta} \\right) \\\\\nQ_\\zeta = J \\left( g^{\\zeta\\xi} \\frac{\\partial u_m}{\\partial \\xi} + g^{\\zeta\\eta} \\frac{\\partial u_m}{\\partial \\eta} + g^{\\zeta\\zeta} \\frac{\\partial u_m}{\\partial \\zeta} \\right)\n\\end{aligned}\n$$\nwhere $J = \\det(X)$ and $g = (X^T X)^{-1}$. The divergence term in the Laplacian, $\\partial_\\alpha Q_\\alpha$, is approximated by central differences with a step size of $h = 1 \\times 10^{-6}$:\n$$\n\\partial_\\alpha Q_\\alpha \\approx \\frac{Q_\\xi(\\xi+h, \\eta, \\zeta) - Q_\\xi(\\xi-h, \\eta, \\zeta)}{2h} + \\frac{Q_\\eta(\\xi, \\eta+h, \\zeta) - Q_\\eta(\\xi, \\eta-h, \\zeta)}{2h} + \\frac{Q_\\zeta(\\xi, \\eta, \\zeta+h) - Q_\\zeta(\\xi, \\eta, \\zeta-h)}{2h}\n$$\nThe Laplacian is then computed at $(\\xi, \\eta, \\zeta)$ as:\n$$\n\\Delta u_m(\\xi, \\eta, \\zeta) \\approx \\frac{1}{J(\\xi,\\eta,\\zeta)} \\left( \\partial_\\alpha Q_\\alpha \\right)\n$$\nAnd the source term is $f(\\xi, \\eta, \\zeta) = -k \\Delta u_m$.\n\n**4. RMS Calculation**\nThe RMS value is computed over the $N=4$ sample points $(\\xi_n, \\eta_n, \\zeta_n)$:\n$$\n\\text{RMS}(f) = \\sqrt{\\frac{1}{N}\\sum_{n=1}^N f(\\xi_n,\\eta_n,\\zeta_n)^2}\n$$\nThis procedure is implemented for each of the three test cases specified in the problem statement. The implementation will use numerical libraries for matrix operations such as determinant and inversion. All trigonometric function inputs are treated as radians.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the Method of Manufactured Solutions task.\n    It computes the RMS of the source term for three different test cases.\n    \"\"\"\n    \n    # Define the finite difference step size\n    H = 1e-6\n    \n    # Define the sample points in the reference domain\n    sample_points = [\n        (0.33, 0.27, 0.41),\n        (0.73, 0.19, 0.87),\n        (0.51, 0.61, 0.29),\n        (0.23, 0.47, 0.79)\n    ]\n    \n    # Define the test cases with mapping parameters and conductivity\n    test_cases = [\n        # Case A: Affine mapping\n        {'params': (0.0, 0.0, 0.0, 0.0, 0.0, 0.0), 'k': 2.0},\n        # Case B: Moderate curvature\n        {'params': (0.1, 0.05, 0.2, 0.07, 0.15, 0.12), 'k': 1.0},\n        # Case C: Stronger curvature\n        {'params': (0.2, 0.1, 0.3, 0.15, 0.25, 0.22), 'k': 0.7}\n    ]\n\n    def get_grad_um(xi, eta, zeta):\n        \"\"\"\n        Computes the analytical gradient of the manufactured solution u_m\n        in the reference coordinates (xi, eta, zeta).\n        \"\"\"\n        term1_arg1 = np.pi * (xi + 0.2 * eta)\n        term1_arg2 = np.pi * (zeta + 0.1 * xi * eta)\n        \n        sin1 = np.sin(term1_arg1)\n        cos1 = np.cos(term1_arg1)\n        sin2 = np.sin(term1_arg2)\n        cos2 = np.cos(term1_arg2)\n\n        # Partial derivative with respect to xi\n        du_dxi = (np.pi * cos1 * cos2 \n                  - 0.1 * np.pi * eta * sin1 * sin2 \n                  + 2.0 * xi * eta + zeta**2 + eta * zeta)\n                  \n        # Partial derivative with respect to eta\n        du_deta = (0.2 * np.pi * cos1 * cos2 \n                   - 0.1 * np.pi * xi * sin1 * sin2 \n                   + xi**2 + 2.0 * eta * zeta + xi * zeta)\n                   \n        # Partial derivative with respect to zeta\n        du_dzeta = (-np.pi * sin1 * sin2 \n                    + eta**2 + 2.0 * zeta * xi + xi * eta)\n        \n        return np.array([du_dxi, du_deta, du_dzeta])\n\n    def compute_Q_and_J(xi, eta, zeta, params):\n        \"\"\"\n        Computes the flux-related vector Q and the Jacobian determinant J.\n        \"\"\"\n        a, b, c, d, e, f = params\n        pi = np.pi\n        \n        # Jacobian matrix X\n        X = np.zeros((3, 3))\n        X[0, 0] = 1.0 + a * pi * np.cos(pi * xi) * np.sin(pi * eta)\n        X[0, 1] = a * pi * np.sin(pi * xi) * np.cos(pi * eta)\n        X[0, 2] = 2.0 * b * zeta\n        X[1, 0] = c * eta\n        X[1, 1] = 1.0 + c * xi\n        X[1, 2] = d * pi * np.cos(pi * zeta)\n        X[2, 0] = e * zeta\n        X[2, 1] = f * zeta\n        X[2, 2] = 1.0 + e * xi + f * eta\n        \n        # Jacobian determinant J\n        J = np.linalg.det(X)\n        \n        # Covariant metric tensor G and contravariant metric tensor g\n        G = X.T @ X\n        g = np.linalg.inv(G)\n        \n        # Gradient of u_m\n        grad_u = get_grad_um(xi, eta, zeta)\n        \n        # Flux vector Q\n        Q = J * (g @ grad_u)\n        \n        return Q, J\n\n    def calculate_source_rms(params, k):\n        \"\"\"\n        Calculates the RMS of the manufactured source term over the sample points.\n        \"\"\"\n        f_squared_values = []\n        \n        for xi_c, eta_c, zeta_c in sample_points:\n            # Finite difference approximation for the divergence of Q\n            Q_px, _ = compute_Q_and_J(xi_c + H, eta_c, zeta_c, params)\n            Q_mx, _ = compute_Q_and_J(xi_c - H, eta_c, zeta_c, params)\n            div_Q_xi = (Q_px[0] - Q_mx[0]) / (2.0 * H)\n            \n            Q_py, _ = compute_Q_and_J(xi_c, eta_c + H, zeta_c, params)\n            Q_my, _ = compute_Q_and_J(xi_c, eta_c - H, zeta_c, params)\n            div_Q_eta = (Q_py[1] - Q_my[1]) / (2.0 * H)\n\n            Q_pz, _ = compute_Q_and_J(xi_c, eta_c, zeta_c + H, params)\n            Q_mz, _ = compute_Q_and_J(xi_c, eta_c, zeta_c - H, params)\n            div_Q_zeta = (Q_pz[2] - Q_mz[2]) / (2.0 * H)\n            \n            div_Q = div_Q_xi + div_Q_eta + div_Q_zeta\n            \n            # Jacobian determinant at the center point\n            _, J_c = compute_Q_and_J(xi_c, eta_c, zeta_c, params)\n            \n            # Laplacian of the manufactured solution\n            laplacian_um = div_Q / J_c\n            \n            # Manufactured source term f\n            f_val = -k * laplacian_um\n            f_squared_values.append(f_val**2)\n            \n        return np.sqrt(np.mean(f_squared_values))\n\n    results = []\n    for case in test_cases:\n        rms_val = calculate_source_rms(case['params'], case['k'])\n        results.append(rms_val)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2576815"}]}