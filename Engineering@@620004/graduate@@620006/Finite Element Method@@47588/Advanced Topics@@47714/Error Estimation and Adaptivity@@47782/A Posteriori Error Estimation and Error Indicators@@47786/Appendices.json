{"hands_on_practices": [{"introduction": "We begin with a foundational exercise to build intuition for residual-based error estimators. This practice focuses on a simple one-dimensional problem where both the exact solution and the finite element approximation can be computed analytically. By manually calculating the element residuals and inter-element flux jumps, you will construct a global error estimator and compare it directly to the true error, providing a concrete understanding of estimator reliability and efficiency. [@problem_id:2539270]", "problem": "Consider the boundary value problem $-u''=1$ on $(0,1)$ with homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$. Let $V:=H_{0}^{1}(0,1)$ and let $u\\in V$ denote the exact solution. Let $\\{\\mathcal{T}_h\\}$ be the family of uniform meshes of $(0,1)$ with $N\\in\\mathbb{N}$ elements of size $h=1/N$, and let $V_h\\subset V$ be the conforming piecewise linear finite element space associated with $\\mathcal{T}_h$. Let $u_h\\in V_h$ be the Galerkin solution of the weak problem in $V_h$. Starting from the weak residual and its localization by integration by parts, construct the standard residual-based a posteriori error estimator that is built from element (volume) residuals and interelement normal flux jumps, with mesh-size scalings. Compute, in closed form as functions of $N$, both:\n- the global residual-based estimator $\\eta(N)$,\n- the exact energy-norm error $\\|u-u_h\\|_{H_{0}^{1}(0,1)}$.\nThen form the efficiency index $\\theta(N):=\\eta(N)\\big/\\|u-u_h\\|_{H_{0}^{1}(0,1)}$.\n\nProvide your final answer as a single closed-form expression in terms of $N$ only (no numerical rounding).", "solution": "The problem as stated is valid. It is a well-posed, canonical problem in the numerical analysis of partial differential equations, specifically within the topic of a posteriori error estimation for the finite element method. All components are clearly defined and mathematically sound. We shall proceed with the solution.\n\nThe boundary value problem is:\n$$ -u'' = 1 \\quad \\text{on } (0,1), \\quad u(0)=u(1)=0 $$\nThe space for the weak formulation is $V := H_{0}^{1}(0,1)$. The weak form is to find $u \\in V$ such that\n$$ a(u,v) = L(v) \\quad \\forall v \\in V, $$\nwhere the bilinear form $a(u,v)$ and linear functional $L(v)$ are given by:\n$$ a(u,v) := \\int_{0}^{1} u'(x) v'(x) \\, dx, \\quad L(v) := \\int_{0}^{1} 1 \\cdot v(x) \\, dx $$\nThe energy norm associated with this problem is $\\|v\\|_{H_{0}^{1}(0,1)} = (\\int_{0}^{1} (v'(x))^2 \\, dx)^{1/2} = \\|v'\\|_{L^2(0,1)}$.\n\nFirst, we find the exact solution $u(x)$. Integrating $-u''=1$ twice yields $u(x) = -\\frac{1}{2}x^2 + C_1 x + C_2$. Applying the boundary conditions $u(0)=0$ and $u(1)=0$ gives $C_2=0$ and $C_1=\\frac{1}{2}$. Thus, the exact solution is\n$$ u(x) = \\frac{1}{2}x(1-x) $$\nThe derivative of the exact solution is $u'(x) = \\frac{1}{2} - x$.\n\nNext, we characterize the Galerkin solution $u_h \\in V_h$. The space $V_h$ consists of continuous piecewise linear functions on a uniform mesh with nodes $x_i = i h$ for $i=0, \\dots, N$, where $h=1/N$. The Galerkin problem is: find $u_h \\in V_h$ such that\n$$ a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h $$\nFor this specific problem, the finite element solution $u_h$ interpolates the exact solution $u$ at the mesh nodes: $u_h(x_i) = u(x_i)$ for all $i=0, \\dots, N$. On each element $T_i := [x_{i-1}, x_i]$, $u_h$ is linear, so its derivative $u_h'$ is constant. This constant is\n$$ u_h'(x)|_{T_i} = \\frac{u_h(x_i) - u_h(x_{i-1})}{h} = \\frac{u(ih) - u((i-1)h)}{h} $$\nSubstituting the expression for $u(x)$:\n$$ u_h'(x)|_{T_i} = \\frac{1}{h} \\left( \\frac{1}{2}ih(1-ih) - \\frac{1}{2}(i-1)h(1-(i-1)h) \\right) = \\frac{1}{2} (1 - (2i-1)h) $$\nThis is equal to the value of the exact derivative $u'(x)$ at the midpoint of the element, $x_{i-1/2} = (i-1/2)h$.\n\nWe now compute the exact energy-norm error, $\\|u-u_h\\|_{H_{0}^{1}(0,1)}$.\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)}^2 = \\int_{0}^{1} (u'(x) - u_h'(x))^2 \\, dx = \\sum_{i=1}^{N} \\int_{x_{i-1}}^{x_i} (u'(x) - u_h'(x))^2 \\, dx $$\nOn an element $T_i$, the integrand is:\n$$ (u'(x) - u_h'(x))^2 = \\left( \\left(\\frac{1}{2} - x\\right) - \\frac{1}{2}(1 - (2i-1)h) \\right)^2 = \\left( (i-1/2)h - x \\right)^2 $$\nLet $s = x - (i-1/2)h$. The integral over $T_i$ becomes:\n$$ \\int_{-h/2}^{h/2} s^2 \\, ds = \\left[ \\frac{s^3}{3} \\right]_{-h/2}^{h/2} = \\frac{1}{3} \\left( \\left(\\frac{h}{2}\\right)^3 - \\left(-\\frac{h}{2}\\right)^3 \\right) = \\frac{h^3}{12} $$\nThis result is identical for all $N$ elements. Summing these contributions gives the total squared error:\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)}^2 = \\sum_{i=1}^{N} \\frac{h^3}{12} = N \\frac{h^3}{12} = N \\frac{(1/N)^3}{12} = \\frac{1}{12N^2} $$\nTherefore, the exact error is:\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)} = \\sqrt{\\frac{1}{12N^2}} = \\frac{1}{2\\sqrt{3}N} $$\n\nNext, we construct the standard residual-based a posteriori error estimator. The error $e = u-u_h$ satisfies the Galerkin orthogonality condition $a(e, v_h)=0$ for all $v_h \\in V_h$. For any $v \\in V$, the error equation is $a(e,v) = L(v) - a(u_h,v)$. This right-hand side is the weak residual. By element-wise integration by parts, it can be written as:\n$$ L(v) - a(u_h,v) = \\sum_{i=1}^{N} \\int_{T_i} (1+u_h''(x)) v(x) \\, dx + \\sum_{i=1}^{N-1} [[-u_h']](x_i) v(x_i) $$\nwhere $R_{T_i} = 1+u_h''|_{T_i}$ is the element residual and $J_i = [[-u_h']](x_i)$ is the jump residual at interior node $x_i$.\nThe standard estimator is built by taking the norms of these residual components, scaled by powers of the element size $h$. The squared estimator is:\n$$ \\eta^2 = \\sum_{i=1}^{N} h^2 \\|R_{T_i}\\|_{L^2(T_i)}^2 + \\sum_{i=1}^{N-1} h |[[u_h']](x_i)|^2 $$\nWe compute the components. Since $u_h$ is linear on each element $T_i$, $u_h''=0$. Thus, the element residual $R_{T_i} = 1$. The $L^2$-norm squared is:\n$$ \\|R_{T_i}\\|_{L^2(T_i)}^2 = \\int_{x_{i-1}}^{x_i} 1^2 \\, dx = h $$\nThe jump in the derivative at an interior node $x_i$ is:\n$$ [[u_h']](x_i) = u_h'(x)|_{T_{i+1}} - u_h'(x)|_{T_i} = \\frac{1}{2}(1 - (2(i+1)-1)h) - \\frac{1}{2}(1 - (2i-1)h) $$\n$$ = \\frac{1}{2}(1 - (2i+1)h - 1 + (2i-1)h) = \\frac{1}{2}(-2h) = -h $$\nThe sum of squared volume residuals is:\n$$ \\sum_{i=1}^{N} h^2 \\|R_{T_i}\\|_{L^2(T_i)}^2 = \\sum_{i=1}^{N} h^2 \\cdot h = N h^3 $$\nThe sum of squared jump residuals is:\n$$ \\sum_{i=1}^{N-1} h |[[u_h']](x_i)|^2 = \\sum_{i=1}^{N-1} h(-h)^2 = (N-1)h^3 $$\nThe total estimator squared is the sum of these two parts:\n$$ \\eta^2 = N h^3 + (N-1)h^3 = (2N-1)h^3 $$\nSubstituting $h=1/N$:\n$$ \\eta(N)^2 = \\frac{2N-1}{N^3} \\implies \\eta(N) = \\sqrt{\\frac{2N-1}{N^3}} $$\n\nFinally, we compute the efficiency index $\\theta(N) = \\eta(N) / \\|u-u_h\\|_{H_{0}^{1}(0,1)}$:\n$$ \\theta(N) = \\frac{\\sqrt{\\frac{2N-1}{N^3}}}{\\frac{1}{2\\sqrt{3}N}} = 2\\sqrt{3}N \\sqrt{\\frac{2N-1}{N^3}} = 2\\sqrt{3} \\sqrt{\\frac{N^2(2N-1)}{N^3}} $$\n$$ \\theta(N) = 2\\sqrt{3} \\sqrt{\\frac{2N-1}{N}} = \\sqrt{12 \\left(2 - \\frac{1}{N}\\right)} = \\sqrt{\\frac{12(2N-1)}{N}} $$", "answer": "$$\\boxed{\\sqrt{\\frac{12(2N-1)}{N}}}$$", "id": "2539270"}, {"introduction": "Building on the fundamentals of interior residuals, this next practice addresses the crucial task of estimating error contributions from the domain boundary. Many physical models involve mixed boundary conditions, and this exercise provides a focused calculation on how to derive and compute the residual terms for Neumann and Robin boundaries. This is an essential step in applying a posteriori error estimation to a wider class of practical problems. [@problem_id:2539242]", "problem": "Consider the scalar diffusion Partial Differential Equation (PDE)\n$$-\\nabla \\cdot (\\kappa \\nabla u) = f \\quad \\text{in } \\Omega := (0,1)\\times(0,1),$$\nwith mixed boundary conditions on the boundary $\\Gamma = \\partial \\Omega$ given by the partition $\\Gamma = \\Gamma_{D} \\cup \\Gamma_{N} \\cup \\Gamma_{R}$, where $\\Gamma_{D}$ is the union of the left and top edges, $\\Gamma_{N}$ is the right edge $\\{1\\}\\times[0,1]$, and $\\Gamma_{R}$ is the bottom edge $[0,1]\\times\\{0\\}$. The boundary conditions are\n$$u = 0 \\ \\text{on } \\Gamma_{D}, \\qquad \\kappa \\,\\partial_{n} u = g_{N} \\ \\text{on } \\Gamma_{N}, \\qquad \\kappa \\,\\partial_{n} u + \\beta\\, u = g_{R} \\ \\text{on } \\Gamma_{R},$$\nwith outward unit normal $\\boldsymbol{n}$. Assume $\\kappa = 2$ and $\\beta = 1$, and let $g_{N}(y) = 1 + y$ for $(x,y) \\in \\Gamma_{N}$ and $g_{R}(x) = 2 - x$ for $(x,y) \\in \\Gamma_{R}$. The source $f$ is smooth but otherwise unspecified, since only boundary contributions are to be computed.\n\nLet $u_h$ be a continuous, piecewise affine Finite Element Method (FEM) approximation on a shape-regular triangulation that induces the following four straight boundary edges of equal length $h_E = 0.5$:\n$$E_{1} = [0,0.5]\\times\\{0\\} \\subset \\Gamma_{R}, \\quad E_{2} = [0.5,1]\\times\\{0\\} \\subset \\Gamma_{R},$$\n$$E_{3} = \\{1\\}\\times[0,0.5] \\subset \\Gamma_{N}, \\quad E_{4} = \\{1\\}\\times[0.5,1] \\subset \\Gamma_{N}.$$\nOn the single triangle $T_i$ adjacent to each edge $E_i$, the local affine representation of $u_h$ is\n$$u_h(x,y) = c_i + a_i\\, x + b_i\\, y,$$\nwith gradients $\\nabla u_h|_{T_i} = (a_i,b_i)$ given by\n$$(a_1,b_1,c_1) = (0.5,-0.2,1.0), \\quad (a_2,b_2,c_2) = (0.6,0.1,0.8),$$\n$$(a_3,b_3,c_3) = (-0.3,0.4,0.2), \\quad (a_4,b_4,c_4) = (0.1,0.7,-0.1).$$\n\nStarting from the weak formulation and performing elementwise integration by parts, derive the boundary residual terms that appear in a standard residual-based a posteriori error estimator for mixed boundary conditions, identifying the appropriate boundary residuals for Neumann and Robin edges in terms of the data and $u_h$. Then, using your derived expressions, compute the boundary portion of the estimator,\n$$\\eta_{\\partial} := \\left(\\sum_{E \\subset \\Gamma_{N}} h_E \\,\\|g_N - \\kappa\\,\\partial_n u_h\\|_{0,E}^{2} \\;+\\; \\sum_{E \\subset \\Gamma_{R}} h_E \\,\\|g_R - (\\kappa\\,\\partial_n u_h + \\beta\\, u_h)\\|_{0,E}^{2}\\right)^{1/2},$$\nwhere $\\|\\cdot\\|_{0,E}$ denotes the $L^2$ norm on the edge $E$, and $\\partial_n u_h := \\nabla u_h \\cdot \\boldsymbol{n}$.\n\nTake the outward normal $\\boldsymbol{n} = (0,-1)$ on $\\Gamma_{R}$ and $\\boldsymbol{n} = (1,0)$ on $\\Gamma_{N}$. Evaluate the edge integrals exactly by direct computation using the given affine forms of $u_h$ and the data $g_N$, $g_R$. Round your final numerical value of $\\eta_{\\partial}$ to four significant figures. Express your final answer as a pure number (no units).", "solution": "The problem statement is scrutinized and found to be valid. It is scientifically grounded in the theory of a posteriori error estimation for the Finite Element Method, is well-posed with all necessary data provided, and is formulated with objective, precise language. No flaws are detected. We may therefore proceed with the solution.\n\nThe task is twofold: first, to derive the boundary residual terms from the weak formulation of the problem, and second, to compute the numerical value of the boundary error estimator $\\eta_{\\partial}$.\n\nLet the test space $V$ be the Sobolev space of functions with square-integrable first derivatives that vanish on the Dirichlet boundary $\\Gamma_D$, i.e., $V := \\{v \\in H^1(\\Omega) \\mid v|_{\\Gamma_D} = 0\\}$. The weak formulation for the exact solution $u \\in H^1(\\Omega)$ with $u|_{\\Gamma_D} = 0$ is to find $u$ such that for all $v \\in V$:\n$$ \\int_{\\Omega} \\kappa \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} + \\int_{\\Gamma_R} \\beta u v \\, ds = \\int_{\\Omega} f v \\, d\\boldsymbol{x} + \\int_{\\Gamma_N} g_N v \\, ds + \\int_{\\Gamma_R} g_R v \\, ds. $$\nLet this be denoted $a(u,v) = L(v)$. The finite element solution $u_h \\in V_h \\subset V$ is constructed such that it satisfies the Galerkin orthogonality property. The error $e = u - u_h$ satisfies $a(e,v) = a(u,v) - a(u_h,v) = L(v) - a(u_h,v)$ for all $v \\in V$. Expanding this gives:\n$$ a(e,v) = \\int_{\\Omega} f v \\, d\\boldsymbol{x} + \\int_{\\Gamma_N} g_N v \\, ds + \\int_{\\Gamma_R} g_R v \\, ds - \\int_{\\Omega} \\kappa \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} - \\int_{\\Gamma_R} \\beta u_h v \\, ds. $$\nWe apply integration by parts (Green's first identity) on an element-by-element basis to the term involving $\\nabla u_h$:\n$$ \\int_{\\Omega} \\kappa \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} = \\sum_{T} \\int_{T} \\kappa \\nabla u_h \\cdot \\nabla v \\, d\\boldsymbol{x} = \\sum_{T} \\left( \\int_{T} (-\\nabla \\cdot (\\kappa \\nabla u_h)) v \\, d\\boldsymbol{x} + \\int_{\\partial T} (\\kappa \\nabla u_h \\cdot \\boldsymbol{n}_T) v \\, ds \\right). $$\nSince $\\kappa$ is a constant and $u_h$ is piecewise affine, its gradient $\\nabla u_h$ is piecewise constant, thus $\\nabla \\cdot (\\kappa \\nabla u_h) = 0$ inside each element $T$. The error equation becomes:\n$$ a(e,v) = \\int_{\\Omega} f v \\, d\\boldsymbol{x} - \\sum_{T} \\int_{\\partial T} (\\kappa \\partial_n u_h) v \\, ds + \\int_{\\Gamma_N} g_N v \\, ds + \\int_{\\Gamma_R} g_R v \\, ds - \\int_{\\Gamma_R} \\beta u_h v \\, ds. $$\nThe sum over element boundaries $\\partial T$ is split into sums over interior edges $\\mathcal{E}_I$ and boundary edges. The jumps across interior edges give rise to edge residuals, but we are concerned only with the boundary contributions. Collecting the terms on the boundary $\\Gamma = \\Gamma_N \\cup \\Gamma_R$ (since $v=0$ on $\\Gamma_D$), we get:\n$$ a(e,v) = \\dots + \\sum_{E \\subset \\Gamma_N} \\int_E (g_N - \\kappa \\partial_n u_h) v \\, ds + \\sum_{E \\subset \\Gamma_R} \\int_E (g_R - \\kappa \\partial_n u_h - \\beta u_h) v \\, ds. $$\nThis derivation identifies the boundary residuals. For an edge $E \\subset \\Gamma_N$ (Neumann), the residual is $R_N = g_N - \\kappa \\partial_n u_h$. For an edge $E \\subset \\Gamma_R$ (Robin), the residual is $R_R = g_R - (\\kappa \\partial_n u_h + \\beta u_h)$. These are precisely the terms appearing in the definition of $\\eta_{\\partial}$.\n\nNow, we compute the individual terms contributing to $\\eta_{\\partial}^2$. We are given $\\kappa=2$, $\\beta=1$, and $h_E=0.5$ for all edges.\n\n**Edge $E_1 = [0,0.5]\\times\\{0\\} \\subset \\Gamma_R$:**\nThe outward normal is $\\boldsymbol{n} = (0,-1)$. On the adjacent triangle $T_1$, $u_h(x,y) = 1.0 + 0.5x - 0.2y$ and $\\nabla u_h|_{T_1} = (0.5, -0.2)$.\nThe normal derivative part is $\\kappa \\partial_n u_h = \\kappa(\\nabla u_h \\cdot \\boldsymbol{n}) = 2((0.5, -0.2) \\cdot (0,-1)) = 2(0.2) = 0.4$.\nOn $E_1$, $y=0$, so $u_h(x,0) = 1.0 + 0.5x$. The Robin data is $g_R(x) = 2 - x$.\nThe residual is $R_R|_{E_1} = g_R - (\\kappa \\partial_n u_h + \\beta u_h) = (2 - x) - (0.4 + 1 \\cdot (1.0 + 0.5x)) = 0.6 - 1.5x$.\nThe squared $L^2$-norm is $\\|R_R\\|_{0,E_1}^2 = \\int_0^{0.5} (0.6 - 1.5x)^2 dx = \\int_0^{0.5} (0.36 - 1.8x + 2.25x^2) dx = [0.36x - 0.9x^2 + 0.75x^3]_0^{0.5} = 0.36(0.5) - 0.9(0.25) + 0.75(0.125) = 0.18 - 0.225 + 0.09375 = 0.04875$.\nThe contribution to $\\eta_{\\partial}^2$ is $h_{E_1} \\|R_R\\|_{0,E_1}^2 = 0.5 \\times 0.04875 = 0.024375$.\n\n**Edge $E_2 = [0.5,1]\\times\\{0\\} \\subset \\Gamma_R$:**\nThe normal is $\\boldsymbol{n} = (0,-1)$. On $T_2$, $\\nabla u_h|_{T_2} = (0.6, 0.1)$.\n$\\kappa \\partial_n u_h = 2((0.6, 0.1) \\cdot (0,-1)) = 2(-0.1) = -0.2$.\nOn $E_2$, $u_h(x,0) = 0.8 + 0.6x$. The Robin data is $g_R(x) = 2 - x$.\nThe residual is $R_R|_{E_2} = (2 - x) - (-0.2 + 1 \\cdot (0.8 + 0.6x)) = 1.4 - 1.6x$.\n$\\|R_R\\|_{0,E_2}^2 = \\int_{0.5}^1 (1.4 - 1.6x)^2 dx = [ \\frac{(1.4 - 1.6x)^3}{3 \\cdot (-1.6)} ]_{0.5}^1 = -\\frac{1}{4.8} ((-0.2)^3 - (0.6)^3) = -\\frac{1}{4.8} (-0.008 - 0.216) = \\frac{0.224}{4.8} = \\frac{0.14}{3}$.\nThe contribution is $h_{E_2} \\|R_R\\|_{0,E_2}^2 = 0.5 \\times \\frac{0.14}{3} = \\frac{0.07}{3}$.\n\n**Edge $E_3 = \\{1\\}\\times[0,0.5] \\subset \\Gamma_N$:**\nThe outward normal is $\\boldsymbol{n} = (1,0)$. On $T_3$, $\\nabla u_h|_{T_3} = (-0.3, 0.4)$.\n$\\kappa \\partial_n u_h = 2((-0.3, 0.4) \\cdot (1,0)) = 2(-0.3) = -0.6$.\nThe Neumann data is $g_N(y) = 1 + y$.\nThe residual is $R_N|_{E_3} = g_N - \\kappa \\partial_n u_h = (1+y) - (-0.6) = 1.6 + y$.\n$\\|R_N\\|_{0,E_3}^2 = \\int_0^{0.5} (1.6 + y)^2 dy = [ \\frac{(1.6+y)^3}{3} ]_0^{0.5} = \\frac{1}{3} (2.1^3 - 1.6^3) = \\frac{1}{3} (9.261 - 4.096) = \\frac{5.165}{3}$.\nThe contribution is $h_{E_3} \\|R_N\\|_{0,E_3}^2 = 0.5 \\times \\frac{5.165}{3} = \\frac{5.165}{6}$.\n\n**Edge $E_4 = \\{1\\}\\times[0.5,1] \\subset \\Gamma_N$:**\nThe normal is $\\boldsymbol{n} = (1,0)$. On $T_4$, $\\nabla u_h|_{T_4} = (0.1, 0.7)$.\n$\\kappa \\partial_n u_h = 2((0.1, 0.7) \\cdot (1,0)) = 2(0.1) = 0.2$.\nThe Neumann data is $g_N(y) = 1 + y$.\nThe residual is $R_N|_{E_4} = (1+y) - 0.2 = 0.8 + y$.\n$\\|R_N\\|_{0,E_4}^2 = \\int_{0.5}^1 (0.8 + y)^2 dy = [ \\frac{(0.8+y)^3}{3} ]_{0.5}^1 = \\frac{1}{3} (1.8^3 - 1.3^3) = \\frac{1}{3} (5.832 - 2.197) = \\frac{3.635}{3}$.\nThe contribution is $h_{E_4} \\|R_N\\|_{0,E_4}^2 = 0.5 \\times \\frac{3.635}{3} = \\frac{3.635}{6}$.\n\nFinally, we sum the contributions to find $\\eta_{\\partial}^2$:\n$$ \\eta_{\\partial}^2 = 0.024375 + \\frac{0.07}{3} + \\frac{5.165}{6} + \\frac{3.635}{6}. $$\nTo perform exact arithmetic, we convert to fractions:\n$0.024375 = \\frac{24375}{1000000} = \\frac{39}{1600}$.\n$\\frac{0.07}{3} = \\frac{7}{300}$.\n$\\frac{5.165}{6} = \\frac{5165}{6000} = \\frac{1033}{1200}$.\n$\\frac{3.635}{6} = \\frac{3635}{6000} = \\frac{727}{1200}$.\n$$ \\eta_{\\partial}^2 = \\frac{39}{1600} + \\frac{7}{300} + \\frac{1033}{1200} + \\frac{727}{1200} = \\frac{39}{1600} + \\frac{7}{300} + \\frac{1760}{1200} = \\frac{39}{1600} + \\frac{7}{300} + \\frac{22}{15}. $$\nThe least common multiple of the denominators $1600$, $300$, and $15$ is $4800$.\n$$ \\eta_{\\partial}^2 = \\frac{39 \\cdot 3}{4800} + \\frac{7 \\cdot 16}{4800} + \\frac{22 \\cdot 320}{4800} = \\frac{117 + 112 + 7040}{4800} = \\frac{7269}{4800}. $$\nThis fraction can be simplified by dividing numerator and denominator by $3$:\n$$ \\eta_{\\partial}^2 = \\frac{2423}{1600}. $$\nNow we compute the value of $\\eta_{\\partial}$:\n$$ \\eta_{\\partial} = \\sqrt{\\frac{2423}{1600}} = \\frac{\\sqrt{2423}}{40} \\approx \\frac{49.223977896}{40} \\approx 1.2305994474. $$\nRounding to four significant figures gives $1.231$.", "answer": "$$\\boxed{1.231}$$", "id": "2539242"}, {"introduction": "This capstone practice brings together all the concepts into a complete adaptive finite element method (AFEM) implementation. You will move beyond simply computing estimators to using them for their primary purpose: driving an automated `SOLVE -> ESTIMATE -> MARK -> REFINE` loop. By applying this algorithm to a problem with a discontinuous material coefficient, you will witness how the estimator correctly identifies solution singularities and directs mesh refinement to efficiently improve accuracy, the core goal of adaptive analysis. [@problem_id:2539292]", "problem": "Consider the one-dimensional scalar diffusion problem with two materials on the open interval $\\Omega = (0,1)$: find $u:\\overline{\\Omega}\\to\\mathbb{R}$ with homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ such that\n$$\n-\\frac{d}{dx}\\left( k(x)\\,\\frac{du}{dx}(x) \\right) = f(x)\\quad\\text{for }x\\in(0,1),\n$$\nwhere the scalar diffusion coefficient $k(x)$ is piecewise constant with a single jump at the material interface $x_{\\star} = 0.5$, namely $k(x)=k_1$ for $x<x_{\\star}$ and $k(x)=k_2$ for $x>x_{\\star}$. The source $f(x)$ is piecewise smooth and, in the tests below, is a constant function. Work in the Sobolev space $H_0^1(\\Omega)$ and use the standard Galerkin finite element method with continuous, piecewise affine (linear) shape functions on a conforming partition of $\\Omega$ into closed intervals.\n\nYour task is to implement an adaptive finite element algorithm driven by a residual-based a posteriori error indicator that is consistent with the following fundamental principles and core definitions:\n\n- The weak formulation is: find $u\\in H_0^1(\\Omega)$ such that for all $v\\in H_0^1(\\Omega)$,\n$$\n\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx.\n$$\n\n- The continuous residual is defined as $R(v) = \\int_0^1 \\left(f(x) + (k(x)u_h'(x))'\\right)v(x)\\,dx$, where $u_h$ is the finite element solution. Using integration by parts on each element and the continuity of $v$, this residual splits into element contributions from the bulk equilibrium and interelement contributions from the jumps of the discrete flux across interior nodes.\n\n- A residual-based a posteriori error indicator per element must be constructed from the above weak residual decomposition and must include both a bulk term that scales with the element size and the $L^2$-magnitude of the strong residual over the element, and an edge term that scales with the element size and the magnitude of the jump of the discrete normal flux across the element’s endpoints (interior nodes).\n\n- Mesh refinement must be conducted by marking elements via a bulk-chasing strategy (also known as Dörfler marking): given a parameter $\\theta\\in(0,1)$, select a minimal set of elements whose indicators (in a suitable nonnegative aggregation) account for at least a fraction $\\theta$ of the global sum. Refine all marked elements by bisecting them.\n\nStarting from a conforming initial mesh of $\\Omega$, implement an adaptive loop that repeatedly:\n$\\,$(i) assembles and solves the linear system for $u_h$, $\\,$(ii) computes the elementwise residual-based indicators consistent with the principles above, $\\,$(iii) marks elements by the bulk-chasing criterion with parameter $\\theta$, and $\\,$(iv) refines all marked elements by bisection. After a prescribed number of adaptive iterations $L$, quantify the concentration of refinement along the material interface by computing the fraction of the elements marked in the last iteration that intersect the interface neighborhood $[x_{\\star}-\\delta,\\,x_{\\star}+\\delta]$. Declare that refinement is concentrated along the interface if and only if this fraction is greater than or equal to a given threshold $\\alpha$.\n\nImplementation requirements:\n- Use piecewise affine shape functions and exact or sufficiently accurate numerical quadrature for element integrals; the numerical procedure must be consistent with the weak formulation stated above.\n- The residual-based indicator must reflect both bulk equilibrium residuals and discrete flux jumps; its construction must be derived from the weak form and integration by parts, not from any ad hoc rule.\n- Use homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$.\n\nTest suite:\nFor each test, the parameters are the pair $(k_1,k_2)$, the constant source value $c$ with $f(x)\\equiv c$, the number of adaptive iterations $L$, the bulk-chasing parameter $\\theta$, the interface neighborhood half-width $\\delta$, the decision threshold $\\alpha$, and a boolean flag that determines the initial mesh layout. If the flag “align” is true, the initial mesh is the two-element mesh with nodes at $x=0$, $x=0.5$, and $x=1$. If the flag is false, the initial mesh is the three-element mesh with nodes at $x=0$, $x=1/3$, $x=2/3$, and $x=1$.\n\nProvide results for the following four test cases:\n- Test $1$: $(k_1,k_2)=(1,10)$, $c=1$, $L=5$, $\\theta=0.5$, $\\delta=0.1$, $\\alpha=0.6$, align $=\\,$false.\n- Test $2$: $(k_1,k_2)=(1,1000)$, $c=1$, $L=4$, $\\theta=0.5$, $\\delta=0.08$, $\\alpha=0.6$, align $=\\,$false.\n- Test $3$: $(k_1,k_2)=(1,1)$, $c=1$, $L=4$, $\\theta=0.5$, $\\delta=0.08$, $\\alpha=0.6$, align $=\\,$false.\n- Test $4$: $(k_1,k_2)=(0.01,1)$, $c=1$, $L=5$, $\\theta=0.5$, $\\delta=0.08$, $\\alpha=0.6$, align $=\\,$true.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests above, where each entry is a boolean indicating whether refinement concentrates at the interface according to the rule stated. For example, an output could be of the form “[True,False,True,True]”. No other text should be printed.", "solution": "The problem presented is a well-defined task in the field of numerical analysis for partial differential equations, specifically concerning the adaptive finite element method (FEM) for a one-dimensional diffusion problem.\n\nThe problem is validated as follows:\n- **Givens**: All necessary components are provided: the governing differential equation $-\\frac{d}{dx}(k(x) \\frac{du}{dx}) = f(x)$, the domain $\\Omega=(0,1)$, homogeneous Dirichlet boundary conditions, a piecewise constant diffusion coefficient $k(x)$ with a jump at $x_{\\star}=0.5$, a constant source term $f(x)=c$, the weak formulation, and the core principles for constructing a residual-based a posteriori error indicator. The adaptive strategy, including Dörfler marking and bisection refinement, is clearly specified. The test suite provides all necessary parameters $(k_1, k_2, c, L, \\theta, \\delta, \\alpha)$ and initial mesh configurations.\n- **Validation Verdict**: The problem is **valid**. It is scientifically sound, resting on the established theory of FEM and a posteriori error estimation. It is well-posed, objective, complete, and computationally feasible. The task requires deriving a specific algorithm from first principles and implementing it, which is a standard and non-trivial exercise in scientific computing.\n\nThe solution proceeds by first formalizing the a posteriori error indicator, then outlining the adaptive algorithm, and finally implementing it to solve the given test cases.\n\n### Mathematical Formulation\n\n**1. Finite Element Discretization**\nWe use continuous, piecewise linear finite elements on a mesh $\\mathcal{T}_h = \\{T_i\\}$ of $\\Omega=(0,1)$, where each element $T_i$ is a closed interval $[x_{i-1}, x_i]$. The finite element solution $u_h$ is sought in the space $V_h \\subset H_0^1(\\Omega)$ of continuous piecewise linear functions vanishing at $x=0$ and $x=1$. The Galerkin formulation is to find $u_h \\in V_h$ such that for all $v_h \\in V_h$:\n$$\na(u_h, v_h) := \\int_0^1 k(x) u_h'(x) v_h'(x) dx = \\int_0^1 f(x) v_h(x) dx\n$$\nThis leads to a linear system of equations $AU=b$, where $U$ is the vector of nodal values of $u_h$ at interior nodes.\n\nFor an element $T_i = [x_{i-1}, x_i]$ of length $h_i = x_i - x_{i-1}$, the element stiffness matrix and load vector are computed. The coefficient $k(x)$ is approximated as a piecewise constant function $k_h$ on the mesh, with $k_h|_{T_i} = k((x_{i-1}+x_i)/2)$. With $f(x)=c$, this gives:\n$$\nA^{(i)} = \\frac{k_h|_{T_i}}{h_i} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad b^{(i)} = \\frac{c h_i}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n\n**2. Residual-Based A Posteriori Error Indicator**\nThe error $e=u-u_h$ satisfies the a posteriori error relation derived from the weak residual. For any $v \\in H_0^1(\\Omega)$:\n$$\na(e,v) = \\int_0^1 f v dx - \\int_0^1 k u_h' v' dx = \\sum_{T \\in \\mathcal{T}_h} \\left( \\int_T f v dx - \\int_T k u_h' v' dx \\right)\n$$\nIntegrating by parts element-wise and rearranging terms yields a representation of the error in terms of element residuals and flux jumps. The squared energy norm of the error is bounded by a sum of squared local error indicators, $\\eta_T^2$. A standard form for the local indicator on an element $T_i=[x_{i-1}, x_i]$, consistent with the problem's principles, is composed of a bulk term and edge (jump) terms:\n$$\n\\eta_{T_i}^2 = h_i^2 \\| f + (k_h u_h')' \\|_{L^2(T_i)}^2 + \\frac{1}{2}h_i |J_{i-1}|^2 + \\frac{1}{2}h_i |J_{i}|^2\n$$\nHere, since $u_h$ is linear and $k_h$ is constant on $T_i$, the strong residual $(k_h u_h')'$ vanishes. The jump $J_i$ at an interior node $x_i$ is the jump in the discrete flux:\n$$\nJ_i = [k_h u_h']_{x_i} = (k_h u_h')|_{T_{i+1}} - (k_h u_h')|_{T_i}\n$$\nFor boundary nodes, the jump is zero. With $f(x)=c$, the indicator simplifies to:\n$$\n\\eta_{T_i}^2 = h_i^2 \\int_{x_{i-1}}^{x_i} c^2 dx + \\frac{1}{2}h_i (J_{i-1}^2 + J_i^2) = c^2 h_i^3 + \\frac{1}{2}h_i (J_{i-1}^2 + J_i^2)\n$$\nThis form scales appropriately and is used to guide the mesh refinement.\n\n### Adaptive Algorithm\n\nThe adaptive loop proceeds for a prescribed number of iterations $L$. In each iteration:\n1.  **Solve**: Given the current mesh (a sorted array of nodes), assemble the global stiffness matrix $A$ and load vector $b$. Apply homogeneous Dirichlet boundary conditions by reducing the system to interior nodes. Solve the linear system for the nodal values $U$ of the FEM solution $u_h$.\n2.  **Estimate**: Compute the element-wise error indicators $\\eta_{T_i}^2$ for all elements $T_i$ in the mesh using the formula derived above. This requires calculating the derivative $u_h'$ on each element and then the flux jumps $J_i$ at each interior node.\n3.  **Mark**: Employ Dörfler's marking strategy. Calculate the total indicator sum $\\mathcal{E}^2 = \\sum_i \\eta_{T_i}^2$. Sort elements in descending order of their indicator values. Mark a minimal set of elements $\\mathcal{M}$ such that $\\sum_{T \\in \\mathcal{M}} \\eta_T^2 \\ge \\theta \\mathcal{E}^2$.\n4.  **Refine**: Generate a new mesh by bisecting every marked element. The new set of nodes is formed by adding the midpoints of all marked elements to the existing set of nodes.\n\nAfter $L$ iterations, the set of elements marked in the final step, $\\mathcal{M}_L$, is analyzed. We compute the fraction of elements in $\\mathcal{M}_L$ that intersect the neighborhood $[x_{\\star}-\\delta, x_{\\star}+\\delta]$ of the material interface. An element $[x_{i-1}, x_i]$ intersects this neighborhood if $x_i > x_{\\star}-\\delta$ and $x_{i-1} < x_{\\star}+\\delta$. If this fraction is greater than or equal to the threshold $\\alpha$, the refinement is considered concentrated at the interface.\n\nThis procedure constitutes a complete algorithm to solve the problem and evaluate the test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the adaptive finite element problem.\n    \"\"\"\n    test_cases = [\n        # Test 1: (k1, k2)=(1,10), c=1, L=5, theta=0.5, delta=0.1, alpha=0.6, align=false.\n        (1, 10, 1, 5, 0.5, 0.1, 0.6, False),\n        # Test 2: (k1, k2)=(1,1000), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6, align=false.\n        (1, 1000, 1, 4, 0.5, 0.08, 0.6, False),\n        # Test 3: (k1, k2)=(1,1), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6, align=false.\n        (1, 1, 1, 4, 0.5, 0.08, 0.6, False),\n        # Test 4: (k1, k2)=(0.01,1), c=1, L=5, theta=0.5, delta=0.08, alpha=0.6, align=true.\n        (0.01, 1, 1, 5, 0.5, 0.08, 0.6, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_adaptive_fem(*case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_adaptive_fem(k1, k2, c, L, theta, delta, alpha, align_flag):\n    \"\"\"\n    Executes the adaptive FEM for a single test case.\n    \"\"\"\n    x_star = 0.5\n\n    def k_func(x):\n        # Per problem, k(x) jumps at x_star.\n        # k(x) = k1 for x = x_star, k2 for x > x_star.\n        if np.isscalar(x):\n            return k1 if x = x_star else k2\n        return np.where(x = x_star, k1, k2)\n\n    # Initial mesh setup\n    if align_flag:\n        nodes = np.array([0.0, 0.5, 1.0])\n    else:\n        nodes = np.array([0.0, 1.0/3.0, 2.0/3.0, 1.0])\n\n    marked_indices = []\n    # nodes_on_which_marking_was_done will store the mesh state\n    # before the final refinement, which is used for the analysis.\n    nodes_on_which_marking_was_done = nodes\n\n    for _ in range(L):\n        nodes_on_which_marking_was_done = np.copy(nodes)\n        num_nodes = len(nodes)\n        num_elements = num_nodes - 1\n        h = np.diff(nodes)\n        \n        num_unknowns = num_nodes - 2\n        if num_unknowns = 0:\n            marked_indices = list(range(num_elements))\n            # Refine all elements if no system to solve\n            new_nodes_set = set(nodes)\n            for idx in marked_indices:\n                new_node = (nodes[idx] + nodes[idx+1]) / 2.0\n                new_nodes_set.add(new_node)\n            nodes = np.array(sorted(list(new_nodes_set)))\n            continue\n\n        # Assemble stiffness matrix A and load vector b for interior nodes\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        element_midpoints = nodes[:-1] + h / 2.0\n        k_h = k_func(element_midpoints)\n\n        # Diagonal entries for A\n        diag = k_h[:-1] / h[:-1] + k_h[1:] / h[1:]\n        np.fill_diagonal(A, diag)\n        \n        # Off-diagonal entries for A\n        off_diag = -k_h[1:-1] / h[1:-1]\n        np.fill_diagonal(A[1:], off_diag)\n        np.fill_diagonal(A[:, 1:], off_diag)\n        \n        # Load vector b\n        b[:] = c * (h[:-1] + h[1:]) / 2.0\n\n        # Solve linear system AU=b for interior nodal values\n        try:\n            U_interior = scipy.linalg.solve(A, b, assume_a='sym')\n        except np.linalg.LinAlgError:\n            # Fallback for singular matrix\n            U_interior = np.zeros(num_unknowns)\n\n        U = np.concatenate(([0.0], U_interior, [0.0]))\n\n        # Compute a posteriori error indicators\n        u_h_deriv = np.diff(U) / h\n        flux = k_h * u_h_deriv\n        jumps = flux[1:] - flux[:-1]\n        full_jumps = np.concatenate(([0.0], jumps, [0.0]))\n\n        indicators_sq = np.zeros(num_elements)\n        for i in range(num_elements):\n            h_i = h[i]\n            # Jump contribution from left and right nodes of element i\n            J_left_sq = full_jumps[i]**2\n            J_right_sq = full_jumps[i+1]**2\n            \n            bulk_term = (c**2) * (h_i**3)\n            jump_term = 0.5 * h_i * (J_left_sq + J_right_sq)\n            indicators_sq[i] = bulk_term + jump_term\n            \n        # Dörfler (bulk-chasing) marking\n        total_indicator_sq_sum = np.sum(indicators_sq)\n        if total_indicator_sq_sum  1e-18:\n            marked_indices = []\n        else:\n            sorted_indices = np.argsort(indicators_sq)[::-1]\n            cumulative_sum = 0.0\n            marked_indices = []\n            for idx in sorted_indices:\n                marked_indices.append(idx)\n                cumulative_sum += indicators_sq[idx]\n                if cumulative_sum >= theta * total_indicator_sq_sum:\n                    break\n        \n        # Refine mesh by bisecting marked elements\n        new_nodes_set = set(nodes)\n        for idx in marked_indices:\n            new_node = (nodes[idx] + nodes[idx+1]) / 2.0\n            new_nodes_set.add(new_node)\n        nodes = np.array(sorted(list(new_nodes_set)))\n\n    # Final analysis on the last set of marked elements\n    if not marked_indices:\n        return False\n        \n    num_marked = len(marked_indices)\n    num_intersecting = 0\n    neighborhood_min = x_star - delta\n    neighborhood_max = x_star + delta\n    \n    for idx in marked_indices:\n        elem_left = nodes_on_which_marking_was_done[idx]\n        elem_right = nodes_on_which_marking_was_done[idx+1]\n        \n        # Check for non-empty intersection of interval (elem_left, elem_right)\n        # with [neighborhood_min, neighborhood_max]\n        if elem_right > neighborhood_min and elem_left  neighborhood_max:\n            num_intersecting += 1\n            \n    fraction = num_intersecting / num_marked if num_marked > 0 else 0.0\n    \n    return fraction >= alpha\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2539292"}]}