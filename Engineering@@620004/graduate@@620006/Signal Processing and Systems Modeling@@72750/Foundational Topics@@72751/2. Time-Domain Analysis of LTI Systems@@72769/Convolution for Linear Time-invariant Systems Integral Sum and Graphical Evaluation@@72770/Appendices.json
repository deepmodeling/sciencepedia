{"hands_on_practices": [{"introduction": "The best way to develop a deep understanding of convolution is to build it from the ground up. This first practice focuses on the graphical \"flip-and-slide\" method for discrete-time signals, which is a direct visual representation of the convolution sum formula [@problem_id:2862227]. By manually tracing the interaction between the input signal and the time-reversed impulse response, you will gain a concrete intuition for how an LTI system's output is generated one sample at a time.", "problem": "Consider a discrete-time Linear Time-Invariant (LTI) system whose input is a finite-length sequence $x[n]$ and whose impulse response is a finite-length sequence $h[n]$. The only permitted foundational facts to use are: (i) superposition of shifted unit impulses expresses any discrete-time signal $x[n]$ as $x[n]=\\sum_{k \\in \\mathbb{Z}} x[k]\\,\\delta[n-k]$, where $\\delta[n]$ is the Kronecker delta, and (ii) time invariance implies that the response to $\\delta[n-k]$ is $h[n-k]$. From these, one may conclude how to compute the output $y[n]$ of an LTI system. Using solely this logical chain and the “flip-and-slide” graphical interpretation that follows from it, evaluate $y[n]$ for the specific finite sequences\n$x[n]$ and $h[n]$ defined by\n$x[n]=1$ for $n \\in \\{0,1,2\\}$ and $x[n]=0$ otherwise, but with the middle sample scaled so that $x[1]=2$, and\n$h[n]=1$ for $n \\in \\{0,1\\}$ and $h[n]=0$ otherwise.\nThat is, $x[n]$ has samples $\\{1,2,1\\}$ at indices $n \\in \\{0,1,2\\}$ and $h[n]$ has samples $\\{1,1\\}$ at indices $n \\in \\{0,1\\}$. Perform the evaluation by explicitly forming the reversed kernel $h[-k]$ and sliding it across $x[k]$ to compute $y[n]$ as an inner product at each shift $n$, making clear the support constraints at each step that determine which terms contribute. Report the nonzero samples of $y[n]$ in increasing $n$ as a single row vector of values corresponding to successive integer $n$. No transform-domain shortcuts or pre-memorized convolution-length formulas may be used in the derivation; rely only on the fundamental definitions stated above and the graphical “flip-and-slide” evaluation that follows from them. The final answer must be the row vector of samples only, with no indices or units.", "solution": "The problem statement is subjected to validation before any attempt at a solution.\n\n### Step 1: Extract Givens\n-   **System Type**: Discrete-time Linear Time-Invariant (LTI) system.\n-   **Input Signal**: $x[n]$ is a finite-length sequence defined by $x[n]=1$ for $n \\in \\{0, 1, 2\\}$ and $x[n]=0$ otherwise, with the modification $x[1]=2$. This specifies the sequence samples as $\\{1, 2, 1\\}$ for $n \\in \\{0, 1, 2\\}$.\n-   **Impulse Response**: $h[n]$ is a finite-length sequence defined by $h[n]=1$ for $n \\in \\{0, 1\\}$ and $h[n]=0$ otherwise. This specifies the sequence samples as $\\{1, 1\\}$ for $n \\in \\{0, 1\\}$.\n-   **Foundational Principles**:\n    1.  Any discrete-time signal $x[n]$ can be expressed as a superposition of shifted unit impulses: $x[n]=\\sum_{k \\in \\mathbb{Z}} x[k]\\,\\delta[n-k]$, where $\\delta[n]$ is the Kronecker delta.\n    2.  For an LTI system, the response to a shifted impulse $\\delta[n-k]$ is the shifted impulse response $h[n-k]$.\n-   **Required Method**: The output $y[n]$ must be evaluated using the \"flip-and-slide\" graphical interpretation derived from the foundational principles. This involves explicitly forming the reversed kernel $h[-k]$ and sliding it across $x[k]$ to compute $y[n]$ as an inner product for each shift $n$.\n-   **Constraints**: No transform-domain methods or pre-memorized formulas (e.g., for the length of the convolved sequence) may be used. The derivation must rely solely on the provided principles.\n-   **Output Format**: Report the nonzero samples of $y[n]$ as a single row vector.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is found to be valid based on the following criteria:\n-   **Scientifically Grounded**: The problem is a standard exercise in linear systems theory, based on the fundamental definition of discrete convolution. All principles provided are correct and central to the field of signal processing.\n-   **Well-Posed**: The input signal $x[n]$ and the impulse response $h[n]$ are unambiguously defined. The task is to compute their convolution, which is a well-defined mathematical operation with a unique result for the given finite-length sequences.\n-   **Objective**: The problem is stated using precise mathematical language, free from subjectivity or ambiguity.\n-   **Completeness**: All necessary information to solve the problem is provided.\n-   **Consistency**: There are no contradictions in the problem statement. The constraints on the solution method are restrictive but consistent with a pedagogical goal of reinforcing first principles.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution will now be derived.\n\nThe output $y[n]$ of an LTI system with impulse response $h[n]$ to an input $x[n]$ is determined by applying the principles of linearity and time-invariance. First, the input signal is decomposed into a sum of scaled and shifted unit impulses, as given:\n$$x[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\delta[n-k]$$\nLet the system be represented by the operator $L\\{\\cdot\\}$. The output is $y[n] = L\\{x[n]\\}$. By the property of linearity, the operator can be distributed over the summation and the constant coefficients $x[k]$:\n$$y[n] = L\\left\\{\\sum_{k=-\\infty}^{\\infty} x[k] \\delta[n-k]\\right\\} = \\sum_{k=-\\infty}^{\\infty} x[k] L\\{\\delta[n-k]\\}$$\nThe response of the system to a unit impulse $\\delta[n]$ is the impulse response $h[n] = L\\{\\delta[n]\\}$. By the property of time-invariance, the response to a time-shifted impulse $\\delta[n-k]$ is a similarly time-shifted impulse response, $h[n-k] = L\\{\\delta[n-k]\\}$. Substituting this into the expression for $y[n]$ yields the discrete convolution sum:\n$$y[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]$$\nThis formula prescribes the method for computing the output sample at each time index $n$. It is an inner product over the index $k$ of the input signal $x[k]$ and the time-reversed, shifted impulse response $h[n-k]$. This is the basis of the \"flip-and-slide\" evaluation method.\n\nThe specific signals are given:\n-   The input signal $x[k]$ has non-zero values $x[0]=1$, $x[1]=2$, and $x[2]=1$. The support of $x[k]$ is the set of indices $\\{0, 1, 2\\}$.\n-   The impulse response $h[k]$ has non-zero values $h[0]=1$ and $h[1]=1$. The support of $h[k]$ is the set of indices $\\{0, 1\\}$.\n\nWe evaluate $y[n]$ for each integer value of $n$ by performing the following steps:\n1.  **Flip**: The impulse response $h[k]$ is time-reversed to obtain $h[-k]$. The sample $h[0]=1$ remains at index $k=0$, and the sample $h[1]=1$ moves to index $k=-1$. So, $h[-k]$ has non-zero values at $k \\in \\{-1, 0\\}$.\n2.  **Slide**: The flipped sequence $h[-k]$ is shifted by $n$ to obtain $h[n-k]$. Since the non-zero values of $h[m]$ are for $m \\in \\{0,1\\}$, the non-zero values for $h[n-k]$ occur when $n-k=0$ and $n-k=1$. This means $k=n$ and $k=n-1$. The support of $h[n-k]$ as a function of $k$ is the set $\\{n-1, n\\}$.\n3.  **Multiply and Sum**: For each $n$, the product $x[k]h[n-k]$ is formed and summed over all $k$. The sum will be non-zero only if the supports of $x[k]$ and $h[n-k]$ have a non-empty intersection. The support of $x[k]$ is $\\{0, 1, 2\\}$, and the support of $h[n-k]$ is $\\{n-1, n\\}$. Overlap exists only for values of $n$ where $\\{0, 1, 2\\} \\cap \\{n-1, n\\} \\neq \\emptyset$. This condition holds for $n$ from $0$ to $3$. For all other $n$, the output $y[n]$ is zero. We now compute the non-zero values.\n\n-   **For $n=0$**:\n    The support of $h[0-k] = h[-k]$ is $\\{-1, 0\\}$. The intersection with the support of $x[k]$ is $\\{0\\}$.\n    $$y[0] = \\sum_{k=-\\infty}^{\\infty} x[k] h[-k] = \\dots + x[-1]h[1] + x[0]h[0] + x[1]h[-1] + \\dots$$\n    The only non-zero term in the sum is for $k=0$.\n    $$y[0] = x[0]h[0] = (1)(1) = 1$$\n\n-   **For $n=1$**:\n    The support of $h[1-k]$ is $\\{0, 1\\}$. The intersection with the support of $x[k]$ is $\\{0, 1\\}$.\n    $$y[1] = \\sum_{k=-\\infty}^{\\infty} x[k] h[1-k] = x[0]h[1] + x[1]h[0]$$\n    $$y[1] = (1)(1) + (2)(1) = 1 + 2 = 3$$\n\n-   **For $n=2$**:\n    The support of $h[2-k]$ is $\\{1, 2\\}$. The intersection with the support of $x[k]$ is $\\{1, 2\\}$.\n    $$y[2] = \\sum_{k=-\\infty}^{\\infty} x[k] h[2-k] = x[1]h[1] + x[2]h[0]$$\n    $$y[2] = (2)(1) + (1)(1) = 2 + 1 = 3$$\n\n-   **For $n=3$**:\n    The support of $h[3-k]$ is $\\{2, 3\\}$. The intersection with the support of $x[k]$ is $\\{2\\}$.\n    $$y[3] = \\sum_{k=-\\infty}^{\\infty} x[k] h[3-k] = x[2]h[1]$$\n    $$y[3] = (1)(1) = 1$$\n\n-   **For $n \\ge 4$**:\n    The support of $h[n-k]$ is $\\{n-1, n\\}$. Since $n \\ge 4$, $n-1 \\ge 3$. The intersection with the support of $x[k]$, which is $\\{0, 1, 2\\}$, is empty. Therefore, $y[n] = 0$ for all $n \\ge 4$.\n\n-   **For $n < 0$**:\n    The support of $h[n-k]$ is $\\{n-1, n\\}$. Since $n < 0$, both $n-1$ and $n$ are less than $0$. The intersection with the support of $x[k]$ is empty. Therefore, $y[n] = 0$ for all $n < 0$.\n\nThe resulting output sequence $y[n]$ has non-zero samples for $n \\in \\{0, 1, 2, 3\\}$. The sequence of samples is $y[0]=1$, $y[1]=3$, $y[2]=3$, and $y[3]=1$. The required output is the row vector of these values.", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 3 & 3 & 1 \\end{pmatrix}}$$", "id": "2862227"}, {"introduction": "Having established the mechanics in the discrete domain, we now transition to continuous-time systems. This exercise challenges you to compute the convolution of a ramp signal with a rectangular pulse, bridging the intuitive graphical method with a formal analytical evaluation using the convolution integral [@problem_id:2862220]. This practice is crucial for understanding how the overlapping regions of the two functions define the piecewise structure of the output signal, a key characteristic of convolution with finite-duration signals.", "problem": "A continuous-time, linear time-invariant (LTI) system has impulse response given by the rectangular pulse $h(t) = u(t) - u(t-1)$, where $u(t)$ is the unit step function. The input is the ramp $x(t) = t\\,u(t)$. Let $(x*h)(t)$ denote the convolution of $x(t)$ and $h(t)$.\n\nStarting only from the definition of convolution for continuous-time LTI systems and the definition of the unit step function, do the following:\n\n1) Using a graphical flip-and-shift argument based on the support of $h(t-\\tau)$ and the overlap with $x(\\tau)$, determine $(x*h)(t)$ for all real $t$ by evaluating the integral directly over the range where the product $x(\\tau)\\,h(t-\\tau)$ does not vanish. Your reasoning should explicitly identify the intervals of $t$ that lead to distinct expressions for the convolution.\n\n2) Re-derive $(x*h)(t)$ analytically from the same convolution definition by employing integration by parts with respect to $\\tau$, where the antiderivative of $h(\\cdot)$ with respect to its argument is used. Treat the unit step and its distributional derivatives carefully, and justify the boundary terms.\n\n3) Express your final result as a single closed-form analytic expression in terms of $t$ and $u(\\cdot)$ that is valid for all real $t$. Do not use any pre-tabulated convolution pairs. No numerical rounding is required. The final answer must be written as a single analytic expression.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It presents a standard task in linear systems theory, free of contradictions or ambiguities. We may therefore proceed with the solution.\n\nThe convolution of an input signal $x(t)$ with a system's impulse response $h(t)$ is defined as:\n$$ y(t) = (x*h)(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau $$\nThe given functions are the input signal $x(t) = t\\,u(t)$ and the impulse response $h(t) = u(t) - u(t-1)$. Here, $u(t)$ is the unit step function, defined as $u(t) = 1$ for $t \\ge 0$ and $u(t) = 0$ for $t < 0$.\n\nThe function $x(\\tau) = \\tau u(\\tau)$ is a ramp starting at $\\tau=0$. It is zero for $\\tau < 0$ and equal to $\\tau$ for $\\tau \\ge 0$.\nThe function $h(\\tau) = u(\\tau) - u(\\tau-1)$ is a rectangular pulse of unit amplitude over the interval $[0, 1)$.\n\nWe will solve the problem in three parts as requested.\n\n**1) Graphical Flip-and-Shift Evaluation**\n\nTo evaluate the convolution integral, we first find the function $h(t-\\tau)$. This is obtained by time-reversing $h(\\tau)$ to get $h(-\\tau)$, which is a rectangular pulse on the interval $(-1, 0]$, and then shifting it by $t$. Thus, $h(t-\\tau)$ is a rectangular pulse of unit amplitude on the interval $(t-1, t]$. The integral becomes non-zero only where the support of $x(\\tau)$ (which is $\\tau \\ge 0$) and the support of $h(t-\\tau)$ (which is $t-1 < \\tau \\le t$) overlap. We analyze the product $x(\\tau)h(t-\\tau)$ for different ranges of the shift parameter $t$.\n\nCase 1: $t < 0$\nThe interval $(t-1, t]$ is entirely in the negative $\\tau$-axis. Since $x(\\tau) = 0$ for all $\\tau < 0$, the product $x(\\tau)h(t-\\tau)$ is zero for all $\\tau$.\n$$ y(t) = \\int_{-\\infty}^{\\infty} 0 \\, d\\tau = 0 $$\n\nCase 2: $0 \\le t < 1$\nThe interval $(t-1, t]$ partially overlaps with the non-zero region of $x(\\tau)$. The lower limit $t-1$ is negative or zero, and the upper limit $t$ is in $[0, 1)$. The overlap occurs for $\\tau \\in [0, t]$. In this interval, $x(\\tau) = \\tau$ and $h(t-\\tau) = 1$.\n$$ y(t) = \\int_{0}^{t} \\tau \\cdot 1 \\, d\\tau = \\left[ \\frac{1}{2}\\tau^{2} \\right]_{0}^{t} = \\frac{1}{2}t^{2} $$\n\nCase 3: $t \\ge 1$\nThe interval $(t-1, t]$ is now entirely in the non-negative $\\tau$-axis, since $t-1 \\ge 0$. The overlap occurs for the full width of the pulse, $\\tau \\in [t-1, t]$. Over this interval, $x(\\tau) = \\tau$ and $h(t-\\tau)=1$.\n$$ y(t) = \\int_{t-1}^{t} \\tau \\cdot 1 \\, d\\tau = \\left[ \\frac{1}{2}\\tau^{2} \\right]_{t-1}^{t} = \\frac{1}{2}\\left( t^{2} - (t-1)^{2} \\right) = \\frac{1}{2}\\left( t^{2} - (t^{2} - 2t + 1) \\right) = \\frac{1}{2}(2t - 1) = t - \\frac{1}{2} $$\n\nCombining these results gives the piecewise expression for the convolution:\n$$ y(t) = \\begin{cases} 0 & \\text{for } t < 0 \\\\ \\frac{1}{2}t^{2} & \\text{for } 0 \\le t < 1 \\\\ t - \\frac{1}{2} & \\text{for } t \\ge 1 \\end{cases} $$\n\n**2) Analytical Derivation using Integration by Parts**\n\nWe now re-derive the result using integration by parts on the convolution integral:\n$$ y(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau $$\nLet $U = x(\\tau)$ and $dV = h(t-\\tau)d\\tau$. Then $dU = x'(\\tau)d\\tau$ and $V = \\int h(t-\\tau)d\\tau$.\nThe derivative of the input signal is $x'(t) = \\frac{d}{dt}(t\\,u(t)) = 1 \\cdot u(t) + t \\cdot \\delta(t)$. Using the sifting property, $t\\,\\delta(t) = 0 \\cdot \\delta(t) = 0$, so $x'(\\tau) = u(\\tau)$.\nFor the integral $V$, let $s = t-\\tau$, which implies $d\\tau = -ds$.\n$$ V(\\tau) = \\int h(t-\\tau)d\\tau = \\int h(s)(-ds) = - \\int h(s)ds $$\nLet $H(s) = \\int_{-\\infty}^{s} h(\\lambda)d\\lambda$. Then $V(\\tau) = -H(t-\\tau)$. The function $H(s)$ is the integral of the rectangular pulse $h(s) = u(s) - u(s-1)$:\n$$ H(s) = \\int_{-\\infty}^{s} (u(\\lambda) - u(\\lambda-1))d\\lambda = s\\,u(s) - (s-1)u(s-1) $$\nThis function $H(s)$ is a triangular pulse: it is $s$ for $0 \\le s < 1$, $1$ for $s \\ge 1$, and $0$ for $s < 0$.\n\nApplying the integration by parts formula $\\int U dV = [UV] - \\int V dU$:\n$$ y(t) = \\left[ x(\\tau) \\cdot (-H(t-\\tau)) \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} (-H(t-\\tau)) x'(\\tau) d\\tau $$\n$$ y(t) = - \\left[ x(\\tau)H(t-\\tau) \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} H(t-\\tau) u(\\tau) d\\tau $$\nWe must evaluate the boundary term. The product $x(\\tau)H(t-\\tau) = (\\tau u(\\tau)) H(t-\\tau)$ is non-zero only where both functions are non-zero. This requires $\\tau \\ge 0$ and $t-\\tau \\ge 0$, i.e., $0 \\le \\tau \\le t$. Outside this finite interval, the product is identically zero. Therefore, the boundary term evaluated at $\\tau \\to \\pm\\infty$ is zero.\n\nThe convolution is simplified to:\n$$ y(t) = \\int_{-\\infty}^{\\infty} H(t-\\tau) u(\\tau) d\\tau = \\int_{0}^{\\infty} H(t-\\tau) d\\tau $$\nThis integral can be evaluated by a change of variable. Let $s = t-\\tau$, so $d\\tau = -ds$. When $\\tau=0$, $s=t$. As $\\tau \\to \\infty$, $s \\to -\\infty$.\n$$ y(t) = \\int_{t}^{-\\infty} H(s)(-ds) = \\int_{-\\infty}^{t} H(s) ds $$\nSo, the output $y(t)$ is the area under the triangular pulse $H(s)$ from $-\\infty$ to $t$. We can compute this by integrating $H(s)$ piece by piece. Recalling $H(s)$ is $0$ for $s<0$, $s$ for $0 \\le s < 1$, and $1$ for $s \\ge 1$:\n- If $t<0$: $y(t) = \\int_{-\\infty}^{t} 0 \\, ds = 0$.\n- If $0 \\le t < 1$: $y(t) = \\int_{-\\infty}^{0} 0 \\, ds + \\int_{0}^{t} s \\, ds = \\left[ \\frac{1}{2}s^{2} \\right]_{0}^{t} = \\frac{1}{2}t^{2}$.\n- If $t \\ge 1$: $y(t) = \\int_{0}^{1} s \\, ds + \\int_{1}^{t} 1 \\, ds = \\left[ \\frac{1}{2}s^{2} \\right]_{0}^{1} + \\left[ s \\right]_{1}^{t} = \\frac{1}{2} + (t-1) = t - \\frac{1}{2}$.\nThese results are identical to the graphical method.\n\nAlternatively, we can write $y(t) = \\int_{-\\infty}^{t} H(s)ds$ using singularity functions.\n$$ y(t) = \\int_{-\\infty}^{t} (s\\,u(s) - (s-1)u(s-1)) ds = \\int_{-\\infty}^{t} s\\,u(s)\\,ds - \\int_{-\\infty}^{t} (s-1)u(s-1)\\,ds $$\nRecognizing that the integral of the ramp function $r(t)=t\\,u(t)$ is the parabolic function $p(t)=\\frac{1}{2}t^{2}u(t)$, the expression becomes:\n$$ y(t) = \\frac{1}{2}t^{2}u(t) - \\frac{1}{2}(t-1)^{2}u(t-1) $$\n\n**3) Final Closed-Form Expression**\n\nThe expression derived from the integration by parts method is already in the required single, closed-form analytic expression valid for all $t \\in \\mathbb{R}$. This expression compactly represents the piecewise function derived previously.\n$$ y(t) = \\frac{1}{2}t^{2}u(t) - \\frac{1}{2}(t-1)^{2}u(t-1) $$\nThis is the final result. It is constructed from a parabolic function starting at $t=0$ and a second, negative, time-shifted parabolic function starting at $t=1$, which correctly generates the required output waveform.", "answer": "$$\n\\boxed{\\frac{1}{2}t^{2}u(t) - \\frac{1}{2}(t-1)^{2}u(t-1)}\n$$", "id": "2862220"}, {"introduction": "This final practice moves beyond simply calculating convolutions to using convolution as a powerful modeling tool. Here, the challenge is to solve an inverse problem: given an input and a desired output, you will design the Finite Impulse Response (FIR) filter that best produces this transformation [@problem_id:2862210]. By framing convolution as a linear system and solving it using least squares, you will engage in the practical engineering discipline of system identification, a fundamental concept in fields from communications to control theory.", "problem": "You are given the foundational definitions of a discrete-time Linear Time-Invariant (LTI) system with a finite impulse response (FIR). For any finite impulse response $h[n]$ of length $M$, the output $y[n]$ of the system to an input $x[n]$ is the convolution sum\n$$\ny[n] = (h * x)[n] = \\sum_{k=0}^{M-1} h[k]\\,x[n-k],\n$$\nwhere samples of $x[n]$ outside their specified finite support are taken to be zero. The goal is to design $h[n]$ such that the system output approximates a given desired sequence $d[n]$ over a finite index set. Formally, for a given observation window $\\mathcal{N} = \\{0,1,\\dots,N-1\\}$, find the FIR vector $h \\in \\mathbb{R}^M$ that minimizes\n$$\nJ(h) = \\sum_{n=0}^{N-1} \\left(\\sum_{k=0}^{M-1} h[k]\\,x[n-k] - d[n]\\right)^2.\n$$\nThis is a least-squares problem that can be interpreted as a finite-interval deconvolution, where the unknown impulse response $h[n]$ is inferred from $x[n]$ and $d[n]$.\n\nYour task is to write a complete, runnable program that:\n- Constructs the convolution design matrix implied by the convolution sum over the window $\\mathcal{N}$.\n- Computes the least-squares solution $h$ that minimizes $J(h)$.\n- Applies the method to each test case below.\n- Outputs the resulting $h$ vectors with entries rounded to $6$ decimal places.\n\nAssumptions and conventions:\n- For all sums, signals outside their specified finite supports are taken to be zero.\n- All indices are integers. There are no physical units in this problem.\n- Angles are not involved in this problem.\n- All computations must be performed in double-precision floating point and results rounded to $6$ decimal places.\n\nTest suite (three cases):\n- Case A (overdetermined, noise-free, persistently exciting input):\n  - FIR length $M_A = 3$ and window length $N_A = 10$.\n  - Input sequence $x_A[n]$ for $n \\in \\{0,\\dots,9\\}$ is\n    $$\n    x_A = [\\,2,-1,0,3,-2,1,4,0,-1,2\\,].\n    $$\n  - Ground-truth FIR $h_A^{\\text{true}}$ is\n    $$\n    h_A^{\\text{true}} = [\\,0.4,-0.1,0.25\\,].\n    $$\n  - Desired sequence $d_A[n]$ for $n \\in \\{0,\\dots,9\\}$ is generated by the convolution sum\n    $$\n    d_A[n] = \\sum_{k=0}^{2} h_A^{\\text{true}}[k]\\,x_A[n-k],\n    $$\n    with the convention that $x_A[m]=0$ for any index $m$ outside $\\{0,\\dots,9\\}$.\n\n- Case B (underdetermined, zero desired output):\n  - FIR length $M_B = 3$ and window length $N_B = 2$.\n  - Input sequence $x_B[n]$ for $n \\in \\{0,1\\}$ is\n    $$\n    x_B = [\\,1,-1\\,].\n    $$\n  - Desired sequence $d_B[n]$ for $n \\in \\{0,1\\}$ is\n    $$\n    d_B = [\\,0,0\\,].\n    $$\n\n- Case C (identity deconvolution via the Kronecker delta input):\n  - FIR length $M_C = 4$ and window length $N_C = 6$.\n  - Input sequence $x_C[n]$ for $n \\in \\{0,\\dots,5\\}$ is\n    $$\n    x_C = [\\,1,0,0,0,0,0\\,].\n    $$\n  - Desired sequence $d_C[n]$ for $n \\in \\{0,\\dots,5\\}$ is\n    $$\n    d_C = [\\,0.2,0.8,-0.5,1.0,0.0,0.3\\,].\n    $$\n\nRequired final output format:\n- Your program must produce a single line of output containing the results aggregated as a comma-separated list enclosed in square brackets.\n- Each element of this outer list corresponds to one test case and must itself be a list of the estimated FIR coefficients $[\\,h[0],h[1],\\dots,h[M-1]\\,]$, with each coefficient rounded to $6$ decimal places.\n- The final format therefore looks like a list of lists, for example, an outer list with $3$ inner lists corresponding to the $3$ test cases.\n\nInterpretation requirement:\n- After computing the solutions, interpret them conceptually as finite-interval deconvolution: the least-squares estimates recover the impulse response that, when convolved with the given input, most closely reproduces the desired sequence over the specified window.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each inner list containing the rounded coefficients for one test case in order A, B, C.", "solution": "The problem presented is found to be valid. It is a standard, well-posed problem in digital signal processing and system identification, specifically the design of a Finite Impulse Response (FIR) filter using a least-squares criterion. The problem statement is scientifically grounded, formally specified, and free of contradictions or ambiguities.\n\nThe objective is to find the FIR filter coefficients, represented by the vector $\\mathbf{h} \\in \\mathbb{R}^M$, that minimize the sum of squared errors between the filter output and a desired sequence $\\mathbf{d}$ over a finite observation window. The cost function is given as:\n$$\nJ(\\mathbf{h}) = \\sum_{n=0}^{N-1} \\left( y[n] - d[n] \\right)^2 = \\sum_{n=0}^{N-1} \\left(\\sum_{k=0}^{M-1} h[k]\\,x[n-k] - d[n]\\right)^2\n$$\nHere, $x[n]$ is the input signal, $d[n]$ is the desired output signal, $M$ is the length of the FIR filter $h[n]$, and $N$ is the number of observations. We are to solve this for $\\mathbf{h} = [h[0], h[1], \\dots, h[M-1]]^T$.\n\nThis problem is a classical linear least-squares problem. To solve it, we must first express the relationship between the output $y[n]$ and the unknown coefficients $h[k]$ in matrix-vector form. For each time index $n$ in the observation window $\\mathcal{N} = \\{0, 1, \\dots, N-1\\}$, the output $y[n]$ is a linear combination of the filter coefficients $h[k]$:\n$$\ny[n] = x[n]h[0] + x[n-1]h[1] + \\dots + x[n-(M-1)]h[M-1]\n$$\nWe can write this for all $n \\in \\mathcal{N}$ as a single matrix equation $\\mathbf{y} = \\mathbf{Xh}$, where $\\mathbf{y} \\in \\mathbb{R}^N$ is the vector of outputs, $\\mathbf{h} \\in \\mathbb{R}^M$ is the vector of filter coefficients, and $\\mathbf{X}$ is an $N \\times M$ matrix known as the convolution matrix. The entries of $\\mathbf{X}$ are given by $X_{n,k} = x[n-k]$ for $n \\in \\{0, \\dots, N-1\\}$ and $k \\in \\{0, \\dots, M-1\\}$. The convention is that $x[m]=0$ for any index $m$ outside its specified support.\n\nThe cost function can then be expressed in vector notation as the squared Euclidean norm of the residual vector:\n$$\nJ(\\mathbf{h}) = \\|\\mathbf{Xh} - \\mathbf{d}\\|_2^2\n$$\nwhere $\\mathbf{d} = [d[0], d[1], \\dots, d[N-1]]^T$ is the vector of desired output samples. The vector $\\mathbf{h}$ that minimizes this expression is the least-squares solution. While this solution can be formally written using the pseudoinverse of $\\mathbf{X}$ as $\\mathbf{h} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{d}$ (assuming $\\mathbf{X}^T\\mathbf{X}$ is invertible), it is numerically more stable and general to solve this system using methods such as QR decomposition or Singular Value Decomposition (SVD). These methods are implemented in standard numerical libraries and correctly handle both overdetermined ($N > M$) and underdetermined ($N < M$) systems.\n\nThe procedure to solve for $\\mathbf{h}$ for each test case is as follows:\n1.  From the given parameters $M$, $N$, and the input signal $x[n]$, construct the $N \\times M$ convolution matrix $\\mathbf{X}$.\n2.  Form the desired output vector $\\mathbf{d} \\in \\mathbb{R}^N$.\n3.  Solve the linear least-squares problem $\\min_{\\mathbf{h}} \\|\\mathbf{Xh} - \\mathbf{d}\\|_2^2$ to find the optimal filter coefficient vector $\\mathbf{h}$.\n\nWe now apply this procedure to the $3$ specified cases.\n\nCase A: $M_A = 3$, $N_A = 10$. The input $x_A[n]$ is given. The desired signal $d_A[n]$ is generated by convolving a known filter $h_A^{\\text{true}} = [0.4, -0.1, 0.25]$ with $x_A[n]$. We construct the $10 \\times 3$ convolution matrix $\\mathbf{X}_A$ and the desired vector $\\mathbf{d}_A$. Since $N_A > M_A$, this is an overdetermined system. As the data are generated from the model itself and are noise-free, and the input is sufficiently rich (persistently exciting), the least-squares solution is expected to recover $h_A^{\\text{true}}$ with high precision.\n\nCase B: $M_B = 3$, $N_B = 2$. We are given $x_B[n]$ and $d_B[n] = [0, 0]$. We construct the $2 \\times 3$ convolution matrix $\\mathbf{X}_B$. Since $N_B < M_B$, this system is underdetermined. There will be an affine subspace of solutions that perfectly satisfy $\\mathbf{Xh}=\\mathbf{d}$. The standard least-squares solver will return the unique solution with the minimum Euclidean norm $\\|\\mathbf{h}\\|_2$. The equations are $h[0] = 0$ and $-h[0] + h[1] = 0$, implying $h[0]=h[1]=0$. The coefficient $h[2]$ does not affect the output, so the minimum norm solution sets $h[2]=0$. Thus, we expect $\\mathbf{h}_B = [0, 0, 0]^T$.\n\nCase C: $M_C = 4$, $N_C = 6$. The input is $x_C[n] = [1, 0, 0, 0, 0, 0]$, which is a discrete-time impulse (Kronecker delta) at $n=0$. The convolution of any filter $h[n]$ with an impulse $\\delta[n]$ is the filter itself: $(h * \\delta)[n] = h[n]$. Thus, the output of the system is $y[n] = h[n]$ for $n \\in \\{0, 1, 2, 3\\}$, and $y[n]=0$ for $n \\ge 4$. The $6 \\times 4$ convolution matrix $\\mathbf{X}_C$ will be an identity matrix $\\mathbf{I}_{4 \\times 4}$ stacked on top of a $2 \\times 4$ zero matrix. The least-squares problem becomes minimizing $\\sum_{n=0}^{3} (h[n] - d_C[n])^2 + \\sum_{n=4}^{5} (0 - d_C[n])^2$. The optimal solution is simply $h[n] = d_C[n]$ for $n \\in \\{0, 1, 2, 3\\}$. The error contribution from $n \\ge 4$ is independent of $\\mathbf{h}$ and is part of the minimum achievable error. We expect $\\mathbf{h}_C = [0.2, 0.8, -0.5, 1.0]^T$.\n\nThis process of finding $\\mathbf{h}$ from $x$ and $d$ is a form of system identification or, equivalently, deconvolution. We are computationally \"inverting\" the effect of the convolution with $x[n]$ to recover the filter $h[n]$ that best explains the desired signal $d[n]$ over the specified finite interval $\\mathcal{N}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the least-squares FIR filter for three test cases.\n    \"\"\"\n\n    # Define the test cases based on the problem statement.\n    # Note: For Case A, the desired signal 'd' is generated from a true filter.\n    # For Cases B and C, 'd' is given directly.\n    \n    # Case A: Overdetermined, noise-free\n    M_A = 3\n    N_A = 10\n    x_A = np.array([2.0, -1.0, 0.0, 3.0, -2.0, 1.0, 4.0, 0.0, -1.0, 2.0])\n    h_A_true = np.array([0.4, -0.1, 0.25])\n    # Generate the desired signal d_A by convolving h_true with x_A.\n    # The convolution sum y[n] = sum_k h[k]x[n-k] corresponds to np.convolve(h, x).\n    # We take the first N_A samples of the full convolution result.\n    d_A = np.convolve(h_A_true, x_A, mode='full')[:N_A]\n\n    # Case B: Underdetermined, zero desired output\n    M_B = 3\n    N_B = 2\n    x_B = np.array([1.0, -1.0])\n    d_B = np.array([0.0, 0.0])\n\n    # Case C: Identity deconvolution\n    M_C = 4\n    N_C = 6\n    x_C = np.array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    d_C = np.array([0.2, 0.8, -0.5, 1.0, 0.0, 0.3])\n    \n    test_cases = [\n        {'M': M_A, 'N': N_A, 'x': x_A, 'd': d_A},\n        {'M': M_B, 'N': N_B, 'x': x_B, 'd': d_B},\n        {'M': M_C, 'N': N_C, 'x': x_C, 'd': d_C},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        M = case['M']\n        N = case['N']\n        x = case['x']\n        d = case['d']\n\n        # Construct the N x M convolution matrix X.\n        # The entry at (n, k) is x[n-k], where x is zero outside its support.\n        X = np.zeros((N, M))\n        for n in range(N):\n            for k in range(M):\n                idx = n - k\n                if 0 = idx  len(x):\n                    X[n, k] = x[idx]\n        \n        # Solve the linear least-squares problem: min ||Xh - d||^2.\n        # np.linalg.lstsq returns a tuple; the solution vector h is the first element.\n        h_solution = np.linalg.lstsq(X, d, rcond=None)[0]\n        \n        # Round the resulting filter coefficients to 6 decimal places.\n        h_rounded = np.round(h_solution, 6)\n        \n        # Append the list of coefficients to the overall results.\n        results.append(h_rounded.tolist())\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., \"[[c1_h0, c1_h1], [c2_h0, c2_h1]]\"\n    output_str = f\"[{','.join(map(str, results))}]\"\n    \n    # Python's default str() for lists adds spaces. The requested format implies\n    # a more compact representation, but str() is sufficient for correctness.\n    # To be extremely precise about no spaces:\n    # output_str = \"[\" + \",\".join([str(res).replace(\" \", \"\") for res in results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```", "id": "2862210"}]}