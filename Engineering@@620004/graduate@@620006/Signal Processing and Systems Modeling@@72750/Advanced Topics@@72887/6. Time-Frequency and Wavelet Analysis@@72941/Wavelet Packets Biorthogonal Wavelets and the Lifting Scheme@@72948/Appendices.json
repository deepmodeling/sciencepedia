{"hands_on_practices": [{"introduction": "The power of wavelet transforms lies in their ability to decompose a signal into different components and then perfectly reconstruct it. This first exercise provides a foundational, step-by-step walkthrough of the analysis and synthesis process using the simple yet powerful Haar wavelet [@problem_id:2916288]. By deriving the transform and its inverse both symbolically and numerically, you will gain a concrete understanding of the perfect reconstruction property and see how the lifting scheme provides an elegant and invertible framework for these operations.", "problem": "Consider a length-$4$ discrete-time signal with samples $x[0]=\\alpha$, $x[1]=\\beta$, $x[2]=\\gamma$, and $x[3]=\\delta$, where $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$. Let a two-channel analysis/synthesis filter bank be formed from the Haar wavelet, viewed as a special biorthogonal pair that is orthonormal. The analysis low-pass and high-pass filters are $h_{0}[n]=\\left\\{\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right\\}$ and $h_{1}[n]=\\left\\{\\frac{1}{\\sqrt{2}},-\\frac{1}{\\sqrt{2}}\\right\\}$, each of length $2$. The analysis stage consists of filtering followed by downsampling by $2$, applied without boundary wrap-around by grouping the samples in nonoverlapping adjacent pairs. The synthesis stage is the exact inverse obtained either by the perfect reconstruction (PR) property of the Haar filter bank or by inverting the lifting steps of the corresponding lifting scheme with predict and update operators.\n\nTasks:\n1) Using only the definitions of linear time-invariant filtering, downsampling-by-$2$, and the given analysis filters, compute explicitly the first-level approximation and detail sequences $a_{1}[k]$ and $d_{1}[k]$ for $k\\in\\{0,1\\}$ in terms of $\\alpha,\\beta,\\gamma,\\delta$.\n2) Derive the synthesis relations directly from first principles using either the inverse of the analysis polyphase mapping or the inverse of the lifting scheme with split-predict-update-scaling steps appropriate for the Haar case. Use these relations to reconstruct $\\hat{x}[n]$ for $n\\in\\{0,1,2,3\\}$ symbolically in terms of $\\alpha,\\beta,\\gamma,\\delta$.\n3) Verify perfect reconstruction (PR) symbolically by expressing the reconstruction error energy $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$ as a closed-form expression in $\\alpha,\\beta,\\gamma,\\delta$. Your final answer must be this $E(\\alpha,\\beta,\\gamma,\\delta)$.\n4) To numerically validate your symbolic derivation, take the concrete choice $x[0]=2$, $x[1]=-1$, $x[2]=0$, $x[3]=3$ and compute the numerical $a_{1}[k]$, $d_{1}[k]$, and $\\hat{x}[n]$, confirming the value of $E$ obtained symbolically. No rounding is required; leave any occurrences of $\\sqrt{2}$ in exact form.\n\nExpress the final answer as a single closed-form expression for $E(\\alpha,\\beta,\\gamma,\\delta)$ with no units. Do not provide an inequality or an equation; provide only the expression. No rounding is required.", "solution": "The problem statement is subjected to validation before any attempt at a solution.\n\nStep 1: Extract Givens\n- Signal: A discrete-time signal of length $4$, denoted by $x[n]$, with samples $x[0]=\\alpha$, $x[1]=\\beta$, $x[2]=\\gamma$, and $x[3]=\\delta$. The parameters $\\alpha, \\beta, \\gamma, \\delta$ are real numbers, i.e., $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$.\n- Filter Bank: A two-channel analysis/synthesis system based on the Haar wavelet.\n- Analysis Filters:\n  - Low-pass: $h_{0}[n]=\\left\\{\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right\\}$ for $n \\in \\{0, 1\\}$.\n  - High-pass: $h_{1}[n]=\\left\\{\\frac{1}{\\sqrt{2}},-\\frac{1}{\\sqrt{2}}\\right\\}$ for $n \\in \\{0, 1\\}$.\n- Analysis Process: \"filtering followed by downsampling by $2$, applied without boundary wrap-around by grouping the samples in nonoverlapping adjacent pairs.\"\n- Synthesis Process: The exact inverse of the analysis stage.\n- Task 1: Compute first-level approximation sequence $a_{1}[k]$ and detail sequence $d_{1}[k]$ for $k\\in\\{0,1\\}$.\n- Task 2: Derive synthesis relations and reconstruct the signal $\\hat{x}[n]$ for $n\\in\\{0,1,2,3\\}$.\n- Task 3: Verify perfect reconstruction (PR) by finding a closed-form expression for the reconstruction error energy $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$.\n- Task 4: Numerically validate the symbolic derivation using $x[0]=2$, $x[1]=-1$, $x[2]=0$, $x[3]=3$.\n- Final Answer: The expression for $E(\\alpha,\\beta,\\gamma,\\delta)$.\n\nStep 2: Validate Using Extracted Givens\n- Scientific Grounding: The problem is fundamentally sound. It is based on the established principles of digital signal processing, specifically the Discrete Wavelet Transform (DWT), filter banks, and the lifting scheme, all of which are standard topics in engineering and applied mathematics. The Haar wavelet is a canonical example.\n- Well-Posedness: The problem is well-posed. The signal is finite, the filters are explicitly defined, and the boundary handling (\"nonoverlapping adjacent pairs\") is specified unambiguously. This ensures a unique solution can be determined.\n- Objectivity: The problem is stated in precise, objective, and mathematical language, free from any subjective or ambiguous terminology.\n\nStep 3: Verdict and Action\nThe problem is valid. It is a standard exercise in discrete signal processing that is scientifically grounded, well-posed, and objective. A complete solution will now be provided.\n\nThe problem requires a four-part derivation and validation process. We will proceed methodically through each task. The phrase \"grouping the samples in nonoverlapping adjacent pairs\" implies that the transform is applied independently to the pair $(x[0], x[1])$ and the pair $(x[2], x[3])$.\n\nTask 1: Analysis Stage Calculation\nThe analysis stage computes the approximation coefficients $a_{1}[k]$ and detail coefficients $d_{1}[k]$. For a non-overlapping block-based transform, this is equivalent to applying the filter action to each pair of samples. Let the filter coefficients be indexed from $n=0$ to $n=1$.\n\nFor the first pair $(x[0], x[1]) = (\\alpha, \\beta)$, corresponding to $k=0$:\nThe approximation coefficient $a_{1}[0]$ is computed using the low-pass filter $h_0[n]$:\n$$a_{1}[0] = h_{0}[0]x[0] + h_{0}[1]x[1] = \\frac{1}{\\sqrt{2}}\\alpha + \\frac{1}{\\sqrt{2}}\\beta = \\frac{\\alpha+\\beta}{\\sqrt{2}}$$\nThe detail coefficient $d_{1}[0]$ is computed using the high-pass filter $h_1[n]$:\n$$d_{1}[0] = h_{1}[0]x[0] + h_{1}[1]x[1] = \\frac{1}{\\sqrt{2}}\\alpha - \\frac{1}{\\sqrt{2}}\\beta = \\frac{\\alpha-\\beta}{\\sqrt{2}}$$\n\nFor the second pair $(x[2], x[3]) = (\\gamma, \\delta)$, corresponding to $k=1$:\nThe approximation coefficient $a_{1}[1]$ is computed similarly:\n$$a_{1}[1] = h_{0}[0]x[2] + h_{0}[1]x[3] = \\frac{1}{\\sqrt{2}}\\gamma + \\frac{1}{\\sqrt{2}}\\delta = \\frac{\\gamma+\\delta}{\\sqrt{2}}$$\nThe detail coefficient $d_{1}[1]$ is:\n$$d_{1}[1] = h_{1}[0]x[2] + h_{1}[1]x[3] = \\frac{1}{\\sqrt{2}}\\gamma - \\frac{1}{\\sqrt{2}}\\delta = \\frac{\\gamma-\\delta}{\\sqrt{2}}$$\n\nTask 2: Synthesis Stage Derivation and Reconstruction\nThe problem requires deriving the synthesis relations from first principles, specifically the inverse lifting scheme. First, we establish the forward lifting scheme that corresponds to our analysis filters.\n\nForward Lifting Scheme:\n1.  Split: The signal $x[n]$ is split into even-indexed samples $x_e[k] = x[2k]$ and odd-indexed samples $x_o[k] = x[2k+1]$.\n2.  Predict: The unscaled detail is $d_1'[k] = x_e[k] - x_o[k]$.\n3.  Update: The unscaled approximation is $a_1'[k] = x_o[k] + \\frac{1}{2}d_1'[k] = \\frac{1}{2}(x_e[k] + x_o[k])$.\n4.  Scale: A normalization is applied. $d_1[k] = d_1'[k] / \\sqrt{2}$ and $a_1[k] = a_1'[k] \\times \\sqrt{2}$.\n\nInverse Lifting Scheme:\nTo reconstruct the signal, we reverse these steps in order.\n1.  Inverse Scale: We recover the unscaled coefficients $d_1'[k]$ and $a_1'[k]$.\n    $$d_1'[k] = d_1[k] \\times \\sqrt{2}$$\n    $$a_1'[k] = a_1[k] / \\sqrt{2}$$\n2.  Inverse Update: We recover the odd-indexed samples $x_o[k]$ from $a_1'[k]$ and $d_1'[k]$.\n    $$\\hat{x}_o[k] = a_1'[k] - \\frac{1}{2}d_1'[k]$$\n3.  Inverse Predict: We recover the even-indexed samples $x_e[k]$ from $d_1'[k]$ and the now-known $\\hat{x}_o[k]$.\n    $$\\hat{x}_e[k] = d_1'[k] + \\hat{x}_o[k]$$\n4.  Merge: The reconstructed signal samples are $\\hat{x}[2k] = \\hat{x}_e[k]$ and $\\hat{x}[2k+1] = \\hat{x}_o[k]$.\n\nNow, we apply these synthesis relations to reconstruct $\\hat{x}[n]$ symbolically.\nFor $k=0$:\n1.  Inverse Scale:\n    $d_1'[0] = \\left(\\frac{\\alpha-\\beta}{\\sqrt{2}}\\right)\\sqrt{2} = \\alpha-\\beta$\n    $a_1'[0] = \\left(\\frac{\\alpha+\\beta}{\\sqrt{2}}\\right)/\\sqrt{2} = \\frac{\\alpha+\\beta}{2}$\n2.  Inverse Update (reconstructs $\\hat{x}[1]$):\n    $\\hat{x}[1] = \\hat{x}_o[0] = a_1'[0] - \\frac{1}{2}d_1'[0] = \\frac{\\alpha+\\beta}{2} - \\frac{1}{2}(\\alpha-\\beta) = \\frac{\\alpha+\\beta-\\alpha+\\beta}{2} = \\beta$\n3.  Inverse Predict (reconstructs $\\hat{x}[0]$):\n    $\\hat{x}[0] = \\hat{x}_e[0] = d_1'[0] + \\hat{x}_o[0] = (\\alpha-\\beta) + \\beta = \\alpha$\n\nFor $k=1$:\n1.  Inverse Scale:\n    $d_1'[1] = \\left(\\frac{\\gamma-\\delta}{\\sqrt{2}}\\right)\\sqrt{2} = \\gamma-\\delta$\n    $a_1'[1] = \\left(\\frac{\\gamma+\\delta}{\\sqrt{2}}\\right)/\\sqrt{2} = \\frac{\\gamma+\\delta}{2}$\n2.  Inverse Update (reconstructs $\\hat{x}[3]$):\n    $\\hat{x}[3] = \\hat{x}_o[1] = a_1'[1] - \\frac{1}{2}d_1'[1] = \\frac{\\gamma+\\delta}{2} - \\frac{1}{2}(\\gamma-\\delta) = \\frac{\\gamma+\\delta-\\gamma+\\delta}{2} = \\delta$\n3.  Inverse Predict (reconstructs $\\hat{x}[2]$):\n    $\\hat{x}[2] = \\hat{x}_e[1] = d_1'[1] + \\hat{x}_o[1] = (\\gamma-\\delta) + \\delta = \\gamma$\n\nThe reconstructed signal is $\\hat{x}[n] = \\{\\alpha, \\beta, \\gamma, \\delta\\}$.\n\nTask 3: Reconstruction Error Energy\nThe reconstruction error energy is defined as $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$.\nFrom Task 2, we have established that the reconstructed signal is identical to the original signal: $\\hat{x}[n] = x[n]$ for all $n$.\nTherefore, the error at each sample point is zero.\nThe total error energy is thus:\n$$E(\\alpha, \\beta, \\gamma, \\delta) = (\\alpha-\\alpha)^2 + (\\beta-\\beta)^2 + (\\gamma-\\gamma)^2 + (\\delta-\\delta)^2 = 0^2 + 0^2 + 0^2 + 0^2 = 0$$\nThis demonstrates symbolically that the Haar filter bank provides perfect reconstruction. The closed-form expression for the error energy is simply $0$.\n\nTask 4: Numerical Validation\nTo confirm the symbolic results, we use the specific signal $x[n] = \\{2, -1, 0, 3\\}$. Here, $\\alpha=2$, $\\beta=-1$, $\\gamma=0$, $\\delta=3$.\nAnalysis coefficients:\n$a_{1}[0] = \\frac{2+(-1)}{\\sqrt{2}} = \\frac{1}{\\sqrt{2}}$\n$d_{1}[0] = \\frac{2-(-1)}{\\sqrt{2}} = \\frac{3}{\\sqrt{2}}$\n$a_{1}[1] = \\frac{0+3}{\\sqrt{2}} = \\frac{3}{\\sqrt{2}}$\n$d_{1}[1] = \\frac{0-3}{\\sqrt{2}} = -\\frac{3}{\\sqrt{2}}$\n\nReconstruction:\nWe apply the inverse lifting steps to the numerical coefficients.\nFor $k=0$ (reconstructing $x[0], x[1]$):\n$a_1'[0] = a_1[0]/\\sqrt{2} = (\\frac{1}{\\sqrt{2}})/\\sqrt{2} = \\frac{1}{2}$\n$d_1'[0] = d_1[0]\\sqrt{2} = (\\frac{3}{\\sqrt{2}})\\sqrt{2} = 3$\n$\\hat{x}[1] = \\hat{x}_o[0] = a_1'[0] - \\frac{1}{2}d_1'[0] = \\frac{1}{2} - \\frac{1}{2}(3) = -1$.\n$\\hat{x}[0] = \\hat{x}_e[0] = d_1'[0] + \\hat{x}_o[0] = 3 + (-1) = 2$.\n\nFor $k=1$ (reconstructing $x[2], x[3]$):\n$a_1'[1] = a_1[1]/\\sqrt{2} = (\\frac{3}{\\sqrt{2}})/\\sqrt{2} = \\frac{3}{2}$\n$d_1'[1] = d_1[1]\\sqrt{2} = (-\\frac{3}{\\sqrt{2}})\\sqrt{2} = -3$\n$\\hat{x}[3] = \\hat{x}_o[1] = a_1'[1] - \\frac{1}{2}d_1'[1] = \\frac{3}{2} - \\frac{1}{2}(-3) = 3$.\n$\\hat{x}[2] = \\hat{x}_e[1] = d_1'[1] + \\hat{x}_o[1] = -3 + 3 = 0$.\n\nThe reconstructed signal is $\\hat{x}[n] = \\{2, -1, 0, 3\\}$, which is identical to the original signal. The numerical error energy $E$ is $0$, confirming the symbolic result. The derivation is sound. The final answer is the symbolic expression for the error energy $E(\\alpha,\\beta,\\gamma,\\delta)$.", "answer": "$$\n\\boxed{0}\n$$", "id": "2916288"}, {"introduction": "While the standard wavelet transform recursively splits only the low-frequency channel, the Wavelet Packet Transform (WPT) offers greater flexibility by decomposing both low- and high-frequency channels at each level. This coding exercise challenges you to implement a two-level WPT and demonstrates a remarkable property: perfect reconstruction is guaranteed for any valid choice of basis from the resulting packet tree [@problem_id:2916274]. This hands-on task illuminates how WPT can be used to create custom, adaptive frequency decompositions tailored to a specific signal's characteristics.", "problem": "You are given the task of implementing and analyzing a two-level Wavelet Packet Transform (WPT) using the Haar basis realized by the lifting scheme, within the biorthogonal framework. The goal is to compute all node coefficients up to depth 2 and to verify that different admissible bases yield exactly the same reconstruction when the matching dual synthesis is used.\n\nStart from the following fundamental definitions and facts:\n\n- The lifting scheme implements biorthogonal wavelet transforms as a sequence of invertible linear steps. For a discrete-time signal $x[n]$ of even length, define the even-odd split $e[k] = x[2k]$ and $o[k] = x[2k+1]$.\n- The predict operator $\\mathcal{P}$ generates detail coefficients by $d[k] = o[k] - e[k]$.\n- The update operator $\\mathcal{U}$ generates coarse (approximation) coefficients by $a[k] = e[k] + \\frac{1}{2} d[k]$.\n- The synthesis (dual) operators invert these steps exactly: $e[k] = a[k] - \\frac{1}{2} d[k]$, $o[k] = d[k] + e[k]$, and interleaving recovers the original signal via $x[2k] = e[k]$, $x[2k+1] = o[k]$.\n- The above pair of analysis and synthesis steps constitutes a biorthogonal Haar transform implemented by lifting and achieves Perfect Reconstruction (PR).\n- A wavelet packet decomposition applies the same two-channel split to both approximation and detail channels, producing a full binary tree of subbands. At depth 2, the nodes are $A_1$ and $D_1$ at level $1$, and the four level-2 nodes $AA$, $AD$ coming from $A_1$, and $DA$, $DD$ coming from $D_1$.\n- An admissible basis is a collection of tree leaves that are pairwise disjoint and whose union spans the root node. For exact reconstruction, each selected leaf must be synthesized by the matching dual transform along its path, and parents of non-decomposed leaves must be combined with their siblings via the inverse lifting steps.\n\nTasks to complete:\n\n1. Implement the analysis and synthesis lifting steps described above for the Haar biorthogonal transform.\n2. Implement a depth-2 wavelet packet decomposition of a signal $x[n]$ to compute all node coefficients $A_1$, $D_1$, $AA$, $AD$, $DA$, $DD$.\n3. Implement basis-dependent reconstruction using the matching duals:\n   - Basis $\\mathcal{B}_1$: uniform depth-2 leaves $\\{AA, AD, DA, DD\\}$.\n   - Basis $\\mathcal{B}_2$: split only the approximation branch $\\{AA, AD, D_1\\}$.\n   - Basis $\\mathcal{B}_3$: split only the detail branch $\\{A_1, DA, DD\\}$.\n   Reconstruction must first synthesize children to their parent when a branch is split, then synthesize the level-1 pair to the root.\n4. For each test case below, compute the maximum absolute reconstruction error $E = \\max_n |x[n] - \\hat{x}[n]|$ and verify whether $E \\le \\tau$ with tolerance $\\tau = 10^{-12}$. Report a boolean for each test case.\n\nTest suite:\n\n- Use signals of length $8$ so that depth-2 decomposition is well-defined without boundary handling. The three signals are:\n  - $x^{(1)} = [\\, 3.0,\\, 1.0,\\, 0.0,\\, -1.0,\\, 2.0,\\, 4.0,\\, -2.0,\\, 0.5 \\,]$.\n  - $x^{(2)} = [\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0 \\,]$.\n  - $x^{(3)} = [\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0 \\,]$.\n- Combine each signal with each basis $\\mathcal{B}_1$, $\\mathcal{B}_2$, $\\mathcal{B}_3$ to obtain $9$ test cases. For each case, output a boolean indicating whether the reconstruction passes the tolerance check $E \\le \\tau$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $9$ boolean values in the following order: $(x^{(1)}, \\mathcal{B}_1)$, $(x^{(1)}, \\mathcal{B}_2)$, $(x^{(1)}, \\mathcal{B}_3)$, $(x^{(2)}, \\mathcal{B}_1)$, $(x^{(2)}, \\mathcal{B}_2)$, $(x^{(2)}, \\mathcal{B}_3)$, $(x^{(3)}, \\mathcal{B}_1)$, $(x^{(3)}, \\mathcal{B}_2)$, $(x^{(3)}, \\mathcal{B}_3)$. For example, the output format must be exactly like $[True,True,True,True,True,True,True,True,True]$ with no extra spaces.", "solution": "We formalize the two-level wavelet packet decomposition and reconstruction using the Haar basis via the lifting scheme, demonstrating why any admissible basis reconstructs the original when the matching duals are used.\n\nFoundational operators:\n\n- Even-odd split: For a discrete-time signal $x[n]$ of even length, define $e[k] = x[2k]$ and $o[k] = x[2k+1]$ for $k = 0, 1, \\dots, \\frac{N}{2}-1$.\n- Predict (analysis): The detail is $d[k] = o[k] - e[k]$. This corresponds to predicting the odd sample by the even sample and storing the prediction error.\n- Update (analysis): The approximation is $a[k] = e[k] + \\frac{1}{2} d[k]$. This updates the coarse scale using the detail to preserve low-frequency moments.\n- Synthesis (dual): Inversion is exact via $e[k] = a[k] - \\frac{1}{2} d[k]$, then $o[k] = d[k] + e[k]$, and interleaving gives back $x[2k] = e[k]$, $x[2k+1] = o[k]$.\n\nThe analysis mapping $(x \\mapsto (a, d))$ is an invertible linear operator with inverse given above; hence this constitutes a biorthogonal pair with Perfect Reconstruction (PR). The Perfect Reconstruction (PR) property is immediate from direct substitution:\n$$\ne[k] = \\Big(e[k] + \\tfrac{1}{2} d[k]\\Big) - \\tfrac{1}{2} d[k] = e[k], \\quad\no[k] = d[k] + e[k] = (o[k] - e[k]) + e[k] = o[k].\n$$\nTherefore interleaving reproduces $x[n]$ exactly.\n\nWavelet packet tree:\n\n- Level $1$ decomposition of $x[n]$ yields $(A_1, D_1) = (a^{(1)}, d^{(1)})$ computed from $(e^{(0)}, o^{(0)})$ as above.\n- Level $2$ decomposition proceeds by applying the same lifting steps to both $A_1$ and $D_1$:\n  - From $A_1$ we obtain $(AA, AD)$ by even-odd splitting and the same predict-update pair.\n  - From $D_1$ we obtain $(DA, DD)$ similarly.\n\nLet $\\mathcal{L}$ denote the analysis lifting operator and $\\mathcal{L}^{-1}$ its synthesis dual. At level $1$ we apply $\\mathcal{L}$ to $x$ to obtain $(A_1, D_1)$. At level $2$, $\\mathcal{L}$ is applied independently to $A_1$ and to $D_1$, producing the four grandchildren $(AA, AD, DA, DD)$.\n\nAdmissible bases and reconstruction:\n\n- An admissible basis is a set of leaves that partition the tree such that each original degree of freedom at the root is represented exactly once. Examples at depth $2$:\n  - $\\mathcal{B}_1 = \\{ AA, AD, DA, DD \\}$ (uniform refinement).\n  - $\\mathcal{B}_2 = \\{ AA, AD, D_1 \\}$ (refine only the approximation branch).\n  - $\\mathcal{B}_3 = \\{ A_1, DA, DD \\}$ (refine only the detail branch).\n- Reconstruction with matching duals composes the inverse lifting operators along the paths from each selected leaf to the root:\n  - For $\\mathcal{B}_1$, synthesize $A_1 = \\mathcal{L}^{-1}(AA, AD)$ and $D_1 = \\mathcal{L}^{-1}(DA, DD)$, then $x = \\mathcal{L}^{-1}(A_1, D_1)$.\n  - For $\\mathcal{B}_2$, synthesize $A_1 = \\mathcal{L}^{-1}(AA, AD)$ and use the original $D_1$, then $x = \\mathcal{L}^{-1}(A_1, D_1)$.\n  - For $\\mathcal{B}_3$, synthesize $D_1 = \\mathcal{L}^{-1}(DA, DD)$ and use the original $A_1$, then $x = \\mathcal{L}^{-1}(A_1, D_1)$.\n  \nBecause each $\\mathcal{L}$ is invertible with a two-sided inverse $\\mathcal{L}^{-1}$ and different branches operate on disjoint index sets (due to even-odd splitting), linearity and block-diagonal structure imply that any composition of inverse operators along the selected leaf paths recovers the same vector $x$ provided that every degree of freedom is included exactly once. More formally, if we denote by $T$ the full level-$2$ analysis operator mapping $x$ to $(AA, AD, DA, DD)$ and by $T^{-1}$ its blockwise inverse that first reconstructs $(A_1, D_1)$ and then $x$, then the admissible bases correspond to pruning $T$ into block-triangular forms whose inverses are obtained by partially applying $T^{-1}$ on the refined branches and directly passing unrefined parents. Since all paths use the matching duals, the net operator is the identity on $\\mathbb{R}^N$.\n\nAlgorithmic design:\n\n- Implement the analysis lifting step using the explicit formulas $d = o - e$, $a = e + \\frac{1}{2}d$.\n- Implement the synthesis lifting step using $e = a - \\frac{1}{2}d$, $o = d + e$, with interleaving.\n- Implement depth-2 WPT by applying analysis to the root and then to both children.\n- Implement reconstruction for a selected basis by applying synthesis bottom-up along the necessary branches.\n- For each test case, compute the maximum absolute error $E = \\max_n |x[n] - \\hat{x}[n]|$ and check $E \\le \\tau$ with $\\tau = 10^{-12}$.\n\nTest suite and expected outcomes:\n\n- Signals of length $8$: $x^{(1)} = [\\, 3.0,\\, 1.0,\\, 0.0,\\, -1.0,\\, 2.0,\\, 4.0,\\, -2.0,\\, 0.5 \\,]$, $x^{(2)} = [\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0 \\,]$, $x^{(3)} = [\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0 \\,]$.\n- Bases $\\mathcal{B}_1$, $\\mathcal{B}_2$, $\\mathcal{B}_3$ as defined above.\n- Since synthesis uses the exact dual operators of analysis, PR guarantees that the reconstruction error is exactly zero in exact arithmetic and is numerically zero within floating-point tolerance. Therefore, each of the $9$ booleans should be $True$ for $\\tau = 10^{-12}$.\n\nThe program specified in the final answer implements these steps and prints a single line list of the $9$ booleans in the required order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analysis_lifting_haar_biorth(x: np.ndarray):\n    \"\"\"\n    One-level biorthogonal Haar analysis via lifting:\n    - Split into even and odd\n    - Predict: d = o - e\n    - Update:  a = e + 0.5 * d\n    Returns (a, d)\n    \"\"\"\n    e = x[0::2]\n    o = x[1::2]\n    d = o - e\n    a = e + 0.5 * d\n    return a, d\n\ndef synthesis_lifting_haar_biorth(a: np.ndarray, d: np.ndarray):\n    \"\"\"\n    One-level biorthogonal Haar synthesis via lifting:\n    - Invert update: e = a - 0.5 * d\n    - Invert predict: o = d + e\n    - Interleave to reconstruct x\n    Returns reconstructed x\n    \"\"\"\n    e = a - 0.5 * d\n    o = d + e\n    x = np.empty(e.size + o.size, dtype=float)\n    x[0::2] = e\n    x[1::2] = o\n    return x\n\ndef wp2_forward(x: np.ndarray):\n    \"\"\"\n    Two-level wavelet packet decomposition using the above lifting steps.\n    Returns a dictionary with A1, D1, AA, AD, DA, DD.\n    \"\"\"\n    a1, d1 = analysis_lifting_haar_biorth(x)\n    aa, ad = analysis_lifting_haar_biorth(a1)\n    da, dd = analysis_lifting_haar_biorth(d1)\n    return {\n        'A1': a1,\n        'D1': d1,\n        'AA': aa,\n        'AD': ad,\n        'DA': da,\n        'DD': dd\n    }\n\ndef reconstruct_from_basis(coeffs: dict, basis: str):\n    \"\"\"\n    Reconstruct the signal from depth-2 wavelet packet coefficients using different admissible bases:\n    - basis == 'B1': leaves {AA, AD, DA, DD}\n    - basis == 'B2': leaves {AA, AD, D1}\n    - basis == 'B3': leaves {A1, DA, DD}\n    Returns reconstructed signal x_hat.\n    \"\"\"\n    if basis == 'B1':\n        # First synthesize A1 and D1 from their children\n        a1_hat = synthesis_lifting_haar_biorth(coeffs['AA'], coeffs['AD'])\n        d1_hat = synthesis_lifting_haar_biorth(coeffs['DA'], coeffs['DD'])\n        # Then synthesize full signal\n        x_hat = synthesis_lifting_haar_biorth(a1_hat, d1_hat)\n        return x_hat\n    elif basis == 'B2':\n        # Synthesize A1 from AA, AD; use original D1\n        a1_hat = synthesis_lifting_haar_biorth(coeffs['AA'], coeffs['AD'])\n        d1 = coeffs['D1']\n        x_hat = synthesis_lifting_haar_biorth(a1_hat, d1)\n        return x_hat\n    elif basis == 'B3':\n        # Synthesize D1 from DA, DD; use original A1\n        d1_hat = synthesis_lifting_haar_biorth(coeffs['DA'], coeffs['DD'])\n        a1 = coeffs['A1']\n        x_hat = synthesis_lifting_haar_biorth(a1, d1_hat)\n        return x_hat\n    else:\n        raise ValueError(\"Unknown basis identifier\")\n\ndef max_abs_err(x: np.ndarray, y: np.ndarray) -> float:\n    return float(np.max(np.abs(x - y)))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Signals of length 8\n    x1 = np.array([3.0, 1.0, 0.0, -1.0, 2.0, 4.0, -2.0, 0.5], dtype=float)\n    x2 = np.array([5.0]*8, dtype=float)\n    x3 = np.array([1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0], dtype=float)\n\n    signals = [x1, x2, x3]\n    bases = ['B1', 'B2', 'B3']  # B1: {AA,AD,DA,DD}, B2: {AA,AD,D1}, B3: {A1,DA,DD}\n    tol = 1e-12\n\n    test_cases = []\n    for sig in signals:\n        for b in bases:\n            test_cases.append((sig, b))\n\n    results = []\n    for x, basis in test_cases:\n        coeffs = wp2_forward(x)\n        x_hat = reconstruct_from_basis(coeffs, basis)\n        err = max_abs_err(x, x_hat)\n        results.append(err <= tol)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2916274"}, {"introduction": "Many real-world applications, such as lossless image and data compression, require transforms that map integers to integers and are perfectly reversible. This exercise brings the lifting scheme into the practical domain by tasking you with implementing the integer-reversible Le Gall 5/3 biorthogonal wavelet, a cornerstone of the JPEG2000 standard [@problem_id:2916322]. You will grapple with the critical details of rounding and boundary handling to ensure that the transform achieves true lossless reconstruction, solidifying your understanding of how these theoretical tools are adapted for robust, practical systems.", "problem": "Design and implement a complete, runnable program that computes and inverts the integer-reversible transform corresponding to the Le Gall 5/3 biorthogonal wavelet using the lifting scheme with explicitly specified rounding. The program must verify numerically that reconstruction is lossless for a set of short integer signals and report a boolean result for each case.\n\nStart from the following fundamental base:\n- The lifting scheme factorizes two-channel perfect reconstruction filter banks into a sequence of prediction and update steps acting on even and odd indexed samples. Given an input integer sequence $x$ of length $N$, define its even-indexed part $s$ and odd-indexed part $o$ by $s[n] = x[2n]$ and $o[n] = x[2n+1]$, for all valid indices. The Le Gall 5/3 biorthogonal wavelet is known to admit a lifting factorization with a predict operator proportional to $-1/2$ and an update operator proportional to $1/4$.\n- Integer-to-integer transforms are constructed by replacing real-valued linear combinations with integer combinations followed by specified rounding, so that both forward and inverse steps map integers to integers exactly and compose to the identity when combined with the same boundary handling.\n\nTasks and specifications:\n1. Implement the forward transform using two lifting steps on $(s,o)$:\n   - Predict step (odd update): compute detail samples $d[n]$ from $o[n]$ using the neighbors of $s[n]$ that would correspond to a linear prediction with coefficient $-1/2$, but ensure integer outputs by applying the following rounding rule: use the floor of the average for divisions by $2$. Specifically, when computing an average of two integers $a$ and $b$, interpret it as $\\left\\lfloor \\dfrac{a + b}{2} \\right\\rfloor$.\n   - Update step (even update): refine $s[n]$ using neighboring detail samples $d$ corresponding to an update coefficient $1/4$, using round-to-nearest via a floor with offset. Specifically, for a sum of two integers $u$ and $v$, interpret $\\dfrac{u+v}{4}$ as $\\left\\lfloor \\dfrac{u + v + 2}{4} \\right\\rfloor$.\n2. Boundary handling: use symmetric extension at boundaries for missing neighbors. If a neighbor index would fall outside the valid range, replace it by the nearest valid index. For the special case when the detail array $d$ is empty (this occurs when $N = 1$), define the update contribution to be $0$.\n3. Implement the inverse transform by algebraically inverting the forward lifting steps with the same rounding conventions and boundary handling, in reverse order of application.\n4. Verification: for each test case, compute the forward transform $(s,d)$, then invert to reconstruct $\\hat{x}$, and check exact equality $\\hat{x} = x$ elementwise to produce a boolean result.\n5. Test suite to cover general and edge cases. Use the following input signals, each expressed as a Python-style list:\n   - Case 1 (mixed signs, odd length): [7, -3, 2, 9, -8, 1, 0].\n   - Case 2 (short, even length): [-3, 7].\n   - Case 3 (singleton): [42].\n   - Case 4 (constant): [5, 5, 5, 5, 5].\n   - Case 5 (alternating large magnitudes): [1000, -1000, 1000, -1000, 999, -999].\n   - Case 6 (zeros and negatives, odd length): [0, -1, 0, -1, 0].\n6. Output format: your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets. For example, an output for three cases should look like [True,False,True].\n\nYour implementation must be self-contained, use integer arithmetic consistent with the specified floor-based rounding rules, and use the symmetric extension boundary rule as stated. No physical units or angle units apply. The only permissible output is the required single-line list of booleans for the specified test suite, in the exact order provided.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n**Step 1: Extract Givens**\n- **Transform**: Integer-reversible transform for the Le Gall 5/3 biorthogonal wavelet.\n- **Method**: Lifting scheme consisting of a prediction step and an update step.\n- **Input Signal**: Integer sequence $x$ of length $N$.\n- **Signal Decomposition**: $s[n] = x[2n]$ (even-indexed samples), $o[n] = x[2n+1]$ (odd-indexed samples).\n- **Forward Transform Steps**:\n  1. **Predict (odd update)**: The detail coefficient $d[n]$ is computed from $o[n]$ and its neighbors in $s$. The operation corresponds to a real-valued predictor with coefficient $-\\frac{1}{2}$. Rounding for an average of integers $a$ and $b$ is specified as $\\left\\lfloor \\frac{a + b}{2} \\right\\rfloor$.\n  2. **Update (even update)**: The approximation coefficient $a[n]$ is computed by refining $s[n]$ with its neighboring detail coefficients $d$. The operation corresponds to a real-valued update with coefficient $\\frac{1}{4}$. Rounding for a term $\\frac{u+v}{4}$ is specified as $\\left\\lfloor \\frac{u + v + 2}{4} \\right\\rfloor$.\n- **Boundary Handling**: Symmetric extension, interpreted as \"replace an out-of-bounds neighbor index with the nearest valid index\". A special case is defined for an empty detail array $d$ (when $N=1$), where the update contribution is $0$.\n- **Inverse Transform**: Algebraically invert the forward lifting steps in reverse order, using identical rounding and boundary handling rules.\n- **Verification**: For each test case signal $x$, compute the forward transform to get $(a, d)$, then compute the inverse transform to get $\\hat{x}$, and verify if $\\hat{x} = x$.\n- **Test Cases**:\n  1. $[7, -3, 2, 9, -8, 1, 0]$\n  2. $[-3, 7]$\n  3. $[42]$\n  4. $[5, 5, 5, 5, 5]$\n  5. $[1000, -1000, 1000, -1000, 999, -999]$\n  6. $[0, -1, 0, -1, 0]$\n- **Output Format**: A single line containing a comma-separated list of boolean results for the test cases, enclosed in square brackets.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed for validity:\n- **Scientifically Grounded**: The problem is founded on the established mathematical principles of wavelet theory and the lifting scheme. The Le Gall 5/3 wavelet is a standard example of a biorthogonal wavelet, and its implementation via lifting is a well-documented technique. Integer-to-integer transforms using specified rounding are a valid method for lossless signal processing.\n- **Well-Posed**: The problem is precisely specified. It provides all necessary components: the input data structure, the transformation equations, the exact integer rounding rules, and the boundary handling conditions. This ensures that a unique and verifiable solution can be constructed.\n- **Objective**: The problem is stated in precise, objective language without ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a well-defined and self-contained exercise in computational signal processing. A solution will now be derived.\n\n### Solution Derivation\n\nThe implementation of the integer-reversible Le Gall 5/3 wavelet transform via the lifting scheme requires the careful construction of the forward and inverse transform steps, adhering strictly to the specified rounding and boundary rules.\n\n**1. Forward Transform**\n\nThe forward transform maps an input integer signal $x$ of length $N$ to a pair of integer sequences: the approximation coefficients $a$ and the detail coefficients $d$.\n\n**a. Splitting**\nThe input signal $x$ is first split into its even-indexed elements $s$ and odd-indexed elements $o$:\n$$ s[n] = x[2n], \\quad n \\in [0, \\lceil N/2 \\rceil - 1] $$\n$$ o[n] = x[2n+1], \\quad n \\in [0, \\lfloor N/2 \\rfloor - 1] $$\nThe lengths of $s$ and $o$ are $N_s = \\lceil N/2 \\rceil$ and $N_o = \\lfloor N/2 \\rfloor$, respectively.\n\n**b. Predict Step**\nThe odd samples $o$ are updated to produce detail coefficients $d$. The real-valued lifting step is $d[n] = o[n] - \\frac{1}{2}(s[n] + s[n+1])$. The specified integer implementation is:\n$$ d[n] = o[n] - \\left\\lfloor \\frac{s_{left} + s_{right}}{2} \\right\\rfloor $$\nThis is computed for each $n$ from $0$ to $N_o-1$. The neighbors $s_{left}$ and $s_{right}$ correspond to $s[n]$ and $s[n+1]$. Boundary handling is required.\n- For $o[n]$, the left neighbor is $s[n]$, which is always in bounds as $n \\le N_o-1 < N_s$.\n- The right neighbor is $s[n+1]$. If $n+1 \\ge N_s$, the index is out of bounds. The nearest valid index is $N_s-1$.\nThus, the neighbors are $s_{left} = s[n]$ and $s_{right} = s[\\min(n+1, N_s-1)]$.\n\n**c. Update Step**\nThe even samples $s$ are updated using the newly computed detail coefficients $d$ to produce the approximation coefficients $a$. The real-valued step is $a[n] = s[n] + \\frac{1}{4}(d[n-1] + d[n])$. The specified integer implementation is:\n$$ a[n] = s[n] + \\left\\lfloor \\frac{d_{left} + d_{right} + 2}{4} \\right\\rfloor $$\nThis is computed for each $n$ from $0$ to $N_s-1$.\n- Special Case: If $N=1$, then $N_o=0$ and the detail sequence $d$ is empty. The problem specifies the update is $0$, so $a[0] = s[0]$.\n- General Case ($N_o > 0$): For $s[n]$, the neighbors are $d[n-1]$ and $d[n]$. Boundary handling is applied:\n  - The left neighbor $d_{left}$ is found at index $n-1$. If $n-1 < 0$, the nearest valid index is $0$. So, $d_{left} = d[\\max(0, n-1)]$.\n  - The right neighbor $d_{right}$ is found at index $n$. If $n \\ge N_o$, the nearest valid index is $N_o-1$. So, $d_{right} = d[\\min(n, N_o-1)]$.\n\n**2. Inverse Transform**\n\nThe inverse transform reconstructs the original signal $\\hat{x}$ from the coefficients $(a, d)$ by reversing the forward steps.\n\n**a. Inverse Update Step**\nFirst, we reverse the update step to recover the original even samples, which we denote $s_{rec}$. This is achieved by subtraction:\n$$ s_{rec}[n] = a[n] - \\left\\lfloor \\frac{d_{left} + d_{right} + 2}{4} \\right\\rfloor $$\nThe boundary handling for $d_{left}$ and $d_{right}$ is identical to that in the forward update step. This operation is performed for $n$ from $0$ to $N_s-1$.\n\n**b. Inverse Predict Step**\nNext, we reverse the predict step to recover the original odd samples, $o_{rec}$. This is achieved by addition:\n$$ o_{rec}[n] = d[n] + \\left\\lfloor \\frac{s_{rec, left} + s_{rec, right}}{2} \\right\\rfloor $$\nThis operation uses the just-recovered even samples $s_{rec}$. The boundary handling for the neighbors from $s_{rec}$ is identical to that in the forward predict step. This is performed for $n$ from $0$ to $N_o-1$.\n\n**c. Merging**\nFinally, the reconstructed signal $\\hat{x}$ is formed by interleaving the recovered even and odd samples:\n$$ \\hat{x}[2n] = s_{rec}[n] $$\n$$ \\hat{x}[2n+1] = o_{rec}[n] $$\n\n**3. Verification**\nThe perfect reconstruction property is verified by checking for element-wise equality between the original signal $x$ and the reconstructed signal $\\hat{x}$. For each test case, the result is a boolean value indicating whether $x = \\hat{x}$. Because the integer arithmetic is designed to be perfectly reversible, this check validates the correctness of the implementation. All test cases are expected to yield a `True` result.", "answer": "```python\nimport numpy as np\n\ndef forward_lg53(x_in):\n    \"\"\"\n    Computes the forward Le Gall 5/3 integer wavelet transform using the lifting scheme.\n    \"\"\"\n    x = np.array(x_in, dtype=np.int64)\n    N = len(x)\n\n    if N == 0:\n        return np.array([], dtype=np.int64), np.array([], dtype=np.int64)\n\n    # Split the signal into even and odd samples\n    s = x[0::2]\n    o = x[1::2]\n    Ns = len(s)\n    No = len(o)\n\n    # 1. Predict step (odd samples update)\n    # d[n] = o[n] - floor((s[n] + s[n+1]) / 2)\n    d = np.zeros(No, dtype=np.int64)\n    for n in range(No):\n        s_left = s[n]\n        # Boundary handling for the right neighbor\n        s_right_idx = min(n + 1, Ns - 1)\n        s_right = s[s_right_idx]\n        d[n] = o[n] - (s_left + s_right) // 2\n\n    # 2. Update step (even samples update)\n    # a[n] = s[n] + floor((d[n-1] + d[n] + 2) / 4)\n    a = np.zeros(Ns, dtype=np.int64)\n    if No == 0:  # This handles the N=1 case where d is empty\n        a = s.copy()\n    else:\n        for n in range(Ns):\n            # Boundary handling for detail coefficient neighbors\n            d_left_idx = max(0, n - 1)\n            d_right_idx = min(n, No - 1)\n            d_left = d[d_left_idx]\n            d_right = d[d_right_idx]\n            a[n] = s[n] + (d_left + d_right + 2) // 4\n            \n    return a, d\n\ndef inverse_lg53(a, d):\n    \"\"\"\n    Computes the inverse Le Gall 5/3 integer wavelet transform.\n    \"\"\"\n    a = np.array(a, dtype=np.int64)\n    d = np.array(d, dtype=np.int64)\n    Ns = len(a)\n    No = len(d)\n    N = Ns + No\n\n    if N == 0:\n        return np.array([], dtype=np.int64)\n\n    # 1. Inverse Update step (recover s)\n    # s_rec[n] = a[n] - floor((d[n-1] + d[n] + 2) / 4)\n    s_rec = np.zeros(Ns, dtype=np.int64)\n    if No == 0: # Handles N=1 case\n        s_rec = a.copy()\n    else:\n        for n in range(Ns):\n            d_left_idx = max(0, n - 1)\n            d_right_idx = min(n, No - 1)\n            d_left = d[d_left_idx]\n            d_right = d[d_right_idx]\n            s_rec[n] = a[n] - (d_left + d_right + 2) // 4\n\n    # 2. Inverse Predict step (recover o)\n    # o_rec[n] = d[n] + floor((s_rec[n] + s_rec[n+1]) / 2)\n    o_rec = np.zeros(No, dtype=np.int64)\n    for n in range(No):\n        s_left = s_rec[n]\n        s_right_idx = min(n + 1, Ns - 1)\n        s_right = s_rec[s_right_idx]\n        o_rec[n] = d[n] + (s_left + s_right) // 2\n\n    # Merge the recovered even and odd samples\n    x_rec = np.zeros(N, dtype=np.int64)\n    x_rec[0::2] = s_rec\n    x_rec[1::2] = o_rec\n\n    return x_rec\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify perfect reconstruction.\n    \"\"\"\n    test_cases = [\n        # Case 1: mixed signs, odd length\n        [7, -3, 2, 9, -8, 1, 0],\n        # Case 2: short, even length\n        [-3, 7],\n        # Case 3: singleton\n        [42],\n        # Case 4: constant\n        [5, 5, 5, 5, 5],\n        # Case 5: alternating large magnitudes\n        [1000, -1000, 1000, -1000, 999, -999],\n        # Case 6: zeros and negatives, odd length\n        [0, -1, 0, -1, 0],\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert to numpy array with a safe integer type\n        x_original = np.array(case, dtype=np.int64)\n\n        # Perform forward transform\n        approximation_coeffs, detail_coeffs = forward_lg53(x_original)\n\n        # Perform inverse transform\n        x_reconstructed = inverse_lg53(approximation_coeffs, detail_coeffs)\n\n        # Verify perfect reconstruction\n        is_perfect = np.array_equal(x_original, x_reconstructed)\n        results.append(is_perfect)\n\n    # Format the output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2916322"}]}