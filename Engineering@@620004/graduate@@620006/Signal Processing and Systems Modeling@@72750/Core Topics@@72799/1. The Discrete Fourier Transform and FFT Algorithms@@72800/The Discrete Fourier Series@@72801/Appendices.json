{"hands_on_practices": [{"introduction": "The Discrete Fourier Series (DFS) decomposes a signal into its frequency components, each described by a magnitude and a phase. While it is common to visualize the frequency content using the magnitude spectrum, the phase spectrum is equally critical for defining the signal's structure. This exercise challenges you to demonstrate concretely that the DFS magnitude alone is insufficient for unique signal reconstruction, forcing a deeper consideration of the fundamental role of phase information [@problem_id:2896131].", "problem": "Let $N \\geq 3$ be a fixed positive integer. Consider length-$N$ periodic sequences and their $N$-point discrete Fourier series (DFS), defined by\n$$\nX[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-j \\frac{2\\pi}{N} k n\\right), \\quad k=0,1,\\dots,N-1,\n$$\nwith inverse\n$$\nx[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp\\!\\left(j \\frac{2\\pi}{N} k n\\right), \\quad n=0,1,\\dots,N-1.\n$$\nConstruct two explicit, distinct $N$-periodic sequences $x_{1}[n]$ and $x_{2}[n]$ whose DFS magnitudes are identical for every harmonic index $k$, that is, $|X_{1}[k]| = |X_{2}[k]|$ for all $k$, but whose phases differ for at least one $k$, that is, $\\arg X_{1}[k] \\neq \\arg X_{2}[k]$ for some $k$. Your construction must be justified directly from the DFS definitions above, not by appealing to any unproved transform property. Then, compute the squared Euclidean distance\n$$\nD \\triangleq \\sum_{n=0}^{N-1} \\left| x_{1}[n] - x_{2}[n] \\right|^{2}.\n$$\nExpress your final answer as a single real number or a closed-form analytic expression. Finally, explain, using only reasoning grounded in the DFS definitions, the implication of your construction for the uniqueness of signal reconstruction from magnitude-only DFS data. No numerical rounding is required, and no physical units apply.", "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n-   $N \\geq 3$ is a fixed positive integer.\n-   Length-$N$ periodic sequence $x[n]$.\n-   $N$-point discrete Fourier series (DFS): $X[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\exp(-j \\frac{2\\pi}{N} k n)$, for $k=0,1,\\dots,N-1$.\n-   Inverse DFS: $x[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp(j \\frac{2\\pi}{N} k n)$, for $n=0,1,\\dots,N-1$.\n-   Required Construction: Two distinct $N$-periodic sequences $x_{1}[n]$ and $x_{2}[n]$ such that $|X_{1}[k]| = |X_{2}[k]|$ for all $k$, but $\\arg X_{1}[k] \\neq \\arg X_{2}[k]$ for at least one $k$.\n-   Required Calculation: The squared Euclidean distance $D \\triangleq \\sum_{n=0}^{N-1} | x_{1}[n] - x_{2}[n] |^{2}$.\n-   Required Explanation: The implication of the construction for the uniqueness of signal reconstruction from magnitude-only DFS data, based only on the given definitions.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem is a standard exercise in discrete-time signal processing, based on the fundamental definitions of the Discrete Fourier Series. All concepts are mathematically sound.\n-   **Well-Posed:** The problem is clearly stated, providing all necessary definitions and constraints. It requests a specific construction and a subsequent calculation, which is a well-defined task. The constraint $N \\geq 3$ is crucial and correctly specified.\n-   **Objective:** The problem is formulated with precise, objective mathematical language, free from ambiguity or subjective content.\n-   The problem does not violate any other validity criteria. It is not incomplete, contradictory, unrealistic, ill-posed, or trivial.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A complete solution will be provided.\n\nWe begin by constructing the two sequences $x_{1}[n]$ and $x_{2}[n]$. A simple and canonical choice that satisfies the requirements is to use shifted unit impulses. Let us define the sequences as:\n$$x_{1}[n] \\triangleq \\delta[n-1]$$\n$$x_{2}[n] \\triangleq \\delta[n-(N-1)]$$\nwhere $\\delta[m]$ is the discrete-time unit impulse (Kronecker delta), which is $1$ if $m \\equiv 0 \\pmod{N}$ and $0$ otherwise.\n\nWe must now verify that this construction meets all the stated requirements, using only reasoning based on the provided DFS definitions.\n$1$. **Distinctness of Sequences**: The sequence $x_{1}[n]$ is non-zero only at $n=1$, where $x_{1}[1]=1$. The sequence $x_{2}[n]$ is non-zero only at $n=N-1$, where $x_{2}[N-1]=1$. Since the problem specifies $N \\geq 3$, the indices $1$ and $N-1$ are distinct. Thus, $x_{1}[n]$ and $x_{2}[n]$ are distinct sequences.\n\n$2$. **DFS Properties**: We compute the DFS for each sequence directly from the definition.\nFor $x_{1}[n]$, its DFS $X_{1}[k]$ is:\n$$X_{1}[k] = \\sum_{n=0}^{N-1} \\delta[n-1] \\exp\\left(-j \\frac{2\\pi}{N} k n\\right) = \\exp\\left(-j \\frac{2\\pi}{N} k \\cdot 1\\right) = \\exp\\left(-j \\frac{2\\pi k}{N}\\right)$$\nFor $x_{2}[n]$, its DFS $X_{2}[k]$ is:\n$$X_{2}[k] = \\sum_{n=0}^{N-1} \\delta[n-(N-1)] \\exp\\left(-j \\frac{2\\pi}{N} k n\\right) = \\exp\\left(-j \\frac{2\\pi}{N} k (N-1)\\right) = \\exp\\left(-j 2\\pi k + j \\frac{2\\pi k}{N}\\right) = \\exp\\left(j \\frac{2\\pi k}{N}\\right)$$\nNow we examine the magnitudes and phases.\nThe magnitudes are:\n$$|X_{1}[k]| = \\left|\\exp\\left(-j \\frac{2\\pi k}{N}\\right)\\right| = 1$$\n$$|X_{2}[k]| = \\left|\\exp\\left(j \\frac{2\\pi k}{N}\\right)\\right| = 1$$\nClearly, $|X_{1}[k]| = |X_{2}[k]|$ for all $k \\in \\{0, 1, \\dots, N-1\\}$. The magnitude condition is satisfied.\n\nThe phases are:\n$$\\arg X_{1}[k] = -\\frac{2\\pi k}{N} \\pmod{2\\pi}$$\n$$\\arg X_{2}[k] = \\frac{2\\pi k}{N} \\pmod{2\\pi}$$\nFor the phases to differ, we need to find a $k$ such that $\\arg X_{1}[k] \\neq \\arg X_{2}[k]$. This is equivalent to $-\\frac{2\\pi k}{N} \\not\\equiv \\frac{2\\pi k}{N} \\pmod{2\\pi}$, which simplifies to requiring that $\\frac{4\\pi k}{N}$ is not an integer multiple of $2\\pi$, or that $\\frac{2k}{N}$ is not an integer.\nLet us choose $k=1$. Since $N \\geq 3$, the value $\\frac{2(1)}{N} = \\frac{2}{N}$ is not an integer. Therefore, for $k=1$, $\\arg X_{1}[1] = -2\\pi/N$ and $\\arg X_{2}[1] = 2\\pi/N$ are indeed different. The phase condition is satisfied.\n\nHaving validated our construction, we now compute the squared Euclidean distance $D$:\n$$D \\triangleq \\sum_{n=0}^{N-1} \\left| x_{1}[n] - x_{2}[n] \\right|^{2}$$\nThe difference sequence is $d[n] = x_{1}[n] - x_{2}[n] = \\delta[n-1] - \\delta[n-(N-1)]$. This sequence consists of the following values over one period $n \\in \\{0, 1, \\dots, N-1\\}$:\n$$d[n] = \\begin{cases} 1 & n=1 \\\\ -1 & n=N-1 \\\\ 0 & \\text{otherwise} \\end{cases}$$\nThe sum of the squared magnitudes of these values is:\n$$D = |d[1]|^{2} + |d[N-1]|^{2} + \\sum_{n \\in \\{0, \\dots, N-1\\}, n \\neq 1, n \\neq N-1} |d[n]|^{2} = |1|^{2} + |-1|^{2} + 0 = 1 + 1 = 2$$\nThe squared Euclidean distance is $2$.\n\nAs confirmation, this result can be derived using Parseval's relation, which must first be proven from the given definitions. For any sequence $y[n]$ with DFS $Y[k]$:\n$$ \\sum_{n=0}^{N-1} |y[n]|^2 = \\sum_{n=0}^{N-1} y[n] y^*[n] = \\sum_{n=0}^{N-1} \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j\\frac{2\\pi}{N}kn}\\right) \\left(\\frac{1}{N} \\sum_{l=0}^{N-1} Y^*[l] e^{-j\\frac{2\\pi}{N}ln}\\right) $$\n$$ = \\frac{1}{N^2} \\sum_{k=0}^{N-1} \\sum_{l=0}^{N-1} Y[k] Y^*[l] \\left(\\sum_{n=0}^{N-1} e^{j\\frac{2\\pi}{N}(k-l)n}\\right) $$\nThe inner sum equals $N$ if $k=l$ and $0$ otherwise. This reduces the expression to:\n$$ \\sum_{n=0}^{N-1} |y[n]|^2 = \\frac{1}{N^2} \\sum_{k=0}^{N-1} Y[k] Y^*[k] (N) = \\frac{1}{N} \\sum_{k=0}^{N-1} |Y[k]|^2 $$\nApplying this to our difference sequence $d[n]$, whose DFS is $D[k] = X_{1}[k] - X_{2}[k]$:\n$$ D = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_{1}[k] - X_{2}[k]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left| -2j \\sin\\left(\\frac{2\\pi k}{N}\\right) \\right|^2 = \\frac{4}{N} \\sum_{k=0}^{N-1} \\sin^2\\left(\\frac{2\\pi k}{N}\\right) $$\nUsing the identity $\\sin^2(\\theta) = \\frac{1}{2}(1-\\cos(2\\theta))$:\n$$ D = \\frac{4}{N} \\sum_{k=0}^{N-1} \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{4\\pi k}{N}\\right)\\right) = \\frac{2}{N} \\left( \\sum_{k=0}^{N-1} 1 - \\sum_{k=0}^{N-1} \\cos\\left(\\frac{4\\pi k}{N}\\right) \\right) $$\nThe first sum is $N$. The second sum is the real part of a geometric series sum $\\sum_{k=0}^{N-1} (\\exp(j\\frac{4\\pi}{N}))^k$, which is zero since its ratio is not $1$ for $N \\geq 3$. Thus, $\\sum \\cos(\\dots)=0$.\n$$ D = \\frac{2}{N} (N - 0) = 2 $$\nThis confirms the result from the direct time-domain calculation.\n\nFinally, we explain the implication for uniqueness of signal reconstruction from magnitude-only DFS data. The inverse DFS definition, $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp(j \\frac{2\\pi}{N} k n)$, can be expressed in terms of magnitude and phase as:\n$$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]| \\exp(j \\arg X[k]) \\exp\\left(j \\frac{2\\pi}{N} k n\\right)$$\nThis formula explicitly shows that reconstruction of the sequence $x[n]$ requires knowledge of both the DFS magnitude $|X[k]|$ and the DFS phase $\\arg X[k]$. Our construction provides a concrete counterexample to the possibility of unique reconstruction from magnitude alone. We have shown the existence of two distinct sequences, $x_{1}[n]$ and $x_{2}[n]$, which produce identical DFS magnitude spectra, $|X_{1}[k]| = |X_{2}[k]|$. An observer who is provided only with this magnitude spectrum has no way to determine whether the original sequence was $x_{1}[n]$ or $x_{2}[n]$, because the phase information that distinguishes them is unavailable. This demonstrates that the mapping from a sequence $x[n]$ to its DFS magnitude spectrum $|X[k]|$ is not injective (one-to-one). Consequently, without additional information or constraints (such as minimum phase, causality, or known properties of the signal), the unique recovery of an arbitrary signal from its Fourier magnitude is fundamentally impossible.", "answer": "$$\\boxed{2}$$", "id": "2896131"}, {"introduction": "One of the most transformative applications of the Fourier transform is its ability to convert computationally intensive time-domain convolutions into simple frequency-domain multiplications. This powerful property, known as the convolution theorem, is the engine behind many fast algorithms. This practice guides you through a rigorous, first-principles analysis to quantify the computational trade-off and determine the precise \"break-even\" point where the FFT-based method becomes more efficient than direct, sparse convolution [@problem_id:2896155].", "problem": "Consider complex, length-$N$ periodic sequences in the discrete-time domain, and let the Discrete Fourier Series (DFS) of a sequence $x[n]$ be defined by the analysis-synthesis pair\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\Big(-j \\frac{2\\pi}{N}kn\\Big), \\quad\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\!\\Big(j \\frac{2\\pi}{N}kn\\Big),\n$$\nfor $k,n \\in \\{0,1,\\dots,N-1\\}$. The length-$N$ circular convolution of two sequences $x[n]$ and $h[n]$ is\n$$\ny[n] = \\sum_{m=0}^{N-1} x[m]\\, h[(n-m) \\bmod N].\n$$\nAssume $h[n]$ is $K$-sparse, meaning exactly $K$ of its $N$ entries are nonzero, and the support of $h[n]$ is known. You are to compare two methods for computing $y[n]$: \n- Direct circular convolution in the time domain that exploits the sparsity of $h[n]$, and \n- A DFS-based method that forms $X[k]$ and multiplies it by $H[k]$, then applies the inverse DFS to obtain $y[n]$. \n\nAssume the following computational model:\n- Count real floating-point operations with unit weights: each real addition counts as $1$, and each real multiplication counts as $1$. \n- One complex addition is $2$ real additions.\n- One complex multiplication is $4$ real multiplications and $2$ real additions, for a total of $6$ real operations.\n- The DFS and its inverse are implemented using a radix-$2$ Cooley–Tukey Fast Fourier Transform (FFT). A length-$N$ radix-$2$ FFT has $\\log_{2} N$ stages, each with $N/2$ butterflies, and each butterfly consists of exactly one complex multiplication by a twiddle factor and two complex additions.\n- The DFS of $h[n]$ is precomputed and available as $H[k]$, so that per-evaluation cost for the DFS-based method includes one forward FFT of $x[n]$, $N$ pointwise complex multiplications $X[k]H[k]$, and one inverse FFT to synthesize $y[n]$.\n\nStarting from the fundamental definitions above and any properties you can derive from them, perform an operation-count comparison between these two methods specialized to $N=4096$. Determine the exact break-even sparsity level $K_{\\text{be}}$ at which both methods require the same total number of real operations for one evaluation of $y[n]$. Report your final result for $K_{\\text{be}}$ as a single number. No rounding is required.", "solution": "The problem as stated will first be subject to validation to ensure it is scientifically sound, self-contained, and well-posed.\n\nThe givens are extracted verbatim from the problem statement:\n- The sequences are complex, periodic with length $N$.\n- The Discrete Fourier Series (DFS) analysis equation is $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp(-j \\frac{2\\pi}{N}kn)$.\n- The DFS synthesis equation is $x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp(j \\frac{2\\pi}{N}kn)$.\n- The indices $k, n$ are in the set $\\{0, 1, \\dots, N-1\\}$.\n- The length-$N$ circular convolution is $y[n] = \\sum_{m=0}^{N-1} x[m]\\, h[(n-m) \\bmod N]$.\n- The sequence $h[n]$ is $K$-sparse, meaning exactly $K$ of its $N$ entries are non-zero.\n- The support of $h[n]$ (the locations of non-zero entries) is known.\n- The specific length is $N=4096$.\n- The computational cost model counts real floating-point operations (FLOPS):\n    - A real addition costs $1$ FLOP.\n    - A real multiplication costs $1$ FLOP.\n    - A complex addition is equivalent to $2$ real additions ($2$ FLOPS).\n    - A complex multiplication is equivalent to $4$ real multiplications and $2$ real additions ($6$ FLOPS).\n- The DFS and its inverse are computed using a radix-$2$ Cooley–Tukey Fast Fourier Transform (FFT).\n- A length-$N$ radix-$2$ FFT has $\\log_2 N$ stages.\n- Each stage has $N/2$ butterflies.\n- Each butterfly calculation consists of one complex multiplication and two complex additions.\n- The DFS of $h[n]$, denoted $H[k]$, is precomputed and its cost is not included in the comparison.\n- The DFS-based method cost consists of: one forward FFT of $x[n]$, $N$ pointwise complex multiplications, and one inverse FFT of the product.\n\nThe problem is valid. It is scientifically grounded in the established principles of digital signal processing, specifically the theory of discrete Fourier analysis and fast algorithms for convolution. It is well-posed, providing all necessary definitions, constants ($N=4096$), and a complete computational cost model to allow for a unique, deterministic solution. The problem statement is objective and uses precise, standard terminology. There are no contradictions, ambiguities, or missing information. The use of a radix-$2$ FFT is consistent with $N=4096$, which is a power of $2$ ($4096 = 2^{12}$).\n\nWe proceed to the solution. The objective is to find the break-even sparsity level $K_{\\text{be}}$ for which the computational cost of the direct time-domain method equals the cost of the frequency-domain (FFT-based) method.\n\nFirst, we determine the computational cost of the direct method, $C_D$. The circular convolution is given by\n$$\ny[n] = \\sum_{m=0}^{N-1} x[m]\\, h[(n-m) \\bmod N].\n$$\nTo compute a single output sample $y[n]$, this sum involves $N$ multiplications and $N-1$ additions. However, the sequence $h[n]$ is $K$-sparse. Since the support of $h[n]$ is known, we can exploit this sparsity. Let the set of indices where $h[n]$ is non-zero be $\\mathcal{S}_h = \\{n_1, n_2, \\dots, n_K\\}$. The convolution sum for a given $n$ reduces to a sum over only $K$ terms. For each $n \\in \\{0, 1, \\dots, N-1\\}$, the computation is\n$$\ny[n] = \\sum_{i=1}^{K} x[(n-n_i) \\bmod N] \\, h[n_i].\n$$\nFor each output sample $y[n]$, we perform $K$ complex multiplications (one for each term in the sum) and $K-1$ complex additions to sum the resulting products.\nThe cost to compute one sample $y[n]$ in terms of real operations is:\n- Cost of $K$ complex multiplications: $K \\times (4 \\text{ real muls} + 2 \\text{ real adds}) = K \\times 6 = 6K$ FLOPS.\n- Cost of $K-1$ complex additions: $(K-1) \\times (2 \\text{ real adds}) = 2K-2$ FLOPS.\nThe total cost for one sample $y[n]$ is $6K + (2K-2) = 8K-2$ FLOPS.\nTo compute the entire output sequence $y[n]$ for $n=0, 1, \\dots, N-1$, we must repeat this calculation $N$ times.\nTherefore, the total cost of the direct method is\n$$\nC_D(K) = N(8K-2).\n$$\n\nNext, we determine the computational cost of the FFT-based method, $C_F$. This method involves three steps:\n1. Compute the DFS of $x[n]$: $X[k] = \\text{FFT}(x[n])$.\n2. Perform pointwise multiplication in the frequency domain: $Y[k] = X[k]H[k]$.\n3. Compute the inverse DFS to get the result: $y[n] = \\text{IFFT}(Y[k])$.\n\nWe analyze the cost of each step using the provided model.\nThe cost of an $N$-point radix-$2$ FFT is based on its structure. It has $\\log_2 N$ stages, each with $N/2$ butterflies. Each butterfly involves $1$ complex multiplication and $2$ complex additions.\nThe cost of one butterfly in real operations is:\n- $1$ complex multiplication: $6$ FLOPS.\n- $2$ complex additions: $2 \\times 2 = 4$ FLOPS.\nTotal cost per butterfly is $6+4=10$ FLOPS.\nThe total cost for one $N$-point FFT is the number of stages multiplied by the number of butterflies per stage multiplied by the cost per butterfly:\n$$\nC_{\\text{FFT}} = (\\log_2 N) \\times \\Big(\\frac{N}{2}\\Big) \\times 10 = 5N \\log_2 N \\text{ FLOPS}.\n$$\nThe problem states the inverse FFT has the same implementation basis. We assume its computational cost is identical to the forward FFT. This is a standard assumption, as the IFFT algorithm differs only by the sign of the exponential's argument and a final scaling factor of $1/N$, whose operational cost is often considered negligible in comparison or absorbed into the algorithm stages without changing the overall complexity class. The problem statement separates the process into three distinct computational blocks, implying we sum their costs as defined.\n\nThe total cost $C_F$ is the sum of the costs of the forward FFT, the pointwise multiplications, and the inverse FFT.\n- Cost of forward FFT of $x[n]$: $5N \\log_2 N$.\n- Cost of $N$ pointwise complex multiplications $X[k]H[k]$: $N \\times (6 \\text{ FLOPS/mul}) = 6N$.\n- Cost of inverse FFT: $5N \\log_2 N$.\n\nSumming these components gives the total cost for the FFT-based method:\n$$\nC_F = 5N \\log_2 N + 6N + 5N \\log_2 N = 10N \\log_2 N + 6N.\n$$\n\nThe break-even point $K_{\\text{be}}$ is the value of $K$ where the two costs are equal: $C_D(K_{\\text{be}}) = C_F$.\n$$\nN(8K_{\\text{be}}-2) = 10N \\log_2 N + 6N.\n$$\nSince $N=4096 \\neq 0$, we can divide the entire equation by $N$:\n$$\n8K_{\\text{be}}-2 = 10 \\log_2 N + 6.\n$$\nNow, we solve for $K_{\\text{be}}$:\n$$\n8K_{\\text{be}} = 10 \\log_2 N + 8.\n$$\n$$\nK_{\\text{be}} = \\frac{10 \\log_2 N + 8}{8} = \\frac{5}{4}\\log_2 N + 1.\n$$\nThe problem specifies $N=4096$. We calculate $\\log_2 N$:\n$$\n\\log_2(4096) = \\log_2(2^{12}) = 12.\n$$\nSubstituting this value into the expression for $K_{\\text{be}}$:\n$$\nK_{\\text{be}} = \\frac{5}{4}(12) + 1 = 5 \\times 3 + 1 = 15 + 1 = 16.\n$$\nThus, for a sparsity level of $K=16$, the computational costs of the two methods are identical. For $K<16$, the direct method is more efficient. For $K>16$, the FFT-based method is more efficient. The exact break-even sparsity is $16$.", "answer": "$$\\boxed{16}$$", "id": "2896155"}, {"introduction": "While the DFS is a powerful tool for representing periodic signals, its effectiveness can be limited when dealing with signals containing abrupt changes or discontinuities. The resulting partial Fourier sums exhibit a persistent overshoot near the jump, a phenomenon named after Josiah Willard Gibbs. This computational practice will allow you to construct and quantify this behavior from the ground up, providing a tangible understanding of the convergence properties and limitations of Fourier analysis in practical scenarios [@problem_id:2896135].", "problem": "You are to write a complete and runnable program that constructs a discrete-time periodic step sequence, computes its Discrete Fourier Series (DFS) partial sums, and quantitatively evaluates the discrete-time Gibbs phenomenon near a discontinuity. The goal is to test your reasoning from first principles about the properties of the DFS and its partial sums applied to sequences with jump discontinuities.\n\nDefinitions and constraints to use:\n- Consider a complex-valued, discrete-time sequence $x[n]$ with period $N \\in \\mathbb{Z}_{>0}$. Use the standard Discrete Fourier Transform (DFT) conventions (equivalently, the Discrete Fourier Series (DFS) conventions for periodic sequences) with complex exponentials in radians:\n  - Analysis: $X[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi k n / N}$ for $k \\in \\{0,1,\\dots,N-1\\}$.\n  - Synthesis: $x[n] = \\dfrac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi k n / N}$ for all integers $n$.\n  - Angles must be in radians.\n- Define a step sequence with levels $x_{\\text{low}}$ and $x_{\\text{high}}$ by specifying a rising index $n_0 \\in \\{0,1,\\dots,N-1\\}$ and an active duration $L \\in \\{1,2,\\dots,N-1\\}$. The $N$-periodic step is\n  $$\n  x[n] =\n  \\begin{cases}\n  x_{\\text{high}}, & n \\in \\{ n_0, n_0+1, \\dots, n_0+L-1 \\} \\ (\\text{all indices modulo } N),\\\\\n  x_{\\text{low}}, & \\text{otherwise}.\n  \\end{cases}\n  $$\n  This creates a rising jump at $n=n_0$ (from $x_{\\text{low}}$ to $x_{\\text{high}}$) and a falling jump at $n = n_0 + L$ (indices modulo $N$). Assume $x_{\\text{high}} \\neq x_{\\text{low}}$ so the jump magnitude is $\\Delta \\triangleq x_{\\text{high}} - x_{\\text{low}} \\neq 0$.\n- For an integer partial-sum order $M$ with $M \\in \\{0,1,\\dots,\\lfloor (N-1)/2 \\rfloor\\}$, define the DFS partial sum $x_M[n]$ by preserving the $2M+1$ centered harmonics $\\{-M,-M+1,\\dots,0,\\dots,M\\}$ in the DFS sense. Concretely, using the DFT $X[k]$, retain indices $k \\in \\{0,1,\\dots,M\\} \\cup \\{N-M, \\dots, N-1\\}$ and set all other $X[k]$ to zero; then synthesize $x_M[n]$ via the inverse DFT. This yields the $2M+1$-term Fourier partial sum in the discrete-time setting.\n- To characterize the discrete-time Gibbs phenomenon near the rising edge at $n=n_0$, compute the local overshoot and undershoot of $x_M[n]$ relative to the ideal step levels, normalized by the jump magnitude $\\Delta$. Let the window half-width be $w \\triangleq \\max\\{1, \\lfloor 0.1 N \\rfloor\\}$. Consider the set of indices $\\mathcal{W} \\triangleq \\{ n_0 - w, n_0 - w + 1, \\dots, n_0 + w \\}$ with indices understood modulo $N$.\n  - The overshoot ratio is\n    $$\n    \\rho_{\\text{over}} \\triangleq \\max\\left\\{ 0, \\frac{\\max_{n \\in \\mathcal{W}} x_M[n] - x_{\\text{high}}}{\\Delta} \\right\\}.\n    $$\n  - The undershoot ratio is\n    $$\n    \\rho_{\\text{under}} \\triangleq \\max\\left\\{ 0, \\frac{x_{\\text{low}} - \\min_{n \\in \\mathcal{W}} x_M[n]}{\\Delta} \\right\\}.\n    $$\n  Both ratios must be reported as pure decimal numbers (dimensionless), not as percentages.\n\nTask:\n- Implement from first principles the construction of $x[n]$, the computation of its DFT $X[k]$, the formation of the partial-sum spectrum by retaining $2M+1$ centered harmonics, and the synthesis of $x_M[n]$.\n- Then compute $\\rho_{\\text{over}}$ and $\\rho_{\\text{under}}$ as defined above for the following test suite of parameter sets. Each test case is given as a tuple $(N, n_0, L, x_{\\text{low}}, x_{\\text{high}}, M)$:\n\nTest suite (covering a typical case, increased order, duty-cycle variation, boundary orders, and small-period effects):\n- Case $1$: $(128, 64, 64, 0, 1, 31)$.\n- Case $2$: $(128, 64, 64, 0, 1, 63)$.\n- Case $3$: $(129, 10, 39, 0, 1, 40)$.\n- Case $4$: $(128, 64, 64, 0, 1, 0)$.\n- Case $5$: $(16, 8, 8, 0, 1, 7)$.\n- Case $6$: $(128, 64, 64, 0, 1, 1)$.\n\nOutput specification:\n- For each test case, output the two ratios in the order $(\\rho_{\\text{over}}, \\rho_{\\text{under}})$, both rounded to exactly $6$ decimal places using standard rounding to nearest.\n- Aggregate the results across all cases into a single flat list in test-case order. That is, the final output is a single line containing a list with $12$ decimal numbers:\n  $$\n  [\\rho_{\\text{over}}^{(1)}, \\rho_{\\text{under}}^{(1)}, \\rho_{\\text{over}}^{(2)}, \\rho_{\\text{under}}^{(2)}, \\dots, \\rho_{\\text{over}}^{(6)}, \\rho_{\\text{under}}^{(6)}].\n  $$\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_{12}]$). Angles must be in radians throughout, and all reported values are pure decimals (no units, no percentage signs).\n\nScientific basis required:\n- Begin from the DFS analysis and synthesis definitions above, the notion of truncating harmonics to form partial sums, and standard properties of orthogonality of complex exponentials. Do not rely on any pre-quoted special-case closed forms as a computational shortcut; derive and implement the algorithm directly from the DFS framework.", "solution": "The problem as stated is valid. It is scientifically grounded in the established principles of Discrete Fourier Series (DFS) analysis for periodic signals, is mathematically well-posed with all necessary parameters and definitions provided, and is entirely objective. No inconsistencies, ambiguities, or factual errors are present. We shall therefore proceed with a rigorous solution derived from first principles.\n\nThe task is to numerically analyze the Gibbs phenomenon in the discrete-time domain. This phenomenon is an inherent property of representing a function with jump discontinuities using a truncated Fourier series. The partial sum of the series exhibits oscillations, or \"ripples,\" near the discontinuity, where the peak of the oscillation overshoots the true value of the function. We are required to construct a discrete-time periodic step sequence, compute its approximation using a truncated DFS, and quantify the resulting overshoot and undershoot.\n\nThe entire procedure will be derived directly from the provided definitions for the DFS analysis and synthesis pair.\n\n1.  **Construction of the Periodic Step Sequence $x[n]$**\n    The problem defines an $N$-periodic step sequence $x[n]$ with two levels, $x_{\\text{low}}$ and $x_{\\text{high}}$. The sequence is at the high level for $L$ consecutive samples, starting at index $n_0$, and at the low level otherwise. The indices are interpreted modulo $N$.\n    To construct this sequence for a given set of parameters $(N, n_0, L, x_{\\text{low}}, x_{\\text{high}})$, we first create a numerical array of length $N$ and initialize all its elements to $x_{\\text{low}}$. Subsequently, we identify the indices corresponding to the high-level portion, which are $\\{n_0, n_0+1, \\dots, n_0+L-1\\}$. Using modulo-$N$ arithmetic, these indices are correctly mapped into the range $[0, N-1]$. The elements of the array at these specific indices are then set to $x_{\\text{high}}$. The jump magnitude is defined as $\\Delta = x_{\\text{high}} - x_{\\text{low}}$.\n\n2.  **DFS Analysis: Computation of Coefficients $X[k]$**\n    The DFS analysis equation provides the frequency-domain representation, $X[k]$, of the periodic sequence $x[n]$:\n    $$\n    X[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi k n / N}\n    $$\n    This is the standard definition of the Discrete Fourier Transform (DFT). For numerical computation, we employ the Fast Fourier Transform (FFT) algorithm, which is a highly efficient implementation of this summation. The result is an array $X$ of $N$ complex-valued DFS coefficients.\n\n3.  **Formation of the Partial Sum Spectrum $X_M[k]$**\n    The DFS partial sum, $x_M[n]$, is synthesized from a truncated set of DFS coefficients. The problem specifies that the $2M+1$ \"centered\" harmonics are to be retained. For a DFS spectrum of length $N$, the frequency indices $k \\in \\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$ correspond to non-negative frequencies, while indices $k \\in \\{\\lfloor N/2 \\rfloor + 1, \\dots, N-1\\}$ correspond to negative frequencies, where $X[N-k]$ represents the coefficient for the frequency corresponding to $-k$.\n    Thus, retaining the centered harmonics from $-M$ to $M$ is equivalent to keeping the coefficients $X[k]$ for $k \\in \\{0, 1, \\dots, M\\}$ and $k \\in \\{N-M, \\dots, N-1\\}$. A new spectrum, $X_M[k]$, is formed by setting all other coefficients of $X[k]$ to zero. This is effectively a frequency-domain multiplication of $X[k]$ with an ideal low-pass filter mask.\n\n4.  **DFS Synthesis: Computation of the Partial Sum Sequence $x_M[n]$**\n    The partial sum sequence $x_M[n]$ is obtained by applying the DFS synthesis formula to the truncated spectrum $X_M[k]$:\n    $$\n    x_M[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X_M[k] \\, e^{j 2\\pi k n / N}\n    $$\n    This is the definition of the Inverse Discrete Fourier Transform (IDFT). We use the Inverse Fast Fourier Transform (IFFT) algorithm for its computation. The IFFT correctly implements this synthesis sum, including the scaling factor of $1/N$. Since the original sequence $x[n]$ is real-valued, and the truncation of its spectrum preserves conjugate symmetry (i.e., $X_M[k] = X_M[N-k]^*$), the resulting sequence $x_M[n]$ must also be real. Any residual imaginary component in the numerical result is due to floating-point precision error and must be discarded.\n\n5.  **Quantification of Gibbs Phenomenon**\n    To quantify the overshoot and undershoot, we examine the behavior of $x_M[n]$ in a window around the rising-edge discontinuity at $n=n_0$.\n    The window half-width is $w = \\max\\{1, \\lfloor 0.1 N \\rfloor\\}$.\n    The set of indices for analysis is $\\mathcal{W} = \\{ n_0 - w, \\dots, n_0, \\dots, n_0 + w\\}$, with all indices taken modulo $N$.\n    Within this window, we find the maximum value, $\\max_{n \\in \\mathcal{W}} x_M[n]$, and the minimum value, $\\min_{n \\in \\mathcal{W}} x_M[n]$.\n    The normalized overshoot and undershoot ratios are then calculated according to the provided formulas:\n    $$\n    \\rho_{\\text{over}} = \\max\\left\\{ 0, \\frac{\\max_{n \\in \\mathcal{W}} x_M[n] - x_{\\text{high}}}{\\Delta} \\right\\}\n    $$\n    $$\n    \\rho_{\\text{under}} = \\max\\left\\{ 0, \\frac{x_{\\text{low}} - \\min_{n \\in \\mathcal{W}} x_M[n]}{\\Delta} \\right\\}\n    $$\n    These calculations are performed for each test case specified in the problem statement. The final results are rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a discrete-time periodic step sequence, computes its Discrete Fourier Series (DFS)\n    partial sums, and quantitatively evaluates the discrete-time Gibbs phenomenon.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, n0, L, x_low, x_high, M)\n    test_cases = [\n        (128, 64, 64, 0, 1, 31),\n        (128, 64, 64, 0, 1, 63),\n        (129, 10, 39, 0, 1, 40),\n        (128, 64, 64, 0, 1, 0),\n        (16, 8, 8, 0, 1, 7),\n        (128, 64, 64, 0, 1, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, n0, L, x_low, x_high, M = case\n        \n        # Step 1: Construct the periodic step sequence x[n]\n        # Initialize sequence with the low value\n        x = np.full(N, x_low, dtype=float)\n        \n        # Determine indices for the high value, handling wrapping with modulo N\n        high_indices = (n0 + np.arange(L)) % N\n        x[high_indices] = x_high\n\n        # Jump magnitude\n        delta = x_high - x_low\n        # delta must not be zero, though problem statement guarantees this.\n        if np.isclose(delta, 0):\n            # This case will not occur with the given test suite\n            results.extend([0.0, 0.0])\n            continue\n\n        # Step 2: Compute the DFS coefficients X[k] via FFT\n        X = np.fft.fft(x)\n\n        # Step 3: Form the partial sum spectrum X_M[k]\n        # Create a mask to retain the 2M+1 centered harmonics\n        mask = np.zeros(N, dtype=float)\n        # Harmonics from k=0 to k=M\n        mask[0:M + 1] = 1\n        # Corresponding negative harmonics k=-1 to -M, which map to N-1 to N-M\n        if M > 0:\n            mask[N - M:N] = 1\n        \n        X_M = X * mask\n\n        # Step 4: Synthesize the partial sum sequence x_M[n] via IFFT\n        x_M = np.fft.ifft(X_M)\n        \n        # The result should be real; take the real part to discard numerical noise\n        x_M_real = x_M.real\n\n        # Step 5: Quantify the Gibbs phenomenon\n        # Define the analysis window around the discontinuity at n0\n        w = max(1, int(0.1 * N))\n        window_indices = (n0 + np.arange(-w, w + 1)) % N\n        \n        # Get the partial sum values within the window\n        x_M_window = x_M_real[window_indices]\n\n        # Find max and min values in the window\n        max_val_in_window = np.max(x_M_window)\n        min_val_in_window = np.min(x_M_window)\n\n        # Calculate overshoot and undershoot ratios\n        rho_over = max(0.0, (max_val_in_window - x_high) / delta)\n        rho_under = max(0.0, (x_low - min_val_in_window) / delta)\n\n        # Append rounded results to the list\n        results.append(rho_over)\n        results.append(rho_under)\n\n    # Final print statement in the exact required format.\n    # Round to 6 decimal places and format as a string.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2896135"}]}