{"hands_on_practices": [{"introduction": "The remarkable efficiency of the Decimation-In-Time (DIT) Fast Fourier Transform stems from its clever divide-and-conquer approach. A crucial prerequisite for this algorithm is the reordering of the input data via a bit-reversal permutation. This exercise [@problem_id:2863858] challenges you to move beyond the definition and design an efficient, in-place algorithm for this permutation, gaining a deep, practical understanding of the computational mechanics that underpin the FFT's speed.", "id": "2863858", "problem": "You are given the context of the Decimation-In-Time Fast Fourier Transform (DIT FFT). The DIT FFT reorders input data by a bit-reversal permutation before butterfly computations. Let $N$ be a power of two, $N=2^{b}$ for some integer $b \\ge 0$. Define the bit-reversal permutation $\\pi$ on the index set $\\{0,1,\\dots,N-1\\}$ as follows: write an index $i$ in binary with exactly $b$ bits, reverse its bit string to obtain another $b$-bit integer, and denote that integer by $\\pi(i)$. Your task is to design and analyze an in-place algorithm for applying this permutation to an array.\n\nStarting from the definitions of a permutation, binary representation, and cycle decomposition, carry out the following:\n\n- Design an in-place algorithm to apply $\\pi$ to an array of length $N$ using minimal temporary storage. Your algorithm must be based only on the fundamental definitions above and must not rely on precomputed tables or auxiliary arrays of length proportional to $N$. State clearly the asymptotic time complexity in terms of $N$ and $b$, and the extra space complexity in terms of $N$ and $b$.\n\n- Analyze the cycle structure of $\\pi$ purely from first principles. Determine what cycle lengths can occur, characterize the fixed points, and derive closed-form expressions for the number of fixed points and the number of nontrivial cycles as functions of $N$ and $b$.\n\n- Implement the algorithm and the analysis in a program. For each test case, construct an array $a$ of length $N$ with entries $a[i]=i$ for $i \\in \\{0,1,\\dots,N-1\\}$, apply your in-place permutation algorithm to $a$, and compute:\n  1. The number of swaps your in-place algorithm performed, as an integer.\n  2. The total number of cycles in the cycle decomposition of $\\pi$, as an integer.\n  3. The number of fixed points of $\\pi$, as an integer.\n  4. The maximum cycle length among all cycles of $\\pi$, as an integer.\n  5. A boolean indicating whether the final permuted array satisfies $a[j]=\\pi(j)$ for all $j \\in \\{0,1,\\dots,N-1\\}$.\n\nTest suite and coverage:\n\n- Use the test suite $N \\in \\{1,2,8,16\\}$, which covers the boundary case $N=1$, the smallest nontrivial case $N=2$, and two typical powers of two $N=8$ and $N=16$.\n\nOutput specification:\n\n- Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets. For each $N$ in the order $N=1$, $N=2$, $N=8$, $N=16$, include a list of the five values described above. For example, the output must have the form\n  \"[[value\\_1\\_1,value\\_1\\_2,value\\_1\\_3,value\\_1\\_4,value\\_1\\_5],[value\\_2\\_1,value\\_2\\_2,value\\_2\\_3,value\\_2\\_4,value\\_2\\_5],...]\" where each value is an integer or a boolean as specified.", "solution": "The provided problem is well-defined, scientifically sound, and internally consistent. It poses a standard, albeit non-trivial, algorithmic challenge rooted in the theory of Fast Fourier Transforms. We shall proceed with a full solution, beginning with a structural analysis of the permutation, followed by the design and complexity analysis of an in-place algorithm, and finally culminating in an implementation that computes the required metrics.\n\nLet $N$ be a power of two, $N=2^b$ for an integer $b \\ge 0$. The set of indices is $S = \\{0, 1, \\dots, N-1\\}$. For any index $i \\in S$, its unique $b$-bit binary representation is $(b_{b-1}b_{b-2}\\dots b_1b_0)_2$, where $i = \\sum_{k=0}^{b-1} b_k 2^k$. The bit-reversal permutation $\\pi: S \\to S$ is defined such that $\\pi(i)$ is the integer whose $b$-bit binary representation is the reverse of that of $i$. That is, if $i \\leftrightarrow (b_{b-1}\\dots b_0)_2$, then $\\pi(i) \\leftrightarrow (b_0\\dots b_{b-1})_2$.\n\nA critical property of $\\pi$ is that it is an involution, meaning it is its own inverse. Applying the permutation twice returns the original index: $\\pi(\\pi(i)) = i$ for all $i \\in S$. To see this, reversing the bit string of $\\pi(i)$ simply yields the original bit string of $i$. From a group-theoretic perspective, any permutation that is an involution can be decomposed into disjoint cycles of length $1$ (fixed points) or $2$ (transpositions). There are no cycles of length greater than $2$. This observation is fundamental to both the analysis and the algorithm design.\n\nLet us first analyze the cycle structure of $\\pi$.\n\nA fixed point of $\\pi$ is an index $i$ such that $\\pi(i)=i$. This equality holds if and only if the $b$-bit binary representation of $i$ is a palindrome, i.e., $(b_{b-1}b_{b-2}\\dots b_0)_2 = (b_0b_1\\dots b_{b-1})_2$. This requires that $b_k = b_{b-1-k}$ for all $k \\in \\{0, 1, \\dots, b-1\\}$. To count the number of such palindromic strings of length $b$, we only need to specify the first $\\lceil b/2 \\rceil$ bits, as they determine the remaining bits. Since each of these $\\lceil b/2 \\rceil$ bits can be chosen independently as $0$ or $1$, the number of fixed points, denoted $N_{fp}$, is $2^{\\lceil b/2 \\rceil}$.\n\nThe total number of elements being permuted is $N$. The elements that are not fixed points must belong to $2$-cycles. The number of such elements is $N - N_{fp}$. Since each $2$-cycle comprises two elements, the number of $2$-cycles (transpositions) is $(N - N_{fp})/2$.\n\nThe total number of cycles in the permutation is the sum of the number of $1$-cycles and $2$-cycles:\n$$ C_{total} = N_{fp} + \\frac{N - N_{fp}}{2} = \\frac{2N_{fp} + N - N_{fp}}{2} = \\frac{N + N_{fp}}{2} $$\nSubstituting the formula for $N_{fp}$, the total number of cycles is $\\frac{1}{2}(N + 2^{\\lceil b/2 \\rceil})$.\n\nThe possible cycle lengths are $1$ and $2$. The maximum cycle length is $2$ if there is at least one $2$-cycle, and $1$ otherwise. The number of $2$-cycles is positive if $N - N_{fp} > 0$, i.e., $2^b > 2^{\\lceil b/2 \\rceil}$. This inequality simplifies to $b > \\lceil b/2 \\rceil$.\n- If $b$ is even, $b=2k$, the inequality is $2k > k$, which is true for $k \\ge 1$ (i.e., $b \\ge 2$).\n- If $b$ is odd, $b=2k+1$, the inequality is $2k+1 > k+1$, which is $k>0$, true for $k \\ge 1$ (i.e., $b \\ge 3$).\nCombining these, $2$-cycles exist for all $b \\ge 2$. For $b=0$ ($N=1$) and $b=1$ ($N=2$), we have $0 \\ngtr \\lceil 0/2 \\rceil=0$ and $1 \\ngtr \\lceil 1/2 \\rceil=1$. Thus, for $N=1$ and $N=2$, all elements are fixed points. The maximum cycle length is $1$ for $N \\in \\{1, 2\\}$ and $2$ for $N \\ge 4$.\n\nNext, we design an in-place algorithm to apply this permutation. Let $a$ be an array of length $N$. Applying the permutation means transforming the array such that the element originally at position $k$ moves to position $\\pi(k)$. That is, the new array $a_{new}$ satisfies $a_{new}[\\pi(k)] = a_{old}[k]$ for all $k \\in \\{0, \\dots, N-1\\}$. As $\\pi$ is an involution, we can write $k=\\pi(\\pi(k))$ and substitute to get $a_{new}[\\pi(k)] = a_{old}[\\pi(\\pi(k))]$. Let $j=\\pi(k)$, then this is $a_{new}[j] = a_{old}[\\pi(j)]$. So, the task is to perform an in-place transformation $a[j] \\leftarrow a[\\pi(j)]$ for all $j$.\n\nSince the permutation consists only of fixed points and transpositions, this transformation can be achieved by simply swapping the elements for each transposition. We can iterate through the indices $i$ from $0$ to $N-1$. For each $i$, we compute its permuted index $j=\\pi(i)$.\n- If $i=j$, the element $a[i]$ is a fixed point of the permutation. It should not be moved.\n- If $i \\neq j$, then $(i, j)$ forms a $2$-cycle, since $\\pi(j) = \\pi(\\pi(i)) = i$. To perform the swap for this pair exactly once, we can enforce an ordering. By iterating through $i$ and only swapping when $i < j$, we ensure that for each pair $(i,j)$ with $i<j$, the swap of $a[i]$ and $a[j]$ is performed when the loop is at index $i$, and skipped when the loop reaches index $j$ (since then $j > \\pi(j)=i$).\n\nThe algorithm is as follows:\n$1.$ For $i$ from $0$ to $N-1$:\n$2.$   Compute $j = \\pi(i)$.\n$3.$   If $i < j$, then swap $a[i]$ and $a[j]$.\n\nThis algorithm correctly permutes the array in-place. It uses a single temporary variable for the swap, so its extra space complexity is $O(1)$.\nThe time complexity is determined by the loop, which runs $N$ times, and the computation of $\\pi(i)$ inside the loop. A straightforward method to compute $\\pi(i)$ is to iterate through the $b$ bits of $i$, which takes $O(b)$ time. Therefore, the total time complexity is $O(N \\cdot b) = O(N \\log_2 N)$.\n\nThe outputs required by the problem can be computed as follows:\n$1.$ The number of swaps is the number of $2$-cycles, which is $(N - N_{fp})/2$. This value will also be counted directly by the permutation algorithm.\n$2.$ The total number of cycles is $(N + N_{fp})/2$.\n$3.$ The number of fixed points is $N_{fp} = 2^{\\lceil b/2 \\rceil}$.\n$4.$ The maximum cycle length is $1$ if $b \\in \\{0, 1\\}$ (i.e. $N \\le 2$), and $2$ if $b \\ge 2$ (i.e. $N \\ge 4$).\n$5.$ The correctness is verified by checking if the final array $a$ satisfies $a[k] = \\pi_{true}(k)$ for all $k \\in \\{0, \\dots, N-1\\}$, assuming the initial array was $a[k]=k$. The permutation algorithm implements transformation $a[k] \\leftarrow a[\\pi(k)]$. So with initial state $a[k]=k$, the final state should be $a[k] = \\pi(k)$, which is what we need to verify.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bit-reversal permutation problem for the given test suite.\n    \"\"\"\n\n    test_cases = [1, 2, 8, 16]\n\n    final_results = []\n\n    for N in test_cases:\n        # Determine b such that N = 2^b\n        b = N.bit_length() - 1 if N > 0 else 0\n\n        # --- Part 1: In-place permutation algorithm and swap count ---\n\n        def bit_reverse(i, num_bits):\n            \"\"\"Computes the bit-reversal of an integer i for a given bit width.\"\"\"\n            rev_i = 0\n            for k in range(num_bits):\n                if (i >> k) & 1:\n                    rev_i |= 1 << (num_bits - 1 - k)\n            return rev_i\n\n        # Initial array a[i] = i\n        a = list(range(N))\n        \n        num_swaps = 0\n        # Apply the in-place permutation algorithm\n        for i in range(N):\n            j = bit_reverse(i, b)\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n                num_swaps += 1\n\n        # --- Part 3, Output 5: Correctness verification ---\n        \n        is_correct = True\n        for i in range(N):\n            if a[i] != bit_reverse(i, b):\n                is_correct = False\n                break\n        \n        # --- Part 2 & 3: Analytical results ---\n\n        # Number of fixed points (1-cycles)\n        # N_fp = 2^ceil(b/2)\n        num_fixed_points = 2**((b + 1) // 2)\n\n        # Number of 2-cycles\n        num_2_cycles = (N - num_fixed_points) // 2\n        \n        # Total number of cycles = 1-cycles + 2-cycles\n        total_cycles = num_fixed_points + num_2_cycles\n\n        # Maximum cycle length\n        max_cycle_len = 2 if b >= 2 else 1\n\n        # The number of swaps performed must equal the number of 2-cycles.\n        # This serves as an internal consistency check.\n        assert num_swaps == num_2_cycles\n\n        case_results = [\n            num_swaps,\n            total_cycles,\n            num_fixed_points,\n            max_cycle_len,\n            is_correct\n        ]\n        final_results.append(case_results)\n\n    # Format the final output string to not contain spaces inside the lists.\n    # The default str(list) adds spaces, e.g., '[1, 2, 3]'.\n    # The required format has no spaces, e.g., '[1,2,3]'.\n    output_str = str(final_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"}, {"introduction": "While the FFT is a powerful tool for spectral analysis, its application to real-world, finite-length signals introduces important artifacts. This practice [@problem_id:1717762] explores the phenomenon of spectral leakage, which occurs when a signal's frequency does not align perfectly with the FFT's discrete frequency bins. By quantifying the ratio of energy in adjacent bins, you will develop a concrete intuition for interpreting the spectrograms of signals whose observation window is not an integer multiple of their period.", "id": "1717762", "problem": "An engineer is analyzing a vibration signal from a large industrial motor. For this analysis, the signal is modeled as a pure sinusoid, $x(t) = \\cos(2\\pi f_c t)$, where the effects of amplitude and phase are ignored as they do not influence the final required ratio. The signal is sampled by an Analog-to-Digital Converter (ADC) at a sampling rate of $f_s = 8000 \\text{ Hz}$. A total of $N = 1024$ samples are collected and then processed using a Fast Fourier Transform (FFT) algorithm, which computes the Discrete Fourier Transform (DFT).\n\nThe true rotational frequency of the motor results in a vibration signal with a frequency of $f_c = 150.0 \\text{ Hz}$. Due to the finite sampling duration, this frequency does not coincide exactly with any of the frequency bins of the 1024-point FFT. As a result, the signal's energy appears spread across multiple frequency bins, a phenomenon known as spectral leakage.\n\nLet $X[k]$ be the complex-valued coefficient of the $k$-th frequency bin of the FFT, where $k$ is an integer from $0$ to $N-1$. Calculate the ratio of the magnitude of the FFT coefficient in the adjacent bin above the true frequency to the magnitude of the FFT coefficient in the adjacent bin below the true frequency. Specifically, determine the value of the ratio $|X[k_{above}]| / |X[k_{below}]|$ where $k_{below}$ and $k_{above}$ are the integer bin indices immediately below and above the true signal frequency $f_c$, respectively.\n\nExpress your answer as a single real number rounded to three significant figures.\n\n", "solution": "We sample the continuous-time sinusoid $x(t)=\\cos(2\\pi f_{c}t)$ to obtain the discrete-time sequence $x[n]=\\cos\\!\\left(2\\pi \\frac{f_{c}}{f_{s}}n\\right)$ for $n=0,\\ldots,N-1$. The $N$-point DFT is defined by\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\!\\left(-j\\frac{2\\pi kn}{N}\\right).\n$$\nUsing $x[n]=\\frac{1}{2}\\left(\\exp\\!\\left(j2\\pi \\frac{f_{c}}{f_{s}}n\\right)+\\exp\\!\\left(-j2\\pi \\frac{f_{c}}{f_{s}}n\\right)\\right)$ and linearity,\n$$\nX[k]=\\frac{1}{2}X_{+}[k]+\\frac{1}{2}X_{-}[k],\n$$\nwhere\n$$\nX_{+}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(j2\\pi n\\left(\\frac{f_{c}}{f_{s}}-\\frac{k}{N}\\right)\\right),\\qquad\nX_{-}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(-j2\\pi n\\left(\\frac{f_{c}}{f_{s}}+\\frac{k}{N}\\right)\\right).\n$$\nEach is a finite geometric series. Let $\\Delta=\\frac{f_{c}}{f_{s}}-\\frac{k}{N}$. Then\n$$\nX_{+}[k]=\\exp\\!\\left(j\\pi (N-1)\\Delta\\right)\\frac{\\sin(\\pi N\\Delta)}{\\sin(\\pi \\Delta)},\n$$\nso\n$$\n|X_{+}[k]|=\\frac{|\\sin(\\pi N\\Delta)|}{|\\sin(\\pi \\Delta)|}.\n$$\nDefine the bin location of the tone as $r=\\frac{Nf_{c}}{f_{s}}$ and the fractional offset $\\alpha=r-\\lfloor r\\rfloor\\in(0,1)$. The adjacent bins around $f_{c}$ are $k_{below}=\\lfloor r\\rfloor$ and $k_{above}=\\lfloor r\\rfloor+1$. Then\n$$\n\\Delta_{below}=\\frac{f_{c}}{f_{s}}-\\frac{k_{below}}{N}=\\frac{r}{N}-\\frac{\\lfloor r\\rfloor}{N}=\\frac{\\alpha}{N},\\qquad\n\\Delta_{above}=\\frac{f_{c}}{f_{s}}-\\frac{k_{above}}{N}=\\frac{\\alpha-1}{N}=-\\frac{1-\\alpha}{N}.\n$$\nThus, for the complex exponential component near $+f_{c}$,\n$$\n|X_{+}[k_{below}]|=\\frac{|\\sin(\\pi \\alpha)|}{|\\sin(\\pi \\alpha/N)|},\\qquad\n|X_{+}[k_{above}]|=\\frac{|\\sin(\\pi (1-\\alpha))|}{|\\sin(\\pi (1-\\alpha)/N)|}.\n$$\nUsing $|\\sin(\\pi \\alpha)|=|\\sin(\\pi (1-\\alpha))|$, the ratio governed by the main lobe is\n$$\nR\\equiv\\frac{|X[k_{above}]|}{|X[k_{below}]|}\\approx\\frac{|X_{+}[k_{above}]|}{|X_{+}[k_{below}]|}=\\frac{\\sin(\\pi \\alpha/N)}{\\sin(\\pi (1-\\alpha)/N)}.\n$$\nNow substitute the given parameters to find $\\alpha$. With $f_{s}=8000$, $N=1024$, and $f_{c}=150$,\n$$\nr=\\frac{Nf_{c}}{f_{s}}=\\frac{1024\\cdot 150}{8000}=19.2,\\qquad \\alpha=0.2.\n$$\nHence\n$$\nR=\\frac{\\sin\\!\\left(\\pi\\cdot \\frac{0.2}{1024}\\right)}{\\sin\\!\\left(\\pi\\cdot \\frac{0.8}{1024}\\right)}.\n$$\nBecause the arguments are small, using $\\sin(x)\\approx x$ gives\n$$\nR\\approx\\frac{\\pi\\cdot 0.2/1024}{\\pi\\cdot 0.8/1024}=\\frac{0.2}{0.8}=\\frac{1}{4}=0.25.\n$$\nRounded to three significant figures, the ratio is $0.250$.", "answer": "$$\\boxed{0.250}$$"}, {"introduction": "Perhaps the most transformative application of the FFT is its ability to vastly accelerate the computation of linear convolution, a cornerstone of digital filtering. The algorithm, however, naturally computes *circular* convolution, creating a potential pitfall known as time-domain aliasing. This hands-on problem [@problem_id:2870696] guides you through a concrete example to distinguish these two types of convolution and master the zero-padding technique required to correctly implement linear convolution using the FFT.", "id": "2870696", "problem": "Consider two finite-length discrete-time sequences $x[n]$ and $h[n]$ defined by $x[n] = 0$ for all $n \\notin \\{0,1,2,3,4\\}$ and $h[n] = 0$ for all $n \\notin \\{0,1,2\\}$, with explicit nonzero samples\n- $x[0] = 1$, $x[1] = -1$, $x[2] = 2$, $x[3] = 0$, $x[4] = 1$,\n- $h[0] = 2$, $h[1] = 0$, $h[2] = 3$.\n\nStart from the fundamental definitions of linear convolution and $N$-point circular convolution in the discrete-time domain, and the Discrete Fourier Transform (DFT) definition together with the circular convolution property of the DFT. Do not invoke any unproven shortcut formulas.\n\nUsing only those bases, complete the following:\n\n- Compute the linear convolution $y_{\\text{lin}}[k] = \\sum_{m=-\\infty}^{\\infty} x[m]\\,h[k-m]$ for all integer $k$ where it is nonzero.\n- Compute the $N$-point circular convolution $y_{\\text{circ},N}[k] = \\sum_{m=0}^{N-1} x[(m)]_{N}\\,h[(k-m)]_{N}$ for $k \\in \\{0,1,\\dots,N-1\\}$ with $N=6$, where $[\\cdot]_{N}$ denotes modulo-$N$ indexing and $x[(n)]_{N}$ and $h[(n)]_{N}$ are taken to be the length-$N$ periodic extensions of $x[n]$ and $h[n]$ after zero-padding them to length $N$.\n- Using the Discrete Fourier Transform (DFT) and its circular convolution property, explain why $y_{\\text{circ},6}[k]$ differs from $y_{\\text{lin}}[k]$ and interpret the discrepancy as time-domain aliasing due to periodic extension induced by the DFT when the transform length is insufficient.\n- Determine the smallest power-of-two transform length $N$ such that, if both $x[n]$ and $h[n]$ are zero-padded to length $N$ and convolved via an $N$-point circular convolution (as would be implemented by a Fast Fourier Transform (FFT) based method), the result equals the linear convolution for all indices without aliasing.\n\nProvide, as your final reported answer, only this smallest power-of-two $N$ as a single integer. No rounding is needed. No units are required.", "solution": "The problem is first validated to be self-contained, scientifically grounded, and well-posed. All necessary data and definitions are provided, the context is standard digital signal processing theory, and the tasks are unambiguous. The problem is valid. We proceed with the solution.\n\nThe problem requires starting from fundamental definitions. We begin by stating these.\nThe two sequences are $x[n]$ and $h[n]$. The sequence $x[n]$ is non-zero only for $n \\in \\{0, 1, 2, 3, 4\\}$, with length $L_x = 5$. The sequence $h[n]$ is non-zero only for $n \\in \\{0, 1, 2\\}$, with length $L_h = 3$. The explicit values are:\n$x[n] = \\{1, -1, 2, 0, 1\\}$ for $n \\in \\{0, 1, 2, 3, 4\\}$.\n$h[n] = \\{2, 0, 3\\}$ for $n \\in \\{0, 1, 2\\}$.\n\nThe linear convolution of two discrete-time sequences $x[n]$ and $h[n]$ is defined as:\n$$ y_{\\text{lin}}[k] = (x * h)[k] = \\sum_{m=-\\infty}^{\\infty} x[m] h[k-m] $$\nThe length of the resulting sequence $y_{\\text{lin}}[k]$ is $L_y = L_x + L_h - 1$.\n\nThe $N$-point circular convolution of two length-$N$ sequences $x_N[n]$ and $h_N[n]$ is defined as:\n$$ y_{\\text{circ},N}[k] = \\sum_{m=0}^{N-1} x_N[m] h_N[(k-m) \\pmod N] $$\nfor $k \\in \\{0, 1, \\dots, N-1\\}$. The sequences $x_N[n]$ and $h_N[n]$ are typically formed by zero-padding the original sequences $x[n]$ and $h[n]$ to length $N$.\n\nThe circular convolution property of the $N$-point Discrete Fourier Transform (DFT) states that the DFT of the circular convolution of two sequences is the product of their individual DFTs:\n$$ \\text{DFT}\\{y_{\\text{circ},N}[n]\\} = \\text{DFT}\\{x_N[n]\\} \\cdot \\text{DFT}\\{h_N[n]\\} $$\nA crucial consequence of this property, which connects circular and linear convolution, is the time-domain aliasing formula. If $y_{\\text{lin}}[n]$ is the linear convolution of $x[n]$ and $h[n]$, and $y_{\\text{circ},N}[n]$ is the $N$-point circular convolution of their zero-padded versions, then:\n$$ y_{\\text{circ},N}[k] = \\sum_{r=-\\infty}^{\\infty} y_{\\text{lin}}[k + rN] \\quad \\text{for } k \\in \\{0, 1, \\dots, N-1\\} $$\nThis relationship is the foundation for our analysis.\n\n**Part 1: Linear Convolution**\n\nThe lengths of the sequences are $L_x = 5$ and $L_h = 3$. The length of the linear convolution $y_{\\text{lin}}[k]$ is $L_y = L_x + L_h - 1 = 5 + 3 - 1 = 7$. The convolution is non-zero for $k \\in \\{0, 1, 2, 3, 4, 5, 6\\}$. We compute the values.\n$y_{\\text{lin}}[0] = x[0]h[0] = (1)(2) = 2$.\n$y_{\\text{lin}}[1] = x[0]h[1] + x[1]h[0] = (1)(0) + (-1)(2) = -2$.\n$y_{\\text{lin}}[2] = x[0]h[2] + x[1]h[1] + x[2]h[0] = (1)(3) + (-1)(0) + (2)(2) = 3 + 4 = 7$.\n$y_{\\text{lin}}[3] = x[1]h[2] + x[2]h[1] + x[3]h[0] = (-1)(3) + (2)(0) + (0)(2) = -3$.\n$y_{\\text{lin}}[4] = x[2]h[2] + x[3]h[1] + x[4]h[0] = (2)(3) + (0)(0) + (1)(2) = 6 + 2 = 8$.\n$y_{\\text{lin}}[5] = x[3]h[2] + x[4]h[1] = (0)(3) + (1)(0) = 0$.\n$y_{\\text{lin}}[6] = x[4]h[2] = (1)(3) = 3$.\nThus, the linear convolution result is the sequence:\n$y_{\\text{lin}}[k] = \\{2, -2, 7, -3, 8, 0, 3\\}$ for $k \\in \\{0, 1, \\dots, 6\\}$.\n\n**Part 2: $N=6$ Circular Convolution**\n\nFor $N=6$, we first zero-pad the sequences $x[n]$ and $h[n]$ to length $6$:\n$x_6[n] = \\{1, -1, 2, 0, 1, 0\\}$ for $n \\in \\{0, 1, \\dots, 5\\}$.\n$h_6[n] = \\{2, 0, 3, 0, 0, 0\\}$ for $n \\in \\{0, 1, \\dots, 5\\}$.\nWe compute $y_{\\text{circ},6}[k] = \\sum_{m=0}^{5} x_6[m] h_6[(k-m) \\pmod 6]$.\n$y_{\\text{circ},6}[0] = \\sum_{m=0}^{5} x_6[m] h_6[(-m) \\pmod 6] = x_6[0]h_6[0] + x_6[1]h_6[5] + x_6[2]h_6[4] + x_6[3]h_6[3] + x_6[4]h_6[2] + x_6[5]h_6[1] = (1)(2) + (-1)(0) + (2)(0) + (0)(0) + (1)(3) + (0)(0) = 2 + 3 = 5$.\n$y_{\\text{circ},6}[1] = \\sum_{m=0}^{5} x_6[m] h_6[(1-m) \\pmod 6] = x_6[0]h_6[1] + x_6[1]h_6[0] + \\dots = (1)(0) + (-1)(2) = -2$.\n$y_{\\text{circ},6}[2] = \\sum_{m=0}^{5} x_6[m] h_6[(2-m) \\pmod 6] = x_6[0]h_6[2] + x_6[1]h_6[1] + x_6[2]h_6[0] + \\dots = (1)(3) + (-1)(0) + (2)(2) = 3 + 4 = 7$.\n$y_{\\text{circ},6}[3] = x_6[1]h_6[2] + x_6[2]h_6[1] + x_6[3]h_6[0] + \\dots = (-1)(3) + (2)(0) + (0)(2) = -3$.\n$y_{\\text{circ},6}[4] = x_6[2]h_6[2] + x_6[3]h_6[1] + x_6[4]h_6[0] + \\dots = (2)(3) + (0)(0) + (1)(2) = 6 + 2 = 8$.\n$y_{\\text{circ},6}[5] = x_6[3]h_6[2] + x_6[4]h_6[1] + x_6[5]h_6[0] + \\dots = (0)(3) + (1)(0) + (0)(2) = 0$.\nThe $6$-point circular convolution result is the sequence:\n$y_{\\text{circ},6}[k] = \\{5, -2, 7, -3, 8, 0\\}$ for $k \\in \\{0, 1, \\dots, 5\\}$.\n\n**Part 3: Discrepancy Analysis**\n\nComparing the linear convolution $y_{\\text{lin}}[k] = \\{2, -2, 7, -3, 8, 0, 3\\}$ with the $6$-point circular convolution $y_{\\text{circ},6}[k] = \\{5, -2, 7, -3, 8, 0\\}$, we observe that the values for $k \\in \\{1, 2, 3, 4, 5\\}$ are identical. However, $y_{\\text{circ},6}[0] = 5$ while $y_{\\text{lin}}[0] = 2$.\nThe discrepancy is explained by time-domain aliasing, as described by the fundamental relation:\n$y_{\\text{circ},N}[k] = \\sum_{r=-\\infty}^{\\infty} y_{\\text{lin}}[k + rN]$.\nFor our case with $N=6$, this is $y_{\\text{circ},6}[k] = \\sum_{r=-\\infty}^{\\infty} y_{\\text{lin}}[k + 6r]$.\nSince the linear convolution $y_{\\text{lin}}[k]$ has a finite length of $L_y=7$, the sum has very few non-zero terms.\nFor $k=0$:\n$y_{\\text{circ},6}[0] = \\dots + y_{\\text{lin}}[-6] + y_{\\text{lin}}[0] + y_{\\text{lin}}[6] + y_{\\text{lin}}[12] + \\dots$.\nSince $y_{\\text{lin}}[k]$ is zero outside the range $k \\in \\{0, \\dots, 6\\}$, this simplifies to:\n$y_{\\text{circ},6}[0] = y_{\\text{lin}}[0] + y_{\\text{lin}}[6] = 2 + 3 = 5$.\nThis calculation perfectly matches the directly computed value of $y_{\\text{circ},6}[0]$. This phenomenon is called time-domain aliasing. The length of the linear convolution, $L_y=7$, is greater than the DFT length, $N=6$. Consequently, the sample at index $k=6$ in the linear convolution result ($y_{\\text{lin}}[6]=3$) \"wraps around\" and adds to the sample at index $k=6 \\pmod 6 = 0$.\nFor any other index $k \\in \\{1, \\dots, 5\\}$, the sum $\\sum_{r} y_{\\text{lin}}[k+6r]$ only has one non-zero term, $y_{\\text{lin}}[k]$ itself, as $k+6r$ would be outside the support $\\{0, \\dots, 6\\}$ for any non-zero integer $r$. For example, for $k=1$, $y_{\\text{circ},6}[1] = y_{\\text{lin}}[1] = -2$.\n\n**Part 4: Minimum Power-of-Two DFT Length**\n\nTo perform linear convolution using FFT-based methods (which compute circular convolution), we must choose a DFT length $N$ large enough to avoid time-domain aliasing. The circular convolution result $y_{\\text{circ},N}[k]$ will be identical to the linear convolution result $y_{\\text{lin}}[k]$ for $k \\in \\{0, \\dots, L_y-1\\}$ if and only if no wrap-around occurs.\nThis requires the transform length $N$ to be large enough to accommodate the full length of the linear convolution result, $L_y$. The condition is:\n$N \\ge L_y$.\nIn our problem, $L_x = 5$ and $L_h = 3$, so the length of the linear convolution is $L_y = L_x + L_h - 1 = 5 + 3 - 1 = 7$.\nTherefore, the minimum required DFT length is $N \\ge 7$.\n\nThe problem asks for the smallest *power-of-two* transform length $N$ that satisfies this condition. This is a common constraint for efficient implementation using the Fast Fourier Transform (FFT) algorithm. We must find the smallest integer $p$ such that $N = 2^p$ and $N \\ge 7$.\nWe check powers of $2$:\n$2^1 = 2 < 7$\n$2^2 = 4 < 7$\n$2^3 = 8 \\ge 7$\nThe smallest power of two that is greater than or equal to $7$ is $8$.\nTherefore, the required transform length is $N=8$. With this length, both sequences would be padded to length $8$, their $8$-point DFTs multiplied, and the inverse $8$-point DFT would yield the sequence $\\{2, -2, 7, -3, 8, 0, 3, 0\\}$, which correctly represents the linear convolution result padded with one zero.", "answer": "$$\n\\boxed{8}\n$$"}]}