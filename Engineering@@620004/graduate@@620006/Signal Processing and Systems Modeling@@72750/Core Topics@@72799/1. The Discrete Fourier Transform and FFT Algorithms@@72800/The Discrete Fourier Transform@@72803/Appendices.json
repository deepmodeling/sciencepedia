{"hands_on_practices": [{"introduction": "The journey into the practical application of the Discrete Fourier Transform begins with its most fundamental component: the $k=0$ frequency bin, also known as the DC component. This exercise demystifies this concept by connecting it directly to the time-domain signal's properties. By applying the DFT definition in this simplest case, you will see how $X[0]$ provides a measure of the signal's average value, a crucial piece of information in many analysis tasks [@problem_id:1759598].", "problem": "In a digital signal processing application, a sensor monitors a decaying physical process. The sensor captures a sequence of $N$ measurements, indexed from $n=0$ to $n=N-1$. This finite-length sequence, denoted by $x[n]$, is modeled by the equation:\n$$x[n] = A \\alpha^n$$\nwhere $A$ is the initial amplitude of the measurement, and $\\alpha$ is a real-valued constant representing the decay factor per sample, with $0 < \\alpha < 1$.\n\nIn the frequency domain analysis of this signal, the \"DC component\" provides a measure of its average value. This component is given by the $k=0$ term of the $N$-point Discrete Fourier Transform (DFT), which is denoted by $X[0]$.\n\nDetermine the DC component, $X[0]$, for the given sequence $x[n]$. Your final answer should be a closed-form symbolic expression in terms of $A$, $\\alpha$, and $N$.", "solution": "The problem asks for the DC component, $X[0]$, of the $N$-point Discrete Fourier Transform (DFT) of the sequence $x[n] = A \\alpha^n$.\n\nThe definition of the $N$-point DFT of a sequence $x[n]$ is given by:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi}{N} kn\\right)$$\nwhere $j$ is the imaginary unit.\n\nTo find the DC component, we need to evaluate this expression for the frequency index $k=0$. Substituting $k=0$ into the DFT formula gives:\n$$X[0] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi}{N} (0)n\\right)$$\nThe exponential term simplifies significantly:\n$$\\exp\\left(-j \\frac{2\\pi}{N} (0)n\\right) = \\exp(0) = 1$$\nThus, the expression for $X[0]$ becomes the sum of all the elements in the sequence $x[n]$:\n$$X[0] = \\sum_{n=0}^{N-1} x[n]$$\nNow, we substitute the given sequence $x[n] = A \\alpha^n$ into this summation:\n$$X[0] = \\sum_{n=0}^{N-1} A \\alpha^n$$\nSince $A$ is a constant, it can be factored out of the summation:\n$$X[0] = A \\sum_{n=0}^{N-1} \\alpha^n$$\nThe remaining sum is a finite geometric series. The formula for the sum of a finite geometric series is:\n$$\\sum_{i=0}^{M-1} r^i = \\frac{1 - r^M}{1 - r}$$\nThis formula is valid for any $r \\neq 1$. In our problem, the summation is from $n=0$ to $N-1$ and the ratio is $r = \\alpha$. The problem states that $0 < \\alpha < 1$, so the condition $\\alpha \\neq 1$ is satisfied.\n\nApplying the geometric series formula with $r = \\alpha$ and $M=N$:\n$$\\sum_{n=0}^{N-1} \\alpha^n = \\frac{1 - \\alpha^N}{1 - \\alpha}$$\nSubstituting this result back into our expression for $X[0]$ yields the final answer:\n$$X[0] = A \\left( \\frac{1 - \\alpha^N}{1 - \\alpha} \\right)$$\nThis is the closed-form symbolic expression for the DC component of the given sequence.", "answer": "$$\\boxed{A \\frac{1 - \\alpha^{N}}{1 - \\alpha}}$$", "id": "1759598"}, {"introduction": "In countless applications, the signals we analyze—from audio recordings to financial data—are real-valued. This reality imposes a beautiful and powerful structure on their frequency-domain representation, known as Hermitian or conjugate symmetry. This practice challenges you not just to use this property, but to derive it from first principles, thereby gaining a deeper insight into why the DFT of a real signal contains redundant information and how we can exploit this for efficient computation and storage [@problem_id:2911736].", "problem": "Consider an $N$-point Discrete Fourier Transform (DFT) computed via a Fast Fourier Transform (FFT) of a real-valued discrete-time sequence $x[n]$, where $N = 12$ and $0 \\leq n \\leq N-1$. You are given only the unique frequency bins that are typically reported for real-valued $x[n]$, namely $X[k]$ for $k \\in \\{0,1,2,3,4,5,6\\}$. These one-sided bins are:\n- $X[0] = 6$\n- $X[1] = 1 - 2j$\n- $X[2] = -\\frac{3}{2} + \\frac{1}{2}j$\n- $X[3] = \\frac{5}{3} - \\frac{4}{3}j$\n- $X[4] = -2 + j$\n- $X[5] = \\frac{7}{5} + \\frac{6}{5}j$\n- $X[6] = -4$\n\nHere $X[k]$ denotes the DFT of $x[n]$ indexed with $k \\in \\{0,1,\\dots,N-1\\}$. Starting only from the DFT definition\n$$\nX[k] \\triangleq \\sum_{n=0}^{N-1} x[n]\\,\\exp\\!\\left(-j\\,\\frac{2\\pi}{N}\\,k\\,n\\right),\n$$\nand the assumption that $x[n]$ is real-valued for all $n$, do the following:\n\n1. Derive the exact relationship that must hold between $X[k]$ and $X[\\ell]$ for appropriate indices $k$ and $\\ell$ that follows from the reality of $x[n]$. Your derivation should begin from the DFT definition above, without invoking any pre-memorized symmetry formulas.\n\n2. Use your derived relationship to reconstruct the full complex spectrum $X[k]$ for all $k \\in \\{0,1,\\dots,11\\}$ from the given one-sided bins.\n\n3. Define the scalar\n$$\nS \\triangleq \\sum_{k=0}^{11} \\left|\\,X[k] - \\overline{X[(-k)\\bmod 12]}\\,\\right|^{2}.\n$$\nCompute $S$ exactly and provide it as your final answer. No rounding is required.", "solution": "The problem as stated will first be validated for correctness.\n\n**Problem Validation**\n\nStep 1: Extract Givens.\n- The signal is a real-valued discrete-time sequence $x[n]$.\n- The number of points for the Discrete Fourier Transform (DFT) is $N = 12$.\n- The sequence index is $n \\in \\{0, 1, \\dots, N-1\\}$.\n- The frequency index is $k \\in \\{0, 1, \\dots, N-1\\}$.\n- The DFT is defined as $X[k] \\triangleq \\sum_{n=0}^{N-1} x[n]\\,\\exp(-j\\,\\frac{2\\pi}{N}\\,k\\,n)$.\n- The given DFT coefficients are:\n  - $X[0] = 6$\n  - $X[1] = 1 - 2j$\n  - $X[2] = -\\frac{3}{2} + \\frac{1}{2}j$\n  - $X[3] = \\frac{5}{3} - \\frac{4}{3}j$\n  - $X[4] = -2 + j$\n  - $X[5] = \\frac{7}{5} + \\frac{6}{5}j$\n  - $X[6] = -4$\n- The scalar to be computed is $S \\triangleq \\sum_{k=0}^{11} \\left|\\,X[k] - \\overline{X[(-k)\\bmod 12]}\\,\\right|^{2}$.\n\nStep 2: Validate Using Extracted Givens.\n- **Scientifically Grounded:** The problem is based on the fundamental definition and properties of the DFT in signal processing, a core topic in STEM. The concept of conjugate symmetry for real-valued signals is a standard and verifiable principle.\n- **Well-Posed:** The problem provides sufficient information to derive the required relationship, reconstruct the spectrum, and calculate the scalar $S$. The tasks are clearly defined and lead to a unique solution. We must verify consistency of the provided data with the premise that $x[n]$ is real. The symmetry property for a real signal implies $X[k] = \\overline{X[N-k]}$. For $k=0$, this gives $X[0]=\\overline{X[0]}$, so $X[0]$ must be real. The given $X[0]=6$ is real. For the Nyquist frequency $k=N/2=6$, this gives $X[6]=\\overline{X[6]}$, so $X[6]$ must also be real. The given $X[6]=-4$ is real. The given data are consistent with the premises.\n- **Objective:** The language is precise and mathematical. No subjective elements are present.\n\nStep 3: Verdict and Action.\nThe problem is valid. It is scientifically sound, self-contained, consistent, and well-posed. A solution will now be provided.\n\n**Solution**\n\nThe problem is solved in three parts as requested.\n\nPart 1: Derivation of the Conjugate Symmetry Property.\nWe start with the definition of the $N$-point DFT of a sequence $x[n]$:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\,\\exp\\left(-j\\,\\frac{2\\pi}{N}\\,kn\\right)\n$$\nWe take the complex conjugate of this expression:\n$$\n\\overline{X[k]} = \\overline{\\sum_{n=0}^{N-1} x[n]\\,\\exp\\left(-j\\,\\frac{2\\pi}{N}\\,kn\\right)}\n$$\nUsing the properties of complex conjugation ($\\overline{z_1+z_2} = \\overline{z_1}+\\overline{z_2}$ and $\\overline{z_1 z_2} = \\overline{z_1}\\overline{z_2}$):\n$$\n\\overline{X[k]} = \\sum_{n=0}^{N-1} \\overline{x[n]} \\cdot \\overline{\\exp\\left(-j\\,\\frac{2\\pi}{N}\\,kn\\right)}\n$$\nThe problem states that $x[n]$ is real-valued, so $\\overline{x[n]} = x[n]$. For the exponential term, we use $\\overline{\\exp(j\\theta)} = \\exp(-j\\theta)$:\n$$\n\\overline{\\exp\\left(-j\\,\\frac{2\\pi}{N}\\,kn\\right)} = \\exp\\left(j\\,\\frac{2\\pi}{N}\\,kn\\right)\n$$\nSubstituting these back, we obtain:\n$$\n\\overline{X[k]} = \\sum_{n=0}^{N-1} x[n]\\,\\exp\\left(j\\,\\frac{2\\pi}{N}\\,kn\\right)\n$$\nNow, let's examine the DFT definition for a frequency index $\\ell = -k$:\n$$\nX[-k] = \\sum_{n=0}^{N-1} x[n]\\,\\exp\\left(-j\\,\\frac{2\\pi}{N}\\,(-k)n\\right) = \\sum_{n=0}^{N-1} x[n]\\,\\exp\\left(j\\,\\frac{2\\pi}{N}\\,kn\\right)\n$$\nBy comparing the expressions for $\\overline{X[k]}$ and $X[-k]$, we see they are identical.\n$$\n\\overline{X[k]} = X[-k]\n$$\nThe DFT is periodic with period $N$, meaning $X[m] = X[m \\pmod N]$. Therefore, $X[-k] = X[(-k) \\pmod N] = X[N-k]$ for $k=1, \\dots, N-1$. For $k=0$, $X[0]=X[0]$. Thus, the desired relationship between $X[k]$ and $X[\\ell]$ is:\n$$\nX[N-k] = \\overline{X[k]} \\quad \\text{for } k=0, 1, \\dots, N-1.\n$$\nThis is the conjugate symmetry property for the DFT of a real-valued sequence. The required indices are $\\ell = N-k$.\n\nPart 2: Reconstruction of the Full Spectrum.\nWe are given $N=12$ and the values of $X[k]$ for $k \\in \\{0, 1, 2, 3, 4, 5, 6\\}$. We use the derived property $X[12-k] = \\overline{X[k]}$ to find the remaining coefficients.\n- For $k=1$: $X[11] = X[12-1] = \\overline{X[1]} = \\overline{1 - 2j} = 1 + 2j$.\n- For $k=2$: $X[10] = X[12-2] = \\overline{X[2]} = \\overline{-\\frac{3}{2} + \\frac{1}{2}j} = -\\frac{3}{2} - \\frac{1}{2}j$.\n- For $k=3$: $X[9] = X[12-3] = \\overline{X[3]} = \\overline{\\frac{5}{3} - \\frac{4}{3}j} = \\frac{5}{3} + \\frac{4}{3}j$.\n- For $k=4$: $X[8] = X[12-4] = \\overline{X[4]} = \\overline{-2 + j} = -2 - j$.\n- For $k=5$: $X[7] = X[12-5] = \\overline{X[5]} = \\overline{\\frac{7}{5} + \\frac{6}{5}j} = \\frac{7}{5} - \\frac{6}{5}j$.\nThe full spectrum for $k \\in \\{0, 1, \\dots, 11\\}$ is:\n- $X[0] = 6$\n- $X[1] = 1 - 2j$\n- $X[2] = -\\frac{3}{2} + \\frac{1}{2}j$\n- $X[3] = \\frac{5}{3} - \\frac{4}{3}j$\n- $X[4] = -2 + j$\n- $X[5] = \\frac{7}{5} + \\frac{6}{5}j$\n- $X[6] = -4$\n- $X[7] = \\frac{7}{5} - \\frac{6}{5}j$\n- $X[8] = -2 - j$\n- $X[9] = \\frac{5}{3} + \\frac{4}{3}j$\n- $X[10] = -\\frac{3}{2} - \\frac{1}{2}j$\n- $X[11] = 1 + 2j$\n\nPart 3: Computation of the scalar $S$.\nThe scalar $S$ is defined as:\n$$\nS \\triangleq \\sum_{k=0}^{11} \\left|\\,X[k] - \\overline{X[(-k)\\bmod 12]}\\,\\right|^{2}\n$$\nLet us analyze the term inside the summation, $X[k] - \\overline{X[(-k)\\bmod 12]}$.\nThe modulo operation $(-k)\\bmod 12$ results in:\n- For $k=0$: $(-0)\\bmod 12 = 0$.\n- For $k \\in \\{1, 2, \\dots, 11\\}$: $(-k)\\bmod 12 = 12-k$.\n\nWe examine the term for these two cases.\nCase 1: $k=0$.\nThe term is $X[0] - \\overline{X[0]}$. Since $x[n]$ is real, its sum $\\sum x[n]$ is real. From the DFT definition, $X[0] = \\sum_{n=0}^{N-1} x[n]$, which must be a real number. Therefore, $X[0]=\\overline{X[0]}$, and the term is $X[0] - X[0] = 0$.\n\nCase 2: $k \\in \\{1, 2, \\dots, 11\\}$.\nThe term is $X[k] - \\overline{X[12-k]}$.\nFrom the conjugate symmetry property derived in Part 1, we know that $X[12-k] = \\overline{X[k]}$.\nSubstituting this into the expression, we get:\n$$\nX[k] - \\overline{(\\overline{X[k]})}\n$$\nFor any complex number $z$, $\\overline{\\overline{z}} = z$. Applying this, we have $\\overline{\\overline{X[k]}} = X[k]$. The expression becomes:\n$$\nX[k] - X[k] = 0\n$$\nThus, for every value of $k$ from $0$ to $11$, the term inside the absolute value is exactly $0$. It is not necessary to use the specific numerical values of $X[k]$, as the result follows directly from the fact that $x[n]$ is real.\nThe sum $S$ is therefore:\n$$\nS = \\sum_{k=0}^{11} |0|^2 = \\sum_{k=0}^{11} 0 = 0\n$$", "answer": "$$\n\\boxed{0}\n$$", "id": "2911736"}, {"introduction": "While the DFT definition is mathematically elegant, its $\\mathcal{O}(N^2)$ complexity was a major barrier for large-scale applications until the development of the Fast Fourier Transform (FFT) algorithm. This advanced exercise takes you to the heart of computational signal processing by having you implement the seminal Cooley-Tukey FFT algorithm from scratch. By building the algorithm and using it to verify foundational results like the Circular Convolution Theorem and Parseval's Identity, you will bridge the gap between abstract theory and powerful, practical computation [@problem_id:2387187].", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $\\mathcal{O}(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4j]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the area of signal processing. It requires the implementation and verification of the Discrete Fourier Transform (DFT), its inverse (IDFT), and fundamental associated theorems. The problem is complete, objective, and its resolution is verifiable. We will proceed with the solution.\n\nThe core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $\\mathcal{O}(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $\\mathcal{O}(N^2)$ to $\\mathcal{O}(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi j k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi j k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi j k m / (N/2)} + e^{-2\\pi j k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi j k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi j k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k < N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k < N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi j k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi j k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $\\mathcal{O}(N^2)$ DFT, a recursive $\\mathcal{O}(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N <= 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 <= epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 <= epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 <= epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}