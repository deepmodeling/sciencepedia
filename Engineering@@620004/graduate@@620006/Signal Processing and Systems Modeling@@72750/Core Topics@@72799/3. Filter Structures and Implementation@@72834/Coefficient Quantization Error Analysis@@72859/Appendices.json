{"hands_on_practices": [{"introduction": "We begin our practical exploration with the most direct consequence of coefficient quantization. This exercise examines an FIR filter where a single coefficient cannot be perfectly represented in a fixed-point format. By analyzing the system's response to a simple unit-step input, you will derive the resulting steady-state error, or DC bias, directly from first principles. This practice [@problem_id:2858816] is designed to build a concrete intuition for how a small, localized quantization error propagates through the linear system to affect the final output.", "problem": "Consider a length-$5$ Finite Impulse Response (FIR) filter with impulse response coefficients $h[0]=\\frac{1}{4}$, $h[1]=-\\frac{3}{8}$, $h[2]=\\frac{13}{64}$, $h[3]=\\frac{1}{16}$, and $h[4]=-\\frac{1}{32}$. All coefficients are to be stored in fixed-point $Qm.n$ format, where $Qm.n$ denotes a two's-complement fixed-point representation with $m$ integer bits (excluding the sign bit) and $n$ fractional bits. Assume $n=5$ and that saturation does not occur. All coefficients are exactly representable in $Qm.n$ except $h[2]$, which is quantized by deterministic truncation toward zero. Define the truncation operator by\n$$\n\\mathcal{T}_{n}(x) \\triangleq \\mathrm{sgn}(x)\\,\\frac{\\left\\lfloor 2^{n}\\,|x|\\right\\rfloor}{2^{n}}.\n$$\nLet $\\tilde{h}[k]$ denote the stored (quantized) coefficient sequence with $\\tilde{h}[k]=h[k]$ for all $k\\neq 2$ and $\\tilde{h}[2]=\\mathcal{T}_{5}\\!\\big(h[2]\\big)$. The filter is driven by a unit-step input $x[n]=u[n]$. Define the induced direct current (DC) bias as the steady-state difference between the output of the quantized filter and the output of the exact-coefficient filter in response to the same input:\n$$\nb \\triangleq \\lim_{n\\to\\infty}\\big(\\tilde{y}[n]-y[n]\\big),\n$$\nwhere $y[n]$ and $\\tilde{y}[n]$ are the outputs corresponding to $h[k]$ and $\\tilde{h}[k]$, respectively.\n\nStarting only from the definitions of linear time-invariant convolution, fixed-point truncation, and basic stability properties of FIR systems, derive an expression for $b$ and compute its exact value. Express your final answer as a single exact real number. No rounding is required.", "solution": "The problem requires the computation of the steady-state output difference between a filter with exact coefficients and one with quantized coefficients, when both are driven by a unit-step input. This difference is defined as the direct current (DC) bias $b$.\n\nLet $h[k]$ be the impulse response of the exact Finite Impulse Response (FIR) filter and $\\tilde{h}[k]$ be the impulse response of the filter with quantized coefficients. The lengths of both impulse responses are $5$, so $k$ ranges from $0$ to $4$. The output of a linear time-invariant (LTI) system is given by the convolution of its impulse response with the input signal $x[n]$.\n\nThe output of the exact filter, $y[n]$, is given by:\n$$\ny[n] = (h * x)[n] = \\sum_{k=0}^{4} h[k] x[n-k]\n$$\nThe output of the quantized filter, $\\tilde{y}[n]$, is given by:\n$$\n\\tilde{y}[n] = (\\tilde{h} * x)[n] = \\sum_{k=0}^{4} \\tilde{h}[k] x[n-k]\n$$\nThe DC bias $b$ is defined as the steady-state difference between these two outputs:\n$$\nb \\triangleq \\lim_{n\\to\\infty}\\big(\\tilde{y}[n]-y[n]\\big)\n$$\nBy linearity of the summation operator, the difference $\\tilde{y}[n]-y[n]$ can be expressed as:\n$$\n\\tilde{y}[n] - y[n] = \\sum_{k=0}^{4} \\tilde{h}[k] x[n-k] - \\sum_{k=0}^{4} h[k] x[n-k] = \\sum_{k=0}^{4} (\\tilde{h}[k]-h[k]) x[n-k]\n$$\nLet us define the coefficient error sequence $\\Delta h[k] \\triangleq \\tilde{h}[k]-h[k]$. The output difference is then the response of an \"error filter\" with impulse response $\\Delta h[k]$ to the input $x[n]$:\n$$\n\\tilde{y}[n] - y[n] = (\\Delta h * x)[n] = \\sum_{k=0}^{4} \\Delta h[k] x[n-k]\n$$\nThe input signal is the unit-step function, $x[n]=u[n]$, defined as $u[n]=1$ for $n \\ge 0$ and $u[n]=0$ for $n < 0$. We must evaluate the limit as $n \\to \\infty$. For an FIR filter of length $5$, the convolution sum involves terms $x[n-k]$ for $k \\in \\{0, 1, 2, 3, 4\\}$. As $n$ becomes large, specifically for any $n \\ge 4$, the argument $n-k$ will be non-negative for all $k$ in the sum. That is, $n-4 \\ge 0$, $n-3 \\ge 0$, and so on.\nFor $n \\ge 4$, we have $u[n-k] = 1$ for all $k \\in \\{0, 1, 2, 3, 4\\}$.\nTherefore, for $n \\ge 4$, the output difference becomes constant:\n$$\n\\tilde{y}[n] - y[n] = \\sum_{k=0}^{4} \\Delta h[k] \\cdot 1 = \\sum_{k=0}^{4} \\Delta h[k]\n$$\nSince this expression is constant for all $n \\ge 4$, the limit as $n \\to \\infty$ is this constant value. Thus, the DC bias $b$ is the sum of the coefficient errors:\n$$\nb = \\lim_{n\\to\\infty} \\sum_{k=0}^{4} \\Delta h[k] u[n-k] = \\sum_{k=0}^{4} \\Delta h[k]\n$$\nThis result is a direct consequence of the stability of FIR filters and the nature of the step response, which reaches a steady-state value equal to the filter's DC gain (the sum of its impulse response coefficients).\n\nThe problem states that only the coefficient $h[2]$ is quantized, while the others remain exact. This implies:\n$\\Delta h[k] = \\tilde{h}[k] - h[k] = 0$ for $k \\in \\{0, 1, 3, 4\\}$.\nThe only non-zero error coefficient is $\\Delta h[2] = \\tilde{h}[2] - h[2]$.\nTherefore, the DC bias simplifies to:\n$$\nb = \\Delta h[2]\n$$\nWe must now compute $\\Delta h[2]$. The coefficient $h[2]=\\frac{13}{64}$ is quantized using truncation toward zero with $n=5$ fractional bits. The truncation operator $\\mathcal{T}_{n}(x)$ is given by:\n$$\n\\mathcal{T}_{n}(x) \\triangleq \\mathrm{sgn}(x)\\,\\frac{\\left\\lfloor 2^{n}\\,|x|\\right\\rfloor}{2^{n}}\n$$\nFor $x = h[2] = \\frac{13}{64}$, which is a positive value, $\\mathrm{sgn}(x)=1$. With $n=5$, we have $2^n = 2^5 = 32$. The quantized coefficient $\\tilde{h}[2]$ is:\n$$\n\\tilde{h}[2] = \\mathcal{T}_{5}\\left(\\frac{13}{64}\\right) = \\frac{\\left\\lfloor 2^{5} \\cdot \\frac{13}{64}\\right\\rfloor}{2^{5}} = \\frac{\\left\\lfloor 32 \\cdot \\frac{13}{64}\\right\\rfloor}{32}\n$$\nWe evaluate the term inside the floor function:\n$$\n32 \\cdot \\frac{13}{64} = \\frac{13}{2} = 6.5\n$$\nTaking the floor gives $\\lfloor 6.5 \\rfloor = 6$.\nSo, the quantized coefficient is:\n$$\n\\tilde{h}[2] = \\frac{6}{32} = \\frac{3}{16}\n$$\nNow we compute the coefficient error $\\Delta h[2]$:\n$$\n\\Delta h[2] = \\tilde{h}[2] - h[2] = \\frac{3}{16} - \\frac{13}{64}\n$$\nTo subtract these fractions, we find a common denominator, which is $64$:\n$$\n\\Delta h[2] = \\frac{3 \\cdot 4}{16 \\cdot 4} - \\frac{13}{64} = \\frac{12}{64} - \\frac{13}{64} = -\\frac{1}{64}\n$$\nFinally, as established earlier, the DC bias $b$ is equal to this single non-zero coefficient error.\n$$\nb = \\Delta h[2] = -\\frac{1}{64}\n$$", "answer": "$$\\boxed{-\\frac{1}{64}}$$", "id": "2858816"}, {"introduction": "Having seen the direct output error in an FIR filter, we now turn to the more complex case of IIR filters, where feedback makes the system's performance highly sensitive to coefficient values. The stability and frequency response of an IIR filter are determined by its pole locations. This exercise [@problem_id:2858988] requires you to perform a classic sensitivity analysis, deriving how the pole radius $r$ and angle $\\theta$ change in response to small perturbations in the denominator coefficients $a_1$ and $a_2$. Mastering this analytical technique is essential for predicting which filter structures are robust against quantization and for understanding the trade-offs in filter design.", "problem": "Consider a real-coefficient second-order (biquad) digital filter with transfer function\n$$\nH(z) \\;=\\; \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2}},\n$$\nwhere $b_0$, $b_1$, $b_2$, $a_1$, and $a_2$ are real. Assume the pole pair is complex-conjugate, so that the denominator polynomial has two roots $z_p$ and $z_p^{\\ast}$ strictly inside the unit circle and off the real axis. Define the polar representation of a pole by $z_p = r \\exp(j \\theta)$ with radius $r \\in (0,1)$ and angle $\\theta \\in (0,\\pi)$ in radians.\n\nSuppose the coefficients $a_1$ and $a_2$ are subject to small finite-word-length quantization perturbations, modeled as independent, sufficiently small differentials $\\mathrm{d}a_1$ and $\\mathrm{d}a_2$. Define the local sensitivities of the pole invariants $r$ and $\\theta$ with respect to $a_1$ and $a_2$ by the partial derivatives $\\frac{\\partial r}{\\partial a_1}$, $\\frac{\\partial r}{\\partial a_2}$, $\\frac{\\partial \\theta}{\\partial a_1}$, and $\\frac{\\partial \\theta}{\\partial a_2}$, so that the first-order variations satisfy\n$$\n\\mathrm{d}r \\;\\approx\\; \\frac{\\partial r}{\\partial a_1}\\,\\mathrm{d}a_1 \\;+\\; \\frac{\\partial r}{\\partial a_2}\\,\\mathrm{d}a_2,\\qquad\n\\mathrm{d}\\theta \\;\\approx\\; \\frac{\\partial \\theta}{\\partial a_1}\\,\\mathrm{d}a_1 \\;+\\; \\frac{\\partial \\theta}{\\partial a_2}\\,\\mathrm{d}a_2.\n$$\n\nStarting only from fundamental polynomial factorization for real-coefficient quadratics with complex-conjugate roots and the definitions of $r$ and $\\theta$, derive closed-form expressions for these four partial derivatives in terms of $a_1$ and $a_2$, under the admissibility conditions $a_2>0$ and $a_1^2<4a_2$. Report your final result as the four entries in the order $\\left(\\frac{\\partial r}{\\partial a_1},\\,\\frac{\\partial r}{\\partial a_2},\\,\\frac{\\partial \\theta}{\\partial a_1},\\,\\frac{\\partial \\theta}{\\partial a_2}\\right)$. Angles must be expressed in radians. No numerical evaluation is required; provide exact analytic expressions only.", "solution": "The problem is valid. It is a standard exercise in the sensitivity analysis of digital filters, which is scientifically grounded, well-posed, and objective. We shall proceed with the derivation.\n\nThe poles of the filter are the roots of the denominator polynomial $D(z^{-1}) = 1 + a_1 z^{-1} + a_2 z^{-2}$. This is equivalent to finding the roots of the characteristic polynomial $P(z) = z^2 + a_1 z + a_2 = 0$.\nThe problem states that the poles are a complex-conjugate pair, denoted by $z_p = r \\exp(j\\theta)$ and $z_p^{\\ast} = r \\exp(-j\\theta)$, where $r \\in (0,1)$ and $\\theta \\in (0,\\pi)$.\n\nThe polynomial $P(z)$ can be factored based on its roots:\n$$P(z) = (z - z_p)(z - z_p^{\\ast}) = z^2 - (z_p + z_p^{\\ast})z + z_p z_p^{\\ast}$$\nBy comparing the coefficients of this expanded form with $z^2 + a_1 z + a_2$, we establish the relationship between the coefficients $(a_1, a_2)$ and the polar representation of the poles $(r, \\theta)$.\n\nThe sum of the roots is:\n$$z_p + z_p^{\\ast} = r \\exp(j\\theta) + r \\exp(-j\\theta) = r(\\cos\\theta + j\\sin\\theta) + r(\\cos\\theta - j\\sin\\theta) = 2r\\cos\\theta$$\nThe product of the roots is:\n$$z_p z_p^{\\ast} = (r \\exp(j\\theta))(r \\exp(-j\\theta)) = r^2$$\n\nEquating the coefficients gives the following system of equations:\n$$a_1 = -2r\\cos\\theta \\quad (1)$$\n$$a_2 = r^2 \\quad (2)$$\n\nThese equations define $a_1$ and $a_2$ as functions of $r$ and $\\theta$. We need to find the partial derivatives of $r$ and $\\theta$ with respect to $a_1$ and $a_2$. We will use the method of implicit differentiation. We treat $r$ and $\\theta$ as functions of $a_1$ and $a_2$ and differentiate the system $(1)$ and $(2)$ with respect to $a_1$ and $a_2$.\n\nFirst, we differentiate with respect to $a_1$:\n$$\\frac{\\partial}{\\partial a_1}(a_1) = 1 = \\frac{\\partial}{\\partial a_1}(-2r\\cos\\theta) = -2\\left(\\frac{\\partial r}{\\partial a_1}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}\\right)$$\n$$\\frac{\\partial}{\\partial a_1}(a_2) = 0 = \\frac{\\partial}{\\partial a_1}(r^2) = 2r\\frac{\\partial r}{\\partial a_1}$$\n\nFrom the second differentiated equation, since $r \\in (0,1)$, we have $r \\neq 0$, which implies:\n$$\\frac{\\partial r}{\\partial a_1} = 0$$\nSubstituting this result into the first differentiated equation:\n$$1 = -2\\left(0 \\cdot \\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}\\right) = 2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}$$\nSolving for $\\frac{\\partial \\theta}{\\partial a_1}$ gives:\n$$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{2r\\sin\\theta}$$\n\nNext, we differentiate the original system with respect to $a_2$:\n$$\\frac{\\partial}{\\partial a_2}(a_1) = 0 = \\frac{\\partial}{\\partial a_2}(-2r\\cos\\theta) = -2\\left(\\frac{\\partial r}{\\partial a_2}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}\\right)$$\n$$\\frac{\\partial}{\\partial a_2}(a_2) = 1 = \\frac{\\partial}{\\partial a_2}(r^2) = 2r\\frac{\\partial r}{\\partial a_2}$$\n\nFrom the second differentiated equation, we find $\\frac{\\partial r}{\\partial a_2}$:\n$$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2r}$$\nSubstituting this into the first differentiated equation:\n$$0 = -2\\left(\\frac{1}{2r}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}\\right) = -\\frac{\\cos\\theta}{r} + 2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}$$\nSolving for $\\frac{\\partial \\theta}{\\partial a_2}$:\n$$2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{r} \\implies \\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{2r^2\\sin\\theta}$$\n\nThe derived partial derivatives are currently expressed in terms of $r$ and $\\theta$. We must convert them into expressions solely in terms of $a_1$ and $a_2$.\nFrom equation $(2)$, $r = \\sqrt{a_2}$ (since $r>0$).\nFrom equation $(1)$, $\\cos\\theta = -\\frac{a_1}{2r} = -\\frac{a_1}{2\\sqrt{a_2}}$.\nSince $\\theta \\in (0,\\pi)$, $\\sin\\theta$ must be positive. Therefore:\n$$\\sin\\theta = \\sqrt{1 - \\cos^2\\theta} = \\sqrt{1 - \\left(-\\frac{a_1}{2\\sqrt{a_2}}\\right)^2} = \\sqrt{1 - \\frac{a_1^2}{4a_2}} = \\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}$$\nThe admissibility condition $a_1^2 < 4a_2$ ensures the argument of the square root is positive.\n\nNow we substitute these expressions back into our results for the partial derivatives.\n\nFor $\\frac{\\partial r}{\\partial a_1}$:\nThe result is already absolute: $\\frac{\\partial r}{\\partial a_1} = 0$.\n\nFor $\\frac{\\partial r}{\\partial a_2}$:\n$$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2r} = \\frac{1}{2\\sqrt{a_2}}$$\n\nFor $\\frac{\\partial \\theta}{\\partial a_1}$:\n$$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{2r\\sin\\theta} = \\frac{1}{2(\\sqrt{a_2})\\left(\\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}\\right)} = \\frac{1}{\\sqrt{4a_2 - a_1^2}}$$\n\nFor $\\frac{\\partial \\theta}{\\partial a_2}$:\n$$\\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{2r^2\\sin\\theta} = \\frac{-\\frac{a_1}{2\\sqrt{a_2}}}{2(a_2)\\left(\\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}\\right)} = \\frac{-\\frac{a_1}{2\\sqrt{a_2}}}{\\frac{a_2\\sqrt{4a_2 - a_1^2}}{\\sqrt{a_2}}} = -\\frac{a_1}{2\\sqrt{a_2}} \\cdot \\frac{\\sqrt{a_2}}{a_2\\sqrt{4a_2 - a_1^2}} = -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}}$$\n\nThe four partial derivatives are:\n$\\frac{\\partial r}{\\partial a_1} = 0$\n$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2\\sqrt{a_2}}$\n$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{\\sqrt{4a_2 - a_1^2}}$\n$\\frac{\\partial \\theta}{\\partial a_2} = -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}}$\n\nThese are the required closed-form expressions in terms of $a_1$ and $a_2$. The conditions $a_2>0$ and $a_1^2<4a_2$ ensure all expressions are well-defined and real. We now assemble the final answer in the specified order.", "answer": "$$\\boxed{\\begin{pmatrix} 0 & \\frac{1}{2\\sqrt{a_2}} & \\frac{1}{\\sqrt{4a_2 - a_1^2}} & -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}} \\end{pmatrix}}$$", "id": "2858988"}, {"introduction": "Linear sensitivity analysis provides powerful predictions, but the reality of fixed-point hardware involves inherently nonlinear operations like rounding and saturation. These nonlinearities can give rise to complex phenomena, such as limit cycles, which are self-sustaining oscillations even with zero input. This hands-on programming exercise challenges you to build an exact fixed-point simulation of a second-order IIR filter to explore its behavior as a finite state machine [@problem_id:2858969]. By computing the filter's deadband and smallest limit cycle amplitude, you will gain invaluable insight into the zero-input nonlinear dynamics that linear models fail to capture.", "problem": "You are given a class of discrete-time, real-coefficient, second-order Infinite Impulse Response (IIR) systems implemented in fixed-point arithmetic with coefficient quantization and rounding at every primitive operation. The system is defined in the direct-form recursion by\n$$\ny[n] \\;=\\; -a_1\\,y[n-1] \\;-\\; a_2\\,y[n-2] \\;+\\; b_0\\,x[n] \\;+\\; b_1\\,x[n-1] \\;+\\; b_2\\,x[n-2],\n$$\nwith zero input, i.e., \n$$\nx[n] \\equiv 0,\n$$\nso the evolution reduces to\n$$\ny[n] \\;=\\; -a_1\\,y[n-1] \\;-\\; a_2\\,y[n-2],\n$$\nbut computed in a fixed-point environment where every multiplication and every addition is immediately rounded to the signal word grid and saturated to the signal range. Coefficients are quantized prior to use. Assume the following computational model.\n\n1. Signal word format: two's-complement fixed-point with exactly one sign bit and $F_s$ fractional bits (no integer magnitude bits). The representable signal set is \n$$\n\\mathcal{Y}_{F_s} \\;=\\; \\left\\{ m \\cdot 2^{-F_s} \\;:\\; m \\in \\mathbb{Z}, \\; -2^{F_s} \\le m \\le 2^{F_s}-1 \\right\\},\n$$\nwith saturation bounds \n$$\ny_{\\min} \\;=\\; -1, \n\\qquad\ny_{\\max} \\;=\\; 1 - 2^{-F_s}.\n$$\nLet $\\Delta_s \\triangleq 2^{-F_s}$ denote the signal quantization step size.\n\n2. Coefficient word format: real coefficients $a_1$ and $a_2$ are quantized to $F_c$ fractional bits by rounding to the nearest multiple of $\\Delta_c \\triangleq 2^{-F_c}$ (ties resolved to the nearest even quantization level). The quantized coefficients are\n$$\n\\widehat{a}_i \\;=\\; \\operatorname{Q}_c(a_i) \\;=\\; \\operatorname{round\\_to\\_nearest\\_even}\\!\\left(a_i, \\Delta_c\\right), \\quad i \\in \\{1,2\\}.\n$$\n\n3. Arithmetic model (rounding at each operation with saturation): At each time $n$, compute\n- two products $p_1[n] = -\\widehat{a}_1 \\, y[n-1]$ and $p_2[n] = -\\widehat{a}_2 \\, y[n-2]$, each immediately rounded to the nearest multiple of $\\Delta_s$ with ties to even, then saturated into $[y_{\\min}, y_{\\max}]$,\n- followed by one sum $s[n] = p_1[n] + p_2[n]$, immediately saturated into $[y_{\\min}, y_{\\max}]$ (no additional rounding is necessary because the operands are already on the signal grid),\n- and finally $y[n] = s[n]$.\n\n4. State-space representation on the signal grid: The system's state at time $n$ is the ordered pair \n$$\n\\mathbf{s}[n] \\triangleq \\big(y[n], \\; y[n-1]\\big) \\in \\mathcal{Y}_{F_s} \\times \\mathcal{Y}_{F_s},\n$$\nand the next state is a deterministic function of the current state, i.e., \n$$\n\\mathbf{s}[n+1] \\;=\\; \\Phi(\\mathbf{s}[n]),\n$$\ninduced by the arithmetic model above. Because the state space is finite and the dynamics deterministic, every trajectory is eventually periodic (converges to a fixed point or to a nontrivial limit cycle).\n\nDefinitions required for the task:\n\n- Deadband width along the $y[-1]$ axis: Consider zero input and restrict initial conditions to\n$$\ny[-2] \\;=\\; 0, \n\\qquad\ny[-1] \\in \\mathcal{Y}_{F_s}.\n$$\nDefine \n$$\n\\mathcal{D} \\;=\\; \\left\\{ y[-1] \\in \\mathcal{Y}_{F_s} \\;:\\; \\text{the trajectory converges to the zero fixed point } (y[n]\\equiv 0) \\right\\}.\n$$\nLet $D$ be the supremum of nonnegative $d$ such that the entire symmetric interval $[-d, d] \\cap \\mathcal{Y}_{F_s}$ is contained in $\\mathcal{D}$. The deadband width is the length of this largest symmetric interval,\n$$\nW_{\\mathrm{dead}} \\;\\triangleq\\; 2D.\n$$\n\n- Smallest nonzero limit cycle amplitude: For any periodic orbit (limit cycle) in the zero-input dynamics, define its amplitude as\n$$\nA(\\text{cycle}) \\;\\triangleq\\; \\max_{n \\text{ on the cycle}} |y[n]|.\n$$\nAmong all nonzero cycles, define\n$$\nA_{\\min} \\;\\triangleq\\; \\min_{\\text{nonzero cycles}} A(\\text{cycle}).\n$$\nIf there are no nonzero cycles, define $A_{\\min} \\triangleq 0$.\n\nYour task is to write a program that, for the given test suite of parameter sets $(a_1, a_2, F_c, F_s)$, performs the exact fixed-point simulation on the finite state space implied by the model above, and computes:\n\n- the deadband width $W_{\\mathrm{dead}}$ (a real number in the same units as $y[n]$),\n- the smallest nonzero limit cycle amplitude $A_{\\min}$ (a real number in the same units as $y[n]$).\n\nYou must treat rounding to the nearest with ties to even at the coefficient quantization step and at each multiplication result. All saturations must conform to the signal range $[y_{\\min}, y_{\\max}]$. The sums are saturated but otherwise exactly representable on the signal grid.\n\nTest suite:\n\n- Case $1$: $a_1 = -1.8$, $a_2 = 0.81$, $F_c = 6$, $F_s = 6$.\n- Case $2$: $a_1 = 0.0$, $a_2 = 0.0$, $F_c = 10$, $F_s = 5$.\n- Case $3$: $a_1 = -1.98$, $a_2 = 0.9801$, $F_c = 10$, $F_s = 7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list of the form $[W_{\\mathrm{dead}}, A_{\\min}]$, both expressed as decimal real numbers. For example, the output format must be exactly\n$$\n\\big[ [W_1, A_1], [W_2, A_2], [W_3, A_3] \\big].\n$$\nNo physical units are involved in this problem. Angles do not appear. Do not print any additional text besides the specified single line. The algorithm must be exact with respect to the finite fixed-point model; do not use stochastic noise models or asymptotic approximations.", "solution": "The problem is valid as it is scientifically grounded in the principles of digital signal processing, specifically the analysis of finite wordlength effects in IIR filters. It is well-posed, objective, and provides a complete and consistent set of specifications for a computationally feasible task.\n\nThe solution is found by performing an exact simulation of the system's dynamics on its finite state space. The core principle is to map the fixed-point signal values and arithmetic operations onto integer arithmetic to avoid floating-point inaccuracies and to work directly with the discrete nature of the problem.\n\nFirst, we formalize the system's state and its evolution. The state at time $n$ is the pair of previous outputs $\\mathbf{s}[n-1] = (y[n-1], y[n-2])$. Since signal values $y$ belong to the discrete set $\\mathcal{Y}_{F_s} = \\{ m \\cdot \\Delta_s : m \\in \\mathbb{Z}, -2^{F_s} \\le m \\le 2^{F_s}-1 \\}$, where $\\Delta_s = 2^{-F_s}$, it is exact and computationally advantageous to represent the state by an integer pair $(m_{n-1}, m_{n-2})$. The integer multipliers $m$ range from $m_{\\min} = -2^{F_s}$ to $m_{\\max} = 2^{F_s}-1$. The state space is a finite grid of $(m_{\\max} - m_{\\min} + 1)^2 = (2 \\cdot 2^{F_s})^2 = 4 \\cdot 2^{2F_s}$ states.\n\nThe state transition function $\\mathbf{s}[n] = \\Phi(\\mathbf{s}[n-1])$ is implemented as a function that maps an integer state $(m_{n-1}, m_{n-2})$ to the next state $(m_n, m_{n-1})$. The calculation of the new integer multiplier $m_n$ follows the specified arithmetic model:\n1.  **Coefficient Quantization**: The real coefficients $a_1$ and $a_2$ are first quantized to their fixed-point representations, $\\widehat{a}_1$ and $\\widehat{a}_2$, by rounding to the nearest multiple of $\\Delta_c = 2^{-F_c}$ with ties to the nearest even quantization level. This is performed once per test case.\n    $$\n    \\widehat{a}_i = \\operatorname{round\\_to\\_nearest\\_even}(a_i, \\Delta_c)\n    $$\n2.  **Product Calculation**: The intermediate products $p_1[n] = -\\widehat{a}_1 y[n-1]$ and $p_2[n] = -\\widehat{a}_2 y[n-2]$ are computed. In our integer model, this corresponds to calculating $-\\widehat{a}_1 m_{n-1} \\Delta_s$ and $-\\widehat{a}_2 m_{n-2} \\Delta_s$.\n3.  **Rounding**: Each product is rounded to the nearest multiple of $\\Delta_s$. An intermediate value $V$ is rounded to $k \\cdot \\Delta_s$ where $k$ is the integer closest to $V/\\Delta_s$. The integer multiplier for the first product, $m_{p1}$, is thus found by rounding the value $-\\widehat{a}_1 m_{n-1}$:\n    $$\n    m_{p1} = \\operatorname{round\\_half\\_to\\_even}(-\\widehat{a}_1 m_{n-1})\n    $$\n    and similarly $m_{p2} = \\operatorname{round\\_half\\_to\\_even}(-\\widehat{a}_2 m_{n-2})$. The standard `round()` function in Python 3 implements the required \"round half to even\" rule.\n4.  **Saturation and Summation**: The integer multipliers of the products are saturated to the range $[m_{\\min}, m_{\\max}]$. The saturated multipliers, $m_{p1, \\text{sat}}$ and $m_{p2, \\text{sat}}$, are then added. The sum is saturated again to the same range to yield the final integer multiplier for the new output, $m_n$.\n    $$\n    m_n = \\operatorname{clip}(m_{p1, \\text{sat}} + m_{p2, \\text{sat}}, m_{\\min}, m_{\\max})\n    $$\n\nWith a deterministic state transition function on a finite state space, every trajectory must eventually become periodic, converging to either a fixed point or a limit cycle. To find these attractors and their basins of attraction, we perform an exhaustive search of the state space. We use a 2D array, `fate`, to store the ultimate destiny of each state. We iterate through every state $(m_1, m_2)$. If its fate is unknown, we simulate the trajectory starting from it, recording the path. The simulation for a path terminates when it encounters a state that has already been classified, or when it repeats a state from its own path, thus identifying a new cycle. The fates of all states in the newly traversed path are then recorded. Cycles are categorized as either the zero fixed point $(0,0)$ or a non-zero limit cycle, for which an amplitude is calculated.\n\nFinally, we compute the required quantities:\n-   **Smallest Nonzero Limit Cycle Amplitude ($A_{\\min}$)**: This is the minimum of the amplitudes computed for all identified nonzero limit cycles. The amplitude of a cycle is defined as $\\max|y[n]|$ over the cycle, which is calculated as $(\\max|m_n|) \\cdot \\Delta_s$. If no nonzero cycles are found, $A_{\\min}$ is $0$.\n-   **Deadband Width ($W_{\\mathrm{dead}}$)**: The deadband is related to the set $\\mathcal{D}$ of initial values $y[-1]$ (with $y[-2]=0$) for which the system converges to the zero fixed point. We find the largest integer $M \\ge 0$ such that for all integer multipliers $k$ in the range $[-M, M]$, the trajectory starting from state $(k, 0)$ converges to the zero fixed point $(0,0)$. The half-width of the deadband is $D = M \\cdot \\Delta_s$, and the full width is $W_{\\mathrm{dead}} = 2D$.\n\nThis systematic approach guarantees an exact analysis of the specified fixed-point model.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the IIR filter analysis problem for a suite of test cases.\n    \"\"\"\n\n    def analyze_system(a1, a2, Fc, Fs):\n        \"\"\"\n        Performs exact fixed-point simulation and analysis for a single system.\n\n        Args:\n            a1 (float): The ideal coefficient a1.\n            a2 (float): The ideal coefficient a2.\n            Fc (int): The number of fractional bits for coefficients.\n            Fs (int): The number of fractional bits for the signal.\n\n        Returns:\n            list: A list containing [W_dead, A_min].\n        \"\"\"\n        # 1. Setup\n        delta_c = 2**(-Fc)\n        delta_s = 2**(-Fs)\n        m_limit = 2**Fs\n        m_min = -m_limit\n        m_max = m_limit - 1\n\n        # Quantize coefficients using round-half-to-even\n        a1_hat = np.round(a1 / delta_c) * delta_c\n        a2_hat = np.round(a2 / delta_c) * delta_c\n\n        # State space representation: integer multipliers (m1, m2)\n        # fate array: 0=unvisited, -1=converges to zero, >0=cycle_id\n        state_space_dim = m_max - m_min + 1\n        fate = np.zeros((state_space_dim, state_space_dim), dtype=np.int32)\n        \n        cycles = {}  # {cycle_id: {'amplitude': float}}\n        cycle_id_counter = 1\n\n        # 2. State Space Traversal\n        for m1_init in range(m_min, m_max + 1):\n            for m2_init in range(m_min, m_max + 1):\n                idx1, idx2 = m1_init + m_limit, m2_init + m_limit\n                \n                if fate[idx1, idx2] != 0:\n                    continue\n\n                # Start a new trajectory simulation\n                s_current = (m1_init, m2_init)\n                path = [s_current]\n                path_dict = {s_current: 0}\n\n                while True:\n                    m_prev1, m_prev2 = s_current\n\n                    # Fixed-point arithmetic using integer multipliers\n                    # round() in Python 3 is round-half-to-even\n                    prod1 = round(-a1_hat * m_prev1)\n                    prod2 = round(-a2_hat * m_prev2)\n                    \n                    prod1_sat = int(np.clip(prod1, m_min, m_max))\n                    prod2_sat = int(np.clip(prod2, m_min, m_max))\n                    \n                    sum_val = prod1_sat + prod2_sat\n                    m_next = int(np.clip(sum_val, m_min, m_max))\n                    \n                    s_next = (m_next, m_prev1)\n                    \n                    next_idx1, next_idx2 = s_next[0] + m_limit, s_next[1] + m_limit\n                    \n                    if fate[next_idx1, next_idx2] != 0:\n                        merged_fate = fate[next_idx1, next_idx2]\n                        for s_in_path in path:\n                            s_idx1 = s_in_path[0] + m_limit\n                            s_idx2 = s_in_path[1] + m_limit\n                            fate[s_idx1, s_idx2] = merged_fate\n                        break\n                    \n                    if s_next in path_dict:\n                        cycle_start_index = path_dict[s_next]\n                        cycle_states = path[cycle_start_index:]\n                        transient_states = path[:cycle_start_index]\n\n                        if len(cycle_states) == 1 and cycle_states[0] == (0, 0):\n                            current_fate = -1\n                        else:\n                            current_fate = cycle_id_counter\n                            max_abs_m = 0\n                            for s_in_cycle in cycle_states:\n                                max_abs_m = max(max_abs_m, abs(s_in_cycle[0]))\n                            \n                            amplitude = max_abs_m * delta_s\n                            cycles[current_fate] = {'amplitude': amplitude}\n                            cycle_id_counter += 1\n\n                        for s in transient_states:\n                            fate[s[0] + m_limit, s[1] + m_limit] = current_fate\n                        for s in cycle_states:\n                            fate[s[0] + m_limit, s[1] + m_limit] = current_fate                        \n                        break\n\n                    path.append(s_next)\n                    path_dict[s_next] = len(path) - 1\n                    s_current = s_next\n\n        # 3. Calculate W_dead\n        m2_idx_zero = 0 + m_limit\n        max_m_deadband = 0\n        if fate[0 + m_limit, m2_idx_zero] == -1:\n            for m in range(1, m_limit):\n                fate_pos = fate[m + m_limit, m2_idx_zero]\n                fate_neg = fate[-m + m_limit, m2_idx_zero]\n                \n                if fate_pos == -1 and fate_neg == -1:\n                    max_m_deadband = m\n                else:\n                    break\n        D = max_m_deadband * delta_s\n        W_dead = 2 * D\n\n        # 4. Calculate A_min\n        all_amplitudes = [c['amplitude'] for c in cycles.values()]\n        A_min = min(all_amplitudes) if all_amplitudes else 0.0\n        \n        return [W_dead, A_min]\n\n    test_cases = [\n        (-1.8, 0.81, 6, 6),\n        (0.0, 0.0, 10, 5),\n        (-1.98, 0.9801, 10, 7),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_system(*case)\n        results.append(result)\n\n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2858969"}]}