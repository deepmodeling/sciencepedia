{"hands_on_practices": [{"introduction": "The back-calculation method is a cornerstone of anti-windup design, yet the tuning of its gain, $k_{\\mathrm{aw}}$, is often approached heuristically. This exercise moves beyond trial-and-error by developing a principled tuning rule based on loop shaping concepts [@problem_id:2690044]. You will derive a direct relationship between $k_{\\mathrm{aw}}$ and the desired desaturation bandwidth—a measure of how quickly the controller recovers from saturation—and then validate your theoretical findings through numerical simulation.", "problem": "You are given a single-input single-output closed-loop system consisting of a linear time-invariant plant, a proportional-integral controller, a saturating actuator, and a back-calculation anti-windup mechanism. The plant is described by the transfer function $P(s) = \\dfrac{1}{s + 1}$, and the controller is described by the transfer function $K(s) = k_p + \\dfrac{k_i}{s}$. The actuator saturates the controller output $u(t)$ into the signal $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$ with symmetric limits $\\pm u_{\\max}$. The back-calculation anti-windup is implemented by modifying the controller’s internal integrator state through the signal $v(t) - u(t)$ multiplied by a scalar gain $k_{\\mathrm{aw}}$, that is, the controller integrator dynamics are \n$$\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right),$$\nwith $u(t) = k_p e(t) + k_i z(t)$ and $e(t) = r(t) - y(t)$, where $y(t)$ is the plant output and $r(t)$ is the reference.\n\nStarting from the core definitions of linear time-invariant systems, Laplace transforms, and closed-loop interconnections, and using only the properties of the proportional-integral controller and the saturating actuator, derive a principled tuning method for the anti-windup gain $k_{\\mathrm{aw}}$ by shaping the loop transfer from the exogenous signal $w(t) = u(t) - v(t)$ to $v(t)$ so that the effective desaturation dynamics exhibit a single real pole at a desired angular bandwidth $\\omega_{\\mathrm{aw}}$ measured in radians per second. Your derivation must begin from the state-space or transfer-function representation of the closed loop with the exogenous input $w(t)$ injected at the actuator, must be internally consistent with the plant and controller given above, and must justify how the selection of $k_{\\mathrm{aw}}$ determines the desaturation bandwidth.\n\nAfter deriving the tuning rule, implement it in a numerical experiment that demonstrates how the anti-windup bandwidth affects transient recovery from actuator saturation after a large step command. Use the following fixed parameters for the numerical experiment:\n- Plant $P(s) = \\dfrac{1}{s + 1}$.\n- Controller gains $k_p = 4$ and $k_i = 4$.\n- Saturation limit $u_{\\max} = 0.5$.\n- Step reference $r(t) = r_0$ with $r_0 = 2$ for all $t \\ge 0$.\n- Initial conditions $x_p(0) = 0$ for the plant state $x_p$, and $z(0) = 0$ for the controller integrator state.\n\nDefine the unsaturated closed-loop bandwidth $\\omega_{\\mathrm{cl}}$ as the absolute value of the real part of the slowest (closest to the imaginary axis) pole of the linear closed-loop system formed by $P(s)$ and $K(s)$ without actuator saturation and without anti-windup feedback (i.e., with the standard proportional-integral controller). Using your derived tuning method, choose $k_{\\mathrm{aw}}$ to achieve three different anti-windup bandwidths $\\omega_{\\mathrm{aw}}$ given by $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$ with the factors $f$ specified in the test suite below.\n\nSimulate the resulting nonlinear closed-loop system with the saturator and anti-windup feedback, and compute the desaturation recovery time $t_{\\mathrm{rec}}$ defined as the last time at which the saturation discrepancy $|w(t)| = |u(t) - v(t)|$ exceeds a small threshold $\\varepsilon$. Use $\\varepsilon = 1\\times 10^{-3}$, and simulate up to a finite horizon $T_{\\max}$ large enough to capture recovery; you must use $T_{\\max} = 15$ seconds. Express $t_{\\mathrm{rec}}$ in seconds, rounded to three decimal places.\n\nYour program must implement the following test suite of three anti-windup bandwidth factors:\n- Case $1$: $f = 0.5$.\n- Case $2$: $f = 2$.\n- Case $3$: $f = 10$.\n\nFor each case, compute $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$, tune $k_{\\mathrm{aw}}$ according to your derived loop-shaping rule, run the simulation, and return the corresponding $t_{\\mathrm{rec}}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[1.234,5.678,9.000]\"), where each entry is $t_{\\mathrm{rec}}$ for the corresponding test case in seconds, rounded to three decimals. No additional text should be printed.", "solution": "We begin with the standard interconnection of a single-input single-output linear plant with a proportional-integral controller and a saturating actuator. The plant is $P(s) = \\dfrac{1}{s + 1}$. The controller is $K(s) = k_p + \\dfrac{k_i}{s}$, implemented via the internal integrator state $z(t)$ with equations $u(t) = k_p e(t) + k_i z(t)$ and $\\dot{z}(t) = e(t)$ in the absence of anti-windup. The saturator maps the pre-saturation input $u(t)$ into $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$, and the plant state-space realization is $\\dot{x}_p(t) = - x_p(t) + v(t)$ with output $y(t) = x_p(t)$. The closed-loop error is $e(t) = r(t) - y(t)$.\n\nTo analyze actuator saturation, we introduce the exogenous discrepancy signal $w(t) = u(t) - v(t)$ so that $v(t) = u(t) - w(t)$. The back-calculation anti-windup modifies the integrator dynamics to\n$$\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right) = e(t) - k_{\\mathrm{aw}} w(t).$$\nThis structure causes the controller internal state to track the saturated actuator output, counteracting windup.\n\nWe derive a loop-shaping rule by examining the mapping that governs desaturation dynamics, which are captured by the tracking of the pre-saturation controller signal $u(t)$ towards the saturated actuator output $v(t)$. Consider the scenario that isolates the tracking loop by setting $e(t) = 0$, which represents the local effect of saturation on the controller when the error feedback is negligible compared to the back-calculation term. Under $e(t) = 0$, we have $u(t) = k_i z(t)$ and\n$$\\dot{z}(t) = - k_{\\mathrm{aw}} w(t) = k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right).$$\nIt follows that\n$$\\dot{u}(t) = k_i \\dot{z}(t) = k_i k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right).$$\nTaking Laplace transforms with zero initial conditions gives\n$$s U(s) = k_i k_{\\mathrm{aw}} \\left(V(s) - U(s)\\right),$$\nso that the transfer function from $V(s)$ to $U(s)$ is\n$$\\frac{U(s)}{V(s)} = \\frac{k_i k_{\\mathrm{aw}}}{s + k_i k_{\\mathrm{aw}}}.$$\nTherefore, the tracking dynamics of $u(t)$ towards $v(t)$ are those of a stable first-order system with a single pole at $s = - k_i k_{\\mathrm{aw}}$, and a bandwidth equal to the angular frequency $\\omega = k_i k_{\\mathrm{aw}}$. Since $w(t) = u(t) - v(t)$, the discrepancy $w(t)$ decays with the same time constant. This fundamental relationship is independent of the plant details in the limit where $e(t)$ is small relative to the back-calculation action during desaturation.\n\nThis suggests a loop-shaping rule: choose $k_{\\mathrm{aw}}$ to realize a desired desaturation bandwidth $\\omega_{\\mathrm{aw}}$ by setting\n$$k_{\\mathrm{aw}} = \\frac{\\omega_{\\mathrm{aw}}}{k_i}.$$\nThis rule ensures that the closed-loop mapping associated with desaturation has a single real pole at $s = - \\omega_{\\mathrm{aw}}$, thereby shaping the transfer from $w(t)$ to $v(t)$ indirectly via the tracking of $u(t)$ to $v(t)$ with the specified bandwidth. The effect on the full closed loop including $P(s)$ and $K(s)$ is that, during saturation, the controller internal state is pulled to track the saturated actuator output with a time constant $1 / \\omega_{\\mathrm{aw}}$, thereby reducing windup and improving recovery once the actuator leaves saturation.\n\nNext, we must define the baseline closed-loop bandwidth $\\omega_{\\mathrm{cl}}$ in the absence of saturation and anti-windup. With $P(s) = \\dfrac{1}{s + 1}$ and $K(s) = k_p + \\dfrac{k_i}{s}$, the characteristic polynomial of the linear closed-loop system under unity feedback is obtained from $1 + K(s) P(s) = 0$, or\n$$1 + \\left(k_p + \\frac{k_i}{s}\\right) \\frac{1}{s + 1} = 0.$$\nMultiplying by $s (s + 1)$ yields\n$$s (s + 1) + k_p s + k_i = 0,$$\nwhich simplifies to\n$$s^2 + (1 + k_p) s + k_i = 0.$$\nThe closed-loop poles are the roots of this quadratic. The slowest pole (that closest to the imaginary axis) determines the dominant decay rate, and we define the unsaturated closed-loop bandwidth as\n$$\\omega_{\\mathrm{cl}} = \\left| \\operatorname{Re}\\left(s_{\\mathrm{dom}}\\right) \\right|,$$\nwhere $s_{\\mathrm{dom}}$ is the pole with the largest real part (closest to zero) among the two distinct real poles in this case. For the numerical parameters $k_p = 4$ and $k_i = 4$, the characteristic polynomial is $s^2 + 5 s + 4$, with roots at $s = -1$ and $s = -4$, so the dominant pole is $s_{\\mathrm{dom}} = -1$ and $\\omega_{\\mathrm{cl}} = 1$.\n\nWith this baseline bandwidth, we implement the loop-shaping rule by setting\n$$\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}, \\quad k_{\\mathrm{aw}} = \\frac{\\omega_{\\mathrm{aw}}}{k_i} = \\frac{f \\, \\omega_{\\mathrm{cl}}}{k_i}.$$\nThis provides a systematic mapping from a desired desaturation bandwidth factor $f$ to the anti-windup gain $k_{\\mathrm{aw}}$.\n\nTo demonstrate the effect of anti-windup bandwidth on transient recovery, we simulate the nonlinear closed loop with the saturator and back-calculation anti-windup, using the plant state-space $\\dot{x}_p(t) = - x_p(t) + v(t)$ and $y(t) = x_p(t)$, the controller $u(t) = k_p e(t) + k_i z(t)$ with $\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right)$, the error $e(t) = r(t) - y(t)$, the step reference $r(t) = r_0$ with $r_0 = 2$, and saturation $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$ with $u_{\\max} = 0.5$. The initial conditions are $x_p(0) = 0$ and $z(0) = 0$.\n\nWe define the desaturation recovery time $t_{\\mathrm{rec}}$ as the last time at which the saturation discrepancy $|w(t)| = |u(t) - v(t)|$ exceeds the threshold $\\varepsilon = 10^{-3}$. That is, $t_{\\mathrm{rec}}$ is the supremum of times $t$ in the simulation horizon $[0, T_{\\max}]$ such that $|w(t)| > \\varepsilon$. We simulate up to $T_{\\max} = 15$ seconds, which is sufficient to capture recovery for the given ranges of $k_{\\mathrm{aw}}$.\n\nThe test suite uses three factors $f$:\n- Case $1$: $f = 0.5$, so $\\omega_{\\mathrm{aw}} = 0.5 \\, \\omega_{\\mathrm{cl}}$ and $k_{\\mathrm{aw}} = \\dfrac{0.5 \\, \\omega_{\\mathrm{cl}}}{k_i}$,\n- Case $2$: $f = 2$, so $\\omega_{\\mathrm{aw}} = 2 \\, \\omega_{\\mathrm{cl}}$ and $k_{\\mathrm{aw}} = \\dfrac{2 \\, \\omega_{\\mathrm{cl}}}{k_i}$,\n- Case $3$: $f = 10$, so $\\omega_{\\mathrm{aw}} = 10 \\, \\omega_{\\mathrm{cl}}$ and $k_{\\mathrm{aw}} = \\dfrac{10 \\, \\omega_{\\mathrm{cl}}}{k_i}$.\n\nWe expect that larger $\\omega_{\\mathrm{aw}}$ (larger $k_{\\mathrm{aw}}$) will produce faster desaturation, hence smaller $t_{\\mathrm{rec}}$, but excessively large $k_{\\mathrm{aw}}$ can increase transient peaking or cause chatter near saturation limits. The numerical experiment quantifies recovery via $t_{\\mathrm{rec}}$.\n\nAlgorithmic steps for the program:\n- Compute the unsaturated closed-loop poles by solving $s^2 + (1 + k_p) s + k_i = 0$ and set $\\omega_{\\mathrm{cl}}$ to the absolute value of the real part of the dominant pole.\n- For each factor $f$ in the test suite, set $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$ and $k_{\\mathrm{aw}} = \\omega_{\\mathrm{aw}} / k_i$.\n- Simulate the closed-loop differential equations with saturation and back-calculation anti-windup over $[0, T_{\\max}]$ and compute $w(t) = u(t) - v(t)$.\n- Set $t_{\\mathrm{rec}}$ equal to the last time at which $|w(t)| > \\varepsilon$ (or zero if saturation never occurs), and round to three decimals.\n- Print the list $[t_{\\mathrm{rec}}^{(1)}, t_{\\mathrm{rec}}^{(2)}, t_{\\mathrm{rec}}^{(3)}]$ as a single line, where the superscripts correspond to the three cases.\n\nThis procedure is grounded in the fundamental dynamics of the proportional-integral controller and the saturating actuator, and it uses loop shaping of the desaturation tracking dynamics to select the anti-windup gain.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.polynomial.polynomial import Polynomial\n\ndef closed_loop_dominant_bandwidth(kp: float, ki: float) -> float:\n    \"\"\"\n    Compute the unsaturated closed-loop dominant bandwidth as the absolute value\n    of the real part of the slowest pole of s^2 + (1+kp)s + ki = 0.\n    For kp=4, ki=4, poles are -1 and -4, so bandwidth is 1 rad/s.\n    \"\"\"\n    # Characteristic polynomial coefficients: s^2 + (1+kp)s + ki\n    a2 = 1.0\n    a1 = 1.0 + kp\n    a0 = ki\n    roots = np.roots([a2, a1, a0])\n    # Dominant pole: real part closest to zero (largest real part)\n    # For real coefficients, roots should be real here given values.\n    real_parts = np.real(roots)\n    dominant = real_parts[np.argmax(real_parts)]\n    return abs(dominant)\n\ndef simulate_aw_response(kp: float, ki: float, umax: float, r0: float,\n                         k_aw: float, t_final: float = 15.0,\n                         eps: float = 1e-3) -> float:\n    \"\"\"\n    Simulate the nonlinear closed loop with saturation and back-calculation AW.\n    Plant: xdot = -x + v, y = x.\n    Controller: u = kp*e + ki*z, zdot = e + k_aw*(v - u), e = r - y.\n    Saturation: v = sat(u, umax).\n    Return desaturation recovery time t_rec = last time where |u - v| > eps,\n    or 0.0 if saturation discrepancy never exceeds eps.\n    \"\"\"\n    def dynamics(t, state):\n        x, z = state\n        y = x\n        e = r0 - y\n        u = kp * e + ki * z\n        v = np.clip(u, -umax, umax)\n        zdot = e + k_aw * (v - u)\n        xdot = -x + v\n        return [xdot, zdot]\n\n    # Time grid for evaluation\n    t_eval = np.linspace(0.0, t_final, 6001)  # 2.5 ms step approx\n    sol = solve_ivp(dynamics, (0.0, t_final), [0.0, 0.0], t_eval=t_eval, rtol=1e-8, atol=1e-10, method='RK45')\n    x = sol.y[0, :]\n    z = sol.y[1, :]\n    y = x\n    e = r0 - y\n    u = kp * e + ki * z\n    v = np.clip(u, -umax, umax)\n    w = u - v\n    mask = np.abs(w) > eps\n    if not np.any(mask):\n        return 0.0\n    # Last time index where saturation discrepancy is above eps\n    last_idx = np.where(mask)[0][-1]\n    t_rec = sol.t[last_idx]\n    return float(t_rec)\n\ndef solve():\n    # Fixed parameters\n    kp = 4.0\n    ki = 4.0\n    umax = 0.5\n    r0 = 2.0\n    t_final = 15.0\n    eps = 1e-3\n\n    # Compute unsaturated closed-loop dominant bandwidth\n    omega_cl = closed_loop_dominant_bandwidth(kp, ki)\n\n    # Test cases: factors f for omega_aw = f * omega_cl\n    test_cases = [0.5, 2.0, 10.0]\n\n    results = []\n    for f in test_cases:\n        omega_aw = f * omega_cl\n        k_aw = omega_aw / ki  # loop-shaping rule derived from u_dot = ki*k_aw (v - u)\n        t_rec = simulate_aw_response(kp, ki, umax, r0, k_aw, t_final=t_final, eps=eps)\n        results.append(round(t_rec, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2690044"}, {"introduction": "Now that we have a method to tune an anti-windup compensator, how do we holistically quantify its impact on closed-loop stability and performance? This practice introduces the concept of the Region of Attraction (RoA) as a key metric for nonlinear systems subject to saturation [@problem_id:2690066]. You will implement a numerical procedure to estimate the RoA for a system with and without anti-windup, providing a powerful visualization and a quantitative measure of how the compensator enhances the domain of stable operation.", "problem": "Consider the double integrator plant with a saturated actuator and a linear state-feedback controller augmented by an integral action on the position state. The plant obeys the state-space equations\n$$\n\\dot{x}_1 = x_2,\\quad \\dot{x}_2 = u,\n$$\nwhere $x_1 \\in \\mathbb{R}$ is position, $x_2 \\in \\mathbb{R}$ is velocity, and $u \\in \\mathbb{R}$ is the control input. The commanded control $v \\in \\mathbb{R}$ is generated by a linear state-feedback with integral action,\n$$\nv = -k_1 x_1 - k_2 x_2 - k_I z,\n$$\nwhere $z \\in \\mathbb{R}$ is the controller integrator state that integrates $x_1$. The actuator saturates the commanded control according to\n$$\nu = \\mathrm{sat}(v; u_{\\max}) \\triangleq \\max\\!\\big(-u_{\\max},\\, \\min(v,\\, u_{\\max})\\big),\n$$\nwith saturation limit $u_{\\max} \\gt 0$. The integrator dynamics without anti-windup are\n$$\n\\dot{z} = x_1,\n$$\nand with a standard linear back-calculation anti-windup augmentation they are\n$$\n\\dot{z} = x_1 + k_{\\mathrm{aw}}(u - v),\n$$\nwhere $k_{\\mathrm{aw}} \\ge 0$ is the anti-windup gain. All quantities are dimensionless.\n\nFor a given parameter set $(k_1, k_2, k_I, u_{\\max}, k_{\\mathrm{aw}})$ and a fixed initial integrator state $z(0) = 0$, define the region of attraction (RoA) of the origin in the $(x_1, x_2)$-plane as the set of initial conditions $(x_1(0), x_2(0))$ for which the closed-loop trajectory converges to the origin. In this problem, you will compute a certified inner estimate of the RoA as the largest Euclidean ball centered at the origin contained in the RoA, quantified by its radius $r^\\star \\ge 0$:\n$$\nr^\\star \\triangleq \\sup\\{ r \\ge 0 \\; | \\; \\text{for all } \\theta \\in [0, 2\\pi),\\ \\|(x_1(0), x_2(0))\\|_2=r,\\ z(0)=0 \\Rightarrow \\lim_{t\\to\\infty} \\|(x_1(t), x_2(t))\\|_2 = 0 \\}.\n$$\n\nBecause exact analytical computation of $r^\\star$ for this nonlinear saturated system is difficult, you must estimate it numerically by simulating the closed-loop system and performing a bisection search over $r$. Use the following principle-based specification:\n\n1. Use the full nonlinear closed-loop dynamics with saturation as given above.\n2. For a candidate radius $r \\ge 0$, test all initial conditions on the circle $\\{(x_1(0), x_2(0)) \\; | \\; \\|(x_1(0), x_2(0))\\|_2 = r\\}$ at $N$ equally spaced angles $\\theta_j = 2\\pi j/N$, where $j \\in \\{0,1,\\ldots,N-1\\}$, $x_1(0) = r\\cos(\\theta_j)$, $x_2(0) = r\\sin(\\theta_j)$, and $z(0)=0$.\n3. For each initial condition, simulate the system up to a finite horizon $T$, and declare convergence if the trajectory enters the ball of radius $\\varepsilon$ around the origin, that is if there exists $t \\in [0, T]$ such that $\\sqrt{x_1(t)^2 + x_2(t)^2} \\le \\varepsilon$. If any initial condition on the circle fails to converge within the horizon, then the candidate $r$ is not certified.\n4. Use a bisection search bracketed by radii that fail/succeed to compute an estimate of $r^\\star$ with a desired numerical tolerance. You may grow the upper bracket geometrically until a failure is detected or a preset cap is reached.\n5. Repeat the computation twice for each parameter set: once without anti-windup (that is, using $\\dot{z} = x_1$) and once with anti-windup (that is, using $\\dot{z} = x_1 + k_{\\mathrm{aw}}(u-v)$). Denote the estimated radii by $r^\\star_{\\mathrm{no\\_aw}}$ and $r^\\star_{\\mathrm{aw}}$, respectively, and quantify the expansion due to augmentation by the ratio\n$$\n\\rho \\triangleq \\frac{r^\\star_{\\mathrm{aw}}}{\\max(r^\\star_{\\mathrm{no\\_aw}}, \\delta)},\n$$\nwhere $\\delta \\gt 0$ is a tiny regularizer to avoid division by zero in degenerate cases.\n\nUse fixed-step explicit fourth-order Runge–Kutta (RK4) numerical integration with time step $\\Delta t$ to ensure determinism. Use the following numerical parameters for all tests:\n- Number of angles $N = 24$.\n- Time horizon $T = 12$.\n- Time step $\\Delta t = 0.01$.\n- Convergence radius $\\varepsilon = 0.02$.\n- Divergence guard: if $\\sqrt{x_1(t)^2 + x_2(t)^2}$ ever exceeds $R_{\\mathrm{div}} = 100$, declare failure for that initial condition.\n- Bisection iterations $N_{\\mathrm{bis}} = 12$.\n- Initial upper bracket $r_{\\mathrm{init}} = 0.1$ grown by a factor of $2$ up to a cap $r_{\\mathrm{cap}} = 5.0$ if the test continues to succeed.\n\nTest Suite. Your program must compute $(r^\\star_{\\mathrm{no\\_aw}}, r^\\star_{\\mathrm{aw}}, \\rho)$ for each of the following four parameter sets, in the given order:\n- Case $1$: $k_1 = 2.0$, $k_2 = 2.0$, $k_I = 3.0$, $u_{\\max} = 0.5$, $k_{\\mathrm{aw}} = 5.0$.\n- Case $2$: $k_1 = 2.0$, $k_2 = 2.0$, $k_I = 3.0$, $u_{\\max} = 0.2$, $k_{\\mathrm{aw}} = 5.0$.\n- Case $3$: $k_1 = 4.0$, $k_2 = 3.0$, $k_I = 2.0$, $u_{\\max} = 0.5$, $k_{\\mathrm{aw}} = 10.0$.\n- Case $4$: $k_1 = 3.0$, $k_2 = 2.5$, $k_I = 2.0$, $u_{\\max} = 0.3$, $k_{\\mathrm{aw}} = 8.0$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, append three floating-point numbers in order $(r^\\star_{\\mathrm{no\\_aw}}, r^\\star_{\\mathrm{aw}}, \\rho)$, yielding a flat list of length $12$. For example, the output must have the form\n$$\n[\\; r^\\star_{\\mathrm{no\\_aw},1},\\ r^\\star_{\\mathrm{aw},1},\\ \\rho_1,\\ r^\\star_{\\mathrm{no\\_aw},2},\\ r^\\star_{\\mathrm{aw},2},\\ \\rho_2,\\ r^\\star_{\\mathrm{no\\_aw},3},\\ r^\\star_{\\mathrm{aw},3},\\ \\rho_3,\\ r^\\star_{\\mathrm{no\\_aw},4},\\ r^\\star_{\\mathrm{aw},4},\\ \\rho_4 \\;].\n$$\nRound each printed floating-point number to $6$ decimal places.", "solution": "The problem requires the numerical estimation of the region of attraction for a double integrator plant under saturated state-feedback control with integral action. We will perform this analysis for two cases: with and without a back-calculation anti-windup scheme. The objective is to quantify the performance improvement afforded by the anti-windup augmentation.\n\nThe closed-loop system dynamics are described by a set of three first-order nonlinear ordinary differential equations. Let the state vector be $\\mathbf{y}(t) = [x_1(t), x_2(t), z(t)]^T$, where $x_1$ is position, $x_2$ is velocity, and $z$ is the integrator state. The state-space representation is $\\dot{\\mathbf{y}} = f(\\mathbf{y})$. The components of the vector field $f$ are given by:\n$$\n\\dot{x}_1 = x_2\n$$\n$$\n\\dot{x}_2 = u\n$$\n$$\n\\dot{z} = x_1 + k_{\\mathrm{aw}}(u - v)\n$$\nThe commanded control signal, $v$, is a linear function of the state:\n$$\nv = -k_1 x_1 - k_2 x_2 - k_I z\n$$\nThe actual control input to the plant, $u$, is the commanded signal $v$ subjected to actuator saturation with limit $u_{\\max}$:\n$$\nu = \\mathrm{sat}(v; u_{\\max}) = \\max(-u_{\\max}, \\min(v, u_{\\max}))\n$$\nThe system without anti-windup is a special case of these dynamics where the anti-windup gain $k_{\\mathrm{aw}}$ is set to $0$.\n\nAnalytical determination of the region of attraction (RoA) for such a nonlinear, saturated system is generally intractable. Therefore, we resort to a structured numerical procedure to compute a certified inner estimate of the RoA. The specified estimate is the largest Euclidean ball in the $(x_1, x_2)$-plane, centered at the origin, from which all trajectories converge to the origin. We denote the radius of this ball by $r^\\star$. The formal definition is:\n$$\nr^\\star \\triangleq \\sup\\{ r \\ge 0 \\; | \\; \\text{for all } \\theta \\in [0, 2\\pi),\\ \\|(x_1(0), x_2(0))\\|_2=r,\\ z(0)=0 \\Rightarrow \\lim_{t\\to\\infty} \\|(x_1(t), x_2(t))\\|_2 = 0 \\}\n$$\nThe initial integrator state is fixed at $z(0) = 0$.\n\nThe computational methodology to estimate $r^\\star$ follows a systematic, two-stage process: bracketing followed by bisection.\n\nFirst, we define a test procedure, `check_radius(r)`, which determines if a given candidate radius $r$ is certified. This is accomplished by discretizing the circle of radius $r$ in the $(x_1, x_2)$-plane into $N=24$ initial points, $(x_1(0), x_2(0)) = (r\\cos(\\theta_j), r\\sin(\\theta_j))$ for $\\theta_j = 2\\pi j/N$, $j \\in \\{0, \\dots, N-1\\}$. For each initial condition, the system's trajectory is simulated for a time horizon of $T=12$. The simulation is performed using the explicit fourth-order Runge-Kutta (RK4) method with a fixed time step of $\\Delta t=0.01$ to ensure deterministic results. A trajectory is declared convergent if its projection onto the $(x_1, x_2)$-plane enters a ball of radius $\\varepsilon=0.02$ around the origin, i.e., $\\sqrt{x_1(t)^2 + x_2(t)^2} \\le \\varepsilon$ for some $t \\in [0, T]$. If a trajectory's norm exceeds a divergence guard of $R_{\\mathrm{div}}=100$, it is declared non-convergent. The radius $r$ is certified only if all $N$ trajectories from its circumference converge.\n\nSecond, we employ a search algorithm to find the supremum $r^\\star$.\n1.  **Bracketing**: We seek an interval $[r_{\\text{low}}, r_{\\text{high}}]$ such that `check_radius`($r_{\\text{low}}$) succeeds and `check_radius`($r_{\\text{high}}$) fails. We begin with $r_{\\text{high}} = r_{\\text{init}} = 0.1$ and a known success at $r=0$. If $r_{\\text{high}}$ is a success, we update $r_{\\text{low}}$ to this new value and geometrically increase $r_{\\text{high}}$ by a factor of $2$, repeating until a failure is detected or an upper cap of $r_{\\text{cap}}=5.0$ is reached. If the test still succeeds at $r_{\\text{cap}}$, we take $r^\\star = r_{\\text{cap}}$.\n2.  **Bisection**: Once a valid bracket $[r_{\\text{low}}, r_{\\text{high}}]$ is found, we perform $N_{\\mathrm{bis}}=12$ iterations of the bisection method to refine the estimate of $r^\\star$. In each iteration, we test the midpoint $r_{\\text{mid}} = (r_{\\text{low}} + r_{\\text{high}})/2$. If $r_{\\text{mid}}$ is certified, we update $r_{\\text{low}} = r_{\\text{mid}}$; otherwise, we update $r_{\\text{high}} = r_{\\text{mid}}$. The final result is the terminal value of $r_{\\text{low}}$.\n\nThis entire procedure is executed for each parameter set, once with $k_{\\mathrm{aw}}=0$ to find $r^\\star_{\\mathrm{no\\_aw}}$ and once with the given $k_{\\mathrm{aw}}>0$ to find $r^\\star_{\\mathrm{aw}}$. The relative improvement is measured by the ratio $\\rho = r^\\star_{\\mathrm{aw}} / \\max(r^\\star_{\\mathrm{no\\_aw}}, \\delta)$, where $\\delta=10^{-9}$ is a small regularizer. The implementation adheres strictly to all specified numerical parameters.", "answer": "```python\nimport numpy as np\nimport math\n\n# Global numerical parameters\nN_ANGLES = 24\nTIME_HORIZON = 12.0\nDT = 0.01\nCONVERGENCE_RADIUS = 0.02\nDIVERGENCE_GUARD = 100.0\nN_BISECTION = 12\nR_INIT = 0.1\nR_CAP = 5.0\nDELTA_REG = 1e-9\n\ndef system_dynamics(state, params, use_aw):\n    \"\"\"\n    Computes the time derivative of the state vector.\n    state: [x1, x2, z]\n    params: dictionary of controller and plant parameters\n    use_aw: boolean to enable/disable anti-windup\n    \"\"\"\n    x1, x2, z = state\n    k1, k2, kI, u_max, k_aw = params['k1'], params['k2'], params['kI'], params['u_max'], params['k_aw']\n\n    # Commanded control\n    v = -k1 * x1 - k2 * x2 - kI * z\n\n    # Saturated control\n    u = np.clip(v, -u_max, u_max)\n\n    # State derivatives\n    dx1_dt = x2\n    dx2_dt = u\n    \n    if use_aw:\n        dz_dt = x1 + k_aw * (u - v)\n    else:\n        dz_dt = x1\n        \n    return np.array([dx1_dt, dx2_dt, dz_dt])\n\ndef rk4_step(func, state, t, dt, params, use_aw):\n    \"\"\"Performs a single RK4 step.\"\"\"\n    k1 = func(state, params, use_aw)\n    k2 = func(state + dt / 2.0 * k1, params, use_aw)\n    k3 = func(state + dt / 2.0 * k2, params, use_aw)\n    k4 = func(state + dt * k3, params, use_aw)\n    return state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef simulate_trajectory(x1_0, x2_0, params, use_aw):\n    \"\"\"\n    Simulates a single trajectory to check for convergence.\n    Returns True if converges, False otherwise.\n    \"\"\"\n    state = np.array([x1_0, x2_0, 0.0])\n    num_steps = int(TIME_HORIZON / DT)\n\n    for i in range(num_steps):\n        t = i * DT\n        state = rk4_step(system_dynamics, state, t, DT, params, use_aw)\n        \n        # Check for convergence\n        if math.sqrt(state[0]**2 + state[1]**2) <= CONVERGENCE_RADIUS:\n            return True\n            \n        # Check for divergence\n        if math.sqrt(state[0]**2 + state[1]**2) > DIVERGENCE_GUARD:\n            return False\n\n    return False\n\ndef check_radius(r, params, use_aw):\n    \"\"\"\n    Tests if all initial conditions on a circle of radius r converge.\n    Returns True if all converge, False otherwise.\n    \"\"\"\n    if r == 0.0:\n        return True\n    \n    angles = np.linspace(0, 2 * np.pi, N_ANGLES, endpoint=False)\n    for theta in angles:\n        x1_0 = r * math.cos(theta)\n        x2_0 = r * math.sin(theta)\n        \n        if not simulate_trajectory(x1_0, x2_0, params, use_aw):\n            return False\n            \n    return True\n\ndef find_r_star(params, use_aw):\n    \"\"\"\n    Finds the estimated radius of the region of attraction r_star.\n    \"\"\"\n    # Phase 1: Bracket finding\n    r_low = 0.0\n    r_high = R_INIT\n    \n    while True:\n        is_success = check_radius(r_high, params, use_aw)\n        if is_success:\n            r_low = r_high\n            if r_high == R_CAP:\n                return R_CAP  # Succeeded up to the cap\n            r_high = min(r_high * 2, R_CAP)\n        else:\n            break  # Found bracket [r_low, r_high] where low succeeds and high fails\n            \n    # Phase 2: Bisection search\n    for _ in range(N_BISECTION):\n        r_mid = (r_low + r_high) / 2.0\n        if check_radius(r_mid, params, use_aw):\n            r_low = r_mid\n        else:\n            r_high = r_mid\n            \n    return r_low\n\ndef solve():\n    test_cases = [\n        {'k1': 2.0, 'k2': 2.0, 'kI': 3.0, 'u_max': 0.5, 'k_aw': 5.0},\n        {'k1': 2.0, 'k2': 2.0, 'kI': 3.0, 'u_max': 0.2, 'k_aw': 5.0},\n        {'k1': 4.0, 'k2': 3.0, 'kI': 2.0, 'u_max': 0.5, 'k_aw': 10.0},\n        {'k1': 3.0, 'k2': 2.5, 'kI': 2.0, 'u_max': 0.3, 'k_aw': 8.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        r_star_no_aw = find_r_star(params, use_aw=False)\n        r_star_aw = find_r_star(params, use_aw=True)\n        \n        rho = r_star_aw / max(r_star_no_aw, DELTA_REG)\n        \n        all_results.extend([r_star_no_aw, r_star_aw, rho])\n\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2690066"}, {"introduction": "Actuator saturation can have far more severe consequences than performance degradation, particularly in systems with non-minimum phase (NMP) characteristics. Attempting to cancel NMP zeros with a feedforward controller—a common technique for improving tracking—can lead to internal instability when the actuator saturates. This exercise will first guide you to demonstrate this dangerous \"windup\" phenomenon and then challenge you to select and justify an effective anti-windup strategy that uses switching logic to ensure stability while preserving performance [@problem_id:2690016].", "problem": "Consider a Single-Input Single-Output (SISO) Linear Time-Invariant (LTI) plant with transfer function $P(s) = \\dfrac{s - z}{s + p}$, where $z > 0$ and $p > 0$. The actuator is subject to hard saturation, modeled as $u(t) = \\operatorname{sat}(v(t))$, where $\\operatorname{sat}(\\cdot)$ is the symmetric saturation with bounds $\\pm u_{\\max}$, i.e., $\\operatorname{sat}(v) = \\max\\{\\min\\{v, u_{\\max}\\}, -u_{\\max}\\}$. A feedforward prefilter $F(s)$ is introduced to improve tracking. The nominal design inverts the plant, i.e., $F(s) = P(s)^{-1} = \\dfrac{s + p}{s - z}$, so that the nominal cascade $P(s) F(s) = 1$ yields exact tracking in the absence of saturation.\n\nPart I. Using only the definitions of transfer functions, step responses of first-order systems, and the basic fact that a right-half-plane zero of $P(s)$ becomes a right-half-plane pole of $F(s)$, show that even if the output $y(t)$ is bounded by the plant dynamics and saturation, the internal signal $v(t)$ generated by the unstable inverse $F(s)$ can become unbounded after saturation engages. Concretely, let $r(t) = r_{0} \\mathbf{1}_{\\{t \\ge 0\\}}$ be a step reference with $r_{0} \\ne 0$, and realize $F(s)$ in the decomposition\n$$\nF(s) \\;=\\; 1 \\;+\\; \\frac{p + z}{s - z}.\n$$\nAssume the initial condition of the inverse’s internal state is $x_{F}(0)=0$, and recall that the time response of $\\dfrac{1}{s - z}$ to a unit step contains a term proportional to $e^{z t}$. Derive $v(t)$ explicitly and use the saturation model to argue that:\n- there exists a finite time $t^{\\star}$ at which $\\operatorname{sat}(v(t)) \\ne v(t)$ whenever $r_{0}$ has the same sign as $(p+z)$ and $u_{\\max}$ is finite,\n- once saturation is active on some interval $[t^{\\star}, \\infty)$, the internal signal $v(t)$ generated by $F(s)$ exhibits an $e^{z t}$ component that is not canceled by the plant input-output map and therefore grows without bound, even though $y(t)$ remains bounded by the stable plant driven by a bounded input.\n\nExplain why this phenomenon is an instance of “windup” driven by the unstable zero dynamics inversion and why it cannot be removed by any stabilizing feedback around $P(s)$ that does not also modify the path carrying the unstable inverse.\n\nPart II. Consider the following anti-windup design candidates for the feedforward path. The objective is twofold: ($i$) guarantee bounded internal signals for any bounded reference when saturation occurs, and ($ii$) preserve exact inversion $P(s) F(s) = 1$ whenever the actuator is not saturated. Select the option that satisfies both objectives and justify your choice based on first principles.\n\nA. Switch the feedforward between the exact inverse and a stable approximate inverse with bumpless transfer and hysteresis: define\n$$\nF_{\\text{exact}}(s) = \\frac{s + p}{s - z}, \\qquad F_{\\text{stab}}(s) = \\frac{s + p}{s + z} = 1 + \\frac{p - z}{s + z}.\n$$\nUse the logic\n$$\nF_{\\sigma}(s) \\;=\\; \\begin{cases}\nF_{\\text{exact}}(s), & \\text{if } |v(t)| \\le u_{\\max} - \\delta, \\\\\nF_{\\text{stab}}(s), & \\text{if } |v(t)| \\ge u_{\\max},\n\\end{cases}\n$$\nwith a hysteresis band $\\delta \\in (0, u_{\\max})$ and a state reset at switching instants $t_{s}$ chosen so that $v(t)$ is continuous, i.e., set the state of the newly engaged realization to match the current output $v(t_{s}^{-})$. Argue that in the saturated mode the internal pole is at $-z < 0$, ensuring bounded internal signals, and that in the unsaturated mode the exact inversion is recovered.\n\nB. Keep $F(s) = \\dfrac{s + p}{s - z}$ fixed, but wrap the plant $P(s)$ in a high-gain static feedback stabilizer $u(t) = \\operatorname{sat}(v(t)) - k\\,y(t)$ with $k \\gg 1$. Claim that high gain will dominate saturation nonlinearities and prevent windup of the internal state of $F(s)$.\n\nC. Pre-scale the reference by a saturating prefilter $r_{\\text{sat}}(t) = \\operatorname{sat}_{r}(r(t))$ so that $|r_{\\text{sat}}(t)| \\le r_{\\max}$ with $r_{\\max}$ chosen to avoid actuator saturation at steady state, and keep $F(s) = \\dfrac{s + p}{s - z}$. Argue that bounding the reference suffices to prevent windup in the feedforward inverse.\n\nD. Place a strictly proper low-pass filter $L(s) = \\dfrac{\\omega_{c}}{s + \\omega_{c}}$ after $F(s)$ to limit the high-frequency content of $v(t)$, i.e., use $v(t)$ generated by $L(s) F(s) r(t)$, without modifying the unstable pole at $s = z$ of $F(s)$. Claim that bandwidth limiting is enough to prevent windup in the presence of saturation.\n\nSelect the single best option that meets objectives ($i$) and ($ii$).", "solution": "**Part I: Demonstration of Windup**\n\nThe system consists of a stable plant with a right-half-plane (RHP) zero, $P(s) = \\dfrac{s - z}{s + p}$, where $z > 0$ and $p > 0$. To achieve perfect tracking, a feedforward prefilter $F(s)$ is designed as the plant inverse, $F(s) = P(s)^{-1} = \\dfrac{s + p}{s - z}$. This prefilter is unstable due to the pole at $s = z$.\n\nWe are asked to analyze the behavior of the prefilter's output, $v(t)$, for a step reference input $r(t) = r_{0} \\mathbf{1}_{\\{t \\ge 0\\}}$, where $r_{0} \\ne 0$. The Laplace transform of the reference is $R(s) = \\dfrac{r_{0}}{s}$. The output of the prefilter, before any saturation is considered, is given by $V(s) = F(s)R(s)$.\n\nUsing the provided decomposition $F(s) = 1 + \\dfrac{p + z}{s - z}$, we have:\n$$V(s) = \\left(1 + \\frac{p + z}{s - z}\\right) \\frac{r_{0}}{s} = \\frac{r_{0}}{s} + \\frac{r_{0}(p + z)}{s(s - z)}$$\nWe perform a partial fraction expansion on the second term:\n$$\\frac{1}{s(s - z)} = \\frac{A}{s} + \\frac{B}{s - z}$$\nwhere $A = \\left.\\frac{1}{s - z}\\right|_{s=0} = -\\frac{1}{z}$ and $B = \\left.\\frac{1}{s}\\right|_{s=z} = \\frac{1}{z}$.\nThus,\n$$V(s) = \\frac{r_{0}}{s} + r_{0}(p + z) \\left(-\\frac{1}{zs} + \\frac{1}{z(s - z)}\\right) = \\left(r_{0} - \\frac{r_{0}(p + z)}{z}\\right)\\frac{1}{s} + \\frac{r_{0}(p + z)}{z}\\frac{1}{s - z}$$\n$$V(s) = r_{0}\\left(\\frac{z - p - z}{z}\\right)\\frac{1}{s} + \\frac{r_{0}(p + z)}{z}\\frac{1}{s - z} = -\\frac{r_{0}p}{z}\\frac{1}{s} + \\frac{r_{0}(p + z)}{z}\\frac{1}{s - z}$$\nTaking the inverse Laplace transform, we obtain the time-domain signal $v(t)$ for $t \\ge 0$, assuming the system starts from rest ($x_{F}(0)=0$):\n$$v(t) = -\\frac{r_{0}p}{z} + \\frac{r_{0}(p + z)}{z} e^{zt} = \\frac{r_{0}}{z} \\left( (p+z)e^{zt} - p \\right)$$\n\n1.  **Existence of saturation time $t^{\\star}$**: We are given $p > 0$ and $z > 0$, which implies $p+z > 0$. We assume $r_{0}$ has the same sign as $p+z$, so we take $r_{0} > 0$. The expression for $v(t)$ shows an exponentially growing term $e^{zt}$ because $z > 0$. At $t=0$, $v(0) = \\frac{r_{0}}{z}(p+z-p) = r_{0}$. Since $v(t)$ grows monotonically without bound, for any finite saturation limit $u_{\\max} > 0$, $v(t)$ will eventually exceed $u_{\\max}$. If $r_{0} \\ge u_{\\max}$, saturation is immediate at $t^{\\star}=0$. If $r_{0} < u_{\\max}$, the time to saturation $t^{\\star}$ is found by solving $v(t^{\\star}) = u_{\\max}$:\n    $$\\frac{r_{0}}{z} \\left( (p+z)e^{zt^{\\star}} - p \\right) = u_{\\max} \\implies e^{zt^{\\star}} = \\frac{1}{p+z}\\left(\\frac{zu_{\\max}}{r_{0}} + p\\right)$$\n    Since $u_{\\max} > r_{0}$, we have $\\frac{zu_{\\max}}{r_{0}} + p > z+p$, so the argument of the logarithm is greater than $1$, yielding a finite positive solution for $t^{\\star}$. Thus, saturation at a finite time $t^{\\star}$ is guaranteed.\n\n2.  **Unboundedness of $v(t)$ post-saturation**: For $t \\ge t^{\\star}$, the actuator saturates. Assuming $r_{0} > 0$, the plant input becomes constant: $u(t) = u_{\\max}$. The plant transfer function $P(s)$ is stable (pole at $s=-p<0$). A stable LTI system driven by a bounded input (here, a constant $u_{\\max}$) produces a bounded output. The output $y(t)$ will converge to the steady-state value $y_{ss} = P(0)u_{\\max} = -\\frac{z}{p}u_{\\max}$. Thus, $y(t)$ remains bounded.\n\n    However, the signal $v(t)$ is generated by the prefilter $F(s)$ acting on $r(t)$. This process is independent of the plant's saturation and output. The expression $v(t) = \\frac{r_{0}}{z} \\left( (p+z)e^{zt} - p \\right)$ remains valid for all $t \\ge 0$. Due to the $e^{zt}$ term with $z>0$, $v(t) \\to \\infty$ as $t \\to \\infty$.\n\n    This phenomenon is called \"windup\". The internal state of the controller (here, the prefilter $F(s)$) grows without bound because its unstable dynamics are no longer \"masked\" by the plant's zero once the signal path is broken by saturation. The difference between the commanded signal $v(t)$ and the actual plant input $u(t)$ grows, indicating a loss of control.\n\n3.  **Insufficiency of standard feedback**: Any standard feedback loop, for example one creating a command $v_{cmd} = v_{ff} + v_{fb} = F(s)r - C(s)y$, does not inherently solve this problem. As long as the feedforward component $v_{ff} = F(s)r$ is generated by the unstable inverse and is part of the signal being saturated, its internal state will wind up when saturation occurs. The feedback can stabilize the plant, but it cannot reach \"inside\" the separate, open-loop feedforward block $F(s)$ to stabilize its internal state. To prevent this windup, the anti-windup scheme must explicitly modify the dynamics of $F(s)$ or provide a corrective signal to its state, which is precisely what \"anti-windup\" techniques are designed to do.\n\n**Part II: Evaluation of Anti-Windup Candidates**\n\nThe objectives are (i) bounded internal signals during saturation and (ii) exact inversion when not saturated.\n\n**A. Switching between exact and stable approximate inverse:**\nThis strategy proposes using $F_{\\text{exact}}(s) = \\frac{s+p}{s-z}$ when $|v(t)|$ is safely below $u_{\\max}$, and switching to a stable approximation $F_{\\text{stab}}(s) = \\frac{s+p}{s+z}$ when saturation is active or imminent.\n-   **Objective (ii) - Unsaturated mode:** When $|v(t)| \\le u_{\\max} - \\delta$, the filter is $F_{\\text{exact}}(s)$. The cascade with the plant is $P(s)F_{\\text{exact}}(s) = \\frac{s-z}{s+p}\\frac{s+p}{s-z} = 1$. This provides exact inversion. Objective (ii) is met.\n-   **Objective (i) - Saturated mode:** When $|v(t)| \\ge u_{\\max}$, the filter switches to $F_{\\text{stab}}(s) = \\frac{s+p}{s+z}$. This transfer function has a pole at $s=-z$ (since $z>0$, this is a stable pole) and is stable. For any bounded reference $r(t)$, the output of this stable filter and all its internal states will remain bounded. The bumpless transfer mechanism ensures smooth transitions. Thus, internal signals are guaranteed to be bounded. Objective (i) is met.\nThis candidate satisfies both objectives.\n**Verdict: Correct.**\n\n**B. High-gain feedback around the plant:**\nThis option proposes adding feedback $u(t) = \\operatorname{sat}(v(t)) - k y(t)$, while keeping the prefilter $F(s) = \\frac{s+p}{s-z}$ unchanged, where $v(t)$ is generated from $r(t)$ by $F(s)$.\nThe signal $v(t)$ is synthesized independently from the feedback loop. As shown in Part I, $v(t)$ contains a term $e^{zt}$ and grows unbounded. The proposed feedback acts on the plant input $u(t)$, downstream from the generation of $v(t)$ and the saturation block. It has no mechanism to influence the internal state of the filter $F(s)$. The internal state of $F(s)$ will therefore wind up regardless of the feedback action. The claim that this prevents windup of the internal state of $F(s)$ is false.\n-   **Objective (i) - Boundedness:** Fails, as the state of $F(s)$ is not stabilized.\n-   **Objective (ii) - Exact Inversion:** In the unsaturated case, $u(t) = v(t) - k y(t)$. The closed-loop response from $v$ to $y$ is $Y(s) = \\frac{P(s)}{1+kP(s)}V(s)$. The overall response from $r$ to $y$ is $Y(s) = \\frac{P(s)F(s)}{1+kP(s)}R(s) = \\frac{1}{1+kP(s)}R(s)$, which is not $R(s)$. Exact inversion is not achieved.\nThis candidate fails both objectives.\n**Verdict: Incorrect.**\n\n**C. Pre-scaling the reference:**\nThis option suggests limiting the amplitude of the reference signal, $r_{\\text{sat}}(t)$, based on a steady-state analysis. The steady-state value of $v(t)$ for a step input $\\hat{r}_0$ is $v_{ss} = F(0)\\hat{r}_0 = \\frac{p}{-z}\\hat{r}_0$. Bounding $r(t)$ can keep $|v_{ss}| < u_{\\max}$. However, this ignores the transient behavior. The transient response of $v(t)$ is $v(t) = \\frac{\\hat{r}_0}{z} \\left( (p+z)e^{zt} - p \\right)$. This signal still grows exponentially due to the unstable pole at $s=z$. It will inevitably exceed any finite saturation limit $u_{\\max}$ during the transient phase, triggering saturation and windup. Bounding the reference amplitude is not sufficient to prevent windup caused by unstable dynamics.\n-   **Objective (i) - Boundedness:** Fails, as the transient will be unbounded.\n**Verdict: Incorrect.**\n\n**D. Low-pass filtering the prefilter output:**\nThis proposes a new prefilter $F_{new}(s) = L(s)F(s) = \\frac{\\omega_c}{s+\\omega_c}\\frac{s+p}{s-z}$. This new filter still possesses the unstable pole at $s=z$ from $F(s)$. A cascade of a stable filter and an unstable filter is unstable. The output $v(t)$ of this filter for a bounded input $r(t)$ will still be unbounded due to the $e^{zt}$ mode. Bandwidth limiting alone does not remove the instability.\n-   **Objective (i) - Boundedness:** Fails, as the filter remains unstable.\nFurthermore, the nonsaturated cascade response is $P(s)F_{new}(s) = P(s)L(s)F(s) = 1 \\cdot L(s) = \\frac{\\omega_c}{s+\\omega_c} \\ne 1$.\n-   **Objective (ii) - Exact Inversion:** Fails, as perfect tracking is lost.\nThis candidate fails both objectives.\n**Verdict: Incorrect.**\n\nBased on the analysis, only Option A provides a correct and complete solution that meets both specified objectives. It correctly diagnoses the source of the problem—the unstable pole of the inverse—and remedies it by switching to a stable filter during saturation, while preserving the desired performance in the linear regime.", "answer": "$$\\boxed{A}$$", "id": "2690016"}]}