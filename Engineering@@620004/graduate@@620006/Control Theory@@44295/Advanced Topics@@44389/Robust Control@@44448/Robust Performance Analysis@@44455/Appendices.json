{"hands_on_practices": [{"introduction": "The Small-Gain Theorem provides a powerful and elegant condition for guaranteeing the stability of systems with uncertainty. To truly master this concept, it is essential to move beyond the abstract statement and understand its application in practice. This exercise ([@problem_id:2741697]) bridges this gap by guiding you from the fundamental definition of the $\\mathcal{H}_\\infty$ norm to a concrete, frequency-by-frequency test for robust performance, culminating in a direct calculation for a single-input, single-output (SISO) system.", "problem": "A linear time-invariant (LTI) feedback loop is modeled with an unstructured, norm-bounded uncertainty that is scaled by a frequency-dependent weighting function. Let the uncertainty weighting be the stable, proper transfer function $W_{\\Delta}(s)$ and let the closed-loop complementary input-output map seen by the uncertainty be the stable transfer function $M(s)$. The robust performance requirement under the small-gain paradigm is that the Hardy-space infinity norm ($\\mathcal{H}_\\infty$ norm) of the product $W_{\\Delta} M$ satisfies $\\|W_{\\Delta} M\\|_{\\infty} < 1$.\n\nStarting only from the induced $\\mathcal{L}_2$-to-$\\mathcal{L}_2$ norm definition of the $\\mathcal{H}_\\infty$ norm for stable LTI systems,\n$$\n\\|G\\|_{\\infty} \\triangleq \\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}\\big(G(\\mathrm{j}\\omega)\\big),\n$$\nwhere $\\bar{\\sigma}(\\cdot)$ denotes the maximum singular value, derive a frequency-by-frequency inequality in $\\omega$ that is necessary and sufficient for $\\|W_{\\Delta} M\\|_{\\infty}<1$. Specialize your derivation to the single-input single-output (SISO) case.\n\nThen, for the specific SISO case with\n$$\nW_{\\Delta}(s) = \\frac{s + 1}{s + 2}, \\qquad M(s) = \\frac{0.8}{s + 1},\n$$\ncompute the value of $\\|W_{\\Delta} M\\|_{\\infty}$ exactly. Your final answer must be a single real number written in exact form. Do not include units. Do not round; give the exact value.", "solution": "The problem as stated is well-posed, scientifically grounded in established principles of robust control theory, and contains sufficient information for a unique and meaningful solution. It is therefore deemed valid.\n\nThe task is to first derive a frequency-domain condition for robust performance and then apply it to a specific case. The robust performance criterion is given as $\\|W_{\\Delta} M\\|_{\\infty} < 1$, where the $\\mathcal{H}_{\\infty}$ norm is defined from the induced $\\mathcal{L}_{2}$-to-$\\mathcal{L}_{2}$ gain for a stable linear time-invariant (LTI) system $G(s)$ as\n$$\n\\|G\\|_{\\infty} \\triangleq \\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}\\big(G(\\mathrm{j}\\omega)\\big)\n$$\nHere, $\\bar{\\sigma}(\\cdot)$ denotes the maximum singular value of a matrix, and $G(\\mathrm{j}\\omega)$ is the frequency response of the system $G(s)$ evaluated at $s = \\mathrm{j}\\omega$.\n\nLet $G(s) = W_{\\Delta}(s) M(s)$. The condition is $\\|G\\|_{\\infty} < 1$. Substituting the definition of the norm, we have:\n$$\n\\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}\\big(W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)\\big) < 1\n$$\nThe supremum of a set of non-negative real numbers, in this case $\\{\\bar{\\sigma}\\big(W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)\\big) \\mid \\omega \\in \\mathbb{R}\\}$, is less than $1$ if and only if every element in the set is less than $1$. This provides the necessary and sufficient frequency-by-frequency condition for the general multi-input multi-output (MIMO) case:\n$$\n\\bar{\\sigma}\\big(W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)\\big) < 1 \\quad \\text{for all } \\omega \\in \\mathbb{R}\n$$\n\nNext, we specialize this result to the single-input single-output (SISO) case. For a SISO system, the transfer function is a scalar function. When evaluated at a particular frequency $s = \\mathrm{j}\\omega$, the frequency response $G(\\mathrm{j}\\omega)$ is a complex number. A complex number can be viewed as a $1 \\times 1$ matrix. The maximum singular value of a $1 \\times 1$ matrix $[c]$ is simply the magnitude of the complex number $c$. That is, $\\bar{\\sigma}([c]) = |c|$.\nTherefore, for a SISO system $G(s)$, the maximum singular value of its frequency response is the magnitude of the frequency response:\n$$\n\\bar{\\sigma}\\big(G(\\mathrm{j}\\omega)\\big) = |G(\\mathrm{j}\\omega)|\n$$\nThe $\\mathcal{H}_{\\infty}$ norm for a stable SISO system simplifies to the peak magnitude of its frequency response:\n$$\n\\|G\\|_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} |G(\\mathrm{j}\\omega)|\n$$\nApplying this to the robust performance condition $\\|W_{\\Delta} M\\|_{\\infty} < 1$, we get:\n$$\n\\sup_{\\omega \\in \\mathbb{R}} |W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)| < 1\n$$\nUsing the property of complex number magnitudes that $|z_1 z_2| = |z_1| |z_2|$, this is equivalent to:\n$$\n\\sup_{\\omega \\in \\mathbb{R}} \\left( |W_{\\Delta}(\\mathrm{j}\\omega)| \\cdot |M(\\mathrm{j}\\omega)| \\right) < 1\n$$\nThe corresponding necessary and sufficient frequency-by-frequency inequality for the SISO case is:\n$$\n|W_{\\Delta}(\\mathrm{j}\\omega)| \\cdot |M(\\mathrm{j}\\omega)| < 1 \\quad \\text{for all } \\omega \\in \\mathbb{R}\n$$\nThis completes the derivation part of the problem.\n\nFinally, we must compute the exact value of $\\|W_{\\Delta} M\\|_{\\infty}$ for the specific SISO transfer functions:\n$$\nW_{\\Delta}(s) = \\frac{s + 1}{s + 2}, \\qquad M(s) = \\frac{0.8}{s + 1}\n$$\nFirst, we form the product transfer function $G(s) = W_{\\Delta}(s) M(s)$:\n$$\nG(s) = \\left(\\frac{s + 1}{s + 2}\\right) \\left(\\frac{0.8}{s + 1}\\right)\n$$\nA pole-zero cancellation occurs at $s = -1$. Since both original transfer functions are stable, this cancellation is permissible and the resulting transfer function accurately describes the overall system's input-output frequency response.\n$$\nG(s) = \\frac{0.8}{s + 2}\n$$\nThis system is stable, as its only pole is at $s = -2$ in the left-half of the complex plane. We now compute its $\\mathcal{H}_{\\infty}$ norm:\n$$\n\\|G\\|_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} |G(\\mathrm{j}\\omega)|\n$$\nWe evaluate the frequency response $G(\\mathrm{j}\\omega)$:\n$$\nG(\\mathrm{j}\\omega) = \\frac{0.8}{\\mathrm{j}\\omega + 2}\n$$\nThe magnitude of the frequency response is a function of $\\omega$:\n$$\n|G(\\mathrm{j}\\omega)| = \\left|\\frac{0.8}{2 + \\mathrm{j}\\omega}\\right| = \\frac{|0.8|}{|2 + \\mathrm{j}\\omega|} = \\frac{0.8}{\\sqrt{2^2 + \\omega^2}} = \\frac{0.8}{\\sqrt{4 + \\omega^2}}\n$$\nTo find the supremum of this expression for $\\omega \\in \\mathbb{R}$, we must find its maximum value. The numerator is a positive constant, $0.8$. The function's value is maximized when the denominator, $\\sqrt{4 + \\omega^2}$, is minimized. The term $\\omega^2$ is always non-negative, i.e., $\\omega^2 \\ge 0$. The minimum value of $4 + \\omega^2$ occurs when $\\omega^2$ is at its minimum, which is $0$. This happens at the frequency $\\omega = 0$.\nThe minimum value of the denominator is therefore $\\sqrt{4 + 0^2} = \\sqrt{4} = 2$.\nThe maximum value of the magnitude, which is the $\\mathcal{H}_{\\infty}$ norm, is thus:\n$$\n\\|W_{\\Delta} M\\|_{\\infty} = |G(\\mathrm{j}0)| = \\frac{0.8}{\\sqrt{4 + 0^2}} = \\frac{0.8}{2} = 0.4\n$$\nThis is the exact value of the norm.", "answer": "$$\n\\boxed{0.4}\n$$", "id": "2741697"}, {"introduction": "While the standard Small-Gain Theorem is a cornerstone of robust control, its treatment of all uncertainties as a single, unstructured block can lead to overly conservative conclusions. The structured singular value ($\\mu$) offers a more refined tool by explicitly considering the known structure of the uncertainty. This practice ([@problem_id:2741714]) allows you to empirically explore this crucial distinction, demonstrating through a computational exercise how $\\mu$-analysis can certify robustness in cases where the simpler small-gain test would fail.", "problem": "Consider a fixed-frequency robust performance/stability check for a two-input, two-output Linear Time-Invariant (LTI) interconnection described by a complex matrix $M \\in \\mathbb{C}^{2 \\times 2}$ and an uncertainty block $\\Delta = \\mathrm{diag}(\\delta_1,\\delta_2)$, where each $\\delta_i \\in \\mathbb{C}$ is a scalar satisfying $\\lvert \\delta_i \\rvert \\le 1$. Two classical analysis tests are as follows.\n\n1. Unstructured small-gain test: This test replaces the structured uncertainty by a single full block with spectral norm bound and certifies robustness if the induced 2-norm (largest singular value) satisfies $\\lVert M \\rVert_2 < 1$.\n2. Structured singular value (SSV), or $\\mu$) test: For the diagonal structure $\\Delta = \\mathrm{diag}(\\delta_1,\\delta_2)$ with scalar complex blocks, the structured singular value at $M$ is defined by\n$$\n\\mu_{\\Delta}(M) \\triangleq \\frac{1}{\\min \\left\\{ \\lVert \\Delta \\rVert_2 \\; \\middle| \\; \\Delta=\\mathrm{diag}(\\delta_1,\\delta_2),\\ \\lvert \\delta_i \\rvert \\le \\lVert \\Delta \\rVert_2,\\ \\det(I - M \\Delta)=0 \\right\\}}.\n$$\nRobust performance/stability is certified if $\\mu_{\\Delta}(M) < 1$.\n\nStarting from the above definitions only (that is, do not assume any prepackaged $\\mu$ formulas), you are to design a program that, given a set of matrices $M$, computes:\n- The unstructured small-gain decision: whether $\\lVert M \\rVert_2 < 1$.\n- The structured decision: whether $\\mu_{\\Delta}(M) < 1$ for the diagonal scalar uncertainty.\n\nYour program must proceed by first principles and logic that can be implemented in finite-precision arithmetic. In particular, for the structured decision, reason from the singularity condition $\\det(I - M \\Delta)=0$ and the scalar magnitude bounds on $\\delta_i$. You may use any equivalent computational characterization derived from these definitions, provided it is clearly obtained from the singularity condition and the structure $\\Delta=\\mathrm{diag}(\\delta_1,\\delta_2)$.\n\nTest Suite:\nUse the following four fixed-frequency test matrices, each of size $2 \\times 2$:\n- Test 1 (happy path): $M_1 = \\begin{bmatrix} 0 & 0.5 \\\\ 0.5 & 0 \\end{bmatrix}$.\n- Test 2 (conservatism demonstration): $M_2 = \\begin{bmatrix} 0 & 1.2 \\\\ 0.8 & 0 \\end{bmatrix}$.\n- Test 3 (boundary case): $M_3 = \\begin{bmatrix} 0 & 1.25 \\\\ 0.8 & 0 \\end{bmatrix}$.\n- Test 4 (strong failure): $M_4 = \\begin{bmatrix} 0 & 1.5 \\\\ 1.2 & 0 \\end{bmatrix}$.\n\nRequirements:\n- For each test matrix $M_k$, return a pair of booleans encoded as integers $\\{0,1\\}$ in the order $[\\text{small\\_gain\\_passes}, \\text{structured\\_}\\mu\\text{\\_passes}]$, where a test \"passes\" if and only if the corresponding strict inequality is satisfied, namely $\\lVert M \\rVert_2 < 1$ for small gain and $\\mu_{\\Delta}(M) < 1$ for the structured test.\n- Angle units, where applicable, must be in radians.\n- The final output must be a single line containing a list of the four pairs, in order, aggregated as a single Python-style list of lists, for example: \"[[a,b],[c,d],[e,f],[g,h]]\".\n\nYour program must be complete and runnable as specified below, and must produce exactly one output line in the format described above.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of robust control theory, specifically small-gain and structured singular value ($\\mu$) analysis. The problem is well-posed, providing all necessary definitions, data, and constraints to arrive at a unique, verifiable solution. The language is objective and mathematically precise.\n\nThe task is to perform two distinct robustness checks for a given set of matrices $M \\in \\mathbb{C}^{2 \\times 2}$ against a structured uncertainty block $\\Delta = \\mathrm{diag}(\\delta_1, \\delta_2)$. The checks are the unstructured small-gain test and the structured singular value ($\\mu$) test.\n\nFirst, we analyze the unstructured small-gain test. This test provides a sufficient condition for robust stability. The condition is that the induced 2-norm of the matrix $M$, which is its largest singular value $\\sigma_{\\max}(M)$, must be strictly less than $1$.\n$$\n\\lVert M \\rVert_2 = \\sigma_{\\max}(M) < 1\n$$\nFor each test matrix $M_k$, we will compute its singular values. The singular values of $M_k$ are the square roots of the eigenvalues of the positive semidefinite matrix $M_k^* M_k$ (or $M_k^T M_k$ since the given matrices are real). The test passes, and we assign a value of 1, if the largest singular value is less than $1$. Otherwise, the test fails, and we assign a value of $0$.\n\nSecond, we analyze the structured singular value ($\\mu$) test. This provides a necessary and sufficient condition for robust stability for the given uncertainty structure. The condition is $\\mu_{\\Delta}(M) < 1$. We must derive a computational procedure from first principles as requested. The condition $\\mu_{\\Delta}(M) < 1$ is equivalent to stating that the matrix $I - M\\Delta$ is non-singular for all perturbations $\\Delta = \\mathrm{diag}(\\delta_1, \\delta_2)$ such that $\\lVert \\Delta \\rVert_2 \\le 1$. Since for this diagonal structure $\\lVert \\Delta \\rVert_2 = \\max (|\\delta_1|, |\\delta_2|)$, this means we must have $\\det(I - M\\Delta) \\neq 0$ for all $\\delta_1, \\delta_2 \\in \\mathbb{C}$ with $|\\delta_1| \\le 1$ and $|\\delta_2| \\le 1$.\n\nWe analyze the singularity condition $\\det(I - M\\Delta) = 0$. Let $M = \\begin{bmatrix} m_{11} & m_{12} \\\\ m_{21} & m_{22} \\end{bmatrix}$.\n$$\n\\det(I - M\\Delta) = \\det \\left( \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} m_{11} & m_{12} \\\\ m_{21} & m_{22} \\end{bmatrix} \\begin{bmatrix} \\delta_1 & 0 \\\\ 0 & \\delta_2 \\end{bmatrix} \\right) = \\det \\begin{bmatrix} 1 - m_{11}\\delta_1 & -m_{12}\\delta_2 \\\\ -m_{21}\\delta_1 & 1 - m_{22}\\delta_2 \\end{bmatrix}\n$$\nThe determinant is $(1 - m_{11}\\delta_1)(1 - m_{22}\\delta_2) - m_{12}m_{21}\\delta_1\\delta_2 = 0$. This expands to:\n$$\n1 - m_{11}\\delta_1 - m_{22}\\delta_2 + (m_{11}m_{22} - m_{12}m_{21})\\delta_1\\delta_2 = 0\n$$\n$$\n1 - m_{11}\\delta_1 - m_{22}\\delta_2 + \\det(M) \\delta_1\\delta_2 = 0\n$$\nAll test matrices provided have the form $M_k = \\begin{bmatrix} 0 & m_{12}^{(k)} \\\\ m_{21}^{(k)} & 0 \\end{bmatrix}$. For this structure, $m_{11} = 0$, $m_{22} = 0$, and $\\det(M) = -m_{12}m_{21}$. The characteristic equation simplifies significantly:\n$$\n1 - m_{12}m_{21}\\delta_1\\delta_2 = 0 \\quad \\implies \\quad \\delta_1\\delta_2 = \\frac{1}{m_{12}m_{21}}\n$$\nThe value of $\\mu_{\\Delta}(M)$ is given by its definition:\n$$\n\\mu_{\\Delta}(M) = \\frac{1}{\\min \\left\\{ \\lVert \\Delta \\rVert_2 \\; \\middle| \\; \\det(I - M \\Delta)=0 \\right\\}}\n$$\nUsing our simplified condition and $\\lVert \\Delta \\rVert_2 = \\max(|\\delta_1|, |\\delta_2|)$, we need to find the minimum of $\\max(|\\delta_1|, |\\delta_2|)$ subject to the constraint $\\delta_1\\delta_2 = 1/(m_{12}m_{21})$. Let $r_1 = |\\delta_1|$ and $r_2 = |\\delta_2|$. The constraint on the magnitudes becomes $r_1 r_2 = |1/(m_{12}m_{21})|$. We want to minimize $\\max(r_1, r_2)$ subject to $r_1 r_2 = C$, where $C$ is a positive constant. This minimum occurs when $r_1 = r_2 = \\sqrt{C}$.\nTherefore, the minimum value of $\\max(|\\delta_1|, |\\delta_2|)$ is $\\sqrt{|1/(m_{12}m_{21})|} = 1/\\sqrt{|m_{12}m_{21}|}$.\nThis is the value of $\\mu_{\\Delta}(M)^{-1}$.\n$$\n\\mu_{\\Delta}(M)^{-1} = \\frac{1}{\\sqrt{|m_{12}m_{21}|}} \\quad \\implies \\quad \\mu_{\\Delta}(M) = \\sqrt{|m_{12}m_{21}|}\n$$\nThe structured test condition $\\mu_{\\Delta}(M) < 1$ is thus equivalent to $\\sqrt{|m_{12}m_{21}|} < 1$, or simply $|m_{12}m_{21}| < 1$. The test passes if and only if this strict inequality holds.\n\nWe now apply these two tests to each matrix.\n\nTest 1: $M_1 = \\begin{bmatrix} 0 & 0.5 \\\\ 0.5 & 0 \\end{bmatrix}$.\n- Unstructured test: The singular values of $M_1$ are $0.5$ and $0.5$. The largest is $\\lVert M_1 \\rVert_2 = 0.5$. Since $0.5 < 1$, the test passes (result: 1).\n- Structured test: We compute $|m_{12}m_{21}| = |0.5 \\times 0.5| = 0.25$. Since $0.25 < 1$, the test passes (result: 1).\n- Resulting pair: (1, 1).\n\nTest 2: $M_2 = \\begin{bmatrix} 0 & 1.2 \\\\ 0.8 & 0 \\end{bmatrix}$.\n- Unstructured test: The singular values of $M_2$ are $1.2$ and $0.8$. The largest is $\\lVert M_2 \\rVert_2 = 1.2$. Since $1.2 \\not< 1$, the test fails (result: 0).\n- Structured test: We compute $|m_{12}m_{21}| = |1.2 \\times 0.8| = 0.96$. Since $0.96 < 1$, the test passes (result: 1).\n- Resulting pair: (0, 1). This demonstrates the conservatism of the unstructured small-gain test.\n\nTest 3: $M_3 = \\begin{bmatrix} 0 & 1.25 \\\\ 0.8 & 0 \\end{bmatrix}$.\n- Unstructured test: The singular values of $M_3$ are $1.25$ and $0.8$. The largest is $\\lVert M_3 \\rVert_2 = 1.25$. Since $1.25 \\not< 1$, the test fails (result: 0).\n- Structured test: We compute $|m_{12}m_{21}| = |1.25 \\times 0.8| = 1.0$. Since $1.0 \\not< 1$, the test fails (result: 0).\n- Resulting pair: (0, 0). This is a boundary case for the structured test.\n\nTest 4: $M_4 = \\begin{bmatrix} 0 & 1.5 \\\\ 1.2 & 0 \\end{bmatrix}$.\n- Unstructured test: The singular values of $M_4$ are $1.5$ and $1.2$. The largest is $\\lVert M_4 \\rVert_2 = 1.5$. Since $1.5 \\not< 1$, the test fails (result: 0).\n- Structured test: We compute $|m_{12}m_{21}| = |1.5 \\times 1.2| = 1.8$. Since $1.8 \\not< 1$, the test fails (result: 0).\n- Resulting pair: (0, 0). Both tests decisively fail.\n\nThe final program will compute these pairs and aggregate them into the required string format: `[[1,1],[0,1],[0,0],[0,0]]`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes robust stability checks for a set of 2x2 matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0, 0.5], [0.5, 0]], dtype=float),\n        np.array([[0, 1.2], [0.8, 0]], dtype=float),\n        np.array([[0, 1.25], [0.8, 0]], dtype=float),\n        np.array([[0, 1.5], [1.2, 0]], dtype=float)\n    ]\n\n    results = []\n    for M in test_cases:\n        # 1. Unstructured small-gain test: norm(M, 2) < 1\n        # The induced 2-norm is the largest singular value of M.\n        # It can be computed directly using numpy.linalg.norm with ord=2.\n        norm_M_2 = np.linalg.norm(M, ord=2)\n        small_gain_passes = 1 if norm_M_2 < 1.0 else 0\n\n        # 2. Structured singular value (mu) test: mu(M) < 1\n        # For the given M structure (zero diagonal elements), mu(M) < 1\n        # is equivalent to |m_12 * m_21| < 1, as derived from first\n        # principles.\n        m12 = M[0, 1]\n        m21 = M[1, 0]\n        mu_criterion = np.abs(m12 * m21)\n        structured_mu_passes = 1 if mu_criterion < 1.0 else 0\n        \n        results.append([small_gain_passes, structured_mu_passes])\n\n    # Final print statement in the exact required format.\n    # The required format is a string representation of a Python list of lists,\n    # with no whitespace, e.g., \"[[a,b],[c,d]]\".\n    # We construct this string manually to ensure exactness.\n    outer_parts = []\n    for pair in results:\n        outer_parts.append(f\"[{pair[0]},{pair[1]}]\")\n    final_output_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2741714"}, {"introduction": "In complex multivariable systems, analyzing each control loop in isolation can be dangerously misleading; strong individual loop performance does not guarantee overall system robustness. This exercise ([@problem_id:2741663]) provides a compelling, hands-on demonstration of this critical principle by constructing a system where seemingly robust single-loop margins mask a hidden fragility to simultaneous perturbations. Through this computational analysis, you will gain a profound appreciation for the impact of cross-coupling and the necessity of true multivariable robustness tools.", "problem": "You are given a linear time-invariant (LTI) multiple-input multiple-output (MIMO) continuous-time feedback system with negative feedback and a diagonal static controller. Let $G(s)$ denote the $2 \\times 2$ plant transfer matrix, and let $K = \\mathrm{diag}(k_1,k_2)$ denote the controller. The loop transfer matrix is $L(s) = G(s)K$, and the complementary sensitivity matrix is $T(s) = L(s)(I + L(s))^{-1}$, where $I$ is the $2 \\times 2$ identity matrix. Consider complex multiplicative uncertainty at the loop openings. For a single loop $i \\in \\{1,2\\}$ perturbed as $L_{ii}(s) \\mapsto (1 + \\Delta_i)L_{ii}(s)$ with $|\\Delta_i| \\le \\rho_i$ (complex scalar), the Small Gain Theorem provides a condition for robust stability in terms of the size of the complementary sensitivity for that loop. For simultaneous and independent complex multiplicative uncertainty at both loops, modelled as a block-diagonal uncertainty $\\Delta = \\mathrm{diag}(\\Delta_1,\\Delta_2)$ with $|\\Delta_i| \\le \\rho$ (complex scalars), the Small Gain Theorem provides a sufficient condition for robust stability in terms of the induced norm of the complementary sensitivity matrix. Your task is to:\n- Starting from the Small Gain Theorem and the definition of complementary sensitivity, derive the expressions that allow you to compute:\n  1. For each loop $i \\in \\{1,2\\}$ analyzed independently (with the other loop opened), the largest complex-gain margin $\\rho_i$ that guarantees robust stability against all complex scalar multiplicative perturbations $|\\Delta_i| \\le \\rho_i$.\n  2. A conservative bound $\\rho_{\\mathrm{sim}}$ on the largest simultaneous complex-gain (disk) margin that guarantees robust stability against all block-diagonal complex scalar multiplicative perturbations $|\\Delta_i| \\le \\rho$ applied simultaneously at both loops.\n- Then implement your derivation numerically using frequency-domain analysis.\n\nUse the following modeling and numerical instructions:\n- Each scalar transfer function entry of $G(s)$ has the form $G_{ij}(s) = \\frac{a_{ij}}{s + p_{ij}}$, with real $a_{ij}$ and strictly positive $p_{ij}$.\n- The controller is $K = \\mathrm{diag}(k_1,k_2)$ with real positive gains $k_1,k_2$.\n- For the single-loop analysis of loop $i$, open the other loop. Model the single-loop complementary sensitivity as $T_i(s)$ built from the SISO loop transfer $L_{ii}(s)$.\n- Approximate essential supremums over frequency by sampling the frequency axis on a logarithmic grid $\\omega \\in [10^{-3}, 10^{3}]$ (in radians per second), using at least $N = 3000$ logarithmically spaced samples.\n\nTest Suite:\nCompute the quantities below for three specified plants and controllers. For each case, report three values:\n- The smallest individual loop complex-gain margin $\\min(\\rho_1,\\rho_2)$.\n- The conservative simultaneous disk margin bound $\\rho_{\\mathrm{sim}}$ obtained from the complementary sensitivity matrix.\n- The ratio $\\rho_{\\mathrm{sim}} / \\min(\\rho_1,\\rho_2)$.\n\nCase $1$ (diagonal plant, baseline consistency check):\n- $G_{11}(s) = \\frac{2.0}{s + 1.0}$, $G_{12}(s) = \\frac{0.0}{s + 1.0}$,\n- $G_{21}(s) = \\frac{0.0}{s + 1.0}$, $G_{22}(s) = \\frac{3.0}{s + 0.5}$,\n- $K = \\mathrm{diag}(0.6, 0.4)$.\n\nCase $2$ (moderate cross-coupling):\n- $G_{11}(s) = \\frac{2.0}{s + 1.0}$, $G_{12}(s) = \\frac{0.5}{s + 0.7}$,\n- $G_{21}(s) = \\frac{-0.4}{s + 0.9}$, $G_{22}(s) = \\frac{3.0}{s + 0.5}$,\n- $K = \\mathrm{diag}(0.6, 0.4)$.\n\nCase $3$ (strong cross-coupling causing fragility):\n- $G_{11}(s) = \\frac{0.2}{s + 1.0}$, $G_{12}(s) = \\frac{5.0}{s + 0.3}$,\n- $G_{21}(s) = \\frac{-5.0}{s + 0.3}$, $G_{22}(s) = \\frac{0.2}{s + 1.0}$,\n- $K = \\mathrm{diag}(1.0, 1.0)$.\n\nRequired outputs and format:\n- For each case, compute:\n  - $\\rho_1$ and $\\rho_2$ from your single-loop analysis, and then $\\min(\\rho_1,\\rho_2)$,\n  - the conservative simultaneous disk margin bound $\\rho_{\\mathrm{sim}}$ from your multiloop analysis,\n  - the ratio $\\rho_{\\mathrm{sim}} / \\min(\\rho_1,\\rho_2)$.\n- Report each case as a list $[\\min(\\rho_1,\\rho_2), \\rho_{\\mathrm{sim}}, \\rho_{\\mathrm{sim}} / \\min(\\rho_1,\\rho_2)]$, with each value rounded to exactly three decimal places.\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets, for example $[[r_{1,1}, r_{1,2}, r_{1,3}],[r_{2,1}, r_{2,2}, r_{2,3}],[r_{3,1}, r_{3,2}, r_{3,3}]]$.\n\nAngle units:\n- All frequencies are in radians per second. No angular conversions are needed.\n\nThere are no physical units in the outputs; all outputs are dimensionless real numbers. Ensure numerical stability and accuracy by adhering to the specified frequency grid and by avoiding ill-conditioned matrix inversions where possible. Your program must be self-contained, require no user input, and follow the specified output format exactly.", "solution": "The problem presented is a well-posed exercise in the robust control analysis of a linear time-invariant (LTI) multiple-input multiple-output (MIMO) system. It is scientifically grounded in established control theory, provides all necessary data and definitions, and requests the calculation of standard robustness metrics. The problem is therefore deemed valid and a full solution will be provided.\n\nThe core of the problem is to determine robust stability margins for a feedback system subject to complex multiplicative uncertainty, using the Small Gain Theorem. We will first derive the necessary theoretical expressions and then outline the numerical implementation.\n\nLet the system be described by the negative feedback interconnection of a plant $G(s)$ and a controller $K$. The loop transfer matrix is $L(s) = G(s)K$, and the nominal closed-loop system is assumed to be stable. The output complementary sensitivity matrix is defined as $T(s) = L(s)(I + L(s))^{-1}$.\n\n**1. Single-Loop Robustness Analysis**\n\nFor the analysis of a single loop $i \\in \\{1,2\\}$, the problem states that the other loop is opened and a multiplicative perturbation is applied to the loop transfer function $L_{ii}(s)$. The perturbed scalar loop transfer function is $L'_{ii}(s) = (1 + \\Delta_i(s))L_{ii}(s)$, where $\\Delta_i(s)$ is a stable complex transfer function representing the uncertainty, bounded by $|\\Delta_i(\\mathrm{j}\\omega)| \\leq \\rho_i$ for all frequencies $\\omega$.\n\nThe nominal characteristic equation for loop $i$ is $1 + L_{ii}(s) = 0$. The perturbed characteristic equation is $1 + L'_{ii}(s) = 0$. Substituting the expression for $L'_{ii}(s)$:\n$$\n1 + (1 + \\Delta_i(s))L_{ii}(s) = 0\n$$\n$$\n(1 + L_{ii}(s)) + \\Delta_i(s)L_{ii}(s) = 0\n$$\nFor a nominally stable closed-loop, $1 + L_{ii}(s)$ is non-zero on the imaginary axis. We can rearrange the equation to isolate the uncertainty:\n$$\n1 + \\Delta_i(s) \\frac{L_{ii}(s)}{1 + L_{ii}(s)} = 0\n$$\nWe identify the scalar complementary sensitivity function for loop $i$ as $T_i(s) = \\frac{L_{ii}(s)}{1 + L_{ii}(s)}$. The stability condition becomes $1 + \\Delta_i(s)T_i(s) \\neq 0$ for all $s$ in the right-half plane. This can be viewed as a feedback loop between $\\Delta_i(s)$ and $T_i(s)$. By the Small Gain Theorem, this loop is stable for all stable $\\Delta_i(s)$ satisfying $\\|\\Delta_i\\|_{\\infty} < 1/\\|T_i\\|_{\\infty}$.\n\nGiven the uncertainty bound $|\\Delta_i(\\mathrm{j}\\omega)| \\le \\rho_i$, we have $\\|\\Delta_i\\|_{\\infty} \\le \\rho_i$. The condition for robust stability is therefore $\\rho_i < 1/\\|T_i\\|_{\\infty}$. The largest complex-gain margin $\\rho_i$ for which stability is guaranteed for all admissible perturbations is:\n$$\n\\rho_i = \\frac{1}{\\|T_i\\|_{\\infty}} = \\frac{1}{\\sup_{\\omega} |T_i(\\mathrm{j}\\omega)|}\n$$\nwhere $L_{ii}(s) = G_{ii}(s)k_i$.\n\n**2. Simultaneous MIMO Robustness Analysis**\n\nFor simultaneous perturbations on both loops, we model the uncertainty as a diagonal matrix $\\Delta(s) = \\mathrm{diag}(\\Delta_1(s), \\Delta_2(s))$, where $|\\Delta_i(\\mathrm{j}\\omega)| \\le \\rho$ for all $\\omega$. We assume the standard output multiplicative uncertainty model, where the perturbed plant is $G_p(s) = G(s)(I + \\Delta(s))$. This is one of the standard models for which the complementary sensitivity matrix $T(s)$ is the relevant transfer function for analysis.\n\nTo apply the Small Gain Theorem, we formulate the system in the M-$\\Delta$ framework. Let $z(s)$ be the input to the uncertainty block $\\Delta(s)$ and $w(s)$ be its output, such that $w(s) = \\Delta(s)z(s)$. The objective is to find the transfer matrix $M(s)$ from $w(s)$ to $z(s)$ for the nominal system.\n\nThe feedback system equations are:\n- Plant output: $y(s) = G(s)u(s)$\n- Controller output: $u(s) = K(r(s) - y_f(s))$\n- Feedback signal (perturbed): $y_f(s) = y(s) + w(s)$\n- Uncertainty input: $z(s) = y(s)$\n\nFor internal stability analysis, we set the external reference $r(s) = 0$.\n$$\nu(s) = -K(y(s) + w(s)) = -K(z(s) + w(s))\n$$\n$$\ny(s) = G(s)u(s) = -G(s)K(z(s) + w(s)) = -L(s)(z(s) + w(s))\n$$\nSince $z(s) = y(s)$, we have:\n$$\nz(s) = -L(s)(z(s) + w(s))\n$$\n$$\n(I + L(s))z(s) = -L(s)w(s)\n$$\n$$\nz(s) = -(I + L(s))^{-1}L(s)w(s)\n$$\nBy reversing the order of matrices in the last expression, $z(s) = -L(s)(I + L(s))^{-1}w(s) = -T(s)w(s)$. The transfer matrix from $w$ to $z$ is $M(s) = -T(s)$.\n\nThe Small Gain Theorem states that the interconnected system is stable if $\\|\\Delta M\\|_{\\infty} < 1$. A sufficient (and conservative) condition is $\\|\\Delta\\|_{\\infty} \\|M\\|_{\\infty} < 1$.\nThe $H_{\\infty}$-norm of the block-diagonal uncertainty $\\Delta(s)$ is:\n$$\n\\|\\Delta\\|_{\\infty} = \\sup_{\\omega} \\sigma_{\\max}(\\Delta(\\mathrm{j}\\omega)) = \\sup_{\\omega} \\max_{i} |\\Delta_i(\\mathrm{j}\\omega)| \\le \\rho\n$$\nThe norm of $M(s)$ is $\\|M\\|_{\\infty} = \\|-T\\|_{\\infty} = \\|T\\|_{\\infty}$. The stability condition becomes $\\rho \\|T\\|_{\\infty} < 1$.\nThe largest simultaneous disk margin $\\rho_{\\mathrm{sim}}$ is therefore given by:\n$$\n\\rho_{\\mathrm{sim}} = \\frac{1}{\\|T\\|_{\\infty}} = \\frac{1}{\\sup_{\\omega} \\sigma_{\\max}(T(\\mathrm{j}\\omega))}\n$$\nwhere $\\sigma_{\\max}(\\cdot)$ denotes the maximum singular value. This bound is conservative because it does not exploit the diagonal structure of $\\Delta(s)$.\n\n**3. Numerical Implementation**\n\nThe $H_{\\infty}$-norms are computed numerically by taking the maximum value over a dense grid of frequencies. For a scalar function $T_i(s)$, $\\|T_i\\|_{\\infty} \\approx \\max_{\\omega \\in \\Omega} |T_i(\\mathrm{j}\\omega)|$. For a matrix function $T(s)$, $\\|T\\|_{\\infty} \\approx \\max_{\\omega \\in \\Omega} \\sigma_{\\max}(T(\\mathrm{j}\\omega))$. The frequency grid $\\Omega$ is specified as $N=3000$ logarithmically spaced points between $10^{-3}$ and $10^3$ rad/s. The calculation proceeds by evaluating the relevant transfer functions at each frequency point in the grid and finding the maximum of the corresponding norm. For the MIMO case, this involves matrix inversion and singular value decomposition at each frequency point.\n\nThe ratio $\\rho_{\\mathrm{sim}} / \\min(\\rho_1, \\rho_2)$ quantifies the impact of multivariable coupling on robustness. For a decoupled system (diagonal plant), this ratio is expected to be $1$. For coupled systems, interactions typically reduce robustness, leading to a ratio less than $1$.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef g_ij(s, a, p):\n    \"\"\"\n    Computes the value of a single transfer function G_ij(s) = a / (s + p).\n    \"\"\"\n    return a / (s + p)\n\ndef solve_case(G_params, K_diag):\n    \"\"\"\n    Solves for robustness margins for a single test case.\n\n    Args:\n        G_params (list of lists of tuples): 2x2 matrix of (a_ij, p_ij) parameters for the plant G(s).\n        K_diag (list): Diagonal elements [k1, k2] of the controller K.\n\n    Returns:\n        list: A list containing [min(rho_1, rho_2), rho_sim, ratio], rounded to 3 decimal places.\n    \"\"\"\n    # Define frequency grid\n    w_grid = np.logspace(-3, 3, 3000)\n    s_grid = 1j * w_grid\n\n    k1, k2 = K_diag\n    K = np.diag(K_diag)\n\n    # --- Single-loop analysis (SISO) ---\n\n    # Loop 1\n    a11, p11 = G_params[0][0]\n    L11_s_vals = g_ij(s_grid, a11, p11) * k1\n    T1_s_vals = L11_s_vals / (1.0 + L11_s_vals)\n    norm_T1_inf = np.max(np.abs(T1_s_vals))\n    rho1 = 1.0 / norm_T1_inf if norm_T1_inf > 0 else float('inf')\n\n    # Loop 2\n    a22, p22 = G_params[1][1]\n    L22_s_vals = g_ij(s_grid, a22, p22) * k2\n    T2_s_vals = L22_s_vals / (1.0 + L22_s_vals)\n    norm_T2_inf = np.max(np.abs(T2_s_vals))\n    rho2 = 1.0 / norm_T2_inf if norm_T2_inf > 0 else float('inf')\n\n    min_rho_i = min(rho1, rho2)\n\n    # --- Simultaneous analysis (MIMO) ---\n    max_sigma_T_list = []\n\n    for s in s_grid:\n        # Construct G(s) matrix\n        G_s = np.array([\n            [g_ij(s, G_params[0][0][0], G_params[0][0][1]), g_ij(s, G_params[0][1][0], G_params[0][1][1])],\n            [g_ij(s, G_params[1][0][0], G_params[1][0][1]), g_ij(s, G_params[1][1][0], G_params[1][1][1])]\n        ], dtype=complex)\n\n        # Loop transfer matrix L(s) = G(s)K\n        L_s = G_s @ K\n\n        # Complementary sensitivity T(s) = L(s) * inv(I + L(s))\n        # Numerically better: T(s) = I - S(s) where S(s) = inv(I + L(s))\n        I = np.eye(2)\n        try:\n            S_s = np.linalg.inv(I + L_s)\n            T_s = I - S_s\n        except np.linalg.LinAlgError:\n            # If I+L is singular, ||T|| -> inf, rho -> 0.\n            # This indicates instability, but for this problem, we can assume it's stable.\n            # A large norm will be captured at other frequencies.\n            # We can skip this point, or assign a large value.\n            # Using svd on L might give a large singular value, leading to a large norm for T.\n            # For simplicity, we skip if inversion fails.\n            continue\n            \n        # Maximum singular value of T(s)\n        # scipy.linalg.svd is faster for just singular values\n        singular_values = svd(T_s, compute_uv=False)\n        max_sigma_T_list.append(singular_values[0])\n\n    norm_T_inf = np.max(max_sigma_T_list)\n    rho_sim = 1.0 / norm_T_inf if norm_T_inf > 0 else float('inf')\n\n    ratio = rho_sim / min_rho_i if min_rho_i != 0 else float('inf')\n\n    return [round(min_rho_i, 3), round(rho_sim, 3), round(ratio, 3)]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"G_params\": [[(2.0, 1.0), (0.0, 1.0)], [(0.0, 1.0), (3.0, 0.5)]],\n            \"K_diag\": [0.6, 0.4]\n        },\n        {\n            \"G_params\": [[(2.0, 1.0), (0.5, 0.7)], [(-0.4, 0.9), (3.0, 0.5)]],\n            \"K_diag\": [0.6, 0.4]\n        },\n        {\n            \"G_params\": [[(0.2, 1.0), (5.0, 0.3)], [(-5.0, 0.3), (0.2, 1.0)]],\n            \"K_diag\": [1.0, 1.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"G_params\"], case[\"K_diag\"])\n        results.append(result)\n\n    # Format the output string exactly as required\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2741663"}]}