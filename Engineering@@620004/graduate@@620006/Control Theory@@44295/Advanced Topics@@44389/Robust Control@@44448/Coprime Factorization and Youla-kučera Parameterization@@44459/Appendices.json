{"hands_on_practices": [{"introduction": "This first practice exercise takes us back to the algebraic foundations of control theory. We will explore how the characterization of all stabilizing controllers for a plant can be traced back to a fundamental property of polynomials described by the Bézout identity. By applying the classical Euclidean algorithm to find a specific solution [@problem_id:2697784], you will gain a deeper appreciation for how the Youla-Kučera parameterization emerges directly from algebraic principles, establishing a concrete link between abstract algebra and controller synthesis.", "problem": "Consider the single-input single-output plant $P(s) = \\dfrac{n(s)}{m(s)}$ with $m(s) = s + 1$ and $n(s) = s + 2$. Work over the ring of real polynomials $\\mathbb{R}[s]$.\n\n- Using only the definitions of a coprime factorization and the polynomial Bézout identity, first justify that $m(s)$ and $n(s)$ are right coprime in $\\mathbb{R}[s]$ and that there must exist polynomials $x(s), y(s) \\in \\mathbb{R}[s]$ such that $x(s)\\,m(s) + y(s)\\,n(s) = 1$.\n\n- Compute explicit polynomials $x(s)$ and $y(s)$ satisfying the identity $x(s)\\,m(s) + y(s)\\,n(s) = 1$. Your computation must proceed from first principles, i.e., by an explicit application of the Euclidean algorithm (no use of pre-remembered shortcut formulas).\n\n- Interpret the computed pair $x(s)$ and $y(s)$ in the context of the Youla-Kučera parameterization. Starting from the definitions of a right coprime factorization and the internal stability condition, reason how the existence of a polynomial Bézout pair $(x(s), y(s))$ reflects the existence of a particular stabilizing solution for the single-input single-output case when the free parameter is chosen as a stable, proper real-rational function $q(s)$ set to $q(s) = 0$. Clearly explain the logical steps connecting the Bézout identity to the existence of a stabilizing controller family, and identify the special “central” stabilizing choice corresponding to $q(s) = 0$.\n\nExpress your final answer as the ordered pair $\\big(x(s),\\,y(s)\\big)$. No numerical rounding is required, and no physical units are involved.", "solution": "### Solution\n\nThe problem is addressed in three parts as requested.\n\n#### Part 1: Justification of Coprimality and Existence of Bézout's Identity\n\nTwo polynomials in $\\mathbb{R}[s]$ are defined as coprime if their greatest common divisor (GCD) is a non-zero constant. Since the ring of polynomials $\\mathbb{R}[s]$ is a Euclidean domain, we can use the Euclidean algorithm to find the GCD of $m(s) = s + 1$ and $n(s) = s + 2$. The algorithm consists of sequential polynomial division.\n\nWe divide $n(s)$ by $m(s)$:\n$$\nn(s) = q_1(s) m(s) + r_1(s)\n$$\n$$\ns + 2 = (1)(s + 1) + 1\n$$\nThe quotient is $q_1(s) = 1$ and the remainder is $r_1(s) = 1$. Since the remainder is a non-zero constant, the algorithm terminates. The last non-zero remainder is the GCD. Here, the GCD is $1$.\n\nSince $\\text{gcd}(m(s), n(s)) = 1$, the polynomials $m(s)$ and $n(s)$ are coprime in $\\mathbb{R}[s]$. For a commutative ring like $\\mathbb{R}[s]$, the distinction between right and left coprimality is moot; they are simply coprime.\n\nBézout's identity for a Euclidean domain states that if $d(s) = \\text{gcd}(m(s), n(s))$, then there exist elements $x(s)$ and $y(s)$ in the domain such that $x(s)m(s) + y(s)n(s) = d(s)$. Since we have found that $\\text{gcd}(m(s), n(s)) = 1$, it follows directly from this theorem that there must exist polynomials $x(s), y(s) \\in \\mathbb{R}[s]$ satisfying the identity:\n$$\nx(s)m(s) + y(s)n(s) = 1\n$$\nThis justifies the existence of such a pair $(x(s), y(s))$.\n\n#### Part 2: Computation of the Bézout Pair $(x(s), y(s))$\n\nTo find an explicit pair $(x(s), y(s))$, we use the Extended Euclidean Algorithm, which involves working backward from the division step performed above.\nFrom the division equation:\n$$\n1 = (s+2) - (1)(s+1)\n$$\nWe rearrange this equation to match the form $x(s)m(s) + y(s)n(s) = 1$, which is $x(s)(s+1) + y(s)(s+2) = 1$.\n$$\n(-1)(s+1) + (1)(s+2) = 1\n$$\nBy comparing this with the required identity, we can identify the polynomials $x(s)$ and $y(s)$.\n$$\nx(s) = -1\n$$\n$$\ny(s) = 1\n$$\nThis gives the explicit polynomial pair $(x(s), y(s)) = (-1, 1)$. These are constant polynomials, which are elements of $\\mathbb{R}[s]$.\n\n#### Part 3: Interpretation in Youla-Kučera Parameterization\n\nThe Youla-Kučera parameterization provides a complete set of all *internally stabilizing* controllers for a plant, based on a coprime factorization over the ring of stable, proper functions ($RH_\\infty$). The problem, however, considers a factorization over the ring of polynomials, $\\mathbb{R}[s]$. The connection can be seen through the closed-loop characteristic polynomial.\n\nFor a plant $P=n/m$ and controller $C=u/v$, the characteristic polynomial is $mv+nu$. The Bézout identity $xm+yn=1$ shows that it is possible to choose a controller such that this polynomial is a non-zero constant, which implies input-output stability (no closed-loop poles).\n\nIf we choose controller parts based on the Bézout pair $(x,y)=(-1, 1)$, for instance $C = x/y = -1/1 = -1$, the characteristic polynomial becomes $m(1)+n(-1) = (s+1)-(s+2) = -1$. The absence of roots implies input-output stability.\n\nHowever, this does not guarantee *internal* stability. The sensitivity function is $S=(1+PC)^{-1} = (1 - P)^{-1} = \\left(1-\\frac{s+2}{s+1}\\right)^{-1} = \\left(\\frac{s+1-(s+2)}{s+1}\\right)^{-1} = (-1/(s+1))^{-1} = -(s+1)$. This function is not in $RH_\\infty$ (it is not proper or stable), so the system is not internally stable.\n\nThus, while the polynomial Bézout identity guarantees that input-output stability can be achieved, the Youla-Kučera framework is essential because it is built upon factorizations in $RH_\\infty$, which guarantees internal stability by ensuring all internal transfer functions (like $S$) are stable and proper. The central controller $K(0)$ in the Y-K framework is guaranteed to be internally stabilizing by construction. The pair $(x,y)$ from the polynomial ring is a precursor to finding the factors required for the full Y-K parameterization over $RH_\\infty$.", "answer": "$$\n\\boxed{\\begin{pmatrix} -1 & 1 \\end{pmatrix}}\n$$", "id": "2697784"}, {"introduction": "Building upon the concept of factorization, we now transition from the ring of polynomials to the more general framework of stable, proper rational functions used in modern control. This exercise [@problem_id:2697785] guides you through constructing a *normalized* right coprime factorization, a special structure that is pivotal for simplifying robust control design problems. You will practice the powerful technique of spectral factorization, which is essential for creating factorizations that satisfy the key normalization condition and pave the way for elegant solutions in $H_{\\infty}$ synthesis.", "problem": "Consider the single-input single-output transfer function $P(s) = \\dfrac{s - 1}{s + 2}$, which has no poles on the imaginary axis. Using only first principles from coprime factorization and the Youla-Kučera parameterization, construct a normalized right coprime factorization of $P(s)$ over the ring of real-rational, proper, stable transfer functions, as follows.\n\n1. Use the scalar spectral factorization approach: for continuous-time real-rational functions, define the para-conjugate by $F^{\\sim}(s) \\triangleq F(-s)$, and find a stable, minimum-phase spectral factor $q(s)$ satisfying $q(-s) \\, q(s) = \\Phi(s)$, where $\\Phi(s) \\triangleq 1 + P^{\\sim}(s) P(s)$.\n2. From this spectral factor, define $m(s) \\triangleq q(s)^{-1}$ and $n(s) \\triangleq q(s)^{-1} P(s)$.\n\nDerive $q(s)$ explicitly and hence obtain closed-form expressions for $m(s)$ and $n(s)$ in lowest terms. Your final answer must be the ordered pair $\\big(m(s),\\,n(s)\\big)$ written as a single row using the LaTeX pmatrix convention. No numerical rounding is required, and no units are involved.", "solution": "The given plant transfer function is $P(s) = \\dfrac{s - 1}{s + 2}$. The objective is to find a normalized right coprime factorization of $P(s)$ over the ring of real-rational, proper, stable transfer functions. This factorization is denoted by the pair $(n(s), m(s))$ such that $P(s) = n(s)m(s)^{-1}$. The procedure is based on scalar spectral factorization.\n\nFirst, we must construct the function $\\Phi(s)$, defined as $\\Phi(s) \\triangleq 1 + P^{\\sim}(s) P(s)$. The para-conjugate $P^{\\sim}(s)$ is defined as $P(-s)$.\nFor the given $P(s)$, we have:\n$$\nP^{\\sim}(s) = P(-s) = \\frac{(-s) - 1}{(-s) + 2} = \\frac{-(s + 1)}{-(s - 2)} = \\frac{s + 1}{s - 2}\n$$\nNext, we compute the product $P^{\\sim}(s) P(s)$:\n$$\nP^{\\sim}(s) P(s) = \\left( \\frac{s + 1}{s - 2} \\right) \\left( \\frac{s - 1}{s + 2} \\right) = \\frac{(s + 1)(s - 1)}{(s - 2)(s + 2)} = \\frac{s^2 - 1}{s^2 - 4}\n$$\nUsing this product, we form $\\Phi(s)$:\n$$\n\\Phi(s) = 1 + P^{\\sim}(s) P(s) = 1 + \\frac{s^2 - 1}{s^2 - 4} = \\frac{(s^2 - 4) + (s^2 - 1)}{s^2 - 4} = \\frac{2s^2 - 5}{s^2 - 4}\n$$\nThe second step is to find the stable, minimum-phase spectral factor $q(s)$ that satisfies the relation $q(-s) q(s) = \\Phi(s)$. To do this, we analyze the poles and zeros of $\\Phi(s)$.\nThe zeros of $\\Phi(s)$ are the roots of the numerator $2s^2 - 5 = 0$, which are $s^2 = \\frac{5}{2}$, or $s = \\pm \\sqrt{\\frac{5}{2}}$.\nThe poles of $\\Phi(s)$ are the roots of the denominator $s^2 - 4 = 0$, which are $s = \\pm 2$.\n\nFor $q(s)$ to be stable, its poles must be in the open left-half complex plane. From the poles of $\\Phi(s)$, we select the pole at $s = -2$.\nFor $q(s)$ to be minimum-phase, its zeros must also be in the open left-half complex plane. From the zeros of $\\Phi(s)$, we select the zero at $s = -\\sqrt{\\frac{5}{2}}$.\n\nWe can now construct $q(s)$ by assembling these components. Let us write $\\Phi(s)$ in factored form:\n$$\n\\Phi(s) = \\frac{2(s^2 - \\frac{5}{2})}{s^2 - 4} = \\frac{2(s - \\sqrt{\\frac{5}{2}})(s + \\sqrt{\\frac{5}{2}})}{(s - 2)(s + 2)}\n$$\nWe propose a form for $q(s) = k \\frac{s + \\sqrt{5/2}}{s + 2}$, where $k$ is a constant. Then $q(-s) = k \\frac{-s + \\sqrt{5/2}}{-s + 2} = k \\frac{s - \\sqrt{5/2}}{s - 2}$.\nThe product is:\n$$\nq(-s) q(s) = k^2 \\frac{(s - \\sqrt{\\frac{5}{2}})(s + \\sqrt{\\frac{5}{2}})}{(s - 2)(s + 2)} = k^2 \\frac{s^2 - \\frac{5}{2}}{s^2 - 4}\n$$\nComparing this with $\\Phi(s) = 2 \\frac{s^2 - \\frac{5}{2}}{s^2 - 4}$, we deduce that $k^2 = 2$. We choose the positive root, $k = \\sqrt{2}$.\nTherefore, the spectral factor $q(s)$ is:\n$$\nq(s) = \\sqrt{2} \\left( \\frac{s + \\sqrt{\\frac{5}{2}}}{s + 2} \\right) = \\frac{\\sqrt{2} s + \\sqrt{2}\\sqrt{\\frac{5}{2}}}{s + 2} = \\frac{\\sqrt{2}s + \\sqrt{5}}{s + 2}\n$$\nThis function $q(s)$ is stable (pole at $s = -2$) and minimum-phase (zero at $s = -\\sqrt{5/2}$), as required.\n\nFinally, we derive the coprime factors $m(s)$ and $n(s)$ using the given definitions.\nThe factor $m(s)$ is defined as the inverse of $q(s)$:\n$$\nm(s) \\triangleq q(s)^{-1} = \\left( \\frac{\\sqrt{2}s + \\sqrt{5}}{s + 2} \\right)^{-1} = \\frac{s + 2}{\\sqrt{2}s + \\sqrt{5}}\n$$\nThis function $m(s)$ is stable, with its pole at $s = -\\frac{\\sqrt{5}}{\\sqrt{2}} = -\\sqrt{\\frac{5}{2}}$, which is in the left-half plane. It is also proper, as the degrees of the numerator and denominator are both $1$.\n\nThe factor $n(s)$ is defined as $q(s)^{-1} P(s)$, which is equivalent to $m(s) P(s)$:\n$$\nn(s) \\triangleq m(s) P(s) = \\left( \\frac{s + 2}{\\sqrt{2}s + \\sqrt{5}} \\right) \\left( \\frac{s - 1}{s + 2} \\right)\n$$\nThe term $(s+2)$ cancels in the numerator and denominator, yielding the expression in lowest terms:\n$$\nn(s) = \\frac{s - 1}{\\sqrt{2}s + \\sqrt{5}}\n$$\nThis function $n(s)$ is also stable, having the same pole as $m(s)$ at $s = -\\sqrt{\\frac{5}{2}}$. It is also proper, with numerator and denominator degrees both equal to $1$.\n\nThe pair $(m(s), n(s))$ constitutes the normalized right coprime factorization. The property of coprimeness is confirmed by the existence of stable, proper functions $X(s)$ and $Y(s)$ such that $X(s)n(s) + Y(s)m(s)=1$, which is readily verifiable. The normalization condition $m^{\\sim}(s)m(s) + n^{\\sim}(s)n(s) = 1$ is satisfied by construction.\n\nThe required expressions are:\n$m(s) = \\frac{s + 2}{\\sqrt{2}s + \\sqrt{5}}$\n$n(s) = \\frac{s - 1}{\\sqrt{2}s + \\sqrt{5}}$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{s + 2}{\\sqrt{2}s + \\sqrt{5}} & \\frac{s - 1}{\\sqrt{2}s + \\sqrt{5}} \\end{pmatrix}}\n$$", "id": "2697785"}, {"introduction": "With the theoretical tools of coprime factorization in hand, we can now tackle a practical design problem. This final exercise [@problem_id:2697790] demonstrates how the Youla-Kučera parameterization transforms the challenge of controller synthesis into a tractable search for a stable parameter, $Q(s)$. You will work to find a simple controller that satisfies specific performance bounds on the sensitivity $S(s)$ and complementary sensitivity $T(s)$ functions, gaining insight into the trade-offs inherent in feedback design and the power of this parameterization to systematically explore them.", "problem": "You are given a single-input single-output (SISO) strictly proper, stable plant specified by the transfer function $P(s)$ and design objectives stated as magnitude bounds on the sensitivity function $S(j\\omega)$ and the complementary sensitivity function $T(j\\omega)$ over a finite set of angular frequencies. Your task is to use coprime factorization and the Youla-Kučera parameterization to algorithmically synthesize a stable Youla parameter $Q(s)$ and verify whether the specified bounds can be met.\n\nFundamental base:\n- Let $P(s)$ be a real-rational, scalar, strictly proper, and stable transfer function. Consider a doubly coprime factorization of $P(s)$ over the ring of real, rational, stable transfer functions.\n- The Youla-Kučera parameterization characterizes all internally stabilizing controllers via a stable, proper, free design parameter $Q(s)$. In this framework, the closed-loop maps can be expressed as affine functions of $Q(s)$, and feasibility of magnitude bounds on $S(j\\omega)$ and $T(j\\omega)$ can be tested by searching over a stable, proper class of $Q(s)$.\n\nProgram requirements:\n- Plant: $P(s) = \\dfrac{1}{s + 1}$.\n- Candidate Youla parameter restricted to the real-rational, strictly proper, first-order family $Q(s) = \\dfrac{k}{s + q_1}$ with $k > 0$ and $q_1 > 0$.\n- Use the Youla-Kučera parameterization to express $S(j\\omega)$ and $T(j\\omega)$ as functions of $P(j\\omega)$ and $Q(j\\omega)$, and then enforce the magnitude constraints at each frequency in the test suite described below.\n- Numerical angle unit: all frequencies $\\omega$ are specified in radians per second. No other physical units are involved.\n- Your program must search over a bounded set of parameters $(k, q_1)$ and determine, for each test case, whether there exists any stabilizing $Q(s)$ of the restricted family for which all frequency-wise magnitude constraints are satisfied simultaneously.\n- Output specification: For each test case, output a boolean indicating feasibility, i.e., whether a suitable $Q(s)$ exists. Aggregate the results for all test cases into a single line printed as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True]\").\n\nTest suite:\nFor each case, you are given a frequency grid $\\Omega = [\\omega_1,\\ldots,\\omega_m]$ and frequency-wise upper bounds on the magnitudes of $S(j\\omega)$ and $T(j\\omega)$, denoted by vectors $b_S$ and $b_T$ of the same length as $\\Omega$.\n\n- Case 1 (general feasibility, multi-frequency shaping):\n  - $\\Omega = [0.01, 1.0, 10.0]$ radians/second\n  - $b_S = [0.05, 0.60, 1.00]$\n  - $b_T = [0.98, 0.80, 0.20]$\n\n- Case 2 (provably infeasible necessary condition):\n  - $\\Omega = [1.0]$ radians/second\n  - $b_S = [0.30]$\n  - $b_T = [0.60]$\n\n- Case 3 (low-frequency tightness with high-frequency roll-off):\n  - $\\Omega = [0.10, 10.0]$ radians/second\n  - $b_S = [0.35, 1.00]$\n  - $b_T = [0.70, 0.05]$\n\nFeasibility decision rule:\n- Using the Youla-Kučera parameterization, compute $S(j\\omega)$ and $T(j\\omega)$ from $P(j\\omega)$ and $Q(j\\omega)$ for the family $Q(s) = \\dfrac{k}{s + q_1}$ with $k > 0$ and $q_1 > 0$.\n- For a candidate $(k,q_1)$, constraints are satisfied if and only if for all $\\omega \\in \\Omega$,\n  - $\\lvert S(j\\omega) \\rvert \\le b_S(\\omega)$, and\n  - $\\lvert T(j\\omega) \\rvert \\le b_T(\\omega)$.\n- Your program must search a finite, well-specified grid of $(k,q_1)$ values and return True if at least one candidate satisfies the constraints for that case; otherwise, return False.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the test cases provided: Case 1, Case 2, Case 3. For example: \"[True,False,True]\".", "solution": "The problem requires us to determine the feasibility of satisfying performance specifications on a feedback system using a specific class of controllers. The theoretical framework for this task is the Youla-Kučera parameterization, which characterizes all controllers that internally stabilize a given plant.\n\nThe plant is given by the stable, strictly proper transfer function $P(s) = \\dfrac{1}{s + 1}$. For a stable plant, the set of all stabilizing controllers can be parameterized using a stable, proper transfer function $Q(s)$, the Youla parameter. The key closed-loop transfer functions, the sensitivity function $S(s)$ and the complementary sensitivity function $T(s)$, are expressed as affine functions of $Q(s)$. For the simple coprime factorization of a stable plant where $N(s) = P(s)$ and $D(s)=1$, these relations are:\n$$S(s) = 1 - P(s)Q(s)$$\n$$T(s) = P(s)Q(s)$$\nA fundamental, inviolable relationship between these two functions is $S(s) + T(s) = 1$ for all $s$.\n\nThe candidate Youla parameter is restricted to the family $Q(s) = \\dfrac{k}{s + q_1}$, where $k > 0$ and $q_1 > 0$. This choice ensures $Q(s)$ is stable and strictly proper, as required.\n\nWe substitute the expressions for $P(s)$ and $Q(s)$ into the equations for $S(s)$ and $T(s)$:\n$$T(s) = P(s)Q(s) = \\left(\\frac{1}{s + 1}\\right) \\left(\\frac{k}{s + q_1}\\right) = \\frac{k}{(s+1)(s+q_1)}$$\n$$S(s) = 1 - T(s) = 1 - \\frac{k}{(s+1)(s+q_1)} = \\frac{s^2 + (1+q_1)s + q_1 - k}{(s+1)(s+q_1)}$$\n\nThe performance specifications are given as magnitude bounds at a set of discrete frequencies $\\omega \\in \\Omega$. To check these, we evaluate the functions at $s=j\\omega$:\n$$|T(j\\omega)| = \\frac{|k|}{|j\\omega+1||j\\omega+q_1|} = \\frac{k}{\\sqrt{\\omega^2+1}\\sqrt{\\omega^2+q_1^2}}$$\n$$|S(j\\omega)| = \\frac{|(j\\omega)^2 + (1+q_1)j\\omega + q_1 - k|}{|j\\omega+1||j\\omega+q_1|} = \\frac{|(q_1 - k - \\omega^2) + j\\omega(1+q_1)|}{\\sqrt{\\omega^2+1}\\sqrt{\\omega^2+q_1^2}} = \\frac{\\sqrt{(q_1-k-\\omega^2)^2 + \\omega^2(1+q_1)^2}}{\\sqrt{\\omega^2+1}\\sqrt{\\omega^2+q_1^2}}$$\nFor computational efficiency, we work with squared magnitudes. The constraints are $|T(j\\omega)| \\le b_T(\\omega)$ and $|S(j\\omega)| \\le b_S(\\omega)$, which are equivalent to:\n$$|T(j\\omega)|^2 = \\frac{k^2}{(\\omega^2+1)(\\omega^2+q_1^2)} \\le b_T^2(\\omega)$$\n$$|S(j\\omega)|^2 = \\frac{(q_1-k-\\omega^2)^2 + \\omega^2(1+q_1)^2}{(\\omega^2+1)(\\omega^2+q_1^2)} \\le b_S^2(\\omega)$$\nFor a given test case, a solution is feasible if there exists at least one pair of parameters $(k, q_1)$ with $k>0, q_1>0$ that simultaneously satisfies these two inequalities for all specified frequencies $\\omega \\in \\Omega$.\n\nBefore proceeding to numerical search, we must analyze the fundamental constraint $S+T=1$. By the triangle inequality, $|S(j\\omega)| + |T(j\\omega)| \\ge |S(j\\omega) + T(j\\omega)| = |1| = 1$. This implies that a necessary condition for feasibility at any frequency $\\omega$ is that the bounds must permit this, i.e., $b_S(\\omega) + b_T(\\omega) \\ge 1$. Let us examine the test cases.\n\n- Case 1: All frequency points satisfy $b_S(\\omega) + b_T(\\omega) \\ge 1$. Feasibility is possible.\n  - At $\\omega=0.01: 0.05 + 0.98 = 1.03 \\ge 1$.\n  - At $\\omega=1.0: 0.60 + 0.80 = 1.40 \\ge 1$.\n  - At $\\omega=10.0: 1.00 + 0.20 = 1.20 \\ge 1$.\n\n- Case 2: At $\\omega=1.0$, the bounds are $b_S(1.0) = 0.30$ and $b_T(1.0) = 0.60$.\n  Their sum is $0.30 + 0.60 = 0.90$.\n  This violates the necessary condition, as $0.90 < 1$. It is mathematically impossible to find any controller, regardless of its form, that can simultaneously satisfy $|S(j1.0)| \\le 0.30$ and $|T(j1.0)| \\le 0.60$. Thus, Case 2 is provably infeasible without any search. The correct output must be False.\n\n- Case 3: All frequency points satisfy $b_S(\\omega) + b_T(\\omega) \\ge 1$. Feasibility is possible.\n  - At $\\omega=0.10: 0.35 + 0.70 = 1.05 \\ge 1$.\n  - At $\\omega=10.0: 1.00 + 0.05 = 1.05 \\ge 1$.\n\nFor Cases 1 and 3, feasibility must be determined by a numerical search. We will construct a grid of candidate $(k, q_1)$ values and test each point. A logarithmic grid is appropriate for parameters that span several orders of magnitude. We define a search grid for $k$ and $q_1$ over the range $[10^{-2}, 10^3]$ with $200$ points for each parameter. For each test case, we construct a boolean mask over this grid, initially all True. For each frequency constraint, we update the mask, setting elements to False where the constraint is violated. If any element of the final mask remains True, a feasible parameter set exists.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_feasibility(omegas, bS_vals, bT_vals, k_grid, q1_grid):\n    \"\"\"\n    Checks if a feasible (k, q1) pair exists on the given grid.\n\n    This function vectorizes the constraint checking over the entire grid of\n    (k, q1) parameters for each frequency. It maintains a boolean mask\n    `overall_validity` which represents the feasible region in the parameter space.\n    This mask is updated (by logical AND) for each frequency constraint.\n    \"\"\"\n    # Create 2D meshgrid for vectorized calculations\n    k_mesh, q1_mesh = np.meshgrid(k_grid, q1_grid)\n\n    # Initialize a mask representing the feasible region for (k, q1).\n    # Initially, all points on the grid are considered potentially feasible.\n    overall_validity = np.ones_like(k_mesh, dtype=bool)\n\n    # Sequentially apply constraints for each frequency\n    for i in range(len(omegas)):\n        omega = omegas[i]\n        bS_sq = bS_vals[i]**2\n        bT_sq = bT_vals[i]**2\n\n        omega2 = omega**2\n\n        # Basic check for fundamental infeasibility\n        if bS_vals[i] + bT_vals[i]  1.0 - 1e-9: # Use a small tolerance for float comparison\n            return False\n\n        # Denominator of squared magnitudes of S and T\n        # This term is common to both |S|^2 and |T|^2\n        den_sq = (omega2 + 1.0) * (omega2 + q1_mesh**2)\n\n        # Constraint for T(j*omega): |T|^2 = bT^2\n        T_mag_sq = k_mesh**2 / den_sq\n        T_is_valid = T_mag_sq = bT_sq\n\n        # Constraint for S(j*omega): |S|^2 = bS^2\n        S_num_sq = (q1_mesh - k_mesh - omega2)**2 + omega2 * (1.0 + q1_mesh)**2\n        S_mag_sq = S_num_sq / den_sq\n        S_is_valid = S_mag_sq = bS_sq\n\n        # Update the overall validity mask. A point (k, q1) is only valid\n        # if it satisfies the constraints for ALL frequencies.\n        overall_validity = (T_is_valid  S_is_valid)\n\n    # If any point in the final validity mask is True, a feasible solution exists.\n    return np.any(overall_validity)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General feasibility, multi-frequency shaping\n        {'omegas': [0.01, 1.0, 10.0], 'bS': [0.05, 0.60, 1.00], 'bT': [0.98, 0.80, 0.20]},\n        # Case 2: Provably infeasible necessary condition\n        {'omegas': [1.0], 'bS': [0.30], 'bT': [0.60]},\n        # Case 3: Low-frequency tightness with high-frequency roll-off\n        {'omegas': [0.10, 10.0], 'bS': [0.35, 1.00], 'bT': [0.70, 0.05]},\n    ]\n    \n    # Define the search grid for parameters k and q1.\n    # A logarithmic scale is suitable for control parameters.\n    # Grid: k, q1 in [10^-2, 10^3] with 200 points each.\n    k_grid = np.logspace(-2, 3, 200)\n    q1_grid = np.logspace(-2, 3, 200)\n\n    results = []\n    for case in test_cases:\n        # Determine feasibility for the current case.\n        is_feasible = check_feasibility(\n            omegas=np.array(case['omegas']),\n            bS_vals=np.array(case['bS']),\n            bT_vals=np.array(case['bT']),\n            k_grid=k_grid,\n            q1_grid=q1_grid\n        )\n        results.append(is_feasible)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2697790"}]}