{"hands_on_practices": [{"introduction": "This first practice takes us to the heart of the Linear Quadratic Regulator (LQR) design process. Before relying on an automatic solver, it is essential to understand the algebraic foundations from which the optimal control law originates. This exercise involves deriving the LQR gain for a second-order system by directly solving the algebraic Riccati equation (ARE), providing a first-principles understanding of how optimality maps to a specific, stabilizing feedback gain and guarantees a symmetric closed-loop pole structure [@problem_id:2751329].", "problem": "Consider the continuous-time linear time-invariant state-space system with state matrix $A=\\begin{bmatrix}0 & 1 \\\\ -4 & -1\\end{bmatrix}$ and input matrix $B=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$. Design the Linear Quadratic Regulator (LQR) state-feedback $u=-Kx$ that minimizes the quadratic cost $J=\\int_{0}^{\\infty}\\left(x(t)^{\\top}Qx(t)+u(t)^{\\top}Ru(t)\\right)\\,dt$ with $Q=I$ and $R=1$. \n\nStarting from the algebraic Riccati equation $A^{\\top}P+PA-PBR^{-1}B^{\\top}P+Q=0$ with $P=P^{\\top}\\succ 0$, determine the unique stabilizing solution $P$ and the corresponding optimal gain $K=R^{-1}B^{\\top}P$. Then, using only first principles of second-order stability, verify that the closed-loop matrix $A-BK$ is Hurwitz and that, if its eigenvalues are complex, they occur as a conjugate-symmetric pair, explaining why this symmetry must hold. \n\nIn your final answer, report only the exact feedback gain row vector $K$ in closed form, without numerical approximation and without units. Do not round; no numerical approximation is required.", "solution": "The Linear Quadratic Regulator (LQR) problem with $Q=I$ and $R=1$ yields the algebraic Riccati equation\n$$\nA^{\\top}P+PA-PBR^{-1}B^{\\top}P+Q=0,\n$$\nwhere $P=P^{\\top}\\succ 0$ is the unique stabilizing solution and the optimal state-feedback gain is\n$$\nK=R^{-1}B^{\\top}P=B^{\\top}P.\n$$\nLet $P=\\begin{bmatrix}p & r \\\\ r & s\\end{bmatrix}$ with unknown real scalars $p$, $r$, and $s$. We compute each term in the Riccati equation.\n\nFirst, $A=\\begin{bmatrix}0 & 1 \\\\ -4 & -1\\end{bmatrix}$ and $A^{\\top}=\\begin{bmatrix}0 & -4 \\\\ 1 & -1\\end{bmatrix}$. Then\n$$\nA^{\\top}P=\\begin{bmatrix}0 & -4 \\\\ 1 & -1\\end{bmatrix}\\begin{bmatrix}p & r \\\\ r & s\\end{bmatrix}\n=\\begin{bmatrix}-4r & -4s \\\\ p-r & r-s\\end{bmatrix},\n$$\nand\n$$\nPA=\\begin{bmatrix}p & r \\\\ r & s\\end{bmatrix}\\begin{bmatrix}0 & 1 \\\\ -4 & -1\\end{bmatrix}\n=\\begin{bmatrix}-4r & p-r \\\\ -4s & r-s\\end{bmatrix}.\n$$\nHence\n$$\nA^{\\top}P+PA=\\begin{bmatrix}-8r & p-r-4s \\\\ p-r-4s & 2(r-s)\\end{bmatrix}.\n$$\nNext, with $B=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$ and $R=1$, we have\n$$\nPBR^{-1}B^{\\top}P=PBB^{\\top}P=(PB)(B^{\\top}P).\n$$\nSince $PB=\\begin{bmatrix}r \\\\ s\\end{bmatrix}$ and $B^{\\top}P=\\begin{bmatrix}r & s\\end{bmatrix}$, it follows that\n$$\nPBR^{-1}B^{\\top}P=\\begin{bmatrix}r \\\\ s\\end{bmatrix}\\begin{bmatrix}r & s\\end{bmatrix}\n=\\begin{bmatrix}r^{2} & rs \\\\ rs & s^{2}\\end{bmatrix}.\n$$\nFinally, $Q=I=\\begin{bmatrix}1 & 0 \\\\ 0 & 1\\end{bmatrix}$. Therefore, the Riccati equation becomes\n$$\n\\begin{bmatrix}-8r & p-r-4s \\\\ p-r-4s & 2(r-s)\\end{bmatrix}\n-\n\\begin{bmatrix}r^{2} & rs \\\\ rs & s^{2}\\end{bmatrix}\n+\n\\begin{bmatrix}1 & 0 \\\\ 0 & 1\\end{bmatrix}\n=\n\\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}.\n$$\nEquating entries yields the system\n$$\n\\begin{aligned}\n&-8r-r^{2}+1=0, \\\\\n&p-r-4s-rs=0, \\\\\n&2(r-s)-s^{2}+1=0.\n\\end{aligned}\n$$\nThe first and third equations decouple $r$ and $s$ from $p$. From the $(1,1)$ equation,\n$$\nr^{2}+8r-1=0 \\quad \\Rightarrow \\quad r=-4\\pm\\sqrt{17}.\n$$\nTo obtain a real, stabilizing solution compatible with a positive definite $P$, we must also satisfy the $(2,2)$ equation, $2(r-s)-s^{2}+1=0$. This can be rearranged into the quadratic equation for $s$: $s^{2}+2s-(2r+1)=0$. This equation gives\n$$\ns=-1\\pm\\sqrt{2(r+1)}.\n$$\nIf we choose $r=-4-\\sqrt{17}$, then $r+1=-3-\\sqrt{17}<0$, so $\\sqrt{2(r+1)}$ is not real. Hence the only admissible real branch is\n$$\nr=-4+\\sqrt{17},\n$$\nwhich yields\n$$\ns=-1\\pm\\sqrt{2(r+1)}=-1\\pm\\sqrt{-6+2\\sqrt{17}}.\n$$\nTo obtain the stabilizing positive definite $P$, we select the branch with\n$$\ns=-1+\\sqrt{-6+2\\sqrt{17}},\n$$\nwhich is strictly positive because $-6+2\\sqrt{17}>0$.\n\nWith $r$ and $s$ determined, the $(1,2)$ equation gives $p$:\n$$\np-r-4s-rs=0 \\quad \\Rightarrow \\quad p=r+4s+rs.\n$$\nThus the stabilizing Riccati solution is\n$$\nP=\\begin{bmatrix}p & r \\\\ r & s\\end{bmatrix}\n=\n\\begin{bmatrix}\nr+4s+rs & r \\\\\nr & s\n\\end{bmatrix},\n\\quad\nr=-4+\\sqrt{17},\\quad s=-1+\\sqrt{-6+2\\sqrt{17}}.\n$$\nThe optimal LQR feedback gain is\n$$\nK=R^{-1}B^{\\top}P=B^{\\top}P=\\begin{bmatrix}0 & 1\\end{bmatrix}\\begin{bmatrix}p & r \\\\ r & s\\end{bmatrix}\n=\\begin{bmatrix}r & s\\end{bmatrix}\n=\\begin{bmatrix}-4+\\sqrt{17} & -1+\\sqrt{-6+2\\sqrt{17}}\\end{bmatrix}.\n$$\n\nWe now verify closed-loop stability and conjugate symmetry. The closed-loop matrix under $u=-Kx$ is\n$$\nA-BK=\\begin{bmatrix}0 & 1 \\\\ -4 & -1\\end{bmatrix}-\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}\\begin{bmatrix}r & s\\end{bmatrix}\n=\\begin{bmatrix}0 & 1 \\\\ -4-r & -1-s\\end{bmatrix}.\n$$\nIts characteristic polynomial is\n$$\n\\chi(\\lambda)=\\det\\!\\left(\\lambda I-(A-BK)\\right)\n=\\det\\!\\begin{bmatrix}\\lambda & -1 \\\\ 4+r & \\lambda+1+s\\end{bmatrix}\n=\\lambda^{2}+(1+s)\\lambda+(4+r).\n$$\nFor a real second-order polynomial $\\lambda^{2}+a_{1}\\lambda+a_{0}$, Hurwitz stability is equivalent to $a_{1}>0$ and $a_{0}>0$. Here,\n$$\na_{1}=1+s=\\sqrt{-6+2\\sqrt{17}}>0,\\quad a_{0}=4+r=4+(-4+\\sqrt{17})=\\sqrt{17}>0,\n$$\nso $A-BK$ is Hurwitz.\n\nThe eigenvalues are roots of a real-coefficient polynomial, hence any complex eigenvalues occur in conjugate-symmetric pairs by the Fundamental Theorem of Algebra applied to polynomials with real coefficients. Indeed, the discriminant is\n$$\n\\Delta=(1+s)^{2}-4(4+r)=(-6+2\\sqrt{17}) - 4\\sqrt{17}=-6-2\\sqrt{17}<0,\n$$\nwhich confirms a complex conjugate pair with negative real part. This conjugate symmetry aligns with the symmetric root locus property for real systems under real feedback gains.\n\nTherefore, the exact optimal feedback gain is the row vector\n$$\nK=\\begin{bmatrix}-4+\\sqrt{17} & -1+\\sqrt{-6+2\\sqrt{17}}\\end{bmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}-4+\\sqrt{17} & -1+\\sqrt{-6+2\\sqrt{17}}\\end{pmatrix}}$$", "id": "2751329"}, {"introduction": "Building upon the design of an LQR controller, the next critical step is to analyze its robustness properties. This computational exercise explores the connection between LQR weighting matrices and the frequency-domain characteristics of the closed-loop system. By computing the sensitivity ($S$) and complementary sensitivity ($T$) functions, you will quantify the system's guaranteed stability margins against input and output multiplicative uncertainties, offering a tangible measure of the trade-offs between performance and robustness [@problem_id:2751314].", "problem": "Consider the single-input single-output linear time-invariant plant with transfer function given by the rational function $G(s) = \\dfrac{1}{s(s+1)}$. Use the following minimal continuous-time state-space realization with full-state measurement to uniquely define the interconnection for loop analysis:\n- State-space matrices: $A = \\begin{bmatrix} 0 & 1 \\\\ 0 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$.\n- Measured output equals the full state: $y = x \\in \\mathbb{R}^2$.\n\nA full-state static feedback controller is implemented as $u = -K y$, where the state-feedback gain $K \\in \\mathbb{R}^{1 \\times 2}$ is designed via the Linear Quadratic Regulator (LQR) optimal control framework that minimizes the infinite-horizon quadratic cost\n$$\nJ = \\int_{0}^{\\infty} \\left( x(t)^{\\mathsf{T}} Q x(t) + u(t)^{\\mathsf{T}} R u(t) \\right) \\, dt,\n$$\nwith $Q \\succeq 0$ and $R \\succ 0$. The optimal gain $K$ is computed from the unique positive semidefinite stabilizing solution $P$ of the continuous-time algebraic Riccati equation\n$$\nA^{\\mathsf{T}} P + P A - P B R^{-1} B^{\\mathsf{T}} P + Q = 0,\n$$\nvia $K = R^{-1} B^{\\mathsf{T}} P$.\n\nDefine the loop transfer matrix from the measurement $y$ to itself, induced by the unity-feedback interconnection with the full-state controller, as\n$$\nL(s) = \\left( s I - A \\right)^{-1} B \\left( -K \\right) \\in \\mathbb{C}^{2 \\times 2}.\n$$\nDefine the sensitivity and complementary sensitivity matrices by\n$$\nS(s) = \\left( I + L(s) \\right)^{-1}, \\qquad T(s) = I - S(s),\n$$\nwhere $I$ denotes the $2 \\times 2$ identity matrix. For frequency-domain analysis, evaluate these matrices on the imaginary axis $s = j \\omega$ with angular frequency $\\omega$ expressed in radians per second.\n\nScientific base and objectives:\n- The Bode magnitude for a multiple-input multiple-output (MIMO) matrix transfer function at a given frequency is taken to be the induced $2$-norm, i.e., the largest singular value. For a matrix $M(j\\omega)$, denote this magnitude as $\\bar{\\sigma}\\left( M(j\\omega) \\right)$.\n- The robustness relevance is as follows. Under multiplicative output uncertainty bounded in induced norm by $\\rho_{\\text{out}}$, robust stability is certified by $\\sup_{\\omega} \\bar{\\sigma}\\big( T(j\\omega) \\big) \\cdot \\rho_{\\text{out}} < 1$, hence the largest tolerable bound is $\\rho_{\\text{out}}^{\\star} = 1 / \\left\\| T \\right\\|_{\\infty}$ where $\\left\\| T \\right\\|_{\\infty} = \\sup_{\\omega} \\bar{\\sigma}\\big( T(j\\omega) \\big)$. Similarly, for multiplicative input uncertainty bounded by $\\rho_{\\text{in}}$, a sufficient condition is $\\left\\| S \\right\\|_{\\infty} \\cdot \\rho_{\\text{in}} < 1$, giving $\\rho_{\\text{in}}^{\\star} = 1 / \\left\\| S \\right\\|_{\\infty}$. These are standard sufficient conditions derived from small-gain principles.\n- The root-locus symmetry about the real axis for closed-loop poles under real-valued gains follows from complex conjugation symmetry of polynomial coefficients; you will connect how LQR weight choices shift closed-loop poles and thereby affect the Bode magnitudes of $S$ and $T$ and the implied robustness margins.\n\nTasks:\n1. For each LQR weight set below, compute the optimal $K$, then compute $S(j\\omega)$ and $T(j\\omega)$ over a logarithmically spaced grid of $300$ angular frequencies $\\omega$ from $10^{-3}$ to $10^{3}$ radians per second (inclusive). For each matrix function, compute its approximate $\\mathcal{H}_{\\infty}$ norm as the maximum over the grid of its largest singular value:\n   $$\n   \\left\\| S \\right\\|_{\\infty} \\approx \\max_{\\omega} \\bar{\\sigma}\\left( S(j\\omega) \\right), \\qquad\n   \\left\\| T \\right\\|_{\\infty} \\approx \\max_{\\omega} \\bar{\\sigma}\\left( T(j\\omega) \\right).\n   $$\n   Then compute the inferred robustness margins $\\rho_{\\text{in}}^{\\star} = 1 / \\left\\| S \\right\\|_{\\infty}$ and $\\rho_{\\text{out}}^{\\star} = 1 / \\left\\| T \\right\\|_{\\infty}$.\n\n2. Use the following test suite of LQR weights:\n   - Case 1 (moderate control effort): $Q_1 = \\mathrm{diag}(1,\\,0.1)$, $R_1 = 0.5$.\n   - Case 2 (aggressive state regulation): $Q_2 = \\mathrm{diag}(10,\\,1)$, $R_2 = 0.05$.\n\n3. Report, for each case, the four floats in the order $\\left\\| S \\right\\|_{\\infty}$, $\\left\\| T \\right\\|_{\\infty}$, $\\rho_{\\text{in}}^{\\star}$, $\\rho_{\\text{out}}^{\\star}$, rounded to six decimal places.\n\n4. Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n   $$\n   \\big[ \\left\\| S \\right\\|_{\\infty}^{(1)}, \\left\\| T \\right\\|_{\\infty}^{(1)}, \\rho_{\\text{in}}^{\\star (1)}, \\rho_{\\text{out}}^{\\star (1)}, \\left\\| S \\right\\|_{\\infty}^{(2)}, \\left\\| T \\right\\|_{\\infty}^{(2)}, \\rho_{\\text{in}}^{\\star (2)}, \\rho_{\\text{out}}^{\\star (2)} \\big],\n   $$\n   where the superscripts $(1)$ and $(2)$ denote Case 1 and Case 2 respectively. No units are required for the magnitudes because they are dimensionless.\n\nNotes and interpretive requirement (to be addressed in your solution reasoning, not in the program output):\n- Explain, from first principles, why the root-locus of the closed-loop poles under real-valued gains is symmetric about the real axis and how the LQR weight choices shift the poles, thereby influencing the Bode magnitudes of $S$ and $T$.\n- Connect the computed differences in $\\left\\| S \\right\\|_{\\infty}$ and $\\left\\| T \\right\\|_{\\infty}$ between the two cases to the input and output multiplicative uncertainty robustness margins $\\rho_{\\text{in}}^{\\star}$ and $\\rho_{\\text{out}}^{\\star}$ as defined above.\n\nAngle units: All angular frequencies must be in radians per second. Numerical outputs must be rounded to six decimal places as specified above.", "solution": "We begin from the foundational definitions for linear time-invariant systems and their feedback interconnections. The given single-input single-output plant has transfer function $G(s) = \\dfrac{1}{s(s+1)}$. A minimal state-space realization with full-state measurement is specified by\n$$\nA = \\begin{bmatrix} 0 & 1 \\\\ 0 & -1 \\end{bmatrix}, \\quad\nB = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad\ny = x \\in \\mathbb{R}^2.\n$$\nThe controller is full-state feedback $u = -K y$ with $K \\in \\mathbb{R}^{1 \\times 2}$ designed by the Linear Quadratic Regulator (LQR). The LQR design problem minimizes\n$$\nJ = \\int_{0}^{\\infty} \\left( x^{\\mathsf{T}} Q x + u^{\\mathsf{T}} R u \\right) dt,\n$$\nwhere $Q \\succeq 0$ and $R \\succ 0$. The well-tested result from optimal control theory is that the optimal $K$ is obtained by solving the continuous-time algebraic Riccati equation (CARE)\n$$\nA^{\\mathsf{T}} P + P A - P B R^{-1} B^{\\mathsf{T}} P + Q = 0\n$$\nfor the unique positive semidefinite stabilizing solution $P$, then\n$$\nK = R^{-1} B^{\\mathsf{T}} P.\n$$\n\nTo analyze loop properties, we explicitly form the unity-feedback interconnection between the measured output and the controller input. The transfer from control input to measured output is\n$$\nG_{yu}(s) = (s I - A)^{-1} B \\in \\mathbb{C}^{2 \\times 1}.\n$$\nThe loop transfer matrix from $y$ to $y$ induced by the controller $u = -K y$ is\n$$\nL(s) = G_{yu}(s) (-K) \\in \\mathbb{C}^{2 \\times 2}.\n$$\nThe sensitivity and complementary sensitivity matrices are\n$$\nS(s) = (I + L(s))^{-1}, \\qquad T(s) = I - S(s) = L(s) (I + L(s))^{-1}.\n$$\nFor multiple-input multiple-output systems, a standard Bode magnitude at a given frequency is the induced $2$-norm, the largest singular value. For a matrix $M(j\\omega)$, denote this as $\\bar{\\sigma}(M(j\\omega))$. The $\\mathcal{H}_{\\infty}$ norm of $M$ is $\\|M\\|_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}(M(j\\omega))$. We approximate this supremum on a logarithmic frequency grid $\\omega \\in [10^{-3}, 10^{3}]$ radians per second using $300$ points.\n\nRobustness margins from small-gain reasoning:\n- Consider multiplicative output uncertainty represented as $\\tilde{G}(s) = G(s) (I + \\Delta_{\\text{out}}(s))$ with $\\|\\Delta_{\\text{out}}\\|_{\\infty} \\le \\rho_{\\text{out}}$. In the standard interconnection, robust stability is ensured if $\\| T \\|_{\\infty} \\cdot \\rho_{\\text{out}} < 1$, so the largest tolerable bound is\n$$\n\\rho_{\\text{out}}^{\\star} = \\frac{1}{\\|T\\|_{\\infty}}.\n$$\n- For multiplicative input uncertainty represented as $\\tilde{G}(s) = (I + \\Delta_{\\text{in}}(s)) G(s)$ with $\\|\\Delta_{\\text{in}}\\|_{\\infty} \\le \\rho_{\\text{in}}$, the sufficient small-gain condition is $\\| S \\|_{\\infty} \\cdot \\rho_{\\text{in}} < 1$, leading to\n$$\n\\rho_{\\text{in}}^{\\star} = \\frac{1}{\\|S\\|_{\\infty}}.\n$$\nThese are well-tested sufficient conditions linking sensitivity functions to robustness margins.\n\nSymmetric root locus and LQR effects:\n- The closed-loop state matrix is $A_{\\text{cl}} = A - B K$. Because $A$, $B$, and $K$ are real, the characteristic polynomial of $A_{\\text{cl}}$ has real coefficients. It follows from fundamental properties of polynomials with real coefficients that complex eigenvalues occur in conjugate pairs, implying that the locus of closed-loop poles as gains vary is symmetric about the real axis in the complex plane. This is the symmetric root locus property.\n- Changing the LQR weights $(Q, R)$ modifies the solution $P$ and thereby $K = R^{-1} B^{\\mathsf{T}} P$. Increasing state penalties (entries of $Q$) or decreasing control penalty $R$ typically produces larger gain magnitudes and shifts closed-loop poles further left (higher bandwidth), which often reduces low-frequency sensitivity but can increase peaking in $\\bar{\\sigma}(T(j\\omega))$ near the crossover frequency due to reduced damping. Conversely, larger $R$ or smaller $Q$ reduce bandwidth, often increasing $\\|S\\|_{\\infty}$ (poorer disturbance attenuation) and sometimes reducing high-frequency peaking in $T$ (potentially improving tolerance to output multiplicative uncertainty at high frequencies). The computed $\\|S\\|_{\\infty}$ and $\\|T\\|_{\\infty}$ thus quantify these trade-offs and map directly to the robustness margins $\\rho_{\\text{in}}^{\\star}$ and $\\rho_{\\text{out}}^{\\star}$ as above.\n\nAlgorithmic steps for each case:\n1. Form $Q$ and $R$.\n2. Solve the CARE for $P$ and compute $K = R^{-1} B^{\\mathsf{T}} P$.\n3. Over the grid of $\\omega$ values, compute $G_{yu}(j\\omega) = (j\\omega I - A)^{-1} B$, then $L(j\\omega) = G_{yu}(j\\omega) (-K)$, $S(j\\omega) = (I + L(j\\omega))^{-1}$, and $T(j\\omega) = I - S(j\\omega)$.\n4. At each $\\omega$, compute the largest singular values $\\bar{\\sigma}(S(j\\omega))$ and $\\bar{\\sigma}(T(j\\omega))$.\n5. Approximate $\\|S\\|_{\\infty}$ and $\\|T\\|_{\\infty}$ by taking the maxima over the grid; then compute $\\rho_{\\text{in}}^{\\star} = 1/\\|S\\|_{\\infty}$ and $\\rho_{\\text{out}}^{\\star} = 1/\\|T\\|_{\\infty}$.\n6. Round the four outputs for each case to six decimal places and present them in the specified single-line list format.\n\nInterpretation of expected differences:\n- Case 2 uses larger state penalties and a smaller control penalty than Case 1, which typically yields a larger feedback gain $K$, increased closed-loop bandwidth, and thus smaller low-frequency sensitivity (potentially reducing $\\|S\\|_{\\infty}$) but possibly larger complementary sensitivity peaking near crossover (potentially increasing $\\|T\\|_{\\infty}$). Hence, one might expect $\\rho_{\\text{in}}^{\\star}$ to be larger and $\\rho_{\\text{out}}^{\\star}$ to be smaller in Case 2 relative to Case 1, although the exact values are determined by the computation.\n- The symmetric root locus property is reflected in the complex conjugate symmetry of the closed-loop poles $A - BK$ for both cases. The more aggressive weights in Case 2 shift these poles further left (higher natural frequencies and damping configurations), which reshapes the frequency response magnitudes of $S$ and $T$ and thus the computed robustness margins.\n\nAll computations use angular frequency in radians per second, and the final reported magnitudes are dimensionless.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_continuous_are\n\ndef lqr_gain(A, B, Q, R):\n    # Solve CARE: A^T P + P A - P B R^{-1} B^T P + Q = 0\n    P = solve_continuous_are(A, B, Q, R)\n    # K = R^{-1} B^T P\n    R_inv = 1.0 / R if np.ndim(R) == 0 else np.linalg.inv(R)\n    K = R_inv * (B.T @ P)\n    return K, P\n\ndef hinf_norms_S_T(A, B, K, w_grid):\n    I = np.eye(A.shape[0])\n    max_sv_S = 0.0\n    max_sv_T = 0.0\n    for w in w_grid:\n        sI_minus_A = 1j * w * I - A\n        # G_yu(jw) = (jw I - A)^(-1) B\n        Gyu = np.linalg.solve(sI_minus_A, B)  # shape (n,1)\n        # L(jw) = G_yu(jw) * (-K)\n        L = Gyu @ (-K)  # shape (n,n)\n        # S = (I + L)^(-1)\n        S = np.linalg.inv(I + L)\n        T = I - S\n        # Largest singular values\n        sv_S = np.linalg.svd(S, compute_uv=False)\n        sv_T = np.linalg.svd(T, compute_uv=False)\n        max_sv_S = max(max_sv_S, float(np.max(sv_S)))\n        max_sv_T = max(max_sv_T, float(np.max(sv_T)))\n    return max_sv_S, max_sv_T\n\ndef solve():\n    # Plant definition\n    A = np.array([[0.0, 1.0],\n                  [0.0, -1.0]])\n    B = np.array([[0.0],\n                  [1.0]])\n\n    # Frequency grid (rad/s)\n    w_grid = np.logspace(-3, 3, 300)\n\n    # Test cases: (Q, R)\n    test_cases = [\n        (np.diag([1.0, 0.1]), 0.5),   # Case 1: moderate control effort\n        (np.diag([10.0, 1.0]), 0.05), # Case 2: aggressive state regulation\n    ]\n\n    results = []\n    for Q, R in test_cases:\n        K, _ = lqr_gain(A, B, Q, R)\n        norm_S, norm_T = hinf_norms_S_T(A, B, K, w_grid)\n        # Robustness margins\n        rho_in = 1.0 / norm_S if norm_S > 0 else float('inf')\n        rho_out = 1.0 / norm_T if norm_T > 0 else float('inf')\n        # Round to six decimals for output stability\n        results.extend([\n            f\"{norm_S:.6f}\",\n            f\"{norm_T:.6f}\",\n            f\"{rho_in:.6f}\",\n            f\"{rho_out:.6f}\",\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2751314"}, {"introduction": "In most practical scenarios, not all state variables are directly measurable, necessitating the use of a state estimator like a Kalman filter. While combining an LQR controller with a Kalman filter yields a Linear-Quadratic-Gaussian (LQG) controller, this can compromise the excellent robustness guarantees of the original LQR design. This final practice demonstrates the powerful technique of Loop Transfer Recovery (LTR), showing numerically how to tune the estimator to recover the desirable loop-shaping properties of the state-feedback LQR system, thus bridging the gap between ideal theory and practical implementation [@problem_id:2751321].", "problem": "You are given a continuous-time, single-input single-output, linear time-invariant state-space model with real coefficients. Your task is to implement a numerical study of Loop Transfer Recovery (LTR) for a Linear Quadratic Gaussian (LQG) regulator, and to verify the symmetry property of the root locus for real systems. Your program must compute the Linear Quadratic Regulator (LQR), the Kalman filter for several Linear Quadratic Gaussian (LQG) noise intensity values, and frequency-domain loop transfer magnitudes to demonstrate that the LQG input-loop transfer approaches the state-feedback LQR loop as the Loop Transfer Recovery (LTR) tuning parameter increases. Additionally, your program must check the symmetric root locus property by evaluating the eigenvalues of the closed-loop state matrix under scalar gain variation.\n\nUse the following fixed plant and design data:\n- State matrix: \n$$\nA = \\begin{bmatrix}\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n-3 & -3 & -1\n\\end{bmatrix}\n$$\n- Input matrix:\n$$\nB = \\begin{bmatrix}\n0 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n$$\n- Output matrix:\n$$\nC = \\begin{bmatrix}\n1 & 0 & 0\n\\end{bmatrix}\n$$\n- Direct feedthrough:\n$$\nD = \\begin{bmatrix}\n0\n\\end{bmatrix}\n$$\n\nDesign an Linear Quadratic Regulator (LQR) state-feedback gain using the standard algebraic Riccati equation with:\n- State weighting:\n$$\nQ = \\mathrm{diag}(10,\\,1,\\,1)\n$$\n- Control weighting:\n$$\nR = \\begin{bmatrix}\n1\n\\end{bmatrix}\n$$\n\nDesign a continuous-time steady-state Kalman filter (the estimator of a Linear Quadratic Gaussian (LQG) regulator) using the estimator algebraic Riccati equation with measurement noise covariance and process noise covariance defined as:\n- Measurement noise covariance:\n$$\nV = \\begin{bmatrix}\n1\n\\end{bmatrix}\n$$\n- Process noise covariance for Loop Transfer Recovery (LTR):\n$$\nW(\\alpha) = \\alpha \\, I_3\n$$\nfor the tuning parameter values\n$$\n\\alpha \\in \\{10^{-3},\\,10^{-1},\\,10^{1},\\,10^{3}\\}.\n$$\n\nDefine the following transfer functions in the complex frequency domain $s = j \\omega$ for $\\omega > 0$:\n1. The state-feedback LQR loop element (a scalar transfer function) at the plant input:\n$$\nL_{\\mathrm{LQR}}(s) \\triangleq K \\, (s I - A)^{-1} B,\n$$\nwhere $K$ is the LQR gain.\n2. The Linear Quadratic Gaussian (LQG) input-loop transfer element formed by the plant, the estimator, and the LQR gain:\n$$\nL_{\\mathrm{LQG}}(s;\\alpha) \\triangleq K \\left(s I - (A - B K - L(\\alpha) C)\\right)^{-1} L(\\alpha) \\, C \\, (s I - A)^{-1} B,\n$$\nwhere $L(\\alpha)$ is the Kalman filter gain obtained from solving the estimator Riccati equation with $W(\\alpha)$ and $V$.\n\nYour program must:\n- Compute the LQR gain $K$ and, for each specified $\\alpha$, compute the Kalman gain $L(\\alpha)$.\n- Evaluate the magnitudes $\\lvert L_{\\mathrm{LQR}}(j \\omega)\\rvert$ and $\\lvert L_{\\mathrm{LQG}}(j \\omega;\\alpha)\\rvert$ on a logarithmically spaced grid of frequencies\n$$\n\\omega \\in \\left[10^{-2},\\,10^{2}\\right] \\ \\text{radians/second}\n$$\nwith at least $100$ points.\n- For each $\\alpha$, compute the mean relative magnitude error over the frequency grid:\n$$\nE(\\alpha) \\triangleq \\frac{1}{N} \\sum_{i=1}^{N} \\frac{\\left|\\,\\lvert L_{\\mathrm{LQG}}(j \\omega_i;\\alpha)\\rvert - \\lvert L_{\\mathrm{LQR}}(j \\omega_i)\\rvert\\,\\right|}{\\lvert L_{\\mathrm{LQR}}(j \\omega_i)\\rvert + \\varepsilon},\n$$\nwith $N$ the number of frequency points and $\\varepsilon = 10^{-9}$ a small positive number to avoid division by zero.\n\nAdditionally, verify numerically the symmetric root locus property as follows. For a real closed-loop state matrix of the form\n$$\nA_{\\gamma} \\triangleq A - \\gamma \\, B K,\n$$\nwith scalar gain $\\gamma > 0$, the eigenvalues should be symmetric with respect to the real axis; that is, if $\\lambda$ is an eigenvalue with nonzero imaginary part, then its complex conjugate $\\overline{\\lambda}$ must also be an eigenvalue. Test this property for\n$$\n\\gamma \\in \\{10^{-1},\\, 1,\\, 10\\}.\n$$\nDefine a numerical tolerance $\\tau = 10^{-7}$ on the imaginary parts and pairwise matching.\n\nTest suite to implement and evaluate:\n- LTR tuning parameters:\n$$\n\\alpha \\in \\{10^{-3},\\,10^{-1},\\,10^{1},\\,10^{3}\\}.\n$$\n- Root locus gain values:\n$$\n\\gamma \\in \\{10^{-1},\\, 1,\\, 10\\}.\n$$\n- Frequency grid:\n$$\n\\omega \\in \\left[10^{-2},\\,10^{2}\\right] \\ \\text{radians/second}\n$$\nwith $N = 150$ logarithmically spaced points.\n\nOutput specification:\n- Your program must output a single line containing a list with five entries:\n    - Four floating-point values corresponding to $E(10^{-3})$, $E(10^{-1})$, $E(10^{1})$, and $E(10^{3})$ in that order.\n    - One boolean value indicating whether the symmetric root locus property holds for all tested $\\gamma$ values within tolerance $\\tau$.\n- The output must be printed exactly as a comma-separated list enclosed in square brackets, for example:\n$$\n[\\text{E1},\\text{E2},\\text{E3},\\text{E4},\\text{bool}]\n$$\nNo additional text should be printed.\n\nAll numerical values are dimensionless, and no physical units are required. Angles (frequencies) are in radians per second by definition of $s = j \\omega$ and must be treated as such. The final answers for the error metrics must be floating-point numbers, and the symmetry verification must be a boolean. Your solution must be computationally self-contained and not require any user input.", "solution": "The problem statement has been rigorously validated and is deemed valid. It is scientifically grounded in the principles of modern control theory, specifically concerning the design and analysis of Linear Quadratic Regulator (LQR), Linear Quadratic Gaussian (LQG) controllers, and the associated Loop Transfer Recovery (LTR) methodology. The problem is well-posed, with all necessary parameters and definitions provided to ensure a unique, computable solution. All terms are objective and precisely defined. We will now proceed with a systematic, principle-based solution.\n\nThe solution is structured into four main parts:\n1.  Synthesis of the LQR state-feedback gain $K$.\n2.  Synthesis of the Kalman filter gain $L(\\alpha)$ for each specified noise intensity parameter $\\alpha$.\n3.  Numerical evaluation of Loop Transfer Recovery by comparing the frequency responses of the LQR and LQG loop transfer functions.\n4.  Numerical verification of the symmetric root locus property for a real linear system.\n\n**1. LQR Controller Synthesis**\n\nThe objective of the LQR design is to find the optimal state-feedback gain matrix $K$ for the control law $u = -Kx$ that minimizes the quadratic cost function:\n$$\nJ = \\int_{0}^{\\infty} (x^T Q x + u^T R u) \\, dt\n$$\nFor a continuous-time linear time-invariant (LTI) system $\\dot{x} = Ax + Bu$, the optimal gain $K$ is found by first solving the continuous-time Algebraic Riccati Equation (CARE) for the unique, symmetric, positive semi-definite matrix $P$:\n$$\nA^T P + P A - P B R^{-1} B^T P + Q = 0\n$$\nGiven the system matrices $A$ and $B$, and the weighting matrices $Q = \\mathrm{diag}(10, 1, 1)$ and $R = [1]$, we solve this equation for $P$. The system pair $(A, B)$ is controllable, and the pair $(A, Q^{1/2})$ is observable, which guarantees the existence of a unique positive definite solution $P$ that stabilizes the closed-loop system $A-BK$.\n\nThe optimal LQR gain is then calculated as:\n$$\nK = R^{-1} B^T P\n$$\nThis gain matrix $K$ will be used both for the state-feedback loop transfer function and in the construction of the LQG controller.\n\n**2. Kalman Filter Synthesis**\n\nThe LQG controller uses a state estimator, which in this case is a continuous-time steady-state Kalman filter. The filter estimates the system state $x$ based on the measured output $y = Cx + v$, where $v$ is measurement noise. The dynamics are driven by process noise $w$, such that $\\dot{x} = Ax + Bu + w$. The filter design requires solving a dual version of the CARE. The filter error covariance matrix $X$ is the symmetric, positive semi-definite solution to the estimator ARE:\n$$\nA X + X A^T - X C^T V^{-1} C X + W = 0\n$$\nHere, $W$ and $V$ are the process and measurement noise covariance matrices, respectively. We are given $V = [1]$ and a tunable process noise covariance $W(\\alpha) = \\alpha I_3$, where $\\alpha$ is the LTR tuning parameter taking values in $\\{10^{-3}, 10^{-1}, 10^{1}, 10^{3}\\}$. The system pair $(A, C)$ is observable, and for $\\alpha > 0$, the pair $(A, W(\\alpha)^{1/2})$ is controllable, ensuring a unique, positive definite, stabilizing solution $X$ exists for each $\\alpha$.\n\nThe Kalman filter gain $L(\\alpha)$ is then computed as:\n$$\nL(\\alpha) = X C^T V^{-1}\n$$\nThis procedure is repeated for each value of $\\alpha$.\n\n**3. Loop Transfer Recovery (LTR) Analysis**\n\nLTR is a procedure to shape the loop transfer function of an LQG system to recover the desirable properties (e.g., robustness) of a target LQR loop. We will numerically verify the convergence of the LQG loop transfer function to the LQR loop transfer function as the parameter $\\alpha$ increases.\n\nFirst, we define the LQR loop transfer function (breaking the loop at the plant input):\n$$\nL_{\\mathrm{LQR}}(s) = K (s I - A)^{-1} B\n$$\nNext, we use the problem-defined LQG input-loop transfer function, which combines the plant $G_p(s) = C(sI-A)^{-1}B$ and the LQG compensator:\n$$\nL_{\\mathrm{LQG}}(s;\\alpha) = K \\left(s I - (A - B K - L(\\alpha) C)\\right)^{-1} L(\\alpha) \\, C \\, (s I - A)^{-1} B\n$$\nThe LTR theorem suggests that, under certain conditions, as the intensity of the process noise is increased relative to the measurement noise (i.e., as $\\alpha \\to \\infty$), the magnitude of the LQG loop transfer function should approach that of the LQR loop. We will evaluate the magnitudes $|L_{\\mathrm{LQR}}(j\\omega)|$ and $|L_{\\mathrm{LQG}}(j\\omega; \\alpha)|$ over a logarithmic grid of frequencies $\\omega \\in [10^{-2}, 10^{2}]$ with $N=150$ points.\n\nFor each $\\alpha$, we quantify the recovery error using the mean relative magnitude error:\n$$\nE(\\alpha) = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{\\left|\\,|L_{\\mathrm{LQG}}(j \\omega_i;\\alpha)| - |L_{\\mathrm{LQR}}(j \\omega_i)|\\,\\right|}{|L_{\\mathrm{LQR}}(j \\omega_i)| + \\varepsilon}\n$$\nwhere $\\varepsilon = 10^{-9}$ is a regularization constant. We expect $E(\\alpha)$ to decrease as $\\alpha$ increases.\n\n**4. Symmetric Root Locus Verification**\n\nA fundamental property of any LTI system described by real-valued matrices is that the characteristic polynomial has real coefficients. Consequently, the roots of this polynomial—the system's eigenvalues—must appear in complex conjugate pairs. If $\\lambda$ is an eigenvalue, then its complex conjugate $\\overline{\\lambda}$ must also be an eigenvalue.\n\nWe will verify this property for the closed-loop system matrix:\n$$\nA_{\\gamma} = A - \\gamma B K\n$$\nfor a varying scalar gain $\\gamma > 0$. The eigenvalues of $A_{\\gamma}$ for $\\gamma \\in \\{10^{-1}, 1, 10\\}$ will be computed. For each set of eigenvalues, we will implement a numerical check. The set of complex eigenvalues (those with an imaginary part exceeding a tolerance $\\tau = 10^{-7}$) will be partitioned. We then verify that for each complex eigenvalue $\\lambda = a + jb$ in the set, its conjugate $\\overline{\\lambda} = a - jb$ is also present, within the specified tolerance. The property is considered to hold if all complex eigenvalues for all tested values of $\\gamma$ can be successfully paired.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_continuous_are\n\ndef solve():\n    \"\"\"\n    Performs a numerical study of Loop Transfer Recovery (LTR) for an LQG regulator\n    and verifies the symmetric root locus property for a given LTI system.\n    \"\"\"\n    # Define constants and system matrices from the problem statement.\n    A = np.array([[0., 1., 0.], [0., 0., 1.], [-3., -3., -1.]])\n    B = np.array([[0.], [0.], [1.]])\n    C = np.array([[1., 0., 0.]])\n    # D is zero and not explicitly needed for the requested calculations.\n\n    # LQR design parameters\n    Q = np.diag([10., 1., 1.])\n    R = np.array([[1.]])\n\n    # LTR and Kalman filter parameters\n    alphas = [1e-3, 1e-1, 1e1, 1e3]\n    V = np.array([[1.]])\n\n    # Symmetric root locus parameters\n    gammas = [1e-1, 1., 10.]\n\n    # Numerical parameters\n    N_omega = 150\n    omega = np.logspace(-2, 2, N_omega)\n    epsilon = 1e-9\n    tau = 1e-7\n\n    # --- Part 1: LQR Controller Synthesis ---\n    # Solve the continuous-time Algebraic Riccati Equation (CARE) for P\n    # A'P + PA - PBR^-1B'P + Q = 0\n    try:\n        P = solve_continuous_are(A, B, Q, R)\n    except np.linalg.LinAlgError:\n        print(\"[Error: LQR Riccati solver failed]\")\n        return\n        \n    # Calculate the LQR gain K = R^-1 B' P\n    K = np.linalg.inv(R) @ B.T @ P\n\n    # --- Part 2 & 3: LTR Analysis ---\n    #\n    # 2.1: Evaluate the LQR loop transfer magnitude |L_LQR(jw)|\n    s_grid = 1j * omega\n    mag_lqr = np.zeros(N_omega, dtype=float)\n    inv_sI_A_grid = np.array([np.linalg.inv(s * np.identity(3) - A) for s in s_grid])\n    for i in range(N_omega):\n        # L_LQR(s) = K * (sI - A)^-1 * B\n        L_lqr_s = K @ inv_sI_A_grid[i] @ B\n        mag_lqr[i] = np.abs(L_lqr_s[0, 0])\n\n    errors = []\n    for alpha in alphas:\n        # 2.2: Design Kalman filter for the current alpha\n        # Process noise covariance W(alpha) = alpha * I_3\n        W = alpha * np.identity(3)\n        \n        # Solve the dual CARE for the filter error covariance X\n        # AX + XA' - XC'V^-1CX + W = 0\n        # Use solver with substitutions: A->A.T, B->C.T, R->V, Q->W\n        try:\n            X = solve_continuous_are(A.T, C.T, W, V)\n        except np.linalg.LinAlgError:\n            print(f\"[Error: Kalman Riccati solver failed for alpha={alpha}]\")\n            return\n\n        # Calculate the Kalman gain L = X C' V^-1\n        L_gain = X @ C.T @ np.linalg.inv(V)\n\n        # 2.3: Evaluate the LQG loop transfer magnitude |L_LQG(jw; alpha)|\n        mag_lqg = np.zeros(N_omega, dtype=float)\n        # LQG closed-loop system matrix for the controller state\n        A_lqg_controller = A - B @ K - L_gain @ C\n        \n        for i in range(N_omega):\n            s = s_grid[i]\n            # L_LQG(s) = K * (sI - (A-BK-LC))^-1 * L * C * (sI-A)^-1 * B\n            inv_sI_A_lqg_ctrl = np.linalg.inv(s * np.identity(3) - A_lqg_controller)\n            inv_sI_A = inv_sI_A_grid[i]\n            \n            L_lqg_s = K @ inv_sI_A_lqg_ctrl @ L_gain @ C @ inv_sI_A @ B\n            mag_lqg[i] = np.abs(L_lqg_s[0, 0])\n\n        # 2.4: Compute the mean relative magnitude error E(alpha)\n        relative_error = np.abs(mag_lqg - mag_lqr) / (mag_lqr + epsilon)\n        mean_error = np.mean(relative_error)\n        errors.append(mean_error)\n\n    # --- Part 4: Symmetric Root Locus Verification ---\n    symmetry_holds_all = True\n    for gamma in gammas:\n        A_gamma = A - gamma * B @ K\n        eigenvalues = np.linalg.eigvals(A_gamma)\n        \n        # Create a list of eigenvalues not yet paired.\n        unpaired_evs = list(eigenvalues)\n        has_unpaired_complex = False\n\n        while unpaired_evs:\n            ev = unpaired_evs.pop(0)\n            \n            # If eigenvalue is effectively real, it needs no conjugate pair.\n            if np.abs(ev.imag) <= tau:\n                continue\n            \n            # If it's a complex eigenvalue, find its conjugate in the remaining list.\n            found_conjugate = False\n            conjugate_idx = -1\n            for idx, other_ev in enumerate(unpaired_evs):\n                if np.abs(ev.real - other_ev.real) < tau and \\\n                   np.abs(ev.imag + other_ev.imag) < tau:\n                    conjugate_idx = idx\n                    found_conjugate = True\n                    break\n            \n            if found_conjugate:\n                # Remove the found conjugate from the list.\n                unpaired_evs.pop(conjugate_idx)\n            else:\n                # A complex eigenvalue was found without a conjugate pair.\n                has_unpaired_complex = True\n                break\n        \n        if has_unpaired_complex:\n            symmetry_holds_all = False\n            break\n\n    # Assemble and print the final results in the specified format.\n    final_output = errors + [symmetry_holds_all]\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "2751321"}]}