{"hands_on_practices": [{"introduction": "A cornerstone of robust control is ensuring that system states and inputs remain within safe operating limits, even in the worst-case scenario. The most direct way to achieve this is by tightening the constraints on the nominal system, creating a \"buffer\" to absorb disturbances. This practice introduces the Pontryagin difference, the fundamental mathematical operator for computing these tightened constraint sets, providing a clear, hands-on calculation for the common case of hypercubic sets defined by the infinity norm. [@problem_id:2746569]", "problem": "Consider a robust Model Predictive Control (MPC) setup for a discrete-time system with an additive disturbance entering the state update, where only the state constraint set and the disturbance set are relevant in this task. The constraint set for the true state at each prediction step is the axis-aligned hypercube given by $X=\\{x\\in\\mathbb{R}^{n}:\\|x\\|_{\\infty}\\le 1\\}$, and the additive disturbance belongs to the uncertainty set $E=\\{e\\in\\mathbb{R}^{n}:\\|e\\|_{\\infty}\\le 0.2\\}$. In robust MPC, one common technique to ensure one-step robust feasibility is to impose the tightened constraint $x\\in X\\ominus E$ on the nominal state, where $\\ominus$ denotes the Pontryagin set difference.\n\nStarting only from core definitions and properties of norms and set operations, compute the Pontryagin difference $X\\ominus E$ as a closed-form set expression, and verify the resulting coordinate-wise margins implied by this tightening. Then, justify (using first principles) why the tightened set you obtained ensures that $x+e\\in X$ for all $e\\in E$ whenever $x\\in X\\ominus E$.\n\nProvide your final answer as the single closed-form expression for $X\\ominus E$. No numerical rounding is required. Express your final answer purely as a set in terms of $\\|\\cdot\\|_{\\infty}$ without additional commentary.", "solution": "The problem requires the computation and justification of a tightened constraint set used in robust Model Predictive Control. We are given the state constraint set $X$ and the disturbance set $E$, and we must find the Pontryagin difference $X \\ominus E$.\n\nFirst, we state the definitions provided in the problem.\nThe state constraint set is $X = \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 1\\}$.\nThe additive disturbance set is $E = \\{e \\in \\mathbb{R}^n : \\|e\\|_{\\infty} \\le 0.2\\}$.\n\nThe Pontryagin set difference $A \\ominus B$ is defined as the set of all points $c$ such that the Minkowski sum of $\\{c\\}$ and $B$ is a subset of $A$. Formally:\n$$A \\ominus B = \\{c \\in \\mathbb{R}^n \\mid \\{c\\} + B \\subseteq A\\}$$\nThis is equivalent to the condition that for any $c \\in A \\ominus B$ and any $b \\in B$, the sum $c+b$ must be in $A$.\n\nApplying this definition to our specific sets $X$ and $E$, a vector $x$ is in $X \\ominus E$ if and only if for all disturbances $e \\in E$, the resulting state $x+e$ is in $X$. The condition for a vector to be in $X$ is that its infinity norm is less than or equal to $1$. Thus, we must find the set of all $x \\in \\mathbb{R}^n$ such that:\n$$\\|x+e\\|_{\\infty} \\le 1 \\quad \\forall e \\in E \\text{ where } \\|e\\|_{\\infty} \\le 0.2$$\nThis is equivalent to finding all $x$ such that the maximum possible value of $\\|x+e\\|_{\\infty}$ over all valid $e$ does not exceed $1$:\n$$\\sup_{e \\in E} \\|x+e\\|_{\\infty} \\le 1$$\n\nWe will now prove that the resulting set is $X \\ominus E = \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\}$. The proof consists of two inclusions.\n\nPart 1: We show that $\\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\} \\subseteq X \\ominus E$.\nLet $x$ be an arbitrary vector such that $\\|x\\|_{\\infty} \\le 0.8$. Let $e$ be an arbitrary disturbance from the set $E$, so $\\|e\\|_{\\infty} \\le 0.2$. We must show that $x+e \\in X$.\nWe use the triangle inequality for the infinity norm, which states that $\\|u+v\\|_{\\infty} \\le \\|u\\|_{\\infty} + \\|v\\|_{\\infty}$ for any $u, v \\in \\mathbb{R}^n$.\nApplying this, we get:\n$$\\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty}$$\nSubstituting the bounds on the norms of $x$ and $e$:\n$$\\|x+e\\|_{\\infty} \\le 0.8 + 0.2 = 1.0$$\nThis confirms that $\\|x+e\\|_{\\infty} \\le 1$, which means $x+e \\in X$. Since this holds for any arbitrary $e \\in E$, we have shown that if $\\|x\\|_{\\infty} \\le 0.8$, then $x \\in X \\ominus E$.\n\nPart 2: We show that $X \\ominus E \\subseteq \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\}$.\nWe proceed by contradiction. Assume there exists an $x \\in X \\ominus E$ such that $\\|x\\|_{\\infty} > 0.8$.\nBy the definition of the infinity norm, $\\|x\\|_{\\infty} = \\max_{i \\in \\{1,\\dots,n\\}} |x_i|$. Let $j$ be an index for which this maximum is achieved, so $|x_j| = \\|x\\|_{\\infty} > 0.8$.\nWe now construct a specific disturbance vector $e^* \\in E$ designed to maximally increase the $j$-th component of $x$. Let the components of $e^*$ be defined as:\n$$e^*_i = \\begin{cases} 0.2 \\cdot \\text{sgn}(x_j) & \\text{if } i=j \\\\ 0 & \\text{if } i \\neq j \\end{cases}$$\nThe infinity norm of this vector is $\\|e^*\\|_{\\infty} = \\max_i |e^*_i| = |0.2 \\cdot \\text{sgn}(x_j)| = 0.2$. Therefore, this specific vector $e^*$ is an element of the disturbance set $E$.\nNow, consider the sum $x+e^*$. The $j$-th component of this vector is $(x+e^*)_j = x_j + e^*_j = x_j + 0.2 \\cdot \\text{sgn}(x_j)$. Since $x_j$ and $0.2 \\cdot \\text{sgn}(x_j)$ have the same sign (or one is zero if $x_j=0$, which is not the case here), the magnitude of their sum is the sum of their magnitudes:\n$$|(x+e^*)_j| = |x_j| + |0.2 \\cdot \\text{sgn}(x_j)| = |x_j| + 0.2$$\nRecalling that $|x_j| = \\|x\\|_{\\infty}$, we have $|(x+e^*)_j| = \\|x\\|_{\\infty} + 0.2$.\nSince we assumed $\\|x\\|_{\\infty} > 0.8$, it follows that:\n$$|(x+e^*)_j| > 0.8 + 0.2 = 1.0$$\nThe infinity norm of any vector is at least as large as the magnitude of any of its components. Thus:\n$$\\|x+e^*\\|_{\\infty} \\ge |(x+e^*)_j| > 1.0$$\nThis result, $\\|x+e^*\\|_{\\infty} > 1$, means that for this particular $e^* \\in E$, the state $x+e^*$ is not in $X$. This contradicts our initial assumption that $x \\in X \\ominus E$, which requires $x+e \\in X$ for *all* $e \\in E$. The contradiction implies our premise $\\|x\\|_{\\infty} > 0.8$ must be false. Therefore, any $x \\in X \\ominus E$ must satisfy $\\|x\\|_{\\infty} \\le 0.8$.\n\nCombining both parts of the proof, we have rigorously established that the Pontryagin difference is:\n$$X \\ominus E = \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\}$$\n\nThe coordinate-wise margin is the amount by which the constraints on each state variable component are tightened. The original constraint is $|x_i| \\le 1$. The tightened constraint is $|x_i| \\le 0.8$. The margin is the difference between the bounds, which is $1 - 0.8 = 0.2$. This margin corresponds exactly to the maximum possible magnitude of the disturbance on any single coordinate, $\\sup_{e \\in E}|e_i| = 0.2$.\n\nFinally, we justify from first principles why this tightened set ensures robust feasibility. By definition, if we constrain the nominal state $x$ to be in the set $X \\ominus E$, we are choosing an $x$ that satisfies $\\|x\\|_{\\infty} \\le 0.8$. For any possible realization of the disturbance $e \\in E$, we know that $\\|e\\|_{\\infty} \\le 0.2$. The true state is $x+e$. To check if the true state satisfies the original state constraints, we must verify if $\\|x+e\\|_{\\infty} \\le 1$. From the triangle inequality of a norm, $\\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty}$. Substituting the established bounds for the nominal state and the disturbance, we obtain the upper bound $\\|x+e\\|_{\\infty} \\le 0.8 + 0.2 = 1$. This guarantees that the true state will always be contained within the original constraint set $X$, for any selection of nominal state $x \\in X \\ominus E$ and any disturbance $e \\in E$. This is the principle of robust constraint satisfaction via constraint tightening.", "answer": "$$\\boxed{\\{x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 0.8\\}}$$", "id": "2746569"}, {"introduction": "While single-step constraint tightening handles immediate disturbances, a truly robust system must account for the cumulative effect of disturbances over time. This leads to the concept of a Robust Positively Invariant (RPI) setâ€”a region of the state space within which the system is guaranteed to remain indefinitely. This exercise provides a concrete, analytical derivation of the minimal RPI set for a stable linear system, demonstrating how system dynamics dictate the necessary long-term safety margin. [@problem_id:2746575]", "problem": "Consider a discrete-time Linear Time-Invariant (LTI) closed-loop error system under Model Predictive Control (MPC) with additive bounded disturbance given by the dynamics $e_{k+1} = A_{K} e_{k} + w_{k}$, where $A_{K} \\in \\mathbb{R}^{n \\times n}$ and $w_{k} \\in W$ for all $k \\in \\mathbb{N}$. A set $\\mathcal{E} \\subset \\mathbb{R}^{n}$ is called a Robust Positively Invariant (RPI) set for this system if $A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$, where $\\oplus$ denotes Minkowski sum. In robust MPC, nominal state constraints are typically tightened by the RPI set so that the nominal state remains feasible despite disturbances; specifically, for a symmetric convex constraint set $X$, a common tightening is $X_{\\text{tight}} = X \\ominus \\mathcal{E}$, where $\\ominus$ denotes the Pontryagin difference.\n\nSuppose $A_{K} = 0.5 I$ and the disturbance set is the axis-aligned hypercube $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$. The nominal state constraint set is $X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$. Using only fundamental definitions of RPI sets, Minkowski sums, and limits of set-valued series, derive the minimal RPI set $\\mathcal{E}$ as the limit of the Minkowski sum series generated by repeated propagation of $W$ through the closed-loop dynamics. Then, from first principles, quantify the induced infinity-norm constraint tightening, defined as the scalar $\\tau$ that must be subtracted from each bound of $X$ so that $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ satisfies $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$.\n\nProvide the exact value of the tightening magnitude $\\tau$ as your final answer. No rounding is required. The final answer must be a single real number.", "solution": "The first step is to derive the minimal Robust Positively Invariant (RPI) set, $\\mathcal{E}$, for the given system. The minimal RPI set is the set of all states reachable from the origin ($e_0 = 0$) under the action of all possible disturbance sequences. It is constructed as the infinite Minkowski sum of the disturbance set propagated by the system dynamics.\nThe state at time step $k$, starting from $e_0 = 0$, is given by:\n$$ e_k = \\sum_{i=0}^{k-1} A_K^i w_{k-1-i} $$\nThe set of all possible states at any time is the union of all reachable sets. The minimal RPI set $\\mathcal{E}$ is the limit of these reachable sets as $k \\to \\infty$:\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} A_K^i W $$\nThis series converges because the system matrix $A_K$ is Schur stable. The eigenvalues of $A_K = 0.5 I$ are all $0.5$, which have a magnitude less than $1$.\nSubstituting the given $A_K = 0.5 I$:\n$$ A_K^i = (0.5 I)^i = (0.5)^i I $$\nThe minimal RPI set is therefore:\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} (0.5)^i I W = \\bigoplus_{i=0}^{\\infty} (0.5)^i W $$\nThe disturbance set $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$ is a convex, centrally symmetric set (an origin-centered hypercube). For such sets, scaling and Minkowski addition have the property that $\\alpha S \\oplus \\beta S = (\\alpha+\\beta)S$ for non-negative scalars $\\alpha, \\beta$. Extending this to the infinite sum, we can write:\n$$ \\mathcal{E} = \\left( \\sum_{i=0}^{\\infty} (0.5)^i \\right) W $$\nThe sum is a geometric series with ratio $r = 0.5$:\n$$ \\sum_{i=0}^{\\infty} (0.5)^i = \\frac{1}{1 - 0.5} = \\frac{1}{0.5} = 2 $$\nThus, the minimal RPI set is:\n$$ \\mathcal{E} = 2 W = 2 \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\} $$\nTo characterize this set, let $e \\in \\mathcal{E}$. Then $e = 2w$ for some $w \\in W$. The norm of $e$ is $\\|e\\|_{\\infty} = \\|2w\\|_{\\infty} = 2\\|w\\|_{\\infty}$. Since $\\|w\\|_{\\infty} \\le 0.1$, it follows that $\\|e\\|_{\\infty} \\le 2 \\times 0.1 = 0.2$.\nSo, the minimal RPI set is the hypercube:\n$$ \\mathcal{E} = \\{ e \\in \\mathbb{R}^{n} : \\|e\\|_{\\infty} \\le 0.2 \\} $$\n\nThe second step is to determine the tightening magnitude $\\tau$. The tightened constraint set is given as $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$. This set must satisfy the condition $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$. This condition ensures that if the nominal state is in $X_{\\text{tight}}$, the true state (nominal plus error) remains within the original constraint set $X$.\n\nLet us analyze the Minkowski sum $X_{\\text{tight}} \\oplus \\mathcal{E}$. Both $X_{\\text{tight}}$ and $\\mathcal{E}$ are origin-centered hypercubes, defined by infinity-norm bounds.\n- $X_{\\text{tight}}$ is a hypercube of infinity-norm radius $1 - \\tau$.\n- $\\mathcal{E}$ is a hypercube of infinity-norm radius $0.2$.\nThe Minkowski sum of two origin-centered hypercubes is another origin-centered hypercube whose radius is the sum of their radii.\nLet $z \\in X_{\\text{tight}} \\oplus \\mathcal{E}$. Then $z = x + e$ for some $x \\in X_{\\text{tight}}$ and $e \\in \\mathcal{E}$. The infinity norm of $z$ is bounded by:\n$$ \\|z\\|_{\\infty} = \\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty} $$\nThe maximum possible value is attained, so the resulting set is characterized by:\n$$ \\sup_{z \\in X_{\\text{tight}} \\oplus \\mathcal{E}} \\|z\\|_{\\infty} = \\sup_{x \\in X_{\\text{tight}}} \\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}} \\|e\\|_{\\infty} = (1 - \\tau) + 0.2 = 1.2 - \\tau $$\nSo, $X_{\\text{tight}} \\oplus \\mathcal{E} = \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\}$.\nThe condition $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$ becomes:\n$$ \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\} \\subseteq \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\} $$\nFor this set inclusion to hold, the radius of the inner set must be less than or equal to the radius of the outer set:\n$$ 1.2 - \\tau \\le 1 $$\nThis implies $0.2 \\le \\tau$. To ensure feasibility while being minimally conservative, we must choose the smallest possible value for the tightening $\\tau$. The minimal tightening that satisfies the condition is $\\tau = 0.2$.\n\nThis is equivalent to computing the Pontryagin difference $X \\ominus \\mathcal{E}$. By definition, $X \\ominus \\mathcal{E} = \\{ x \\in \\mathbb{R}^n \\mid x \\oplus \\mathcal{E} \\subseteq X \\}$.\nFor an element $x$ to be in this set, we must have $x+e \\in X$ for all $e \\in \\mathcal{E}$. This means $\\|x+e\\|_{\\infty} \\le 1$ for all $\\|e\\|_{\\infty} \\le 0.2$.\nThe maximal value of $\\|x+e\\|_{\\infty}$ for a fixed $x$ is $\\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}}\\|e\\|_{\\infty}$.\nSo, the condition is $\\|x\\|_{\\infty} + 0.2 \\le 1$, which simplifies to $\\|x\\|_{\\infty} \\le 0.8$.\nThis defines the maximally large tightened set: $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 0.8 \\}$.\nComparing this to the given form $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 1 - \\tau \\}$, we equate the bounds:\n$$ 1 - \\tau = 0.8 $$\nSolving for $\\tau$ gives $\\tau = 1 - 0.8 = 0.2$.\nThe tightening magnitude is $\\tau = 0.2$.", "answer": "$$\n\\boxed{0.2}\n$$", "id": "2746575"}, {"introduction": "Analytical derivations of invariant sets are only possible for relatively simple systems, but real-world applications require a more general and scalable approach. This practice bridges the gap between theory and implementation by guiding you through the development of an algorithm to compute the maximal RPI set for any stabilizable linear system with polyhedral constraints. By implementing a fixed-point iteration that relies on linear programming, you will gain hands-on experience with the computational tools that underpin modern robust control synthesis and verification. [@problem_id:2741157]", "problem": "Consider a discrete-time, linear time-invariant system with additive disturbance given by $x^{+} = A x + B u + w$, where $x \\in \\mathbb{R}^{n}$ is the state, $u \\in \\mathbb{R}^{m}$ is the control input, and $w \\in \\mathbb{R}^{n}$ is an exogenous disturbance. A static state-feedback $u = K x$ is applied, yielding the closed-loop system $x^{+} = A_{\\mathrm{cl}} x + w$ with $A_{\\mathrm{cl}} := A + B K$. The state is constrained to a compact convex set $X := \\{ x \\in \\mathbb{R}^{n} \\mid H x \\le h \\}$ and the disturbance is bounded in a compact convex set $W$. A set $S \\subseteq X$ is called a robust positively invariant (RPI) set for the closed-loop system if for all $x \\in S$ and all $w \\in W$ the successor $A_{\\mathrm{cl}} x + w$ is in $S$. In the context of Robust Model Predictive Control (RMPC), computing the largest RPI set contained in $X$ certifies robust feasibility and constraint satisfaction.\n\nYour task is to derive and implement a fixed-point iteration to compute the maximal RPI set contained in $X$, using polyhedral fixed-point iterations based on the robust one-step predecessor operator. The computation must be fully automated and must terminate numerically when a convergence criterion is met or when the resulting set becomes empty.\n\nFundamental base:\n- The definition of robust positive invariance: A set $S$ is RPI for $x^{+} = A_{\\mathrm{cl}} x + w$ if and only if $A_{\\mathrm{cl}} x + w \\in S$ for all $x \\in S$ and all $w \\in W$.\n- The robust one-step predecessor of a set $S$ is $\\mathrm{Pre}(S) := \\{ x \\in \\mathbb{R}^{n} \\mid A_{\\mathrm{cl}} x + w \\in S \\ \\text{for all} \\ w \\in W \\}$.\n- For polyhedral $S = \\{ x \\mid H x \\le c \\}$ and a compact convex $W$, the inclusion $A_{\\mathrm{cl}} x + w \\in S$ for all $w \\in W$ is equivalent to $H A_{\\mathrm{cl}} x \\le c - s$, where $s \\in \\mathbb{R}^{q}$ has entries $s_{i} = \\max_{w \\in W} (H_{i} w)$, i.e., the support function of $W$ evaluated at the facet normals $H_{i}$.\n- The set iteration for the maximal RPI subset of $X$ is $S_{0} := X$ and $S_{k+1} := X \\cap \\mathrm{Pre}(S_{k})$, which is a monotone nonincreasing sequence that converges (under mild conditions) to the maximal RPI subset of $X$ or to the empty set.\n\nTo make the computation algorithmically tractable in finite time and easily testable, use a fixed template of facet normals $H$ and compute a sequence of sets of the form $S_{k} = \\{ x \\mid H x \\le c_{k} \\}$ for a vector $c_{k}$, with $H$ fixed. You must:\n- Use the axis-aligned box template $H = \\begin{bmatrix} I \\\\ -I \\end{bmatrix}$, where $I$ is the $n \\times n$ identity matrix. This template represents symmetric hyper-rectangles about the origin when the upper bounds in opposite facets are equal. The state constraint set is $X := \\{ x \\mid H x \\le h_{X} \\}$ with $h_{X} = \\begin{bmatrix} \\bar{x} \\\\ \\bar{x} \\end{bmatrix}$, where $\\bar{x} \\in \\mathbb{R}^{n}_{\\ge 0}$ is the vector of state bounds.\n- Let the disturbance set be the box $W := \\{ w \\in \\mathbb{R}^{n} \\mid |w_{j}| \\le \\bar{w}_{j} \\}$, so its support function at a row $H_{i}$ is $s_{i} = \\sum_{j=1}^{n} |H_{i j}| \\bar{w}_{j}$. For the chosen $H$, this simplifies to $s = \\begin{bmatrix} \\bar{w} \\\\ \\bar{w} \\end{bmatrix}$.\n\nDerive the fixed-point update that maps $c_{k} \\mapsto c_{k+1}$ as follows:\n- Start with $c_{0} = h_{X}$.\n- Given $c_{k}$, compute the robust predecessor constraints $H A_{\\mathrm{cl}} x \\le c_{k} - s$.\n- Compute $c_{k+1}$ as the tightest vector in the same template satisfying $S_{k+1} = \\{ x \\mid H x \\le c_{k+1} \\} \\supseteq X \\cap \\mathrm{Pre}(S_{k})$ by solving, for each row $i$, the linear program that returns the maximal value of $H_{i} x$ over $x$ satisfying both $H A_{\\mathrm{cl}} x \\le c_{k} - s$ and $H x \\le h_{X}$. Set $c_{k+1,i}$ equal to this maximal value. If the intersection is empty, declare $S_{k+1} = \\varnothing$ and terminate.\n- Stop when $\\| c_{k+1} - c_{k} \\|_{\\infty} \\le \\varepsilon$, for a convergence tolerance $\\varepsilon$, or when emptiness is detected.\n\nFor reporting, define the per-axis half-widths of the final set as $r_{j} := \\min\\{ c_{\\infty, j}, \\ c_{\\infty, j+n} \\}$ for $j \\in \\{1,\\dots,n\\}$, where $c_{\\infty}$ is the converged vector. If the set is empty, define $r_{j} := 0$ for all $j$. Define the area in two dimensions as $A := 4 \\, r_{1} r_{2}$. All numerical results must be rounded to six decimal places.\n\nImplement the above using linear programming to solve the facet-wise maximizations and use the following test suite. In each test, compute $A_{\\mathrm{cl}} = A + B K$, iterate to convergence or emptiness, and output the half-widths and area.\n\nTest suite (all numbers are real scalars; all matrices and vectors are explicitly given):\n- Test $1$ (happy path, stable open-loop):\n  - $n = 2$,\n  - $A = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.0 & 0.8 \\end{bmatrix}$,\n  - $B = I_{2}$,\n  - $K = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$,\n  - $\\bar{x} = \\begin{bmatrix} 2.0 \\\\ 2.0 \\end{bmatrix}$,\n  - $\\bar{w} = \\begin{bmatrix} 0.05 \\\\ 0.05 \\end{bmatrix}$.\n- Test $2$ (stabilized by feedback, nontrivial coupling):\n  - $n = 2$,\n  - $A = \\begin{bmatrix} 1.2 & 0.1 \\\\ 0.2 & 1.1 \\end{bmatrix}$,\n  - $B = I_{2}$,\n  - $K = \\begin{bmatrix} -0.8 & 0.0 \\\\ 0.0 & -0.7 \\end{bmatrix}$,\n  - $\\bar{x} = \\begin{bmatrix} 1.0 \\\\ 0.8 \\end{bmatrix}$,\n  - $\\bar{w} = \\begin{bmatrix} 0.02 \\\\ 0.01 \\end{bmatrix}$.\n- Test $3$ (edge case, infeasible due to large disturbance):\n  - $n = 2$,\n  - $A = 0.95 \\, I_{2}$,\n  - $B = I_{2}$,\n  - $K = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$,\n  - $\\bar{x} = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$,\n  - $\\bar{w} = \\begin{bmatrix} 0.12 \\\\ 0.12 \\end{bmatrix}$.\n\nNumerical specifications:\n- Use convergence tolerance $\\varepsilon = 10^{-8}$ in the $\\ell_{\\infty}$-norm and a maximum of $200$ iterations.\n- Treat the set as empty if any iteration produces an infeasible intersection $X \\cap \\mathrm{Pre}(S_{k})$.\n\nRequired final output format:\n- Your program must print a single line containing a list of the per-test results, where each per-test result is a list $[r_{1}, r_{2}, A]$ with all entries rounded to six decimal places. For the above three tests, the required format is:\n- $[[r_{1}^{(1)}, r_{2}^{(1)}, A^{(1)}],[r_{1}^{(2)}, r_{2}^{(2)}, A^{(2)}],[r_{1}^{(3)}, r_{2}^{(3)}, A^{(3)}]]$.\n\nThere are no physical units in this problem. Angles are not used. All real-valued outputs must be decimals with exactly six digits after the decimal point.", "solution": "The problem requires the derivation and implementation of a fixed-point iteration to compute the maximal robust positively invariant (RPI) set for a discrete-time linear system under state and disturbance constraints. The solution will be based on polyhedral set operations, realized algorithmically through linear programming.\n\nThe system dynamics are given by $x^{+} = A x + B u + w$, and with a state-feedback control law $u=Kx$, the closed-loop system is $x^{+} = A_{\\mathrm{cl}} x + w$, where $A_{\\mathrm{cl}} = A + B K$. The state $x \\in \\mathbb{R}^n$ is constrained to a set $X$, and the disturbance $w \\in \\mathbb{R}^n$ is bounded in a set $W$.\n\nA set $S$ is a robust positively invariant (RPI) set if, for any state $x \\in S$ and any disturbance $w \\in W$, the next state $x^{+} = A_{\\mathrm{cl}}x + w$ remains in $S$. The goal is to find the largest such set contained within the state constraint set $X$, denoted $S_{\\infty} \\subseteq X$.\n\nThe computation proceeds via a fixed-point iteration on a sequence of sets $\\{S_k\\}_{k \\ge 0}$, defined as:\n$$ S_0 = X $$\n$$ S_{k+1} = X \\cap \\mathrm{Pre}(S_k) $$\nwhere $\\mathrm{Pre}(S_k)$ is the robust one-step predecessor set of $S_k$. It contains all states $x$ for which all possible next states $A_{\\mathrm{cl}}x + w$ are in $S_k$, regardless of the disturbance $w \\in W$. Formally,\n$$ \\mathrm{Pre}(S_k) = \\{ x \\in \\mathbb{R}^n \\mid A_{\\mathrm{cl}}x + w \\in S_k, \\ \\forall w \\in W \\} $$\nThis sequence of sets is monotonically non-increasing, $S_{k+1} \\subseteq S_k$, and converges to the maximal RPI set $S_{\\infty}$.\n\nTo make this algorithm computationally tractable, we represent the sets as polyhedra with a fixed template of facet normals. The template is given by $H = \\begin{bmatrix} I \\\\ -I \\end{bmatrix}$, where $I$ is the $n \\times n$ identity matrix. The sets are therefore hyper-rectangles of the form $S_k = \\{ x \\mid H x \\le c_k \\}$.\n\nThe state constraint set is $X = \\{ x \\mid H x \\le h_X \\}$, where $h_X = [\\bar{x}^T, \\bar{x}^T]^T$ for a given vector of positive bounds $\\bar{x}$. This corresponds to $|x_j| \\le \\bar{x}_j$ for each component $j$.\nThe disturbance set is $W = \\{ w \\mid |w_j| \\le \\bar{w}_j \\}$.\n\nLet's derive the constraints for the predecessor set $\\mathrm{Pre}(S_k)$. Given $S_k = \\{ x \\mid H x \\le c_k \\}$, the condition $A_{\\mathrm{cl}}x + w \\in S_k$ becomes $H(A_{\\mathrm{cl}}x + w) \\le c_k$. This must hold for all $w \\in W$. This is equivalent to:\n$$ H A_{\\mathrm{cl}} x + H w \\le c_k, \\quad \\forall w \\in W $$\n$$ H A_{\\mathrm{cl}} x \\le c_k - H w, \\quad \\forall w \\in W $$\nTo satisfy this for all $w$, we must satisfy it for the worst-case $w$ that maximizes $Hw$. This leads to the inequality:\n$$ H A_{\\mathrm{cl}} x \\le c_k - s $$\nwhere $s$ is a vector whose $i$-th component is the value of the support function of $W$ for the normal vector $H_i$, i.e., $s_i = \\max_{w \\in W} (H_i w)$. For the chosen template $H$ and disturbance set $W$, the rows of $H$ are $H_{j} = e_j$ and $H_{n+j} = -e_j$ for $j=1, \\dots, n$.\nFor a row $H_j = e_j$, $s_j = \\max_{w \\in W} w_j = \\bar{w}_j$.\nFor a row $H_{n+j} = -e_j$, $s_{n+j} = \\max_{w \\in W} (-w_j) = \\bar{w}_j$.\nThus, the support vector is constant $s = [\\bar{w}^T, \\bar{w}^T]^T$.\nThe predecessor set is the polyhedron $\\mathrm{Pre}(S_k) = \\{ x \\mid H A_{\\mathrm{cl}} x \\le c_k - s \\}$.\n\nThe next iterate, $S_{k+1}$, is defined by the intersection of two polyhedra: $S_{k+1, \\text{exact}} = X \\cap \\mathrm{Pre}(S_k) = \\{ x \\mid H x \\le h_X \\text{ and } H A_{\\mathrm{cl}} x \\le c_k - s \\}$.\nTo continue the iteration using the fixed template $H$, we must find the tightest hyper-rectangle $\\{x \\mid H x \\le c_{k+1}\\}$ that contains this intersection. The components $c_{k+1,i}$ of the new vector are found by maximizing the corresponding linear function $H_i x$ over the intersection set. This is achieved by solving a linear program (LP) for each of the $2n$ facets:\n$$ c_{k+1, i} = \\max_{x \\in \\mathbb{R}^n} \\quad H_i x $$\n$$ \\text{subject to:} \\quad \\begin{bmatrix} H \\\\ H A_{\\mathrm{cl}} \\end{bmatrix} x \\le \\begin{bmatrix} h_X \\\\ c_k - s \\end{bmatrix} $$\nIf any of these LPs are infeasible, the intersection is empty, meaning no RPI set exists within $X$, and the iteration terminates.\n\nThe overall algorithm is as follows:\n1.  Initialize $k=0$ with $c_0 = h_X$.\n2.  In each iteration $k$, construct the right-hand side of the LP constraints, $b_{LP} = [h_X^T, (c_k - s)^T]^T$. The constraint matrix $A_{LP} = [H^T, (H A_{\\mathrm{cl}})^T]^T$ is constant.\n3.  For each facet $i=1, \\ldots, 2n$, solve the corresponding LP to find $c_{k+1,i}$. If any LP is infeasible, the maximal RPI set is empty. Terminate and report an empty set.\n4.  Check for convergence by comparing the new vector $c_{k+1}$ with the previous one $c_k$. If $\\|c_{k+1} - c_k\\|_{\\infty} \\le \\varepsilon$ for a small tolerance $\\varepsilon$, the iteration has converged to $c_{\\infty}$.\n5.  If not converged, set $c_k = c_{k+1}$ and repeat from step 2, up to a maximum number of iterations.\n6.  Once converged to $c_{\\infty}$, the final set is $S_{\\infty} = \\{x \\mid Hx \\le c_{\\infty}\\}$. The half-widths are computed as $r_j = \\min\\{ c_{\\infty, j}, c_{\\infty, j+n} \\}$ for $j=1, \\dots, n$. If the set is empty, all $r_j=0$. For $n=2$, the area is $A = 4 r_1 r_2$.\nThis procedure is implemented to solve the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef compute_mRPI(A, B, K, x_bar, w_bar, tol=1e-8, max_iter=200):\n    \"\"\"\n    Computes the maximal Robust Positively Invariant (RPI) set.\n    \n    The function implements a fixed-point iteration using linear programming\n    to find the maximal RPI set S_inf contained in the state constraint set X\n    for the system x^+ = A_cl*x + w.\n    \"\"\"\n    n = A.shape[0]\n\n    # --- Setup System and Set Definitions ---\n    A_cl = A + B @ K\n    I_n = np.identity(n)\n    H = np.vstack([I_n, -I_n])  # Shape (2n, n)\n\n    h_X = np.hstack([x_bar, x_bar])  # Shape (2n,)\n    s = np.hstack([w_bar, w_bar])    # Shape (2n,)\n\n    # --- LP Formulation ---\n    # The constraint matrix is constant throughout the iterations.\n    A_lp = np.vstack([H, H @ A_cl])  # Shape (4n, n)\n\n    # --- Iteration ---\n    c_k = h_X\n    is_empty = False\n    \n    for k in range(max_iter):\n        c_k_plus_1 = np.zeros(2 * n)\n        \n        # The right-hand side of the LP constraints depends on c_k.\n        b_lp = np.hstack([h_X, c_k - s])  # Shape (4n,)\n\n        for i in range(2 * n):\n            # Objective: max H[i,:] @ x  => min -H[i,:] @ x\n            c_obj = -H[i, :]\n\n            # Solve the LP. The 'highs' method is robust and the default in recent SciPy.\n            res = linprog(c=c_obj, A_ub=A_lp, b_ub=b_lp, bounds=(None, None), method='highs')\n            \n            # Check for infeasibility.\n            if not res.success:\n                is_empty = True\n                break\n            \n            # The LP minimizes, so the maximum value is -res.fun\n            c_k_plus_1[i] = -res.fun\n        \n        if is_empty:\n            break\n\n        # Check for emptiness based on derived bounds.\n        # If max(x_j)  min(x_j), the set is empty.\n        # max(x_j) = c_k_plus_1[j], min(x_j) = -c_k_plus_1[n+j].\n        # So, if c_k_plus_1[j]  -c_k_plus_1[n+j] for any j, it's empty.\n        if np.any(c_k_plus_1[:n]  -c_k_plus_1[n:]):\n            is_empty = True\n            break\n        \n        # Check for convergence in the infinity norm.\n        if np.max(np.abs(c_k_plus_1 - c_k)) = tol:\n            c_k = c_k_plus_1 # Final converged value\n            break\n        \n        c_k = c_k_plus_1\n\n    # --- Post-processing and Result Calculation ---\n    if is_empty:\n        r = np.zeros(n)\n        area = 0.0\n    else:\n        # If loop finished due to max_iter, use the last computed c_k.\n        c_inf = c_k\n        # Calculate half-widths as per problem definition\n        r = np.minimum(c_inf[:n], c_inf[n:])\n        \n        # If any half-width is negative, the set is considered empty.\n        if np.any(r  0):\n            r.fill(0.0)\n            area = 0.0\n        else:\n            if n == 2:\n                # Area = (2*r1) * (2*r2)\n                area = 4 * r[0] * r[1]\n            else:\n                area = np.nan # Not defined for n!=2 in this problem\n    return r, area\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Stable open-loop system\n        {\n            \"A\": np.array([[0.9, 0.1], [0.0, 0.8]]),\n            \"B\": np.identity(2),\n            \"K\": np.zeros((2, 2)),\n            \"x_bar\": np.array([2.0, 2.0]),\n            \"w_bar\": np.array([0.05, 0.05]),\n        },\n        # Test 2: Unstable system stabilized by feedback\n        {\n            \"A\": np.array([[1.2, 0.1], [0.2, 1.1]]),\n            \"B\": np.identity(2),\n            \"K\": np.array([[-0.8, 0.0], [0.0, -0.7]]),\n            \"x_bar\": np.array([1.0, 0.8]),\n            \"w_bar\": np.array([0.02, 0.01]),\n        },\n        # Test 3: Infeasible due to large disturbance\n        {\n            \"A\": 0.95 * np.identity(2),\n            \"B\": np.identity(2),\n            \"K\": np.zeros((2, 2)),\n            \"x_bar\": np.array([0.1, 0.1]),\n            \"w_bar\": np.array([0.12, 0.12]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r, area = compute_mRPI(\n            A=case[\"A\"], \n            B=case[\"B\"], \n            K=case[\"K\"], \n            x_bar=case[\"x_bar\"], \n            w_bar=case[\"w_bar\"]\n        )\n        \n        # Store results for final printing\n        if r.shape[0] == 2:\n            results.append([r[0], r[1], area])\n\n    # Final print statement in the exact required format.\n    # Format: [[r1_1,r2_1,A_1],[r1_2,r2_2,A_2],[r1_3,r2_3,A_3]]\n    # with 6 decimal places and no spaces within the inner lists.\n    formatted_results = []\n    for res in results:\n        # res is a list [r1, r2, Area]\n        formatted_results.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2741157"}]}