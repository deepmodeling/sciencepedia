{"hands_on_practices": [{"introduction": "This foundational exercise guides you through the complete analytical design and evaluation of a Smith predictor in continuous time. You will first design a controller for the delay-free portion of the plant using pole placement, and then apply it within the predictor structure to control the full time-delay system. By deriving the closed-loop response and comparing it against a standard feedback loop, this practice [@problem_id:2696599] illuminates the core mechanism of the Smith predictor: its ability to remove the delay term $\\exp(-Ls)$ from the characteristic equation, thereby simplifying design and improving performance.", "problem": "Consider a stable, strictly proper, time-delay plant with transfer function $P(s)=G(s)\\exp(-Ls)$, where $G(s)=\\frac{1}{(s+1)^{2}}$ and $L=1$ (time in seconds). A strictly proper controller of the form $C(s)=k\\frac{s+z}{s+p}$ is implemented in a Smith predictor architecture that uses an exact internal model of the plant. You will design $C(s)$ for the delay-free plant $G(s)$ and then analytically derive the closed-loop transfer functions with and without the Smith predictor.\n\nStarting from the definition of the Smith predictor structure and standard block-diagram algebra, perform the following steps:\n\n1) For the delay-free loop around $G(s)$, require that the closed-loop characteristic polynomial be a triply repeated real pole at $s=-a$ with $a=\\frac{2}{3}$, and that the delay-free closed-loop from reference to output has unit steady-state gain. Use these two specifications to determine the values of $k$, $z$, and $p$.\n\n2) Using the exact Smith predictor (with an exact internal model) and your $C(s)$ from step 1, derive from first principles the closed-loop transfer function from reference to output, $T_{\\mathrm{SP}}(s)$, for the overall delayed plant. Then derive the corresponding unit-step response $y_{\\mathrm{SP}}(t)$ in the time domain.\n\n3) For comparison, derive the standard unity-feedback closed-loop transfer function without the Smith predictor, $T_{\\mathrm{NP}}(s)$, and state its characteristic equation. Briefly note how the pole locations differ, based on the presence or absence of the exponential factor in the characteristic equation.\n\nProvide your final answer as the analytical expression for $T_{\\mathrm{SP}}(s)$ in terms of $s$ only. No numerical rounding is required. Do not include physical units in the final answer expression.", "solution": "The problem statement will first be validated for scientific soundness, completeness, and objectivity.\n\nStep 1: Extract Givens\n- Plant transfer function: $P(s)=G(s)\\exp(-Ls)$\n- Delay-free part of the plant: $G(s)=\\frac{1}{(s+1)^{2}}$\n- Time delay: $L=1$\n- Controller form: $C(s)=k\\frac{s+z}{s+p}$, stated to be strictly proper.\n- Smith predictor configuration with an exact internal model ($G_m(s)=G(s)$, $L_m=L$).\n- Design specification 1 for the delay-free loop ($C(s)$ and $G(s)$): The closed-loop characteristic polynomial is $(s+a)^3$, where $a=\\frac{2}{3}$.\n- Design specification 2 for the delay-free loop: Unit steady-state gain for the closed-loop transfer function from reference to output.\n\nStep 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is a standard exercise in control theory concerning the design and analysis of a Smith predictor for a time-delay system. All concepts are fundamental to the field. It is scientifically sound.\n- **Well-Posedness**: The problem provides sufficient specifications (pole placement and steady-state gain) to uniquely determine the controller parameters. The tasks are clearly defined and sequential.\n- **Objectivity**: The problem is stated in precise mathematical and engineering terms, free of subjectivity.\n- **Completeness and Consistency**: The problem is largely self-contained. There is one minor inconsistency: the problem asks for a \"strictly proper\" controller, but the design specifications for achieving a specific third-order characteristic polynomial and unit steady-state gain lead to a controller with a pole at the origin ($p=0$), which is a Proportional-Integral (PI) controller. A PI controller is proper, but not strictly proper. This is a common outcome in such design problems and does not render the problem unsolvable. The intent is clear, and the method to find the parameters is unambiguous. We shall proceed, noting this slight imprecision in terminology.\n\nStep 3: Verdict and Action\nThe problem is deemed **valid** with a minor note on the \"strictly proper\" controller terminology. A complete solution will be provided.\n\n**Part 1: Controller Design**\n\nWe first consider the delay-free feedback loop, consisting of the controller $C(s)$ and the delay-free plant $G(s)$ in a unity feedback configuration. The open-loop transfer function is $L_0(s) = C(s)G(s)$.\n$$L_0(s) = \\left( k\\frac{s+z}{s+p} \\right) \\left( \\frac{1}{(s+1)^2} \\right) = \\frac{k(s+z)}{(s+p)(s+1)^2}$$\nThe closed-loop transfer function for this delay-free system, $T_0(s)$, is given by:\n$$T_0(s) = \\frac{L_0(s)}{1+L_0(s)} = \\frac{\\frac{k(s+z)}{(s+p)(s+1)^2}}{1+\\frac{k(s+z)}{(s+p)(s+1)^2}} = \\frac{k(s+z)}{(s+p)(s+1)^2 + k(s+z)}$$\nThe characteristic polynomial of the delay-free closed-loop system is the denominator of $T_0(s)$:\n$$\\Delta_0(s) = (s+p)(s+1)^2 + k(s+z)$$\nExpanding this polynomial, we get:\n$$\\Delta_0(s) = (s+p)(s^2+2s+1) + ks+kz = s^3 + 2s^2 + s + ps^2 + 2ps + p + ks + kz$$\n$$\\Delta_0(s) = s^3 + (2+p)s^2 + (1+2p+k)s + (p+kz)$$\nThe problem requires this characteristic polynomial to be a triply repeated real pole at $s=-a$, where $a=\\frac{2}{3}$. The desired characteristic polynomial is:\n$$\\Delta_{\\text{desired}}(s) = \\left(s+\\frac{2}{3}\\right)^3 = s^3 + 3s^2\\left(\\frac{2}{3}\\right) + 3s\\left(\\frac{2}{3}\\right)^2 + \\left(\\frac{2}{3}\\right)^3 = s^3 + 2s^2 + \\frac{4}{3}s + \\frac{8}{27}$$\nBy equating the coefficients of $\\Delta_0(s)$ and $\\Delta_{\\text{desired}}(s)$:\n\\begin{itemize}\n    \\item Coefficient of $s^2$: $2+p = 2 \\implies p=0$.\n    \\item Coefficient of $s^1$: $1+2p+k = \\frac{4}{3} \\implies 1+2(0)+k = \\frac{4}{3} \\implies k=\\frac{1}{3}$.\n    \\item Coefficient of $s^0$: $p+kz = \\frac{8}{27} \\implies 0 + \\left(\\frac{1}{3}\\right)z = \\frac{8}{27} \\implies z=\\frac{8}{9}$.\n\\end{itemize}\nThe resulting controller is:\n$$C(s) = \\frac{1}{3}\\frac{s+8/9}{s} = \\frac{s+8/9}{3s}$$\nThis is a PI controller. As noted, it is proper ($\\text{degree of denominator} = \\text{degree of numerator}$) but not strictly proper.\n\nThe second specification is that the delay-free closed loop must have unit steady-state gain. The steady-state gain is the value of the transfer function $T_0(s)$ at $s=0$.\n$$T_0(s) = \\frac{k(s+z)}{(s+a)^3} = \\frac{\\frac{1}{3}(s+\\frac{8}{9})}{(s+\\frac{2}{3})^3}$$\nThe steady-state gain is $T_0(0)$:\n$$T_0(0) = \\frac{\\frac{1}{3}(\\frac{8}{9})}{(\\frac{2}{3})^3} = \\frac{\\frac{8}{27}}{\\frac{8}{27}} = 1$$\nThis specification is satisfied by our design.\n\n**Part 2: Smith Predictor Analysis**\n\nThe general closed-loop transfer function for a Smith predictor architecture is:\n$$T_{\\mathrm{SP}}(s) = \\frac{C(s)P(s)}{1 + C(s)G_m(s) + C(s)(P(s) - P_m(s))}$$\nwhere $P(s) = G(s)\\exp(-Ls)$ is the actual plant and $P_m(s)=G_m(s)\\exp(-L_m s)$ is the model. The problem states an exact internal model is used, so $G_m(s) = G(s)$ and $L_m = L$. The expression simplifies significantly:\n$$T_{\\mathrm{SP}}(s) = \\frac{C(s)G(s)\\exp(-Ls)}{1 + C(s)G(s) + C(s)(G(s)\\exp(-Ls) - G(s)\\exp(-Ls))} = \\frac{C(s)G(s)\\exp(-Ls)}{1 + C(s)G(s)}$$\nThe term $\\frac{C(s)G(s)}{1 + C(s)G(s)}$ is precisely the closed-loop transfer function of the delay-free system, $T_0(s)$. Thus:\n$$T_{\\mathrm{SP}}(s) = T_0(s) \\exp(-Ls)$$\nSubstituting the expression for $T_0(s)$ derived previously:\n$$T_{\\mathrm{SP}}(s) = \\frac{\\frac{1}{3}(s+\\frac{8}{9})}{(s+\\frac{2}{3})^3} \\exp(-s)$$\nWe simplify this expression:\n$$T_{\\mathrm{SP}}(s) = \\frac{\\frac{1}{3}\\frac{9s+8}{9}}{(\\frac{3s+2}{3})^3} \\exp(-s) = \\frac{\\frac{9s+8}{27}}{\\frac{(3s+2)^3}{27}} \\exp(-s) = \\frac{9s+8}{(3s+2)^3} \\exp(-s)$$\nThis is the required closed-loop transfer function.\n\nTo find the unit-step response $y_{\\mathrm{SP}}(t)$, we multiply $T_{\\mathrm{SP}}(s)$ by the Laplace transform of a unit step, $R(s) = \\frac{1}{s}$:\n$$Y_{\\mathrm{SP}}(s) = T_{\\mathrm{SP}}(s) \\frac{1}{s} = \\frac{9s+8}{s(3s+2)^3} \\exp(-s)$$\nThe response $y_{\\mathrm{SP}}(t)$ is the inverse Laplace transform of $Y_{\\mathrm{SP}}(s)$. Let $Y_0(s) = \\frac{9s+8}{s(3s+2)^3}$. Then $y_{\\mathrm{SP}}(t) = \\mathcal{L}^{-1}\\{Y_0(s)\\exp(-s)\\} = y_0(t-1)u(t-1)$, where $y_0(t) = \\mathcal{L}^{-1}\\{Y_0(s)\\}$ and $u(t)$ is the Heaviside step function. We perform a partial fraction expansion of $Y_0(s)$:\n$$Y_0(s) = \\frac{9s+8}{27s(s+\\frac{2}{3})^3} = \\frac{A}{s} + \\frac{B_1}{s+\\frac{2}{3}} + \\frac{B_2}{(s+\\frac{2}{3})^2} + \\frac{B_3}{(s+\\frac{2}{3})^3}$$\nThe coefficients are found to be $A=1$, $B_1=-1$, $B_2=-\\frac{2}{3}$, and $B_3=-\\frac{1}{9}$.\n$$Y_0(s) = \\frac{1}{s} - \\frac{1}{s+\\frac{2}{3}} - \\frac{2/3}{(s+\\frac{2}{3})^2} - \\frac{1/9}{(s+\\frac{2}{3})^3}$$\nTaking the inverse Laplace transform using the property $\\mathcal{L}^{-1}\\left\\{\\frac{1}{(s+a)^n}\\right\\} = \\frac{t^{n-1}}{(n-1)!}\\exp(-at)$:\n$$y_0(t) = \\left(1 - \\exp(-\\frac{2}{3}t) - \\frac{2}{3}t\\exp(-\\frac{2}{3}t) - \\frac{1}{9}\\frac{t^2}{2!}\\exp(-\\frac{2}{3}t)\\right)u(t)$$\n$$y_0(t) = \\left(1 - \\exp(-\\frac{2}{3}t)\\left[1 + \\frac{2}{3}t + \\frac{1}{18}t^2\\right]\\right)u(t)$$\nThe final response is therefore:\n$$y_{\\mathrm{SP}}(t) = \\left(1 - \\exp(-\\frac{2}{3}(t-1))\\left[1 + \\frac{2}{3}(t-1) + \\frac{1}{18}(t-1)^2\\right]\\right)u(t-1)$$\n\n**Part 3: Comparison with Standard Feedback**\n\nWithout the Smith predictor, the system is a standard unity feedback loop with controller $C(s)$ and plant $P(s)=G(s)\\exp(-Ls)$. The closed-loop transfer function $T_{\\mathrm{NP}}(s)$ is:\n$$T_{\\mathrm{NP}}(s) = \\frac{C(s)P(s)}{1+C(s)P(s)} = \\frac{C(s)G(s)\\exp(-Ls)}{1+C(s)G(s)\\exp(-Ls)}$$\nSubstituting expressions for $C(s)$ and $G(s)$:\n$$T_{\\mathrm{NP}}(s) = \\frac{\\frac{s+8/9}{3s(s+1)^2}\\exp(-s)}{1+\\frac{s+8/9}{3s(s+1)^2}\\exp(-s)} = \\frac{(s+8/9)\\exp(-s)}{3s(s+1)^2 + (s+8/9)\\exp(-s)}$$\nThe characteristic equation is obtained by setting the denominator to zero:\n$$1+C(s)G(s)\\exp(-Ls) = 0 \\implies 3s(s+1)^2 + (s+8/9)\\exp(-s) = 0$$\nThe fundamental difference lies in the characteristic equations.\n- **With Smith Predictor**: The characteristic equation is $1+C(s)G(s)=0$, which is $(s+\\frac{2}{3})^3=0$. This is a polynomial equation with a finite number of poles (three poles at $s=-2/3$). The delay is effectively removed from the stability determination loop, allowing for conventional pole placement.\n- **Without Smith Predictor**: The characteristic equation is $1+C(s)G(s)\\exp(-s)=0$. This is a transcendental equation, also known as a quasi-polynomial. Due to the $\\exp(-s)$ term, it possesses an infinite number of poles in the s-plane, making stability analysis and controller design significantly more complex. The performance is typically degraded by the delay compared to the ideal Smith predictor case.", "answer": "$$\\boxed{\\frac{9s+8}{(3s+2)^{3}}\\exp(-s)}$$", "id": "2696599"}, {"introduction": "Beyond reference tracking, a robust control system must be resilient to disturbances like sensor noise. This exercise focuses on a critical aspect of the Smith predictor's performance: the propagation of sensor noise to the control actuator. By deriving the transfer function from the noise input $N(s)$ to the control signal $U(s)$, this practice [@problem_id:2696670] reveals a profound and elegant property of the ideal Smith predictor, demonstrating how its internal structure handles the system's time delay in the context of noise rejection.", "problem": "Consider a single-input/single-output linear time-invariant plant with an input-output pure time-delay. The plant is given by the transfer function $P(s) = G_{0}(s)\\exp(-Ls)$, where $G_{0}(s)$ is strictly proper and stable, and $L \\ge 0$ is the delay. The measured output is corrupted by additive sensor noise, so that $y_{m}(s) = y(s) + n(s)$, where $n(s)$ is the Laplace transform of the sensor noise signal. A Smith predictor is implemented using a nominal model $\\hat{P}(s) = \\hat{G}_{0}(s)\\exp(-\\hat{L}s)$ to form a delay-free feedback to the controller through the predictor. The predictor constructs the internal estimate\n$$\n\\hat{y}(s) \\;=\\; \\hat{G}_{0}(s)U(s) \\;+\\; \\Big(y_{m}(s) - \\exp(-\\hat{L}s)\\,\\hat{G}_{0}(s)U(s)\\Big),\n$$\nand the controller is any proper compensator $C(s)$ driven by the predictor-based error:\n$$\nU(s) \\;=\\; C(s)\\big(R(s) - \\hat{y}(s)\\big).\n$$\nAssume perfect model matching, namely $\\hat{G}_{0}(s) = G_{0}(s)$ and $\\hat{L} = L$. Using only linear time-invariant interconnection laws and Laplace-domain algebra, derive the closed-form transfer function from sensor noise to control input when the reference is zero, that is, find the expression for\n$$\n\\frac{U(s)}{N(s)} \\quad \\text{with} \\quad R(s) \\equiv 0.\n$$\nExpress your final answer as a single closed-form analytic expression. No numerical rounding is required. In one or two sentences inside your derivation, explain how the time-delay $L$ affects (or does not affect) this noise-to-control transfer under perfect matching.", "solution": "The problem statement is evaluated and found to be valid. It is a well-posed problem in linear control theory, scientifically sound, and contains all necessary information for a unique solution. We proceed with the derivation.\n\nThe system is described by the following set of equations in the Laplace domain:\nThe plant transfer function is $P(s) = G_{0}(s)\\exp(-Ls)$, relating the plant output $y(s)$ to the control input $U(s)$:\n$$y(s) = G_{0}(s)\\exp(-Ls)U(s)$$\nThe measured output $y_{m}(s)$ is corrupted by additive sensor noise $n(s)$, denoted as $N(s)$ in the Laplace domain:\n$$y_{m}(s) = y(s) + N(s) = G_{0}(s)\\exp(-Ls)U(s) + N(s)$$\nThe Smith predictor uses a nominal model $\\hat{P}(s) = \\hat{G}_{0}(s)\\exp(-\\hat{L}s)$ to generate an internal estimate $\\hat{y}(s)$ of the output:\n$$\\hat{y}(s) = \\hat{G}_{0}(s)U(s) + \\Big(y_{m}(s) - \\exp(-\\hat{L}s)\\hat{G}_{0}(s)U(s)\\Big)$$\nThe control law is given by a compensator $C(s)$ operating on the error between the reference $R(s)$ and the estimated output $\\hat{y}(s)$:\n$$U(s) = C(s)\\big(R(s) - \\hat{y}(s)\\big)$$\nThe problem specifies two conditions: the reference input is zero, $R(s) \\equiv 0$, and there is perfect model matching, which means $\\hat{G}_{0}(s) = G_{0}(s)$ and $\\hat{L} = L$.\n\nWe are to derive the transfer function from the sensor noise $N(s)$ to the control input $U(s)$, which is $\\frac{U(s)}{N(s)}$.\n\nFirst, we apply the zero reference condition, $R(s)=0$, to the control law:\n$$U(s) = C(s)\\big(0 - \\hat{y}(s)\\big) = -C(s)\\hat{y}(s)$$\nNext, we substitute the perfect model parameters $\\hat{G}_{0}(s) = G_{0}(s)$ and $\\hat{L} = L$ into the equation for the predictor estimate $\\hat{y}(s)$:\n$$\\hat{y}(s) = G_{0}(s)U(s) + \\Big(y_{m}(s) - \\exp(-Ls)G_{0}(s)U(s)\\Big)$$\nNow, we substitute the expression for the measured output $y_{m}(s) = G_{0}(s)\\exp(-Ls)U(s) + N(s)$ into this equation for $\\hat{y}(s)$:\n$$\\hat{y}(s) = G_{0}(s)U(s) + \\Big(\\big(G_{0}(s)\\exp(-Ls)U(s) + N(s)\\big) - \\exp(-Ls)G_{0}(s)U(s)\\Big)$$\nWe can simplify the expression within the large parentheses. The terms involving the plant delay cancel each other out:\n$$G_{0}(s)\\exp(-Ls)U(s) - \\exp(-Ls)G_{0}(s)U(s) = 0$$\nThis leaves a simplified expression for the predictor estimate $\\hat{y}(s)$:\n$$\\hat{y}(s) = G_{0}(s)U(s) + N(s)$$\nThis algebraic cancellation demonstrates that, with a perfect model, the Smith predictor structure effectively removes the influence of the plant delay from the feedback signal used by the controller. As a result, the time-delay $L$ does not appear in the closed-loop transfer function from noise to the control signal, because its effect is perfectly subtracted out by the predictor's internal model.\n\nFinally, we substitute this simplified expression for $\\hat{y}(s)$ back into the control law $U(s) = -C(s)\\hat{y}(s)$:\n$$U(s) = -C(s)\\big(G_{0}(s)U(s) + N(s)\\big)$$\nTo find the desired transfer function, we must algebraically solve for $U(s)$ in terms of $N(s)$. We distribute $-C(s)$ on the right-hand side:\n$$U(s) = -C(s)G_{0}(s)U(s) - C(s)N(s)$$\nNow, we gather all terms containing $U(s)$ on the left-hand side of the equation:\n$$U(s) + C(s)G_{0}(s)U(s) = -C(s)N(s)$$\nFactor out $U(s)$ from the terms on the left-hand side:\n$$U(s)\\big(1 + C(s)G_{0}(s)\\big) = -C(s)N(s)$$\nBy dividing both sides by $N(s)$ and by the term $\\big(1 + C(s)G_{0}(s)\\big)$, we arrive at the closed-form transfer function from sensor noise to control input:\n$$\\frac{U(s)}{N(s)} = \\frac{-C(s)}{1 + C(s)G_{0}(s)}$$\nThis is the final expression relating the control input to the sensor noise under the specified conditions.", "answer": "$$\\boxed{\\frac{-C(s)}{1 + C(s)G_{0}(s)}}$$", "id": "2696670"}, {"introduction": "Translating continuous-time theory into a working digital controller is a vital engineering skill. This hands-on coding exercise [@problem_id:2696634] challenges you to implement a complete discrete-time Smith predictor from first principles, including the design of a digital proportional controller via pole placement. You will confront practical implementation details, such as resolving algebraic loops, and use simulation to observe the system's step response, solidifying your understanding of how the predictor behaves in a sampled-data environment.", "problem": "Consider the discrete-time Single-Input Single-Output (SISO) Linear Time-Invariant (LTI) plant model with a pure input delay. The nominal plant (without delay) is given by the transfer function in the complex $z$-domain\n$$\nG(z) = \\frac{0.1}{1 - 0.9 z^{-1}},\n$$\nand the true plant includes a pure delay of $N$ samples, so the true plant is\n$$\nG_{\\text{true}}(z) = z^{-N} G(z),\n$$\nwith $N = 3$. The reference input is a unit step $r(k) = 1$ for all integer time indices $k \\ge 0$. All simulations are to be carried out in discrete time with unit sampling, so time is measured in integer-valued samples. All requested time indices below are sample indices (unit: samples).\n\nYour task is to implement a discrete Smith predictor for this delayed plant, using an internal model that matches the true plant exactly (same $G(z)$ and same delay $N$). The Smith predictor must be configured as follows:\n\n1. The controller $C(z)$ used in the Smith predictor shall be a proportional controller $C(z) = K$, where the gain $K$ is not given directly but must be designed by pole placement for the delay-free nominal plant $G(z)$ under unity negative feedback. Specifically, for a chosen desired closed-loop pole $p_d \\in (0,1)$ for the delay-free closed loop (i.e., the closed-loop pole of the system with $G(z)$ and controller $C(z)$ but without the delay), determine the proportional gain $K$ that achieves this pole.\n\n2. Use the standard discrete-time Smith predictor construction: the controller $C(z)$ acts on the difference between the reference and a predicted undelayed output. Let $y(k)$ be the true plant output, $y_m(k)$ be the output of the plant model with delay $N$, and $y_{m0}(k)$ be the output of the plant model without delay. The internal predicted undelayed output used by the controller is\n$$\ny_{\\text{sp}}(k) = y_{m0}(k) + y(k) - y_m(k).\n$$\nThe control law is\n$$\nu(k) = K \\left( r(k) - y_{\\text{sp}}(k) \\right).\n$$\n\n3. Realize the plant and model dynamics in the time domain using the standard causal difference equation corresponding to $G(z)$:\n$$\ny(k) = 0.9\\, y(k-1) + 0.1\\, u(k), \\quad \\text{(no delay)}\n$$\nand\n$$\ny(k) = 0.9\\, y(k-1) + 0.1\\, u(k-N), \\quad \\text{(with delay } N \\text{)}.\n$$\nAll initial conditions are zero, and the input delay is realized by a First-In First-Out (FIFO) buffer of length $N$ initialized with zeros.\n\nImportant implementation note: Because $G(z)$ has a nonzero direct term (i.e., the output depends on $u(k)$), the equation for $y_{m0}(k)$ contains $u(k)$, which is computed from the controller using $y_{\\text{sp}}(k)$ that itself uses $y_{m0}(k)$. To avoid an algebraic loop, you must resolve $u(k)$ explicitly in closed form for the proportional controller. The result is a causal computation that uses $y(k)$, $y_m(k)$, and $y_{m0}(k-1)$ to compute $u(k)$, after which $y_{m0}(k)$ is updated.\n\nDesign basis and data:\n- The model parameters for $G(z)$ are $a = 0.9$ and $b = 0.1$, meaning the difference equation for the undelayed model is $y(k) = a\\, y(k-1) + b\\, u(k)$.\n- The plant delay is $N = 3$ samples.\n- The step input is $r(k) = 1$ for all $k \\ge 0$.\n- Simulate for $T = 120$ samples, i.e., $k = 0,1,\\dots,119$.\n\nController design by pole placement:\n- For the delay-free closed loop with unity negative feedback and plant $G(z)$, choose a desired real closed-loop pole $p_d \\in (0,1)$, and design a proportional gain $K$ such that the closed-loop pole (of the delay-free closed loop) is exactly $p_d$. You must derive $K$ from first principles.\n\nWhat to compute and return:\n- For each test case specified below (each with a different desired pole $p_d$), implement the Smith predictor, simulate the closed-loop response to the unit step, and report the following three quantities:\n  1. The output sample value $y(k)$ at time index $k = N + 5$.\n  2. The output sample value $y(k)$ at time index $k = N + 20$.\n  3. The output sample value $y(k)$ at the final simulation time $k = T - 1$.\n- All three quantities are dimensionless and should be reported as real numbers rounded to $6$ decimal places.\n\nTest suite:\n- Use the following desired closed-loop poles for the delay-free design:\n  - Case A: $p_d = 0.2$\n  - Case B: $p_d = 0.5$\n  - Case C: $p_d = 0.8$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The order is Case A values first, then Case B values, then Case C values. Within each case, report the three values in the order specified above. Concretely, the output must be\n$$\n[ y_{A,N+5}, y_{A,N+20}, y_{A,T-1}, y_{B,N+5}, y_{B,N+20}, y_{B,T-1}, y_{C,N+5}, y_{C,N+20}, y_{C,T-1} ],\n$$\nwith each entry rounded to $6$ decimal places.", "solution": "The problem is subjected to validation.\n\n**Step 1: Extract Givens**\n- Nominal plant transfer function: $G(z) = \\frac{0.1}{1 - 0.9 z^{-1}}$. In general form, $G(z) = \\frac{b}{1 - a z^{-1}}$ with $a=0.9$ and $b=0.1$.\n- True plant transfer function: $G_{\\text{true}}(z) = z^{-N} G(z)$.\n- Plant delay: $N = 3$ samples.\n- Reference input: $r(k) = 1$ for $k \\ge 0$.\n- Simulation duration: $T = 120$ samples ($k \\in [0, 119]$).\n- Controller: Proportional, $C(z) = K$.\n- Controller design: Pole placement for the delay-free unity negative feedback loop, with a desired closed-loop pole $p_d$.\n- Smith predictor structure:\n  - Control law: $u(k) = K ( r(k) - y_{\\text{sp}}(k) )$.\n  - Predicted undelayed output: $y_{\\text{sp}}(k) = y_{m0}(k) + y(k) - y_m(k)$, where $y(k)$ is the true plant output, $y_m(k)$ is the delayed model output, and $y_{m0}(k)$ is the undelayed model output.\n- Time-domain dynamics:\n  - Undelayed plant/model: $y(k) = a y(k-1) + b u(k)$.\n  - Delayed plant/model: $y(k) = a y(k-1) + b u(k-N)$.\n- Initial conditions: All states and buffers are zero.\n- Algebraic loop warning: $u(k)$ must be solved for explicitly.\n- Test cases (desired pole $p_d$): Case A: $p_d=0.2$, Case B: $p_d=0.5$, Case C: $p_d=0.8$.\n- Required outputs: For each case, the values of $y(N+5)$, $y(N+20)$, and $y(T-1)$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is a standard exercise in discrete-time control theory. It is scientifically grounded, using established principles of LTI systems and the Smith predictor architecture. It is well-posed, with all necessary parameters and conditions provided for a unique numerical solution. The language is objective and precise. There are no violations of scientific or mathematical principles, no missing information, and no contradictions. The requirement to resolve an algebraic loop is a non-trivial but standard procedure in DSP and control implementations, reflecting a correct understanding of computational causality.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\n**Principle-Based Solution**\n\nThe objective is to design and simulate a Smith predictor for a first-order discrete-time plant with input delay. The solution proceeds in three stages: controller synthesis, formulation of the discrete-time simulation equations, and numerical implementation.\n\n**1. Controller Synthesis by Pole Placement**\n\nThe proportional controller gain $K$ is designed for the nominal plant $G(z) = \\frac{b}{1 - a z^{-1}}$ in a unity negative feedback configuration, without the delay. The closed-loop transfer function $T_{CL}(z)$ for this delay-free system is:\n$$\nT_{CL}(z) = \\frac{C(z)G(z)}{1 + C(z)G(z)} = \\frac{K \\frac{b}{1 - a z^{-1}}}{1 + K \\frac{b}{1 - a z^{-1}}}\n$$\nMultiplying the numerator and denominator by $(1 - a z^{-1})$ yields:\n$$\nT_{CL}(z) = \\frac{Kb}{1 - a z^{-1} + Kb} = \\frac{Kb}{(1+Kb) - a z^{-1}}\n$$\nThe closed-loop pole $z_p$ is found from the characteristic equation, which is the denominator of the transfer function set to zero:\n$$\n(1+Kb) - a z^{-1} = 0 \\implies z_p = \\frac{a}{1+Kb}\n$$\nWe are required to place this pole at a desired location $p_d$. Therefore, we set $z_p = p_d$:\n$$\np_d = \\frac{a}{1+Kb}\n$$\nSolving this equation for the controller gain $K$ gives:\n$$\np_d(1+Kb) = a \\implies p_d + p_d Kb = a \\implies K = \\frac{a - p_d}{p_d b}\n$$\nUsing the given parameters $a = 0.9$ and $b = 0.1$, we compute $K$ for each test case:\n- Case A ($p_d = 0.2$): $K = \\frac{0.9 - 0.2}{0.2 \\times 0.1} = \\frac{0.7}{0.02} = 35$.\n- Case B ($p_d = 0.5$): $K = \\frac{0.9 - 0.5}{0.5 \\times 0.1} = \\frac{0.4}{0.05} = 8$.\n- Case C ($p_d = 0.8$): $K = \\frac{0.9 - 0.8}{0.8 \\times 0.1} = \\frac{0.1}{0.08} = 1.25$.\n\n**2. Smith Predictor Simulation Equations**\n\nThe simulation requires careful handling of computational dependencies to ensure causality. At each discrete time step $k$, we must compute the current control input $u(k)$ and update all system states. The problem statement correctly indicates an algebraic loop in the definition of $u(k)$. We resolve this as follows.\n\nThe control law is $u(k) = K(r(k) - y_{sp}(k))$. Substituting the definition of $y_{sp}(k) = y_{m0}(k) + y(k) - y_m(k)$:\n$$\nu(k) = K(r(k) - [y_{m0}(k) + y(k) - y_m(k)])\n$$\nThe undelayed model output is given by the difference equation $y_{m0}(k) = a y_{m0}(k-1) + b u(k)$. Substituting this into the control law:\n$$\nu(k) = K(r(k) - [ (a y_{m0}(k-1) + b u(k)) + y(k) - y_m(k) ])\n$$\nExpanding and collecting terms containing $u(k)$:\n$$\nu(k) = K r(k) - K a y_{m0}(k-1) - K b u(k) - K y(k) + K y_m(k)\n$$\n$$\nu(k) (1 + Kb) = K [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n$$\nThis gives the explicit, causal update rule for the control input $u(k)$:\n$$\nu(k) = \\frac{K}{1 + Kb} [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n$$\nAt time step $k$, the values $y(k)$ and $y_m(k)$ are available, as they depend on the input $u(k-N)$, a past value. The value $y_{m0}(k-1)$ is also a past state. Thus, $u(k)$ can be computed.\n\n**3. Simulation Algorithm**\n\nThe simulation proceeds iteratively for $k = 0, 1, \\dots, T-1$. At each step $k$, the following calculations are performed in order:\n\n1.  **Retrieve past values**: Access state values from step $k-1$ (e.g., $y(k-1)$, $y_m(k-1)$, $y_{m0}(k-1)$) and the delayed input $u(k-N)$. For $k-1  0$ or $k-N  0$, these values are zero according to the initial conditions.\n2.  **Compute delayed outputs**: Calculate the outputs of the true plant and the delayed model. Since the model is perfect, these are governed by identical dynamics:\n    $$\n    y(k) = a y(k-1) + b u(k-N)\n    $$\n    $$\n    y_m(k) = a y_m(k-1) + b u(k-N)\n    $$\n    In an ideal simulation, $y(k) = y_m(k)$ for all $k$.\n3.  **Compute control input**: Use the derived causal formula to calculate $u(k)$:\n    $$\n    u(k) = \\frac{K}{1 + Kb} [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n    $$\n    Here $r(k)=1$. The term $y(k)-y_m(k)$ will be zero in this ideal case.\n4.  **Compute undelayed model output**: Update the state of the undelayed model using the just-computed $u(k)$:\n    $$\n    y_{m0}(k) = a y_{m0}(k-1) + b u(k)\n    $$\n5.  **Store states**: The computed values $y(k)$, $y_m(k)$, $y_{m0}(k)$, and $u(k)$ are stored for use in subsequent time steps.\n\nThis algorithm is implemented for the specified duration $T=120$ for each design case. The output values $y(k)$ at $k=N+5=8$, $k=N+20=23$, and $k=T-1=119$ are then extracted and reported. The behavior of the Smith predictor with a perfect model is to yield a closed-loop response equivalent to the delay-free system response, shifted in time by the delay $N$. The system output $y(k)$ should exhibit the dynamics of a first-order system with pole $p_d$ but with its response starting at $k=N$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete-time Smith predictor problem for a plant with time delay.\n    \"\"\"\n    # Define system parameters from the problem statement.\n    a = 0.9  # Plant pole\n    b = 0.1  # Plant numerator gain\n    N = 3    # Input delay in samples\n    T = 120  # Total simulation time in samples\n\n    # Define the test cases with different desired closed-loop poles.\n    test_cases_pd = [0.2, 0.5, 0.8]\n\n    # A list to store the final results for all test cases.\n    results = []\n\n    # Iterate through each test case.\n    for p_d in test_cases_pd:\n        # 1. Controller Design: Calculate proportional gain K by pole placement.\n        # The formula K = (a - p_d) / (p_d * b) is derived from setting the\n        # delay-free closed-loop pole to p_d.\n        K = (a - p_d) / (p_d * b)\n\n        # 2. Simulation Initialization: Create arrays to store system signals over time.\n        # All signals are initialized to zero, which handles the initial conditions.\n        y = np.zeros(T)      # True plant output\n        ym = np.zeros(T)     # Delayed plant model output\n        ym0 = np.zeros(T)    # Undelayed plant model output\n        u = np.zeros(T)      # Control input\n        r = np.ones(T)       # Reference input (unit step)\n\n        # Pre-calculate a constant factor for the control input equation.\n        u_factor = K / (1 + K * b)\n\n        # 3. Simulation Loop: Iterate from k = 0 to T-1.\n        for k in range(T):\n            # Retrieve past values, handling boundary conditions at k=0.\n            # If the index is negative, the value is 0.\n            y_km1 = y[k - 1] if k > 0 else 0.0\n            ym_km1 = ym[k - 1] if k > 0 else 0.0\n            ym0_km1 = ym0[k - 1] if k > 0 else 0.0\n            \n            # The input u(k-N) causes the delay. For k  N, u(k-N) is 0.\n            u_k_minus_N = u[k - N] if k >= N else 0.0\n\n            # Update delayed outputs based on past values. This must be done\n            # before calculating the current control input u(k).\n            y[k] = a * y_km1 + b * u_k_minus_N\n            ym[k] = a * ym_km1 + b * u_k_minus_N\n\n            # Calculate the current control input u(k).\n            # The formula is derived to resolve the algebraic loop.\n            # Since the model is perfect, y[k] - ym[k] will be zero.\n            u[k] = u_factor * (r[k] - y[k] + ym[k] - a * ym0_km1)\n            \n            # Update the undelayed model output using the newly calculated u(k).\n            ym0[k] = a * ym0_km1 + b * u[k]\n\n        # 4. Extract and Store Results for the current test case.\n        # The required time indices are N+5, N+20, and T-1.\n        y_N_plus_5 = y[N + 5]\n        y_N_plus_20 = y[N + 20]\n        y_T_minus_1 = y[T - 1]\n\n        # Append the rounded results to the main results list.\n        results.extend([\n            np.round(y_N_plus_5, 6),\n            np.round(y_N_plus_20, 6),\n            np.round(y_T_minus_1, 6)\n        ])\n\n    # 5. Final Output: Print the results in the specified format.\n    # The format is a single line: [val1,val2,val3,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2696634"}]}