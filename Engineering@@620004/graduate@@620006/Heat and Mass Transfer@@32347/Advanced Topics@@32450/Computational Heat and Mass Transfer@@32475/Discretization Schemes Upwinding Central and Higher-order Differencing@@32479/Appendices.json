{"hands_on_practices": [{"introduction": "This practice addresses the steady one-dimensional advection-diffusion equation, a canonical problem for benchmarking numerical schemes. By implementing and comparing the Central Differencing Scheme (CDS) and the first-order Upwind Differencing Scheme (UDS), you will directly observe the fundamental trade-off between the formal accuracy of a scheme and its ability to produce physically realistic, non-oscillatory solutions. This exercise is crucial for understanding the practical consequences of the cell Péclet number, $Pe_h$, and for visualizing common numerical artifacts like spurious oscillations and numerical diffusion. [@problem_id:2478026]", "problem": "Consider the steady, one-dimensional advection-diffusion of a scalar $ \\phi(x) $ on the domain $ x \\in [0, L] $, with constant properties and no volumetric source. The governing equation is the conservation law\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d \\phi}{dx}\\right) - \\rho u \\frac{d \\phi}{dx} = 0,\n$$\nsubject to Dirichlet boundary conditions $ \\phi(0) = 1 $ and $ \\phi(L) = 0 $. Assume $ L = 1 $ meter, $ \\Gamma = 1 $ (diffusivity), and $ \\rho u > 0 $ (flow from left to right). Define the Péclet number as $ \\mathrm{Pe} = \\dfrac{\\rho u L}{\\Gamma} $, so that with $ L = 1 $ and $ \\Gamma = 1 $ we have $ \\rho u = \\mathrm{Pe} $.\n\nFrom the fundamental balance above with constant coefficients, the exact analytical solution is known to be exponential. In this task, you must derive from first principles:\n- the exact solution $ \\phi_{\\mathrm{exact}}(x) $,\n- a linear discrete system for the unknown nodal values on a uniform grid using the finite difference method (FDM), once with a central differencing approximation for the convective derivative and once with a first-order upwind differencing approximation for the convective derivative.\n\nUse a uniform grid of $ N $ nodes (including the boundaries at $ x=0 $ and $ x=L $) with grid spacing $ \\Delta x = \\dfrac{L}{N-1} $. Let the interior node indices be $ i = 1, 2, \\ldots, N-2 $. Impose the boundary conditions strongly at $ i = 0 $ and $ i = N-1 $. For the diffusion term, use the standard second-order central difference for $ \\dfrac{d^2 \\phi}{dx^2} $. For the convection term, implement the following two discretization schemes for $ \\dfrac{d \\phi}{dx} $ at interior nodes:\n- Central differencing scheme (CDS): second-order central difference,\n- First-order upwind differencing scheme (UDS): donor-cell upwind assuming $ u > 0 $.\n\nCompute the discrete solution $ \\phi_{\\mathrm{num}} $ by solving the resulting tridiagonal linear system for each scheme and parameter set listed in the test suite below. Then, quantify and compare boundary-layer resolution using a width metric based on two isovalues. Specifically, define the boundary-layer width $ w $ as the difference in positions $ x(\\alpha_1) $ and $ x(\\alpha_2) $, where $ \\alpha_1 = 0.9 $ and $ \\alpha_2 = 0.1 $, and $ x(\\alpha) $ is the location where $ \\phi(x) = \\alpha $, found by linear interpolation between neighboring grid nodes. Compute this width both for the exact solution and for the numerical solution, and form the dimensionless boundary-layer resolution ratio $ r = \\dfrac{w_{\\mathrm{num}}}{w_{\\mathrm{exact}}} $. Additionally, compute the Root-Mean-Square (RMS) error $ \\varepsilon_{\\mathrm{rms}} = \\sqrt{\\dfrac{1}{N} \\sum_{j=0}^{N-1} \\left(\\phi_{\\mathrm{num}}(x_j) - \\phi_{\\mathrm{exact}}(x_j)\\right)^2 } $ over all grid nodes, and a boolean monotonicity flag indicating whether the discrete solution is non-increasing from left to right across the domain.\n\nYou must implement the above and evaluate the following test suite of parameter sets, where $ \\mathrm{Pe} \\in \\{2, 5, 10\\} $ and $ N \\in \\{21, 5\\} $ as listed. For each case, use the specified discretization scheme:\n- Case $1$: scheme $=$ CDS, $ \\mathrm{Pe} = 2 $, $ N = 21 $,\n- Case $2$: scheme $=$ UDS, $ \\mathrm{Pe} = 2 $, $ N = 21 $,\n- Case $3$: scheme $=$ CDS, $ \\mathrm{Pe} = 5 $, $ N = 21 $,\n- Case $4$: scheme $=$ UDS, $ \\mathrm{Pe} = 5 $, $ N = 21 $,\n- Case $5$: scheme $=$ CDS, $ \\mathrm{Pe} = 10 $, $ N = 21 $,\n- Case $6$: scheme $=$ UDS, $ \\mathrm{Pe} = 10 $, $ N = 21 $,\n- Case $7$: scheme $=$ CDS, $ \\mathrm{Pe} = 5 $, $ N = 5 $,\n- Case $8$: scheme $=$ UDS, $ \\mathrm{Pe} = 5 $, $ N = 5 $,\n- Case $9$: scheme $=$ CDS, $ \\mathrm{Pe} = 10 $, $ N = 5 $,\n- Case $10$: scheme $=$ UDS, $ \\mathrm{Pe} = 10 $, $ N = 5 $.\n\nFor each case, compute and report the tuple $ [s, \\mathrm{Pe}, N, \\varepsilon_{\\mathrm{rms}}, r, \\text{monotone}] $, where $ s $ is an integer scheme code defined as $ s=0 $ for CDS and $ s=1 $ for UDS, $ \\varepsilon_{\\mathrm{rms}} $ is dimensionless, $ r $ is dimensionless, and $ \\text{monotone} $ is a boolean that is $ \\text{True} $ if $ \\phi_{\\mathrm{num}}(x_{j+1}) \\le \\phi_{\\mathrm{num}}(x_{j}) $ for all adjacent nodes and $ \\text{False} $ otherwise. The location-based quantities use meters for $ x $ internally, but only the dimensionless ratio $ r $ must be reported.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list as specified above (for example, $ [ [\\cdot], [\\cdot], \\ldots ] $). No other text should be printed.", "solution": "We start from the steady, one-dimensional advection-diffusion equation with constant properties and no source,\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d \\phi}{dx}\\right) - \\rho u \\frac{d \\phi}{dx} = 0, \\quad x \\in [0,L],\n$$\nwith Dirichlet boundary conditions $ \\phi(0) = 1 $ and $ \\phi(L) = 0 $. With constant $ \\Gamma $ and $ \\rho u $, this simplifies to\n$$\n\\Gamma \\frac{d^2 \\phi}{dx^2} - \\rho u \\frac{d \\phi}{dx} = 0.\n$$\nLet $ P = \\dfrac{\\rho u}{\\Gamma} $ be constant. Then\n$$\n\\frac{d^2 \\phi}{dx^2} - P \\frac{d \\phi}{dx} = 0.\n$$\nIntroduce $ \\psi = \\dfrac{d \\phi}{dx} $. Then $ \\dfrac{d \\psi}{dx} - P \\psi = 0 $, giving $ \\psi(x) = C_1 e^{P x} $. Integrating,\n$$\n\\phi(x) = \\frac{C_1}{P} e^{P x} + C_2.\n$$\nUsing $ \\phi(0) = 1 $ and $ \\phi(L) = 0 $ yields\n$$\n\\phi(x) = 1 - \\frac{e^{P x} - 1}{e^{P L} - 1} = \\frac{e^{P L} - e^{P x}}{e^{P L} - 1}.\n$$\nWith $ L = 1 $, $ \\Gamma = 1 $, and $ \\mathrm{Pe} = \\dfrac{\\rho u L}{\\Gamma} = \\rho u $, we have $ P = \\mathrm{Pe} $ and the exact solution is\n$$\n\\phi_{\\mathrm{exact}}(x) = \\frac{e^{\\mathrm{Pe}} - e^{\\mathrm{Pe} x}}{e^{\\mathrm{Pe}} - 1}.\n$$\n\nTo quantify boundary-layer width, define the locations $ x(\\alpha) $ such that $ \\phi(x(\\alpha)) = \\alpha $, for $ \\alpha_1 = 0.9 $ and $ \\alpha_2 = 0.1 $. For the exact solution, inverting the exponential relation gives\n$$\n\\alpha = \\frac{e^{\\mathrm{Pe}} - e^{\\mathrm{Pe} x}}{e^{\\mathrm{Pe}} - 1} \\quad \\Longrightarrow \\quad e^{\\mathrm{Pe} x} = e^{\\mathrm{Pe}} - \\alpha (e^{\\mathrm{Pe}} - 1) = (1-\\alpha) e^{\\mathrm{Pe}} + \\alpha,\n$$\nso\n$$\nx(\\alpha) = \\frac{1}{\\mathrm{Pe}} \\ln\\!\\big( \\alpha + (1-\\alpha) e^{\\mathrm{Pe}} \\big).\n$$\nTherefore, the exact boundary-layer width between $ \\alpha_1 $ and $ \\alpha_2 $ is\n$$\nw_{\\mathrm{exact}} = x(0.1) - x(0.9) = \\frac{1}{\\mathrm{Pe}} \\left[ \\ln\\!\\big(0.1 + 0.9 e^{\\mathrm{Pe}}\\big) - \\ln\\!\\big(0.9 + 0.1 e^{\\mathrm{Pe}}\\big) \\right].\n$$\n\nFor the numerical approximation, use a uniform grid of $ N $ nodes with $ \\Delta x = \\dfrac{L}{N-1} $ and nodal positions $ x_j = j \\Delta x $, $ j = 0,1,\\ldots,N-1 $. The interior unknowns are $ \\phi_1, \\ldots, \\phi_{N-2} $. The diffusion term is approximated by the second-order central difference\n$$\n\\left.\\frac{d^2 \\phi}{dx^2}\\right|_{x_i} \\approx \\frac{\\phi_{i-1} - 2 \\phi_i + \\phi_{i+1}}{\\Delta x^2}.\n$$\nFor the convection term $ \\dfrac{d \\phi}{dx} $ at $ x_i $, we employ two alternatives:\n- Central differencing scheme (CDS):\n$$\n\\left.\\frac{d \\phi}{dx}\\right|_{x_i} \\approx \\frac{\\phi_{i+1} - \\phi_{i-1}}{2 \\Delta x}.\n$$\n- First-order upwind differencing scheme (UDS) for $ u > 0 $:\n$$\n\\left.\\frac{d \\phi}{dx}\\right|_{x_i} \\approx \\frac{\\phi_{i} - \\phi_{i-1}}{\\Delta x}.\n$$\n\nSubstituting into $ \\Gamma \\dfrac{d^2 \\phi}{dx^2} - \\rho u \\dfrac{d \\phi}{dx} = 0 $ at interior node $ i $ yields linear algebraic equations of the tridiagonal form $ a_W \\phi_{i-1} + a_P \\phi_i + a_E \\phi_{i+1} = b_i $, with coefficients depending on the scheme:\n- For CDS:\n$$\na_W = \\frac{\\Gamma}{\\Delta x^2} + \\frac{\\rho u}{2 \\Delta x}, \\quad\na_P = -\\frac{2 \\Gamma}{\\Delta x^2}, \\quad\na_E = \\frac{\\Gamma}{\\Delta x^2} - \\frac{\\rho u}{2 \\Delta x}.\n$$\n- For UDS (with $ u > 0 $):\n$$\na_W = \\frac{\\Gamma}{\\Delta x^2} + \\frac{\\rho u}{\\Delta x}, \\quad\na_P = -\\frac{2 \\Gamma}{\\Delta x^2} - \\frac{\\rho u}{\\Delta x}, \\quad\na_E = \\frac{\\Gamma}{\\Delta x^2}.\n$$\nBoundary conditions are imposed by substituting $ \\phi_0 = 1 $ and $ \\phi_{N-1} = 0 $ into the first and last interior equations, which modifies the right-hand side $ b_i $ for $ i = 1 $ and $ i = N-2 $:\n$$\nb_1 \\leftarrow b_1 - a_W \\phi_0, \\quad b_{N-2} \\leftarrow b_{N-2} - a_E \\phi_{N-1}.\n$$\nAll other $ b_i $ are zero. With $ L = 1 $, $ \\Gamma = 1 $, and $ \\rho u = \\mathrm{Pe} $, the coefficients are directly computable from $ \\Delta x $ and $ \\mathrm{Pe} $. The resulting tridiagonal linear system is solved for $ \\phi_1, \\ldots, \\phi_{N-2} $, and then $ \\phi_0 = 1 $ and $ \\phi_{N-1} = 0 $ are appended to obtain the full discrete solution $ \\phi_{\\mathrm{num}} $.\n\nTo assess solution quality and boundary-layer resolution:\n- Compute the exact profile $ \\phi_{\\mathrm{exact}}(x_j) $ and the Root-Mean-Square (RMS) error\n$$\n\\varepsilon_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(\\phi_{\\mathrm{num}}(x_j) - \\phi_{\\mathrm{exact}}(x_j)\\right)^2 }.\n$$\n- Compute $ x(\\alpha) $ for the discrete solution by scanning from left to right to find the first interval $ [x_{k-1}, x_k] $ where $ \\phi_{\\mathrm{num}} $ crosses the level $ \\alpha $ and linearly interpolating:\n$$\nx_{\\mathrm{num}}(\\alpha) = x_{k-1} + \\frac{\\alpha - \\phi_{k-1}}{\\phi_k - \\phi_{k-1}} \\Delta x.\n$$\nThen obtain $ w_{\\mathrm{num}} = x_{\\mathrm{num}}(0.1) - x_{\\mathrm{num}}(0.9) $ and the resolution ratio $ r = \\dfrac{w_{\\mathrm{num}}}{w_{\\mathrm{exact}}} $.\n- Determine monotonicity by checking $ \\phi_{\\mathrm{num}}(x_{j+1}) \\le \\phi_{\\mathrm{num}}(x_j) $ for all $ j $ (within a small numerical tolerance), yielding a boolean flag.\n\nRegarding stability and oscillations, the central differencing scheme (CDS) for the convection term is known to produce non-monotone, oscillatory solutions when the cell Péclet number $ \\mathrm{Pe}_h = \\dfrac{\\rho u \\Delta x}{\\Gamma} = \\mathrm{Pe} \\Delta x $ exceeds $ 2 $. In our test suite, with $ N = 5 $ and $ \\mathrm{Pe} = 10 $, we have $ \\Delta x = \\dfrac{1}{4} $ and $ \\mathrm{Pe}_h = 2.5 > 2 $, so CDS is expected to be non-monotone, while UDS remains monotone but more diffusive (larger $ r $). For $ N = 21 $ and $ \\mathrm{Pe} \\in \\{2,5,10\\} $, $ \\Delta x = \\dfrac{1}{20} $ so $ \\mathrm{Pe}_h \\in \\{0.1, 0.25, 0.5\\} $, for which CDS remains monotone and usually more accurate than UDS.\n\nAlgorithmic steps for each test case are:\n1. Set $ L = 1 $, $ \\Gamma = 1 $, $ \\rho u = \\mathrm{Pe} $, and build the uniform grid with $ N $ nodes.\n2. Assemble the tridiagonal system using the chosen convection discretization (CDS or UDS) and central diffusion, incorporating boundary values in the right-hand side.\n3. Solve the linear system to obtain $ \\phi_{\\mathrm{num}} $ on all nodes.\n4. Evaluate $ \\phi_{\\mathrm{exact}}(x_j) $ and compute $ \\varepsilon_{\\mathrm{rms}} $.\n5. Compute $ w_{\\mathrm{exact}} $ from the closed-form expression, and $ w_{\\mathrm{num}} $ from linear interpolation at levels $ \\alpha_1 = 0.9 $ and $ \\alpha_2 = 0.1 $, then form $ r $.\n6. Check monotonicity of $ \\phi_{\\mathrm{num}} $ across the grid to produce the boolean flag.\n7. Output the list $ [s, \\mathrm{Pe}, N, \\varepsilon_{\\mathrm{rms}}, r, \\text{monotone}] $ with $ s = 0 $ for CDS and $ s = 1 $ for UDS.\n\nThe final program implements these steps for the ten specified cases and prints a single line containing the list of results as required.", "answer": "```python\nimport numpy as np\n\ndef exact_phi(x, Pe):\n    # Exact solution for L=1, Gamma=1, rho*u = Pe\n    # phi(x) = (exp(Pe) - exp(Pe*x)) / (exp(Pe) - 1)\n    exPe = np.exp(Pe)\n    denom = exPe - 1.0\n    return (exPe - np.exp(Pe * x)) / denom\n\ndef exact_bl_width(Pe):\n    # w_exact = (1/Pe) [ ln(0.1 + 0.9 e^Pe) - ln(0.9 + 0.1 e^Pe) ]\n    exPe = np.exp(Pe)\n    a1 = 0.1 + 0.9 * exPe\n    a2 = 0.9 + 0.1 * exPe\n    return (np.log(a1) - np.log(a2)) / Pe\n\ndef build_system(N, Pe, scheme):\n    # L=1, Gamma=1, rho*u = Pe\n    L = 1.0\n    Gamma = 1.0\n    rhou = Pe\n    dx = L / (N - 1)\n    # Interior unknowns: indices 1..N-2\n    m = N - 2\n    A = np.zeros((m, m), dtype=float)\n    b = np.zeros(m, dtype=float)\n    # Coefficients per scheme\n    if scheme == 'central':\n        aW = Gamma / dx**2 + rhou / (2.0 * dx)\n        aP = -2.0 * Gamma / dx**2\n        aE = Gamma / dx**2 - rhou / (2.0 * dx)\n    elif scheme == 'upwind':\n        aW = Gamma / dx**2 + rhou / dx\n        aP = -2.0 * Gamma / dx**2 - rhou / dx\n        aE = Gamma / dx**2\n    else:\n        raise ValueError(\"Unknown scheme\")\n    # Assemble tridiagonal matrix\n    for i in range(m):\n        # global index is i+1\n        if i - 1 >= 0:\n            A[i, i - 1] = aW\n        A[i, i] = aP\n        if i + 1 < m:\n            A[i, i + 1] = aE\n    # Apply Dirichlet BCs: phi_0 = 1, phi_{N-1} = 0\n    # Modify b for first and last interior equations\n    b[0] -= aW * 1.0  # phi_0 = 1\n    b[-1] -= aE * 0.0  # phi_{N-1} = 0\n    return A, b\n\ndef solve_case(scheme, Pe, N):\n    # Build and solve\n    A, b = build_system(N, Pe, scheme)\n    # Solve interior\n    phi_interior = np.linalg.solve(A, b)\n    # Construct full solution with boundaries\n    phi = np.zeros(N, dtype=float)\n    phi[0] = 1.0\n    phi[-1] = 0.0\n    phi[1:-1] = phi_interior\n    # Grid\n    x = np.linspace(0.0, 1.0, N)\n    # Exact\n    phi_ex = exact_phi(x, Pe)\n    # RMS error\n    rms = np.sqrt(np.mean((phi - phi_ex) ** 2))\n    # Boundary layer width: compute for numerical by linear interpolation\n    def interp_x_for_alpha(alpha):\n        # Find first index where phi <= alpha\n        for k in range(1, N):\n            if (phi[k - 1] >= alpha and phi[k] <= alpha) or (phi[k - 1] <= alpha and phi[k] >= alpha):\n                # Linear interpolation\n                if phi[k] == phi[k - 1]:\n                    return x[k]  # degenerate, return right node\n                t = (alpha - phi[k - 1]) / (phi[k] - phi[k - 1])\n                return x[k - 1] + t * (x[k] - x[k - 1])\n        return np.nan\n    x09 = interp_x_for_alpha(0.9)\n    x01 = interp_x_for_alpha(0.1)\n    w_num = x01 - x09 if (np.isfinite(x01) and np.isfinite(x09)) else np.nan\n    w_ex = exact_bl_width(Pe)\n    r = w_num / w_ex if np.isfinite(w_num) and w_ex != 0.0 else np.nan\n    # Monotonicity: non-increasing across nodes\n    tol = 1e-12\n    monotone = np.all(phi[1:] <= phi[:-1] + tol)\n    # Scheme code: 0 for central, 1 for upwind\n    s_code = 0 if scheme == 'central' else 1\n    return [s_code, float(Pe), int(N), float(rms), float(r), bool(monotone)]\n\ndef solve():\n    test_cases = [\n        ('central', 2.0, 21),\n        ('upwind',  2.0, 21),\n        ('central', 5.0, 21),\n        ('upwind',  5.0, 21),\n        ('central',10.0, 21),\n        ('upwind', 10.0, 21),\n        ('central', 5.0, 5),\n        ('upwind',  5.0, 5),\n        ('central',10.0, 5),\n        ('upwind', 10.0, 5),\n    ]\n    results = []\n    for scheme, Pe, N in test_cases:\n        results.append(solve_case(scheme, Pe, N))\n    # Format output as a single-line list of lists\n    # Ensure booleans and floats are printed naturally\n    def format_inner(lst):\n        # Convert Python list to string without spaces after commas\n        return \"[\" + \",\".join(str(item) for item in lst) + \"]\"\n    print(\"[\" + \",\".join(format_inner(r) for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2478026"}, {"introduction": "In the previous exercise [@problem_id:2478026], you likely observed that the upwind scheme, while stable, produced an overly 'smeared' profile. This practice delves into the theoretical reason for this behavior through a modified equation analysis, a powerful technique that reveals the differential equation a numerical scheme truly solves. You will derive the leading-order truncation error of the upwind scheme and interpret it as an artificial 'numerical diffusion' term, $\\Gamma_{\\text{num}}$, which provides a profound physical insight into why first-order schemes are often unacceptably inaccurate for advection-dominated problems. [@problem_id:2478002]", "problem": "Consider steady, one-dimensional transport of a passive scalar $\\,\\phi(x)\\,$ in a stationary medium with constant density $\\,\\rho\\,$, constant uniform velocity $\\,u>0\\,$, and constant molecular diffusivity $\\,\\Gamma\\,$ over a uniform grid of spacing $\\,\\Delta x\\,$. The governing differential statement of conservation is\n$$\n\\frac{d}{dx}\\!\\left(\\Gamma\\,\\frac{d\\phi}{dx}\\right)\\;-\\;\\rho\\,u\\,\\frac{d\\phi}{dx}\\;=\\;0.\n$$\nA finite-volume discretization is performed on control volumes centered at nodes $\\,x_P\\,$ with faces at $\\,x_w=x_P-\\tfrac{\\Delta x}{2}\\,$ and $\\,x_e=x_P+\\tfrac{\\Delta x}{2}\\,$. The diffusive fluxes at faces are approximated by second-order central differencing, while the convective fluxes at faces are approximated by first-order upwinding (i.e., face values are taken from the upwind node for $\\,u>0\\,$).\n\nStarting only from this conservation law, the uniform grid geometry, and the stated approximations, use a Taylor-series-based modified-equation analysis to identify the leading-order truncation term induced by the upwind discretization of the convective flux. Interpret this term as an additive numerical diffusion $\\,\\Gamma_{\\text{num}}\\,$ multiplying $\\,\\tfrac{d^{2}\\phi}{dx^{2}}\\,$, and thereby obtain the effective total diffusion\n$$\n\\Gamma_{\\text{eff}} \\;=\\; \\Gamma \\;+\\; \\Gamma_{\\text{num}}.\n$$\nExpress your final result for $\\,\\Gamma_{\\text{eff}}\\,$ in closed form in terms of the molecular diffusion $\\,\\Gamma\\,$ and the cell Péclet number (Péclet number) \n$$\n\\mathrm{Pe} \\;=\\; \\frac{\\rho\\,u\\,\\Delta x}{\\Gamma}.\n$$\nThen, based on the same modified-equation reasoning, qualitatively predict how the discrete solution’s boundary-layer thickness and interior gradient errors trend relative to the exact continuous solution as $\\,\\mathrm{Pe}\\,$ increases at fixed $\\,\\Delta x\\,$ and $\\,\\Gamma\\,$. No numerical evaluation is required. State your final answer for $\\,\\Gamma_{\\text{eff}}\\,$ as a single closed-form analytic expression; do not include units.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is a standard exercise in the analysis of numerical methods for transport phenomena. I will proceed with the derivation.\n\nThe governing steady, one-dimensional advection-diffusion equation for a passive scalar $\\phi(x)$ is given as:\n$$\n\\frac{d}{dx}\\!\\left(\\Gamma\\,\\frac{d\\phi}{dx}\\right)\\;-\\;\\rho\\,u\\,\\frac{d\\phi}{dx}\\;=\\;0\n$$\nGiven that the density $\\rho$, velocity $u$, and molecular diffusivity $\\Gamma$ are constant, this simplifies to:\n$$\n\\Gamma\\,\\frac{d^2\\phi}{dx^2} \\;-\\; \\rho\\,u\\,\\frac{d\\phi}{dx}\\;=\\;0\n$$\nTo discretize this equation using the finite volume method, we integrate it over a control volume of length $\\Delta x$ centered at a grid node $x_P$. The faces of this control volume are at $x_w = x_P - \\frac{\\Delta x}{2}$ and $x_e = x_P + \\frac{\\Delta x}{2}$.\n$$\n\\int_{x_w}^{x_e} \\left( \\Gamma\\,\\frac{d^2\\phi}{dx^2} \\;-\\; \\rho\\,u\\,\\frac{d\\phi}{dx} \\right) dx \\;=\\; 0\n$$\nApplying the fundamental theorem of calculus, this becomes a balance of fluxes at the control volume faces:\n$$\n\\left[ \\Gamma\\,\\frac{d\\phi}{dx} \\right]_{x_w}^{x_e} \\;-\\; \\left[ \\rho\\,u\\,\\phi \\right]_{x_w}^{x_e} \\;=\\; 0\n$$\nThis can be written as:\n$$\n\\left( \\Gamma\\,\\frac{d\\phi}{dx} \\right)_e - \\left( \\Gamma\\,\\frac{d\\phi}{dx} \\right)_w - \\left( (\\rho\\,u\\,\\phi)_e - (\\rho\\,u\\,\\phi)_w \\right) = 0\n$$\nHere, the subscripts $e$ and $w$ denote evaluation at the east and west faces, respectively.\n\nWe now introduce the specified numerical approximations. The grid nodes are denoted by $W$ (west, $x_P - \\Delta x$), $P$ (center, $x_P$), and $E$ (east, $x_P + \\Delta x$).\n\nThe diffusive fluxes are approximated using second-order central differencing:\n$$\n\\left( \\Gamma\\,\\frac{d\\phi}{dx} \\right)_e \\approx \\Gamma\\,\\frac{\\phi_E - \\phi_P}{\\Delta x}\n$$\n$$\n\\left( \\Gamma\\,\\frac{d\\phi}{dx} \\right)_w \\approx \\Gamma\\,\\frac{\\phi_P - \\phi_W}{\\Delta x}\n$$\n\nThe convective fluxes are approximated using first-order upwinding. Since the velocity $u>0$, the flow is from west to east. Therefore, the value of $\\phi$ at a face is taken from the upwind node.\nFor the east face at $x_e$, the upwind node is $P$. Thus:\n$$\n(\\rho\\,u\\,\\phi)_e = \\rho\\,u\\,\\phi_e \\approx \\rho\\,u\\,\\phi_P\n$$\nFor the west face at $x_w$, the upwind node is $W$. Thus:\n$$\n(\\rho\\,u\\,\\phi)_w = \\rho\\,u\\,\\phi_w \\approx \\rho\\,u\\,\\phi_W\n$$\n\nSubstituting these discrete approximations into the integrated balance equation yields the discrete equation for node $P$:\n$$\n\\Gamma\\,\\frac{\\phi_E - \\phi_P}{\\Delta x} - \\Gamma\\,\\frac{\\phi_P - \\phi_W}{\\Delta x} - (\\rho\\,u\\,\\phi_P - \\rho\\,u\\,\\phi_W) = 0\n$$\nRearranging and dividing by $\\Delta x$ to relate the terms to derivatives:\n$$\n\\Gamma\\,\\frac{\\phi_E - 2\\phi_P + \\phi_W}{\\Delta x^2} - \\rho\\,u\\,\\frac{\\phi_P - \\phi_W}{\\Delta x} = 0\n$$\nThis is the finite difference equation that the numerical scheme solves at each node. To perform the modified-equation analysis, we replace the nodal values $\\phi_W$ and $\\phi_E$ with their Taylor series expansions around $x_P$, where we use the notation $\\phi'_P = (\\frac{d\\phi}{dx})_P$, $\\phi''_P = (\\frac{d^2\\phi}{dx^2})_P$, and so on.\n$$\n\\phi_E = \\phi_P + \\Delta x \\, \\phi'_P + \\frac{(\\Delta x)^2}{2!} \\, \\phi''_P + \\frac{(\\Delta x)^3}{3!} \\, \\phi'''_P + \\dots\n$$\n$$\n\\phi_W = \\phi_P - \\Delta x \\, \\phi'_P + \\frac{(\\Delta x)^2}{2!} \\, \\phi''_P - \\frac{(\\Delta x)^3}{3!} \\, \\phi'''_P + \\dots\n$$\n\nNow we expand the two terms of the discrete equation.\nFor the diffusion term's finite difference operator:\n$$\n\\frac{\\phi_E - 2\\phi_P + \\phi_W}{\\Delta x^2} = \\frac{1}{\\Delta x^2} \\left[ \\left(\\phi_P + \\Delta x \\, \\phi'_P + \\frac{\\Delta x^2}{2} \\, \\phi''_P + \\dots\\right) - 2\\phi_P + \\left(\\phi_P - \\Delta x \\, \\phi'_P + \\frac{\\Delta x^2}{2} \\, \\phi''_P - \\dots\\right) \\right]\n$$\n$$\n= \\frac{1}{\\Delta x^2} \\left[ \\Delta x^2 \\, \\phi''_P + \\frac{2(\\Delta x)^4}{4!} \\, \\phi''''_P + \\dots \\right] = \\phi''_P + \\frac{\\Delta x^2}{12} \\, \\phi''''_P + O(\\Delta x^4)\n$$\nFor the convection term's finite difference operator:\n$$\n\\frac{\\phi_P - \\phi_W}{\\Delta x} = \\frac{1}{\\Delta x} \\left[ \\phi_P - \\left(\\phi_P - \\Delta x \\, \\phi'_P + \\frac{\\Delta x^2}{2} \\, \\phi''_P - \\dots\\right) \\right]\n$$\n$$\n= \\frac{1}{\\Delta x} \\left[ \\Delta x \\, \\phi'_P - \\frac{\\Delta x^2}{2} \\, \\phi''_P + \\frac{\\Delta x^3}{6} \\, \\phi'''_P - \\dots \\right] = \\phi'_P - \\frac{\\Delta x}{2} \\, \\phi''_P + \\frac{\\Delta x^2}{6} \\, \\phi'''_P - \\dots\n$$\n\nSubstituting these expansions back into the discrete equation gives the modified equation, which is the differential equation that the numerical scheme is actually solving:\n$$\n\\Gamma \\left( \\phi''_P + \\frac{\\Delta x^2}{12} \\phi''''_P + \\dots \\right) - \\rho\\,u \\left( \\phi'_P - \\frac{\\Delta x}{2} \\phi''_P + \\frac{\\Delta x^2}{6} \\phi'''_P - \\dots \\right) = 0\n$$\nWe group the terms to match the original differential equation and identify the remaining truncation error terms:\n$$\n\\left( \\Gamma \\phi''_P - \\rho\\,u\\,\\phi'_P \\right) + \\left( \\frac{\\rho\\,u\\,\\Delta x}{2} \\phi''_P \\right) - \\frac{\\rho\\,u\\,\\Delta x^2}{6} \\phi'''_P + \\frac{\\Gamma\\,\\Delta x^2}{12} \\phi''''_P + \\dots = 0\n$$\nThe leading-order truncation term is the one with the lowest power of $\\Delta x$, which is $\\frac{\\rho\\,u\\,\\Delta x}{2} \\phi''_P$. This term is of order $O(\\Delta x)$, confirming that the upwind scheme is first-order accurate.\nThis leading-order error term has the form of a diffusion term, as it is proportional to the second derivative $\\phi''_P$. We can thus define a numerical diffusion coefficient, $\\Gamma_{\\text{num}}$, such that this term is $\\Gamma_{\\text{num}} \\phi''_P$.\n$$\n\\Gamma_{\\text{num}} \\frac{d^2\\phi}{dx^2} = \\frac{\\rho\\,u\\,\\Delta x}{2} \\frac{d^2\\phi}{dx^2} \\implies \\Gamma_{\\text{num}} = \\frac{\\rho\\,u\\,\\Delta x}{2}\n$$\nThe modified equation, to leading order, can be rewritten by clumping the physical and numerical diffusion terms:\n$$\n\\left(\\Gamma + \\Gamma_{\\text{num}}\\right) \\frac{d^2\\phi}{dx^2} - \\rho\\,u\\,\\frac{d\\phi}{dx} + O(\\Delta x^2) = 0\n$$\nThe effective diffusion coefficient, $\\Gamma_{\\text{eff}}$, is therefore the sum of the physical and numerical diffusion coefficients:\n$$\n\\Gamma_{\\text{eff}} = \\Gamma + \\Gamma_{\\text{num}} = \\Gamma + \\frac{\\rho\\,u\\,\\Delta x}{2}\n$$\nTo express this in terms of the molecular diffusion $\\Gamma$ and the cell Péclet number $\\mathrm{Pe} = \\frac{\\rho\\,u\\,\\Delta x}{\\Gamma}$, we factor out $\\Gamma$:\n$$\n\\Gamma_{\\text{eff}} = \\Gamma \\left( 1 + \\frac{\\rho\\,u\\,\\Delta x}{2\\Gamma} \\right) = \\Gamma \\left( 1 + \\frac{\\mathrm{Pe}}{2} \\right)\n$$\nThis expression reveals that the numerical scheme introduces an artificial diffusion that is directly proportional to the cell Péclet number.\n\nFor the qualitative analysis, we consider the effect of increasing $\\mathrm{Pe}$ at fixed $\\Delta x$ and $\\Gamma$, which corresponds to increasing the velocity $u$.\nThe exact solution to the original equation, $\\Gamma\\,\\phi'' - \\rho\\,u\\,\\phi' = 0$, has features, such as boundary layers, whose characteristic thickness $\\delta$ is proportional to the ratio of diffusive to convective transport, i.e., $\\delta \\sim \\frac{\\Gamma}{\\rho u}$. As $\\mathrm{Pe}$ (and thus $u$) increases, $\\delta$ decreases, meaning the physical boundary layers become thinner and gradients become steeper.\nThe numerical solution, however, behaves according to the modified equation, governed by $\\Gamma_{\\text{eff}}$. The characteristic thickness of features in the numerical solution, $\\delta_{\\text{num}}$, will be proportional to $\\frac{\\Gamma_{\\text{eff}}}{\\rho u}$.\n$$\n\\delta_{\\text{num}} \\sim \\frac{\\Gamma_{\\text{eff}}}{\\rho u} = \\frac{\\Gamma + \\frac{\\rho u \\Delta x}{2}}{\\rho u} = \\frac{\\Gamma}{\\rho u} + \\frac{\\Delta x}{2}\n$$\nAs $\\mathrm{Pe}$ increases, the physical boundary layer thickness $\\delta \\sim \\frac{\\Gamma}{\\rho u}$ approaches zero. However, the numerical boundary layer thickness $\\delta_{\\text{num}}$ approaches a limiting value of $\\frac{\\Delta x}{2}$. This means the numerical solution will fail to resolve the increasingly sharp gradients of the exact solution. This excessive, artificial thickening of gradients is known as numerical smearing. The boundary-layer thickness error will grow substantially with $\\mathrm{Pe}$.\nSimilarly, in the interior of the domain, the numerical diffusion term $\\Gamma_{\\text{num}} \\phi''$ will artificially damp any variations in the solution profile wherever there is curvature ($\\phi'' \\neq 0$). As $\\mathrm{Pe}$ increases, the numerical diffusion $\\Gamma_{\\text{num}}$ increases linearly with $u$, becoming much larger than the physical diffusion $\\Gamma$. This causes the numerical solution to appear far more diffuse than the exact solution, leading to large errors in interior gradients.\nIn summary, as $\\mathrm{Pe}$ increases, the first-order upwind scheme becomes progressively more inaccurate, introducing a dominant numerical diffusion that smears both boundary layers and interior features, causing the numerical solution to deviate significantly from the physically correct, advection-dominated behavior.", "answer": "$$\n\\boxed{\\Gamma \\left( 1 + \\frac{\\mathrm{Pe}}{2} \\right)}\n$$", "id": "2478002"}, {"introduction": "Having witnessed the shortcomings of simple schemes ([@problem_id:2478026], [@problem_id:2478002]), we now turn to a modern, high-resolution approach designed to capture sharp gradients accurately and without oscillations. This practice guides you through implementing the MUSCL-Hancock method, a cornerstone of modern finite volume methods for time-dependent conservation laws. By combining higher-order spatial reconstruction with a slope limiter, you will build a scheme that intelligently adapts its accuracy to provide a robust and precise solution, representing a significant step towards the advanced methods used in computational fluid dynamics. [@problem_id:2477979]", "problem": "Consider the one-dimensional ($1$-D) linear advection of a passive scalar field over a periodic domain, governed by the conservation law\n$$\n\\frac{\\partial \\phi}{\\partial t} + a \\frac{\\partial \\phi}{\\partial x} = 0,\n$$\nwhere $a$ is a constant advection velocity and $\\phi(x,t)$ is a dimensionless scalar (for example, a concentration). Let the spatial domain be periodic on $[0,L]$ with $x$ measured in meters (m), time $t$ in seconds (s), and $a$ in meters per second (m/s). Use a uniform finite-volume mesh with $N$ control volumes of width $\\Delta x = L/N$. Denote by $\\bar{\\phi}_i^n$ the cell-averaged value in cell $i$ at time level $t^n$.\n\nYour task is to implement a single explicit time update from $t^n$ to $t^{n+1}=t^n+\\Delta t$ using a Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL)–Hancock method with a van Leer limiter, and to compare the resulting $\\bar{\\phi}_i^{n+1}$ with the exact advected cell averages computed at $t^{n+1}$ by integrating the initial condition shifted by $a \\Delta t$ around the periodic domain.\n\nFundamental base and requirements:\n- Start from the integral form of the conservation law over cell $i$,\n$$\n\\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} \\phi(x,t)\\,dx + \\left[ F(\\phi)\\big|_{x_{i+\\frac{1}{2}}} - F(\\phi)\\big|_{x_{i-\\frac{1}{2}}} \\right] = 0,\\quad F(\\phi)=a\\phi.\n$$\n- Use a piecewise-linear MUSCL reconstruction with a van Leer slope limiter in each cell $i$. Define\n$$\n\\Delta^-_i = \\bar{\\phi}_i^n - \\bar{\\phi}_{i-1}^n,\\qquad \\Delta^+_i = \\bar{\\phi}_{i+1}^n - \\bar{\\phi}_i^n,\n$$\nwith periodic indexing, and the ratio\n$$\nr_i = \\frac{\\Delta^-_i}{\\Delta^+_i}.\n$$\nThe van Leer limiter is\n$$\n\\Phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|}.\n$$\nThe limited slope is\n$$\n\\sigma_i = \\Phi_{\\mathrm{VL}}(r_i)\\,\\Delta^+_i.\n$$\n- Perform the Hancock predictor to half time step using the cell-local value of the Courant number\n$$\n\\lambda = \\frac{a\\,\\Delta t}{\\Delta x}.\n$$\nForm the predicted interface states at $x_{i+\\frac{1}{2}}$:\n$$\n\\phi_{i+\\frac{1}{2}}^{L,*} = \\bar{\\phi}_i^n + \\frac{1}{2}\\left(1 - \\lambda\\right)\\sigma_i,\\qquad\n\\phi_{i+\\frac{1}{2}}^{R,*} = \\bar{\\phi}_{i+1}^n - \\frac{1}{2}\\left(1 + \\lambda\\right)\\sigma_{i+1}.\n$$\n- Use the exact Riemann solver for linear advection to compute the numerical flux at each interface:\n$$\nF_{i+\\frac{1}{2}} =\n\\begin{cases}\na\\,\\phi_{i+\\frac{1}{2}}^{L,*}, & a \\ge 0,\\\\\na\\,\\phi_{i+\\frac{1}{2}}^{R,*}, & a < 0.\n\\end{cases}\n$$\n- Update the cell average conservatively:\n$$\n\\bar{\\phi}_i^{n+1} = \\bar{\\phi}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwith periodic boundaries.\n\nInitialization and exact reference:\n- Initialize $\\bar{\\phi}_i^n$ as exact cell averages of a given initial condition $\\phi_0(x)$ at $t^n$ over each cell using Gaussian quadrature. Compute the exact reference at $t^{n+1}$ by integrating the shifted initial condition $\\phi_0(x - a\\Delta t)$ over each cell with periodic wrap-around. Use at least $32$-point Gauss–Legendre quadrature per cell to approximate these integrals to high accuracy.\n\nTest suite:\nImplement the above for the following four cases and compute the mean absolute error (discrete $L^1$ error) after one time step,\n$$\nE_1 = \\frac{1}{N}\\sum_{i=0}^{N-1}\\left|\\bar{\\phi}_i^{n+1} - \\bar{\\phi}_{i,\\mathrm{exact}}^{n+1}\\right|.\n$$\nAll parameters are dimensionless except where units are specified. Report $E_1$ as a dimensionless floating-point number.\n\n- Case $1$ (smooth profile, moderate Courant number): $L=1\\,\\mathrm{m}$, $N=100$, $a=1\\,\\mathrm{m/s}$, $\\mathrm{CFL}=0.2$, so $\\Delta t = \\mathrm{CFL}\\cdot \\Delta x/|a|$. Initial condition\n$$\n\\phi_0(x) = 1 + 0.2 \\sin\\left(2\\pi x/L\\right).\n$$\n- Case $2$ (discontinuous top-hat, large Courant number): $L=1\\,\\mathrm{m}$, $N=100$, $a=1\\,\\mathrm{m/s}$, $\\mathrm{CFL}=0.8$. Initial condition\n$$\n\\phi_0(x) =\n\\begin{cases}\n1, & 0.2L \\le x \\le 0.4L,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n- Case $3$ (mixed smooth and discontinuous, negative velocity): $L=1\\,\\mathrm{m}$, $N=128$, $a=-0.75\\,\\mathrm{m/s}$, $\\mathrm{CFL}=0.5$. Initial condition\n$$\n\\phi_0(x) = 0.25 + 0.5\\sin(2\\pi x/L) + \\begin{cases}\n0.75, & 0.6L \\le x \\le 0.8L,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n- Case $4$ (edge Courant number unity): $L=1\\,\\mathrm{m}$, $N=200$, $a=1\\,\\mathrm{m/s}$, $\\mathrm{CFL}=1.0$. Initial condition\n$$\n\\phi_0(x) = \\cos\\left(4\\pi x/L\\right).\n$$\n\nAngle units, if any, are in radians. Time is in seconds, space in meters, and velocity in meters per second. The scalar $\\phi$ is dimensionless. The error values $E_1$ must be reported as dimensionless floating-point numbers.\n\nFinal output format:\nYour program should produce a single line of output containing the four $E_1$ values for the test cases, as a comma-separated list enclosed in square brackets (for example, $[e_1,e_2,e_3,e_4]$). No additional text should be printed. The program must not read any input and must be entirely self-contained.", "solution": "The problem statement is subjected to validation and found to be valid. It is a well-posed, scientifically grounded problem from the field of computational fluid dynamics, specifically concerning numerical methods for hyperbolic conservation laws. The description of the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL)–Hancock method is precise and complete. The test cases are clearly defined and physically consistent. I will now provide the full solution.\n\nThe problem requires the implementation of a single time step for the one-dimensional linear advection equation,\n$$\n\\frac{\\partial \\phi}{\\partial t} + a \\frac{\\partial \\phi}{\\partial x} = 0,\n$$\nusing a finite-volume method on a uniform periodic grid. The core of the method is the MUSCL-Hancock scheme, which achieves second-order accuracy in both space and time while maintaining stability near sharp gradients through a slope limiter.\n\nThe foundation of the finite-volume method is the integral form of the conservation law over a control volume (cell) $i$, extending from $x_{i-\\frac{1}{2}}$ to $x_{i+\\frac{1}{2}}$:\n$$\n\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} \\frac{\\partial \\phi}{\\partial t} \\,dx + \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} \\frac{\\partial (a\\phi)}{\\partial x} \\,dx = 0.\n$$\nDefining the cell average $\\bar{\\phi}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} \\phi(x,t) \\,dx$ and the flux $F(\\phi) = a\\phi$, this becomes\n$$\n\\frac{d\\bar{\\phi}_i}{dt} + \\frac{1}{\\Delta x}\\left[ F(\\phi)\\big|_{x_{i+\\frac{1}{2}}} - F(\\phi)\\big|_{x_{i-\\frac{1}{2}}} \\right] = 0.\n$$\nIntegrating this ordinary differential equation from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ and approximating the time-averaged fluxes yields the conservative update formula:\n$$\n\\bar{\\phi}_i^{n+1} = \\bar{\\phi}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwhere $F_{i\\pm\\frac{1}{2}}$ are numerical fluxes approximating the average flux over the time interval $\\Delta t$ at the cell interfaces. The MUSCL-Hancock method provides a second-order accurate recipe for computing these fluxes.\n\nThe procedure is executed as follows:\n\n1.  **Initialization**: At time $t^n$, we start with the set of cell-averaged values $\\{\\bar{\\phi}_i^n\\}$. For this problem, these are computed by accurately integrating the given initial condition $\\phi_0(x)$ over each cell using high-order Gauss-Legendre quadrature.\n    $$\n    \\bar{\\phi}_i^n = \\frac{1}{\\Delta x} \\int_{x_i - \\Delta x/2}^{x_i + \\Delta x/2} \\phi_0(x) \\,dx.\n    $$\n\n2.  **Spatial Reconstruction with Slope Limiting**: To achieve second-order spatial accuracy, the data is reconstructed from cell averages to a piecewise-linear representation within each cell $i$:\n    $$\n    \\phi_i(x, t^n) = \\bar{\\phi}_i^n + \\sigma_i \\frac{x-x_i}{\\Delta x}, \\quad \\text{for } x \\in [x_{i-1/2}, x_{i+1/2}],\n    $$\n    where $\\sigma_i$ is a limited slope. The limiting process is essential to ensure the scheme is Total Variation Diminishing (TVD), preventing spurious oscillations near discontinuities. The slope is calculated using the van Leer limiter:\n    - First, forward and backward differences are computed with periodic indexing:\n      $$\n      \\Delta^+_i = \\bar{\\phi}_{i+1}^n - \\bar{\\phi}_i^n, \\qquad \\Delta^-_i = \\bar{\\phi}_i^n - \\bar{\\phi}_{i-1}^n.\n      $$\n    - The ratio of these slopes is calculated:\n      $$\n      r_i = \\frac{\\Delta^-_i}{\\Delta^+_i}.\n      $$\n      If $\\Delta^+_i = 0$, the cell is part of a local constant state or extremum, and the limited slope should be zero. This case must be handled to avoid division by zero.\n    - The van Leer limiter function $\\Phi_{\\mathrm{VL}}(r)$ modulates the forward difference to obtain the final slope:\n      $$\n      \\Phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|}.\n      $$\n      This function returns $0$ for $r \\le 0$ and $\\frac{2r}{1+r}$ for $r > 0$, ensuring the slope does not introduce new extrema.\n    - The limited slope for cell $i$ is then:\n      $$\n      \\sigma_i = \\Phi_{\\mathrm{VL}}(r_i) \\, \\Delta^+_i.\n      $$\n\n3.  **Temporal Evolution (Hancock Predictor)**: To achieve second-order temporal accuracy, a predictor step evolves the reconstructed linear data by a half time-step, $\\Delta t/2$. This yields time-centered values at the cell interfaces. The evolution within each cell $i$ is governed by $\\partial_t \\phi = -a \\partial_x \\phi = -a (\\sigma_i / \\Delta x)$. The predicted state at an interface is found by evaluating the evolved linear profile. For the interface at $x_{i+\\frac{1}{2}}$, we need the value from the left (cell $i$) and the right (cell $i+1$):\n    - **Left state**: Evolving the profile from cell $i$ and evaluating at its right boundary $x_{i+\\frac{1}{2}}$:\n      $$\n      \\phi_{i+\\frac{1}{2}}^{L,*} = \\left( \\bar{\\phi}_i^n + \\sigma_i \\frac{(x_{i+\\frac{1}{2}}-x_i)}{\\Delta x} \\right) - \\frac{\\Delta t}{2} \\left( a \\frac{\\sigma_i}{\\Delta x} \\right) = \\bar{\\phi}_i^n + \\frac{\\sigma_i}{2} - \\frac{\\lambda}{2}\\sigma_i = \\bar{\\phi}_i^n + \\frac{1}{2}(1 - \\lambda)\\sigma_i,\n      $$\n      where $\\lambda = a \\Delta t / \\Delta x$ is the Courant number.\n    - **Right state**: Evolving the profile from cell $i+1$ and evaluating at its left boundary $x_{i+\\frac{1}{2}}$:\n      $$\n      \\phi_{i+\\frac{1}{2}}^{R,*} = \\left( \\bar{\\phi}_{i+1}^n + \\sigma_{i+1} \\frac{(x_{i+\\frac{1}{2}}-x_{i+1})}{\\Delta x} \\right) - \\frac{\\Delta t}{2} \\left( a \\frac{\\sigma_{i+1}}{\\Delta x} \\right) = \\bar{\\phi}_{i+1}^n - \\frac{\\sigma_{i+1}}{2} - \\frac{\\lambda}{2}\\sigma_{i+1} = \\bar{\\phi}_{i+1}^n - \\frac{1}{2}(1 + \\lambda)\\sigma_{i+1}.\n      $$\n\n4.  **Flux Calculation (Riemann Solver)**: At each interface $x_{i+\\frac{1}{2}}$, we have a local Riemann problem with the pair of states $(\\phi_{i+\\frac{1}{2}}^{L,*}, \\phi_{i+\\frac{1}{2}}^{R,*})$. For the linear advection equation, the solution is determined by the direction of wave propagation, i.e., the sign of the velocity $a$. This is a simple upwind selection:\n    $$\n    F_{i+\\frac{1}{2}} =\n    \\begin{cases}\n    a\\,\\phi_{i+\\frac{1}{2}}^{L,*}, & \\text{if } a \\ge 0, \\\\\n    a\\,\\phi_{i+\\frac{1}{2}}^{R,*}, & \\text{if } a < 0.\n    \\end{cases}\n    $$\n\n5.  **Corrector Update**: The computed fluxes are used in the conservative update formula to advance the cell averages to time $t^{n+1}$:\n    $$\n    \\bar{\\phi}_i^{n+1} = \\bar{\\phi}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right).\n    $$\n    Periodic boundary conditions require that the flux $F_{-\\frac{1}{2}}$ corresponds to $F_{N-\\frac{1}{2}}$.\n\n6.  **Error Calculation**: The accuracy of the numerical solution is assessed by comparing it to the exact solution. For linear advection, the exact solution at time $t^{n+1}$ is the initial profile shifted by $a\\Delta t$: $\\phi(x, t^{n+1}) = \\phi_0(x - a\\Delta t)$, with periodic wraparound on the domain $[0, L]$. The exact cell averages, $\\bar{\\phi}_{i, \\mathrm{exact}}^{n+1}$, are computed by integrating this shifted profile over each cell using high-order Gaussian quadrature. The discrete $L^1$ error is then computed as:\n    $$\n    E_1 = \\frac{1}{N}\\sum_{i=0}^{N-1}\\left|\\bar{\\phi}_i^{n+1} - \\bar{\\phi}_{i,\\mathrm{exact}}^{n+1}\\right|.\n    $$\nThis procedure is followed for each test case specified in the problem statement. The implementation will use `numpy` for efficient array operations and `scipy.special.roots_legendre` for Gaussian quadrature.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a MUSCL-Hancock scheme\n    for four test cases and computes the L1 error after one time step.\n    \"\"\"\n    \n    # Define the four test cases as per the problem description.\n    def phi0_case1(x, L):\n        return 1.0 + 0.2 * np.sin(2.0 * np.pi * x / L)\n\n    def phi0_case2(x, L):\n        return np.where((x >= 0.2 * L) & (x <= 0.4 * L), 1.0, 0.0)\n\n    def phi0_case3(x, L):\n        base = 0.25 + 0.5 * np.sin(2.0 * np.pi * x / L)\n        square = np.where((x >= 0.6 * L) & (x <= 0.8 * L), 0.75, 0.0)\n        return base + square\n\n    def phi0_case4(x, L):\n        return np.cos(4.0 * np.pi * x / L)\n\n    test_cases = [\n        {'L': 1.0, 'N': 100, 'a': 1.0, 'CFL': 0.2, 'phi0_func': phi0_case1},\n        {'L': 1.0, 'N': 100, 'a': 1.0, 'CFL': 0.8, 'phi0_func': phi0_case2},\n        {'L': 1.0, 'N': 128, 'a': -0.75, 'CFL': 0.5, 'phi0_func': phi0_case3},\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'CFL': 1.0, 'phi0_func': phi0_case4},\n    ]\n\n    results = []\n    \n    # Use a high-order Gaussian quadrature (64 points) for accurate integration.\n    QUAD_ORDER = 64\n    xi, w = roots_legendre(QUAD_ORDER)\n\n    def get_cell_averages(func, L, N, dx, cell_centers):\n        \"\"\"\n        Computes cell averages of a function 'func' using Gaussian quadrature.\n        \"\"\"\n        averages = np.zeros(N)\n        for i in range(N):\n            x_interface_left = cell_centers[i] - dx / 2.0\n            x_interface_right = cell_centers[i] + dx / 2.0\n            \n            # Map Gaussian quadrature nodes from [-1, 1] to [x_l, x_r]\n            x_quad = 0.5 * (x_interface_right - x_interface_left) * xi + 0.5 * (x_interface_right + x_interface_left)\n            \n            integrand_values = func(x_quad, L)\n            integral = 0.5 * (x_interface_right - x_interface_left) * np.sum(w * integrand_values)\n            averages[i] = integral / dx\n        return averages\n\n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        a = case['a']\n        CFL = case['CFL']\n        phi0_func = case['phi0_func']\n\n        dx = L / N\n        dt = CFL * dx / abs(a)\n        lambda_courant = a * dt / dx\n\n        # Define mesh\n        cell_centers = np.linspace(dx / 2.0, L - dx / 2.0, N)\n\n        # 1. Initialization\n        phi_n = get_cell_averages(lambda x, l: phi0_func(x, l), L, N, dx, cell_centers)\n\n        # 2. MUSCL Reconstruction with van Leer limiter\n        # Periodic boundary conditions using np.roll\n        phi_im1 = np.roll(phi_n, 1)\n        phi_ip1 = np.roll(phi_n, -1)\n\n        delta_minus = phi_n - phi_im1\n        delta_plus = phi_ip1 - phi_n\n\n        # Calculate slope ratio r, handling division by zero\n        r = np.divide(delta_minus, delta_plus, out=np.zeros_like(delta_minus), where=delta_plus != 0)\n\n        # Van Leer limiter function\n        phi_vl = (r + np.abs(r)) / (1.0 + np.abs(r))\n        # Handle case where r = -1, which makes denominator 0.\n        # However, for r <= 0, (r + |r|) is 0, so the limit is 0.\n        # np.nan_to_num will correctly handle the 0/0 case if it arises.\n        phi_vl = np.nan_to_num(phi_vl)\n        \n        # Limited slope\n        sigma = phi_vl * delta_plus\n\n        # 3. Hancock Predictor Step\n        sigma_ip1 = np.roll(sigma, -1)\n\n        phi_L_star = phi_n + 0.5 * (1.0 - lambda_courant) * sigma\n        phi_R_star = phi_ip1 - 0.5 * (1.0 + lambda_courant) * sigma_ip1\n\n        # 4. Flux Calculation (Riemann Solver)\n        if a >= 0:\n            flux_half = a * phi_L_star\n        else:\n            flux_half = a * phi_R_star\n            \n        flux_half_im1 = np.roll(flux_half, 1)\n\n        # 5. Corrector Update\n        phi_np1 = phi_n - (dt / dx) * (flux_half - flux_half_im1)\n\n        # 6. Error Calculation\n        # Define exact solution at t = n+1\n        def phi_exact_func(x, L):\n            # Apply periodic boundary condition to the advected coordinate\n            shifted_x = (x - a * dt) % L\n            # Handle potential negative results from modulo operator for negative a*dt\n            shifted_x = (shifted_x + L) % L\n            return phi0_func(shifted_x, L)\n\n        phi_exact_np1 = get_cell_averages(phi_exact_func, L, N, dx, cell_centers)\n\n        # Compute L1 error\n        l1_error = np.mean(np.abs(phi_np1 - phi_exact_np1))\n        results.append(l1_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.10e}' for err in results)}]\")\n\nsolve()\n```", "id": "2477979"}]}