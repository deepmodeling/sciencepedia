{"hands_on_practices": [{"introduction": "The power of the de Haas-van Alphen effect lies in its direct link between a macroscopic, measurable quantity—the oscillation period in magnetization—and a microscopic, quantum property—the geometry of the Fermi surface. This first exercise provides practice with this cornerstone concept, the Onsager relation. You will calculate the oscillation period for a two-dimensional electron gas, demonstrating how the Fermi surface area, $A_F$, can be determined directly from the carrier density, a result that holds even for the more complex non-parabolic energy bands often found in real materials.", "problem": "The de Haas-van Alphen (dHvA) effect refers to the oscillations in the magnetic susceptibility of a metal as a function of an applied magnetic field $B$. These oscillations are periodic in the inverse magnetic field, $1/B$. The period, $\\Delta(1/B)$, is fundamentally related to the geometry of the material's Fermi surface through the Onsager relation:\n$$\n\\Delta\\left(\\frac{1}{B}\\right) = \\frac{2\\pi e}{\\hbar A_F}\n$$\nwhere $e$ is the elementary charge, $\\hbar$ is the reduced Planck constant, and $A_F$ is the extremal cross-sectional area of the Fermi surface in k-space, perpendicular to the direction of the magnetic field.\n\nConsider a two-dimensional electron gas (2DEG) where the magnetic field is applied perpendicular to the plane of the gas. The electrons in this 2DEG have an isotropic but non-parabolic energy dispersion relation given by:\n$$\nE(1 + \\alpha E) = \\frac{\\hbar^2 k^2}{2m^*}\n$$\nHere, $E$ is the electron energy, $k$ is the magnitude of the 2D wavevector, $m^*$ is the band-edge effective mass, and $\\alpha$ is a constant non-parabolicity parameter. The system has a constant, spin-degenerate carrier density $n$.\n\nCalculate the de Haas-van Alphen oscillation period, $\\Delta(1/B)$, for this system. Express your answer in terms of the carrier density $n$, the elementary charge $e$, and the reduced Planck constant $\\hbar$.", "solution": "The de Haas-van Alphen oscillation period is given by the Onsager relation:\n\n$$\n\\Delta\\left(\\frac{1}{B}\\right) = \\frac{2\\pi e}{\\hbar A_F}\n$$\n\nwhere $A_F$ is the extremal cross-sectional area of the Fermi surface perpendicular to the magnetic field. For a two-dimensional electron gas (2DEG) with the magnetic field applied perpendicular to the plane, the Fermi surface is circular due to isotropic dispersion, and $A_F$ is the area of the Fermi disk in k-space.\n\nThe energy dispersion relation is:\n\n$$\nE(1 + \\alpha E) = \\frac{\\hbar^2 k^2}{2m^*}\n$$\n\nAt the Fermi energy $E_F$, this becomes:\n\n$$\nE_F(1 + \\alpha E_F) = \\frac{\\hbar^2 k_F^2}{2m^*}\n$$\n\nwhere $k_F$ is the Fermi wavevector. The carrier density $n$ is constant and spin-degenerate (degeneracy $g = 2$). The density of states per unit area is:\n\n$$\ng(E) = \\frac{m^*}{\\pi \\hbar^2} (1 + 2\\alpha E)\n$$\n\nThe carrier density is:\n\n$$\nn = \\int_0^{E_F} g(E)  dE = \\frac{m^*}{\\pi \\hbar^2} \\int_0^{E_F} (1 + 2\\alpha E)  dE\n$$\n\nEvaluating the integral:\n\n$$\nn = \\frac{m^*}{\\pi \\hbar^2} \\left[ E + \\alpha E^2 \\right]_0^{E_F} = \\frac{m^*}{\\pi \\hbar^2} (E_F + \\alpha E_F^2)\n$$\n\nUsing the dispersion relation at $E_F$:\n\n$$\nE_F + \\alpha E_F^2 = \\frac{\\hbar^2 k_F^2}{2m^*}\n$$\n\nSubstituting:\n\n$$\nn = \\frac{m^*}{\\pi \\hbar^2} \\cdot \\frac{\\hbar^2 k_F^2}{2m^*} = \\frac{k_F^2}{2\\pi}\n$$\n\nSolving for $k_F^2$:\n\n$$\nk_F^2 = 2\\pi n\n$$\n\nThe extremal cross-sectional area $A_F$ is the area of the Fermi disk:\n\n$$\nA_F = \\pi k_F^2 = \\pi (2\\pi n) = 2\\pi^2 n\n$$\n\nSubstituting $A_F$ into the Onsager relation:\n\n$$\n\\Delta\\left(\\frac{1}{B}\\right) = \\frac{2\\pi e}{\\hbar (2\\pi^2 n)} = \\frac{e}{\\pi \\hbar n}\n$$", "answer": "$$ \\boxed{\\dfrac{e}{\\pi \\hbar n}} $$", "id": "122328"}, {"introduction": "Beyond just the frequency, the amplitude of dHvA oscillations carries a wealth of information about the charge carriers. This exercise delves into the Lifshitz-Kosevich theory by focusing on the spin-damping factor, which arises from the Zeeman splitting of Landau levels. You will investigate the specific conditions that lead to a \"spin-splitting zero\"—a quantum interference effect where the fundamental oscillation completely vanishes—and in doing so, learn how amplitude measurements provide powerful constraints on electron properties like the effective mass $m^*$ and the Landé g-factor.", "problem": "The de Haas-van Alphen (dHvA) effect is the periodic oscillation of a metal's magnetic susceptibility as a function of the inverse of an applied magnetic field, $1/B$. The oscillatory part of the magnetization can be described by the Lifshitz-Kosevich (LK) formula, which represents the signal as a Fourier series in $1/B$:\n$$\n\\tilde{M}(T, B) \\propto \\sum_{p=1}^{\\infty} A_p \\cos\\left(2\\pi p \\frac{F}{B} + \\phi_p\\right)\n$$\nHere, $p$ is the harmonic index, $F$ is the dHvA frequency related to the extremal Fermi surface area, and $A_p$ is the amplitude of the $p$-th harmonic. This amplitude is a product of several factors, including a term that accounts for the interaction of the electron spin with the magnetic field (Zeeman effect). This spin factor, $R_S(p)$, for the $p$-th harmonic is given by:\n$$\nR_S(p) = \\cos\\left(p \\pi \\frac{g m^*}{2 m_e}\\right)\n$$\nwhere $g$ is the Landé g-factor for the electrons, $m^*$ is their effective mass, and $m_e$ is the free electron mass.\n\nUnder specific conditions, the contribution from the fundamental harmonic ($p=1$) can be completely suppressed, a phenomenon known as a \"spin-splitting zero\". For a hypothetical single-band metal, find the smallest positive value of the ratio of the effective mass to the free electron mass, $m^*/m_e$, that would lead to the observation of such a spin-splitting zero in its dHvA signal. Express your answer as a closed-form expression in terms of the g-factor, $g$.", "solution": "The problem asks for the condition under which the fundamental harmonic ($p=1$) of the de Haas-van Alphen oscillations vanishes due to the spin factor.\n\n1.  The amplitude of the $p$-th harmonic, $A_p$, is proportional to the spin factor $R_S(p)$. The full cancellation of the fundamental harmonic means its amplitude $A_1$ must be zero. This requires the spin factor for $p=1$ to be zero.\n$$\nR_S(1) = 0\n$$\n\n2.  The spin factor for the fundamental harmonic is obtained by setting $p=1$ in the given formula:\n$$\nR_S(1) = \\cos\\left(\\pi \\frac{g m^*}{2 m_e}\\right)\n$$\n\n3.  Setting this expression to zero gives the condition for the spin-splitting zero:\n$$\n\\cos\\left(\\pi \\frac{g m^*}{2 m_e}\\right) = 0\n$$\n\n4.  The cosine function is zero whenever its argument is an odd integer multiple of $\\pi/2$. We can express this as:\n$$\n\\pi \\frac{g m^*}{2 m_e} = \\left(N + \\frac{1}{2}\\right)\\pi\n$$\nwhere $N$ is an integer.\n\n5.  We can cancel the factor of $\\pi$ from both sides of the equation:\n$$\n\\frac{g m^*}{2 m_e} = N + \\frac{1}{2}\n$$\n\n6.  We are looking for the ratio $m^*/m_e$. Solving the equation for this ratio yields:\n$$\n\\frac{m^*}{m_e} = \\frac{2}{g}\\left(N + \\frac{1}{2}\\right) = \\frac{2N+1}{g}\n$$\n\n7.  The quantities $m^*$, $m_e$, and $g$ are all positive physical constants. Therefore, the ratio $m^*/m_e$ must be positive. This implies that $2N+1$ must also be positive. The integers $N$ that satisfy this are $N = 0, 1, 2, \\dots$.\n\n8.  The problem asks for the smallest, non-zero value of the ratio $m^*/m_e$. This corresponds to the smallest possible integer value for $N$, which is $N=0$.\n\n9.  Substituting $N=0$ into the expression for the ratio gives the desired result:\n$$\n\\left(\\frac{m^*}{m_e}\\right)_{\\min} = \\frac{2(0)+1}{g} = \\frac{1}{g}\n$$\nThis is the smallest positive ratio for which the fundamental dHvA harmonic is suppressed.", "answer": "$$\n\\boxed{\\frac{1}{g}}\n$$", "id": "64375"}, {"introduction": "Extracting the precise frequencies from experimental dHvA data is a critical skill that bridges theoretical models and physical reality. Because the oscillations are periodic in the inverse magnetic field $1/B$, a direct Fourier transform of magnetization versus $B$ is not effective. This computational practice guides you through the essential data processing pipeline used by experimentalists, from resampling the data onto a uniform $1/B$ grid to applying window functions and performing a Fast Fourier Transform (FFT). This hands-on exercise builds the practical skills needed to analyze real experimental signals and accurately map a material's Fermi surface.", "problem": "You are given a task grounded in the study of the de Haas–van Alphen (dHvA) effect in materials physics. In the presence of a magnetic field, the magnetization response exhibits oscillations that are periodic in the inverse magnetic field variable due to Landau quantization of electron orbits. The goal is to extract the oscillation frequencies from a finite-window magnetization dataset by constructing a uniform grid in the inverse field, apodizing the data to mitigate spectral leakage, and computing the Fast Fourier Transform (FFT) to identify the dominant frequency components. Your program must both implement the complete processing pipeline and compute a final numeric answer.\n\nBegin from the following fundamental base, without using any shortcut formulas about the processing outcome:\n- Landau quantization produces oscillatory contributions in thermodynamic quantities when varying the magnetic field, which are periodic in the inverse field variable. Consequently, any Discrete Fourier Transform (DFT) analysis used to reveal these periodicities must be performed with respect to the inverse field variable because periodicity is in $1/B$, not in $B$.\n- The Discrete Fourier Transform requires uniformly sampled data in its independent variable, which in this case is $x = 1/B$.\n- Windowing (apodization) of a finite-length time series is used to reduce spectral leakage arising from the implicit multiplication by a rectangular window over the finite sampling interval.\n\nYour task is to:\n- Given a magnetization dataset $M(B)$ observed over a finite magnetic field window $[B_{\\min},B_{\\max}]$, construct a uniform grid in the inverse field variable $x = 1/B$, interpolate the magnetization onto that grid, detrend the background that varies slowly with $x$, apply an apodization window, and compute the Fast Fourier Transform (FFT).\n- From the FFT magnitude spectrum, identify the dominant dHvA frequency or frequencies. For each test case, return the required number of dominant peak frequencies. Frequencies must be expressed in tesla (T), which is the natural unit for the de Haas–van Alphen frequency since the frequency axis of the Fourier transform in $x=1/B$ is in cycles per tesla. Frequencies must be rounded to the nearest integer (in $\\mathrm{T}$).\n- You must justify, in your code’s structure and the accompanying solution, each preprocessing step: uniform $1/B$ grid construction, detrending, and apodization prior to FFT.\n\nData model and deterministic test suite:\n- For each test case, the magnetization data are generated deterministically as a sum of a slowly varying polynomial background in $B$, an oscillatory contribution periodic in $1/B$, a weak amplitude envelope factor, and a small deterministic pseudo-noise term. Explicitly, for samples indexed by $i \\in \\{0,1,\\dots,N-1\\}$, define\n  - $B_i = \\mathrm{sort}\\left(B_{\\min} + \\frac{B_{\\max} - B_{\\min}}{N-1} \\, i + \\varepsilon \\sin\\!\\left(\\frac{2\\pi i}{N-1}\\right)\\right)$,\n  - $x_i = 1/B_i$,\n  - $M_i = \\underbrace{c_0 + c_1 B_i + c_2 B_i^2}_{\\text{background in } B} + \\underbrace{\\sum_{j=1}^{J} A_j B_i^{-1/2} \\sin\\!\\left(2\\pi \\frac{F_j}{B_i} + \\phi_j\\right)}_{\\text{dHvA oscillations periodic in } 1/B} + \\underbrace{\\eta_1 \\sin\\!\\left(2\\pi \\frac{B_i}{\\tau_1}\\right) + \\eta_2 \\cos\\!\\left(2\\pi \\frac{B_i}{\\tau_2}\\right)}_{\\text{deterministic small pseudo-noise}}.$\n- Use the following deterministic constants for the pseudo-noise across all test cases: $\\tau_1 = 1.3\\,\\mathrm{T}$, $\\tau_2 = 0.7\\,\\mathrm{T}$, $\\eta_1 = 0.02$, and $\\eta_2 = 0.015$.\n\nImplement the following processing pipeline for each test case:\n- Construct $x_i = 1/B_i$ and sort pairs $(x_i, M_i)$ by increasing $x_i$.\n- Interpolate $\\{(x_i, M_i)\\}$ to a uniform grid $\\{x_k\\}$ covering the interval $[x_{\\min}, x_{\\max}]$, where $x_{\\min} = \\min_i x_i$ and $x_{\\max} = \\max_i x_i$. The grid must be uniform in $x$, with $N_{\\mathrm{grid}} = N$ points. Use a stable, piecewise-linear interpolation.\n- Detrend the interpolated series by subtracting a polynomial fit of degree $d = 2$ as a function of $x$. That is, fit $P_2(x) = a_0 + a_1 x + a_2 x^2$ to the interpolated $M(x)$ and use $M_{\\mathrm{detrend}}(x) = M(x) - P_2(x)$.\n- Apply an apodization (window) function $w(x)$ on the detrended data, for example, a Hann window $w_k = \\tfrac{1}{2}\\big(1 - \\cos(2\\pi k/(N_{\\mathrm{grid}}-1))\\big)$ for $k = 0,\\dots,N_{\\mathrm{grid}}-1$.\n- Compute the one-sided FFT magnitude spectrum $| \\mathcal{F}\\{ M_{\\mathrm{detrend}}(x) w(x) \\} |$ using a real-to-complex FFT optimized for uniform sampling, and compute the corresponding frequency axis $f$ (in $\\mathrm{T}$) using the sampling interval $\\Delta x$ of the uniform $x$ grid. Use $f_k = \\frac{k}{N_{\\mathrm{grid}} \\Delta x}$ for nonnegative $k$.\n- Identify peak frequencies by finding local maxima in the FFT magnitude spectrum with sufficient prominence. Exclude the zero-frequency component. For numerical robustness, you may ignore very low frequencies (e.g., below a small floor value) relative to the field windows provided.\n\nTest suite:\n- There are four test cases. For each, specify $(B_{\\min}, B_{\\max}, N, \\varepsilon, J, \\{F_j\\}_{j=1}^J, \\{A_j\\}_{j=1}^J, \\{\\phi_j\\}_{j=1}^J, c_0, c_1, c_2)$ and the number of dominant frequencies to return.\n  1. Case A (single frequency, moderate window): $B_{\\min} = 7\\,\\mathrm{T}$, $B_{\\max} = 15\\,\\mathrm{T}$, $N = 601$, $\\varepsilon = 0.02\\,\\mathrm{T}$, $J = 1$, $F_1 = 530\\,\\mathrm{T}$, $A_1 = 1.2$, $\\phi_1 = 0.3$, $c_0 = 0.5$, $c_1 = 0.1$, $c_2 = 0$, return $K=1$ dominant frequency.\n  2. Case B (two frequencies): $B_{\\min} = 8\\,\\mathrm{T}$, $B_{\\max} = 20\\,\\mathrm{T}$, $N = 801$, $\\varepsilon = 0.015\\,\\mathrm{T}$, $J = 2$, $(F_1,F_2) = (380\\,\\mathrm{T}, 1050\\,\\mathrm{T})$, $(A_1,A_2) = (1.0, 0.6)$, $(\\phi_1,\\phi_2) = (-0.2, 1.0)$, $(c_0,c_1,c_2) = (-0.3, 0.05, 0.002)$, return $K=2$ dominant frequencies.\n  3. Case C (short window, limited resolution): $B_{\\min} = 14\\,\\mathrm{T}$, $B_{\\max} = 16\\,\\mathrm{T}$, $N = 401$, $\\varepsilon = 0.005\\,\\mathrm{T}$, $J = 1$, $F_1 = 800\\,\\mathrm{T}$, $A_1 = 1.0$, $\\phi_1 = 0.5$, $(c_0,c_1,c_2) = (0.1, 0.02, -0.0005)$, return $K=1$ dominant frequency.\n  4. Case D (strong background and pseudo-noise): $B_{\\min} = 5\\,\\mathrm{T}$, $B_{\\max} = 10\\,\\mathrm{T}$, $N = 501$, $\\varepsilon = 0.02\\,\\mathrm{T}$, $J = 1$, $F_1 = 600\\,\\mathrm{T}$, $A_1 = 0.6$, $\\phi_1 = -1.0$, $(c_0,c_1,c_2) = (1.0, 0.8, 0.0)$, return $K=1$ dominant frequency.\n\nNumerical and unit requirements:\n- Express all returned frequencies in tesla (T) and round each to the nearest integer. Because the Fourier transform is performed with respect to $x = 1/B$ sampled in units of $\\mathrm{T}^{-1}$, the frequency axis has units of $\\mathrm{T}$.\n- No angular units occur. Do not return percentages; all numbers must be pure numbers in the specified unit.\n\nFinal output format:\n- Your program should produce a single line of output containing a Python-style list of lists of integers in tesla, in the order of the test cases $[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}]$. For example, the format must be exactly like\n  - $[[f_A],[f_{B,1},f_{B,2}],[f_C],[f_D]]$\n- Do not include any extra text or spaces beyond those in the bracketed, comma-separated list.\n\nYour program must be a complete, runnable implementation that generates the four datasets deterministically according to the formulas above, performs the processing pipeline, and prints the final numeric results in the specified format. The code must be self-contained and must not require any user input or external files. The only permitted libraries are the Python standard library, NumPy, and SciPy.", "solution": "The problem presented is a valid and well-posed task in computational materials physics. It requires the implementation of a standard data analysis pipeline for extracting de Haas-van Alphen (dHvA) oscillation frequencies from a simulated magnetization signal. The problem is scientifically grounded, formally specified, and objective. It does not violate any of the criteria for invalidity. Therefore, I will provide a complete solution.\n\nThe core principle of the dHvA effect is that, in the presence of a strong magnetic field $B$, the quantization of electronic orbits into Landau levels leads to oscillations in thermodynamic properties, such as magnetization $M$. These oscillations are periodic not in the magnetic field $B$ itself, but in its inverse, $x = 1/B$. The frequency $F$ of these oscillations, expressed in units of tesla, is directly proportional to the extremal cross-sectional area of the Fermi surface perpendicular to the magnetic field. The objective is to extract these frequencies from a given signal $M(B)$.\n\nThe provided data is generated deterministically via the model:\n$$\nM_i = \\underbrace{c_0 + c_1 B_i + c_2 B_i^2}_{\\text{Background}} + \\underbrace{\\sum_{j=1}^{J} A_j B_i^{-1/2} \\sin\\!\\left(2\\pi \\frac{F_j}{B_i} + \\phi_j\\right)}_{\\text{dHvA Oscillations}} + \\underbrace{\\eta_1 \\sin\\!\\left(2\\pi \\frac{B_i}{\\tau_1}\\right) + \\eta_2 \\cos\\!\\left(2\\pi \\frac{B_i}{\\tau_2}\\right)}_{\\text{Pseudo-noise}}\n$$\nwhere the magnetic field samples $B_i$ are nearly, but not perfectly, uniform. The analysis pipeline must robustly handle the non-uniform sampling, background signal, and finite window effects to accurately determine the frequencies $F_j$. The following steps detail the methodology, with justifications for each critical stage of processing.\n\n**Step 1: Grid Transformation and Resampling**\n\nThe fundamental tool for frequency analysis is the Fourier Transform. The Discrete Fourier Transform (DFT), and its efficient implementation, the Fast Fourier Transform (FFT), requires the input signal to be sampled at uniform intervals of its independent variable. The physical nature of the dHvA effect dictates that the oscillatory part of the magnetization is periodic in $x=1/B$. Thus, the independent variable for Fourier analysis must be $x$.\n\nThe raw data is provided as pairs $(B_i, M_i)$, where $B_i$ samples are not uniformly spaced. Consequently, the samples in the inverse field, $x_i = 1/B_i$, are also non-uniform. To apply the FFT, we must first resample the magnetization data onto a uniform grid in the $x$ variable.\n\nThe procedure is as follows:\n1. For each measurement $(B_i, M_i)$, compute the inverse field $x_i = 1/B_i$.\n2. Because the original $B_i$ values are sorted, the resulting $x_i$ values will be sorted in descending order. The data pairs $(x_i, M_i)$ are sorted by increasing $x_i$ to prepare for interpolation.\n3. A new uniform grid $\\{x_k\\}_{k=0}^{N_{\\mathrm{grid}}-1}$ is constructed, spanning the full range of the data, from $x_{\\min} = \\min(x_i)$ to $x_{\\max} = \\max(x_i)$. The number of points on this grid, $N_{\\mathrm{grid}}$, is chosen to be equal to the original number of data points, $N$. The grid spacing is uniform: $\\Delta x = (x_{\\max} - x_{\\min}) / (N_{\\mathrm{grid}}-1)$.\n4. The magnetization values $M(x_k)$ on this uniform grid are obtained by applying piecewise-linear interpolation to the sorted, non-uniform data $(x_i, M_i)$. This method is chosen for its stability and computational efficiency.\n\n**Step 2: Background Subtraction (Detrending)**\n\nThe magnetization signal $M(x)$ is a superposition of the desired high-frequency dHvA oscillations and a slowly varying background component. In the provided model, this background originates from the polynomial $c_0 + c_1 B + c_2 B^2$, which becomes a non-polynomial trend when viewed as a function of $x = 1/B$. This low-frequency trend, if not removed, will dominate the Fourier spectrum at and near zero frequency. The discontinuity between the start and end values of this trend, when treated as a periodic signal by the FFT, introduces significant spectral leakage that can obscure the weaker dHvA peaks.\n\nTo isolate the oscillatory component, this background trend must be subtracted. This process is called detrending. A common and effective method is to fit a low-degree polynomial to the signal $M(x_k)$ and subtract this fit from the data. The problem specifies fitting a polynomial of a degree $d=2$ in the variable $x$:\n$$\nP_2(x_k) = a_0 + a_1 x_k + a_2 x_k^2\n$$\nThe coefficients $(a_0, a_1, a_2)$ are determined by a least-squares fit to the interpolated data $M(x_k)$. The detrended signal is then computed as:\n$$\nM_{\\mathrm{detrend}}(x_k) = M(x_k) - P_2(x_k)\n$$\nThis procedure effectively removes the slowly varying component, leaving a signal that oscillates around zero, which is ideal for subsequent Fourier analysis.\n\n**Step 3: Apodization (Windowing)**\n\nAnalyzing a finite segment of data is mathematically equivalent to multiplying an infinite signal by a rectangular window function which is unity over the measurement interval $[x_{\\min}, x_{\\max}]$ and zero elsewhere. The sharp edges of this rectangular window in the $x$-domain cause a convolution with a $\\mathrm{sinc}$ function in the frequency domain. This results in each true spectral peak being broadened and accompanied by large side lobes, an effect known as spectral leakage. These side lobes can obscure nearby, weaker peaks or be mistaken for genuine frequencies.\n\nTo mitigate this, the detrended data is multiplied by an apodization (or window) function, $w(x_k)$, that smoothly tapers to zero at the boundaries of the interval. This reduces the sharpness of the signal's truncation, thereby suppressing the side lobes in the frequency spectrum at the cost of slightly broadening the main peak. For this problem, a Hann window is specified:\n$$\nw_k = \\frac{1}{2} \\left(1 - \\cos\\left(\\frac{2\\pi k}{N_{\\mathrm{grid}}-1}\\right)\\right) \\quad \\text{for } k = 0, \\dots, N_{\\mathrm{grid}}-1\n$$\nThe windowed signal is $M_{\\mathrm{windowed}}(x_k) = M_{\\mathrm{detrend}}(x_k) \\cdot w_k$.\n\n**Step 4: Fourier Transform and Peak Identification**\n\nAfter the preprocessing steps, the signal is prepared for Fourier analysis.\n1. A one-dimensional real-to-complex Fast Fourier Transform (FFT) is applied to the final signal, $M_{\\mathrm{windowed}}(x_k)$.\n2. The frequency axis corresponding to the FFT output is computed. The frequencies $f_k$ are given by $f_k = k / (N_{\\mathrm{grid}} \\Delta x)$, where $\\Delta x$ is the uniform sampling interval in the inverse field domain. The units of $f_k$ are tesla ($\\mathrm{T}$), as the units of $\\Delta x$ are $\\mathrm{T}^{-1}$.\n3. The magnitude of the complex FFT output is calculated to obtain the power spectrum.\n4. The dHvA frequencies correspond to the locations of distinct peaks in this magnitude spectrum. The peaks are identified by finding local maxima. The zero-frequency component (DC offset) is ignored, as it contains remnants of any imperfectly subtracted background. A low-frequency floor is also applied to avoid spurious peaks that may arise from artifacts of the detrending process.\n5. The identified peaks are ranked by their magnitude (prominence), and the top $K$ frequencies are selected as the result for each test case, as specified. These frequencies are then sorted in ascending order and rounded to the nearest integer.\n\nThis complete pipeline ensures a robust and physically meaningful extraction of the dHvA frequencies from the raw magnetization data.", "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the dHvA analysis for all test cases.\n    \"\"\"\n\n    # Deterministic constants for pseudo-noise\n    tau1 = 1.3\n    tau2 = 0.7\n    eta1 = 0.02\n    eta2 = 0.015\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"name\": \"A\", \"B_min\": 7.0, \"B_max\": 15.0, \"N\": 601, \"epsilon\": 0.02,\n            \"J\": 1, \"F\": [530.0], \"A\": [1.2], \"phi\": [0.3],\n            \"c0\": 0.5, \"c1\": 0.1, \"c2\": 0.0, \"K\": 1\n        },\n        {\n            \"name\": \"B\", \"B_min\": 8.0, \"B_max\": 20.0, \"N\": 801, \"epsilon\": 0.015,\n            \"J\": 2, \"F\": [380.0, 1050.0], \"A\": [1.0, 0.6], \"phi\": [-0.2, 1.0],\n            \"c0\": -0.3, \"c1\": 0.05, \"c2\": 0.002, \"K\": 2\n        },\n        {\n            \"name\": \"C\", \"B_min\": 14.0, \"B_max\": 16.0, \"N\": 401, \"epsilon\": 0.005,\n            \"J\": 1, \"F\": [800.0], \"A\": [1.0], \"phi\": [0.5],\n            \"c0\": 0.1, \"c1\": 0.02, \"c2\": -0.0005, \"K\": 1\n        },\n        {\n            \"name\": \"D\", \"B_min\": 5.0, \"B_max\": 10.0, \"N\": 501, \"epsilon\": 0.02,\n            \"J\": 1, \"F\": [600.0], \"A\": [0.6], \"phi\": [-1.0],\n            \"c0\": 1.0, \"c1\": 0.8, \"c2\": 0.0, \"K\": 1\n        },\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        B_min, B_max = case[\"B_min\"], case[\"B_max\"]\n        epsilon = case[\"epsilon\"]\n        \n        # --- 1. Data Generation ---\n        i = np.arange(N)\n        B_raw = B_min + (B_max - B_min) / (N - 1) * i + epsilon * np.sin(2 * np.pi * i / (N - 1))\n        B = np.sort(B_raw)\n        \n        # Background\n        M = case[\"c0\"] + case[\"c1\"] * B + case[\"c2\"] * B**2\n        \n        # dHvA oscillations\n        dHvA_signal = np.zeros_like(B)\n        for j in range(case[\"J\"]):\n            F, A, phi = case[\"F\"][j], case[\"A\"][j], case[\"phi\"][j]\n            dHvA_signal += A * B**(-0.5) * np.sin(2 * np.pi * F / B + phi)\n        M += dHvA_signal\n        \n        # Pseudo-noise\n        noise = eta1 * np.sin(2 * np.pi * B / tau1) + eta2 * np.cos(2 * np.pi * B / tau2)\n        M += noise\n\n        # --- 2. Processing Pipeline ---\n        \n        # Construct inverse field grid and sort\n        x = 1.0 / B\n        # B is sorted ascending, so x is sorted descending. Reverse to sort ascending.\n        x_sorted = x[::-1]\n        M_sorted = M[::-1]\n\n        # Interpolate onto a uniform grid in x\n        x_min, x_max = x_sorted[0], x_sorted[-1]\n        N_grid = N\n        x_uniform = np.linspace(x_min, x_max, N_grid)\n        M_uniform = np.interp(x_uniform, x_sorted, M_sorted)\n        \n        # Detrend by subtracting a 2nd degree polynomial fit in x\n        poly_coeffs = np.polyfit(x_uniform, M_uniform, 2)\n        poly_fit = np.polyval(poly_coeffs, x_uniform)\n        M_detrended = M_uniform - poly_fit\n        \n        # Apply Hann window (apodization)\n        hann_window = np.hanning(N_grid)\n        M_windowed = M_detrended * hann_window\n        \n        # Compute FFT\n        delta_x = x_uniform[1] - x_uniform[0]\n        fft_freqs = np.fft.rfftfreq(N_grid, d=delta_x)\n        fft_magnitudes = np.abs(np.fft.rfft(M_windowed))\n\n        # --- 3. Peak Identification ---\n        \n        # Find peaks with sufficient prominence, ignoring low frequencies\n        # A low frequency floor is set to avoid spurious peaks from detrending artifacts.\n        min_freq_threshold = 50.0  # In Tesla\n        \n        # Prominence is set relative to the max signal amplitude for robustness\n        prominence = 0.1 * np.max(fft_magnitudes) \n        \n        peak_indices, properties = find_peaks(fft_magnitudes, prominence=prominence)\n        \n        # Filter peaks by frequency threshold\n        valid_peaks = []\n        for p_idx in peak_indices:\n            freq = fft_freqs[p_idx]\n            if freq >= min_freq_threshold:\n                valid_peaks.append({'freq': freq, 'mag': fft_magnitudes[p_idx]})\n        \n        # Sort peaks by magnitude in descending order\n        valid_peaks.sort(key=lambda p: p['mag'], reverse=True)\n        \n        # Select top K frequencies\n        K = case[\"K\"]\n        top_freqs = [p['freq'] for p in valid_peaks[:K]]\n        \n        # Sort frequencies in ascending order for consistent output\n        top_freqs.sort()\n        \n        # Round to the nearest integer\n        result_freqs = [int(round(f)) for f in top_freqs]\n        \n        final_results.append(result_freqs)\n    \n    # Format and print the final output\n    # Use replace to remove spaces from str(list) conversion\n    output_str = f\"[{','.join(map(str, final_results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2812572"}]}