{"hands_on_practices": [{"introduction": "The fundamental characteristics of a time integration scheme are best understood by observing its behavior on a simple harmonic oscillator, which represents a single mode of a complex structure. The key to this analysis is the amplification factor, whose locus in the complex plane as a function of time step size visually encodes the method's stability, numerical dissipation (energy loss), and numerical dispersion (phase error). This exercise [@problem_id:2545014] provides a foundational analysis of the explicit central difference method and the implicit Newmark and generalized-$\\alpha$ methods, allowing you to derive and interpret these properties from first principles.", "problem": "Consider the undamped semi-discrete linear elastodynamics initial value problem from the finite element method: find the displacement vector $\\mathbf{u}(t)$ satisfying\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0},\n$$\nwhere $\\mathbf{M}$ and $\\mathbf{K}$ are symmetric positive definite mass and stiffness matrices. Let $\\boldsymbol{\\phi}$ be an eigenvector of the generalized eigenproblem $\\mathbf{K}\\boldsymbol{\\phi} = \\omega^{2}\\mathbf{M}\\boldsymbol{\\phi}$ with eigenfrequency $\\omega > 0$. By modal decoupling, the modal coordinate $q(t)$ associated with $\\boldsymbol{\\phi}$ satisfies the scalar oscillator\n$$\n\\ddot{q}(t) + \\omega^{2} q(t) = 0.\n$$\nLet the time step be $\\Delta t > 0$ and define the nondimensional step $\\Omega := \\omega\\,\\Delta t$.\n\nYou will compare three single-step procedures applied to the scalar modal equation:\n\n- Central difference method (explicit): approximate $\\ddot{q}(t_{n})$ by the centered second difference in terms of $q_{n-1}$, $q_{n}$, and $q_{n+1}$, where $q_{n} := q(n\\Delta t)$.\n- Newmark family with parameters $\\beta$ and $\\gamma$ (implicit in general): use\n$$\n\\begin{aligned}\nq_{n+1} &= q_{n} + \\Delta t\\,v_{n} + \\Delta t^{2}\\big((\\tfrac{1}{2}-\\beta)a_{n} + \\beta a_{n+1}\\big),\\\\\nv_{n+1} &= v_{n} + \\Delta t\\big((1-\\gamma)a_{n} + \\gamma a_{n+1}\\big),\n\\end{aligned}\n$$\ntogether with the equation of motion $a_{n} = -\\omega^{2} q_{n}$ and $a_{n+1} = -\\omega^{2} q_{n+1}$, and take the average-acceleration choice $\\gamma = \\tfrac{1}{2}$ and $\\beta = \\tfrac{1}{4}$.\n- Generalized-$\\alpha$ method for second-order systems: let $\\alpha_{m}$ and $\\alpha_{f}$ be given weights, and enforce\n$$\na_{n+\\alpha_{m}} + \\omega^{2} q_{n+\\alpha_{f}} = 0,\\quad a_{n+\\alpha_{m}} := (1-\\alpha_{m})a_{n+1} + \\alpha_{m} a_{n},\\quad q_{n+\\alpha_{f}} := (1-\\alpha_{f})q_{n+1} + \\alpha_{f} q_{n},\n$$\ncoupled with the Newmark-like kinematics above. Assume the second-order accuracy conditions $\\gamma = \\tfrac{1}{2} + \\alpha_{f} - \\alpha_{m}$ and $\\beta = \\tfrac{1}{4}\\big(1 + \\alpha_{f} - \\alpha_{m}\\big)^{2}$, and take a high-frequency spectral radius design parameter $\\rho_{\\infty} \\in [0,1)$ such that the method is $A$-stable and has limiting amplification factor magnitude $\\rho_{\\infty}$ as $\\Omega \\to \\infty$.\n\nTasks:\n\n1) For each of the three procedures, derive the one-step amplification matrix that advances a suitable state vector from time level $n$ to $n+1$, and compute its eigenvalues as functions of $\\Omega$. These eigenvalues are the methodâ€™s amplification factors for the given eigenmode.\n\n2) As $\\Omega$ varies over $[0,\\infty)$, sketch or plot the loci of these amplification factors in the complex plane and interpret their shapes in terms of numerical dispersion and dissipation for each method.\n\n3) Determine the largest nondimensional time step $\\Omega_{\\max}$ for which the central difference method is marginally stable for the given eigenmode, meaning that the spectral radius of its amplification matrix equals $1$. Express your final answer as the single number $\\Omega_{\\max}$ (dimensionless). No rounding is required.", "solution": "The problem as presented is a standard, well-posed exercise in the analysis of time integration methods for structural dynamics. It is scientifically sound, contains all necessary information, and has no internal contradictions. Therefore, the problem is valid and a solution will be provided.\n\nThe analysis of a time integration scheme for the scalar oscillator $\\ddot{q}(t) + \\omega^{2}q(t) = 0$ involves finding the amplification properties of the algorithm. We seek a matrix $\\mathbf{A}$, the amplification matrix, that advances a state vector $\\mathbf{y}_n$ containing the system's state at time $t_n = n\\Delta t$ to the state $\\mathbf{y}_{n+1}$ at time $t_{n+1}$. The eigenvalues of $\\mathbf{A}$ are the amplification factors, which determine the stability and accuracy of the method. The nondimensional time step is $\\Omega = \\omega\\Delta t$.\n\nTask 1: Derivation of Amplification Matrices and Eigenvalues\n\n**Central Difference Method**\n\nThe central difference approximation to the second derivative at time $t_n$ is $\\ddot{q}_n \\approx \\frac{q_{n+1} - 2q_n + q_{n-1}}{\\Delta t^2}$. Substituting this into the modal equation $\\ddot{q}_n + \\omega^2 q_n = 0$ gives:\n$$\n\\frac{q_{n+1} - 2q_n + q_{n-1}}{\\Delta t^2} + \\omega^2 q_n = 0\n$$\nRearranging for $q_{n+1}$, we obtain the recurrence relation:\n$$\nq_{n+1} = (2 - \\omega^2 \\Delta t^2) q_n - q_{n-1} = (2 - \\Omega^2) q_n - q_{n-1}\n$$\nThis is a two-step method. To write it as a one-step system, we define a state vector $\\mathbf{y}_n = \\begin{pmatrix} q_n \\\\ q_{n-1} \\end{pmatrix}$. The state at the next step is $\\mathbf{y}_{n+1} = \\begin{pmatrix} q_{n+1} \\\\ q_n \\end{pmatrix}$. Using the recurrence relation, we have:\n$$\n\\mathbf{y}_{n+1} = \\begin{pmatrix} (2-\\Omega^2)q_n - q_{n-1} \\\\ q_n \\end{pmatrix} = \\begin{pmatrix} 2-\\Omega^2 & -1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} q_n \\\\ q_{n-1} \\end{pmatrix}\n$$\nThe amplification matrix is thus:\n$$\n\\mathbf{A}_{\\text{CD}} = \\begin{pmatrix} 2-\\Omega^2 & -1 \\\\ 1 & 0 \\end{pmatrix}\n$$\nIts eigenvalues, $\\lambda$, are found by solving the characteristic equation $\\det(\\mathbf{A}_{\\text{CD}} - \\lambda\\mathbf{I}) = 0$:\n$$\n\\det \\begin{pmatrix} 2-\\Omega^2 - \\lambda & -1 \\\\ 1 & -\\lambda \\end{pmatrix} = -\\lambda(2-\\Omega^2 - \\lambda) + 1 = \\lambda^2 - (2-\\Omega^2)\\lambda + 1 = 0\n$$\nThe eigenvalues are given by the quadratic formula:\n$$\n\\lambda_{1,2} = \\frac{(2-\\Omega^2) \\pm \\sqrt{(2-\\Omega^2)^2 - 4}}{2} = 1 - \\frac{\\Omega^2}{2} \\pm \\sqrt{\\left(1-\\frac{\\Omega^2}{2}\\right)^2 - 1}\n$$\n\n**Newmark Method (Average Acceleration)**\n\nThe Newmark family is defined with parameters $\\gamma = \\frac{1}{2}$ and $\\beta = \\frac{1}{4}$. The equations are:\n$$\n\\begin{aligned}\nq_{n+1} &= q_{n} + \\Delta t\\,v_{n} + \\Delta t^{2}\\left(\\frac{1}{4}a_{n} + \\frac{1}{4} a_{n+1}\\right) \\\\\nv_{n+1} &= v_{n} + \\Delta t\\left(\\frac{1}{2}a_{n} + \\frac{1}{2} a_{n+1}\\right)\n\\end{aligned}\n$$\nWe use the equations $a_n = -\\omega^2 q_n$ and $a_{n+1} = -\\omega^2 q_{n+1}$. Substituting these into the Newmark equations gives:\n$$\nq_{n+1} = q_n + \\Delta t v_n - \\frac{\\Omega^2}{4}(q_n + q_{n+1}) \\\\\nv_{n+1} = v_n - \\frac{\\omega^2\\Delta t}{2}(q_n + q_{n+1})\n$$\nWe form a state vector $\\mathbf{y}_n = \\begin{pmatrix} q_n \\\\ \\Delta t v_n \\end{pmatrix}$ and solve for $\\mathbf{y}_{n+1}$. First, we solve the first equation for $q_{n+1}$:\n$$\n(1 + \\frac{\\Omega^2}{4})q_{n+1} = (1 - \\frac{\\Omega^2}{4})q_n + \\Delta t v_n \\implies q_{n+1} = \\frac{1 - \\Omega^2/4}{1 + \\Omega^2/4}q_n + \\frac{1}{1 + \\Omega^2/4}\\Delta t v_n\n$$\nNext, we manipulate the second equation, multiplying by $\\Delta t$:\n$$\n\\Delta t v_{n+1} = \\Delta t v_n - \\frac{\\Omega^2}{2}(q_n + q_{n+1})\n$$\nSubstitute the expression for $q_{n+1}$ to find $q_n + q_{n+1}$:\n$$\nq_n + q_{n+1} = q_n + \\frac{1 - \\Omega^2/4}{1 + \\Omega^2/4}q_n + \\frac{1}{1 + \\Omega^2/4}\\Delta t v_n = \\frac{2}{1 + \\Omega^2/4}q_n + \\frac{1}{1 + \\Omega^2/4}\\Delta t v_n\n$$\nNow substitute this into the equation for $\\Delta t v_{n+1}$:\n$$\n\\Delta t v_{n+1} = \\Delta t v_n - \\frac{\\Omega^2}{2}\\left(\\frac{2}{1 + \\Omega^2/4}q_n + \\frac{1}{1 + \\Omega^2/4}\\Delta t v_n\\right) = -\\frac{\\Omega^2}{1 + \\Omega^2/4}q_n + \\left(1 - \\frac{\\Omega^2/2}{1 + \\Omega^2/4}\\right)\\Delta t v_n = -\\frac{\\Omega^2}{1 + \\Omega^2/4}q_n + \\frac{1 - \\Omega^2/4}{1 + \\Omega^2/4}\\Delta t v_n\n$$\nWe can now write the system in matrix form $\\mathbf{y}_{n+1} = \\mathbf{A}_{\\text{N}}\\mathbf{y}_n$:\n$$\n\\mathbf{A}_{\\text{N}} = \\frac{1}{1+\\Omega^2/4} \\begin{pmatrix} 1-\\Omega^2/4 & 1 \\\\ -\\Omega^2 & 1-\\Omega^2/4 \\end{pmatrix}\n$$\nThe eigenvalues are found from $\\det(\\mathbf{A}_{\\text{N}} - \\lambda\\mathbf{I}) = 0$:\n$$\n\\left(\\frac{1-\\Omega^2/4}{1+\\Omega^2/4} - \\lambda\\right)^2 + \\frac{\\Omega^2}{(1+\\Omega^2/4)^2} = 0\n$$\nThis gives complex conjugate roots:\n$$\n\\lambda_{1,2} = \\frac{1-\\Omega^2/4}{1+\\Omega^2/4} \\pm i \\frac{\\Omega}{1+\\Omega^2/4} = \\frac{1-\\Omega^2/4 \\pm i\\Omega}{1+\\Omega^2/4}\n$$\n\n**Generalized-$\\alpha$ Method**\n\nThe Generalized-$\\alpha$ method uses a state vector which includes acceleration, for example $\\mathbf{z}_n = \\begin{pmatrix} q_n \\\\ \\Delta t v_n \\\\ \\Delta t^2 a_n \\end{pmatrix}$. The one-step procedure is expressed as a linear system $\\mathbf{L}\\mathbf{z}_{n+1} = \\mathbf{R}\\mathbf{z}_n$, making it an implicit method. The amplification matrix is $\\mathbf{A}_{\\text{G}\\alpha} = \\mathbf{L}^{-1}\\mathbf{R}$. The system is:\n$$\n\\begin{pmatrix} 1 & 0 & -\\beta \\\\ (1-\\alpha_f)\\Omega^2 & 0 & 1-\\alpha_m \\\\ 0 & 1 & -\\gamma \\end{pmatrix} \\begin{pmatrix} q_{n+1} \\\\ \\Delta t^2 a_{n+1} \\\\ \\Delta t v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 & \\frac{1}{2}-\\beta & 1 \\\\ -\\alpha_f \\Omega^2 & -\\alpha_m & 0 \\\\ 0 & 1-\\gamma & 1 \\end{pmatrix} \\begin{pmatrix} q_n \\\\ \\Delta t^2 a_n \\\\ \\Delta t v_n \\end{pmatrix}\n$$\nThe amplification factors are the eigenvalues of $\\mathbf{A}_{\\text{G}\\alpha}$, which are the roots of the cubic characteristic polynomial $\\det(\\mathbf{R}-\\lambda\\mathbf{L}) = 0$. The derivation of the analytical expressions for the eigenvalues is algebraically intensive and beyond the scope of a concise solution. However, with the given parameter relations for second-order accuracy, one of the three eigenvalues is spurious and identically zero ($\\lambda_3=0$). The remaining two physical eigenvalues, $\\lambda_{1,2}$, are complex conjugates and their properties can be described. They are the roots of a quadratic equation whose coefficients are complicated rational functions of $\\Omega^2$ and the parameter $\\rho_\\infty$. The key design features are that $|\\lambda_{1,2}| \\le 1$ for all $\\Omega \\ge 0$ (unconditional stability) and $|\\lambda_{1,2}| \\to \\rho_\\infty$ as $\\Omega \\to \\infty$.\n\nTask 2: Loci of Amplification Factors and Interpretation\n\n- **Central Difference Method**: For $\\Omega \\in [0, 2]$, the eigenvalues are a complex conjugate pair with magnitude $|\\lambda| = \\sqrt{(1-\\Omega^2/2)^2 + (\\Omega^2 - \\Omega^4/4)} = 1$. The locus of eigenvalues lies on the unit circle in the complex plane. At $\\Omega=0$, $\\lambda=1$. As $\\Omega$ increases, the eigenvalues travel along the upper and lower semi-circles, reaching $\\lambda=-1$ at $\\Omega=2$. This behavior indicates that the method is not dissipative (it preserves energy) in its stability range, which is correct for an undamped system. However, the phase is not exact. The numerical phase angle $\\bar{\\Omega} = \\arccos(1-\\Omega^2/2)$ is smaller than the exact phase angle $\\Omega$, leading to period elongation (numerical dispersion). The numerical solution's period $T_{\\text{num}} = 2\\pi/\\bar{\\omega}$ is longer than the exact period $T=2\\pi/\\omega$. For $\\Omega > 2$, the eigenvalues become real and the spectral radius exceeds $1$, indicating instability.\n\n- **Newmark Method (Average Acceleration)**: The eigenvalues have magnitude $|\\lambda|^2 = \\frac{(1-\\Omega^2/4)^2 + \\Omega^2}{(1+\\Omega^2/4)^2} = \\frac{1-\\Omega^2/2+\\Omega^4/16+\\Omega^2}{1+\\Omega^2/2+\\Omega^4/16} = 1$ for all $\\Omega \\ge 0$. The locus of eigenvalues is the entire unit circle. Starting at $\\lambda=1$ for $\\Omega=0$, they travel along the circle, passing through $\\mp i$ at $\\Omega=2$, and approaching $\\lambda=-1$ as $\\Omega \\to \\infty$. Like the central difference method, this scheme is non-dissipative. It is unconditionally stable ($A$-stable). It also exhibits numerical dispersion (period elongation), as the numerical phase angle $\\bar{\\Omega} = \\arctan(\\frac{\\Omega}{1-\\Omega^2/4})$ differs from $\\Omega$.\n\n- **Generalized-$\\alpha$ Method**: For $\\rho_\\infty < 1$, the method introduces numerical dissipation. The locus of the principal eigenvalues starts at $\\lambda=1$ for $\\Omega=0$. As $\\Omega$ increases, the locus spirals inward within the unit circle. As $\\Omega \\to \\infty$, the eigenvalues approach the point $-\\rho_\\infty$ on the negative real axis. This means $|\\lambda| < 1$ for $\\Omega > 0$. The method is dissipative, and the amount of dissipation is controlled by $\\rho_\\infty$. Higher frequencies (larger $\\Omega$) are more strongly damped, which is a desirable property for filtering out spurious high-frequency content often present in semi-discrete models. The method also has numerical dispersion, which is typically of a period shortening nature for small $\\Omega$ and transitions to elongation. The $A$-stability ensures that all modal responses are damped, not amplified.\n\nTask 3: Stability Limit for Central Difference Method\n\nThe central difference method is stable as long as the spectral radius of its amplification matrix, $\\rho(\\mathbf{A}_{\\text{CD}})$, is less than or equal to $1$. The eigenvalues are given by $\\lambda_{1,2} = 1 - \\frac{\\Omega^2}{2} \\pm \\sqrt{(1 - \\frac{\\Omega^2}{2})^2 - 1}$.\n\n- If $0 \\le \\Omega \\le 2$, the term under the square root is non-positive. The eigenvalues form a complex conjugate pair $\\lambda_{1,2} = x \\pm iy$ where $x = 1-\\frac{\\Omega^2}{2}$ and $y = \\frac{\\Omega}{2}\\sqrt{4-\\Omega^2}$. Their magnitude is $|\\lambda| = \\sqrt{x^2+y^2} = 1$. The method is marginally stable.\n- If $\\Omega > 2$, the term under the square root is positive. The eigenvalues are real and distinct: $\\lambda_{1,2} = 1 - \\frac{\\Omega^2}{2} \\pm \\frac{\\Omega}{2}\\sqrt{\\Omega^2-4}$. The spectral radius is the magnitude of the larger (in magnitude) eigenvalue. Since $\\Omega^2/2 > 2$, $1-\\Omega^2/2 < -1$. The eigenvalue with the largest magnitude is $\\lambda_1 = 1 - \\frac{\\Omega^2}{2} - \\sqrt{\\frac{\\Omega^4}{4}-\\Omega^2}$. Its magnitude is $|\\lambda_1| = \\frac{\\Omega^2}{2} - 1 + \\sqrt{\\frac{\\Omega^4}{4}-\\Omega^2} > 1$. The method is unstable.\n\nThe transition from stable to unstable behavior occurs at $\\Omega=2$. Therefore, the largest nondimensional time step for which the central difference method is marginally stable is $\\Omega_{\\max}=2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "2545014"}, {"introduction": "Explicit time integration schemes owe much of their computational efficiency to the use of a diagonal, or \"lumped,\" mass matrix, which decouples the equations of motion and avoids a costly system solve at each time step. This simplification, however, is not without consequences, as it alters the inertial properties of the finite element model. This practice [@problem_id:2545080] offers a concrete, hands-on analysis of this trade-off by having you quantify the error in the natural vibration frequencies of a simple bar that results from mass lumping, a crucial skill for evaluating the dynamic fidelity of explicit simulations.", "problem": "A uniform, prismatic, linearly elastic bar of length $L$, cross-sectional area $A$, Young's modulus $E$, and mass density $\\rho$ undergoes small longitudinal vibrations with both ends fixed. The governing strong form is the axial wave equation $ \\rho A \\,\\ddot{u}(x,t) - \\frac{\\partial}{\\partial x}\\big(EA\\, \\frac{\\partial u}{\\partial x}(x,t)\\big) = 0 $ for $x \\in (0,L)$, with essential boundary conditions $u(0,t)=0$ and $u(L,t)=0$. Consider the standard Galerkin Finite Element Method (FEM) spatial semi-discretization using continuous, piecewise-linear shape functions over a uniform partition of the bar into $N=3$ equal elements. Impose the essential boundary conditions exactly, so that the only global unknowns are the interior nodal displacements.\n\nAs context, many implicit time integration procedures (for example, the Newmark family) use the consistent mass matrix, whereas many explicit procedures (for example, central-difference schemes) use a diagonal, lumped mass matrix to avoid solving linear systems. The choice of mass matrix changes the discrete modal properties.\n\nStarting from the weak form obtained by multiplying the strong form by a test function and integrating over $(0,L)$ with integration by parts on the stiffness term, and using the standard two-node linear shape functions on each element, perform the following steps without assuming any special orthogonality beyond what follows from the uniform mesh and imposed boundary conditions:\n- Derive the element stiffness and mass matrices and assemble the global semi-discrete system in the form $K\\,\\mathbf{u}(t) + M\\,\\ddot{\\mathbf{u}}(t) = \\mathbf{0}$ for the $N=3$-element mesh after applying boundary conditions, for both the consistent mass matrix $M^{(C)}$ and a fully diagonal lumped mass matrix $M^{(L)}$ obtained by exact row-sum lumping of the consistent mass at the element level.\n- Form the corresponding generalized eigenvalue problems $K\\,\\boldsymbol{\\phi}^{(C)}=\\omega^{2}\\,M^{(C)}\\,\\boldsymbol{\\phi}^{(C)}$ and $K\\,\\boldsymbol{\\phi}^{(L)}=\\omega^{2}\\,M^{(L)}\\,\\boldsymbol{\\phi}^{(L)}$.\n- Compute the first $2$ discrete angular frequencies $\\omega_{1}^{(C)}$, $\\omega_{2}^{(C)}$ (consistent mass) and $\\omega_{1}^{(L)}$, $\\omega_{2}^{(L)}$ (lumped mass) in closed form.\n\nDefine the relative frequency error for mode $p \\in \\{1,2\\}$ as\n$$\n\\varepsilon_{p} \\equiv \\frac{\\omega_{p}^{(L)} - \\omega_{p}^{(C)}}{\\omega_{p}^{(C)}},\n$$\nand the maximum magnitude of the relative frequency error over the first two discrete modes as\n$$\n\\mathcal{E}_{\\max} \\equiv \\max\\{|\\varepsilon_{1}|,\\,|\\varepsilon_{2}|\\}.\n$$\n\nCompute $\\mathcal{E}_{\\max}$ as a single closed-form analytic expression in terms of radicals and integers only. Do not introduce any numerical values for $E$, $\\rho$, $A$, or $L$; your final expression must be independent of material and geometric parameters. Express the answer as a pure number without units. No rounding is required.", "solution": "The problem statement is critically examined and found to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The problem is a standard exercise in the finite element analysis of structural dynamics.\n\nThe strong form of the governing equation for longitudinal vibrations of a uniform bar is\n$$ \\rho A \\frac{\\partial^2 u}{\\partial t^2}(x,t) - \\frac{\\partial}{\\partial x}\\left(EA \\frac{\\partial u}{\\partial x}(x,t)\\right) = 0, \\quad x \\in (0,L) $$\nwith boundary conditions $u(0,t)=0$ and $u(L,t)=0$. The corresponding weak form is obtained by multiplying by a test function $v(x)$ and integrating by parts:\n$$ \\int_0^L \\rho A v \\ddot{u} \\,dx + \\int_0^L EA \\frac{\\partial v}{\\partial x} \\frac{\\partial u}{\\partial x} \\,dx = 0 $$\nThe solution $u(x,t)$ is approximated as $u(x,t) \\approx \\sum_{i} N_i(x) u_i(t)$, where $N_i(x)$ are the shape functions. This semi-discretization leads to the matrix system $M \\ddot{\\mathbf{u}} + K \\mathbf{u} = \\mathbf{0}$.\n\nWe first derive the element stiffness and mass matrices for a standard $2$-node linear bar element of length $h$. The shape functions in local coordinates $\\xi \\in [0,h]$ are $N_1(\\xi) = 1 - \\frac{\\xi}{h}$ and $N_2(\\xi) = \\frac{\\xi}{h}$. Their derivatives are $N_1'(\\xi) = -\\frac{1}{h}$ and $N_2'(\\xi) = \\frac{1}{h}$.\n\nThe element stiffness matrix $k_e$ has entries $k_{ij} = \\int_0^h EA N_i' N_j' d\\xi$.\n$$ k_e = \\int_0^h EA \\begin{pmatrix} (-1/h)^2 & (-1/h)(1/h) \\\\ (1/h)(-1/h) & (1/h)^2 \\end{pmatrix} d\\xi = \\frac{EA}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\n\nThe element consistent mass matrix $m_e^{(C)}$ has entries $m_{ij}^{(C)} = \\int_0^h \\rho A N_i N_j d\\xi$.\n$$ m_{11}^{(C)} = \\rho A \\int_0^h (1-\\frac{\\xi}{h})^2 d\\xi = \\frac{\\rho A h}{3} $$\n$$ m_{12}^{(C)} = \\rho A \\int_0^h (1-\\frac{\\xi}{h})(\\frac{\\xi}{h}) d\\xi = \\frac{\\rho A h}{6} $$\n$$ m_e^{(C)} = \\frac{\\rho A h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix} $$\n\nThe element lumped mass matrix $m_e^{(L)}$ is obtained by summing the rows of $m_e^{(C)}$ and placing the sums on the diagonal. The sum of each row is $\\frac{\\rho A h}{6}(2+1) = \\frac{\\rho A h}{2}$.\n$$ m_e^{(L)} = \\frac{\\rho A h}{2} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} $$\n\nThe bar is discretized into $N=3$ equal elements, so the element length is $h=L/3$. There are $4$ nodes, indexed $0, 1, 2, 3$. The boundary conditions $u(0,t)=0$ and $u(L,t)=0$ mean that the displacements at node $0$ and node $3$, $u_0$ and $u_3$, are zero. The unknown degrees of freedom are the displacements at the interior nodes $1$ and $2$, $\\mathbf{u} = [u_1, u_2]^T$. We assemble the global matrices and then extract the $2 \\times 2$ sub-system corresponding to these free nodes.\n\nAssembly of the global stiffness matrix $K$:\n$$ K = \\frac{EA}{h} \\begin{pmatrix} 1+1 & -1 \\\\ -1 & 1+1 \\end{pmatrix} = \\frac{3EA}{L} \\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} $$\n\nAssembly of the global consistent mass matrix $M^{(C)}$:\n$$ M^{(C)} = \\frac{\\rho A h}{6} \\begin{pmatrix} 2+2 & 1 \\\\ 1 & 2+2 \\end{pmatrix} = \\frac{\\rho A (L/3)}{6} \\begin{pmatrix} 4 & 1 \\\\ 1 & 4 \\end{pmatrix} = \\frac{\\rho A L}{18} \\begin{pmatrix} 4 & 1 \\\\ 1 & 4 \\end{pmatrix} $$\n\nAssembly of the global lumped mass matrix $M^{(L)}$:\n$$ M^{(L)} = \\frac{\\rho A h}{2} \\begin{pmatrix} 1+1 & 0 \\\\ 0 & 1+1 \\end{pmatrix} = \\frac{\\rho A (L/3)}{2} \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} = \\frac{\\rho A L}{3} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} $$\n\nWe now solve the generalized eigenvalue problems $K \\boldsymbol{\\phi} = \\omega^2 M \\boldsymbol{\\phi}$, which is $\\det(K - \\omega^2 M) = 0$.\n\nFor consistent mass, $M = M^{(C)}$, the problem is $\\det(K - (\\omega^{(C)})^2 M^{(C)}) = 0$. Let $\\lambda_C = (\\omega^{(C)})^2$.\n$$ \\det\\left( \\frac{3EA}{L} \\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} - \\lambda_C \\frac{\\rho A L}{18} \\begin{pmatrix} 4 & 1 \\\\ 1 & 4 \\end{pmatrix} \\right) = 0 $$\nLet us define a constant $C_0 = \\frac{54E}{\\rho L^2}$. The determinant becomes:\n$$ \\det\\left( \\frac{C_0}{18} \\frac{\\rho A L}{3} \\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} - \\lambda_C \\frac{\\rho A L}{18} \\begin{pmatrix} 4 & 1 \\\\ 1 & 4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det\\left( C_0 \\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} - \\lambda_C \\begin{pmatrix} 4 & 1 \\\\ 1 & 4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det \\begin{pmatrix} 2C_0 - 4\\lambda_C & -C_0 - \\lambda_C \\\\ -C_0 - \\lambda_C & 2C_0 - 4\\lambda_C \\end{pmatrix} = 0 $$\nThis yields $(2C_0 - 4\\lambda_C)^2 - (C_0 + \\lambda_C)^2 = 0$, which gives two solutions:\n1. $2C_0 - 4\\lambda_C = C_0 + \\lambda_C \\implies C_0 = 5\\lambda_C \\implies \\lambda_C = C_0/5$.\n2. $2C_0 - 4\\lambda_C = -(C_0 + \\lambda_C) \\implies 3C_0 = 3\\lambda_C \\implies \\lambda_C = C_0$.\nThe eigenvalues are $(\\omega_{1}^{(C)})^2 = \\frac{C_0}{5} = \\frac{54}{5} \\frac{E}{\\rho L^2}$ and $(\\omega_{2}^{(C)})^2 = C_0 = 54 \\frac{E}{\\rho L^2}$.\n\nFor lumped mass, $M = M^{(L)}$, the problem is $\\det(K - (\\omega^{(L)})^2 M^{(L)}) = 0$. Let $\\lambda_L = (\\omega^{(L)})^2$.\n$$ \\det\\left( \\frac{3EA}{L} \\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix} - \\lambda_L \\frac{\\rho A L}{3} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\right) = 0 $$\nThis is a standard eigenvalue problem for the matrix $K$. Let $\\mu$ be the eigenvalues of $\\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix}$.\n$\\det \\begin{pmatrix} 2-\\mu & -1 \\\\ -1 & 2-\\mu \\end{pmatrix} = (2-\\mu)^2 - 1 = 0 \\implies 2-\\mu = \\pm 1$.\nThe eigenvalues are $\\mu_1 = 1$ and $\\mu_2 = 3$.\nThe relationship is $\\frac{3EA}{L} \\mu = \\lambda_L \\frac{\\rho A L}{3}$, so $\\lambda_L = \\mu \\frac{9E}{\\rho L^2}$.\nThe eigenvalues are $(\\omega_{1}^{(L)})^2 = 1 \\cdot \\frac{9E}{\\rho L^2} = 9 \\frac{E}{\\rho L^2}$ and $(\\omega_{2}^{(L)})^2 = 3 \\cdot \\frac{9E}{\\rho L^2} = 27 \\frac{E}{\\rho L^2}$.\n\nNow we compute the angular frequencies by taking the square root. All physical parameters are positive.\n$\\omega_{1}^{(C)} = \\sqrt{\\frac{54}{5} \\frac{E}{\\rho L^2}}$, $\\omega_{2}^{(C)} = \\sqrt{54 \\frac{E}{\\rho L^2}}$\n$\\omega_{1}^{(L)} = \\sqrt{9 \\frac{E}{\\rho L^2}} = 3 \\sqrt{\\frac{E}{\\rho L^2}}$, $\\omega_{2}^{(L)} = \\sqrt{27 \\frac{E}{\\rho L^2}}$\n\nThe relative frequency error for mode $p$ is $\\varepsilon_{p} = \\frac{\\omega_{p}^{(L)} - \\omega_{p}^{(C)}}{\\omega_{p}^{(C)}} = \\frac{\\omega_{p}^{(L)}}{\\omega_{p}^{(C)}} - 1$.\nFor mode $p=1$:\n$$ \\frac{\\omega_{1}^{(L)}}{\\omega_{1}^{(C)}} = \\frac{\\sqrt{9}}{\\sqrt{54/5}} = \\sqrt{\\frac{9 \\cdot 5}{54}} = \\sqrt{\\frac{45}{54}} = \\sqrt{\\frac{5}{6}} $$\n$$ \\varepsilon_{1} = \\sqrt{\\frac{5}{6}} - 1 $$\nFor mode $p=2$:\n$$ \\frac{\\omega_{2}^{(L)}}{\\omega_{2}^{(C)}} = \\frac{\\sqrt{27}}{\\sqrt{54}} = \\sqrt{\\frac{27}{54}} = \\sqrt{\\frac{1}{2}} = \\frac{1}{\\sqrt{2}} $$\n$$ \\varepsilon_{2} = \\frac{1}{\\sqrt{2}} - 1 $$\nBoth errors are negative, as expected, because mass lumping reduces the discrete frequencies.\n\nWe need to compute $\\mathcal{E}_{\\max} = \\max\\{|\\varepsilon_{1}|,\\,|\\varepsilon_{2}|\\}$.\n$|\\varepsilon_1| = \\left|\\sqrt{\\frac{5}{6}} - 1\\right| = 1 - \\sqrt{\\frac{5}{6}}$.\n$|\\varepsilon_2| = \\left|\\frac{1}{\\sqrt{2}} - 1\\right| = 1 - \\frac{1}{\\sqrt{2}}$.\nTo compare these values, we compare $\\sqrt{5/6}$ and $1/\\sqrt{2}$. Squaring both gives $5/6$ and $1/2$.\nSince $\\frac{5}{6} > \\frac{1}{2}$ (as $0.833... > 0.5$), it follows that $\\sqrt{\\frac{5}{6}} > \\frac{1}{\\sqrt{2}}$.\nThis implies $1 - \\sqrt{\\frac{5}{6}} < 1 - \\frac{1}{\\sqrt{2}}$.\nTherefore, $|\\varepsilon_1| < |\\varepsilon_2|$, and the maximum error is $|\\varepsilon_2|$.\n$$ \\mathcal{E}_{\\max} = |\\varepsilon_2| = 1 - \\frac{1}{\\sqrt{2}} = 1 - \\frac{\\sqrt{2}}{2} = \\frac{2 - \\sqrt{2}}{2} $$\nThis expression is a pure number, independent of the material and geometric parameters, as required.", "answer": "$$\n\\boxed{\\frac{2 - \\sqrt{2}}{2}}\n$$", "id": "2545080"}, {"introduction": "While linear analysis provides essential insights, the true power and challenge of numerical methods emerge in nonlinear problems, such as those involving material degradation and damage. In these systems, strong coupling between state variables (like displacement and damage) can lead to numerical instabilities, particularly in models exhibiting softening behavior. This advanced coding benchmark [@problem_id:2545077] challenges you to implement both explicit and implicit solvers for a damage evolution problem, providing a stark demonstration of how an explicit \"staggered\" scheme can fail with mesh refinement, and why the superior stability of an implicit approach is often indispensable for robustly simulating complex material phenomena.", "problem": "Consider a one-dimensional bar of length $L$ and cross-sectional area $A$ undergoing quasi-static uniaxial tension, modeled by the Finite Element Method (FEM). Let the bar be partitioned into $N$ equal two-node linear elements of length $h = L/N$, with $N+1$ nodes. The left end at $x=0$ is fixed ($u(0,t)=0$), and the right end at $x=L$ is subjected to a prescribed displacement $u(L,t) = \\bar{u}(t)$ that increases monotonically in pseudo-time $t \\in [0,1]$ according to $\\bar{u}(t) = u_{\\mathrm{final}} \\, t$. Assume dimensionless units for all quantities in this benchmark.\n\nConstitutive behavior is linear elastic with scalar isotropic damage: the Cauchy stress in each element is $\\sigma = (1-d) \\, E \\, \\varepsilon$, where $E$ is Young's modulus, $\\varepsilon$ is the axial strain (constant per element for linear shape functions), and $d \\in [0,1]$ is the internal damage variable ($d=0$ undamaged, $d=1$ fully damaged). Damage evolves according to a viscous regularized rate law driven by the elastic energy release rate. Define the elastic energy release rate per unit volume as $Y = \\tfrac{1}{2} E \\, \\varepsilon^2$. The local damage driving threshold is $Y_c(d) = Y_{0,i} \\, (1 - \\beta \\, d)$ for element index $i \\in \\{0,\\dots,N-1\\}$, where $Y_{0,i}$ is the element-wise initial threshold including a deterministic small material imperfection, and $\\beta>0$ is a softening slope parameter. Use $Y_{0,i} = Y_0 \\, \\bigl( 1 + \\epsilon_{\\mathrm{imp}} \\, \\sin( 2\\pi \\, (i + \\tfrac{1}{2})/N ) \\bigr)$, with a small imperfection amplitude $\\epsilon_{\\mathrm{imp}} \\ll 1$. The rate-dependent damage flow rule is\n$$\n\\eta \\, \\dot{d} = \\langle Y - Y_c(d) \\rangle_{+}, \\quad d \\in [0,1], \\quad \\dot{d} \\ge 0,\n$$\nwhere $\\eta>0$ is the viscosity (regularization) parameter, the Macaulay bracket $\\langle \\cdot \\rangle_{+}$ denotes the positive part, and the inequality $\\dot{d}\\ge 0$ enforces irreversibility. The weak form of equilibrium at each pseudo-time is the standard virtual work statement for the bar with stress $\\sigma = (1-d) E \\varepsilon$, leading to the assembled global linear system\n$$\n\\mathbf{K}(\\mathbf{d}) \\, \\mathbf{u} = \\mathbf{f},\n$$\nwhere $\\mathbf{K}(\\mathbf{d})$ is the damage-dependent global stiffness, $\\mathbf{u}$ is the nodal displacement vector, and $\\mathbf{f}$ represents external nodal loads equivalent to the imposed displacement boundary conditions. For the uniform bar without body forces, one may assemble $\\mathbf{K}(\\mathbf{d})$ from elemental contributions $\\mathbf{K}_e(d_e) = \\dfrac{(1 - d_e) \\, E \\, A}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n\nTwo time-integration procedures for the damage evolution are to be compared:\n\n- An explicit staggered procedure that advances $d$ using a forward Euler update at each pseudo-time step of size $\\Delta t$ based on strains from the previous time step, and then solves the linear equilibrium with the updated $\\mathbf{K}(\\mathbf{d})$ to obtain the new displacement field consistent with the imposed boundary conditions.\n\n- An implicit procedure that, at each pseudo-time step, solves for the displacement and the updated damage in a coupled manner using a backward Euler update of the damage flow rule, iterated to convergence (e.g., by fixed-point or Newton iteration on the coupled system), so that the damage and displacement are consistent at the end of the time step.\n\nYour task is to implement both procedures for the following benchmark in strictly dimensionless form, starting from the above fundamental definitions and the principle of virtual work. Use one Gauss point per element. Use a uniform cross-section and material, with the following parameters:\n- $L = 1$,\n- $A = 1$,\n- $E = 1$,\n- $Y_0 = 0.03$,\n- $\\beta = 1$,\n- $\\eta = 0.01$,\n- $\\epsilon_{\\mathrm{imp}} = 10^{-3}$,\n- $u_{\\mathrm{final}} = 0.3$.\n\nFor each time step, compute the global reaction at the loaded end $x=L$ as the nodal reaction force required to enforce the displacement boundary condition; in the assembled system without body forces, this is the product of the full assembled stiffness row corresponding to the loaded node with the converged displacement vector. Track the reaction force sequence $\\{F_n\\}_{n=0}^{N_t}$ for both explicit and implicit procedures, where $N_t = 1/\\Delta t$.\n\nTo quantitatively compare the procedures, compute for each procedure:\n1. The peak reaction force $F_{\\max} = \\max_{0 \\le n \\le N_t} F_n$.\n2. The oscillation excess\n$$\n\\gamma = \\sum_{n=0}^{N_t-1} \\left| F_{n+1} - F_n \\right| \\;-\\; \\left( (F_{\\max} - F_0) + (F_{\\max} - F_{N_t}) \\right),\n$$\nwhich is zero for a perfectly unimodal monotone-increase-then-monotone-decrease response and positive when mesh-dependent or time-integration-induced oscillations occur.\n\nDesign a small test suite that reveals mesh-dependent instability in the explicit staggered procedure and demonstrates stabilization by the implicit regularization. Use the following three test cases, each defined by $(N, \\Delta t)$:\n- Test $1$: $(N, \\Delta t) = (16, 0.005)$,\n- Test $2$: $(N, \\Delta t) = (64, 0.005)$,\n- Test $3$: $(N, \\Delta t) = (16, 0.010)$.\n\nFor each test case, run both procedures over $t \\in [0,1]$ with $\\bar{u}(t) = u_{\\mathrm{final}} \\, t$. Your program must output a single line containing a list of three items, one per test case, where each item is the list $[\\gamma_{\\mathrm{explicit}}, \\gamma_{\\mathrm{implicit}}, F_{\\max,\\mathrm{explicit}}, F_{\\max,\\mathrm{implicit}}]$ in this exact order. The output must be printed as a single line in the format $[[g_{1,E},g_{1,I},F_{1,E},F_{1,I}],[g_{2,E},g_{2,I},F_{2,E},F_{2,I}],[g_{3,E},g_{3,I},F_{3,E},F_{3,I}]]$ with decimal numbers.\n\nAll quantities are dimensionless. Angles are not used. No percentages are required. The final printout must be exactly one line with the specified list-of-lists format, containing floating-point numbers. The solution must be fully self-contained and not require any user input or external files.", "solution": "The problem requires the implementation and comparison of two numerical procedures, explicit and implicit, for solving a quasi-static uniaxial tension problem of a bar with material damage. The model is based on the Finite Element Method (FEM). This document presents the formulation and algorithmic design for the solution. All mathematical entities are rendered in LaTeX as required.\n\nFirst, we establish the problem's governing equations. The bar has length $L=1$, cross-section area $A=1$, and Young's modulus $E=1$. It is discretized into $N$ linear finite elements of equal length $h=L/N$.\n\nThe equilibrium of the discretized system is expressed by the global matrix equation:\n$$\n\\mathbf{K}(\\mathbf{d}) \\mathbf{u} = \\mathbf{f}\n$$\nwhere $\\mathbf{u}$ is the vector of $N+1$ nodal displacements, $\\mathbf{d}$ is the vector of $N$ element damage variables, $\\mathbf{K}(\\mathbf{d})$ is the $(N+1) \\times (N+1)$ global stiffness matrix, and $\\mathbf{f}$ is the vector of nodal forces. The elemental stiffness matrix for element $e$ with damage $d_e$ is:\n$$\n\\mathbf{K}_e(d_e) = \\frac{(1 - d_e) E A}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix}\n$$\nThe boundary conditions are a fixed displacement $u_0 = 0$ at $x=0$ and a prescribed displacement $u_N = \\bar{u}(t) = u_{\\mathrm{final}} \\cdot t$ at $x=L$. We solve for the $N-1$ unknown internal nodal displacements $\\mathbf{u}_I = [u_1, \\dots, u_{N-1}]^T$. This leads to a reduced, $(N-1) \\times (N-1)$ tridiagonal linear system $\\mathbf{A} \\mathbf{u}_I = \\mathbf{b}$, where the matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ depend on the current damage state $\\mathbf{d}$. The non-zero entries of $\\mathbf{A}$ are:\n$$\nA_{i,i} = \\frac{(1-d_{i-1})EA}{h} + \\frac{(1-d_{i})EA}{h}, \\quad i=1, \\dots, N-1\n$$\n$$\nA_{i,i-1} = -\\frac{(1-d_{i-1})EA}{h}, \\quad i=2, \\dots, N-1\n$$\n$$\nA_{i,i+1} = -\\frac{(1-d_{i})EA}{h}, \\quad i=1, \\dots, N-2\n$$\nThe right-hand side vector $\\mathbf{b}$ is zero except for its last component:\n$$\nb_{N-1} = \\frac{(1-d_{N-1})EA}{h} \\bar{u}(t)\n$$\nThis tridiagonal system is efficiently solvable.\n\nThe damage evolution is governed by the rate law $\\eta \\dot{d} = \\langle Y - Y_c(d) \\rangle_{+}$, where $\\eta=0.01$ is viscosity. The energy release rate is $Y = \\frac{1}{2} E \\varepsilon^2$, with strain $\\varepsilon_i = (u_{i+1} - u_i)/h$ for element $i$. The damage threshold is $Y_c(d) = Y_{0,i}(1 - \\beta d)$, with $\\beta=1$. The initial threshold $Y_{0,i}$ includes a spatial imperfection:\n$$\nY_{0,i} = Y_0 \\left( 1 + \\epsilon_{\\mathrm{imp}} \\sin\\left( \\frac{2\\pi(i + 0.5)}{N} \\right) \\right)\n$$\nwith $Y_0 = 0.03$ and $\\epsilon_{\\mathrm{imp}} = 10^{-3}$.\n\nThe simulation proceeds in discrete time steps of size $\\Delta t$ from $t=0$ to $t=1$. Let the index for the time step be $n$.\n\n**Explicit Staggered Procedure**\n\nIn this procedure, the state at time $t_{n+1}$ is computed sequentially.\n1.  **Damage Update**: The damage $d_{i,n+1}$ for each element $i$ is calculated using a forward Euler step, based on the state at $t_n$:\n    $$\n    d_{i,n+1} = d_{i,n} + \\frac{\\Delta t}{\\eta} \\left\\langle \\frac{1}{2}E \\varepsilon_{i,n}^2 - Y_{0,i}(1 - \\beta d_{i,n}) \\right\\rangle_{+}\n    $$\n    where $\\varepsilon_{i,n} = (u_{i+1,n} - u_{i,n})/h$. The updated damage is constrained to the interval $[d_{i,n}, 1]$ to ensure irreversibility and the physical limit.\n2.  **Equilibrium Solve**: With the new damage values $\\mathbf{d}_{n+1}$, the linear system for displacements at $t_{n+1}$ is assembled and solved: $\\mathbf{A}(\\mathbf{d}_{n+1}) \\mathbf{u}_{I,n+1} = \\mathbf{b}(\\mathbf{d}_{n+1}, \\bar{u}(t_{n+1}))$. This yields the internal displacements $\\mathbf{u}_{I,n+1}$. The full displacement vector is $\\mathbf{u}_{n+1} = [0, u_{1,n+1}, \\dots, u_{N-1,n+1}, \\bar{u}(t_{n+1})]^T$.\n\n**Implicit Procedure**\n\nThis procedure solves for damage and displacements at $t_{n+1}$ simultaneously using a backward Euler scheme for damage. This results in a nonlinear system at each time step, which is solved here using a fixed-point (Picard) iteration.\nFor each time step $n \\to n+1$, we iterate with index $k$:\n1.  **Initialization**: Start with an initial guess for the new damage state, e.g., $\\mathbf{d}_{n+1}^{(0)} = \\mathbf{d}_n$.\n2.  **Fixed-Point Iteration**:\n    a. **Equilibrium Solve**: Given the damage guess $\\mathbf{d}_{n+1}^{(k)}$, solve for the displacements $\\mathbf{u}_{n+1}^{(k+1)}$ by solving the linear system $\\mathbf{A}(\\mathbf{d}_{n+1}^{(k)}) \\mathbf{u}_{I,n+1}^{(k+1)} = \\mathbf{b}(\\mathbf{d}_{n+1}^{(k)}, \\bar{u}(t_{n+1}))$.\n    b. **Damage Update**: Using the computed displacements $\\mathbf{u}_{n+1}^{(k+1)}$, calculate the corresponding strains $\\varepsilon_{i,n+1}^{(k+1)}$. Then, update the damage for each element by solving the implicit equation:\n    $$\n    \\eta \\frac{d_{i,n+1}^{(k+1)} - d_{i,n}}{\\Delta t} = \\left\\langle \\frac{1}{2}E \\left(\\varepsilon_{i,n+1}^{(k+1)}\\right)^2 - Y_{0,i}(1 - \\beta d_{i,n+1}^{(k+1)}) \\right\\rangle_{+}\n    $$\n    If the term in the Macaulay brackets is non-positive when evaluated at $d_{i,n}$, no damage growth occurs, so $d_{i,n+1}^{(k+1)} = d_{i,n}$. Otherwise, the equation is linear in $d_{i,n+1}^{(k+1)}$ and is solved as:\n    $$\n    d_{i,n+1}^{(k+1)} = \\frac{d_{i,n} + \\frac{\\Delta t}{\\eta} \\left( \\frac{1}{2}E\\left(\\varepsilon_{i,n+1}^{(k+1)}\\right)^2 - Y_{0,i} \\right)}{1 - \\frac{\\Delta t}{\\eta} Y_{0,i} \\beta}\n    $$\n    The result is again constrained to $[d_{i,n}, 1]$.\n    c. **Convergence Check**: If the change $\\|\\mathbf{d}_{n+1}^{(k+1)} - \\mathbf{d}_{n+1}^{(k)}\\|$ is smaller than a tolerance, the iteration has converged. Otherwise, set $k \\to k+1$ and repeat.\n\n**Output Calculation**\n\nAfter each successful time step integration (for either procedure), the reaction force $F_{n+1}$ at the loaded end $x=L$ is computed. From the global equilibrium equations, this force corresponds to the last row of $\\mathbf{K}\\mathbf{u}$:\n$$\nF_{n+1} = \\frac{(1 - d_{N-1, n+1}) E A}{h} (u_{N, n+1} - u_{N-1, n+1})\n$$\nThe force history $\\{F_n\\}_{n=0}^{N_t}$ is collected. The peak force $F_{\\max}$ is the maximum of this sequence. The oscillation excess $\\gamma$ is computed using its definition:\n$$\n\\gamma = \\sum_{n=0}^{N_t-1} \\left| F_{n+1} - F_n \\right| - \\left( (F_{\\max} - F_0) + (F_{\\max} - F_{N_t}) \\right)\n$$\nwhere $F_0=0$. These calculations are performed for both explicit and implicit methods for each of the three test cases specified. The expected outcome is that the explicit method will show numerical instability (large $\\gamma$) for finer meshes or larger time steps, while the implicit method remains stable.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark simulations and print the results.\n    \"\"\"\n    # Dimensionless parameters from the problem statement\n    params = {\n        'L': 1.0,\n        'A': 1.0,\n        'E': 1.0,\n        'Y0': 0.03,\n        'beta': 1.0,\n        'eta': 0.01,\n        'eps_imp': 1e-3,\n        'u_final': 0.3\n    }\n    \n    test_cases = [\n        (16, 0.005),  # Test 1\n        (64, 0.005),  # Test 2\n        (16, 0.010),  # Test 3\n    ]\n\n    all_results = []\n    for N, dt in test_cases:\n        F_hist_explicit = run_simulation(N, dt, 'explicit', params)\n        F_hist_implicit = run_simulation(N, dt, 'implicit', params)\n\n        gamma_explicit, F_max_explicit = calculate_metrics(F_hist_explicit)\n        gamma_implicit, F_max_implicit = calculate_metrics(F_hist_implicit)\n        \n        case_results = [gamma_explicit, gamma_implicit, F_max_explicit, F_max_implicit]\n        all_results.append(case_results)\n\n    # Format output as a single line string representation of a list of lists.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    output_str = '[' + ','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results]) + ']'\n    print(output_str)\n\n\ndef run_simulation(N, dt, method, params):\n    \"\"\"\n    Runs a single simulation for a given configuration (N, dt, method).\n    \"\"\"\n    L, A, E = params['L'], params['A'], params['E']\n    Y0, beta, eta = params['Y0'], params['beta'], params['eta']\n    eps_imp, u_final = params['eps_imp'], params['u_final']\n\n    h = L / N\n    Nt = int(round(1.0 / dt))\n\n    # Element-wise initial damage threshold\n    i_coords = np.arange(N) + 0.5\n    Y0_i = Y0 * (1 + eps_imp * np.sin(2 * np.pi * i_coords / N))\n\n    u = np.zeros(N + 1)\n    d = np.zeros(N)\n    \n    F_history = [0.0]\n\n    for n in range(Nt):\n        t_np1 = (n + 1) * dt\n        u_prescribed = u_final * t_np1\n\n        if method == 'explicit':\n            # Explicit damage update\n            eps_n = (u[1:] - u[:-1]) / h\n            Y_n = 0.5 * E * eps_n**2\n            Yc_n = Y0_i * (1 - beta * d)\n            d_dot = (1 / eta) * np.maximum(0, Y_n - Yc_n)\n            d_np1 = d + d_dot * dt\n            d_np1 = np.minimum(d_np1, 1.0) # Enforce d <= 1\n            \n            # Solve for displacement\n            u_np1 = solve_displacements(d_np1, u_prescribed, N, h, A, E)\n\n        elif method == 'implicit':\n            u_np1, d_np1 = solve_implicit_step(u, d, u_prescribed, N, h, dt, params, Y0_i)\n        \n        # Update state variables\n        u = u_np1\n        d = d_np1\n        \n        # Calculate reaction force\n        # F_np1 = (1 - d[N-1]) * E * A / h * (u[N] - u[N-1])\n        # A more stable calculation, as d[N-1] could be 1\n        stiffness_last_elem = (1 - d[N-1]) * E * A / h\n        F_np1 = stiffness_last_elem * (u_np1[N] - u_np1[N-1])\n\n        F_history.append(F_np1)\n        \n    return np.array(F_history)\n\ndef solve_displacements(d, u_prescribed, N, h, A, E):\n    \"\"\"\n    Solves the tridiagonal system for internal nodal displacements.\n    \"\"\"\n    u_np1 = np.zeros(N + 1)\n    u_np1[N] = u_prescribed\n\n    if N > 1:\n        # Assemble tridiagonal system for internal nodes (1 to N-1)\n        k_elem = (1 - d) * E * A / h\n        \n        diag = k_elem[:-1] + k_elem[1:]\n        upper_diag = -k_elem[1:-1]\n        lower_diag = -k_elem[1:-1]\n        \n        # SciPy's solve_banded format:\n        # ab[0,:] is upper diagonal (shifted)\n        # ab[1,:] is main diagonal\n        # ab[2,:] is lower diagonal (shifted)\n        ab = np.zeros((3, N - 1))\n        ab[0, 1:] = upper_diag\n        ab[1, :] = diag\n        ab[2, :-1] = lower_diag\n        \n        # Assemble RHS vector\n        b = np.zeros(N - 1)\n        b[-1] = k_elem[-1] * u_prescribed\n\n        try:\n            u_internal = solve_banded((1, 1), ab, b)\n            u_np1[1:N] = u_internal\n        except np.linalg.LinAlgError:\n            # If matrix is singular (e.g., full damage), handle gracefully.\n            # This simplified handling assumes failure propagation.\n            u_np1[1:N] = np.linspace(0, u_prescribed, N+1)[1:N]\n\n    return u_np1\n\ndef solve_implicit_step(u_n, d_n, u_prescribed, N, h, dt, params, Y0_i):\n    \"\"\"\n    Solves the coupled system for one implicit time step using fixed-point iteration.\n    \"\"\"\n    E, beta, eta = params['E'], params['beta'], params['eta']\n    \n    # Fixed-point iteration settings\n    max_iter = 100\n    tol = 1e-8\n    \n    # Initial guess\n    d_k = d_n.copy()\n    \n    for _ in range(max_iter):\n        # 1. Solve for displacements with current damage guess d_k\n        u_kp1 = solve_displacements(d_k, u_prescribed, N, h, params['A'], E)\n        \n        # 2. Update damage with new displacements u_kp1\n        eps_kp1 = (u_kp1[1:] - u_kp1[:-1]) / h\n        Y_kp1 = 0.5 * E * eps_kp1**2\n        \n        # Check damage criterion\n        g_at_dn = Y_kp1 - Y0_i * (1 - beta * d_n)\n        \n        d_kp1 = d_n.copy()\n        \n        # Find elements where damage grows\n        idx_growth = g_at_dn > 0\n        \n        if np.any(idx_growth):\n            Y0_i_g = Y0_i[idx_growth]\n            d_n_g = d_n[idx_growth]\n            Y_kp1_g = Y_kp1[idx_growth]\n\n            # Solve for d_kp1\n            # d_kp1 * (eta/dt - Y0_i*beta) = eta/dt*d_n + Y_kp1 - Y0_i\n            denom = (eta / dt) - Y0_i_g * beta\n            # Avoid division by zero, although not expected with problem params\n            denom[np.abs(denom) < 1e-12] = 1e-12\n            \n            num = (eta / dt) * d_n_g + Y_kp1_g - Y0_i_g\n            d_kp1[idx_growth] = num / denom\n        \n        # Enforce constraints\n        d_kp1 = np.maximum(d_n, np.minimum(d_kp1, 1.0))\n        \n        # 3. Check for convergence\n        if np.linalg.norm(d_kp1 - d_k) < tol * (np.linalg.norm(d_k) + tol):\n            break\n        \n        d_k = d_kp1\n\n    u_np1 = solve_displacements(d_k, u_prescribed, N, h, params['A'], E)\n    return u_np1, d_k\n\n\ndef calculate_metrics(F_history):\n    \"\"\"\n    Calculates the peak force and oscillation excess.\n    \"\"\"\n    if len(F_history) < 2:\n        return 0.0, 0.0\n\n    F_max = np.max(F_history)\n    F0 = F_history[0]\n    F_Nt = F_history[-1]\n    \n    sum_abs_diff = np.sum(np.abs(np.diff(F_history)))\n    \n    monotone_path_length = (F_max - F0) + (F_max - F_Nt)\n    \n    gamma = sum_abs_diff - monotone_path_length\n    \n    return gamma, F_max\n\nsolve()\n```", "id": "2545077"}]}