{"hands_on_practices": [{"introduction": "Understanding the mathematical origins of bifurcation is the first step toward mastering its detection. This exercise provides a foundational look at how instability points arise directly from a system's potential energy [@problem_id:2542980]. By analyzing a simple two-degree-of-freedom model, you will practice deriving the equilibrium equations (the residual) and the tangent stiffness matrix, and ultimately identify the critical load values where the system's trivial equilibrium path loses stability.", "problem": "Consider a non-dimensional two-degree-of-freedom Finite Element (FE) discretization with nodal displacement vector $u = \\begin{pmatrix} u_{1}  u_{2} \\end{pmatrix}^{\\mathsf{T}}$ and a scalar load parameter $\\lambda$. Let the system be defined by a total potential energy\n$$\n\\Pi(u,\\lambda) \\;=\\; \\frac{1}{2}\\,k\\,(u_{1}^{2}+u_{2}^{2}) \\;+\\; \\frac{c}{2}\\,(u_{1}-u_{2})^{2} \\;+\\; \\frac{\\gamma}{4}\\,(u_{1}^{4}+u_{2}^{4}) \\;-\\; \\frac{\\lambda}{2}\\,g\\,(u_{1}^{2}+u_{2}^{2}),\n$$\nwhere $k0$, $c0$, $g0$, and $\\gamma \\ge 0$ are constants. This energy models a symmetric pair of nonlinear springs with linear coupling and a load-dependent geometric softening term.\n\nUsing the stationarity of the total potential energy for equilibrium, construct the FE residual vector $R(u,\\lambda)$ as the gradient of $\\Pi(u,\\lambda)$ with respect to $u$, and compute the consistent tangent stiffness matrix $K_{T}(u,\\lambda)$ as the Jacobian $\\partial R/\\partial u$. Then specialize $K_{T}(u,\\lambda)$ to the trivial equilibrium branch $u=\\begin{pmatrix} 0  0 \\end{pmatrix}^{\\mathsf{T}}$, and determine all parameter values $\\lambda$ for which $\\det K_{T}(0,\\lambda)=0$.\n\nAnswer specification:\n- Provide the final answer as the set of the two critical parameter values $\\lambda$ in a single row matrix.\n- No numerical rounding is required; present the exact expressions.\n- All quantities are non-dimensional, so no units are required.", "solution": "The problem is validated as scientifically grounded, well-posed, objective, and complete. It is a standard exercise in nonlinear finite element analysis concerning the detection of bifurcation points. We proceed with the solution.\n\nThe total potential energy of the system is given by:\n$$\n\\Pi(u,\\lambda) = \\frac{1}{2} k (u_{1}^{2}+u_{2}^{2}) + \\frac{c}{2} (u_{1}-u_{2})^{2} + \\frac{\\gamma}{4} (u_{1}^{4}+u_{2}^{4}) - \\frac{\\lambda}{2} g (u_{1}^{2}+u_{2}^{2})\n$$\nwhere $u = \\begin{pmatrix} u_{1}  u_{2} \\end{pmatrix}^{\\mathsf{T}}$ is the nodal displacement vector, $\\lambda$ is the load parameter, and $k, c, g, \\gamma$ are constants with $k0$, $c0$, $g0$, and $\\gamma \\ge 0$.\n\nThe condition for equilibrium is the stationarity of the potential energy, $\\delta \\Pi = 0$. This requires that the gradient of $\\Pi$ with respect to the displacement vector $u$ is zero. This gradient is the residual vector $R(u, \\lambda)$.\n$$\nR(u, \\lambda) = \\nabla_{u} \\Pi(u, \\lambda) = \\begin{pmatrix} \\frac{\\partial \\Pi}{\\partial u_{1}} \\\\ \\frac{\\partial \\Pi}{\\partial u_{2}} \\end{pmatrix}\n$$\nWe compute the partial derivatives:\n$$\n\\frac{\\partial \\Pi}{\\partial u_{1}} = k u_{1} + c(u_{1}-u_{2}) + \\gamma u_{1}^{3} - \\lambda g u_{1} = (k+c-\\lambda g)u_{1} - c u_{2} + \\gamma u_{1}^{3}\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial u_{2}} = k u_{2} + c(u_{1}-u_{2})(-1) + \\gamma u_{2}^{3} - \\lambda g u_{2} = -c u_{1} + (k+c-\\lambda g)u_{2} + \\gamma u_{2}^{3}\n$$\nThus, the residual vector is:\n$$\nR(u, \\lambda) = \\begin{pmatrix} (k+c-\\lambda g)u_{1} - c u_{2} + \\gamma u_{1}^{3} \\\\ -c u_{1} + (k+c-\\lambda g)u_{2} + \\gamma u_{2}^{3} \\end{pmatrix}\n$$\nNext, we compute the consistent tangent stiffness matrix $K_{T}(u, \\lambda)$, which is the Jacobian of the residual vector $R$ with respect to the displacement vector $u$.\n$$\nK_{T}(u, \\lambda) = \\frac{\\partial R}{\\partial u} = \\begin{pmatrix} \\frac{\\partial R_{1}}{\\partial u_{1}}  \\frac{\\partial R_{1}}{\\partial u_{2}} \\\\ \\frac{\\partial R_{2}}{\\partial u_{1}}  \\frac{\\partial R_{2}}{\\partial u_{2}} \\end{pmatrix}\n$$\nThe components of the tangent stiffness matrix are:\n$$\n\\frac{\\partial R_{1}}{\\partial u_{1}} = k+c-\\lambda g + 3\\gamma u_{1}^{2}\n$$\n$$\n\\frac{\\partial R_{1}}{\\partial u_{2}} = -c\n$$\n$$\n\\frac{\\partial R_{2}}{\\partial u_{1}} = -c\n$$\n$$\n\\frac{\\partial R_{2}}{\\partial u_{2}} = k+c-\\lambda g + 3\\gamma u_{2}^{2}\n$$\nThis gives the tangent stiffness matrix:\n$$\nK_{T}(u, \\lambda) = \\begin{pmatrix} k+c-\\lambda g + 3\\gamma u_{1}^{2}  -c \\\\ -c  k+c-\\lambda g + 3\\gamma u_{2}^{2} \\end{pmatrix}\n$$\nThe problem requires us to analyze the stability on the trivial equilibrium branch, which is defined by $u = \\begin{pmatrix} 0  0 \\end{pmatrix}^{\\mathsf{T}}$. We check that this is indeed an equilibrium path by substituting $u_{1}=0$ and $u_{2}=0$ into the residual vector: $R(0, \\lambda) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$, which holds for any $\\lambda$.\n\nWe now specialize the tangent stiffness matrix $K_{T}$ to this trivial path by setting $u_{1}=0$ and $u_{2}=0$:\n$$\nK_{T}(0, \\lambda) = \\begin{pmatrix} k+c-\\lambda g  -c \\\\ -c  k+c-\\lambda g \\end{pmatrix}\n$$\nBifurcation points (critical points) on the trivial path occur when the tangent stiffness matrix becomes singular. This condition is mathematically expressed as $\\det K_{T}(0, \\lambda)=0$.\nWe compute the determinant:\n$$\n\\det K_{T}(0, \\lambda) = (k+c-\\lambda g)(k+c-\\lambda g) - (-c)(-c) = (k+c-\\lambda g)^{2} - c^{2}\n$$\nSetting the determinant to zero yields the equation for the critical values of $\\lambda$:\n$$\n(k+c-\\lambda g)^{2} - c^{2} = 0\n$$\nThis is a difference of squares, which factors as:\n$$\n\\left[ (k+c-\\lambda g) - c \\right] \\left[ (k+c-\\lambda g) + c \\right] = 0\n$$\nThis equation is satisfied if either factor is zero.\n\nCase 1:\n$$\n(k+c-\\lambda g) - c = 0 \\implies k - \\lambda g = 0 \\implies \\lambda g = k\n$$\nThis gives the first critical value:\n$$\n\\lambda_{1} = \\frac{k}{g}\n$$\nCase 2:\n$$\n(k+c-\\lambda g) + c = 0 \\implies k+2c - \\lambda g = 0 \\implies \\lambda g = k+2c\n$$\nThis gives the second critical value:\n$$\n\\lambda_{2} = \\frac{k+2c}{g}\n$$\nSince the problem states $k0$, $c0$, and $g0$, both critical values $\\lambda_{1}$ and $\\lambda_{2}$ are positive and distinct. These are the parameter values for which the trivial equilibrium path loses stability.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{k}{g}  \\frac{k+2c}{g} \\end{pmatrix}}\n$$", "id": "2542980"}, {"introduction": "Bridging the gap from abstract concepts to practical finite element (FE) formulation is a crucial skill. This practice challenges you to derive the buckling load for a classic structure—the Euler-Bernoulli beam—using a single finite element from first principles [@problem_id:2543000]. You will construct the elastic and geometric stiffness matrices using Hermite shape functions and solve the resulting eigenvalue problem, providing a concrete understanding of how continuous mechanics is translated into a discrete computational model.", "problem": "A uniform, prismatic Euler–Bernoulli beam of length $L$ and flexural rigidity $EI$ is axially compressed by a constant end force $N$ applied in the centroidal axis. Small strains and small rotations are assumed, and shear deformation is neglected. The beam is simply supported at both ends, modeled as $w(0)=0$, $w(L)=0$, with free end rotations. Consider the detection of buckling as a bifurcation of equilibrium, characterized by loss of positive definiteness of the second variation of the total potential energy, equivalently by the vanishing of the smallest eigenvalue of the tangent stiffness.\n\nUsing the Finite Element Method (FEM) with a single two-node Euler–Bernoulli beam element with Hermite cubic interpolation of the transverse displacement $w(x)$ and nodal degrees of freedom (DOFs) $w_{1}$, $\\theta_{1}$ at $x=0$ and $w_{2}$, $\\theta_{2}$ at $x=L$, proceed as follows from first principles:\n- Starting from the principle of virtual work and the linearization of the geometric nonlinearity induced by $N$, derive the consistent element bending stiffness and geometric (initial stress) stiffness in terms of the Hermite shape functions.\n- Assemble the element tangent stiffness, impose the simply supported boundary conditions by constraining $w_{1}=0$ and $w_{2}=0$ while leaving $\\theta_{1}$ and $\\theta_{2}$ free, and write the resulting reduced generalized eigenvalue problem for the rotational DOFs.\n- Solve this reduced problem to obtain the lowest critical load $N_{\\mathrm{cr}}^{\\mathrm{FE}}$ that predicts bifurcation.\n\nLet the analytical Euler buckling load for a simply supported beam be $N_{\\mathrm{cr}}^{\\mathrm{exact}}=\\pi^{2} EI / L^{2}$. As your final answer, report the single dimensionless ratio\n$$\nr \\;=\\; \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}}.\n$$\nExpress your final result as an exact closed-form analytic expression. Do not round or approximate.", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It presents a standard problem in computational structural mechanics, specifically the finite element analysis of elastic buckling. All required data and conditions are provided, and there are no contradictions or fallacies. The problem is valid. We proceed with the solution from first principles as requested.\n\nThe buckling analysis stems from the second variation of the total potential energy. For a compressive force of magnitude $N$, the tangent stiffness matrix is $\\mathbf{K}_T = \\mathbf{K}_E - N\\mathbf{K}_{G0}$, where $\\mathbf{K}_E$ is the elastic stiffness matrix and $\\mathbf{K}_{G0}$ is the geometric stiffness matrix for a unit compressive force. Buckling occurs when $\\mathbf{K}_T$ becomes singular, leading to the generalized eigenvalue problem: $\\mathbf{K}_E \\mathbf{d} = N_{\\mathrm{cr}} \\mathbf{K}_{G0} \\mathbf{d}$, where $N_{\\mathrm{cr}}$ is the critical buckling load.\n\nA single two-node beam element of length $L$ is used. The transverse displacement field $w(x)$ is interpolated using Hermite cubic shape functions. The nodal degrees of freedom (DOFs) are $\\mathbf{d} = [w_1, \\theta_1, w_2, \\theta_2]^T$, where $w_1 = w(0)$, $\\theta_1 = w'(0)$, $w_2 = w(L)$, and $\\theta_2 = w'(L)$. The displacement is given by $w(x) = \\mathbf{N}(x) \\mathbf{d}$, where $\\mathbf{N}(x) = [H_1(x), H_2(x), H_3(x), H_4(x)]$ is the vector of shape functions. In terms of the non-dimensional coordinate $\\xi = x/L$, these are:\n$$ H_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 $$\n$$ H_2(\\xi) = L(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ H_3(\\xi) = 3\\xi^2 - 2\\xi^3 $$\n$$ H_4(\\xi) = L(-\\xi^2 + \\xi^3) $$\n\nThe components of the elastic stiffness matrix $\\mathbf{K}_E$ are derived from the bending strain energy:\n$$ K_{E,ij} = EI \\int_0^L H_i''(x) H_j''(x) dx = EI \\int_0^1 H_i''(\\xi L) H_j''(\\xi L) L d\\xi $$\nEvaluation of these standard integrals over the element domain $[0, L]$ yields the matrix:\n$$ \\mathbf{K}_E = \\frac{EI}{L^3} \\begin{pmatrix} 12  6L  -12  6L \\\\ 6L  4L^2  -6L  2L^2 \\\\ -12  -6L  12  -6L \\\\ 6L  2L^2  -6L  4L^2 \\end{pmatrix} $$\n\nThe components of the geometric stiffness matrix for a unit force, $\\mathbf{K}_{G0}$, are derived from the work done by the axial force due to member rotation:\n$$ K_{G0,ij} = \\int_0^L H_i'(x) H_j'(x) dx $$\nEvaluation of these integrals yields:\n$$ \\mathbf{K}_{G0} = \\frac{1}{30L} \\begin{pmatrix} 36  3L  -36  3L \\\\ 3L  4L^2  -3L  -L^2 \\\\ -36  -3L  36  -3L \\\\ 3L  -L^2  -3L  4L^2 \\end{pmatrix} $$\nThe full geometric stiffness matrix is $\\mathbf{K}_G = N \\mathbf{K}_{G0}$.\n\nThe problem specifies simply supported boundary conditions, which are $w(0)=w_1=0$ and $w(L)=w_2=0$. These constraints eliminate the first and third DOFs. The eigenvalue problem is reduced to the subspace of the free rotational DOFs, $\\theta_1$ and $\\theta_2$. We extract the submatrices corresponding to the second and fourth rows and columns of $\\mathbf{K}_E$ and $\\mathbf{K}_{G0}$.\nThe reduced elastic stiffness matrix $\\mathbf{K}_{E, red}$ is:\n$$ \\mathbf{K}_{E, red} = \\frac{EI}{L^3} \\begin{pmatrix} 4L^2  2L^2 \\\\ 2L^2  4L^2 \\end{pmatrix} = \\frac{EI}{L} \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} $$\nThe reduced geometric stiffness matrix $\\mathbf{K}_{G0, red}$ is:\n$$ \\mathbf{K}_{G0, red} = \\frac{1}{30L} \\begin{pmatrix} 4L^2  -L^2 \\\\ -L^2  4L^2 \\end{pmatrix} = \\frac{L}{30} \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} $$\n\nThe reduced eigenvalue problem for the critical load $N = N_{\\mathrm{cr}}^{\\mathrm{FE}}$ is:\n$$ (\\mathbf{K}_{E, red} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\mathbf{K}_{G0, red}) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\nFor a non-trivial solution, the determinant of the matrix must be zero. Let us define a dimensionless eigenvalue $\\lambda = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{30EI}$. The characteristic equation becomes:\n$$ \\det \\left( \\frac{EI}{L} \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\frac{L}{30} \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det \\left( \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} - \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{EI} \\frac{1}{30} \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} \\right) = 0 $$\nLet $\\tilde{\\lambda} = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{EI}$. The equation is $\\det \\left( \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} - \\frac{\\tilde{\\lambda}}{30} \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} \\right) = 0$.\nThe determinant calculation is equivalent to what was in the original solution if we set $\\lambda = \\tilde{\\lambda}/30$:\n$$ \\det \\begin{pmatrix} 4 - 4\\lambda  2 + \\lambda \\\\ 2 + \\lambda  4 - 4\\lambda \\end{pmatrix} = 0 $$\n$$ (4 - 4\\lambda)^2 - (2 + \\lambda)^2 = 0 $$\nThis equation can be factored as a difference of squares:\n$$ [4(1-\\lambda) - (2+\\lambda)] [4(1-\\lambda) + (2+\\lambda)] = 0 $$\nThis leads to two possible solutions for $\\lambda$:\n$1$. $4 - 4\\lambda - 2 - \\lambda = 0 \\implies 2 - 5\\lambda = 0 \\implies \\lambda_1 = \\frac{2}{5}$\n$2$. $4 - 4\\lambda + 2 + \\lambda = 0 \\implies 6 - 3\\lambda = 0 \\implies \\lambda_2 = 2$\n\nThe lowest critical load corresponds to the smallest eigenvalue $\\lambda_1$.\n$$ N_{\\mathrm{cr}}^{\\mathrm{FE}} = \\frac{30EI}{L^2} \\lambda_1 = \\frac{30EI}{L^2} \\left(\\frac{2}{5}\\right) = \\frac{12EI}{L^2} $$\nThe analytical Euler buckling load for a simply supported beam is given as $N_{\\mathrm{cr}}^{\\mathrm{exact}} = \\frac{\\pi^2 EI}{L^2}$.\n\nThe required ratio $r$ is:\n$$ r = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}} = \\frac{12EI/L^2}{\\pi^2EI/L^2} = \\frac{12}{\\pi^2} $$\nThis result indicates that the single finite element model, due to its polynomial shape functions, is overly stiff and overestimates the true buckling load. The error is approximately $21.6\\%$. More elements would be required for convergence to the exact solution.", "answer": "$$\n\\boxed{\\frac{12}{\\pi^2}}\n$$", "id": "2543000"}, {"introduction": "This practice moves from single-element analysis to a complete computational implementation for a multi-element structure. You will write a program to analyze the buckling behavior of a symmetric circular arch, a structure known for its rich and complex stability phenomena [@problem_id:2542913]. The exercise involves assembling global system matrices, applying boundary conditions, solving a generalized eigenvalue problem, and, most notably, classifying the resulting buckling modes using principles from symmetry group theory, a powerful technique in advanced structural analysis.", "problem": "You are given a symmetric planar circular arch modeled using the Euler–Bernoulli frame finite element method. Your task is to implement a complete, runnable program that assembles the elastic stiffness matrix and the initial-stress geometric stiffness matrix, computes the two lowest bifurcation (linearized buckling) load factors and their mode shapes for a prescribed compressive axial force pattern, and classifies each mode as symmetric or antisymmetric with respect to the arch’s midspan reflection by projecting onto the group-invariant subspaces.\n\nBegin from the following foundational base:\n\n- The linearized buckling problem arises from the second variation of the total potential energy. In the finite element discretization with nodal displacement vector $\\mathbf{u}$, the stability operator in the presence of a pre-stress state is the sum of the elastic stiffness $\\mathbf{K}$ and the initial-stress geometric stiffness $\\mathbf{K}_\\sigma$. For a compressive load magnitude $P$ (assumed to scale a fixed axial force distribution), the discrete linearized buckling condition is\n$$\n\\left( \\mathbf{K} - P\\,\\mathbf{K}_\\sigma \\right)\\boldsymbol{\\phi} = \\mathbf{0},\n$$\nwhich is equivalent to the generalized eigenvalue problem\n$$\n\\mathbf{K}\\,\\boldsymbol{\\phi} = \\lambda\\,\\mathbf{K}_\\sigma\\,\\boldsymbol{\\phi}, \\quad \\lambda = P.\n$$\n- For a two-dimensional Euler–Bernoulli frame element of length $L$ with Young’s modulus $E$, cross-sectional area $A$, and second moment of area $I$, the local elastic stiffness matrix $\\mathbf{k}_e^{\\text{loc}}$ is assembled from the well-tested expressions\n$$\n\\mathbf{k}_e^{\\text{loc}} =\n\\begin{bmatrix}\n\\frac{EA}{L}  0  0  -\\frac{EA}{L}  0  0 \\\\\n0  \\frac{12EI}{L^3}  \\frac{6EI}{L^2}  0  -\\frac{12EI}{L^3}  \\frac{6EI}{L^2} \\\\\n0  \\frac{6EI}{L^2}  \\frac{4EI}{L}  0  -\\frac{6EI}{L^2}  \\frac{2EI}{L} \\\\\n-\\frac{EA}{L}  0  0  \\frac{EA}{L}  0  0 \\\\\n0  -\\frac{12EI}{L^3}  -\\frac{6EI}{L^2}  0  \\frac{12EI}{L^3}  -\\frac{6EI}{L^2} \\\\\n0  \\frac{6EI}{L^2}  \\frac{2EI}{L}  0  -\\frac{6EI}{L^2}  \\frac{4EI}{L}\n\\end{bmatrix}.\n$$\n- The consistent initial-stress geometric stiffness matrix for an Euler–Bernoulli frame element subjected to a constant compressive axial force $P0$ along the element is\n$$\n\\mathbf{k}_\\sigma^{\\text{loc}}(P) = \\frac{P}{30L}\\begin{bmatrix}\n0  0  0  0  0  0 \\\\\n0  36  3L  0  -36  3L \\\\\n0  3L  4L^2  0  -3L  -L^2 \\\\\n0  0  0  0  0  0 \\\\\n0  -36  -3L  0  36  -3L \\\\\n0  3L  -L^2  0  -3L  4L^2\n\\end{bmatrix}.\n$$\nFor the generalized eigenproblem, use the per-unit compressive force geometric stiffness\n$$\n\\mathbf{k}_\\sigma^{\\text{loc}} := \\mathbf{k}_\\sigma^{\\text{loc}}(P=1),\n$$\nso that the critical load factor is $\\lambda$ in the equation $\\mathbf{K}\\boldsymbol{\\phi} = \\lambda\\,\\mathbf{K}_\\sigma\\boldsymbol{\\phi}$.\n- Transform local element matrices to global coordinates using standard orthonormal direction cosines from the element chord, assemble the global matrices, and impose boundary conditions to model pinned supports: both translations fixed and rotation free at each end node.\n\nSymmetry classification requirement:\n\n- The arch is symmetric with respect to reflection across its midspan vertical axis. Let $\\mathcal{G}$ denote the order-$2$ symmetry group generated by the reflection operator $\\mathbf{R}$. Construct $\\mathbf{R}$ acting on the global nodal displacement vector as follows. For a node with tangential unit vector $\\hat{\\mathbf{t}}$ and normal unit vector $\\hat{\\mathbf{n}}$ (in-plane), define the local displacement components $(u_t,u_n,\\theta)$ by projection of global $(u_x,u_y,\\theta)$ onto $(\\hat{\\mathbf{t}},\\hat{\\mathbf{n}},\\theta)$. Under reflection about the midspan axis, the local components transform as\n$$\n(u_t,u_n,\\theta) \\mapsto (-u_t,\\,u_n,\\,-\\theta),\n$$\nand then are mapped back to global components at the mirrored node. The symmetric and antisymmetric projectors are\n$$\n\\mathbf{P}_{\\text{sym}} = \\tfrac{1}{2}(\\mathbf{I}+\\mathbf{R}), \\quad\n\\mathbf{P}_{\\text{anti}} = \\tfrac{1}{2}(\\mathbf{I}-\\mathbf{R}).\n$$\nGiven a mode vector $\\boldsymbol{\\phi}$, classify it as symmetric if $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 \\ge \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$, otherwise antisymmetric.\n\nGeometry and discretization:\n\n- The arch lies on a circle of radius $R$ with total central angle $\\Phi$, with nodal angles uniformly spaced in the interval $\\alpha \\in [-\\Phi/2,\\Phi/2]$ and coordinates\n$$\nx(\\alpha) = R\\sin(\\alpha), \\quad y(\\alpha) = R\\cos(\\alpha).\n$$\nThe tangent and normal unit vectors at nodal angle $\\alpha$ are\n$$\n\\hat{\\mathbf{t}}(\\alpha) = (\\cos\\alpha,\\,-\\sin\\alpha), \\quad \\hat{\\mathbf{n}}(\\alpha) = (\\sin\\alpha,\\,\\cos\\alpha).\n$$\nUse $n_e$ straight frame elements connecting consecutive nodes.\n\nNumerical procedure and constraints:\n\n- Assemble $\\mathbf{K}$ and $\\mathbf{K}_\\sigma$ from the element contributions in global coordinates.\n- Enforce the pinned boundary conditions by eliminating the end-node translational degrees of freedom $u_x$ and $u_y$ at both ends; end-node rotations remain free.\n- Solve the generalized eigenproblem robustly by converting it to the standard form via $\\mathbf{K}^{-1}\\mathbf{K}_\\sigma$ on the reduced free degrees of freedom. If $\\mu$ is an eigenvalue of $\\mathbf{K}^{-1}\\mathbf{K}_\\sigma$, then the buckling load factor is $\\lambda = 1/\\mu$. Select the two smallest positive $\\lambda$ (equivalently, the two largest positive $\\mu$), and the corresponding eigenvectors.\n\nAngle unit and physical units:\n\n- All angles must be in radians.\n- Use a consistent nondimensional unit system with $E$, $A$, $I$, $R$, and $\\Phi$ as given below. Report load factors $\\lambda$ as pure numbers (nondimensional).\n\nTest suite:\n\n- Use the following three cases. For each, compute the two lowest bifurcation load factors $\\lambda_1 \\le \\lambda_2$ and classify their mode shapes as symmetric ($1$) or antisymmetric ($0$) using the projector criterion above. Each case specifies $(R,\\Phi,E,A,I,n_e)$:\n\n    - Case 1 (happy path): $R=1.0$, $\\Phi=1.6$, $E=1.0$, $A=1.0$, $I=10^{-3}$, $n_e=40$.\n    - Case 2 (bending softer): $R=1.0$, $\\Phi=1.2$, $E=1.0$, $A=1.0$, $I=5\\times 10^{-4}$, $n_e=40$.\n    - Case 3 (larger span): $R=1.0$, $\\Phi=2.0$, $E=1.0$, $A=1.0$, $I=2\\times 10^{-3}$, $n_e=60$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list of the three test-case results, where each test-case result is a list of four entries in the order $[\\lambda_1, s_1, \\lambda_2, s_2]$, with $\\lambda_i$ rounded to six decimal places and $s_i$ equal to $1$ for symmetric or $0$ for antisymmetric. Example formatting: [[0.123456,1,0.234567,0],[...],[...]].", "solution": "The problem requires the determination of the two lowest linearized buckling loads and corresponding mode shapes for a symmetric circular arch, discretized using the finite element method. The modes are to be classified based on their symmetry properties. The validation of the problem statement confirms that it is scientifically sound, well-posed, and contains all necessary information for a unique solution. We proceed with a principled derivation of the solution methodology.\n\nThe discrete form of the linearized buckling equation is given as a generalized eigenvalue problem:\n$$\n\\mathbf{K}\\boldsymbol{\\phi} = \\lambda\\mathbf{K}_\\sigma\\boldsymbol{\\phi}\n$$\nwhere $\\mathbf{K}$ is the elastic stiffness matrix, $\\mathbf{K}_\\sigma$ is the geometric stiffness matrix corresponding to a unit load, $\\lambda$ is the critical buckling load factor, and $\\boldsymbol{\\phi}$ is the corresponding buckling mode shape (eigenvector).\n\n**1. Discretization and Geometry**\n\nThe arch geometry is defined by its radius $R$ and total subtended angle $\\Phi$. The arch centerline is parametrized by angle $\\alpha \\in [-\\Phi/2, \\Phi/2]$ with Cartesian coordinates given by:\n$$\nx(\\alpha) = R\\sin(\\alpha), \\quad y(\\alpha) = R\\cos(\\alpha)\n$$\nThe structure is discretized into $n_e$ straight Euler-Bernoulli frame elements, connecting $n_n = n_e + 1$ nodes. The nodes are uniformly spaced in angle. The angular position of node $i$ (for $i \\in \\{0, 1, \\dots, n_e\\}$) is:\n$$\n\\alpha_i = -\\frac{\\Phi}{2} + i \\frac{\\Phi}{n_e}\n$$\nThe coordinates $(x_i, y_i)$ of each node are computed using the geometric equations above. Each node possesses three degrees of freedom (DOFs) in the plane: two translations ($u_x, u_y$) and one rotation ($\\theta$). The total number of DOFs for the system is $3n_n$.\n\n**2. Element Stiffness Matrices and Coordinate Transformation**\n\nFor each element connecting nodes $i$ and $i+1$, we first compute its properties in a local coordinate system $(x', y')$ where the $x'$-axis aligns with the element's chord.\nThe element length $L$ is the Euclidean distance between its two nodes:\n$$\nL = \\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}\n$$\nThe orientation of the element's local $x'$-axis with respect to the global $x$-axis is given by the angle $\\theta_e$:\n$$\n\\theta_e = \\text{atan2}(y_{i+1}-y_i, x_{i+1}-x_i)\n$$\nThe local elastic stiffness matrix, $\\mathbf{k}_e^{\\text{loc}}$, and the local geometric stiffness matrix, $\\mathbf{k}_\\sigma^{\\text{loc}}$, are provided in the problem statement. They are $6 \\times 6$ matrices corresponding to the DOFs $(u'_1, v'_1, \\theta'_1, u'_2, v'_2, \\theta'_2)$ of the element's two nodes in its local frame.\n\nTo assemble the global system matrices, these local matrices must be transformed into the global coordinate system. This is achieved using a transformation matrix $\\mathbf{T}$, which relates local and global nodal displacements. For a 2D frame element, the matrix $\\mathbf{T}$ that rotates nodal DOFs from the local to the global frame is a $6 \\times 6$ block-diagonal matrix:\n$$\n\\mathbf{T} = \\begin{bmatrix} \\mathbf{\\Lambda}  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{\\Lambda} \\end{bmatrix}, \\quad \\text{where} \\quad \\mathbf{\\Lambda} = \\begin{bmatrix} \\cos\\theta_e  -\\sin\\theta_e  0 \\\\ \\sin\\theta_e  \\cos\\theta_e  0 \\\\ 0  0  1 \\end{bmatrix}\n$$\nThe element stiffness matrices in the global coordinate system, $\\mathbf{k}_e^{\\text{glob}}$ and $\\mathbf{k}_\\sigma^{\\text{glob}}$, are then computed via a congruence transformation:\n$$\n\\mathbf{k}_e^{\\text{glob}} = \\mathbf{T} \\mathbf{k}_e^{\\text{loc}} \\mathbf{T}^T\n$$\n$$\n\\mathbf{k}_\\sigma^{\\text{glob}} = \\mathbf{T} \\mathbf{k}_\\sigma^{\\text{loc}} \\mathbf{T}^T\n$$\n\n**3. Global System Assembly and Boundary Conditions**\n\nThe global stiffness matrices $\\mathbf{K}$ and $\\mathbf{K}_\\sigma$, of size $3n_n \\times 3n_n$, are constructed by summing the contributions from all element global matrices. This is a standard direct stiffness assembly procedure, where entries of $\\mathbf{k}^{\\text{glob}}$ are added to the corresponding locations in the global matrix based on the element's nodal connectivity.\n\nThe arch is supported by pins at both ends (nodes $0$ and $n_e$), which means translational displacements are restrained while rotations are free. The boundary conditions are:\n$$\nu_x=0, u_y=0 \\quad \\text{at node } 0\n$$\n$$\nu_x=0, u_y=0 \\quad \\text{at node } n_e\n$$\nThese conditions are enforced by removing the rows and columns corresponding to these four fixed DOFs from the global matrices, resulting in reduced matrices $\\mathbf{K}_{\\text{free}}$ and $\\mathbf{K}_{\\sigma, \\text{free}}$. The resulting system involves only the free DOFs.\n\n**4. Eigenvalue Problem Solution**\n\nThe problem statement specifies solving the generalized eigenvalue problem by converting it to a standard eigenvalue problem. The buckling equation for the free DOFs is:\n$$\n\\mathbf{K}_{\\text{free}}\\boldsymbol{\\phi}_{\\text{free}} = \\lambda\\mathbf{K}_{\\sigma, \\text{free}}\\boldsymbol{\\phi}_{\\text{free}}\n$$\nSince the structure is properly constrained, $\\mathbf{K}_{\\text{free}}$ is positive definite and thus invertible. We can therefore write:\n$$\n\\mathbf{K}_{\\text{free}}^{-1}\\mathbf{K}_{\\sigma, \\text{free}}\\boldsymbol{\\phi}_{\\text{free}} = \\frac{1}{\\lambda}\\boldsymbol{\\phi}_{\\text{free}}\n$$\nLetting $\\mu = 1/\\lambda$, we solve the standard eigenvalue problem $\\mathbf{A}\\mathbf{x} = \\mu\\mathbf{x}$, where $\\mathbf{A} = \\mathbf{K}_{\\text{free}}^{-1}\\mathbf{K}_{\\sigma, \\text{free}}$ and $\\mathbf{x} = \\boldsymbol{\\phi}_{\\text{free}}$. The eigenvalues $\\mu$ are computed. The critical buckling load factors $\\lambda$ are the reciprocals of these eigenvalues. We seek the two smallest positive values of $\\lambda$, which correspond to the two largest positive values of $\\mu$. The corresponding eigenvectors $\\boldsymbol{\\phi}_{\\text{free}}$ are the mode shapes restricted to the free DOFs. The full mode shape vectors $\\boldsymbol{\\phi}$ are reconstructed by re-inserting zeros at the locations of the fixed DOFs.\n\n**5. Symmetry Classification**\n\nThe arch is symmetric with respect to reflection about the $y$-axis. This symmetry is represented by an operator $\\mathbf{R}$ acting on the global DOF vector $\\boldsymbol{\\phi}$. For a DOF vector partitioned by nodes, $\\boldsymbol{\\phi} = [\\boldsymbol{\\phi}_0^T, \\boldsymbol{\\phi}_1^T, \\dots, \\boldsymbol{\\phi}_{n_e}^T]^T$, the reflection operator maps the DOFs of node $i$ to the transformed DOFs of the reflected node $j=n_e-i$.\n\nThe reflection transformation for global DOFs maps $(u_x, u_y, \\theta)_i$ at node $i$ to $(-u_x, u_y, -\\theta)_j$ at the reflected node $j$. The $3 \\times 3$ sub-block of $\\mathbf{R}$ that maps DOFs from node $i$ to node $j$ is $\\text{diag}(-1, 1, -1)$. The full matrix $\\mathbf{R}$ is a block-permutation matrix composed of these blocks on its anti-diagonal.\n\nWith the operator $\\mathbf{R}$ constructed, we define the symmetric and antisymmetric projection operators:\n$$\n\\mathbf{P}_{\\text{sym}} = \\frac{1}{2}(\\mathbf{I} + \\mathbf{R}), \\quad \\mathbf{P}_{\\text{anti}} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{R})\n$$\nAn arbitrary mode shape $\\boldsymbol{\\phi}$ can be decomposed into its symmetric and antisymmetric components: $\\boldsymbol{\\phi} = \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi} + \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}$. A mode is classified as symmetric if the norm of its symmetric part is greater than or equal to the norm of its antisymmetric part, and antisymmetric otherwise:\n\\begin{itemize}\n    \\item Symmetric ($s=1$): if $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 \\ge \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$\n    \\item Antisymmetric ($s=0$): if $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2  \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$\n\\end{itemize}\nThis procedure is applied to the two computed buckling modes $\\boldsymbol{\\phi}_1$ and $\\boldsymbol{\\phi}_2$ to determine their symmetry classification $s_1$ and $s_2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases specified\n    in the problem statement.\n    \"\"\"\n\n    def analyze_arch(R, Phi, E, A, I, n_e):\n        \"\"\"\n        Performs FEM buckling analysis for a single circular arch case.\n\n        Args:\n            R (float): Arch radius.\n            Phi (float): Total arch angle in radians.\n            E (float): Young's modulus.\n            A (float): Cross-sectional area.\n            I (float): Second moment of area.\n            n_e (int): Number of elements.\n\n        Returns:\n            list: A list containing [lambda_1, s_1, lambda_2, s_2],\n                  where lambda_i are the buckling loads and s_i are the\n                  symmetry classifications (1 for symmetric, 0 for antisymmetric).\n        \"\"\"\n        n_n = n_e + 1\n        dofs_per_node = 3\n        total_dofs = n_n * dofs_per_node\n\n        # 1. Discretization and Nodal Coordinates\n        alphas = np.linspace(-Phi / 2.0, Phi / 2.0, n_n)\n        coords = np.zeros((n_n, 2))\n        coords[:, 0] = R * np.sin(alphas)\n        coords[:, 1] = R * np.cos(alphas)\n\n        # Initialize global stiffness matrices\n        K_global = np.zeros((total_dofs, total_dofs))\n        K_sigma_global = np.zeros((total_dofs, total_dofs))\n\n        # 2. Element-by-Element Assembly\n        for i in range(n_e):\n            node1_idx, node2_idx = i, i + 1\n            node1_coords, node2_coords = coords[node1_idx], coords[node2_idx]\n            \n            dx = node2_coords[0] - node1_coords[0]\n            dy = node2_coords[1] - node1_coords[1]\n            L = math.sqrt(dx**2 + dy**2)\n            \n            # Element orientation\n            angle = math.atan2(dy, dx)\n            c, s = math.cos(angle), math.sin(angle)\n            \n            # Local elastic stiffness matrix\n            ke_loc = np.zeros((6, 6))\n            EA_L = E * A / L\n            EI_L = E * I / L\n            EI_L2 = E * I / L**2\n            EI_L3 = E * I / L**3\n\n            ke_loc[0, 0] = EA_L\n            ke_loc[0, 3] = -EA_L\n            ke_loc[3, 0] = -EA_L\n            ke_loc[3, 3] = EA_L\n\n            ke_loc[1, 1] = 12 * EI_L3\n            ke_loc[1, 2] = 6 * EI_L2\n            ke_loc[1, 4] = -12 * EI_L3\n            ke_loc[1, 5] = 6 * EI_L2\n            ke_loc[2, 1] = 6 * EI_L2\n            ke_loc[2, 2] = 4 * EI_L\n            ke_loc[2, 4] = -6 * EI_L2\n            ke_loc[2, 5] = 2 * EI_L\n            ke_loc[4, 1] = -12 * EI_L3\n            ke_loc[4, 2] = -6 * EI_L2\n            ke_loc[4, 4] = 12 * EI_L3\n            ke_loc[4, 5] = -6 * EI_L2\n            ke_loc[5, 1] = 6 * EI_L2\n            ke_loc[5, 2] = 2 * EI_L\n            ke_loc[5, 4] = -6 * EI_L2\n            ke_loc[5, 5] = 4 * EI_L\n\n            # Local geometric stiffness matrix (for P=1)\n            ksigma_loc = np.zeros((6, 6))\n            _30L = 30 * L\n            ksigma_loc[1, 1] = 36 / _30L\n            ksigma_loc[1, 2] = 3 * L / _30L\n            ksigma_loc[1, 4] = -36 / _30L\n            ksigma_loc[1, 5] = 3 * L / _30L\n            ksigma_loc[2, 1] = 3 * L / _30L\n            ksigma_loc[2, 2] = 4 * L**2 / _30L\n            ksigma_loc[2, 4] = -3 * L / _30L\n            ksigma_loc[2, 5] = -L**2 / _30L\n            ksigma_loc[4, 1] = -36 / _30L\n            ksigma_loc[4, 2] = -3 * L / _30L\n            ksigma_loc[4, 4] = 36 / _30L\n            ksigma_loc[4, 5] = -3 * L / _30L\n            ksigma_loc[5, 1] = 3 * L / _30L\n            ksigma_loc[5, 2] = -L**2 / _30L\n            ksigma_loc[5, 4] = -3 * L / _30L\n            ksigma_loc[5, 5] = 4 * L**2 / _30L\n\n            # Transformation matrix (local to global)\n            Lambda = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n            T = np.zeros((6, 6))\n            T[0:3, 0:3] = Lambda\n            T[3:6, 3:6] = Lambda\n            \n            # Transform and assemble\n            ke_glob = T @ ke_loc @ T.T\n            ksigma_glob = T @ ksigma_loc @ T.T\n            \n            dof_indices = np.array([\n                dofs_per_node * node1_idx, dofs_per_node * node1_idx + 1, dofs_per_node * node1_idx + 2,\n                dofs_per_node * node2_idx, dofs_per_node * node2_idx + 1, dofs_per_node * node2_idx + 2\n            ])\n            \n            K_global[np.ix_(dof_indices, dof_indices)] += ke_glob\n            K_sigma_global[np.ix_(dof_indices, dof_indices)] += ksigma_glob\n\n        # 3. Boundary Conditions\n        fixed_dofs = [0, 1, dofs_per_node * n_e, dofs_per_node * n_e + 1]\n        all_dofs = np.arange(total_dofs)\n        free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n        \n        K_free = K_global[np.ix_(free_dofs, free_dofs)]\n        K_sigma_free = K_sigma_global[np.ix_(free_dofs, free_dofs)]\n        \n        # 4. Eigenvalue Problem\n        # Following problem statement: convert to standard eigenproblem\n        # A more robust method would be scipy.linalg.eigh(K_free, K_sigma_free)\n        try:\n            K_free_inv = np.linalg.inv(K_free)\n        except np.linalg.LinAlgError:\n            return [np.nan, -1, np.nan, -1] # Indicates failure\n            \n        A = K_free_inv @ K_sigma_free\n        \n        mu_vals, eig_vecs_free = np.linalg.eig(A)\n\n        # Filter for positive real eigenvalues mu=1/lambda\n        # and sort to find largest mu (smallest lambda)\n        valid_eigs = []\n        for j, mu in enumerate(mu_vals):\n            if np.isreal(mu) and mu.real > 1e-9: # Filter out non-positive and trivial\n                valid_eigs.append((mu.real, eig_vecs_free[:, j]))\n        \n        # Sort by mu in descending order to get smallest lambda first\n        valid_eigs.sort(key=lambda x: x[0], reverse=True)\n        \n        if len(valid_eigs)  2:\n             return [np.nan, -1, np.nan, -1]\n\n        # 5. Extract results and reconstruct full eigenvectors\n        lambda_vals = [1.0 / eig[0] for eig in valid_eigs[:2]]\n        \n        # Ensure lambda1 = lambda2\n        buckling_results = []\n        if lambda_vals[0] > lambda_vals[1]:\n            lambda_vals = [lambda_vals[1], lambda_vals[0]]\n            eig_vecs_to_process = [valid_eigs[1][1], valid_eigs[0][1]]\n        else:\n            eig_vecs_to_process = [valid_eigs[0][1], valid_eigs[1][1]]\n\n        # 6. Symmetry Classification\n        R_matrix = np.zeros((total_dofs, total_dofs))\n        R_block = np.diag([-1.0, 1.0, -1.0])\n        \n        for i in range(n_n):\n            j = n_e - i # Reflected node index\n            i_start, j_start = i * dofs_per_node, j * dofs_per_node\n            R_matrix[j_start:j_start+3, i_start:i_start+3] = R_block\n\n        I_matrix = np.identity(total_dofs)\n        P_sym = 0.5 * (I_matrix + R_matrix)\n        P_anti = 0.5 * (I_matrix - R_matrix)\n\n        for k in range(2):\n            lambda_val = lambda_vals[k]\n            eig_vec_free = eig_vecs_to_process[k]\n            \n            phi_full = np.zeros(total_dofs, dtype=float)\n            phi_full[free_dofs] = eig_vec_free.real\n            phi_full /= np.linalg.norm(phi_full)\n            \n            phi_sym = P_sym @ phi_full\n            phi_anti = P_anti @ phi_full\n            \n            norm_sym = np.linalg.norm(phi_sym)\n            norm_anti = np.linalg.norm(phi_anti)\n            \n            symmetry_class = 1 if norm_sym >= norm_anti else 0\n            buckling_results.extend([round(lambda_val, 6), symmetry_class])\n\n        return buckling_results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.6, 1.0, 1.0, 1e-3, 40),\n        (1.0, 1.2, 1.0, 1.0, 5e-4, 40),\n        (1.0, 2.0, 1.0, 1.0, 2e-3, 60),\n    ]\n\n    results = []\n    for case in test_cases:\n        R, Phi, E, A, I, n_e = case\n        result = analyze_arch(R, Phi, E, A, I, n_e)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string representation\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2542913"}]}