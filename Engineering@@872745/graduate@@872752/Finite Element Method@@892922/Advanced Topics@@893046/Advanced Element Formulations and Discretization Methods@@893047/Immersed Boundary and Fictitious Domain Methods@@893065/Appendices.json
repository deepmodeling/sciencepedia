{"hands_on_practices": [{"introduction": "The Brinkman penalization method is a powerful technique within fictitious domain frameworks for modeling solid obstacles without body-fitted meshes. It approximates a no-slip boundary condition by adding a penalty term that drives the velocity to zero within the fictitious solid region. This practice [@problem_id:2567670] provides fundamental insight into the method's accuracy by guiding you through an analytical derivation of the velocity profile and drag error in a simplified one-dimensional Stokes flow, revealing how the numerical solution converges to the physical reality as the penalty parameter is adjusted.", "problem": "Consider a two-dimensional, steady, incompressible Stokes flow in a channel occupying the region $0 < y < H$, driven by a constant streamwise body force $g$ (with units of acceleration) acting only in the fluid region. The bottom wall at $y=0$ is represented by a fictitious solid occupying $y<0$ and enforced by Brinkman penalization in a single-domain formulation. Let the velocity be unidirectional, $u = u(y)$ in the streamwise direction, and assume the kinematic viscosity is $\\nu$, the penalization time-scale is $\\eta$, and the mask function is $\\chi(y)$ with $\\chi(y)=0$ for $0<y<H$ and $\\chi(y)=1$ for $y<0$. The steady, one-dimensional momentum equation is\n$$\n\\nu\\,\\frac{d^2 u}{dy^2} + \\big(1-\\chi(y)\\big)\\,g - \\chi(y)\\,\\frac{1}{\\eta}\\,u = 0,\n$$\nwith no-slip at the top wall $u(H)=0$, boundedness as $y\\to -\\infty$, and continuity of $u$ and of the viscous shear $\\nu\\,u'(y)$ at $y=0$.\n\nTasks:\n- Starting from the above governing equation and interface conditions, derive the boundary layer equation in the penalized (solid) region and show that the velocity boundary layer thickness $\\delta$ scales as $\\sqrt{\\nu \\eta}$.\n- Solve the coupled piecewise problem to obtain the force on the fictitious solid computed by the Brinkman method. Define the computed drag per unit span as\n$$\nF_{\\mathrm{pen}} = \\int_{-\\infty}^{0} \\frac{1}{\\eta}\\,u(y)\\,dy,\n$$\nand the exact drag for a true no-slip bottom wall in a Stokes channel as\n$$\nF_{\\mathrm{exact}} = \\frac{g\\,H}{2}.\n$$\nCompute the relative drag error, defined as\n$$\n\\mathcal{E}_{\\mathrm{rel}} = \\frac{F_{\\mathrm{pen}}-F_{\\mathrm{exact}}}{F_{\\mathrm{exact}}}.\n$$\n\nAnswer specification:\n- Provide your final answer as a single closed-form analytical expression for $\\mathcal{E}_{\\mathrm{rel}}$ in terms of $H$, $\\nu$, and $\\eta$ only. Do not include any units in your final answer.", "solution": "The problem presented is a valid, well-posed problem in mathematical physics, specifically in the context of the finite element method and computational fluid dynamics. It is scientifically grounded in the theory of Stokes flow and the Brinkman penalization method. All necessary data, equations, and conditions are provided, and no contradictions are apparent. Therefore, a rigorous solution can be derived.\n\nThe governing equation for the steady, unidirectional velocity profile $u(y)$ is given by\n$$\n\\nu\\,\\frac{d^2 u}{dy^2} + \\big(1-\\chi(y)\\big)\\,g - \\chi(y)\\,\\frac{1}{\\eta}\\,u = 0,\n$$\nwhere the mask function $\\chi(y)$ partitions the domain. We analyze the equation in two separate regions: the fluid region ($0 < y < H$) and the fictitious solid region ($y < 0$).\n\n1.  **Analysis in the Fictitious Solid Region ($y < 0$)**\n\nIn this region, $\\chi(y) = 1$. The governing equation simplifies to a homogeneous second-order ordinary differential equation:\n$$\n\\nu\\,\\frac{d^2 u}{dy^2} - \\frac{1}{\\eta}\\,u = 0\n$$\n$$\n\\frac{d^2 u}{dy^2} - \\frac{1}{\\nu\\eta}\\,u = 0\n$$\nThis is the boundary layer equation for the penalized solid region. We define a characteristic length scale $\\delta = \\sqrt{\\nu\\eta}$. The equation becomes:\n$$\n\\frac{d^2 u}{dy^2} - \\frac{1}{\\delta^2}\\,u = 0\n$$\nThe general solution for $u(y)$ in this region, which we denote $u_s(y)$, is:\n$$\nu_s(y) = C_1 \\exp\\left(\\frac{y}{\\delta}\\right) + C_2 \\exp\\left(-\\frac{y}{\\delta}\\right)\n$$\nThe problem specifies that the velocity must remain bounded as $y \\to -\\infty$. As $y \\to -\\infty$, the term $\\exp(-y/\\delta)$ grows without bound. To satisfy the boundedness condition, its coefficient must be zero, so $C_2 = 0$. The velocity profile in the solid region is thus an exponentially decaying function:\n$$\nu_s(y) = A \\exp\\left(\\frac{y}{\\delta}\\right)\n$$\nwhere $A$ is a constant. This exponential decay defines a velocity boundary layer within the fictitious solid, and its thickness, $\\delta$, scales as $\\sqrt{\\nu\\eta}$. This completes the first task.\n\n2.  **Analysis in the Fluid Region ($0 < y < H$)**\n\nIn this region, $\\chi(y) = 0$. The governing equation simplifies to an inhomogeneous equation:\n$$\n\\nu\\,\\frac{d^2 u}{dy^2} + g = 0\n$$\n$$\n\\frac{d^2 u}{dy^2} = -\\frac{g}{\\nu}\n$$\nIntegrating this equation twice with respect to $y$ gives the general solution for the velocity profile in the fluid region, which we denote $u_f(y)$:\n$$\n\\frac{du_f}{dy} = -\\frac{g}{\\nu}y + B\n$$\n$$\nu_f(y) = -\\frac{g}{2\\nu}y^2 + By + C\n$$\nwhere $B$ and $C$ are constants of integration.\n\n3.  **Application of Boundary and Interface Conditions**\n\nWe have three unknown constants, $A$, $B$, and $C$, which can be determined using the given conditions:\ni.  **Continuity of velocity at $y=0$**: $u_s(0) = u_f(0)$.\n    $$\n    A \\exp(0) = -\\frac{g}{2\\nu}(0)^2 + B(0) + C \\implies A = C\n    $$\nii. **Continuity of viscous shear at $y=0$**: $\\nu \\frac{du_s}{dy}|_{y=0} = \\nu \\frac{du_f}{dy}|_{y=0}$, which simplifies to $\\frac{du_s}{dy}|_{y=0} = \\frac{du_f}{dy}|_{y=0}$.\n    The derivatives are:\n    $$\n    \\frac{du_s}{dy} = \\frac{A}{\\delta}\\exp\\left(\\frac{y}{\\delta}\\right) \\implies \\frac{du_s}{dy}|_{y=0} = \\frac{A}{\\delta}\n    $$\n    $$\n    \\frac{du_f}{dy} = -\\frac{g}{\\nu}y + B \\implies \\frac{du_f}{dy}|_{y=0} = B\n    $$\n    Equating them gives:\n    $$\n    B = \\frac{A}{\\delta}\n    $$\niii. **No-slip condition at the top wall**: $u_f(H) = 0$.\n    $$\n    -\\frac{g}{2\\nu}H^2 + BH + C = 0\n    $$\nNow, we solve this system of three linear equations for $A$, $B$, and $C$. Substitute $C=A$ and $B=A/\\delta$ into the third equation:\n$$\n-\\frac{gH^2}{2\\nu} + \\left(\\frac{A}{\\delta}\\right)H + A = 0\n$$\n$$\nA\\left(\\frac{H}{\\delta} + 1\\right) = \\frac{gH^2}{2\\nu}\n$$\n$$\nA\\left(\\frac{H+\\delta}{\\delta}\\right) = \\frac{gH^2}{2\\nu}\n$$\nSolving for $A$:\n$$\nA = \\frac{gH^2\\delta}{2\\nu(H+\\delta)}\n$$\n\n4.  **Calculation of Penalized Drag**\n\nThe drag per unit span computed by the Brinkman method is defined as:\n$$\nF_{\\mathrm{pen}} = \\int_{-\\infty}^{0} \\frac{1}{\\eta}\\,u(y)\\,dy\n$$\nSubstituting the solution $u_s(y) = A \\exp(y/\\delta)$:\n$$\nF_{\\mathrm{pen}} = \\frac{1}{\\eta} \\int_{-\\infty}^{0} A \\exp\\left(\\frac{y}{\\delta}\\right) dy = \\frac{A}{\\eta} \\left[ \\delta \\exp\\left(\\frac{y}{\\delta}\\right) \\right]_{-\\infty}^{0}\n$$\n$$\nF_{\\mathrm{pen}} = \\frac{A\\delta}{\\eta} \\left( \\exp(0) - \\lim_{y\\to-\\infty}\\exp\\left(\\frac{y}{\\delta}\\right) \\right) = \\frac{A\\delta}{\\eta} (1 - 0) = \\frac{A\\delta}{\\eta}\n$$\nUsing the relationship $\\delta = \\sqrt{\\nu\\eta}$, we have $\\delta^2 = \\nu\\eta$, which implies $\\frac{\\delta}{\\eta} = \\frac{\\nu}{\\delta}$. Therefore:\n$$\nF_{\\mathrm{pen}} = A \\frac{\\nu}{\\delta}\n$$\nNow, substituting the expression for the constant $A$:\n$$\nF_{\\mathrm{pen}} = \\left( \\frac{gH^2\\delta}{2\\nu(H+\\delta)} \\right) \\frac{\\nu}{\\delta} = \\frac{gH^2}{2(H+\\delta)}\n$$\n\n5.  **Calculation of Relative Drag Error**\n\nThe exact drag for a true no-slip wall is given as $F_{\\mathrm{exact}} = \\frac{gH}{2}$. The relative drag error $\\mathcal{E}_{\\mathrm{rel}}$ is defined as:\n$$\n\\mathcal{E}_{\\mathrm{rel}} = \\frac{F_{\\mathrm{pen}}-F_{\\mathrm{exact}}}{F_{\\mathrm{exact}}} = \\frac{F_{\\mathrm{pen}}}{F_{\\mathrm{exact}}} - 1\n$$\nLet's compute the ratio $\\frac{F_{\\mathrm{pen}}}{F_{\\mathrm{exact}}}$:\n$$\n\\frac{F_{\\mathrm{pen}}}{F_{\\mathrm{exact}}} = \\frac{\\frac{gH^2}{2(H+\\delta)}}{\\frac{gH}{2}} = \\frac{gH^2}{2(H+\\delta)} \\cdot \\frac{2}{gH} = \\frac{H}{H+\\delta}\n$$\nNow, substitute this back into the expression for the relative error:\n$$\n\\mathcal{E}_{\\mathrm{rel}} = \\frac{H}{H+\\delta} - 1 = \\frac{H - (H+\\delta)}{H+\\delta} = \\frac{-\\delta}{H+\\delta}\n$$\nFinally, we express the result in terms of the given parameters $H$, $\\nu$, and $\\eta$ by substituting back $\\delta = \\sqrt{\\nu\\eta}$:\n$$\n\\mathcal{E}_{\\mathrm{rel}} = \\frac{-\\sqrt{\\nu\\eta}}{H+\\sqrt{\\nu\\eta}}\n$$\nThis expression represents the relative error in the drag force computed using the Brinkman penalization method compared to the exact analytical solution for a solid wall. The negative sign indicates that the penalized drag is an underestimation of the exact drag. As the penalization parameter $\\eta \\to 0$, the boundary layer thickness $\\delta \\to 0$, and the error $\\mathcal{E}_{\\mathrm{rel}} \\to 0$, which correctly implies that the penalization method converges to the exact solution in the limit of strong penalization.", "answer": "$$\n\\boxed{\\frac{-\\sqrt{\\nu\\eta}}{H+\\sqrt{\\nu\\eta}}}\n$$", "id": "2567670"}, {"introduction": "Verifying the accuracy of a numerical scheme is a critical step in computational science, and analytical solutions provide the most rigorous benchmarks. This exercise [@problem_id:2567789] leverages the classic problem of an oscillating plate in a viscous fluid (Stokes' second problem) to establish a gold standard for testing time-dependent immersed boundary or fictitious domain implementations. By deriving the exact expressions for the velocity amplitude attenuation and phase lag, you will learn how to generate precise target data for validating the dynamic response of your numerical models.", "problem": "You are asked to formalize a reproducible, code-verifiable benchmark for an oscillating rigid plate in a viscous incompressible fluid that serves as a target for Immersed Boundary (IB) and Fictitious Domain (FD) methods within the Finite Element Method (FEM) framework. The goal is to compute the amplitude attenuation and phase lag of the tangential fluid velocity field normal to an oscillating plate, based on the exact solution of the linearized unsteady Stokes problem. This provides reference targets for verification of numerical IB and FD implementations that enforce the plateâ€“fluid kinematic constraint via a distributed Lagrange multiplier or a penalty formulation that approaches a no-slip boundary condition in the stiff limit.\n\nConsider an unbounded half-space fluid domain occupying $\\{ y \\ge 0 \\}$ with a rigid, infinitely extended plate located at $y = 0$. The plate has prescribed tangential velocity $u_{\\text{plate}}(t) = U_0 \\cos(\\omega t)$, where $U_0$ is the amplitude and $\\omega$ is the angular frequency. Assume the following:\n- The fluid is Newtonian, incompressible, and at constant density and viscosity.\n- The motion is planar and parallel to the plate, so the only nonzero velocity component is the tangential component $u(y,t)$, which depends only on $y$ and $t$.\n- The amplitude is sufficiently small so that convective terms are negligible, yielding the linearized unsteady Stokes equation with no background pressure gradient.\n- The physically relevant target for IB/FD enforcement corresponds to the limit in which the constraint recovers a no-slip boundary at the plate.\n\nFrom first principles, start with the linearized momentum balance for the tangential component $u(y,t)$ in the absence of a pressure gradient,\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial y^2},\n$$\nwhere $\\nu$ is the kinematic viscosity. The boundary conditions are\n$$\nu(0,t) = U_0 \\cos(\\omega t), \\quad \\lim_{y \\to \\infty} u(y,t) = 0.\n$$\nDefine the amplitude ratio $A(y)/U_0$ as the ratio of the local harmonic amplitude of $u(y,t)$ to the plate amplitude $U_0$, and define the phase lag $\\phi(y)$ (in radians) as the temporal phase by which the local response at position $y$ lags the plate oscillation $\\cos(\\omega t)$.\n\nYour tasks:\n1. Derive, from the stated governing equation and boundary conditions, the closed-form expressions for the amplitude ratio $A(y)/U_0$ and the phase lag $\\phi(y)$ as functions of $y$, $\\nu$, and $\\omega$. Angles must be expressed in radians.\n2. Implement a program that, for each test case below, computes the pair $[A(y)/U_0,\\;\\phi(y)]$ using your derived expressions, rounds each quantity to six decimal places, and outputs all results on a single line in the specified format. You may assume $U_0 \\ne 0$ and normalize by $U_0$ as defined.\n\nPhysical units and reporting requirements:\n- Distance $y$ in meters.\n- Kinematic viscosity $\\nu$ in $\\text{m}^2/\\text{s}$.\n- Angular frequency $\\omega$ in $\\text{rad}/\\text{s}$.\n- Amplitude ratio $A(y)/U_0$ is dimensionless.\n- Phase lag $\\phi(y)$ must be reported in radians.\n- Round all reported numbers to six decimal places.\n\nTest suite (five cases):\n- Case 1: (0.01, 2.0, 0.05)\n- Case 2: (0.01, 2.0, 0.0)\n- Case 3: (0.01, 2.0, 0.3)\n- Case 4: (0.001, 8.0, 0.02)\n- Case 5: (0.004, 0.5, 0.05)\n\nFinal output format:\n- Your program should produce a single line of output containing a Python-style list of length five, where each entry is a two-element list $[A(y)/U_0,\\;\\phi(y)]$ corresponding to the cases above in the same order. For example:\n\"[ [a1,p1],[a2,p2],[a3,p3],[a4,p4],[a5,p5] ]\"\nDo not print any additional text before or after this list.\n\nYour implementation must be fully self-contained and runnable without user input. Angles must be returned in radians, and all numerical outputs must be rounded to six decimal places as specified. The numerical results produced by your program will be used as the acceptance criterion for correctness.", "solution": "The problem presented is a classical exercise in fluid dynamics, specifically the analysis of Stokes' second problem, which describes the flow induced by an oscillating flat plate. The problem is well-posed, scientifically grounded, and provides all necessary information to derive a unique, analytical solution. Therefore, it is deemed valid. We shall proceed with the derivation.\n\nThe governing equation for the tangential fluid velocity $u(y,t)$ in the domain $y \\ge 0$ is the one-dimensional unsteady Stokes equation, which is mathematically equivalent to the diffusion equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial y^2}\n$$\nHere, $\\nu$ is the kinematic viscosity of the fluid. The motion is driven by the plate at $y=0$, which oscillates tangentially. The boundary conditions are:\n$$\nu(0,t) = U_0 \\cos(\\omega t)\n$$\n$$\n\\lim_{y \\to \\infty} u(y,t) = 0\n$$\nThe second condition indicates that the fluid is at rest far from the plate. We seek a periodic steady-state solution that oscillates with the same angular frequency $\\omega$ as the plate.\n\nTo solve this linear partial differential equation, it is advantageous to employ complex variables. We represent the real velocity $u(y,t)$ as the real part of a complex velocity field $\\tilde{u}(y,t)$. Let $u(y,t) = \\text{Re}[\\tilde{u}(y,t)]$. The boundary condition at the plate can be written as $u(0,t) = \\text{Re}[U_0 e^{i\\omega t}]$, where $i$ is the imaginary unit. We thus pose the problem in terms of $\\tilde{u}(y,t)$ with the complex boundary condition:\n$$\n\\tilde{u}(0,t) = U_0 e^{i\\omega t}\n$$\nWe assume a solution of the form $\\tilde{u}(y,t) = f(y)e^{i\\omega t}$, which separates the spatial and temporal dependencies. Substituting this ansatz into the governing PDE gives:\n$$\n\\frac{\\partial}{\\partial t} \\left( f(y) e^{i\\omega t} \\right) = \\nu \\frac{\\partial^2}{\\partial y^2} \\left( f(y) e^{i\\omega t} \\right)\n$$\n$$\ni\\omega f(y) e^{i\\omega t} = \\nu f''(y) e^{i\\omega t}\n$$\nDividing by the non-zero term $e^{i\\omega t}$ yields a second-order ordinary differential equation for the complex amplitude function $f(y)$:\n$$\nf''(y) - \\frac{i\\omega}{\\nu} f(y) = 0\n$$\nThis is a linear, homogeneous ODE with constant coefficients. The characteristic equation is $\\lambda^2 - i\\omega/\\nu = 0$, which gives $\\lambda^2 = i\\omega/\\nu$. To find the roots $\\lambda$, we must compute the square root of the imaginary unit $i$. In polar form, $i=e^{i\\pi/2}$. Its square roots are $\\pm e^{i\\pi/4} = \\pm(\\cos(\\pi/4) + i\\sin(\\pi/4)) = \\pm\\frac{1+i}{\\sqrt{2}}$.\nThus, the characteristic roots are:\n$$\n\\lambda = \\pm \\sqrt{\\frac{\\omega}{\\nu}} \\sqrt{i} = \\pm \\sqrt{\\frac{\\omega}{\\nu}} \\frac{1+i}{\\sqrt{2}} = \\pm (1+i) \\sqrt{\\frac{\\omega}{2\\nu}}\n$$\nLet us define a characteristic length scale, $\\delta = \\sqrt{2\\nu/\\omega}$, often called the viscous penetration depth or Stokes boundary layer thickness. With this definition, the roots simplify to $\\lambda = \\pm (1+i)/\\delta$.\n\nThe general solution for $f(y)$ is a linear combination of the two exponential solutions:\n$$\nf(y) = C_1 e^{(1+i)y/\\delta} + C_2 e^{-(1+i)y/\\delta}\n$$\nThe constants $C_1$ and $C_2$ are determined by the boundary conditions. The condition at infinity, $\\lim_{y \\to \\infty} u(y,t) = 0$, implies that the complex amplitude must also vanish, $\\lim_{y \\to \\infty} f(y) = 0$. The term $e^{(1+i)y/\\delta} = e^{y/\\delta}e^{iy/\\delta}$ has a magnitude $e^{y/\\delta}$ that grows exponentially with $y$. For the solution to remain bounded and decay to zero, its coefficient $C_1$ must be zero.\nTherefore, the solution form reduces to:\n$$\nf(y) = C_2 e^{-(1+i)y/\\delta}\n$$\nThe remaining constant $C_2$ is found using the boundary condition at the plate, $y=0$. We have $\\tilde{u}(0,t) = f(0)e^{i\\omega t} = U_0 e^{i\\omega t}$, which requires $f(0) = U_0$. Applying this to our solution for $f(y)$:\n$$\nf(0) = C_2 e^0 = C_2 = U_0\n$$\nThus, the specific solution for the complex amplitude is:\n$$\nf(y) = U_0 e^{-(1+i)y/\\delta} = U_0 e^{-y/\\delta} e^{-iy/\\delta}\n$$\nThe complete complex velocity field is then:\n$$\n\\tilde{u}(y,t) = f(y)e^{i\\omega t} = U_0 e^{-y/\\delta} e^{-iy/\\delta} e^{i\\omega t} = U_0 e^{-y/\\delta} e^{i(\\omega t - y/\\delta)}\n$$\nThe physical velocity $u(y,t)$ is the real part of $\\tilde{u}(y,t)$:\n$$\nu(y,t) = \\text{Re}\\left[ U_0 e^{-y/\\delta} \\left(\\cos(\\omega t - y/\\delta) + i\\sin(\\omega t - y/\\delta)\\right) \\right]\n$$\n$$\nu(y,t) = U_0 e^{-y/\\delta} \\cos(\\omega t - y/\\delta)\n$$\nThis solution represents a damped transverse wave propagating from the plate into the fluid.\n\nFrom this final expression, we can directly identify the quantities of interest. The solution is of the form $u(y,t) = A(y) \\cos(\\omega t - \\phi(y))$, where $A(y)$ is the local amplitude and $\\phi(y)$ is the phase lag relative to the plate's motion $\\cos(\\omega t)$.\nBy comparison, we find:\n$1$. The local amplitude is $A(y) = U_0 e^{-y/\\delta}$. The required amplitude ratio is:\n$$\n\\frac{A(y)}{U_0} = e^{-y/\\delta}\n$$\n$2$. The phase lag is $\\phi(y) = y/\\delta$.\n\nSubstituting the definition of $\\delta = \\sqrt{2\\nu/\\omega}$ into these expressions gives the final formulae as functions of the given physical parameters:\nThe amplitude ratio is:\n$$\n\\frac{A(y)}{U_0} = \\exp\\left(-y \\sqrt{\\frac{\\omega}{2\\nu}}\\right)\n$$\nThe phase lag in radians is:\n$$\n\\phi(y) = y \\sqrt{\\frac{\\omega}{2\\nu}}\n$$\nThese are the closed-form expressions required to compute the benchmark values. Note that for $y>0$, the amplitude is attenuated and the phase positively lagged, consistent with physical intuition. For the case $y=0$, the formulae correctly yield an amplitude ratio of $1$ and a phase lag of $0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the amplitude attenuation and phase lag for an oscillating plate\n    in a viscous fluid (Stokes' second problem).\n    \"\"\"\n    # Test cases: tuples of (kinematic_viscosity, angular_frequency, distance_y)\n    # Units: nu (m^2/s), omega (rad/s), y (m)\n    test_cases = [\n        (0.01, 2.0, 0.05),\n        (0.01, 2.0, 0.0),\n        (0.01, 2.0, 0.3),\n        (0.001, 8.0, 0.02),\n        (0.004, 0.5, 0.05),\n    ]\n\n    # A list to store the formatted results for each case.\n    formatted_results = []\n\n    for case in test_cases:\n        nu, omega, y = case\n\n        # The core term y * sqrt(omega / (2 * nu)) appears in both amplitude\n        # and phase calculations.\n        # Handle the case where nu is zero to avoid division errors, although not\n        # present in the test suite.\n        if nu <= 0:\n            # Physically, zero viscosity means no momentum transfer, so amplitude\n            # is zero for y > 0.\n            # However, the problem formulation implies nu > 0.\n            # In the limit nu->0, the exponent goes to infinity for y>0.\n            # Amp ratio would be 0, phase lag infinite.\n            # At y=0, the results are 1 and 0.\n            if y == 0:\n                amplitude_ratio = 1.0\n                phase_lag = 0.0\n            else:\n                # This case is physically ill-defined in the context of this problem\n                # but we handle it for robustness.\n                amplitude_ratio = 0.0\n                phase_lag = float('inf')\n        else:\n            alpha = y * np.sqrt(omega / (2 * nu))\n            amplitude_ratio = np.exp(-alpha)\n            phase_lag = alpha\n\n        # Format each number to six decimal places, ensuring trailing zeros.\n        amp_str = f\"{amplitude_ratio:.6f}\"\n        lag_str = f\"{phase_lag:.6f}\"\n\n        # Create the string representation for the pair [amplitude, phase].\n        formatted_results.append(f\"[{amp_str},{lag_str}]\")\n\n    # Combine all formatted pairs into the final output string.\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2567789"}, {"introduction": "Moving from analytical studies to practical applications, this problem tackles the simulation of flow past a cylinder using a Distributed Lagrange Multiplier (DLM) fictitious domain method. This approach enforces the no-slip condition exactly in a weak sense, and the Lagrange multiplier itself gains the physical meaning of the traction force at the fluid-structure interface. This comprehensive practice [@problem_id:2567766] will guide you through deriving the governing weak formulation and designing a cut-element quadrature scheme to compute the hydrodynamic forces, integrating advanced theoretical concepts with essential numerical techniques.", "problem": "Design a mathematically consistent fictitious domain formulation for steady, incompressible, low-Reynolds-number flow past a stationary circular cylinder embedded in a rectangular domain using the finite element method with an immersed interface. Start from the steady Stokes equations with dynamic viscosity $\\,\\mu\\,$ in a rectangular domain $\\,\\Omega \\subset \\mathbb{R}^2\\,$, with a circular rigid body $\\,B\\subset\\Omega\\,$ of radius $\\,R\\,$ and center $\\,\\boldsymbol{c}=(c_x,c_y)\\,$. The fluid occupies $\\,\\Omega_f=\\Omega\\setminus \\overline{B}\\,$, and the cylinder boundary is $\\,\\Gamma=\\partial B\\,$. The no-slip condition $\\,\\boldsymbol{u}=\\boldsymbol{0}\\,$ holds on $\\,\\Gamma\\,$, and $\\,\\boldsymbol{u}\\,$ satisfies appropriate boundary conditions on $\\,\\partial\\Omega\\,$ (not needed for what follows). Use the following fundamental base:\n\n- The steady Stokes equations in $\\,\\Omega_f\\,$:\n$$\n-\\mu \\nabla^2 \\boldsymbol{u} + \\nabla p = \\boldsymbol{f}, \\quad \\nabla\\cdot \\boldsymbol{u} = 0.\n$$\n\n- The principle of virtual work and the duality pairing of boundary tractions with test functions on $\\,\\Gamma\\,$.\n\nPart A (derivation). Using the Distributed Lagrange Multiplier (DLM) fictitious domain approach, extend the velocity and pressure to the whole $\\,\\Omega\\,$ and introduce a Lagrange multiplier field $\\,\\boldsymbol{\\lambda}\\,$ supported on $\\,\\Gamma\\,$ to enforce $\\,\\boldsymbol{u}=\\boldsymbol{0}\\,$ on $\\,\\Gamma\\,$ in a weak sense. Derive the coupled weak formulation for $\\,(\\boldsymbol{u},p,\\boldsymbol{\\lambda})\\,$ by multiplying the momentum and incompressibility equations by test functions and integrating by parts where appropriate, showing explicitly how the interface term $\\,\\langle \\boldsymbol{\\lambda}, \\boldsymbol{v}\\rangle_{\\Gamma}\\,$ arises from the enforcement of the no-slip constraint on $\\,\\Gamma\\,$. Then, using balance of virtual power and the definition of stress, justify rigorously why the hydrodynamic force on the cylinder is given by the integral of the interface traction, and express the drag and lift in terms of $\\,\\boldsymbol{\\lambda}\\,$. State clearly all assumptions and sign conventions you adopt.\n\nPart B (discretization with cut elements). Consider a uniform background Cartesian mesh of the square domain $\\,\\Omega=[0,1]^2\\,$ into $\\,N\\times N\\,$ square cells of edge size $\\,h=1/N\\,$, and split each square implicitly as needed to support a continuous, piecewise linear velocity space and a piecewise constant pressure space. Represent the interface $\\,\\Gamma\\,$ implicitly via the level-set function\n$$\n\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}-\\boldsymbol{c}\\| - R.\n$$\nFor numerical quadrature on $\\,\\Gamma\\,$, use a cut-element approach: in each cell where $\\,\\phi\\,$ changes sign on the cell boundary, approximate the intersection of $\\,\\Gamma\\,$ with that cell boundary by straight line segments computed via linear interpolation at edges where $\\,\\phi\\,$ changes sign. Using a midpoint rule on each such segment, design a procedure to approximate line integrals over $\\,\\Gamma\\,$. In particular, specify how to compute approximations of drag and lift from a given analytical distribution of $\\,\\boldsymbol{\\lambda}(\\boldsymbol{x})\\,$ along $\\,\\Gamma\\,$, including how to parameterize $\\,\\boldsymbol{\\lambda}\\,$ in terms of the polar angle $\\,\\theta\\,$ defined by $\\,\\boldsymbol{x}=\\boldsymbol{c}+R(\\cos\\theta,\\sin\\theta)\\,$. Angles must be in radians. Assume nondimensional units.\n\nPart C (computable test suite). Implement the cut-element quadrature you designed in Part B to approximate drag and lift for the following four test cases in $\\,\\Omega=[0,1]^2\\,$, all using $\\,N=250\\,$:\n\n- Case $\\,1\\,$ (general constant multiplier): $\\,\\boldsymbol{c}=(0.5,0.5)\\,$, $\\,R=0.3\\,$, and $\\,\\boldsymbol{\\lambda}(\\theta)=(\\alpha,\\beta)\\,$ with $\\,\\alpha=1.2\\,$ and $\\,\\beta=-0.3\\,$.\n\n- Case $\\,2\\,$ (purely radial multiplier): $\\,\\boldsymbol{c}=(0.33,0.65)\\,$, $\\,R=0.22\\,$, and $\\,\\boldsymbol{\\lambda}(\\theta)=A(\\cos\\theta,\\sin\\theta)\\,$ with $\\,A=1.0\\,$.\n\n- Case $\\,3\\,$ (mixed normal/tangential plus constant): $\\,\\boldsymbol{c}=(0.7,0.5)\\,$, $\\,R=0.29\\,$, and\n$$\n\\boldsymbol{\\lambda}(\\theta)=(\\alpha,\\beta)+B(\\cos\\theta,\\sin\\theta)+C(-\\sin\\theta,\\cos\\theta),\n$$\nwith $\\,\\alpha=0.5\\,$, $\\,\\beta=0.0\\,$, $\\,B=0.7\\,$, and $\\,C=-0.4\\,$.\n\n- Case $\\,4\\,$ (small radius constant multiplier): $\\,\\boldsymbol{c}=(0.2,0.2)\\,$, $\\,R=0.05\\,$, and $\\,\\boldsymbol{\\lambda}(\\theta)=(\\alpha,\\beta)\\,$ with $\\,\\alpha=-0.8\\,$ and $\\,\\beta=0.4\\,$.\n\nYour program should compute the drag and lift as two separate floating-point numbers for each case using your cut-segment midpoint quadrature. The final output format must be a single line containing a single list with the results flattened in the order $[\\text{drag}_1,\\text{lift}_1,\\text{drag}_2,\\text{lift}_2,\\text{drag}_3,\\text{lift}_3,\\text{drag}_4,\\text{lift}_4]$. Use radians for all angles. No physical units are required, as the formulation is nondimensional. The output list elements must be floating-point numbers. The code must be fully self-contained and require no user input or external files.", "solution": "The problem is scientifically and mathematically sound, well-posed, and provides a clear, self-contained set of tasks. It is a valid problem in the field of computational fluid dynamics and numerical analysis. We proceed with the solution.\n\nThe solution is presented in two parts as requested: Part A, the theoretical derivation of the weak formulation and force calculation; and Part B, the design of the numerical quadrature scheme.\n\nPart A: Derivation of the Fictitious Domain Formulation and Force Calculation\n\nWe begin with the steady Stokes equations for an incompressible fluid with dynamic viscosity $\\mu$ in the fluid domain $\\Omega_f = \\Omega \\setminus \\overline{B}$:\n$$-\\mu \\nabla^2 \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{in } \\Omega_f$$\n$$\\nabla\\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega_f$$\nsubject to the no-slip boundary condition on the surface $\\Gamma = \\partial B$ of the rigid body:\n$$\\boldsymbol{u} = \\boldsymbol{0} \\quad \\text{on } \\Gamma$$\n\nThe Distributed Lagrange Multiplier (DLM) fictitious domain method extends the problem from the complex domain $\\Omega_f$ to the simpler rectangular domain $\\Omega$. The velocity and pressure fields, $\\boldsymbol{u}$ and $p$, are extended to be defined over the entire domain $\\Omega$. The rigid body constraint $\\boldsymbol{u} = \\boldsymbol{0}$ on the interface $\\Gamma$ is no longer satisfied by construction and must be enforced weakly. This is achieved by introducing a Lagrange multiplier field $\\boldsymbol{\\lambda}$, which is defined only on the interface $\\Gamma$.\n\nTo derive the weak formulation, we introduce appropriate function spaces. Let $V = [H^1(\\Omega)]^2$ be the space for the velocity field $\\boldsymbol{u}$, $Q = L^2_0(\\Omega)$ be the space for the pressure field $p$ (functions with zero mean over $\\Omega$), and $M = [H^{-1/2}(\\Gamma)]^2$ be the space for the Lagrange multiplier $\\boldsymbol{\\lambda}$. The corresponding test function spaces for velocity, pressure, and Lagrange multiplier are denoted by $\\boldsymbol{v} \\in V$, $q \\in Q$, and $\\boldsymbol{\\eta} \\in M$, respectively.\n\nThe weak formulation is derived by multiplying the governing equations by test functions, integrating over the domain $\\Omega$, and applying integration by parts.\nThe momentum equation is multiplied by a test function $\\boldsymbol{v} \\in V$:\n$$\\int_{\\Omega} (-\\mu \\nabla^2 \\boldsymbol{u}) \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x} + \\int_{\\Omega} (\\nabla p) \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x} = \\int_{\\Omega} \\boldsymbol{f} \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x}$$\nApplying integration by parts (Green's first identity) to the Laplacian and divergence terms yields:\n$$\\int_{\\Omega} \\mu \\nabla\\boldsymbol{u} : \\nabla\\boldsymbol{v} \\,d\\boldsymbol{x} - \\int_{\\partial\\Omega} \\mu \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{n}} \\cdot \\boldsymbol{v} \\,ds - \\int_{\\Omega} p (\\nabla \\cdot \\boldsymbol{v}) \\,d\\boldsymbol{x} + \\int_{\\partial\\Omega} p \\boldsymbol{v} \\cdot \\boldsymbol{n} \\,ds = \\int_{\\Omega} \\boldsymbol{f} \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x}$$\nThe boundary integrals on $\\partial\\Omega$ are handled by the boundary conditions on the outer domain, which we are instructed to ignore. The key idea of the fictitious domain method is how the constraint on the internal boundary $\\Gamma$ is handled. The constraint $\\boldsymbol{u}=\\boldsymbol{0}$ on $\\Gamma$ is added to the system via the Lagrange multiplier $\\boldsymbol{\\lambda}$, leading to an additional term in the weak form of the momentum equation.\n\nThe final system of equations for the triplet $(\\boldsymbol{u}, p, \\boldsymbol{\\lambda})$ is a saddle-point problem. Find $(\\boldsymbol{u}, p, \\boldsymbol{\\lambda}) \\in V \\times Q \\times M$ such that for all test functions $(\\boldsymbol{v}, q, \\boldsymbol{\\eta}) \\in V \\times Q \\times M$:\n1.  Weak form of the momentum equation:\n    $$\\int_{\\Omega} \\mu \\nabla\\boldsymbol{u} : \\nabla\\boldsymbol{v} \\,d\\boldsymbol{x} - \\int_{\\Omega} p (\\nabla \\cdot \\boldsymbol{v}) \\,d\\boldsymbol{x} + \\int_{\\Gamma} \\boldsymbol{\\lambda} \\cdot \\boldsymbol{v} \\,ds = \\int_{\\Omega} \\boldsymbol{f} \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x}$$\n2.  Weak form of the incompressibility constraint:\n    $$\\int_{\\Omega} q (\\nabla \\cdot \\boldsymbol{u}) \\,d\\boldsymbol{x} = 0$$\n3.  Weak form of the no-slip constraint on $\\Gamma$:\n    $$\\int_{\\Gamma} \\boldsymbol{\\eta} \\cdot \\boldsymbol{u} \\,ds = 0$$\n\nThe interface term $\\langle \\boldsymbol{\\lambda}, \\boldsymbol{v}\\rangle_{\\Gamma} \\equiv \\int_{\\Gamma} \\boldsymbol{\\lambda} \\cdot \\boldsymbol{v} \\,ds$ arises from the principle of virtual work. In the physical problem on $\\Omega_f$, the virtual power of the contact forces exerted by the solid body on the fluid across $\\Gamma$ would appear as a boundary integral. In the DLM formulation, this physical interaction is replaced by the abstract Lagrange multiplier term. The multiplier $\\boldsymbol{\\lambda}$ can thus be interpreted as the force density exerted by the constraint on the fluid.\n\nTo justify the force calculation, we relate $\\boldsymbol{\\lambda}$ to the hydrodynamic stress tensor $\\boldsymbol{\\sigma} = -p\\boldsymbol{I} + \\mu(\\nabla\\boldsymbol{u} + (\\nabla\\boldsymbol{u})^T)$. The force exerted by the fluid on the body is given by $\\boldsymbol{F} = \\int_{\\Gamma} \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} \\, ds$, where $\\boldsymbol{n}$ is the unit normal vector on $\\Gamma$ pointing outward from the fluid domain $\\Omega_f$ (i.e., into the body $B$).\n\nIf we had derived the weak form on the physical domain $\\Omega_f$, integration by parts of the momentum equation would yield a boundary term over $\\partial\\Omega_f = \\partial\\Omega \\cup \\Gamma$. The integral over $\\Gamma$ would be $\\int_{\\Gamma} \\boldsymbol{v} \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}) \\,ds$. Comparing this with the DLM weak formulation over $\\Omega$, we see that the term $\\int_{\\Gamma} \\boldsymbol{\\lambda} \\cdot \\boldsymbol{v} \\,ds$ plays the role of $-\\int_{\\Gamma} \\boldsymbol{v} \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}) \\,ds$. This identification holds for all admissible test functions $\\boldsymbol{v}$, which implies the strong relationship $\\boldsymbol{\\lambda} = -\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}$ on $\\Gamma$.\n\nTherefore, the hydrodynamic force $\\boldsymbol{F}$ on the body is:\n$$\\boldsymbol{F} = \\int_{\\Gamma} \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} \\,ds = \\int_{\\Gamma} (-\\boldsymbol{\\lambda}) \\,ds = -\\int_{\\Gamma} \\boldsymbol{\\lambda} \\,ds$$\nAssuming a mean flow aligned with the positive x-axis, the drag force $F_D$ is the x-component of $\\boldsymbol{F}$, and the lift force $F_L$ is the y-component. Letting $\\boldsymbol{\\lambda} = (\\lambda_x, \\lambda_y)$, we have:\n$$F_D = -\\int_{\\Gamma} \\lambda_x \\,ds$$\n$$F_L = -\\int_{\\Gamma} \\lambda_y \\,ds$$\nThis is the fundamental result for computing forces from the Lagrange multiplier.\n\nPart B: Cut-Element Quadrature Scheme\n\nWe are tasked with designing a numerical procedure to approximate the force integrals $F_D$ and $F_L$ on a uniform Cartesian mesh of the domain $\\Omega=[0,1]^2$. The mesh consists of $N \\times N$ square cells of side length $h=1/N$. The circular interface $\\Gamma$ is defined implicitly by the level-set function $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}-\\boldsymbol{c}\\| - R = 0$.\n\nThe quadrature scheme proceeds as follows:\n1.  **Grid Generation**: Define a grid of $(N+1) \\times (N+1)$ vertices $\\boldsymbol{x}_{i,j} = (i h, j h)$ for $i,j \\in \\{0, 1, \\dots, N\\}$. These vertices define $N^2$ cells.\n2.  **Level-Set Evaluation**: Evaluate the level-set function $\\phi$ at all grid vertices.\n3.  **Cut-Cell Identification**: Iterate through each cell, indexed by its bottom-left corner $(i,j)$ where $i,j \\in \\{0, \\dots, N-1\\}$. A cell is identified as a \"cut cell\" if the values of $\\phi$ at its four vertices are not all of the same sign. This indicates that the interface $\\Gamma$ crosses the boundary of the cell.\n4.  **Interface Approximation**: For each cut cell, we approximate the curved segment of $\\Gamma$ passing through it with a straight line segment. This segment is determined by finding the intersection points of $\\Gamma$ with the edges of the cell.\n    - An edge is defined by two vertices, say $\\boldsymbol{p}_1$ and $\\boldsymbol{p}_2$. Let the corresponding level-set values be $\\phi_1 = \\phi(\\boldsymbol{p}_1)$ and $\\phi_2 = \\phi(\\boldsymbol{p}_2)$.\n    - If $\\phi_1 \\phi_2 < 0$, the interface intersects this edge. The intersection point $\\boldsymbol{p}_{int}$ is found by linear interpolation of the level-set function, which is equivalent to finding the zero of the linear function that passes through $(\\boldsymbol{p}_1, \\phi_1)$ and $(\\boldsymbol{p}_2, \\phi_2)$. The coordinates of the intersection point are given by:\n      $$\\boldsymbol{p}_{int} = \\frac{|\\phi_2|\\boldsymbol{p}_1 + |\\phi_1|\\boldsymbol{p}_2}{|\\phi_1| + |\\phi_2|}$$\n    - For any given cut cell (that does not contain special topological cases like touching a vertex, which are rare for a smooth boundary), there will be exactly two such intersection points on its boundary. Let us call them $\\boldsymbol{q}_1$ and $\\boldsymbol{q}_2$. The line segment connecting $\\boldsymbol{q}_1$ and $\\boldsymbol{q}_2$ is our linear approximation of $\\Gamma$ within this cell.\n5.  **Midpoint Quadrature**: We approximate the line integral of a function $g(\\boldsymbol{x})$ over $\\Gamma$ by summing contributions from each cut-cell segment. For the segment in cell $k$ defined by endpoints $\\boldsymbol{q}_{1,k}$ and $\\boldsymbol{q}_{2,k}$, we use the midpoint rule.\n    - Calculate the length of the segment: $\\Delta s_k = \\|\\boldsymbol{q}_{2,k} - \\boldsymbol{q}_{1,k}\\|$.\n    - Calculate the midpoint of the segment: $\\boldsymbol{m}_k = (\\boldsymbol{q}_{1,k} + \\boldsymbol{q}_{2,k}) / 2$.\n    - The integral over this segment is approximated as $g(\\boldsymbol{m}_k) \\Delta s_k$.\n6.  **Force Calculation**: To compute drag and lift, we apply this quadrature to the integrands $-\\lambda_x$ and $-\\lambda_y$.\n    - To evaluate $\\boldsymbol{\\lambda}(\\boldsymbol{m}_k)$, which is given as a function of the polar angle $\\theta$, we first compute the angle of the midpoint $\\boldsymbol{m}_k$ with respect to the cylinder center $\\boldsymbol{c}$:\n      $$\\theta_k = \\text{atan2}(m_{k,y} - c_y, m_{k,x} - c_x)$$\n      where $\\boldsymbol{m}_k = (m_{k,x}, m_{k,y})$ and $\\boldsymbol{c} = (c_x, c_y)$.\n    - The Lagrange multiplier vector at the midpoint is then $\\boldsymbol{\\lambda}(\\theta_k) = (\\lambda_x(\\theta_k), \\lambda_y(\\theta_k))$.\n    - The total drag and lift are approximated by summing over all cut cells:\n      $$F_D \\approx \\sum_{k \\in \\text{cut cells}} (-\\lambda_x(\\theta_k)) \\Delta s_k$$\n      $$F_L \\approx \\sum_{k \\in \\text{cut cells}} (-\\lambda_y(\\theta_k)) \\Delta s_k$$\n\nThis procedure provides a complete algorithm for computing the required forces from the analytical expression of the Lagrange multiplier, which will be implemented for the test cases in Part C.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the cut-element quadrature scheme for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General constant multiplier\n        {'id': 1, 'c': np.array([0.5, 0.5]), 'R': 0.3, 'params': {'alpha': 1.2, 'beta': -0.3}},\n        \n        # Case 2: Purely radial multiplier\n        {'id': 2, 'c': np.array([0.33, 0.65]), 'R': 0.22, 'params': {'A': 1.0}},\n        \n        # Case 3: Mixed normal/tangential plus constant\n        {'id': 3, 'c': np.array([0.7, 0.5]), 'R': 0.29, 'params': {'alpha': 0.5, 'beta': 0.0, 'B': 0.7, 'C': -0.4}},\n        \n        # Case 4: Small radius constant multiplier\n        {'id': 4, 'c': np.array([0.2, 0.2]), 'R': 0.05, 'params': {'alpha': -0.8, 'beta': 0.4}},\n    ]\n\n    N = 250\n    h = 1.0 / N\n    results = []\n\n    for case in test_cases:\n        c = case['c']\n        R = case['R']\n        params = case['params']\n        case_id = case['id']\n        \n        # Grid vertices\n        x_coords = np.linspace(0.0, 1.0, N + 1)\n        y_coords = np.linspace(0.0, 1.0, N + 1)\n        \n        # Evaluate level-set function phi on all grid vertices\n        X, Y = np.meshgrid(x_coords, y_coords)\n        phi_values = np.sqrt((X - c[0])**2 + (Y - c[1])**2) - R\n        \n        total_drag = 0.0\n        total_lift = 0.0\n\n        # Iterate over each cell in the grid\n        for j in range(N):\n            for i in range(N):\n                # Get phi values at the four corners of the cell (i, j)\n                # (i,j) -> (x_i, y_j)\n                phi00 = phi_values[j, i]\n                phi10 = phi_values[j, i+1]\n                phi01 = phi_values[j+1, i]\n                phi11 = phi_values[j+1, i+1]\n                \n                #\n                # Vertices of the cell, using (x,y) convention\n                # v00: bottom-left, v10: bottom-right, v01: top-left, v11: top-right\n                #\n                v00 = np.array([x_coords[i], y_coords[j]])\n                v10 = np.array([x_coords[i+1], y_coords[j]])\n                v01 = np.array([x_coords[i], y_coords[j+1]])\n                v11 = np.array([x_coords[i+1], y_coords[j+1]])\n\n                corners_phi = np.array([phi00, phi10, phi11, phi01])\n                \n                # Check if the cell is cut by the interface\n                if np.all(corners_phi >= 0) or np.all(corners_phi < 0):\n                    continue\n\n                intersections = []\n                # Check each of the four edges for intersections\n                \n                # Bottom edge (v00 -> v10)\n                if phi00 * phi10 < 0:\n                    t = phi00 / (phi00 - phi10)\n                    intersect_pt = v00 + t * (v10 - v00)\n                    intersections.append(intersect_pt)\n                \n                # Right edge (v10 -> v11)\n                if phi10 * phi11 < 0:\n                    t = phi10 / (phi10 - phi11)\n                    intersect_pt = v10 + t * (v11 - v10)\n                    intersections.append(intersect_pt)\n\n                # Top edge (v11 -> v01)\n                if phi11 * phi01 < 0:\n                    t = phi11 / (phi11 - phi01)\n                    intersect_pt = v11 + t * (v01 - v11)\n                    intersections.append(intersect_pt)\n                \n                # Left edge (v01 -> v00)\n                if phi01 * phi00 < 0:\n                    t = phi01 / (phi01 - phi00)\n                    intersect_pt = v01 + t * (v00 - v01)\n                    intersections.append(intersect_pt)\n                \n                if len(intersections) == 2:\n                    p1, p2 = intersections[0], intersections[1]\n                    \n                    # Midpoint of the segment\n                    midpoint = (p1 + p2) / 2.0\n                    \n                    # Length of the segment\n                    ds = np.linalg.norm(p2 - p1)\n                    \n                    # Angle of the midpoint relative to the cylinder center\n                    # This angle is used to evaluate the analytical lambda function\n                    relative_pos = midpoint - c\n                    theta = np.arctan2(relative_pos[1], relative_pos[0])\n                    \n                    # Evaluate lambda(theta) based on the test case\n                    lambda_val = np.zeros(2)\n                    if case_id == 1:\n                        lambda_val[0] = params['alpha']\n                        lambda_val[1] = params['beta']\n                    elif case_id == 2:\n                        A = params['A']\n                        lambda_val[0] = A * np.cos(theta)\n                        lambda_val[1] = A * np.sin(theta)\n                    elif case_id == 3:\n                        alpha, beta, B, C = params['alpha'], params['beta'], params['B'], params['C']\n                        cos_t, sin_t = np.cos(theta), np.sin(theta)\n                        # base vector + normal component + tangential component\n                        lambda_val[0] = alpha + B * cos_t - C * sin_t\n                        lambda_val[1] = beta  + B * sin_t + C * cos_t\n                    elif case_id == 4:\n                        lambda_val[0] = params['alpha']\n                        lambda_val[1] = params['beta']\n\n                    # Add contribution to total drag and lift\n                    # Force = -integral(lambda * ds)\n                    total_drag += -lambda_val[0] * ds\n                    total_lift += -lambda_val[1] * ds\n\n        results.extend([total_drag, total_lift])\n        \n    # Format the final output string\n    output_str = \"[\" + \",\".join(f\"{res:.8f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2567766"}]}