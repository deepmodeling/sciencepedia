{"hands_on_practices": [{"introduction": "We begin with a foundational exercise to build intuition for how contact constraints are enforced numerically. By analyzing a simple 1D bar hitting a rigid wall, this problem ([@problem_id:2541954]) illustrates the core concept of the penalty method, which is a key component of the augmented Lagrangian approach. You will see firsthand how increasing the penalty parameter forces the numerical solution to converge to the physically correct, constrained state.", "problem": "Consider a one-dimensional, linearly elastic bar discretized by a single two-node linear finite element in the Finite Element Method (FEM). The bar has axial stiffness $k = \\dfrac{EA}{L}$, where $E$ is Young’s modulus, $A$ is cross-sectional area, and $L$ is length. The left node is prescribed a rightward displacement $u_{1} = U$, and the right node $u_{2}$ may come into unilateral, frictionless contact with a rigid wall located at a distance $g_{0}$ from the bar’s undeformed right end. Adopt the sign convention that the scalar normal gap is $g(u_{2}) = g_{0} - u_{2}$ and the unilateral contact constraint is $g(u_{2}) \\ge 0$.\n\nUsing the principle of minimum total potential energy together with the Augmented Lagrangian Method (ALM) for contact, specialize to the first augmented iteration with initial multiplier $\\lambda^{(0)} = 0$ and a fixed penalty parameter $\\varepsilon > 0$. Under this specialization, the stationary problem at the first augmented step reduces to minimizing the elastic energy plus a quadratic penalty on the violation of the non-penetration constraint. Explicitly derive the scalar stationarity condition for $u_{2}$ and solve it in closed form, distinguishing the no-contact and contact-active cases, to obtain $u_{2}(\\varepsilon)$ and the associated reaction $R(\\varepsilon)$ at the right node.\n\nThen, with the following data,\n- $k = 1000\\,\\mathrm{N/m}$,\n- $U = 0.01\\,\\mathrm{m}$,\n- $g_{0} = 0.006\\,\\mathrm{m}$,\nevaluate the contact reaction $R(\\varepsilon)$ for three penalty values $\\varepsilon \\in \\{100\\,\\mathrm{N/m}, 1000\\,\\mathrm{N/m}, 10000\\,\\mathrm{N/m}\\}$ and also determine the limiting constrained reaction $R^{\\star}$ as $\\varepsilon \\to \\infty$. You may assume that the contact-active branch is the relevant one for these data, but you must justify it from your derived conditions.\n\nReport your final result as a single row matrix containing the four forces, in this order:\n$[R(100\\,\\mathrm{N/m}),\\; R(1000\\,\\mathrm{N/m}),\\; R(10000\\,\\mathrm{N/m}),\\; R^{\\star}]$.\nExpress all forces in newtons. Provide exact values (no rounding).", "solution": "We model the bar as a single axial finite element with nodal displacements $u_{1}$ and $u_{2}$. The internal elastic energy for the element is\n$$\n\\Pi_{\\text{int}}(u_{1},u_{2}) = \\frac{1}{2}\\,k\\,(u_{1} - u_{2})^{2}.\n$$\nThere is no external follower force at the right node; the left node displacement is prescribed as $u_{1} = U$. The unilateral, frictionless contact with a rigid wall at the right end is represented by the normal gap\n$$\ng(u_{2}) = g_{0} - u_{2},\n$$\nwith the constraint $g(u_{2}) \\ge 0$ (non-penetration). The Augmented Lagrangian Method (ALM) uses a Lagrange multiplier $\\lambda$ for the constraint and a penalty parameter $\\varepsilon  0$ to stabilize/improve convergence. At the first augmented step with initial multiplier $\\lambda^{(0)} = 0$, the augmented potential reduces to a penalty regularization of the constraint violation:\n$$\n\\Pi_{\\varepsilon}(u_{2}) \\equiv \\Pi_{\\text{int}}(U,u_{2}) + \\frac{\\varepsilon}{2}\\,\\big\\langle -g(u_{2}) \\big\\rangle_{+}^{2}\n= \\frac{1}{2}\\,k\\,(U - u_{2})^{2} + \\frac{\\varepsilon}{2}\\,\\big\\langle u_{2} - g_{0} \\big\\rangle_{+}^{2},\n$$\nwhere $\\langle x \\rangle_{+} = \\max(x,0)$ is the positive-part function. The minimizer $u_{2}$ satisfies the variational stationarity condition, which we can derive by piecewise differentiation depending on whether the contact is inactive ($u_{2} \\le g_{0}$) or active ($u_{2}  g_{0}$).\n\nCase $1$ (no contact, $u_{2} \\le g_{0}$): Here $\\langle u_{2} - g_{0} \\rangle_{+} = 0$, so\n$$\n\\Pi_{\\varepsilon}(u_{2}) = \\frac{1}{2}\\,k\\,(U - u_{2})^{2}.\n$$\nStationarity $\\dfrac{d\\Pi_{\\varepsilon}}{du_{2}} = 0$ gives\n$$\n-k\\,(U - u_{2}) = 0 \\quad \\Rightarrow \\quad u_{2} = U.\n$$\nThis candidate is admissible in Case $1$ only if $u_{2} \\le g_{0}$, i.e., $U \\le g_{0}$.\n\nCase $2$ (active contact, $u_{2}  g_{0}$): Here $\\langle u_{2} - g_{0} \\rangle_{+} = u_{2} - g_{0}$, and\n$$\n\\Pi_{\\varepsilon}(u_{2}) = \\frac{1}{2}\\,k\\,(U - u_{2})^{2} + \\frac{\\varepsilon}{2}\\,(u_{2} - g_{0})^{2}.\n$$\nStationarity gives\n$$\n-k\\,(U - u_{2}) + \\varepsilon\\,(u_{2} - g_{0}) = 0\n\\quad \\Rightarrow \\quad\n(k + \\varepsilon)\\,u_{2} = k\\,U + \\varepsilon\\,g_{0}\n\\quad \\Rightarrow \\quad\nu_{2}(\\varepsilon) = \\frac{k\\,U + \\varepsilon\\,g_{0}}{k + \\varepsilon}.\n$$\nThis candidate is admissible in Case $2$ if $u_{2}(\\varepsilon)  g_{0}$. Observe that\n$$\nu_{2}(\\varepsilon) - g_{0} = \\frac{k\\,U + \\varepsilon\\,g_{0}}{k + \\varepsilon} - g_{0}\n= \\frac{k\\,(U - g_{0})}{k + \\varepsilon}.\n$$\nTherefore, if $U  g_{0}$ and $\\varepsilon  0$, then $u_{2}(\\varepsilon) - g_{0}  0$, so the contact-active case is self-consistent and unique.\n\nFrom the penalty term, the nodal contact reaction at the right node is\n$$\nR(\\varepsilon) = \\varepsilon\\,\\langle u_{2}(\\varepsilon) - g_{0} \\rangle_{+} = \\varepsilon\\,(u_{2}(\\varepsilon) - g_{0})\n= \\varepsilon\\,\\frac{k\\,(U - g_{0})}{k + \\varepsilon}\n= \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0}).\n$$\nEquivalently, by internal equilibrium, the axial force in the bar is\n$$\nN(\\varepsilon) = k\\,(U - u_{2}(\\varepsilon)) = \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0}),\n$$\nwhich matches $R(\\varepsilon)$, as expected.\n\nThe constrained (exact) contact solution corresponds to enforcing $u_{2} = g_{0}$, giving the limiting reaction as $\\varepsilon \\to \\infty$:\n$$\nR^{\\star} = \\lim_{\\varepsilon \\to \\infty} R(\\varepsilon) = \\lim_{\\varepsilon \\to \\infty} \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0})\n= k\\,(U - g_{0}).\n$$\n\nNow substitute the given data $k = 1000\\,\\mathrm{N/m}$, $U = 0.01\\,\\mathrm{m}$, and $g_{0} = 0.006\\,\\mathrm{m}$. First note that $U - g_{0} = 0.004\\,\\mathrm{m}  0$, so the active-contact branch applies for every $\\varepsilon  0$:\n$$\nR(\\varepsilon) = \\frac{\\varepsilon \\cdot 1000}{1000 + \\varepsilon} \\cdot 0.004.\n$$\nEvaluate at the requested penalty values:\n- For $\\varepsilon = 100\\,\\mathrm{N/m}$,\n$$\nR(100) = \\frac{100 \\cdot 1000}{1000 + 100} \\cdot 0.004\n= \\frac{100000 \\cdot 0.004}{1100}\n= \\frac{400}{1100}\n= \\frac{4}{11}.\n$$\n- For $\\varepsilon = 1000\\,\\mathrm{N/m}$,\n$$\nR(1000) = \\frac{1000 \\cdot 1000}{1000 + 1000} \\cdot 0.004\n= \\frac{1000000}{2000} \\cdot 0.004\n= 500 \\cdot 0.004\n= 2.\n$$\n- For $\\varepsilon = 10000\\,\\mathrm{N/m}$,\n$$\nR(10000) = \\frac{10000 \\cdot 1000}{1000 + 10000} \\cdot 0.004\n= \\frac{10000000 \\cdot 0.004}{11000}\n= \\frac{40000}{11000}\n= \\frac{40}{11}.\n$$\nFinally, the constrained limit is\n$$\nR^{\\star} = 1000 \\cdot 0.004 = 4.\n$$\n\nThus the requested row matrix, in newtons, is\n$$\n\\big[\\, R(100),\\; R(1000),\\; R(10000),\\; R^{\\star} \\,\\big]\n= \\left[\\, \\frac{4}{11},\\; 2,\\; \\frac{40}{11},\\; 4 \\,\\right].\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{4}{11}  2  \\frac{40}{11}  4\\end{pmatrix}}$$", "id": "2541954"}, {"introduction": "While penalty forces can enforce constraints, solving the resulting nonlinear system efficiently requires a robust iterative scheme like the Newton-Raphson method. This practice ([@problem_id:2541817]) moves from the 'what' to the 'how' by having you derive the consistent tangent stiffness of the contact residual. Mastering this linearization is essential for implementing augmented Lagrangian methods within an implicit finite element framework and achieving rapid convergence.", "problem": "Consider a single-node, frictionless, unilateral contact between a deformable body and a rigid obstacle in the Finite Element Method (FEM). Let the kinematic normal gap be the scalar function $g(u) = a\\,u - c$, where $u \\in \\mathbb{R}$ is the nodal normal displacement, $a \\in \\mathbb{R}$ is the constant directional derivative of the gap with respect to $u$ (with $a  0$), and $c \\in \\mathbb{R}$ is a constant offset. The contact is governed by the Kuhn–Tucker conditions for frictionless contact: $g(u) \\ge 0$, $\\lambda \\ge 0$, and $g(u)\\,\\lambda = 0$, where $\\lambda \\in \\mathbb{R}$ is the normal contact Lagrange multiplier.\n\nAn augmented Lagrangian method (ALM) is used with penalty parameter $\\rho  0$ and the algorithmic projection update for the multiplier at Newton iteration $k$ given by\n$$\n\\tilde{\\lambda}(u) \\equiv P\\!\\left(\\lambda^{k} + \\rho\\,g(u)\\right),\n$$\nwhere $P(y) = \\max(0,y)$ is the projection operator onto $[0,\\infty)$. The contribution of the contact to the global residual of the displacement equilibrium equation is modeled by\n$$\nr(u) = a\\,\\tilde{\\lambda}(u).\n$$\nDefine the Heaviside step function $H(y)$ almost everywhere as $H(y)=0$ for $y0$ and $H(y)=1$ for $y0$; its value at $y=0$ may be chosen in $[0,1]$ but is not required here.\n\nStarting solely from the preceding definitions and the complementarity structure, derive the consistent linearization (Newton tangent) $k(u) = \\frac{dr}{du}$, taking into account the derivative of the projection operator $P(\\cdot)$. Introduce the auxiliary variable $y \\equiv \\lambda^{k} + \\rho\\,g(u)$ and express your final result for $k(u)$ in closed form in terms of $a$, $\\rho$, and $H(y)$. Your final answer must be a single analytic expression. No numerical evaluation is required and no units are involved.", "solution": "The objective is to find the consistent linearization of the contact residual, which is its derivative with respect to the displacement variable $u$. This is the tangent stiffness contribution, denoted as $k(u)$.\n$$\nk(u) = \\frac{dr}{du}\n$$\nThe residual $r(u)$ is defined as $r(u) = a\\,\\tilde{\\lambda}(u)$. Since $a$ is a constant, the derivative is:\n$$\nk(u) = a\\,\\frac{d\\tilde{\\lambda}}{du}\n$$\nThe algorithmic multiplier $\\tilde{\\lambda}(u)$ is a composite function defined as $\\tilde{\\lambda}(u) = P(y(u))$, where $P(y) = \\max(0,y)$ and the auxiliary variable $y(u)$ is given by $y(u) = \\lambda^{k} + \\rho\\,g(u)$. We must apply the chain rule for differentiation:\n$$\n\\frac{d\\tilde{\\lambda}}{du} = \\frac{dP}{dy} \\frac{dy}{du}\n$$\nWe shall compute each term separately.\n\nFirst, we find the derivative of the projection operator $P(y) = \\max(0,y)$. This is a non-smooth function. Its derivative is defined almost everywhere:\n- For $y  0$, $P(y) = 0$, so $\\frac{dP}{dy} = 0$.\n- For $y  0$, $P(y) = y$, so $\\frac{dP}{dy} = 1$.\nThis behavior is precisely captured by the Heaviside step function $H(y)$, as defined in the problem. Therefore, we write the derivative of the projection operator as:\n$$\n\\frac{dP}{dy} = H(y)\n$$\nThe non-differentiability at $y=0$ is typical in contact mechanics and is handled by this generalized derivative.\n\nSecond, we find the derivative of the auxiliary variable $y(u)$ with respect to $u$. The function $y(u)$ is given by:\n$$\ny(u) = \\lambda^{k} + \\rho\\,g(u)\n$$\nSubstituting the definition of the gap function, $g(u) = a\\,u - c$:\n$$\ny(u) = \\lambda^{k} + \\rho(a\\,u - c) = \\lambda^{k} + \\rho\\,a\\,u - \\rho\\,c\n$$\nThe quantities $\\lambda^{k}$, $\\rho$, $a$, and $c$ are constant with respect to the differentiation variable $u$ within the current Newton iteration. Thus, the derivative is:\n$$\n\\frac{dy}{du} = \\frac{d}{du} (\\lambda^{k} + \\rho\\,a\\,u - \\rho\\,c) = \\rho\\,a\n$$\nNow, we substitute these two derivatives back into the chain rule expression:\n$$\n\\frac{d\\tilde{\\lambda}}{du} = \\frac{dP}{dy} \\frac{dy}{du} = H(y) \\cdot (\\rho\\,a) = \\rho\\,a\\,H(y)\n$$\nFinally, we substitute this result into the expression for the tangent stiffness $k(u)$:\n$$\nk(u) = a\\,\\frac{d\\tilde{\\lambda}}{du} = a\\,(\\rho\\,a\\,H(y)) = a^2\\,\\rho\\,H(y)\n$$\nThis is the consistent linearization of the contact residual. The result is expressed in the required terms of $a$, $\\rho$, and $H(y)$, where $y \\equiv \\lambda^{k} + \\rho\\,g(u)$.", "answer": "$$\n\\boxed{a^2 \\rho H(y)}\n$$", "id": "2541817"}, {"introduction": "Our final practice integrates the normal contact model with the complexities of friction, a crucial step toward simulating realistic mechanical systems. This exercise ([@problem_id:2541924]) challenges you to implement a complete predictor-corrector update algorithm for a node experiencing frictional contact. You will codify the logic that distinguishes between separation, stick, and slip regimes, a cornerstone of computational contact mechanics.", "problem": "Consider a single two-dimensional node-to-rigid-plane contact element used in the finite element method, with a unit outward normal aligned with the vertical axis. Let the scalar normal gap be denoted by $g_n$, where $g_n \\ge 0$ indicates separation and $g_n  0$ indicates interpenetration that must be corrected by contact forces. Let the tangential relative displacement increment be the vector $\\mathbf{s}_t \\in \\mathbb{R}^2$ lying in the plane tangent to the rigid surface. The contact tractions are represented by Lagrange multipliers: the normal multiplier $\\lambda_n \\ge 0$ (compressive contact pressure) and the tangential multiplier vector $\\boldsymbol{\\lambda}_t \\in \\mathbb{R}^2$. The friction model is Coulomb friction with coefficient $\\mu \\ge 0$. An augmented Lagrangian method uses positive penalty parameters $\\rho_n  0$ and $\\rho_t  0$ for the normal and tangential directions, respectively, to update the Lagrange multipliers.\n\nStarting from the fundamental Signorini conditions for unilateral contact, $g_n \\ge 0$, $\\lambda_n \\ge 0$, and $g_n \\lambda_n = 0$, and the Coulomb friction law defined by the friction cone $\\{\\boldsymbol{\\lambda}_t \\in \\mathbb{R}^2 : \\|\\boldsymbol{\\lambda}_t\\| \\le \\mu \\lambda_n\\}$ and the stick/slip rules, derive a principled augmented Lagrangian update that enforces the contact constraints by projecting the unconstrained multiplier updates onto the admissible sets implied by these laws. Your derivation should begin from the Karush–Kuhn–Tucker conditions and the definition of an augmented Lagrangian for contact, and it should show how to obtain an algorithmic update for $\\lambda_n$ and $\\boldsymbol{\\lambda}_t$ along with a regime classification into separation, stick, or slip, based on the final updated multipliers and the kinematic state.\n\nThen implement a program that, given previous multipliers $\\lambda_n^{\\text{old}}$ and $\\boldsymbol{\\lambda}_t^{\\text{old}}$, current kinematics $(g_n, \\mathbf{s}_t)$, penalty parameters $(\\rho_n, \\rho_t)$, and friction coefficient $\\mu$, computes:\n- the updated normal multiplier $\\lambda_n^{\\text{new}}$,\n- the updated tangential multiplier $\\boldsymbol{\\lambda}_t^{\\text{new}}$,\n- the contact regime code $r \\in \\{0,1,2\\}$ with $r=0$ denoting separation, $r=1$ denoting stick, and $r=2$ denoting slip.\n\nExpress all quantities as dimensionless real numbers; no physical units are required for this problem. Angles are not involved. The algorithm must be robust to the edge case where the trial tangential state lies exactly on the friction cone.\n\nUse the following test suite (each case provides $(g_n, \\mathbf{s}_t, \\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}}, \\rho_n, \\rho_t, \\mu)$):\n- Case A (stick): $g_n = -10^{-5}$, $\\mathbf{s}_t = [10^{-7}, 2 \\cdot 10^{-7}]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n- Case B (slip): $g_n = -5 \\cdot 10^{-6}$, $\\mathbf{s}_t = [2 \\cdot 10^{-2}, 0]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n- Case C (separation): $g_n = 10^{-3}$, $\\mathbf{s}_t = [10^{-3}, -10^{-3}]$, $\\lambda_n^{\\text{old}} = 10^{3}$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [1, -1]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n- Case D (on-cone boundary, treat as stick): $g_n = -10^{-6}$, $\\mathbf{s}_t = [6 \\cdot 10^{-7}, 0]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$.\n\nYour program should process the cases in the order A, B, C, D and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case’s result is itself a list of four numbers $[\\lambda_n^{\\text{new}}, \\lambda_{t,x}^{\\text{new}}, \\lambda_{t,y}^{\\text{new}}, r]$. For example, the final output must look like $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ with no additional text. All numbers must be printed in standard decimal form. The contact regime code must be an integer in $\\{0,1,2\\}$.", "solution": "The derivation of the augmented Lagrangian update for contact is most clearly understood as a predictor-corrector algorithm, also known as an operator split method. This approach decomposes the problem into an unconstrained trial step followed by a projection step that enforces the physical constraints of contact and friction.\n\nThe state of the contact interface is defined by the normal gap $g_n$ and the tangential relative displacement increment $\\mathbf{s}_t$. The corresponding forces (tractions) are the Lagrange multipliers: normal pressure $\\lambda_n$ and tangential traction $\\boldsymbol{\\lambda}_t$.\n\nThe constraints are:\n$1$. Normal direction (unilateral contact): The Karush-Kuhn-Tucker (KKT) conditions, also known as Signorini conditions, state that $g_n \\ge 0$ (no penetration), $\\lambda_n \\ge 0$ (pressure is compressive, no adhesion), and $g_n \\lambda_n = 0$ (pressure is zero if there is a gap).\n$2$. Tangential direction (Coulomb friction): The magnitude of the tangential traction is limited by the normal pressure, $\\|\\boldsymbol{\\lambda}_t\\| \\le \\mu \\lambda_n$, where $\\mu$ is the friction coefficient. This defines the friction cone. The system is either in a stick state (slip is zero) or a slip state (slip occurs opposite to the tangential traction).\n\nThe augmented Lagrangian method seeks to satisfy these conditions iteratively. A common update scheme can be derived from the stationarity conditions of an augmented Lagrangian functional, or more directly, through a predictor-corrector interpretation. We begin with the state from the previous iteration, $(\\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}})$, and compute the new state, $(\\lambda_n^{\\text{new}}, \\boldsymbol{\\lambda}_t^{\\text{new}})$, based on the current kinematics $(g_n, \\mathbf{s}_t)$.\n\n**Step 1: Normal Multiplier Update (Projection onto the Admissible Set of Normal Pressures)**\n\nFirst, a \"trial\" normal pressure, $\\lambda_n^{\\text{trial}}$, is computed. This trial value represents the updated pressure required to close the gap $g_n$, augmented by the pressure from the previous step. It is a linear update based on the penalty parameter $\\rho_n$.\n$$\n\\lambda_n^{\\text{trial}} = \\lambda_n^{\\text{old}} - \\rho_n g_n\n$$\nIn this equation, if there is interpenetration ($g_n  0$), the trial pressure increases. If there is a gap ($g_n  0$), the trial pressure decreases.\n\nThis trial pressure, however, may violate the non-negativity constraint $\\lambda_n \\ge 0$. To enforce this, we project $\\lambda_n^{\\text{trial}}$ onto the admissible set of non-negative real numbers, $\\mathbb{R}^+ \\cup \\{0\\}$. This projection is achieved using the ramp function, or $\\max$ operator.\n$$\n\\lambda_n^{\\text{new}} = \\max(0, \\lambda_n^{\\text{trial}}) = \\max(0, \\lambda_n^{\\text{old}} - \\rho_n g_n)\n$$\nThis update intrinsically satisfies the KKT conditions. If $g_n  0$ such that $\\lambda_n^{\\text{trial}}  0$, the updated pressure becomes $\\lambda_n^{\\text{new}} = 0$, satisfying $\\lambda_n g_n = 0$. If contact is established, $\\lambda_n^{\\text{new}}  0$, implying that the algorithm is driving the gap $g_n$ towards a non-positive value (ideally zero) to satisfy the complementarity condition.\n\nIf $\\lambda_n^{\\text{new}} = 0$, the node is in separation. In this case, there can be no tangential friction force, so we must set $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\mathbf{0}$. The contact regime is **separation** ($r=0$). The algorithm terminates for this iteration.\n\n**Step 2: Tangential Multiplier Update (Projection onto the Friction Cone)**\n\nIf $\\lambda_n^{\\text{new}}  0$, the surfaces are in contact, and we proceed to update the tangential multipliers. The procedure follows a similar predictor-corrector pattern.\n\nFirst, we compute a trial tangential traction, $\\boldsymbol{\\lambda}_t^{\\text{trial}}$, under the assumption of a \"stick\" condition. This trial traction is the force required to prevent any tangential slip $\\mathbf{s}_t$.\n$$\n\\boldsymbol{\\lambda}_t^{\\text{trial}} = \\boldsymbol{\\lambda}_t^{\\text{old}} + \\rho_t \\mathbf{s}_t\n$$\nThis trial state must be checked against the Coulomb friction law. The maximum allowable magnitude for the tangential traction is $\\mu \\lambda_n^{\\text{new}}$, which depends on the **updated** normal pressure. We define a slip function $\\Phi_t$:\n$$\n\\Phi_t(\\boldsymbol{\\lambda}_t^{\\text{trial}}, \\lambda_n^{\\text{new}}) = \\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| - \\mu \\lambda_n^{\\text{new}}\n$$\nwhere $\\|\\cdot\\|$ is the Euclidean norm.\n\nTwo cases arise:\n\nCase 2a: $\\Phi_t \\le 0$ (Stick Condition)\nIf the magnitude of the trial tangential traction is within the friction limit, the stick assumption is valid. The trial traction is admissible. The final updated tangential traction is simply the trial traction.\n$$\n\\boldsymbol{\\lambda}_t^{\\text{new}} = \\boldsymbol{\\lambda}_t^{\\text{trial}}\n$$\nThe contact regime is **stick** ($r=1$). The problem statement requires that the boundary case $\\Phi_t = 0$ is treated as stick.\n\nCase 2b: $\\Phi_t  0$ (Slip Condition)\nIf the magnitude of the trial tangential traction exceeds the friction limit, the stick assumption is invalid. The system must slip. The tangential traction must lie on the boundary of the friction cone. To enforce this, we project $\\boldsymbol{\\lambda}_t^{\\text{trial}}$ radially onto the friction circle of radius $\\mu \\lambda_n^{\\text{new}}$. The direction of the traction is preserved, as it must oppose the direction of impending motion (which is given by $\\boldsymbol{\\lambda}_t^{\\text{trial}}$).\n$$\n\\boldsymbol{\\lambda}_t^{\\text{new}} = (\\mu \\lambda_n^{\\text{new}}) \\frac{\\boldsymbol{\\lambda}_t^{\\text{trial}}}{\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|}\n$$\nThis operation is known as a radial return mapping. The contact regime is **slip** ($r=2$). The division by $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|$ is well-defined because $\\Phi_t  0$ implies $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|  \\mu \\lambda_n^{\\text{new}} \\ge 0$.\n\n**Summary of the Algorithm**\nFor given inputs $(g_n, \\mathbf{s}_t, \\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}}, \\rho_n, \\rho_t, \\mu)$:\n$1$. Compute the updated normal multiplier: $\\lambda_n^{\\text{new}} = \\max(0, \\lambda_n^{\\text{old}} - \\rho_n g_n)$.\n$2$. Check for separation: If $\\lambda_n^{\\text{new}} \\le 0$ (practically, check against a small tolerance or exactly zero), set $\\lambda_n^{\\text{new}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\mathbf{0}$, and the regime is separation ($r=0$).\n$3$. If in contact ($\\lambda_n^{\\text{new}}  0$):\n    a. Compute the trial tangential multiplier: $\\boldsymbol{\\lambda}_t^{\\text{trial}} = \\boldsymbol{\\lambda}_t^{\\text{old}} + \\rho_t \\mathbf{s}_t$.\n    b. Calculate its norm: $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|$.\n    c. Calculate the friction limit: $F_{\\text{lim}} = \\mu \\lambda_n^{\\text{new}}$.\n    d. Compare and classify:\n        i. If $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| \\le F_{\\text{lim}}$: Set $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\boldsymbol{\\lambda}_t^{\\text{trial}}$. The regime is stick ($r=1$).\n        ii. If $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|  F_{\\text{lim}}$: Set $\\boldsymbol{\\lambda}_t^{\\text{new}} = F_{\\text{lim}} \\cdot (\\boldsymbol{\\lambda}_t^{\\text{trial}} / \\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|)$. The regime is slip ($r=2$).\n$4$. Return the results: $(\\lambda_n^{\\text{new}}, \\boldsymbol{\\lambda}_t^{\\text{new}}, r)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_contact_update(g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu):\n    \"\"\"\n    Computes the updated Lagrange multipliers and contact regime for a single node-to-plane element.\n\n    Args:\n        g_n (float): Normal gap (positive for separation).\n        s_t (np.ndarray): Tangential relative displacement increment vector (shape (2,)).\n        lambda_n_old (float): Normal multiplier from the previous iteration.\n        lambda_t_old (np.ndarray): Tangential multiplier vector from the previous iteration (shape (2,)).\n        rho_n (float): Normal penalty parameter.\n        rho_t (float): Tangential penalty parameter.\n        mu (float): Coefficient of friction.\n\n    Returns:\n        list: A list containing [lambda_n_new, lambda_tx_new, lambda_ty_new, regime_code].\n    \"\"\"\n    # Step 1: Normal Multiplier Update\n    lambda_n_trial = lambda_n_old - rho_n * g_n\n    lambda_n_new = max(0.0, lambda_n_trial)\n\n    # Step 2: Check for Separation\n    # A small tolerance is not strictly necessary here since max(0, ...) handles it,\n    # but for floating point comparisons, it's good practice.\n    # We will use direct comparison as the logic is robust.\n    if lambda_n_new == 0.0:\n        lambda_t_new = np.array([0.0, 0.0])\n        regime_code = 0  # Separation\n    else:\n        # Step 3: Tangential Multiplier Update (Contact)\n        # 3a. Compute trial tangential multiplier (stick predictor)\n        lambda_t_trial = lambda_t_old + rho_t * s_t\n\n        # 3b. Calculate its norm\n        norm_lambda_t_trial = np.linalg.norm(lambda_t_trial)\n\n        # 3c. Calculate the friction limit\n        friction_limit = mu * lambda_n_new\n\n        # 3d. Compare and classify (stick/slip)\n        if norm_lambda_t_trial = friction_limit:\n            # Stick condition (including the on-cone boundary case)\n            lambda_t_new = lambda_t_trial\n            regime_code = 1  # Stick\n        else:\n            # Slip condition (radial return projection)\n            # This check is technically not needed as norm_lambda_t_trial will be > 0.\n            if norm_lambda_t_trial > 0:\n                lambda_t_new = friction_limit * (lambda_t_trial / norm_lambda_t_trial)\n            else: # Should not be reached given the slip condition\n                lambda_t_new = np.array([0.0, 0.0])\n            regime_code = 2  # Slip\n\n    return [lambda_n_new, lambda_t_new[0], lambda_t_new[1], regime_code]\n\ndef solve():\n    \"\"\"\n    Processes the test suite and prints the final results in the specified format.\n    \"\"\"\n    # Test suite: (g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu)\n    test_cases = [\n        # Case A (stick)\n        (-1e-5, np.array([1e-7, 2e-7]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n        # Case B (slip)\n        (-5e-6, np.array([2e-2, 0.0]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n        # Case C (separation)\n        (1e-3, np.array([1e-3, -1e-3]), 1e3, np.array([1.0, -1.0]), 1e6, 5e5, 0.3),\n        # Case D (on-cone boundary, stick)\n        (-1e-6, np.array([6e-7, 0.0]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters\n        g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu = case\n        \n        # Calculate result for the current case\n        result = compute_contact_update(g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu)\n        results.append(result)\n\n    # Format the final output string to be exactly as specified, without extra spaces.\n    results_str_list = []\n    for res in results:\n        # res = [lambda_n, lambda_tx, lambda_ty, regime]\n        # Format numbers to standard decimal form as requested.\n        # Python's f-string with default formatting is sufficient here.\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        results_str_list.append(inner_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2541924"}]}