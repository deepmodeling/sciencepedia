{"hands_on_practices": [{"introduction": "Before tackling complex, real-world fracture problems, it is essential to verify that our numerical formulation is fundamentally sound. The patch test serves as a crucial benchmark, confirming that the extended finite element approximation can exactly reproduce simple, known discontinuous solutions when integrated perfectly [@problem_id:2551501]. This exercise will guide you through designing such a test for Heaviside enrichment, forcing a careful analysis of the enriched function space and the precise numerical quadrature required for a successful verification.", "problem": "Consider small-strain linear elasticity on a bounded polygonal domain $\\Omega \\subset \\mathbb{R}^{2}$ with a straight crack $\\Gamma_{c}$ that partitions $\\Omega$ into two disjoint open subdomains $\\Omega^{+}$ and $\\Omega^{-}$. The crack is represented by the signed-distance level set $\\phi(\\mathbf{x}) = \\mathbf{n}\\cdot \\mathbf{x} - c$ with unit normal $\\mathbf{n}$ and constant $c \\in \\mathbb{R}$, so that $H(\\phi(\\mathbf{x})) = +1$ for $\\mathbf{x} \\in \\Omega^{+}$ and $H(\\phi(\\mathbf{x})) = -1$ for $\\mathbf{x} \\in \\Omega^{-}$, where $H$ denotes the Heaviside function. Assume a homogeneous, isotropic, and linear elastic stiffness tensor $\\mathbf{C}$ with no body forces. The exact displacement field to be reproduced in a patch test is piecewise affine,\n$$\n\\mathbf{u}^{\\star}(\\mathbf{x}) = \n\\begin{cases}\n\\mathbf{A}^{+}\\mathbf{x} + \\mathbf{b}^{+}, & \\mathbf{x} \\in \\Omega^{+},\\\\\n\\mathbf{A}^{-}\\mathbf{x} + \\mathbf{b}^{-}, & \\mathbf{x} \\in \\Omega^{-},\n\\end{cases}\n$$\nwith constant matrices $\\mathbf{A}^{\\pm} \\in \\mathbb{R}^{2 \\times 2}$ and vectors $\\mathbf{b}^{\\pm} \\in \\mathbb{R}^{2}$. The crack faces are traction-free and Dirichlet boundary conditions on $\\partial \\Omega$ are set equal to $\\mathbf{u}^{\\star}$.\n\nDiscretize $\\Omega$ with a conforming patch of $P_{1}$ (linear) triangular finite elements with standard nodal shape functions $\\{N_{i}\\}$. Use the partition of unity framework of the eXtended Finite Element Method (XFEM) with Heaviside enrichment: enrich exactly those nodes whose support is cut by $\\Gamma_{c}$ with the shifted enrichment $H_{s}(\\mathbf{x}) = H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_{i}))$. The discrete trial space is then\n$$\n\\mathbf{u}_{h}(\\mathbf{x}) = \\sum_{i \\in \\mathcal{I}} N_{i}(\\mathbf{x})\\, \\mathbf{d}_{i} \\;+\\; \\sum_{j \\in \\mathcal{J}} N_{j}(\\mathbf{x})\\, \\mathbf{a}_{j}\\,\\big(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_{j}))\\big),\n$$\nwhere $\\mathcal{I}$ is the full node set, $\\mathcal{J} \\subset \\mathcal{I}$ is the set of enriched nodes, and $\\mathbf{d}_{i}, \\mathbf{a}_{j} \\in \\mathbb{R}^{2}$ are the standard and enriched nodal unknowns, respectively. The weak form uses the bilinear form $a(\\mathbf{u},\\mathbf{v}) = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{v})^{\\mathsf{T}} \\mathbf{C}\\, \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega$, where $\\boldsymbol{\\varepsilon}(\\cdot)$ is the small-strain operator.\n\nDesign a strong-discontinuity patch test that verifies exact reproduction of $\\mathbf{u}^{\\star}$ by $\\mathbf{u}_{h}$, and specify quadrature sufficient to integrate the stiffness contributions exactly. In particular, argue from first principles why $\\mathbf{u}_{h}$ can represent $\\mathbf{u}^{\\star}$ and determine, on each cut element, the polynomial degree of the integrand of the element stiffness matrix when the element is partitioned into the two subdomains $\\Omega^{+}$ and $\\Omega^{-}$ by the straight crack segment. Then, consider the following quadrature strategy for cut elements: subdivide each cut triangle into two triangles by inserting the straight crack segment as an internal edge, and apply standard Gaussian quadrature on each resulting subtriangle. For uncut elements, use standard triangular Gaussian quadrature.\n\nLet $n_{\\ast}$ denote the smallest integer number of Gauss points per (sub)triangle that guarantees exact evaluation of the element stiffness contribution under this strategy. Determine $n_{\\ast}$. Provide only the value of $n_{\\ast}$ as your final answer. No rounding is required, and no units are needed.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Domain and Crack**: A bounded polygonal domain $\\Omega \\subset \\mathbb{R}^{2}$ with a straight crack $\\Gamma_{c}$ partitioning $\\Omega$ into $\\Omega^{+}$ and $\\Omega^{-}$.\n- **Level Set Function**: $\\phi(\\mathbf{x}) = \\mathbf{n}\\cdot \\mathbf{x} - c$, where $\\mathbf{n}$ is a unit normal and $c \\in \\mathbb{R}$.\n- **Heaviside Function Definition**: $H(\\phi(\\mathbf{x})) = +1$ for $\\mathbf{x} \\in \\Omega^{+}$ and $H(\\phi(\\mathbf{x})) = -1$ for $\\mathbf{x} \\in \\Omega^{-}$.\n- **Material Properties**: Homogeneous, isotropic, linear elastic stiffness tensor $\\mathbf{C}$.\n- **Loading**: No body forces.\n- **Exact Displacement Field**:\n$$\n\\mathbf{u}^{\\star}(\\mathbf{x}) = \n\\begin{cases}\n\\mathbf{A}^{+}\\mathbf{x} + \\mathbf{b}^{+}, & \\mathbf{x} \\in \\Omega^{+},\\\\\n\\mathbf{A}^{-}\\mathbf{x} + \\mathbf{b}^{-}, & \\mathbf{x} \\in \\Omega^{-},\n\\end{cases}\n$$\nwhere $\\mathbf{A}^{\\pm} \\in \\mathbb{R}^{2 \\times 2}$ are constant matrices and $\\mathbf{b}^{\\pm} \\in \\mathbb{R}^{2}$ are constant vectors.\n- **Boundary Conditions**: Traction-free on $\\Gamma_{c}$. Dirichlet boundary conditions on $\\partial \\Omega$ are $\\mathbf{u}|_{\\partial \\Omega} = \\mathbf{u}^{\\star}$.\n- **Discretization**: Conforming patch of $P_{1}$ (linear) triangular finite elements with nodal basis functions $\\{N_{i}\\}$.\n- **XFEM Approximation**: The discrete trial space is\n$$\n\\mathbf{u}_{h}(\\mathbf{x}) = \\sum_{i \\in \\mathcal{I}} N_{i}(\\mathbf{x})\\, \\mathbf{d}_{i} \\;+\\; \\sum_{j \\in \\mathcal{J}} N_{j}(\\mathbf{x})\\, \\mathbf{a}_{j}\\,\\big(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_{j}))\\big)\n$$\nwhere $\\mathcal{I}$ is the full node set, $\\mathcal{J} \\subset \\mathcal{I}$ is the set of enriched nodes (nodes whose support is cut by $\\Gamma_{c}$), $\\mathbf{d}_{i}, \\mathbf{a}_{j} \\in \\mathbb{R}^{2}$ are nodal unknown vectors.\n- **Weak Form**: The bilinear form is $a(\\mathbf{u},\\mathbf{v}) = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{v})^{\\mathsf{T}} \\mathbf{C}\\, \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega$, with $\\boldsymbol{\\varepsilon}(\\cdot)$ being the small-strain operator.\n- **Quadrature Strategy for Cut Elements**: Each cut triangle is subdivided into subtriangles by the crack segment. Standard Gaussian quadrature is applied on each subtriangle.\n- **Objective**: Determine $n_{\\ast}$, the smallest integer number of Gauss points per subtriangle required for exact integration of the stiffness matrix contributions.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard patch test for the eXtended Finite Element Method (XFEM) applied to problems with strong discontinuities (cracks). The formulation is consistent with established literature in computational mechanics. The terms are defined precisely, and the goal is a specific, calculable quantity relevant to numerical implementation. No contradictions or missing information that would prevent a solution are identified. The problem is valid.\n\n**Step 3: Verdict and Action**\nThe problem is valid. Proceed to solution.\n\n**Solution**\nThe objective is to determine the minimum number of quadrature points, $n_{\\ast}$, required for the exact integration of element stiffness matrices in a patch test designed to reproduce a piecewise affine displacement field. The patch test is passed if the finite element solution $\\mathbf{u}_{h}$ exactly matches the analytical solution $\\mathbf{u}^{\\star}$ for the given boundary conditions. This is guaranteed by Galerkin orthogonality if the analytical solution can be exactly represented by the trial function space, i.e., $\\mathbf{u}^{\\star} \\in \\{\\mathbf{u}_h\\}$, and the bilinear form is integrated exactly.\n\nFirst, we verify the representability of $\\mathbf{u}^{\\star}$ in the XFEM space. The piecewise affine solution $\\mathbf{u}^{\\star}$ can be expressed globally using the problem-defined Heaviside function $H(\\phi(\\mathbf{x}))$. Let us define an average field and a jump field:\n$$\n\\mathbf{u}_{avg}(\\mathbf{x}) = \\frac{1}{2}\\big((\\mathbf{A}^{+}+\\mathbf{A}^{-})\\mathbf{x} + (\\mathbf{b}^{+}+\\mathbf{b}^{-})\\big)\n$$\n$$\n\\mathbf{u}_{jump}(\\mathbf{x}) = \\frac{1}{2}\\big((\\mathbf{A}^{+}-\\mathbf{A}^{-})\\mathbf{x} + (\\mathbf{b}^{+}-\\mathbf{b}^{-})\\big)\n$$\nBoth $\\mathbf{u}_{avg}(\\mathbf{x})$ and $\\mathbf{u}_{jump}(\\mathbf{x})$ are affine functions. The exact solution can then be written as:\n$$\n\\mathbf{u}^{\\star}(\\mathbf{x}) = \\mathbf{u}_{avg}(\\mathbf{x}) + H(\\phi(\\mathbf{x}))\\mathbf{u}_{jump}(\\mathbf{x})\n$$\nThe XFEM approximation is:\n$$\n\\mathbf{u}_{h}(\\mathbf{x}) = \\sum_{i \\in \\mathcal{I}} N_{i}(\\mathbf{x})\\, \\mathbf{d}_{i} + \\sum_{j \\in \\mathcal{J}} N_{j}(\\mathbf{x})\\, \\mathbf{a}_{j}\\, H(\\phi(\\mathbf{x})) - \\sum_{j \\in \\mathcal{J}} N_{j}(\\mathbf{x})\\, \\mathbf{a}_{j}\\, H(\\phi(\\mathbf{x}_{j}))\n$$\nThis can be rearranged into the form $\\mathbf{P}(\\mathbf{x}) + H(\\phi(\\mathbf{x}))\\mathbf{Q}(\\mathbf{x})$, where:\n$$\n\\mathbf{P}(\\mathbf{x}) = \\sum_{i \\in \\mathcal{I}} N_{i}(\\mathbf{x})\\, \\mathbf{d}_{i} - \\sum_{j \\in \\mathcal{J}} N_{j}(\\mathbf{x})\\, \\mathbf{a}_{j}\\, H(\\phi(\\mathbf{x}_{j}))\n$$\n$$\n\\mathbf{Q}(\\mathbf{x}) = \\sum_{j \\in \\mathcal{J}} N_{j}(\\mathbf{x})\\, \\mathbf{a}_{j}\n$$\nSince the basis functions $N_{i}(\\mathbf{x})$ are linear ($P_1$ elements), and the summations form linear combinations, both $\\mathbf{P}(\\mathbf{x})$ and $\\mathbf{Q}(\\mathbf{x})$ are vector fields whose components are linear polynomials. The full space of linear polynomials can be spanned by choosing the nodal degrees of freedom $\\mathbf{d}_i$ and $\\mathbf{a}_j$ appropriately. Since $\\mathbf{u}_{avg}(\\mathbf{x})$ and $\\mathbf{u}_{jump}(\\mathbf{x})$ are affine (linear polynomials), there exist sets of coefficients $\\{\\mathbf{d}_i, \\mathbf{a}_j\\}$ such that $\\mathbf{P}(\\mathbf{x}) = \\mathbf{u}_{avg}(\\mathbf{x})$ and $\\mathbf{Q}(\\mathbf{x}) = \\mathbf{u}_{jump}(\\mathbf{x})$. Thus, $\\mathbf{u}^{\\star}$ is representable by $\\mathbf{u}_{h}$.\n\nFor the patch test to pass, the stiffness matrix must be computed exactly. The element stiffness matrix components are given by integrals of the form $k_{ab}^{el} = a(\\boldsymbol{\\psi}_a, \\boldsymbol{\\psi}_b)|_{K}$, where $\\boldsymbol{\\psi}_a, \\boldsymbol{\\psi}_b$ are vector-valued basis functions and $K$ is an element. The integrand on $K$ is $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_b)^{\\mathsf{T}} \\mathbf{C}\\, \\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_a)$. Since $\\mathbf{C}$ is a constant tensor, the polynomial degree of the integrand is determined by the product of the components of the strain fields $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_a)$ and $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_b)$.\n\nLet us analyze the strain field $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi})$ for a generic basis function $\\boldsymbol{\\psi}$ over a cut element $K$. The basis functions are of two types:\n1.  Standard basis function: $\\boldsymbol{\\psi}_i(\\mathbf{x}) = N_i(\\mathbf{x}) \\mathbf{e}_k$, where $\\mathbf{e}_k$ is a coordinate basis vector. Since $N_i$ is a linear polynomial for a $P_1$ element, its gradient $\\nabla N_i$ is a constant vector on $K$. Thus, the strain tensor $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_i)$ is constant over the element $K$.\n2.  Enriched basis function: $\\boldsymbol{\\psi}_j(\\mathbf{x}) = N_j(\\mathbf{x}) E_j(\\mathbf{x}) \\mathbf{e}_k$, where $E_j(\\mathbf{x}) = H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_j))$ is the enrichment function.\n\nThe gradient of the enrichment function is $\\nabla E_j(\\mathbf{x}) = \\nabla H(\\phi(\\mathbf{x})) = \\delta(\\phi(\\mathbf{x}))\\mathbf{n}$, where $\\delta$ is the Dirac delta function. This singularity is handled in XFEM by performing integration separately on the subdomains $\\Omega^+$ and $\\Omega^-$, as prescribed by the quadrature strategy.\n\nConsider a cut element $K$. It is partitioned into $K^+ = K \\cap \\Omega^+$ and $K^- = K \\cap \\Omega^-$.\n- On the subdomain $K^+$, $\\phi(\\mathbf{x}) > 0$, so $H(\\phi(\\mathbf{x})) = +1$. The enrichment function becomes $E_j(\\mathbf{x}) = 1 - H(\\phi(\\mathbf{x}_j))$, which is a constant value on $K^+$.\n- On the subdomain $K^-$, $\\phi(\\mathbf{x})  0$, so $H(\\phi(\\mathbf{x})) = -1$. The enrichment function becomes $E_j(\\mathbf{x}) = -1 - H(\\phi(\\mathbf{x}_j))$, which is also a constant value on $K^-$.\n\nThe gradient of the enriched basis function $\\boldsymbol{\\psi}_j$, away from the crack, is:\n$$\n\\nabla \\boldsymbol{\\psi}_j(\\mathbf{x}) = \\nabla(N_j E_j)\\otimes \\mathbf{e}_k = (\\nabla N_j \\otimes \\mathbf{e}_k) E_j + (N_j \\nabla E_j \\otimes \\mathbf{e}_k)\n$$\nOn $K^+$ or $K^-$ separately, $\\nabla E_j = \\mathbf{0}$, and $E_j$ is a constant. Since $\\nabla N_j$ is a constant vector for a $P_1$ element, the gradient $\\nabla \\boldsymbol{\\psi}_j$ is a constant tensor field on $K^+$ and a (generally different) constant tensor field on $K^-$.\n\nConsequently, for any basis function $\\boldsymbol{\\psi}$ (standard or enriched), the associated strain tensor $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi})$ is piecewise constant over a cut element $K$, with the constant value depending on whether the point is in $K^+$ or $K^-$.\n\nThe integrand of the stiffness matrix, $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_b)^{\\mathsf{T}} \\mathbf{C}\\, \\boldsymbol{\\varepsilon}(\\boldsymbol{\\psi}_a)$, is therefore a product of constants. This means the integrand is itself a constant function on $K^+$ and a different constant function on $K^-$. A constant function is a polynomial of degree $0$.\n\nThe quadrature strategy is to subdivide $K$ into subtriangles, each lying entirely within either $K^+$ or $K^-$. On each of these subtriangles, the integrand is a constant, i.e., a polynomial of degree $0$.\n\nTo exactly integrate a polynomial of degree $d$ over a triangle, a Gaussian quadrature rule must have a degree of precision of at least $d$. The question asks for the smallest number of points, $n_{\\ast}$.\n- A 1-point rule (evaluating at the centroid) has a degree of precision of $1$. It integrates any linear polynomial exactly.\n- A 3-point rule has a degree of precision of $2$.\n\nTo integrate a polynomial of degree $d=0$ exactly, a rule with precision $0$ is sufficient. The 1-point rule, with precision $1$, will be exact. A quadrature rule with fewer than $1$ point is not possible. Therefore, the minimum number of Gauss points required per subtriangle is $1$.\n\nThus, $n_{\\ast}=1$. This holds for uncut elements as well, as the strain field for the trial function on an uncut element is constant, making the integrand for the stiffness matrix also a constant.", "answer": "$$\\boxed{1}$$", "id": "2551501"}, {"introduction": "A successful XFEM simulation depends on robustly identifying which elements are cut by a discontinuity and correctly integrating over the resulting subdomains. This practice translates the abstract concept of a level set function into a concrete algorithm for processing element-level data [@problem_id:2551479]. By implementing a set of precise rules, you will learn how to detect element-crack intersections and classify integration points, building a foundational component of any XFEM code.", "problem": "You are given a reference element for the Extended Finite Element Method (XFEM) crack and interface enrichment task, restricted to two-dimensional bilinear quadrilateral finite elements. The reference element has local isoparametric coordinates $(\\xi,\\eta) \\in [-1,1]^2$ and four local nodes ordered counterclockwise starting at the lower-left corner: node $0$ at $(\\xi,\\eta)=(-1,-1)$, node $1$ at $(\\xi,\\eta)=(+1,-1)$, node $2$ at $(\\xi,\\eta)=(+1,+1)$, and node $3$ at $(\\xi,\\eta)=(-1,+1)$. At each node $i\\in\\{0,1,2,3\\}$ there is a scalar level set value $\\phi_i$ representing the signed distance to a crack surface: $\\phi_i0$ denotes one side, $\\phi_i0$ the other side, and $\\phi_i=0$ the interface. The sign convention is arbitrary but must be used consistently.\n\nGoal: Using only the nodal level set values and standard bilinear interpolation on the reference element, your task is to robustly detect whether the crack intersects the element and to construct the list of Gauss integration points on each side of the crack.\n\nPrinciples to use:\n- Interpolation: Inside the element, the level set field $\\phi(\\xi,\\eta)$ is interpolated from $\\{\\phi_i\\}$ using the standard bilinear quadrilateral shape functions.\n- Crack intersection detection must be robust to degeneracies, including nodal values within a small tolerance $\\tau$ of zero and cases where the crack tip coincides with a node or lies along an edge. Use a tolerance $\\tau = 10^{-8}$.\n- For numerical integration, use a tensor-product Gauss rule with $2\\times 2$ points at $(\\xi,\\eta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ and unit weights. Index the Gauss points as $0,1,2,3$ in the order $(-1/\\sqrt{3},-1/\\sqrt{3})$, $(+1/\\sqrt{3},-1/\\sqrt{3})$, $(+1/\\sqrt{3},+1/\\sqrt{3})$, $(-1/\\sqrt{3},+1/\\sqrt{3})$.\n- Classification: A Gauss point belongs to the positive side if $\\phi(\\xi,\\eta)  \\tau$, to the negative side if $\\phi(\\xi,\\eta)  -\\tau$, and is considered to lie on the interface if $|\\phi(\\xi,\\eta)| \\le \\tau$ (interface points should be excluded from both side lists for this task).\n\nRobust crack-intersection decision rule to implement:\n- Let $\\operatorname{sgn}_\\tau(\\phi_i)$ be $+1$ if $\\phi_i  \\tau$, $-1$ if $\\phi_i  -\\tau$, and $0$ otherwise.\n- Declare the element “cut” if either:\n  - Both signs $+1$ and $-1$ occur among $\\{\\operatorname{sgn}_\\tau(\\phi_i)\\}_{i=0}^3$, or\n  - At least $2$ distinct element edges among $\\{(0\\!-\\!1),(1\\!-\\!2),(2\\!-\\!3),(3\\!-\\!0)\\}$ exhibit an interface event, where an “interface event” on an edge $(i\\!-\\!j)$ is defined as $\\operatorname{sgn}_\\tau(\\phi_i) \\cdot \\operatorname{sgn}_\\tau(\\phi_j)  0$ or exactly one of $\\operatorname{sgn}_\\tau(\\phi_i),\\operatorname{sgn}_\\tau(\\phi_j)$ equals $0$.\nThis rule must treat crack tips at vertices and interfaces passing through nodes or along edges as “cut.”\n\nOutput construction:\n- For each element, construct two lists of Gauss point indices: the indices on the positive side and the indices on the negative side, according to the classification rule above. Indices corresponding to interface points (i.e., $|\\phi| \\le \\tau$ at the Gauss point) should be excluded from both lists.\n- Additionally, output whether the element is cut as an integer $1$ (cut) or $0$ (not cut).\n\nTest suite:\nImplement your program for the following $4$ elements, each specified by their nodal level set arrays $[\\phi_0,\\phi_1,\\phi_2,\\phi_3]$:\n- Case $1$ (diagonal crossing): $[-1.0,\\,1.0,\\,1.0,\\,-1.0]$.\n- Case $2$ (no cut): $[2.0,\\,3.0,\\,2.5,\\,2.2]$.\n- Case $3$ (crack tip at a vertex): $[0.0,\\,1.0,\\,1.0,\\,-1.0]$.\n- Case $4$ (grazing but cutting): $[-0.2,\\,-0.1,\\,0.1,\\,0.2]$.\n\nFinal output format:\n- Your program should produce a single line of output containing a single list of length $4$, where the $k$-th entry corresponds to case $k$ and is itself a list of the form $[c, P, N]$, where $c\\in\\{0,1\\}$ is the cut flag, $P$ is the list of positive-side Gauss point indices, and $N$ is the list of negative-side Gauss point indices.\n- The output must be printed exactly as a comma-separated list enclosed in square brackets, with no spaces anywhere. For example: \"[[1,[0,2],[1,3]],[0,[0,1,2,3],[]],...]\".", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of rules for detecting a crack intersection within a bilinear quadrilateral finite element and for classifying Gauss integration points with respect to the crack. The principles invoked—level set representation, isoparametric mapping with bilinear shape functions, and Gauss quadrature—are fundamental to the extended finite element method (XFEM). Therefore, I will proceed directly to the formulation of the solution.\n\nThe core of the problem lies in evaluating a scalar level set field, $\\phi(\\xi, \\eta)$, within the reference element domain $(\\xi, \\eta) \\in [-1, 1]^2$. This field is interpolated from the given nodal values $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ using the standard bilinear shape functions $N_i(\\xi, \\eta)$:\n$$\n\\phi(\\xi, \\eta) = \\sum_{i=0}^{3} N_i(\\xi, \\eta) \\phi_i\n$$\nThe four shape functions correspond to the nodes $0, 1, 2, 3$ ordered counter-clockwise from the corner $(\\xi, \\eta) = (-1, -1)$:\n\\begin{itemize}\n    \\item $N_0(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n    \\item $N_1(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n    \\item $N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n    \\item $N_3(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\\end{itemize}\n\nThe procedure for each test case, given as an array of nodal values $[\\phi_0, \\phi_1, \\phi_2, \\phi_3]$, is executed in two primary stages: crack intersection detection and Gauss point classification.\n\n**1. Crack Intersection Detection**\n\nThis stage determines if the element is \"cut\" by the crack interface, defined by $\\phi(\\xi, \\eta)=0$. A robust decision rule is specified, which handles degeneracies such as crack tips at nodes or along edges. Let $\\tau = 10^{-8}$ be the zero-tolerance.\n\nFirst, we define a filtered sign function for a nodal value $\\phi_i$:\n$$\n\\operatorname{sgn}_\\tau(\\phi_i) = \\begin{cases} +1  \\text{if } \\phi_i > \\tau \\\\ -1  \\text{if } \\phi_i  -\\tau \\\\ 0  \\text{if } |\\phi_i| \\le \\tau \\end{cases}\n$$\nThe element is declared \"cut\" (output flag $c=1$) if at least one of the following two conditions is met:\n\na) The set of nodal signs $\\{\\operatorname{sgn}_\\tau(\\phi_i)\\}_{i=0}^3$ contains both $+1$ and $-1$. This is the standard case where the crack cleanly separates the element's nodes.\n\nb) At least two distinct edges of the element exhibit an \"interface event\". The edges are $(0-1)$, $(1-2)$, $(2-3)$, and $(3-0)$. An interface event on an edge $(i-j)$ occurs if $\\operatorname{sgn}_\\tau(\\phi_i) \\cdot \\operatorname{sgn}_\\tau(\\phi_j)  0$ (a sign change) or if exactly one of $\\operatorname{sgn}_\\tau(\\phi_i)$ or $\\operatorname{sgn}_\\tau(\\phi_j)$ is zero. This second condition robustly detects crack tips located at a node, which would otherwise be missed by condition (a).\n\nIf neither condition is met, the element is not cut ($c=0$).\n\n**2. Gauss Point Classification**\n\nThis stage partitions the standard $2 \\times 2$ Gauss quadrature points based on their position relative to the crack. The four Gauss points are indexed $0, 1, 2, 3$ corresponding to the local coordinates, with $\\gamma = 1/\\sqrt{3}$:\n\\begin{itemize}\n    \\item Point $0$: $(\\xi_0, \\eta_0) = (-\\gamma, -\\gamma)$\n    \\item Point $1$: $(\\xi_1, \\eta_1) = (+\\gamma, -\\gamma)$\n    \\item Point $2$: $(\\xi_2, \\eta_2) = (+\\gamma, +\\gamma)$\n    \\item Point $3$: $(\\xi_3, \\eta_3) = (-\\gamma, +\\gamma)$\n\\end{itemize}\n\nFor each Gauss point $k \\in \\{0, 1, 2, 3\\}$, the level set value $\\phi_k = \\phi(\\xi_k, \\eta_k)$ is computed via the bilinear interpolation formula. The point's index is then added to one of two lists, $P$ (positive side) or $N$ (negative side), based on the following classification:\n\\begin{itemize}\n    \\item If $\\phi_k > \\tau$, index $k$ is added to list $P$.\n    \\item If $\\phi_k  -\\tau$, index $k$ is added to list $N$.\n    \\item If $|\\phi_k| \\le \\tau$, the point lies on the interface and is excluded from both lists.\n\\end{itemize}\n\nThe final output for each test case is a list containing the cut flag $c$, the list of positive-side Gauss point indices $P$, and the list of negative-side Gauss point indices $N$. The following program implements this logic.", "answer": "```python\nimport numpy as np\n\ndef format_list_no_spaces(data):\n    \"\"\"\n    Recursively formats a list into a string representation without spaces.\n    This is required to match the exact output format string.\n    \"\"\"\n    if isinstance(data, list):\n        return f\"[{','.join(format_list_no_spaces(item) for item in data)}]\"\n    else:\n        return str(data)\n\ndef solve():\n    \"\"\"\n    Solves the XFEM enrichment problem for the given test cases.\n    \"\"\"\n    # Test cases defined as lists of nodal level set values [phi_0, phi_1, phi_2, phi_3]\n    test_cases = [\n        [-1.0, 1.0, 1.0, -1.0],   # Case 1: diagonal crossing\n        [2.0, 3.0, 2.5, 2.2],     # Case 2: no cut\n        [0.0, 1.0, 1.0, -1.0],    # Case 3: crack tip at a vertex\n        [-0.2, -0.1, 0.1, 0.2]    # Case 4: grazing but cutting\n    ]\n\n    # Tolerance for zero-checks\n    tau = 1.0e-8\n\n    # Gauss point coordinates for a 2x2 rule\n    gamma = 1.0 / np.sqrt(3.0)\n    gp_coords = [\n        (-gamma, -gamma),  # GP 0\n        (gamma, -gamma),   # GP 1\n        (gamma, gamma),    # GP 2\n        (-gamma, gamma)    # GP 3\n    ]\n    \n    # Bilinear shape functions, evaluated at (xi, eta)\n    def shape_functions(xi, eta):\n        return np.array([\n            0.25 * (1.0 - xi) * (1.0 - eta),  # N0\n            0.25 * (1.0 + xi) * (1.0 - eta),  # N1\n            0.25 * (1.0 + xi) * (1.0 + eta),  # N2\n            0.25 * (1.0 - xi) * (1.0 + eta)   # N3\n        ])\n\n    # Filtered sign function\n    def sgn_tau(x, tol):\n        if x > tol:\n            return 1\n        elif x  -tol:\n            return -1\n        else:\n            return 0\n\n    results = []\n    for phi_nodes in test_cases:\n        phi_nodes = np.array(phi_nodes)\n        \n        # --- 1. Crack Intersection Detection ---\n        is_cut = 0\n        phi_signs = [sgn_tau(p, tau) for p in phi_nodes]\n        \n        # Condition (a): Mixed signs at nodes\n        if 1 in phi_signs and -1 in phi_signs:\n            is_cut = 1\n        else:\n            # Condition (b): At least 2 interface events on edges\n            edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n            interface_event_count = 0\n            for i, j in edges:\n                s_i, s_j = phi_signs[i], phi_signs[j]\n                # Event: sign change or exactly one node on interface\n                if (s_i * s_j  0) or ((s_i == 0) != (s_j == 0)):\n                    interface_event_count += 1\n            \n            if interface_event_count >= 2:\n                is_cut = 1\n\n        # --- 2. Gauss Point Classification ---\n        P, N = [], []\n        for k in range(len(gp_coords)):\n            xi, eta = gp_coords[k]\n            # Interpolate level set value at Gauss point\n            N_vals = shape_functions(xi, eta)\n            phi_gp = np.dot(N_vals, phi_nodes)\n            \n            # Classify the point\n            if phi_gp > tau:\n                P.append(k)\n            elif phi_gp  -tau:\n                N.append(k)\n        \n        results.append([is_cut, P, N])\n\n    # --- 3. Format and Print Output ---\n    formatted_results = [format_list_no_spaces(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2551479"}, {"introduction": "Simulating the growth of a crack is one of the most powerful applications of XFEM, but it introduces the challenge of updating the solution as the enrichment changes. To maintain a stable and continuous simulation, we must intelligently transfer the solution from one crack configuration to the next [@problem_id:2551517]. This practice introduces the concept of a prolongation operator, guiding you to construct a mapping that preserves the nodal solution in a least-squares sense, a crucial technique for any advanced crack propagation analysis.", "problem": "You are given a two-dimensional scalar partition-of-unity finite element approximation with enrichment functions for cracks. The discrete field is\n$$\nu(\\mathbf{x}) \\approx \\sum_{I \\in \\mathcal{N}} N_I(\\mathbf{x})\\, d_I \\;+\\; \\sum_{I \\in \\mathcal{E}_H} N_I(\\mathbf{x})\\, H(\\mathbf{x})\\, a_I \\;+\\; \\sum_{I \\in \\mathcal{E}_B} N_I(\\mathbf{x})\\, B(\\mathbf{x})\\, b_I,\n$$\nwhere $N_I(\\mathbf{x})$ are nodal Lagrange shape functions with the Kronecker-delta property $N_I(\\mathbf{x}_J) = \\delta_{IJ}$, $\\mathcal{N}$ is the set of all nodes, $\\mathcal{E}_H$ is the set of Heaviside-enriched nodes, and $\\mathcal{E}_B$ is the set of branch-enriched nodes. The Heaviside enrichment $H(\\mathbf{x})$ is defined as the sign of a signed distance $\\phi(\\mathbf{x})$ to the crack line, and the branch enrichment $B(\\mathbf{x})$ is a near-tip scalar function $B(\\mathbf{x}) = \\sqrt{r(\\mathbf{x})}$, where $r(\\mathbf{x})$ is the Euclidean distance from $\\mathbf{x}$ to the crack tip. The vectors of discrete unknowns are $d_I$ for standard degrees of freedom, $a_I$ for Heaviside-enriched degrees of freedom, and $b_I$ for branch-enriched degrees of freedom. We consider a scalar field (e.g., antiplane displacement), so all degrees of freedom are scalar.\n\nThe variational setting is the standard Galerkin method: given a bilinear form $a(\\cdot,\\cdot)$ and a linear functional $\\ell(\\cdot)$ derived from a linear elliptic partial differential equation and appropriate boundary conditions, find $u \\in \\mathcal{V}_h$ such that $a(u,v) = \\ell(v)$ for all $v \\in \\mathcal{V}_h$, where $\\mathcal{V}_h$ is the discrete partition-of-unity enriched trial space spanned by the above functions.\n\nA crack is represented at each propagation step $s$ by a straight segment with endpoints $\\mathbf{c}_1^{(s)}$ and $\\mathbf{c}_2^{(s)}$, with tip at $\\mathbf{t}^{(s)} = \\mathbf{c}_2^{(s)}$. Between two consecutive steps $s$ and $s+1$, the crack extends, changing the enriched node sets from $(\\mathcal{E}_H^{(s)}, \\mathcal{E}_B^{(s)})$ to $(\\mathcal{E}_H^{(s+1)}, \\mathcal{E}_B^{(s+1)})$. The Heaviside $H(\\mathbf{x})$ uses the signed distance to the infinite line through $(\\mathbf{c}_1^{(s)},\\mathbf{c}_2^{(s)})$, with a tie-breaker $\\varepsilon$ to avoid zero at nodes exactly on the line. Specifically, for a point $\\mathbf{x}$,\n$$\n\\phi^{(s)}(\\mathbf{x}) = \\mathbf{n}^{(s)} \\cdot (\\mathbf{x} - \\mathbf{c}_1^{(s)}) + \\varepsilon\\,\\mathbf{w}\\cdot \\mathbf{x}, \\quad H^{(s)}(\\mathbf{x}) = \\mathrm{sign}(\\phi^{(s)}(\\mathbf{x})),\n$$\nwhere $\\mathbf{d}^{(s)} = \\mathbf{c}_2^{(s)}-\\mathbf{c}_1^{(s)}$, $\\mathbf{n}^{(s)} = (-d_y^{(s)}, d_x^{(s)})$ is a fixed orientation of the line normal, and $\\mathbf{w}$ is a fixed nonzero vector (use $\\mathbf{w} = (1,2)$). The branch enrichment is $B^{(s)}(\\mathbf{x}) = \\sqrt{\\|\\mathbf{x}-\\mathbf{t}^{(s)}\\|_2}$.\n\nAt nodal collocation points $\\mathbf{x}_J$, the field evaluates to\n$$\nu(\\mathbf{x}_J) = d_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_H\\}}\\,H(\\mathbf{x}_J)\\,a_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_B\\}}\\,B(\\mathbf{x}_J)\\,b_J,\n$$\nbecause $N_I(\\mathbf{x}_J) = \\delta_{IJ}$. Define a per-step linear mapping from the stacked degree-of-freedom vector to nodal values\n$$\n\\mathbf{v}^{(s)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}, \\quad \\mathbf{v}^{(s)} \\in \\mathbb{R}^{N_n},\n$$\nwhere $N_n$ is the number of nodes, and $\\mathbf{d}^{(s)}$ stacks first all standard degrees of freedom $d_I$, then all Heaviside-enriched degrees of freedom $a_I$ for $I \\in \\mathcal{E}_H^{(s)}$, and then all branch-enriched degrees of freedom $b_I$ for $I \\in \\mathcal{E}_B^{(s)}$.\n\nGoal. When updating enrichment support from step $s$ to $s+1$, design and implement an algorithm that constructs a prolongation operator $\\mathbf{P}^{(s\\to s+1)}$ such that for any old degrees of freedom $\\mathbf{d}^{(s)}$, the new degrees of freedom\n$$\n\\mathbf{d}^{(s+1)} = \\mathbf{P}^{(s\\to s+1)} \\mathbf{d}^{(s)}\n$$\nproduce preserved nodal values,\n$$\n\\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)},\n$$\nwhenever this equation is solvable, and otherwise minimize the Euclidean norm of the difference in a least-squares sense. The update must also support adding new enriched degrees of freedom and removing obsolete ones as the crack grows, while preserving solution continuity across steps at the nodes. Use the Moore–Penrose pseudoinverse to define\n$$\n\\mathbf{P}^{(s\\to s+1)} := \\left(\\mathbf{A}^{(s+1)}\\right)^+ \\mathbf{A}^{(s)}.\n$$\n\nMesh and enrichment selection. Use a uniform structured quadrilateral mesh of the unit square domain $[0,1]\\times[0,1]$ with $2\\times 2$ elements and $3\\times 3$ nodes. An element is marked as cut by the crack if the crack segment intersects the element rectangle (intersection with nonzero segment length in the rectangle). Heaviside-enriched nodes $\\mathcal{E}_H^{(s)}$ are all nodes belonging to any cut element. Branch-enriched nodes $\\mathcal{E}_B^{(s)}$ are all nodes with distance to the crack tip strictly less than a given radius $R_{\\mathrm{tip}}^{(s)}$. Construct $\\mathbf{A}^{(s)}$ by evaluating the coefficients at each node $\\mathbf{x}_J$:\n- the column for the standard degree of freedom $d_J$ is $1$,\n- if $J \\in \\mathcal{E}_H^{(s)}$, the column for $a_J$ is $H^{(s)}(\\mathbf{x}_J) \\in \\{-1,1\\}$,\n- if $J \\in \\mathcal{E}_B^{(s)}$, the column for $b_J$ is $B^{(s)}(\\mathbf{x}_J) = \\sqrt{\\|\\mathbf{x}_J - \\mathbf{t}^{(s)}\\|_2}$.\n\nTest vector. For testing, define a deterministic old degree-of-freedom vector $\\mathbf{d}^{(s)}$ by\n$$\nd_J = \\sin(\\pi x_J)\\cos(\\pi y_J), \\quad a_J = 0.1\\,(x_J+y_J), \\quad b_J = 0.05\\,(x_J - y_J),\n$$\nfor all nodes $J$ in the relevant sets, where $(x_J,y_J)$ are the node coordinates. The entries $a_J$ and $b_J$ are only included for nodes in $\\mathcal{E}_H^{(s)}$ and $\\mathcal{E}_B^{(s)}$, respectively.\n\nTasks to implement.\n- Construct the mesh and the nodal coordinates.\n- For each step $s$ and $s+1$, given crack endpoints and tip, build $\\mathcal{E}_H^{(s)}$, $\\mathcal{E}_B^{(s)}$, and the corresponding matrices $\\mathbf{A}^{(s)}$ and $\\mathbf{A}^{(s+1)}$.\n- Compute the prolongation $\\mathbf{P}^{(s\\to s+1)}$ and apply it to map $\\mathbf{d}^{(s)}$ to $\\mathbf{d}^{(s+1)}$.\n- Evaluate the maximum absolute discrepancy \n$$\n\\delta_{\\max} = \\max_J \\left| \\left(\\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)}\\right)_J - \\left(\\mathbf{A}^{(s)} \\mathbf{d}^{(s)}\\right)_J \\right|.\n$$\n- Count how many enriched degrees of freedom were added and removed during the update:\n$$\nN_{\\mathrm{add}} = \\left|\\mathcal{E}_H^{(s+1)} \\setminus \\mathcal{E}_H^{(s)}\\right| + \\left|\\mathcal{B}^{(s+1)} \\setminus \\mathcal{E}_B^{(s)}\\right|, \\quad\nN_{\\mathrm{rem}} = \\left|\\mathcal{E}_H^{(s)} \\setminus \\mathcal{E}_H^{(s+1)}\\right| + \\left|\\mathcal{B}^{(s)} \\setminus \\mathcal{E}_B^{(s+1)}\\right|.\n$$\n\nAngle units. All trigonometric functions use radians.\n\nNo physical units are required; all quantities are dimensionless.\n\nTest suite. Implement the above for the following three cases, each defining step $s$ and $s+1$ with crack data and tip radius. Use the same mesh for all cases.\n- Case $1$:\n  - Step $s$: $\\mathbf{c}_1^{(s)} = (0.2,0.5)$, $\\mathbf{c}_2^{(s)} = (0.5,0.5)$, $\\mathbf{t}^{(s)} = (0.5,0.5)$, $R_{\\mathrm{tip}}^{(s)} = 0.3$.\n  - Step $s+1$: $\\mathbf{c}_1^{(s+1)} = (0.2,0.5)$, $\\mathbf{c}_2^{(s+1)} = (0.8,0.5)$, $\\mathbf{t}^{(s+1)} = (0.8,0.5)$, $R_{\\mathrm{tip}}^{(s+1)} = 0.3$.\n- Case $2$:\n  - Step $s$: $\\mathbf{c}_1^{(s)} = (0.2,0.2)$, $\\mathbf{c}_2^{(s)} = (0.5,0.5)$, $\\mathbf{t}^{(s)} = (0.5,0.5)$, $R_{\\mathrm{tip}}^{(s)} = 0.25$.\n  - Step $s+1$: $\\mathbf{c}_1^{(s+1)} = (0.2,0.2)$, $\\mathbf{c}_2^{(s+1)} = (0.8,0.5)$, $\\mathbf{t}^{(s+1)} = (0.8,0.5)$, $R_{\\mathrm{tip}}^{(s+1)} = 0.25$.\n- Case $3$ (edge case with nodes on the crack line):\n  - Step $s$: $\\mathbf{c}_1^{(s)} = (0.0,0.5)$, $\\mathbf{c}_2^{(s)} = (0.5,0.5)$, $\\mathbf{t}^{(s)} = (0.5,0.5)$, $R_{\\mathrm{tip}}^{(s)} = 0.2$.\n  - Step $s+1$: $\\mathbf{c}_1^{(s+1)} = (0.0,0.5)$, $\\mathbf{c}_2^{(s+1)} = (0.9,0.5)$, $\\mathbf{t}^{(s+1)} = (0.9,0.5)$, $R_{\\mathrm{tip}}^{(s+1)} = 0.2$.\n\nUse $\\varepsilon = 10^{-8}$ and $\\mathbf{w} = (1,2)$ in all cases.\n\nRequired final output format. Your program should produce a single line of output containing a JSON-like list-of-lists\n$$\n\\big[ [\\delta_{\\max}^{(1)}, N_{\\mathrm{add}}^{(1)}, N_{\\mathrm{rem}}^{(1)}], [\\delta_{\\max}^{(2)}, N_{\\mathrm{add}}^{(2)}, N_{\\mathrm{rem}}^{(2)}], [\\delta_{\\max}^{(3)}, N_{\\mathrm{add}}^{(3)}, N_{\\mathrm{rem}}^{(3)}] \\big],\n$$\nwith no spaces, where the superscript indicates the case number. Each $\\delta_{\\max}^{(i)}$ must be a floating-point number, and each $N_{\\mathrm{add}}^{(i)}$ and $N_{\\mathrm{rem}}^{(i)}$ must be integers. The program must not read any input and must run as-is. The use of the Moore–Penrose pseudoinverse is mandatory for the prolongation operator.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational mechanics, specifically in the context of the eXtended Finite Element Method (XFEM) for fracture analysis. It requires the implementation of a procedure to transfer solution data between two consecutive steps of a quasi-static crack growth simulation. This transfer, or prolongation, is essential for maintaining solution continuity and providing a good initial guess for the next nonlinear solve. The problem is valid and all necessary data and definitions are provided.\n\nThe core of the task is to construct a prolongation operator $\\mathbf{P}^{(s\\to s+1)}$ that maps the vector of degrees of freedom $\\mathbf{d}^{(s)}$ from step $s$ to $\\mathbf{d}^{(s+1)}$ at step $s+1$. This operator must ensure that the physical field, evaluated at the mesh nodes, is preserved as closely as possible. The field preservation is expressed as minimizing the Euclidean norm of the difference between the nodal value vectors $\\mathbf{v}^{(s+1)}$ and $\\mathbf{v}^{(s)}$. The vectors of nodal values are defined by the linear mappings $\\mathbf{v}^{(s)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$ and $\\mathbf{v}^{(s+1)} = \\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)}$. The goal is to find $\\mathbf{d}^{(s+1)} = \\mathbf{P}^{(s\\to s+1)} \\mathbf{d}^{(s)}$ such that $\\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)} \\approx \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$.\n\nThe least-squares solution to the equation $\\mathbf{A}^{(s+1)} \\mathbf{x} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$ for the unknown vector $\\mathbf{x} = \\mathbf{d}^{(s+1)}$ is given by $\\mathbf{d}^{(s+1)} = (\\mathbf{A}^{(s+1)})^{+} (\\mathbf{A}^{(s)} \\mathbf{d}^{(s)})$, where $(\\mathbf{A}^{(s+1)})^{+}$ is the Moore-Penrose pseudoinverse of $\\mathbf{A}^{(s+1)}$. From this, the prolongation operator is identified as $\\mathbf{P}^{(s\\to s+1)} = (\\mathbf{A}^{(s+1)})^{+} \\mathbf{A}^{(s)}$.\n\nThe step-by-step procedure for each test case is as follows:\n\n1.  **Mesh Generation**: A uniform $2 \\times 2$ quadrilateral mesh is created over the unit square $[0,1] \\times [0,1]$. This results in $3 \\times 3 = 9$ nodes. The coordinates and element-node connectivity are established.\n\n2.  **State Processing (for steps $s$ and $s+1$)**: For each step, given the crack geometry ($\\mathbf{c}_1, \\mathbf{c}_2$) and enrichment parameters, we perform the following:\n    *   **Enrichment Set Identification**:\n        *   The set of Heaviside-enriched nodes, $\\mathcal{E}_H$, is determined by identifying all elements that are \"cut\" by the crack segment. An element is considered cut if the crack segment intersects its interior, which is determined using a robust line segment-rectangle intersection algorithm. All nodes of a cut element are added to $\\mathcal{E}_H$.\n        *   The set of branch-enriched nodes, $\\mathcal{E}_B$, is determined by finding all nodes whose Euclidean distance to the crack tip $\\mathbf{t}$ is strictly less than the given radius $R_{\\mathrm{tip}}$.\n    *   **Matrix $\\mathbf{A}$ Construction**: The matrix $\\mathbf{A}$ maps the global vector of degrees of freedom to the vector of nodal field values. Its structure is derived from the nodal evaluation formula:\n        $$u(\\mathbf{x}_J) = d_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_H\\}}\\,H(\\mathbf{x}_J)\\,a_J \\;+\\; \\mathbb{1}_{\\{J \\in \\mathcal{E}_B\\}}\\,B(\\mathbf{x}_J)\\,b_J$$\n        This implies that for a given node $J$, its field value $u(\\mathbf{x}_J)$ depends only on the degrees of freedom $d_J, a_J, b_J$ associated with that same node. The matrix $\\mathbf{A}$ of size $N_n \\times (N_n + |\\mathcal{E}_H| + |\\mathcal{E}_B|)$ is constructed as follows:\n        - The first $N_n$ columns, corresponding to standard DOFs $d_J$, form an identity matrix.\n        - For each node $J \\in \\mathcal{E}_H$, a column is added for the DOF $a_J$. This column is zero everywhere except for the $J$-th row, which contains the value of the Heaviside function $H(\\mathbf{x}_J)$. The function $H(\\mathbf{x}_J) = \\mathrm{sign}(\\phi(\\mathbf{x}_J))$, where $\\phi$ is the signed distance to the crack line with a small perturbation to prevent zeros.\n        - Similarly, for each node $J \\in \\mathcal{E}_B$, a column for the DOF $b_J$ is added. It is zero everywhere except for the $J$-th row, containing the value of the branch function $B(\\mathbf{x}_J) = \\sqrt{r(\\mathbf{x}_J)}$.\n\n3.  **Test Vector Construction**: For step $s$, the test vector of degrees of freedom $\\mathbf{d}^{(s)}$ is constructed. Its components are populated according to the provided formulas: $d_J = \\sin(\\pi x_J)\\cos(\\pi y_J)$, $a_J = 0.1(x_J+y_J)$ for $J \\in \\mathcal{E}_H^{(s)}$, and $b_J = 0.05(x_J - y_J)$ for $J \\in \\mathcal{E}_B^{(s)}$.\n\n4.  **Prolongation and Evaluation**:\n    *   The prolongation operator is computed: $\\mathbf{P}^{(s\\to s+1)} = (\\mathbf{A}^{(s+1)})^{+} \\mathbf{A}^{(s)}$, using the Moore-Penrose pseudoinverse.\n    *   The old DOFs are mapped to the new configuration: $\\mathbf{d}^{(s+1)} = \\mathbf{P}^{(s\\to s+1)} \\mathbf{d}^{(s)}$.\n    *   The nodal value vectors before and after the update are calculated: $\\mathbf{v}^{(s)} = \\mathbf{A}^{(s)} \\mathbf{d}^{(s)}$ and $\\mathbf{v}^{(s+1)} = \\mathbf{A}^{(s+1)} \\mathbf{d}^{(s+1)}$.\n    *   The maximum absolute discrepancy in nodal values is computed: $\\delta_{\\max} = \\max_J \\left| (\\mathbf{v}^{(s+1)})_J - (\\mathbf{v}^{(s)})_J \\right|$. By construction, this value represents the least-squares error of the projection and is expected to be small.\n    *   The number of added ($N_{\\mathrm{add}}$) and removed ($N_{\\mathrm{rem}}$) enriched degrees of freedom are counted by comparing the enrichment sets $\\mathcal{E}_H$ and $\\mathcal{E}_B$ between the two steps using set operations.\n\nThis entire sequence is implemented for each of the three test cases provided.", "answer": "```python\nimport numpy as np\n\nclass CrackUpdateSolver:\n    \"\"\"\n    Solves for the prolongation operator and evaluates its performance for a given crack propagation step.\n    This class handles the entire process for a single test case, from mesh setup to final metric calculation.\n    \"\"\"\n    def __init__(self, case_data, mesh_params, epsilon, w_vec):\n        \"\"\"\n        Initializes the solver with test case data and global parameters.\n        \n        Args:\n            case_data (dict): Contains crack geometry and enrichment radii for steps s and s+1.\n            mesh_params (dict): Specifies the number of elements in x and y directions.\n            epsilon (float): Small perturbation parameter for the signed distance function.\n            w_vec (tuple): Perturbation vector for the signed distance function.\n        \"\"\"\n        self.case_data = case_data\n        self.mesh_params = mesh_params\n        self.epsilon = epsilon\n        self.w_vec = np.array(w_vec)\n        self._setup_mesh()\n\n    def _setup_mesh(self):\n        \"\"\"\n        Generates a uniform rectangular mesh with specified node and element counts.\n        \"\"\"\n        nx, ny = self.mesh_params['nx'], self.mesh_params['ny']\n        self.num_nodes = (nx + 1) * (ny + 1)\n        \n        x_coords = np.linspace(0, 1, nx + 1)\n        y_coords = np.linspace(0, 1, ny + 1)\n        \n        # Node coordinates, indexed row-wise\n        self.nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n        \n        # Element definitions, including node indices and bounding boxes\n        self.elements = []\n        for j in range(ny):\n            for i in range(nx):\n                n0 = j * (nx + 1) + i\n                n1 = n0 + 1\n                n2 = (j + 1) * (nx + 1) + i + 1\n                n3 = (j + 1) * (nx + 1) + i\n                self.elements.append({\n                    'nodes': [n0, n1, n2, n3],\n                    'bbox': [x_coords[i], x_coords[i+1], y_coords[j], y_coords[j+1]]\n                })\n\n    def _segment_intersects_box(self, p1, p2, bbox):\n        \"\"\"\n        Checks if a line segment intersects an axis-aligned bounding box with non-zero length.\n        This uses a variation of the Liang-Barsky line clipping algorithm.\n        \"\"\"\n        p1_arr, p2_arr = np.array(p1), np.array(p2)\n        d = p2_arr - p1_arr\n        xmin, xmax, ymin, ymax = bbox\n        bounds = np.array([[xmin, xmax], [ymin, ymax]])\n        \n        t_near, t_far = 0.0, 1.0\n\n        for i in range(2):  # For x and y dimensions\n            if np.isclose(d[i], 0):  # Segment is parallel to slab boundaries\n                if p1_arr[i]  bounds[i, 0] or p1_arr[i] > bounds[i, 1]:\n                    return False  # Segment is outside the slab\n            else:\n                t1 = (bounds[i, 0] - p1_arr[i]) / d[i]\n                t2 = (bounds[i, 1] - p1_arr[i]) / d[i]\n\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                \n                t_near = max(t_near, t1)\n                t_far = min(t_far, t2)\n        \n        return t_near  t_far\n\n    def _process_step(self, step_data):\n        \"\"\"\n        Processes a single crack step to determine enrichment sets and construct the matrix A.\n        \"\"\"\n        c1, c2, tip, r_tip = np.array(step_data['c1']), np.array(step_data['c2']), np.array(step_data['t']), step_data['R_tip']\n\n        # Determine Heaviside-enriched nodes\n        E_H = set()\n        for elem in self.elements:\n            if self._segment_intersects_box(c1, c2, elem['bbox']):\n                E_H.update(elem['nodes'])\n        \n        # Determine branch-enriched nodes\n        E_B = set()\n        for i, node_coord in enumerate(self.nodes):\n            dist_to_tip = np.linalg.norm(node_coord - tip)\n            if dist_to_tip  r_tip and not np.isclose(dist_to_tip, r_tip):\n                E_B.add(i)\n\n        E_H_sorted, E_B_sorted = sorted(list(E_H)), sorted(list(E_B))\n        \n        num_d, num_a, num_b = self.num_nodes, len(E_H_sorted), len(E_B_sorted)\n        total_dofs = num_d + num_a + num_b\n        A = np.zeros((self.num_nodes, total_dofs))\n        A[:, :num_d] = np.identity(num_d)\n        \n        # Add columns for Heaviside DOFs\n        crack_vec = c2 - c1\n        normal = np.array([-crack_vec[1], crack_vec[0]])\n        for i, node_idx in enumerate(E_H_sorted):\n            node_coord = self.nodes[node_idx]\n            phi = normal @ (node_coord - c1) + self.epsilon * (self.w_vec @ node_coord)\n            H_val = np.sign(phi)\n            if np.isclose(H_val, 0): H_val = 1.0  # Robust tie-breaker\n            A[node_idx, num_d + i] = H_val\n            \n        # Add columns for Branch DOFs\n        for i, node_idx in enumerate(E_B_sorted):\n            node_coord = self.nodes[node_idx]\n            B_val = np.sqrt(np.linalg.norm(node_coord - tip))\n            A[node_idx, num_d + num_a + i] = B_val\n\n        return A, E_H, E_B\n\n    def run(self):\n        \"\"\"\n        Executes the full analysis for the test case.\n        \"\"\"\n        # Process step s\n        A_s, E_H_s, E_B_s = self._process_step(self.case_data['s'])\n\n        # Build test DOF vector for step s\n        E_H_s_sorted, E_B_s_sorted = sorted(list(E_H_s)), sorted(list(E_B_s))\n        num_d_s, num_a_s, num_b_s = self.num_nodes, len(E_H_s_sorted), len(E_B_s_sorted)\n        d_vec_s = np.zeros(num_d_s + num_a_s + num_b_s)\n        \n        for i in range(self.num_nodes):\n            x, y = self.nodes[i]\n            d_vec_s[i] = np.sin(np.pi * x) * np.cos(np.pi * y)\n        for i, node_idx in enumerate(E_H_s_sorted):\n            x, y = self.nodes[node_idx]\n            d_vec_s[num_d_s + i] = 0.1 * (x + y)\n        for i, node_idx in enumerate(E_B_s_sorted):\n            x, y = self.nodes[node_idx]\n            d_vec_s[num_d_s + num_a_s + i] = 0.05 * (x - y)\n\n        # Process step s+1\n        A_s1, E_H_s1, E_B_s1 = self._process_step(self.case_data['s+1'])\n\n        # Compute prolongation and evaluate\n        P = np.linalg.pinv(A_s1) @ A_s\n        d_vec_s1 = P @ d_vec_s\n        v_s = A_s @ d_vec_s\n        v_s1 = A_s1 @ d_vec_s1\n        delta_max = np.max(np.abs(v_s1 - v_s))\n\n        # Count changes in enriched DOFs\n        N_add = len(E_H_s1 - E_H_s) + len(E_B_s1 - E_B_s)\n        N_rem = len(E_H_s - E_H_s1) + len(E_B_s - E_B_s1)\n            \n        return [delta_max, N_add, N_rem]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            's': {'c1': (0.2, 0.5), 'c2': (0.5, 0.5), 't': (0.5, 0.5), 'R_tip': 0.3},\n            's+1': {'c1': (0.2, 0.5), 'c2': (0.8, 0.5), 't': (0.8, 0.5), 'R_tip': 0.3}\n        },\n        { # Case 2\n            's': {'c1': (0.2, 0.2), 'c2': (0.5, 0.5), 't': (0.5, 0.5), 'R_tip': 0.25},\n            's+1': {'c1': (0.2, 0.2), 'c2': (0.8, 0.5), 't': (0.8, 0.5), 'R_tip': 0.25}\n        },\n        { # Case 3\n            's': {'c1': (0.0, 0.5), 'c2': (0.5, 0.5), 't': (0.5, 0.5), 'R_tip': 0.2},\n            's+1': {'c1': (0.0, 0.5), 'c2': (0.9, 0.5), 't': (0.9, 0.5), 'R_tip': 0.2}\n        }\n    ]\n    \n    mesh_params = {'nx': 2, 'ny': 2}\n    epsilon = 1e-8\n    w_vec = (1, 2)\n    \n    results = []\n    for case in test_cases:\n        solver = CrackUpdateSolver(case, mesh_params, epsilon, w_vec)\n        result = solver.run()\n        results.append(f\"[{result[0]:.10e},{result[1]},{result[2]}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2551517"}]}