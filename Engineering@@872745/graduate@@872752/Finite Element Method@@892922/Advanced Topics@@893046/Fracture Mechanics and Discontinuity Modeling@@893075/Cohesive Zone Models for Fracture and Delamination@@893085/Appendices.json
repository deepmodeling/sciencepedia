{"hands_on_practices": [{"introduction": "A cohesive zone model is only as powerful as its parameters are representative of a real material's fracture behavior. This first practice bridges the gap between theory and experiment by demonstrating how to calibrate a simple yet effective triangular cohesive law. Using data from a hypothetical Double Cantilever Beam (DCB) test, you will apply fundamental principles of fracture mechanics to extract the critical fracture energy, $G_{Ic}$, and peak cohesive stress, $\\sigma_c$, which are the cornerstones of any cohesive model. [@problem_id:2544709]", "problem": "A Double Cantilever Beam (DCB) test is performed on a symmetric laminate with a precrack along a weak interface to characterize a Mode I cohesive zone law for delamination. The objective is to identify parameters of a triangular traction–separation law in normal opening for a cohesive zone model (CZM): the critical energy release rate $G_{I c}$, the peak normal traction $\\sigma_{c}$, the final separation $\\delta_{f}$, and the initial penalty stiffness $K$ (normal mode). Assume linear elasticity, small strains, negligible shear deformation, and negligible root rotation. Use Euler–Bernoulli beam theory and the Irwin–Kies relation for energy release rate. Two identical arms of thickness $h$ and width $b$ are made of an isotropic linear elastic solid with Young’s modulus $E$. The applied load $P$ is the force applied to each arm, and the measured opening $\\delta$ is the relative opening between the two load points.\n\nGiven data:\n- Geometry and material: $E = 70 \\times 10^{9}$, $b = 0.020$, $h = 0.003$.\n- Crack length at the onset of crack growth: $a = 0.050$.\n- Measured load and opening at the onset of growth: $P_{\\text{on}} = 60$, $\\delta_{\\text{on}} = 0.0018$.\n- Measured initial (pre-damage) linear response at the same crack length: $P_{\\ell} = 30$, $\\delta_{\\ell} = 0.00090$.\n- Final separation at complete decohesion from digital image correlation: $\\delta_{f} = 20 \\times 10^{-6}$.\n- For matching initial slope to determine the penalty $K$, approximate the interface contribution by an effective linear spring of length $L_{\\text{eff}} = 0.010$ acting in series with the bending compliance of the uncracked arms.\n\nTasks:\n1) Using the Irwin–Kies relation for Mode I, $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$, together with Euler–Bernoulli beam theory for two identical cantilevers, derive a closed-form expression for $G_{I}$ in terms of $P$, $\\delta$, $b$, and $a$, and evaluate $G_{I c}$ at the onset condition.\n2) For a triangular traction–separation law in Mode I, use the area condition $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$ to compute $\\sigma_{c}$.\n3) Determine the penalty stiffness $K$ by matching the initial slope: model the intact structure as the series combination of the bending compliance of the DCB arms at crack length $a$ and an effective cohesive spring of stiffness $k_{c} = b K L_{\\text{eff}}$. Use the measured initial compliance $C_{\\exp} = \\delta_{\\ell}/P_{\\ell}$ to solve for $K$.\n\nReport the ordered triple $\\left(G_{I c},\\,\\sigma_{c},\\,K\\right)$ rounded to three significant figures, expressing $G_{I c}$ in $\\text{J}\\,\\text{m}^{-2}$, $\\sigma_{c}$ in $\\text{MPa}$, and $K$ in $\\text{N}\\,\\text{mm}^{-3}$. Do not include units in your final boxed answer; the order of entries must follow the order specified here.", "solution": "The problem statement is first subjected to a rigorous validation.\n\nStep 1: Extracted Givens.\n- Material property: Young’s modulus $E = 70 \\times 10^{9}$.\n- Geometric properties: beam width $b = 0.020$, beam thickness (single arm) $h = 0.003$.\n- Crack length at onset of growth: $a = 0.050$.\n- Measured data at onset of growth: load $P_{\\text{on}} = 60$, opening $\\delta_{\\text{on}} = 0.0018$.\n- Measured data in the linear elastic regime for the same crack length: load $P_{\\ell} = 30$, opening $\\delta_{\\ell} = 0.00090$.\n- Final separation at complete failure: $\\delta_{f} = 20 \\times 10^{-6}$.\n- Effective length for penalty stiffness calculation: $L_{\\text{eff}} = 0.010$.\n- Governing relations: Irwin–Kies relation $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$, Euler–Bernoulli beam theory, triangular cohesive law area $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$, and series compliance model for initial stiffness $C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$ where $k_{c} = \\frac{1}{C_{\\text{coh}}} = b K L_{\\text{eff}}$.\n- Assumptions: linear elasticity, small strains, negligible shear deformation, negligible root rotation. All numerical values are assumed to be in base SI units (meters, Newtons, Pascals) unless specified otherwise.\n\nStep 2: Validation.\nThe problem is scientifically grounded, employing standard principles of linear elastic fracture mechanics and beam theory to analyze a Double Cantilever Beam (DCB) test, a common experimental procedure. The provided data are self-consistent; for instance, the compliance calculated from the linear response point, $C_{\\ell} = \\delta_{\\ell} / P_{\\ell} = 0.00090 / 30 = 3 \\times 10^{-5}$, is identical to the compliance at the onset point, $C_{\\text{on}} = \\delta_{\\text{on}} / P_{\\text{on}} = 0.0018 / 60 = 3 \\times 10^{-5}$, which is physically correct as the onset of growth marks the end of the linear regime. The problem is well-posed, objective, and contains sufficient information for a unique solution. It does not violate any of the specified invalidity criteria.\n\nStep 3: Verdict.\nThe problem is valid. A solution will be furnished.\n\nThe solution proceeds by addressing the three specified tasks in order.\n\nTask 1: Derivation of $G_{I}$ and calculation of $G_{I c}$.\nAccording to Euler-Bernoulli beam theory, the deflection $w$ at the end of a single cantilever beam of length $a$ under a load $P$ is given by:\n$$w = \\frac{Pa^{3}}{3EI}$$\nwhere $E$ is the Young's modulus and $I$ is the second moment of area of the beam's cross-section. For a rectangular cross-section of width $b$ and thickness $h$, $I = \\frac{bh^{3}}{12}$. The DCB specimen consists of two such beams, so the total opening $\\delta$ at the load points is twice the deflection of a single arm:\n$$\\delta = 2w = \\frac{2Pa^{3}}{3EI} = \\frac{2Pa^{3}}{3E \\left( \\frac{bh^{3}}{12} \\right)} = \\frac{8Pa^{3}}{Ebh^{3}}$$\nThe compliance, $C$, of the specimen is defined as the ratio of opening to load, $C = \\delta/P$.\n$$C(a) = \\frac{8a^{3}}{Ebh^{3}}$$\nThe problem specifies using the Irwin–Kies relation for the Mode I energy release rate, $G_{I}$:\n$$G_{I} = \\frac{P^{2}}{2b} \\frac{dC}{da}$$\nWe compute the derivative of the compliance with respect to the crack length $a$:\n$$\\frac{dC}{da} = \\frac{d}{da} \\left( \\frac{8a^{3}}{Ebh^{3}} \\right) = \\frac{24a^{2}}{Ebh^{3}}$$\nSubstituting this derivative into the Irwin–Kies relation gives an expression for $G_{I}$:\n$$G_{I} = \\frac{P^{2}}{2b} \\left( \\frac{24a^{2}}{Ebh^{3}} \\right) = \\frac{12P^{2}a^{2}}{b^{2}Eh^{3}}$$\nTo express $G_{I}$ in terms of $P$, $\\delta$, $b$, and $a$ as requested, we use the compliance relation $C = \\delta/P$ and note that $\\frac{dC}{da} = 3 \\frac{C}{a}$. Thus:\n$$G_{I} = \\frac{P^{2}}{2b} \\left( 3 \\frac{C}{a} \\right) = \\frac{3P^{2}}{2ab} \\left( \\frac{\\delta}{P} \\right) = \\frac{3P\\delta}{2ab}$$\nThis is the required closed-form expression. The critical energy release rate, $G_{I c}$, is evaluated at the onset of crack growth using the provided data: $P_{\\text{on}} = 60\\,\\text{N}$, $\\delta_{\\text{on}} = 0.0018\\,\\text{m}$, $a = 0.050\\,\\text{m}$, and $b = 0.020\\,\\text{m}$.\n$$G_{I c} = \\frac{3 P_{\\text{on}} \\delta_{\\text{on}}}{2ab} = \\frac{3 \\times 60 \\times 0.0018}{2 \\times 0.050 \\times 0.020} = \\frac{0.324}{0.002} = 162\\,\\text{J}\\,\\text{m}^{-2}$$\n\nTask 2: Computation of the peak normal traction $\\sigma_{c}$.\nFor a triangular traction-separation law, the fracture energy $G_{I c}$ is the area of the triangle defined by the peak traction $\\sigma_{c}$ and the final separation $\\delta_{f}$:\n$$G_{I c} = \\frac{1}{2} \\sigma_{c} \\delta_{f}$$\nSolving for $\\sigma_{c}$:\n$$\\sigma_{c} = \\frac{2G_{I c}}{\\delta_{f}}$$\nUsing the calculated value $G_{I c} = 162\\,\\text{J}\\,\\text{m}^{-2}$ and the given final separation $\\delta_{f} = 20 \\times 10^{-6}\\,\\text{m}$:\n$$\\sigma_{c} = \\frac{2 \\times 162}{20 \\times 10^{-6}} = \\frac{324}{20 \\times 10^{-6}} = 16.2 \\times 10^{6}\\,\\text{Pa}$$\nAs $1\\,\\text{MPa} = 10^{6}\\,\\text{Pa}$, the peak traction is $\\sigma_{c} = 16.2\\,\\text{MPa}$.\n\nTask 3: Determination of the penalty stiffness $K$.\nThe initial response of the specimen is modeled as the series combination of the beam bending compliance, $C_{\\text{beam}}$, and an effective cohesive compliance, $C_{\\text{coh}}$. The total measured compliance, $C_{\\exp}$, is the sum of these two:\n$$C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$$\nThe experimental compliance is determined from the linear response data:\n$$C_{\\exp} = \\frac{\\delta_{\\ell}}{P_{\\ell}} = \\frac{0.00090}{30} = 3.0 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\nThe beam bending compliance is given by the theoretical expression derived previously:\n$$C_{\\text{beam}} = \\frac{8a^{3}}{Ebh^{3}} = \\frac{8 \\times (0.050)^{3}}{(70 \\times 10^{9}) \\times 0.020 \\times (0.003)^{3}} = \\frac{1 \\times 10^{-3}}{37.8} \\approx 2.6455 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\nThe cohesive compliance is found by subtraction:\n$$C_{\\text{coh}} = C_{\\exp} - C_{\\text{beam}} = (3.0 \\times 10^{-5}) - (2.6455 \\times 10^{-5}) = 0.3545 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\nThe cohesive compliance is related to the penalty stiffness $K$ through an effective spring stiffness $k_c = 1/C_{\\text{coh}}$. This spring represents the integrated effect of the penalty stiffness over an effective area $A_{\\text{eff}} = b L_{\\text{eff}}$. The stiffness of the cohesive zone is given as $k_{c} = b K L_{\\text{eff}}$. Therefore:\n$$C_{\\text{coh}} = \\frac{1}{b K L_{\\text{eff}}}$$\nSolving for $K$:\n$$K = \\frac{1}{b L_{\\text{eff}} C_{\\text{coh}}} = \\frac{1}{0.020 \\times 0.010 \\times (0.3545 \\times 10^{-5})} = \\frac{1}{7.09 \\times 10^{-10}} \\approx 1.4104 \\times 10^{9}\\,\\text{N}\\,\\text{m}^{-3}$$\nThe result must be converted to $\\text{N}\\,\\text{mm}^{-3}$. The conversion factor is $1\\,\\text{N}\\,\\text{m}^{-3} = 1\\,\\text{N}\\,(1000\\,\\text{mm})^{-3} = 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3}$.\n$$K = (1.4104 \\times 10^{9}) \\times 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3} \\approx 1.4104\\,\\text{N}\\,\\text{mm}^{-3}$$\nRounding to three significant figures, $K = 1.41\\,\\text{N}\\,\\text{mm}^{-3}$.\n\nThe final ordered triple $(G_{I c}, \\sigma_{c}, K)$, with values rounded to three significant figures, is $(162\\,\\text{J}\\,\\text{m}^{-2}, 16.2\\,\\text{MPa}, 1.41\\,\\text{N}\\,\\text{mm}^{-3})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 162 & 16.2 & 1.41 \\end{pmatrix}\n}\n$$", "id": "2544709"}, {"introduction": "While simple cohesive laws are useful, many engineering materials exhibit irreversible deformation (plasticity) within the fracture process zone. This exercise guides you through the implementation of a rate-independent plasticity model for a cohesive interface, a crucial step towards more realistic simulations. You will derive and implement the \"return-mapping\" algorithm, a fundamental numerical technique in computational mechanics used to enforce the plastic yield condition, and derive the corresponding consistent tangent operator required for robust numerical solutions. [@problem_id:2544669]", "problem": "You are tasked with developing and implementing a robust return-mapping algorithm for an interface with rate-independent associative plasticity in the context of a cohesive zone formulation. The interface traction $\\mathbf{t} \\in \\mathbb{R}^2$ (with components corresponding to the normal and shear directions) is related to the displacement jump $\\boldsymbol{\\delta} \\in \\mathbb{R}^2$ and the plastic displacement jump $\\boldsymbol{\\delta}^{\\mathrm{p}} \\in \\mathbb{R}^2$ through a linear elastic relation. The yield condition and the associative flow rule act in jump space. Your program must compute the updated traction and the algorithmic consistent tangent for several test cases.\n\nBegin from the following fundamental laws and definitions of rate-independent associative plasticity and linear elasticity:\n- The elastic constitutive relation for the interface is $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$, where $\\mathbf{K} \\in \\mathbb{R}^{2 \\times 2}$ is a symmetric positive-definite interface stiffness.\n- The yield function is convex and given by\n$$\nf(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0,\n$$\nwhere $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$ is symmetric positive-definite and $t_c &gt; 0$.\n- The Kuhn–Tucker conditions for plastic admissibility are\n$$\nf(\\mathbf{t}) \\le 0,\\quad \\Delta\\gamma \\ge 0,\\quad \\Delta\\gamma\\,f(\\mathbf{t}) = 0,\n$$\nwhere $\\Delta\\gamma \\ge 0$ is the plastic multiplier increment.\n- The associative flow rule in jump space is\n$$\n\\Delta \\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma\\,\\frac{\\partial f}{\\partial \\mathbf{t}}(\\mathbf{t}).\n$$\n\nYou must derive a return-mapping algorithm that, given the elastic predictor and the yield function above, computes the updated traction $\\mathbf{t}_{n+1}$ and the consistent algorithmic tangent $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$ to ensure quadratic convergence of a Newton method at the global level. Use only the fundamental statements above as your starting point, and do not assume any specialized shortcut formulas.\n\nSpecifically, proceed as follows:\n1. Given $\\boldsymbol{\\delta}_{n+1}$ and $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n}$, form the elastic predictor (trial state)\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big)\n$$\nand test yield admissibility via $f(\\mathbf{t}^{\\mathrm{tr}})$.\n2. If $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$, the step is elastic: set $\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}$ and $\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{K}$.\n3. If $f(\\mathbf{t}^{\\mathrm{tr}}) &gt; 0$, enforce consistency by returning to the yield surface using a Lagrange multiplier $\\lambda \\ge 0$ associated with the constraint $f(\\mathbf{t}_{n+1}) = 0$ and the stationarity of the incremental potential. Show that the stationarity conditions lead to the nonlinear system\n$$\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - \\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0},\\quad f(\\mathbf{t}_{n+1}) = 0,\n$$\nwhich you must solve for $\\mathbf{t}_{n+1}$ and $\\lambda$. Demonstrate that this reduces to a one-dimensional root-finding problem in $\\lambda$.\n4. Derive the exact consistent algorithmic tangent $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$ by linearizing the above system with respect to $\\boldsymbol{\\delta}_{n+1}$, assuming perfect plasticity (no hardening). Your final expression must be obtained by eliminating $\\mathrm{d}\\lambda$ from the linearized equations so that $\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{C}_{\\mathrm{alg}}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$.\n\nAll quantities are nondimensional; no physical units are required.\n\nYour program must implement this return-mapping algorithm and produce the requested outputs for the following test suite. Each test case provides $\\mathbf{K}$, $\\mathbf{A}$, $t_c$, $\\boldsymbol{\\delta}_{n+1}$, and $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$. For each test, compute:\n- The updated traction components $\\mathbf{t}_{n+1} = [t_n,\\, t_s]^\\mathsf{T}$.\n- The consistent tangent matrix $\\mathbf{C}_{\\mathrm{alg}} \\in \\mathbb{R}^{2\\times 2}$, reported as its entries $C_{11}, C_{12}, C_{21}, C_{22}$.\n\nTest suite:\n- Test $1$ (elastic, diagonal $\\mathbf{K}$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.002 \\\\ 0.002 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $2$ (plastic, diagonal $\\mathbf{K}$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $3$ (on the yield surface, treat as elastic if $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} \\frac{3}{1000\\sqrt{2}} \\\\ \\frac{2}{500\\sqrt{2}} \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $4$ (plastic, coupled $\\mathbf{K}$):\n  - $\\mathbf{K} = \\begin{bmatrix} 1200 & 200 \\\\ 200 & 800 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n- Test $5$ (elastic with nonzero prior plastic jump):\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$, $\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$, $t_c = 1$,\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.006 \\\\ 0.0 \\end{bmatrix}$, $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0.004 \\\\ 0.0 \\end{bmatrix}$.\n\nProgram output specification:\n- For each test, output the list $[t_n, t_s, C_{11}, C_{12}, C_{21}, C_{22}]$, where all entries are rounded to six decimal places.\n- Your program should produce a single line of output containing the results for all tests as a comma-separated list of these lists, enclosed in square brackets, for example:\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$.", "solution": "The problem requires the derivation and implementation of a return-mapping algorithm for rate-independent associative plasticity of a cohesive interface. We must compute the updated traction vector $\\mathbf{t}_{n+1}$ and the consistent algorithmic tangent matrix $\\mathbf{C}_{\\mathrm{alg}}$ for a given set of material parameters and prescribed final displacement jump $\\boldsymbol{\\delta}_{n+1}$. The derivation must proceed from first principles.\n\nLet us begin by formalizing the problem. The state at the beginning of the time increment is known, characterized by the plastic displacement jump $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$. The total displacement jump at the end of the increment, $\\boldsymbol{\\delta}_{n+1}$, is given.\n\nThe governing equations are:\n1.  Elastic Law: $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$\n2.  Yield Function: $f(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0$\n3.  Flow Rule (backward Euler discretization): $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} + \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}$ with $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma \\left. \\frac{\\partial f}{\\partial \\mathbf{t}} \\right|_{\\mathbf{t}_{n+1}}$\n4.  Kuhn-Tucker Loading/Unloading Conditions: $\\Delta\\gamma \\ge 0$, $f(\\mathbf{t}_{n+1}) \\le 0$, $\\Delta\\gamma\\,f(\\mathbf{t}_{n+1}) = 0$\n\nThe gradient of the yield function is:\n$$\n\\frac{\\partial f}{\\partial \\mathbf{t}} = \\frac{\\mathbf{A}\\,\\mathbf{t}}{\\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}}}\n$$\nDuring plastic loading, we have $f(\\mathbf{t}_{n+1}) = 0$, which implies $\\sqrt{\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}} = t_c$. The flow rule thus simplifies to:\n$$\n\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\frac{\\Delta\\gamma}{t_c} \\mathbf{A}\\,\\mathbf{t}_{n+1} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\nwhere we define the scaled (and non-negative) plastic multiplier $\\lambda = \\Delta\\gamma/t_c \\ge 0$.\n\nThe return-mapping algorithm proceeds in two main steps: an elastic trial step followed by a plastic corrector step if necessary.\n\n**Step 1: Elastic Predictor (Trial State)**\nFirst, we assume the entire step is elastic, meaning $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\mathbf{0}$. The trial traction, $\\mathbf{t}^{\\mathrm{tr}}$, is computed using the elastic law:\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n})\n$$\nWe then check for plastic yielding by evaluating the yield function at this trial state:\n$$\nf(\\mathbf{t}^{\\mathrm{tr}}) = \\sqrt{(\\mathbf{t}^{\\mathrm{tr}})^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}^{\\mathrm{tr}}} - t_c\n$$\nIf $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$, the assumption of elasticity is correct. The state is updated as:\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\n$$\n\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\nThe response is purely elastic, so the consistent tangent is simply the elastic stiffness matrix:\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}} = \\frac{\\partial}{\\partial \\boldsymbol{\\delta}_{n+1}} \\left[ \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) \\right] = \\mathbf{K}\n$$\n\n**Step 2: Plastic Corrector (Return Mapping)**\nIf $f(\\mathbf{t}^{\\mathrm{tr}}) > 0$, the trial state lies outside the elastic domain, and a plastic correction is required. The final state $(\\mathbf{t}_{n+1}, \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1})$ must satisfy the constitutive equations and the consistency condition $f(\\mathbf{t}_{n+1}) = 0$.\n\nThe updated traction is related to the trial state by:\n$$\n\\mathbf{t}_{n+1} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1}) = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} - \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}) = \\mathbf{t}^{\\mathrm{tr}} - \\mathbf{K}\\,\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}\n$$\nSubstituting the flow rule $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}$:\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}} - \\lambda\\,\\mathbf{K}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\nRearranging for $\\mathbf{t}_{n+1}$ gives:\n$$\n(\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\nPre-multiplying by $\\mathbf{K}^{-1}$, we obtain:\n$$\n(\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathbf{t}^{\\mathrm{tr}} = \\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\nThis leads to the expression for $\\mathbf{t}_{n+1}$ as a function of the unknown multiplier $\\lambda$:\n$$\n\\mathbf{t}_{n+1}(\\lambda) = (\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})^{-1}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) = (\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})^{-1}\\,\\mathbf{t}^{\\mathrm{tr}}\n$$\nThe system of equations to solve for the plastic step, as given in the problem, consists of this relation and the consistency condition:\n$$\n\\begin{cases}\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - (\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0} \\\\\nf(\\mathbf{t}_{n+1}) = 0\n\\end{cases}\n$$\nTo solve this system, we substitute the expression for $\\mathbf{t}_{n+1}(\\lambda)$ into the consistency condition $f(\\mathbf{t}_{n+1})=0$, which is equivalent to $\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} - t_c^2 = 0$. This yields a scalar nonlinear residual equation for $\\lambda$:\n$$\nR(\\lambda) = \\sqrt{\\mathbf{t}_{n+1}(\\lambda)^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}(\\lambda)} - t_c = 0\n$$\nThis one-dimensional root-finding problem for $\\lambda > 0$ can be solved efficiently using numerical methods such as Newton-Raphson. Once $\\lambda$ is determined, the updated traction $\\mathbf{t}_{n+1}$ is computed.\n\n**Step 3: Derivation of the Consistent Algorithmic Tangent**\nThe consistent tangent operator $\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$ is required for the quadratic convergence of global Newton-Raphson solvers in a finite element context. It is derived by taking the total differential of the system of equations governing the plastic state. We linearize the system:\n1.  $(\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\mathbf{t}^{\\mathrm{tr}}$\n2.  $f(\\mathbf{t}_{n+1}) = 0$\n\nRecalling that $\\mathbf{t}^{\\mathrm{tr}}$ depends on $\\boldsymbol{\\delta}_{n+1}$ via $\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$, we differentiate the first equation:\n$$\n\\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} + (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\,\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}^{-1}\\,(\\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}) = \\mathrm{d}\\boldsymbol{\\delta}_{n+1}\n$$\nLet us define $\\mathbf{H}_{\\lambda}^{-1} = \\mathbf{K}^{-1} + \\lambda\\mathbf{A}$. Solving for $\\mathrm{d}\\mathbf{t}_{n+1}$:\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1})\n$$\nNext, we differentiate the consistency condition $f(\\mathbf{t}_{n+1})=0$, which implies that any variation must lie in the tangent plane of the yield surface:\n$$\n\\mathrm{d}f = \\left(\\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}}\\right)^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0\n$$\nLet $\\mathbf{m} = \\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}} = \\frac{\\mathbf{A}\\,\\mathbf{t}_{n+1}}{t_c}$. The condition is $\\mathbf{m}^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0$.\nSubstituting the expression for $\\mathrm{d}\\mathbf{t}_{n+1}$:\n$$\n\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) = 0\n$$\nWe solve this equation for the differential of the multiplier, $\\mathrm{d}\\lambda$:\n$$\n\\mathrm{d}\\lambda = \\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\nThis expression relates the increment in the plastic multiplier to the increment in the total displacement jump. Finally, we substitute $\\mathrm{d}\\lambda$ back into the expression for $\\mathrm{d}\\mathbf{t}_{n+1}$ to eliminate the dependency on $\\mathrm{d}\\lambda$:\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\\,\\left(\\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\\right)\n$$\nUsing the outer product notation $(\\mathbf{u} \\otimes \\mathbf{v}) \\mathbf{w} = \\mathbf{u} (\\mathbf{v}^\\mathsf{T} \\mathbf{w})$, we can identify the operator mapping $\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$ to $\\mathrm{d}\\mathbf{t}_{n+1}$:\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{H}_{\\lambda} - \\frac{(\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) \\otimes (\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda})}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\nwhere $\\mathbf{H}_{\\lambda} = (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})^{-1}$ and $\\mathbf{m} = \\mathbf{A}\\,\\mathbf{t}_{n+1} / t_c$. This is the exact consistent algorithmic tangent for the plastic step.\n\nThe implementation will now follow this derived algorithm for the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the cohesive zone plasticity problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (elastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.002, 0.002]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 2 (plastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 3 (on the yield surface)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([3.0 / (1000.0 * np.sqrt(2.0)), 2.0 / (500.0 * np.sqrt(2.0))]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 4 (plastic, coupled K)\n        {\n            'K': np.array([[1200.0, 200.0], [200.0, 800.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 5 (elastic with prior plastic jump)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.006, 0.0]),\n            'delta_p_n': np.array([0.004, 0.0])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K = case['K']\n        A = case['A']\n        tc = case['tc']\n        delta_n1 = case['delta']\n        delta_p_n = case['delta_p_n']\n\n        # Step 1: Elastic Predictor\n        delta_e_tr = delta_n1 - delta_p_n\n        t_tr = K @ delta_e_tr\n        \n        # Check yield condition\n        f_tr_val_sq = t_tr.T @ A @ t_tr\n        f_tr = np.sqrt(f_tr_val_sq) - tc\n\n        if f_tr <= 1e-12:  # Using tolerance for floating point comparison\n            # Elastic step\n            t_n1 = t_tr\n            C_alg = K\n        else:\n            # Plastic step: return mapping\n            \n            # Formulate the residual function for lambda\n            K_inv = np.linalg.inv(K)\n            \n            def residual(lam):\n                # Using the expression t_n1 = (I + lambda*K*A)^-1 * t_tr\n                # Inversion is expensive, so it's better to solve the linear system\n                # (I + lam*K@A) @ t_n1 = t_tr\n                M = np.eye(2) + lam * K @ A\n                t_n1_lam = np.linalg.solve(M, t_tr)\n                yield_val_sq = t_n1_lam.T @ A @ t_n1_lam\n                return np.sqrt(yield_val_sq) - tc\n\n            # Solve for lambda using a root-finding algorithm\n            sol = root_scalar(residual, bracket=[0, 1e-2], method='brentq')\n            lam = sol.root\n            \n            # Update traction vector\n            M_final = np.eye(2) + lam * K @ A\n            t_n1 = np.linalg.solve(M_final, t_tr)\n            \n            # Calculate consistent tangent\n            H_lam = np.linalg.inv(K_inv + lam * A)\n            m = (A @ t_n1) / tc\n            \n            numerator_vec1 = H_lam @ A @ t_n1\n            numerator_vec2_T = m.T @ H_lam\n            \n            denominator = m.T @ H_lam @ A @ t_n1\n            \n            C_alg = H_lam - np.outer(numerator_vec1, numerator_vec2_T) / denominator\n\n        # Format output\n        tn, ts = t_n1[0], t_n1[1]\n        C11, C12 = C_alg[0, 0], C_alg[0, 1]\n        C21, C22 = C_alg[1, 0], C_alg[1, 1]\n        \n        results.append(\n            f\"[{tn:.6f},{ts:.6f},{C11:.6f},{C12:.6f},{C21:.6f},{C22:.6f}]\"\n        )\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2544669"}, {"introduction": "The fracture response of many materials, particularly polymers and biological tissues, is highly dependent on the rate of loading. To capture such phenomena, we must move beyond rate-independent models to incorporate viscoelasticity. This practice focuses on a Maxwell model—a spring and dashpot in series—to represent time-dependent cohesive behavior. You will derive the governing differential equation, discretize it in time using the robust backward Euler method, and compute the consistent tangent, providing a complete framework for implementing a viscoelastic cohesive law in an implicit finite element code. [@problem_id:2544693]", "problem": "Consider a one-dimensional cohesive interface modeled by a Maxwell element in series, comprising a linear spring and a linear dashpot. Let the scalar opening displacement be denoted by $\\delta(t)$, and the scalar traction by $t(t)$. For a series connection, the traction is the same in both constituents and the total opening displacement is the sum of the spring and dashpot openings. Assume a linear spring with stiffness $k$ and a linear dashpot with viscosity $\\eta$, both positive constants. Use the following fundamental base:\n\n- Series arrangement equilibrium: the traction is the same in the spring and the dashpot, i.e., $t_{\\text{spring}}(t) = t_{\\text{dashpot}}(t) = t(t)$.\n- Kinematic additivity in series: $\\delta(t) = \\delta_{\\text{spring}}(t) + \\delta_{\\text{dashpot}}(t)$.\n- Linear spring law: $t(t) = k\\,\\delta_{\\text{spring}}(t)$.\n- Linear dashpot law: $t(t) = \\eta\\,\\dot{\\delta}_{\\text{dashpot}}(t)$.\n- Time discretization by the backward Euler method over a time step of size $\\Delta t > 0$ from $t_n$ to $t_{n+1}$ with known $(\\delta_n, t_n)$ and prescribed $\\delta_{n+1}$.\n\nYour tasks are:\n\n1) Starting only from the fundamental laws and definitions above, derive the first-order ordinary differential equation governing $t(t)$ in terms of $\\delta(t)$, and then derive a fully discrete update for the traction $t_{n+1}$ using the backward Euler method over the interval $[t_n, t_{n+1}]$. Your final discrete update must be expressed in terms of $k$, $\\eta$, $\\Delta t$, $\\delta_n$, $\\delta_{n+1}$, and $t_n$.\n\n2) Derive the algorithmic consistent tangent (the consistent Jacobian) associated with your backward Euler discretization, i.e., the derivative $\\dfrac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$, holding $k$, $\\eta$, $\\Delta t$, $\\delta_n$, and $t_n$ fixed.\n\n3) Implement a program that, given $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$, computes and returns both the updated traction $t_{n+1}$ and the consistent tangent $\\dfrac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$. The program must apply your derived closed-form formulas from parts $(1)$ and $(2)$.\n\nPhysical and numerical units:\n- Report the traction $t_{n+1}$ in Pascals (Pa).\n- Report the tangent $\\dfrac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$ in Pascal per meter (Pa/m).\n- All angles, if any, must be in radians, though no angles are directly involved here.\n- All numeric answers must be printed as floating-point numbers.\n\nTest suite:\nUse the following parameter sets, each specified as $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$, with the units $(\\text{m}, \\text{Pa}, \\text{m}, \\text{s}, \\text{Pa/m}, \\text{Pa}\\cdot\\text{s}/\\text{m})$:\n\n- Case A (general case): $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (0, 0, 10^{-4}, 10^{-2}, 2\\times 10^{6}, 2\\times 10^{3})$.\n- Case B (very small time step): $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (10^{-5}, 10^{2}, 3\\times 10^{-5}, 10^{-9}, 10^{6}, 10^{3})$.\n- Case C (very large time step): $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (0, 0, 10^{-3}, 10^{1}, 10^{6}, 10^{3})$.\n- Case D (very large viscosity): $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (5\\times 10^{-4}, 2.5\\times 10^{2}, 10^{-3}, 1, 10^{6}, 10^{12})$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for all four cases as a comma-separated list enclosed in square brackets. For each case, output the traction followed by the tangent, so the overall result must be in the order $[t_{n+1}^{(A)}, \\frac{\\partial t_{n+1}^{(A)}}{\\partial \\delta_{n+1}}, t_{n+1}^{(B)}, \\frac{\\partial t_{n+1}^{(B)}}{\\partial \\delta_{n+1}}, t_{n+1}^{(C)}, \\frac{\\partial t_{n+1}^{(C)}}{\\partial \\delta_{n+1}}, t_{n+1}^{(D)}, \\frac{\\partial t_{n+1}^{(D)}}{\\partial \\delta_{n+1}}]$.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\nStep 1: Extract Givens\nThe problem describes a one-dimensional cohesive interface modeled as a Maxwell element, which consists of a linear spring and a linear dashpot connected in series.\n- Variables: scalar opening displacement $\\delta(t)$, scalar traction $t(t)$.\n- Constants: spring stiffness $k > 0$, dashpot viscosity $\\eta > 0$.\n- Fundamental Laws:\n    1. Series arrangement equilibrium: $t_{\\text{spring}}(t) = t_{\\text{dashpot}}(t) = t(t)$.\n    2. Kinematic additivity in series: $\\delta(t) = \\delta_{\\text{spring}}(t) + \\delta_{\\text{dashpot}}(t)$.\n    3. Linear spring law: $t(t) = k\\,\\delta_{\\text{spring}}(t)$.\n    4. Linear dashpot law: $t(t) = \\eta\\,\\dot{\\delta}_{\\text{dashpot}}(t)$, where $\\dot{(\\cdot)}$ denotes the derivative with respect to time $t$.\n- Numerical Method:\n    - Time discretization using the backward Euler method.\n    - Time step from $t_n$ to $t_{n+1}$ of size $\\Delta t > 0$.\n    - At the beginning of the step, $(\\delta_n, t_n)$ are known.\n    - At the end of the step, the displacement $\\delta_{n+1}$ is prescribed.\n- Test Data: Four sets of parameters $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$ are provided with specified units.\n\nStep 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem is based on the Maxwell model of linear viscoelasticity, a foundational concept in continuum mechanics and material science. The governing equations are standard and correct.\n- **Well-Posed**: The problem is well-posed. It requests the derivation of a first-order ordinary differential equation and its subsequent time-discretization using a standard numerical method (backward Euler). The derivation of the consistent tangent is a standard procedure in computational mechanics for implementing implicit solvers. The inputs are clearly defined, and a unique solution is expected.\n- **Objective**: The problem is stated in precise, objective mathematical and physical terms.\n- **Completeness and Consistency**: All necessary definitions, laws, and parameters are provided. There are no contradictions.\n- **Feasibility and Realism**: The problem is physically realistic and computationally feasible. The provided parameters, including those for testing limit cases, are physically plausible.\n\nStep 3: Verdict and Action\nThe problem is valid. It is scientifically sound, well-posed, and complete. A full, reasoned solution will be provided.\n\n**Part 1: Derivation of the Governing ODE and Discrete Update**\n\nThe objective is to derive a relationship between the traction $t(t)$ and the total opening displacement $\\delta(t)$. We begin with the provided fundamental laws. The kinematic additivity states:\n$$\n\\delta(t) = \\delta_{\\text{spring}}(t) + \\delta_{\\text{dashpot}}(t)\n$$\nDifferentiating this expression with respect to time $t$ yields the relationship between the rates:\n$$\n\\dot{\\delta}(t) = \\dot{\\delta}_{\\text{spring}}(t) + \\dot{\\delta}_{\\text{dashpot}}(t)\n$$\nThe constitutive laws for the spring and dashpot can be rearranged and differentiated to express these rates in terms of the traction $t(t)$ and its rate $\\dot{t}(t)$.\nFrom the linear spring law, $t(t) = k\\,\\delta_{\\text{spring}}(t)$, we have $\\delta_{\\text{spring}}(t) = \\frac{t(t)}{k}$. Differentiating with respect to time gives:\n$$\n\\dot{\\delta}_{\\text{spring}}(t) = \\frac{1}{k}\\dot{t}(t)\n$$\nFrom the linear dashpot law, $t(t) = \\eta\\,\\dot{\\delta}_{\\text{dashpot}}(t)$, we can directly write:\n$$\n\\dot{\\delta}_{\\text{dashpot}}(t) = \\frac{1}{\\eta}t(t)\n$$\nSubstituting these two expressions for the rates back into the differentiated kinematic additivity equation, we get:\n$$\n\\dot{\\delta}(t) = \\frac{1}{k}\\dot{t}(t) + \\frac{1}{\\eta}t(t)\n$$\nRearranging this equation to express $\\dot{t}(t)$ as a function of $t(t)$ and $\\dot{\\delta}(t)$ gives the first-order ordinary differential equation (ODE) for the traction:\n$$\n\\dot{t}(t) = k\\,\\dot{\\delta}(t) - \\frac{k}{\\eta}t(t)\n$$\nThis is the governing ODE for the Maxwell model.\n\nNext, we discretize this ODE using the backward Euler method over a time interval $[t_n, t_{n+1}]$ of duration $\\Delta t = t_{n+1} - t_n$. The backward Euler scheme approximates the time derivative at time $t_{n+1}$ as a finite difference and evaluates all other terms at $t_{n+1}$:\n$$\n\\frac{t_{n+1} - t_n}{\\Delta t} \\approx \\dot{t}(t_{n+1})\n$$\n$$\n\\frac{\\delta_{n+1} - \\delta_n}{\\Delta t} \\approx \\dot{\\delta}(t_{n+1})\n$$\nSubstituting these approximations into the ODE evaluated at $t_{n+1}$ gives the discrete equation:\n$$\n\\frac{t_{n+1} - t_n}{\\Delta t} = k \\left( \\frac{\\delta_{n+1} - \\delta_n}{\\Delta t} \\right) - \\frac{k}{\\eta} t_{n+1}\n$$\nOur goal is to solve for the unknown traction $t_{n+1}$ in terms of the known quantities $t_n$, $\\delta_n$, and the prescribed quantity $\\delta_{n+1}$. First, multiply the entire equation by $\\Delta t$:\n$$\nt_{n+1} - t_n = k (\\delta_{n+1} - \\delta_n) - \\frac{k \\Delta t}{\\eta} t_{n+1}\n$$\nNext, we gather all terms involving $t_{n+1}$ on the left-hand side:\n$$\nt_{n+1} + \\frac{k \\Delta t}{\\eta} t_{n+1} = t_n + k (\\delta_{n+1} - \\delta_n)\n$$\nFactoring out $t_{n+1}$:\n$$\nt_{n+1} \\left( 1 + \\frac{k \\Delta t}{\\eta} \\right) = t_n + k (\\delta_{n+1} - \\delta_n)\n$$\nFinally, isolating $t_{n+1}$ provides the fully discrete update formula:\n$$\nt_{n+1} = \\frac{t_n + k (\\delta_{n+1} - \\delta_n)}{1 + \\frac{k \\Delta t}{\\eta}}\n$$\n\n**Part 2: Derivation of the Algorithmic Consistent Tangent**\n\nThe algorithmic consistent tangent (or consistent Jacobian) is the derivative of the updated unknown variable, $t_{n+1}$, with respect to the prescribed driving variable, $\\delta_{n+1}$. This is required for Newton-Raphson-type iterative solvers in a finite element context. We must calculate the partial derivative $\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$, holding all other parameters and previous-step variables ($k$, $\\eta$, $\\Delta t$, $\\delta_n$, $t_n$) constant.\nWe start with the derived expression for $t_{n+1}$:\n$$\nt_{n+1} = \\frac{t_n + k \\delta_{n+1} - k \\delta_n}{1 + \\frac{k \\Delta t}{\\eta}}\n$$\nLet us rewrite this to isolate the term dependent on $\\delta_{n+1}$:\n$$\nt_{n+1} = \\left( \\frac{1}{1 + \\frac{k \\Delta t}{\\eta}} \\right) (t_n - k \\delta_n + k \\delta_{n+1})\n$$\nThe term in the first parenthesis is a constant with respect to $\\delta_{n+1}$. Therefore, the differentiation is straightforward:\n$$\n\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\frac{\\partial}{\\partial \\delta_{n+1}} \\left[ \\left( \\frac{1}{1 + \\frac{k \\Delta t}{\\eta}} \\right) (t_n - k \\delta_n + k \\delta_{n+1}) \\right]\n$$\n$$\n\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\left( \\frac{1}{1 + \\frac{k \\Delta t}{\\eta}} \\right) \\frac{\\partial}{\\partial \\delta_{n+1}} (t_n - k \\delta_n + k \\delta_{n+1})\n$$\nThe derivative of the term $(t_n - k \\delta_n + k \\delta_{n+1})$ with respect to $\\delta_{n+1}$ is simply $k$.\nThus, the consistent tangent is:\n$$\n\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\frac{k}{1 + \\frac{k \\Delta t}{\\eta}}\n$$\n\n**Part 3: Implementation**\n\nThe derived formulas for $t_{n+1}$ and its derivative $\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$ are implemented in a Python program. The program computes these two values for each of the four test cases provided in the problem statement and formats the output as required. The calculations follow the equations directly.\nFor a given set of parameters $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$:\n1.  The traction is calculated as $t_{n+1} = \\frac{t_n + k \\cdot (\\delta_{n+1} - \\delta_n)}{1 + (k \\cdot \\Delta t) / \\eta}$.\n2.  The consistent tangent is calculated as $\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\frac{k}{1 + (k \\cdot \\Delta t) / \\eta}$.\nThese calculations will be performed for all specified test cases. The final answer will present the numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the updated traction and consistent tangent for a 1D Maxwell model\n    discretized with backward Euler, for a given set of test cases.\n    \"\"\"\n\n    # Test cases from the problem statement.\n    # Each tuple is in the format: (delta_n, t_n, delta_n_plus_1, dt, k, eta)\n    # Units: (m, Pa, m, s, Pa/m, Pa*s/m)\n    test_cases = [\n        # Case A (general case)\n        (0.0, 0.0, 1e-4, 1e-2, 2e6, 2e3),\n        # Case B (very small time step)\n        (1e-5, 100.0, 3e-5, 1e-9, 1e6, 1e3),\n        # Case C (very large time step)\n        (0.0, 0.0, 1e-3, 10.0, 1e6, 1e3),\n        # Case D (very large viscosity)\n        (5e-4, 250.0, 1e-3, 1.0, 1e6, 1e12),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_n, t_n, delta_n_plus_1, dt, k, eta = case\n\n        # Derived formula for the updated traction t_{n+1}\n        # t_{n+1} = (t_n + k * (delta_{n+1} - delta_n)) / (1 + (k * dt) / eta)\n        numerator_t = t_n + k * (delta_n_plus_1 - delta_n)\n        denominator = 1.0 + (k * dt) / eta\n        t_n_plus_1 = numerator_t / denominator\n\n        # Derived formula for the consistent tangent d(t_{n+1})/d(delta_{n+1})\n        # tangent = k / (1 + (k * dt) / eta)\n        tangent = k / denominator\n        \n        results.append(t_n_plus_1)\n        results.append(tangent)\n\n    # Final print statement in the exact required format.\n    # Example format: [val1_A,val2_A,val1_B,val2_B,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2544693"}]}