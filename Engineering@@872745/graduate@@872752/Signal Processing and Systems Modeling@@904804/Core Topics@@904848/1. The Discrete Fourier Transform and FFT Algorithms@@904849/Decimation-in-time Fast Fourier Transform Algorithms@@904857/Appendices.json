{"hands_on_practices": [{"introduction": "To fully appreciate the efficiency of the Decimation-in-Time FFT, it is essential to understand its fundamental computational steps. The algorithm begins by reordering the input signal and then proceeds through stages of \"butterfly\" operations that combine smaller DFT results into larger ones. This first exercise provides hands-on practice with the initial stage of a 4-point DIT-FFT, reinforcing the core concepts of bit-reversal and the 2-point DFT butterfly computation that form the foundation of the entire algorithm [@problem_id:1711383].", "problem": "A standard radix-2 decimation-in-time (DIT) Fast Fourier Transform (FFT) algorithm is used to analyze a 4-point discrete-time signal. This algorithm begins by reordering the input sequence $x[n]$ based on a bit-reversal of the time indices. Following this reordering, the first computational stage produces an intermediate sequence, $G[n]$, by performing 2-point Discrete Fourier Transforms (DFTs) on adjacent pairs of the bit-reversed sequence.\n\nConsider an input sequence defined by $x[n] = (1+j)^{n}$ for $n=0, 1, 2, 3$, where $j$ is the imaginary unit satisfying $j^2=-1$.\n\nCalculate the four complex values of the intermediate sequence $G[n] = \\{G[0], G[1], G[2], G[3]\\}$ that result from the first stage of the 4-point DIT-FFT algorithm. Present your answer as a sequence of the four complex numbers.", "solution": "We are given a 4-point radix-2 decimation-in-time FFT. In this formulation, the algorithm first reorders the input $x[n]$ by bit-reversing the time indices, then performs 2-point DFTs on adjacent pairs to produce the intermediate sequence $G[n]$.\n\nFirst compute the input samples:\nFor $x[n]=(1+j)^{n}$ with $j^{2}=-1$:\n$$\nx[0]=(1+j)^{0}=1,\\quad\nx[1]=(1+j)^{1}=1+j,\n$$\n$$\nx[2]=(1+j)^{2}=1+2j+j^{2}=2j,\\quad\nx[3]=(1+j)^{3}=(1+j)\\cdot(1+j)^{2}=(1+j)\\cdot 2j=2j+2j^{2}=-2+2j.\n$$\n\nNext apply bit-reversal on indices $n\\in\\{0,1,2,3\\}$. Using 2-bit reversal:\n$$\n0\\,(00)\\to 0\\,(00),\\quad 1\\,(01)\\to 2\\,(10),\\quad 2\\,(10)\\to 1\\,(01),\\quad 3\\,(11)\\to 3\\,(11).\n$$\nThus the bit-reversed sequence is\n$$\n[x[0],\\,x[2],\\,x[1],\\,x[3]]=[1,\\,2j,\\,1+j,\\,-2+2j].\n$$\n\nThe first stage performs 2-point DFTs on adjacent pairs. For a pair $(a,b)$, the 2-point DFT produces\n$$\nA[0]=a+b,\\qquad A[1]=a-b.\n$$\nApply this to the two adjacent pairs:\n\nPair 1: $(a,b)=(1,\\,2j)$\n$$\nG[0]=1+2j,\\qquad G[1]=1-2j.\n$$\n\nPair 2: $(a,b)=(1+j,\\,-2+2j)$\n$$\nG[2]=(1+j)+(-2+2j)=-1+3j,\\qquad G[3]=(1+j)-(-2+2j)=3-j.\n$$\n\nTherefore, the intermediate sequence is\n$$\nG[n]=\\{\\,1+2j,\\;1-2j,\\;-1+3j,\\;3-j\\,\\}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1+2j & 1-2j & -1+3j & 3-j\\end{pmatrix}}$$", "id": "1711383"}, {"introduction": "A key step in the standard DIT-FFT is the initial reordering of the input sequence according to bit-reversed indices. While simple to describe, performing this permutation efficiently is critical for high-performance FFT implementations. This practice challenges you to derive, from first principles, an elegant and fast algorithm for computing bit-reversed indices using bitwise operations—a classic technique that reveals the power of low-level optimization [@problem_id:2863895].", "problem": "Let $N = 2^{p}$ with integer $p \\geq 1$. Consider the length-$N$ Discrete Fourier Transform (DFT) with\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-\\mathrm{i}\\, \\frac{2\\pi}{N} n k\\right).\n$$\nThe decimation-in-time Fast Fourier Transform (FFT) reorders the input sequence $x[n]$ into bit-reversed index order, so that the recursive radix-$2$ factorization yields an in-place computation without additional permutations between stages.\n\n- Using only fundamental properties of binary representations and the radix-$2$ decomposition of the DFT, formally define the bit-reversal permutation $r(n)$ for $n \\in \\{0,\\dots,2^{p}-1\\}$ in terms of the binary digits of $n$. Your definition must make precise how the binary digits are permuted, and must not assume any prior formula for $r(n)$.\n\n- Derive, from first principles about fixed-width binary words and bit grouping, an $\\mathcal{O}(1)$ method (constant time under a fixed word size) to compute $r(n)$ using only bitwise operations. Concretely, assume a machine word size of at least $16$ bits and restrict to $p \\leq 16$. You may use the bitwise operators bitwise-and `&`, bitwise-or `|`, left shift `<<`, and right shift `>>`, and you may use fixed hexadecimal masks written as `\\mathtt{0x...}`. Provide a finite, fixed sequence of mask-and-shift operations that, for any $n \\in \\{0,\\dots,2^{p}-1\\}$, produces $r(n)$ in a constant number of steps independent of $n$ and $p$ (with $p \\leq 16$). Justify correctness by relating each stage of your mask-and-shift sequence to a well-defined reversal of bit groups.\n\n- Finally, let $p=11$ and $n=1373$. Compute the numerical value of $r(n)$ and give your final answer as a single decimal integer. No rounding is required.", "solution": "The problem is divided into three parts. We will address them in sequence.\n\nFirst, we must formally define the bit-reversal permutation $r(n)$ for an integer $n$ in the set $\\{0, 1, \\dots, 2^p - 1\\}$. Any such integer $n$ has a unique $p$-bit binary representation. Let this representation be\n$$\nn = (b_{p-1} b_{p-2} \\dots b_1 b_0)_2\n$$\nwhere $b_j \\in \\{0, 1\\}$ is the $j$-th bit. The value of $n$ is given by the polynomial representation\n$$\nn = \\sum_{j=0}^{p-1} b_j 2^j\n$$\nThe bit $b_j$ can be formally extracted from $n$ using integer arithmetic: $b_j = \\lfloor n/2^j \\rfloor \\pmod 2$.\n\nThe bit-reversal permutation, $r(n)$, is the integer obtained by reversing the order of the bits in the binary representation of $n$. If the binary representation of $n$ is as given above, the representation of $r(n)$ is\n$$\nr(n) = (b_0 b_1 \\dots b_{p-2} b_{p-1})_2\n$$\nThe value of $r(n)$ is therefore given by the corresponding polynomial representation, where the weight of bit $b_j$ is changed from $2^j$ to $2^{p-1-j}$:\n$$\nr(n) = \\sum_{j=0}^{p-1} b_j 2^{p-1-j}\n$$\nThis constitutes the formal definition of the bit-reversal permutation based on the binary digits of $n$.\n\nSecond, we must derive a constant-time, $\\mathcal{O}(1)$, method to compute $r(n)$ for $p \\le 16$ using bitwise operations. We assume the integer $n$ is stored in a machine word of at least $16$ bits. A naive bit-by-bit reversal requires a loop of $p$ iterations, which is not constant time in the general sense, though it is for a fixed word size. The problem asks for a method with a fixed sequence of operations independent of $n$ and $p$ (for $p \\le 16$), which implies a parallel bit-reversal algorithm.\n\nThe strategy is to reverse the bits by successively swapping adjacent blocks of bits, where the block size doubles at each stage. For a $16$-bit word, this takes $\\log_2(16) = 4$ stages, plus a final alignment step. Let the initial value be $n$. We will denote the result of each stage as $n_k$.\n\nStage 1: Swap adjacent single bits.\nWe wish to swap bit pairs $(b_{15}, b_{14})$, $(b_{13}, b_{12})$, ..., $(b_1, b_0)$. We can isolate all bits at even positions ($b_0, b_2, \\dots, b_{14}$) by masking with $\\mathtt{0x5555} = (0101010101010101)_2$. We isolate all bits at odd positions ($b_1, b_3, \\dots, b_{15}$) by masking with $\\mathtt{0xAAAA} = (1010101010101010)_2$. We then shift the even bits left by $1$ and the odd bits right by $1$ and combine them with a bitwise OR.\n$$\nn_1 = \\left( (n \\ \\& \\mathtt{0xAAAA}) \\gg 1 \\right) \\ | \\ \\left( (n \\ \\& \\mathtt{0x5555}) \\ll 1 \\right)\n$$\nAfter this operation, the bits of $n_1$ are in the order $(b_{14}b_{15}b_{12}b_{13} \\dots b_0b_1)_2$.\n\nStage 2: Swap adjacent $2$-bit blocks.\nThe pairs of bits are now in reversed order. We next swap adjacent $2$-bit blocks. For example, we swap $(b_{14}b_{15})$ with $(b_{12}b_{13})$. We isolate the upper $2$-bit blocks in each $4$-bit nibble using the mask $\\mathtt{0xCCCC} = (1100110011001100)_2$ and shift them right by $2$. We isolate the lower $2$-bit blocks using $\\mathtt{0x3333} = (0011001100110011)_2$ and shift them left by $2$.\n$$\nn_2 = \\left( (n_1 \\ \\& \\mathtt{0xCCCC}) \\gg 2 \\right) \\ | \\ \\left( (n_1 \\ \\& \\mathtt{0x3333}) \\ll 2 \\right)\n$$\nThe bits are now in the order $(b_{12}b_{13}b_{14}b_{15} \\dots b_0b_1b_2b_3)_2$.\n\nStage 3: Swap adjacent $4$-bit blocks.\nWe proceed by swapping adjacent $4$-bit blocks (nibbles). The masks are $\\mathtt{0xF0F0} = (1111000011110000)_2$ and $\\mathtt{0x0F0F} = (0000111100001111)_2$, and the shift is by $4$.\n$$\nn_3 = \\left( (n_2 \\ \\& \\mathtt{0xF0F0}) \\gg 4 \\right) \\ | \\ \\left( (n_2 \\ \\& \\mathtt{0x0F0F}) \\ll 4 \\right)\n$$\nThe bit order becomes $(b_8 \\dots b_{15} b_0 \\dots b_7)_2$.\n\nStage 4: Swap adjacent $8$-bit blocks.\nFinally, we swap the two $8$-bit bytes of the $16$-bit word. The masks are $\\mathtt{0xFF00} = (1111111100000000)_2$ and $\\mathtt{0x00FF} = (0000000011111111)_2$, and the shift is by $8$.\n$$\nn_4 = \\left( (n_3 \\ \\& \\mathtt{0xFF00}) \\gg 8 \\right) \\ | \\ \\left( (n_3 \\ \\& \\mathtt{0x00FF}) \\ll 8 \\right)\n$$\nExecuting these four stages results in a full reversal of the $16$ bits of the word. If $n = (0 \\dots 0 b_{p-1} \\dots b_0)_2$, then $n_4 = (b_0 \\dots b_{p-1} 0 \\dots 0)_2$. The reversed $p$-bit sequence now occupies the most significant $p$ bits of the $16$-bit word.\n\nFinal Step: Alignment.\nTo obtain the final integer value, we must right-shift the result to move the reversed bits to the least significant positions. The number of leading zeros in the original $p$-bit number (within the $16$-bit word) was $16-p$. These have become trailing zeros. We must shift right by this amount.\n$$\nr(n) = n_4 \\gg (16 - p)\n$$\nThis sequence of five operations (four swaps and one final shift) is constant for any $n$ and any $p \\le 16$, thus satisfying the $\\mathcal{O}(1)$ requirement.\n\nThird, we compute the numerical value of $r(n)$ for $p=11$ and $n=1373$.\nFirst, we find the $11$-bit binary representation of $n=1373$.\n$$\n1373 = 1024 + 256 + 64 + 16 + 8 + 4 + 1\n$$\n$$\n1373 = 1 \\cdot 2^{10} + 0 \\cdot 2^9 + 1 \\cdot 2^8 + 0 \\cdot 2^7 + 1 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0\n$$\nSo, the $11$-bit representation is $n = (10101011101)_2$. The bits are $b_{10} = 1, b_9=0, b_8=1, b_7=0, b_6=1, b_5=0, b_4=1, b_3=1, b_2=1, b_1=0, b_0=1$.\n\nTo find $r(n)$, we reverse this bit string to get $(10111010101)_2$.\nNow, we convert this reversed binary number back to its decimal integer value.\n$$\nr(1373) = (10111010101)_2\n$$\n$$\nr(1373) = 1 \\cdot 2^{10} + 0 \\cdot 2^9 + 1 \\cdot 2^8 + 1 \\cdot 2^7 + 1 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0\n$$\n$$\nr(1373) = 1 \\cdot 1024 + 0 + 1 \\cdot 256 + 1 \\cdot 128 + 1 \\cdot 64 + 0 + 1 \\cdot 16 + 0 + 1 \\cdot 4 + 0 + 1 \\cdot 1\n$$\n$$\nr(1373) = 1024 + 256 + 128 + 64 + 16 + 4 + 1\n$$\nSumming these values:\n$$\n1024 + 256 = 1280\n$$\n$$\n1280 + 128 = 1408\n$$\n$$\n1408 + 64 = 1472\n$$\n$$\n1472 + 16 = 1488\n$$\n$$\n1488 + 4 = 1492\n$$\n$$\n1492 + 1 = 1493\n$$\nThus, the numerical value is $1493$.", "answer": "$$\n\\boxed{1493}\n$$", "id": "2863895"}, {"introduction": "Beyond the classic radix-2 algorithm, more advanced variants like the split-radix FFT offer significant reductions in computational complexity. This efficiency arises from a clever decomposition that maximizes the use of \"trivial\" twiddle factors ($\\pm 1, \\pm \\mathrm{j}$), thereby minimizing the number of expensive complex multiplications. This exercise guides you through an analysis of the split-radix structure for $N=16$, challenging you to count the exact number of non-trivial multiplications to appreciate its computational savings firsthand [@problem_id:2863892].", "problem": "Let $x[n]$ be a length-$N$ sequence and let its Discrete Fourier Transform (DFT) be defined by $X[k] = \\sum_{n=0}^{N-1} x[n] W_{N}^{nk}$, where $W_{N} \\triangleq \\exp(-\\mathrm{j} 2\\pi/N)$ and $\\mathrm{j}$ is the imaginary unit. The decimation-in-time (DIT) Split-Radix Fast Fourier Transform (FFT) recursively decomposes the DFT by splitting the time indices into even indices and the two odd residue classes modulo $4$, leading to one $N/2$-point DFT and two $N/4$-point DFTs that are recombined with twiddle factors of the form $W_{N}^{k}$ and $W_{N}^{3k}$ at each level.\n\nFor $N=16$, construct the split-radix DIT flow by explicitly identifying, at each recombination level, the sets of twiddle factors that multiply the outputs of the $N/4$-point subtransforms. Enumerate the corresponding twiddle angles in radians. Classify a multiplier as “trivial” if and only if its twiddle factor is exactly $\\pm 1$ or $\\pm \\mathrm{j}$ (equivalently, if its angle is congruent to $0$, $\\pi/2$, $\\pi$, or $3\\pi/2$ modulo $2\\pi$). Include the $N=8$ sub-FFT that arises in the even-index branch of the $N=16$ flow. Angles must be reported in radians.\n\nFinally, letting $M$ denote the total number of nontrivial complex multiplications by twiddle factors across the entire $N=16$ split-radix DIT FFT flow (counting all recombination stages in the recursion and counting each multiplication by a twiddle factor once; do not count additions or the trivial multipliers), determine $M$ exactly. Your final answer must be this single integer $M$ with no units. No rounding is required.", "solution": "The problem requires an analysis of the decimation-in-time (DIT) split-radix Fast Fourier Transform (FFT) algorithm for a sequence of length $N=16$. We must identify the twiddle factors at each stage of the recursion and determine the total number of nontrivial complex multiplications, denoted by $M$.\n\nA length-$N$ Discrete Fourier Transform (DFT) is defined as:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] W_{N}^{nk}, \\quad k = 0, 1, \\dots, N-1$$\nwhere $W_N \\triangleq \\exp(-\\mathrm{j} 2\\pi/N)$ is the twiddle factor.\n\nThe split-radix algorithm decomposes the DFT sum by splitting the time index $n$ into even indices ($2n$), odd indices of the form $4n+1$, and odd indices of the form $4n+3$. This yields:\n$$X[k] = \\sum_{n=0}^{N/2-1} x[2n]W_N^{2nk} + \\sum_{n=0}^{N/4-1} x[4n+1]W_N^{(4n+1)k} + \\sum_{n=0}^{N/4-1} x[4n+3]W_N^{(4n+3)k}$$\nUsing the property $W_N^{ab} = W_{N/a}^b$, this can be expressed in terms of smaller DFTs:\n$$X[k] = \\sum_{n=0}^{N/2-1} x[2n]W_{N/2}^{nk} + W_N^k \\sum_{n=0}^{N/4-1} x[4n+1]W_{N/4}^{nk} + W_N^{3k} \\sum_{n=0}^{N/4-1} x[4n+3]W_{N/4}^{nk}$$\nThis shows that a length-$N$ DFT can be computed from one length-$N/2$ DFT and two length-$N/4$ DFTs. The recombination of these smaller DFTs requires complex multiplications by the twiddle factors $W_N^k$ and $W_N^{3k}$.\n\nA multiplication is defined as \"trivial\" if the twiddle factor is $\\pm 1$ or $\\pm \\mathrm{j}$. This corresponds to twiddle angles that are integer multiples of $\\pi/2$. The angle of a twiddle factor $W_N^p$ is $-2\\pi p/N$. For the angle to be an integer multiple of $\\pi/2$, i.e., $-2\\pi p/N = q(\\pi/2)$ for some integer $q$, we must have $4p = -qN$, which implies that $p$ must be an integer multiple of $N/4$.\n\nWe will now analyze the recursive structure of the $N=16$ split-radix FFT to count the nontrivial multiplications.\n\n**1. Recombination Stage for $N=16$**\nThe computation of the $16$-point DFT is based on one $8$-point DFT and two $4$-point DFTs. The recombination involves twiddle factors that multiply the outputs of the two $4$-point DFTs. The indices for these factors run from $k=0$ to $N/4-1 = 16/4-1 = 3$. The factor for $k=0$ is $W_{16}^0=1$, which is a trivial multiplication and is not counted. We consider $k \\in \\{1, 2, 3\\}$.\nThe sets of twiddle factors are $\\{W_{16}^k | k=1,2,3\\}$ and $\\{W_{16}^{3k} | k=1,2,3\\}$.\n\n-   Set 1: $\\{W_{16}^1, W_{16}^2, W_{16}^3\\}$.\n    -   Angle for $W_{16}^1$: $-2\\pi(1)/16 = -\\pi/8$ radians.\n    -   Angle for $W_{16}^2$: $-2\\pi(2)/16 = -\\pi/4$ radians.\n    -   Angle for $W_{16}^3$: $-2\\pi(3)/16 = -3\\pi/8$ radians.\n-   Set 2: $\\{W_{16}^3, W_{16}^6, W_{16}^9\\}$.\n    -   Angle for $W_{16}^3$: $-2\\pi(3)/16 = -3\\pi/8$ radians.\n    -   Angle for $W_{16}^6$: $-2\\pi(6)/16 = -3\\pi/4$ radians.\n    -   Angle for $W_{16}^9$: $-2\\pi(9)/16 = -9\\pi/8$ radians.\n\nNone of these angles ($-\\pi/8, -\\pi/4, -3\\pi/8, -3\\pi/4, -9\\pi/8$) is an integer multiple of $\\pi/2$. Therefore, all $2 \\times (16/4 - 1) = 2 \\times 3 = 6$ complex multiplications at this stage are nontrivial.\n\n**2. Recombination Stage for the $N=8$ Sub-FFT**\nThe $N=16$ calculation requires one $N=8$ sub-FFT. This $8$-point DFT is in turn computed from one $4$-point DFT and two $2$-point DFTs. The recombination multipliers are given by $W_8^k$ and $W_8^{3k}$ for $k=0, \\dots, 8/4-1=1$. We only need to consider $k=1$.\nThe sets of twiddle factors are $\\{W_8^1\\}$ and $\\{W_8^3\\}$.\n\n-   Set 1: $\\{W_8^1\\}$.\n    -   Angle for $W_8^1$: $-2\\pi(1)/8 = -\\pi/4$ radians.\n-   Set 2: $\\{W_8^3\\}$.\n    -   Angle for $W_8^3$: $-2\\pi(3)/8 = -3\\pi/4$ radians.\n\nNeither $-\\pi/4$ nor $-3\\pi/4$ is an integer multiple of $\\pi/2$. Thus, both multiplications are nontrivial. The total number of nontrivial multiplications at this stage is $2 \\times (8/4 - 1) = 2 \\times 1 = 2$.\n\n**3. Recombination Stage for $N=4$ Sub-FFTs**\nThe full recursion involves several $N=4$ sub-FFTs. An $N=4$ split-radix FFT is decomposed into one $2$-point DFT and two $1$-point DFTs. The recombination multipliers would be $W_4^k$ and $W_4^{3k}$ for $k=0, \\dots, 4/4-1=0$. Since the range for $k$ is empty (as $k=0$ is trivial), there are zero multiplications in the recombination stage for any $N=4$ sub-FFT.\n\n**4. Total Nontrivial Multiplications ($M$)**\nThe total number of nontrivial complex multiplications $M$ is the sum of such multiplications over all recombination stages in the entire recursive flow. Let $M(N)$ be the number of nontrivial multiplications for a length-$N$ FFT.\nThe recursive structure gives the following:\n$$M(N) = M_{recomb}(N) + M(N/2) + 2 \\times M(N/4)$$\nwhere $M_{recomb}(N)$ is the number of nontrivial multiplications in the recombination stage for size $N$.\n\n-   Base cases: A $2$-point DFT involves only additions and subtractions, so $M(2)=0$. A $1$-point DFT is an identity operation, so $M(1)=0$.\n-   For $N=4$: $M_{recomb}(4) = 2 \\times (4/4-1) = 0$. Thus, $M(4) = M_{recomb}(4) + M(2) + 2M(1) = 0 + 0 + 2(0) = 0$.\n-   For $N=8$: $M_{recomb}(8) = 2$. Thus, $M(8) = M_{recomb}(8) + M(4) + 2M(2) = 2 + 0 + 2(0) = 2$.\n-   For $N=16$: $M_{recomb}(16) = 6$. Thus, $M(16) = M_{recomb}(16) + M(8) + 2M(4) = 6 + 2 + 2(0) = 8$.\n\nThe total number of nontrivial multiplications $M$ for the entire $N=16$ flow is precisely $M(16)$.\nThe calculation unfolds as follows:\n- The top-level decomposition of the $N=16$ FFT contributes $6$ nontrivial multiplications.\n- This creates one sub-problem of size $N=8$ and two sub-problems of size $N=4$.\n- The two $N=4$ sub-problems contribute $M(4)=0$ multiplications each.\n- The one $N=8$ sub-problem contributes $M(8)=2$ multiplications. This sub-problem itself decomposes into smaller FFTs ($N=4$ and $N=2$), but their contributions are already included in the value of $M(8)$.\n\nSumming the contributions from all stages:\n$$M = M_{recomb}(16) + M(8) + 2M(4) = 6 + 2 + 2(0) = 8.$$\nTherefore, the total number of nontrivial complex multiplications by twiddle factors across the entire $N=16$ split-radix DIT FFT flow is $8$.", "answer": "$$\\boxed{8}$$", "id": "2863892"}]}