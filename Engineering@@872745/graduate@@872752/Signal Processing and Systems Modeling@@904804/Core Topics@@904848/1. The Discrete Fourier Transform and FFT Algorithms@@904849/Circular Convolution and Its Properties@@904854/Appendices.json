{"hands_on_practices": [{"introduction": "One of the most fundamental properties of circular convolution is its relationship with circular shifts. This exercise provides hands-on practice in applying the definition of circular convolution to a special case—convolution with a shifted Kronecker delta—to explicitly derive and verify the circular shift property. Mastering this mechanism is crucial for understanding how circular convolution manipulates signal indices [@problem_id:2858547].", "problem": "Let $N$-point circular convolution be defined for sequences $x[n]$ and $h[n]$ by\n$$\n(x \\circledast_N h)[n] \\triangleq \\sum_{m=0}^{N-1} x[m]\\,h[(n-m)\\bmod N], \\quad n \\in \\{0,1,\\dots,N-1\\}.\n$$\nLet the $N$-periodic Kronecker delta $\\delta_N[n]$ be defined by\n$$\n\\delta_N[n] \\triangleq \\begin{cases}\n1,  n \\equiv 0 \\ (\\bmod\\ N),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nand let $x[n]$ be the length-$6$ sequence specified by $x[0]=1$, $x[1]=0$, $x[2]=2$, $x[3]=0$, $x[4]=-1$, $x[5]=3$, with $x[n]$ understood to be extended periodically with period $N=6$.\n\nFor $N=6$, compute $(x \\circledast_6 \\delta_6[n-2])[n]$ using only the definitions above. Derive the closed-form dependence of the result on $x[\\cdot]$ and $n$ (with modular indexing), and then evaluate it explicitly for $n \\in \\{0,1,2,3,4,5\\}$. Finally, verify explicitly—by tracing the summation logic from the definitions—that the result corresponds to a circular shift of $x[n]$. Express your final answer as a single row vector containing $6$ entries in the order $n=0,1,2,3,4,5$. No rounding is required and no units apply.", "solution": "We begin from the core definitions. For $N=6$, the circular convolution of $x[n]$ with $h[n]=\\delta_6[n-2]$ is\n$$\ny[n] \\triangleq (x \\circledast_6 \\delta_6[n-2])[n] = \\sum_{m=0}^{5} x[m]\\,\\delta_6\\!\\big((n-m)-2\\big),\n\\quad n \\in \\{0,1,2,3,4,5\\}.\n$$\nBy the definition of the $6$-periodic Kronecker delta,\n$$\n\\delta_6\\!\\big((n-m)-2\\big)=\\begin{cases}\n1,  (n-m)-2 \\equiv 0 \\ (\\bmod\\ 6),\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nTherefore, for each fixed $n$, the summand $x[m]\\,\\delta_6((n-m)-2)$ is nonzero if and only if\n$$\n(n-m)-2 \\equiv 0 \\ (\\bmod\\ 6) \\quad \\Longleftrightarrow \\quad m \\equiv n-2 \\ (\\bmod\\ 6).\n$$\nSince $m$ ranges over the complete residue set $\\{0,1,2,3,4,5\\}$ modulo $6$, there is exactly one index\n$$\nm^{\\star} = (n-2)\\bmod 6 \\in \\{0,1,2,3,4,5\\}\n$$\nthat satisfies the congruence. Consequently, the sum collapses to a single term:\n$$\ny[n] = x[m^{\\star}] = x\\big((n-2)\\bmod 6\\big).\n$$\nThis is the closed-form dependence on $x[\\cdot]$ and $n$ obtained directly from the definitions, and it shows that the output is a circular shift of $x[n]$ by $2$ samples, in the sense that the index $n$ is mapped to $n-2$ modulo $6$.\n\nWe now evaluate $y[n]$ for $n \\in \\{0,1,2,3,4,5\\}$, using $x[0]=1$, $x[1]=0$, $x[2]=2$, $x[3]=0$, $x[4]=-1$, $x[5]=3$:\n- For $n=0$: $y[0] = x\\big((0-2)\\bmod 6\\big) = x[4] = -1$.\n- For $n=1$: $y[1] = x\\big((1-2)\\bmod 6\\big) = x[5] = 3$.\n- For $n=2$: $y[2] = x\\big((2-2)\\bmod 6\\big) = x[0] = 1$.\n- For $n=3$: $y[3] = x\\big((3-2)\\bmod 6\\big) = x[1] = 0$.\n- For $n=4$: $y[4] = x\\big((4-2)\\bmod 6\\big) = x[2] = 2$.\n- For $n=5$: $y[5] = x\\big((5-2)\\bmod 6\\big) = x[3] = 0$.\n\nCollecting these in order $n=0,1,2,3,4,5$, we obtain the row vector\n$$\n\\big[y[0],y[1],y[2],y[3],y[4],y[5]\\big] = \\big[-1,\\,3,\\,1,\\,0,\\,2,\\,0\\big].\n$$\n\nTo verify explicitly the shift property from first principles, observe that the reduction of the defining sum to a single term occurs precisely at the $m$ that satisfies $(n-m)-2 \\equiv 0 \\ (\\bmod\\ 6)$, i.e., $m\\equiv n-2 \\ (\\bmod\\ 6)$. This equality of indices under modular arithmetic is the exact mechanism by which the periodic delta selects a shifted index of $x[\\cdot]$. Hence, the convolution with $\\delta_6[n-2]$ produces the circularly shifted sequence $x\\big((n-2)\\bmod 6\\big)$, which matches the computed vector above. This completes the explicit verification.", "answer": "$$\\boxed{\\begin{pmatrix}-1  3  1  0  2  0\\end{pmatrix}}$$", "id": "2858547"}, {"introduction": "The power of circular convolution is fully realized through its connection to the Discrete Fourier Transform (DFT), a relationship elegantly captured by the Wiener-Khinchin theorem for autocorrelation. This practice guides you through both a time-domain and a frequency-domain calculation of circular autocorrelation, a special case of circular convolution. By deriving the theorem and verifying the results, you will gain a deeper appreciation for the computational efficiency and analytical power that the DFT brings to convolution and correlation operations [@problem_id:2858542].", "problem": "Consider the length-$N$ discrete-time sequence $x[n]$ with $N=4$, given by $x[n]=\\{1,2,1,0\\}$. Let the $N$-point circular autocorrelation of $x[n]$ be defined as $r_{xx}[m] \\triangleq \\sum_{n=0}^{N-1} x[n]\\,x^{\\ast}[(n-m)\\bmod N]$ for $m \\in \\{0,1,2,3\\}$, where ${}^{\\ast}$ denotes complex conjugation. Let the $N$-point Discrete Fourier Transform (DFT) of $x[n]$ be defined as $X[k] \\triangleq \\sum_{n=0}^{N-1} x[n]\\exp(-\\mathrm{j}2\\pi kn/N)$ for $k \\in \\{0,1,2,3\\}$, and the inverse DFT as $x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\exp(\\mathrm{j}2\\pi kn/N)$.\n\nStarting only from these definitions and basic finite-sum manipulation and orthogonality of complex exponentials, do the following:\n\n1) Derive, without assuming it a priori, a frequency-domain characterization that connects the DFT of $r_{xx}[m]$ to a function of $X[k]$.\n\n2) Compute $r_{xx}[m]$ for all $m \\in \\{0,1,2,3\\}$ directly from its time-domain definition.\n\n3) Compute $r_{xx}[m]$ again by using your derived frequency-domain characterization and explicitly evaluating the necessary finite sums for $N=4$. Verify that the two results agree exactly.\n\nProvide the final result as the complete $4$-point circular autocorrelation sequence ordered as $\\big(r_{xx}[0],\\,r_{xx}[1],\\,r_{xx}[2],\\,r_{xx}[3]\\big)$. No rounding is required. The final answer must be given as exact values with no units.", "solution": "The problem requires a three-part solution: derivation of a frequency-domain property, direct time-domain calculation, and a frequency-domain calculation for verification. We will proceed with each part systematically.\n\nThe given parameters are a discrete-time sequence $x[n] = \\{1, 2, 1, 0\\}$ of length $N=4$. Since the sequence is real-valued, the complex conjugate $x^{\\ast}[n]$ is equal to $x[n]$.\n\nPart 1: Derivation of the Frequency-Domain Characterization\n\nWe begin by finding the Discrete Fourier Transform (DFT) of the circular autocorrelation sequence $r_{xx}[m]$. Let the DFT of $r_{xx}[m]$ be denoted by $R_{xx}[k]$. By definition of the DFT:\n$$R_{xx}[k] \\triangleq \\sum_{m=0}^{N-1} r_{xx}[m] \\exp\\left(-\\frac{\\mathrm{j}2\\pi km}{N}\\right)$$\nSubstitute the definition of $r_{xx}[m] = \\sum_{n=0}^{N-1} x[n]x^{\\ast}[(n-m)\\bmod N]$:\n$$R_{xx}[k] = \\sum_{m=0}^{N-1} \\left( \\sum_{n=0}^{N-1} x[n]x^{\\ast}[(n-m)\\bmod N] \\right) \\exp\\left(-\\frac{\\mathrm{j}2\\pi km}{N}\\right)$$\nThe sums are over finite ranges, so we may interchange the order of summation:\n$$R_{xx}[k] = \\sum_{n=0}^{N-1} x[n] \\sum_{m=0}^{N-1} x^{\\ast}[(n-m)\\bmod N] \\exp\\left(-\\frac{\\mathrm{j}2\\pi km}{N}\\right)$$\nLet us make a change of variable in the inner summation. Let $p = (n-m) \\bmod N$. This implies $m = (n-p) \\bmod N$. As $m$ ranges over a complete period from $0$ to $N-1$, the variable $p$ also ranges over a complete period. Therefore, we can replace the summation over $m$ with a summation over $p$:\n$$R_{xx}[k] = \\sum_{n=0}^{N-1} x[n] \\sum_{p=0}^{N-1} x^{\\ast}[p] \\exp\\left(-\\frac{\\mathrm{j}2\\pi k(n-p)}{N}\\right)$$\nWe can separate the exponential term:\n$$R_{xx}[k] = \\sum_{n=0}^{N-1} x[n] \\sum_{p=0}^{N-1} x^{\\ast}[p] \\exp\\left(-\\frac{\\mathrm{j}2\\pi kn}{N}\\right) \\exp\\left(\\frac{\\mathrm{j}2\\pi kp}{N}\\right)$$\nRearranging the terms by factoring out expressions that do not depend on the inner summation variable $p$:\n$$R_{xx}[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\frac{\\mathrm{j}2\\pi kn}{N}\\right) \\left( \\sum_{p=0}^{N-1} x^{\\ast}[p] \\exp\\left(\\frac{\\mathrm{j}2\\pi kp}{N}\\right) \\right)$$\nWe recognize the first part of the expression as the definition of the DFT of $x[n]$, which is $X[k]$:\n$$\\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\frac{\\mathrm{j}2\\pi kn}{N}\\right) = X[k]$$\nThe second part of the expression, the term in parentheses, can be related to $X[k]$ as well. Let us examine it closely:\n$$\\sum_{p=0}^{N-1} x^{\\ast}[p] \\exp\\left(\\frac{\\mathrm{j}2\\pi kp}{N}\\right) = \\sum_{p=0}^{N-1} \\left( x[p] \\exp\\left(-\\frac{\\mathrm{j}2\\pi kp}{N}\\right) \\right)^{\\ast} = \\left( \\sum_{p=0}^{N-1} x[p] \\exp\\left(-\\frac{\\mathrm{j}2\\pi kp}{N}\\right) \\right)^{\\ast}$$\nThe sum inside the parentheses is again the definition of $X[k]$. Therefore, the second part of the expression is $X^{\\ast}[k]$.\nSubstituting these back, we arrive at the final characterization:\n$$R_{xx}[k] = X[k] X^{\\ast}[k] = |X[k]|^2$$\nThis result, a specific instance of the Wiener-Khinchin theorem, states that the DFT of the circular autocorrelation sequence is equal to the squared magnitude of the DFT of the original sequence.\n\nPart 2: Time-Domain Computation of $r_{xx}[m]$\n\nWe compute $r_{xx}[m]$ for $m \\in \\{0, 1, 2, 3\\}$ using its definition for the sequence $x[n] = \\{1, 2, 1, 0\\}$ and $N=4$. As $x[n]$ is real, $x^{\\ast}[n]=x[n]$.\n$$r_{xx}[m] = \\sum_{n=0}^{3} x[n]x[(n-m)\\bmod 4]$$\nFor $m=0$:\n$$r_{xx}[0] = \\sum_{n=0}^{3} x[n]x[n] = x[0]^2 + x[1]^2 + x[2]^2 + x[3]^2 = 1^2 + 2^2 + 1^2 + 0^2 = 1 + 4 + 1 + 0 = 6$$\nFor $m=1$:\n$$r_{xx}[1] = \\sum_{n=0}^{3} x[n]x[(n-1)\\bmod 4] = x[0]x[3] + x[1]x[0] + x[2]x[1] + x[3]x[2] = (1)(0) + (2)(1) + (1)(2) + (0)(1) = 0 + 2 + 2 + 0 = 4$$\nFor $m=2$:\n$$r_{xx}[2] = \\sum_{n=0}^{3} x[n]x[(n-2)\\bmod 4] = x[0]x[2] + x[1]x[3] + x[2]x[0] + x[3]x[1] = (1)(1) + (2)(0) + (1)(1) + (0)(2) = 1 + 0 + 1 + 0 = 2$$\nFor $m=3$:\n$$r_{xx}[3] = \\sum_{n=0}^{3} x[n]x[(n-3)\\bmod 4] = x[0]x[1] + x[1]x[2] + x[2]x[3] + x[3]x[0] = (1)(2) + (2)(1) + (1)(0) + (0)(1) = 2 + 2 + 0 + 0 = 4$$\nThe resulting circular autocorrelation sequence is $r_{xx}[m] = \\{6, 4, 2, 4\\}$.\n\nPart 3: Frequency-Domain Computation and Verification\n\nWe now re-calculate $r_{xx}[m]$ using the derived frequency-domain property. First, we compute the $4$-point DFT of $x[n]$, denoted as $X[k]$.\nThe DFT is $X[k] = \\sum_{n=0}^{3} x[n] \\exp(-\\frac{\\mathrm{j}2\\pi kn}{4}) = \\sum_{n=0}^{3} x[n] \\exp(-\\frac{\\mathrm{j}\\pi kn}{2})$.\nFor $k=0$:\n$$X[0] = \\sum_{n=0}^{3} x[n] = 1 + 2 + 1 + 0 = 4$$\nFor $k=1$:\n$$X[1] = x[0]\\exp(0) + x[1]\\exp\\left(-\\frac{\\mathrm{j}\\pi}{2}\\right) + x[2]\\exp(-\\mathrm{j}\\pi) + x[3]\\exp\\left(-\\frac{\\mathrm{j}3\\pi}{2}\\right) = 1(1) + 2(-\\mathrm{j}) + 1(-1) + 0(\\mathrm{j}) = -2\\mathrm{j}$$\nFor $k=2$:\n$$X[2] = x[0]\\exp(0) + x[1]\\exp(-\\mathrm{j}\\pi) + x[2]\\exp(-\\mathrm{j}2\\pi) + x[3]\\exp(-\\mathrm{j}3\\pi) = 1(1) + 2(-1) + 1(1) + 0(-1) = 1 - 2 + 1 = 0$$\nFor $k=3$:\n$$X[3] = x[0]\\exp(0) + x[1]\\exp\\left(-\\frac{\\mathrm{j}3\\pi}{2}\\right) + x[2]\\exp(-\\mathrm{j}3\\pi) + x[3]\\exp\\left(-\\frac{\\mathrm{j}9\\pi}{2}\\right) = 1(1) + 2(\\mathrm{j}) + 1(-1) + 0(-\\mathrm{j}) = 2\\mathrm{j}$$\nThe DFT sequence is $X[k] = \\{4, -2\\mathrm{j}, 0, 2\\mathrm{j}\\}$.\n\nNext, we compute $R_{xx}[k] = |X[k]|^2$:\n$$R_{xx}[0] = |X[0]|^2 = |4|^2 = 16$$\n$$R_{xx}[1] = |X[1]|^2 = |-2\\mathrm{j}|^2 = (-2\\mathrm{j})(2\\mathrm{j}) = 4$$\n$$R_{xx}[2] = |X[2]|^2 = |0|^2 = 0$$\n$$R_{xx}[3] = |X[3]|^2 = |2\\mathrm{j}|^2 = (2\\mathrm{j})(-2\\mathrm{j}) = 4$$\nSo, the DFT of the autocorrelation sequence is $R_{xx}[k] = \\{16, 4, 0, 4\\}$.\n\nFinally, we compute the inverse DFT of $R_{xx}[k]$ to find $r_{xx}[m]$:\n$$r_{xx}[m] = \\frac{1}{N} \\sum_{k=0}^{N-1} R_{xx}[k] \\exp\\left(\\frac{\\mathrm{j}2\\pi km}{N}\\right) = \\frac{1}{4} \\sum_{k=0}^{3} R_{xx}[k] \\exp\\left(\\frac{\\mathrm{j}\\pi km}{2}\\right)$$\nFor $m=0$:\n$$r_{xx}[0] = \\frac{1}{4} \\sum_{k=0}^{3} R_{xx}[k] = \\frac{1}{4} (16 + 4 + 0 + 4) = \\frac{24}{4} = 6$$\nFor $m=1$:\n$$r_{xx}[1] = \\frac{1}{4} \\left(R_{xx}[0] + R_{xx}[1]\\exp\\left(\\frac{\\mathrm{j}\\pi}{2}\\right) + R_{xx}[2]\\exp(\\mathrm{j}\\pi) + R_{xx}[3]\\exp\\left(\\frac{\\mathrm{j}3\\pi}{2}\\right)\\right) = \\frac{1}{4}(16 + 4(\\mathrm{j}) + 0(-1) + 4(-\\mathrm{j})) = \\frac{16}{4} = 4$$\nFor $m=2$:\n$$r_{xx}[2] = \\frac{1}{4} \\left(R_{xx}[0] + R_{xx}[1]\\exp(\\mathrm{j}\\pi) + R_{xx}[2]\\exp(\\mathrm{j}2\\pi) + R_{xx}[3]\\exp(\\mathrm{j}3\\pi)\\right) = \\frac{1}{4}(16 + 4(-1) + 0(1) + 4(-1)) = \\frac{8}{4} = 2$$\nFor $m=3$:\n$$r_{xx}[3] = \\frac{1}{4} \\left(R_{xx}[0] + R_{xx}[1]\\exp\\left(\\frac{\\mathrm{j}3\\pi}{2}\\right) + R_{xx}[2]\\exp(\\mathrm{j}3\\pi) + R_{xx}[3]\\exp\\left(\\frac{\\mathrm{j}9\\pi}{2}\\right)\\right) = \\frac{1}{4}(16 + 4(-\\mathrm{j}) + 0(-1) + 4(\\mathrm{j})) = \\frac{16}{4} = 4$$\nThe resulting sequence is $r_{xx}[m] = \\{6, 4, 2, 4\\}$.\nThis result matches exactly the sequence computed directly in the time domain, which verifies the derived property for this specific case as required.\n\nThe final answer is the sequence $(r_{xx}[0], r_{xx}[1], r_{xx}[2], r_{xx}[3])$.", "answer": "$$\\boxed{\\begin{pmatrix} 6  4  2  4 \\end{pmatrix}}$$", "id": "2858542"}, {"introduction": "Beyond a simple signal processing operation, circular convolution possesses a deep algebraic structure that connects it directly to linear algebra. In this computational exercise, you will verify the isomorphism between the ring of sequences under circular convolution and the algebra of circulant matrices. By implementing and testing the identity $C_h C_g = C_{h \\circledast_N g}$, you will solidify your understanding of how circular convolution can be represented as a matrix-vector product, a cornerstone of many advanced signal processing and numerical analysis algorithms [@problem_id:2858508].", "problem": "Let $N$ be a positive integer and let $h \\in \\mathbb{R}^N$ and $g \\in \\mathbb{R}^N$ be sequences indexed by $n \\in \\{0,1,\\ldots,N-1\\}$. Define the length-$N$ circular convolution $h \\circledast_N g$ by the fundamental definition\n$$\n(h \\circledast_N g)[n] \\triangleq \\sum_{k=0}^{N-1} h\\big[(n-k) \\bmod N\\big] \\, g[k], \\quad n \\in \\{0,1,\\ldots,N-1\\}.\n$$\nDefine the $N \\times N$ circulant matrix associated with $h$, denoted $C_h$, by the linear map that satisfies\n$$\n\\big(C_h x\\big)[n] \\triangleq \\sum_{k=0}^{N-1} h\\big[(n-k) \\bmod N\\big] \\, x[k], \\quad n \\in \\{0,1,\\ldots,N-1\\},\n$$\nfor every $x \\in \\mathbb{R}^N$. In other words, $C_h$ has entries\n$$\n(C_h)_{n,k} = h\\big[(n-k) \\bmod N\\big].\n$$\nStarting only from these core definitions and the definition of matrix multiplication, the goal is to algorithmically verify the identity linking matrix and convolution domains:\n$$\nC_h \\, C_g \\;=\\; C_{\\,h \\circledast_N g}.\n$$\nYour program must implement these definitions and, for each test case, compute the boolean value that is true if and only if the identity holds exactly (entrywise equality over the reals using exact integer arithmetic where applicable).\n\nTest suite. Use the following four cases to test different facets, including a general case, identity/boundary cases, and structured sequences:\n- Case A (general, mixed signs): $N = 7$, $h = [3,-1,4,1,-5,9,2]$, $g = [-2,6,-5,3,-5,-8,9]$.\n- Case B (boundary, singleton): $N = 1$, $h = [5]$, $g = [-7]$.\n- Case C (identity element via circular convolution): $N = 6$, $h = [1,0,0,0,0,0]$, $g = [2,-1,0,3,5,-2]$.\n- Case D (structured patterns): $N = 8$, $h = [0,1,0,1,0,1,0,1]$, $g = [1,1,1,1,1,1,1,1]$.\n\nFinal output format. Your program should produce a single line of output containing the four boolean results for the cases A, B, C, and D, in that order, as a comma-separated list enclosed in square brackets (for example, $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$). No additional text should be printed. No physical units or angle units are involved in this problem, and all outputs are booleans.", "solution": "The verification process for each test case, consisting of an integer $N$ and two real-valued sequences $h, g \\in \\mathbb{R}^N$, is decomposed into three stages:\n1.  Calculation of the left-hand side (LHS) of the identity, $L \\triangleq C_h C_g$.\n2.  Calculation of the right-hand side (RHS) of the identity, $R \\triangleq C_{h \\circledast_N g}$.\n3.  A boolean comparison to check for entry-wise equality, $L = R$.\n\nThe core algorithms are constructed directly from the given definitions.\n\n**1. Algorithm for Circulant Matrix Construction**\n\nGiven a vector $x \\in \\mathbb{R}^N$ with elements $x[k]$ for $k \\in \\{0, 1, \\ldots, N-1\\}$, the associated $N \\times N$ circulant matrix $C_x$ has its entries $(C_x)_{n,k}$ defined as:\n$$\n(C_x)_{n,k} = x\\big[(n-k) \\bmod N\\big], \\quad \\text{for } n, k \\in \\{0, 1, \\ldots, N-1\\}.\n$$\nThis formula is implemented by creating an $N \\times N$ matrix and populating each cell $(n,k)$ with the corresponding element from vector $x$, indexed by the result of the modular arithmetic expression $(n-k) \\bmod N$.\n\n**2. Algorithm for Circular Convolution**\n\nGiven two vectors $h, g \\in \\mathbb{R}^N$, their length-$N$ circular convolution is a new vector $y = h \\circledast_N g \\in \\mathbb{R}^N$. The $n$-th element of $y$ is defined as:\n$$\ny[n] \\triangleq (h \\circledast_N g)[n] = \\sum_{k=0}^{N-1} h\\big[(n-k) \\bmod N\\big] \\, g[k].\n$$\nThis is implemented by computing each element $y[n]$ as a sum over $k$ from $0$ to $N-1$, following the precise structure of the formula.\n\n**3. Verification Procedure**\n\nFor each test case $(N, h, g)$:\n\n-   **LHS Computation**:\n    -   Construct the circulant matrix $C_h$ from vector $h$ using the algorithm from step 1.\n    -   Construct the circulant matrix $C_g$ from vector $g$ using the algorithm from step 1.\n    -   Compute the matrix product $L = C_h C_g$. The entry $(L)_{n,m}$ is given by the standard definition of matrix multiplication: $(L)_{n,m} = \\sum_{k=0}^{N-1} (C_h)_{n,k} (C_g)_{k,m}$.\n\n-   **RHS Computation**:\n    -   First, compute the vector result of the circular convolution, $y = h \\circledast_N g$, using the algorithm from step 2.\n    -   Then, construct the circulant matrix $R = C_y$ from the resulting vector $y$ using the algorithm from step 1.\n\n-   **Equality Check**:\n    -   The final step is to perform an exact, entry-wise comparison of the two resulting matrices, $L$ and $R$. The identity is verified for the given case if and only if $L_{n,m} = R_{n,m}$ for all $n, m \\in \\{0, 1, \\ldots, N-1\\}$.\n\nThis entire procedure is deterministic and, as the identity is a known mathematical theorem, is expected to yield a result of true for all provided test cases. The implementation will confirm this through direct computation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the identity C_h * C_g = C_{h * g} for circulant matrices.\n    \"\"\"\n\n    # Test cases as specified in the problem statement.\n    test_cases = [\n        {\n            \"N\": 7,\n            \"h\": [3, -1, 4, 1, -5, 9, 2],\n            \"g\": [-2, 6, -5, 3, -5, -8, 9]\n        },\n        {\n            \"N\": 1,\n            \"h\": [5],\n            \"g\": [-7]\n        },\n        {\n            \"N\": 6,\n            \"h\": [1, 0, 0, 0, 0, 0],\n            \"g\": [2, -1, 0, 3, 5, -2]\n        },\n        {\n            \"N\": 8,\n            \"h\": [0, 1, 0, 1, 0, 1, 0, 1],\n            \"g\": [1, 1, 1, 1, 1, 1, 1, 1]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        # Use numpy arrays with integer types for exact arithmetic.\n        h = np.array(case[\"h\"], dtype=np.int64)\n        g = np.array(case[\"g\"], dtype=np.int64)\n\n        # 1. Algorithm for Circulant Matrix Construction\n        # This function implements (C_x)_{n,k} = x[(n-k) mod N].\n        def construct_circulant_matrix(x_vec):\n            n_dim = len(x_vec)\n            # Initialize with compatible integer type to prevent overflow.\n            c_matrix = np.zeros((n_dim, n_dim), dtype=x_vec.dtype)\n            for n_row in range(n_dim):\n                for k_col in range(n_dim):\n                    # Python's % operator correctly handles negative results for modulo.\n                    # e.g., -1 % 7 = 6, which is what is needed for (n-k) mod N.\n                    c_matrix[n_row, k_col] = x_vec[(n_row - k_col) % n_dim]\n            return c_matrix\n\n        # 2. Algorithm for Circular Convolution\n        # This function implements y[n] = sum_{k=0}^{N-1} h[(n-k) mod N] * g[k].\n        def circular_convolution(h_vec, g_vec):\n            n_dim = len(h_vec)\n            # Determine a safe integer type for the result.\n            y_dtype = np.result_type(h_vec.dtype, g_vec.dtype, np.int64)\n            y_vec = np.zeros(n_dim, dtype=y_dtype)\n            for n_idx in range(n_dim):\n                conv_sum = 0\n                for k_idx in range(n_dim):\n                    h_idx = (n_idx - k_idx) % n_dim\n                    conv_sum += h_vec[h_idx] * g_vec[k_idx]\n                y_vec[n_idx] = conv_sum\n            return y_vec\n\n        # 3. Verification Procedure\n\n        # Compute Left-Hand Side (LHS)\n        C_h = construct_circulant_matrix(h)\n        C_g = construct_circulant_matrix(g)\n        LHS = C_h @ C_g  # Standard matrix multiplication\n\n        # Compute Right-Hand Side (RHS)\n        h_conv_g = circular_convolution(h, g)\n        C_h_conv_g = construct_circulant_matrix(h_conv_g)\n        RHS = C_h_conv_g\n\n        # Compare LHS and RHS for exact equality\n        is_equal = np.array_equal(LHS, RHS)\n        results.append(is_equal)\n\n    # Format output as specified: a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2858508"}]}