{"hands_on_practices": [{"introduction": "The power of Empirical Mode Decomposition (EMD) lies in its adaptive, data-driven approach to separating a signal into its constituent oscillatory modes. To truly grasp how EMD achieves this, we begin with an idealized thought experiment. This exercise will guide you through reasoning from first principles about how the sifting process, which relies on identifying local extrema and constructing envelopes, naturally isolates the highest-frequency component from a composite signal first [@problem_id:2869022]. Understanding this core mechanism provides the fundamental intuition for the entire Hilbert-Huang Transform method.", "problem": "Consider the continuous-time signal defined by $x(t)=\\cos(2\\pi f_1 t)+\\cos(2\\pi f_2 t)$ with strictly positive frequencies $f_1$ and $f_2$ satisfying $f_2/f_1=5$. Assume the Empirical Mode Decomposition (EMD) is applied in the idealized sense: upper and lower envelopes are constructed by perfect interpolation through the true local maxima and minima, the mean envelope is their pointwise average, the Intrinsic Mode Function (IMF) conditions are enforced exactly, and end effects are negligible. The Intrinsic Mode Function (IMF) conditions are that the number of zero-crossings and extrema differ at most by one and that the mean of the upper and lower envelopes is identically zero. Assume the sifting process is iterated to convergence for each IMF.\n\nUsing only the core definitions of EMD and IMF and the notion of envelope construction from local extrema, reason from first principles about how extrema spacing and envelope overlap govern which oscillatory content is isolated first. Then, predict which sinusoidal component is extracted as the first IMF and which remains to form the second IMF. Finally, using the definition of instantaneous frequency from the analytic signal via the Hilbert transform, identify the constant instantaneous frequency associated with each of the first two IMFs.\n\nReport your final answer as the ordered pair $(f_{\\text{IMF1}}, f_{\\text{IMF2}})$, where $f_{\\text{IMFk}}$ denotes the constant instantaneous frequency of the $k$-th IMF as defined by the Hilbert transform. Express your final answer as a $1\\times 2$ row matrix in terms of $f_1$ and $f_2$. No numerical approximation or rounding is required.", "solution": "The problem as stated is subjected to validation.\n\nStep 1: Extract Givens.\n- The continuous-time signal is given by $x(t) = \\cos(2\\pi f_1 t) + \\cos(2\\pi f_2 t)$.\n- The frequencies $f_1$ and $f_2$ are strictly positive: $f_1 > 0$, $f_2 > 0$.\n- A relationship between the frequencies is provided: $f_2/f_1 = 5$.\n- The Empirical Mode Decomposition (EMD) process is idealized under the following assumptions:\n    - Upper and lower envelopes are generated by perfect interpolation through true local maxima and minima.\n    - The mean envelope is the pointwise average of the upper and lower envelopes.\n    - The Intrinsic Mode Function (IMF) conditions are enforced exactly.\n    - End effects are negligible.\n- The IMF conditions are specified as:\n    1. The number of zero-crossings and the number of extrema must either be equal or differ at most by one.\n    2. The mean of the upper and lower envelopes, computed from local extrema, is identically zero at any point.\n- The sifting process is iterated until convergence for each IMF.\n- The task is to determine the first two IMFs, $c_1(t)$ and $c_2(t)$, and their respective constant instantaneous frequencies, $f_{\\text{IMF1}}$ and $f_{\\text{IMF2}}$, derived from the Hilbert transform.\n\nStep 2: Validate Using Extracted Givens.\n- The problem is scientifically grounded. It concerns the established signal processing technique of Empirical Mode Decomposition and the Hilbert-Huang Transform. The signal is a superposition of sinusoids, a standard case for analyzing such methods. The concept of an \"idealized\" process is a common and valid theoretical construct used to probe the fundamental behavior of an algorithm.\n- The problem is well-posed and self-contained. All necessary information is provided, including the signal definition, the relationship between its frequency components, and the precise (idealized) rules governing the decomposition process. The conditions lead to a unique and stable solution.\n- The problem is objective and uses precise, formal language. It is free from ambiguity, subjective claims, or factual inaccuracies.\n\nStep 3: Verdict and Action.\nThe problem is valid. A reasoned solution will be formulated.\n\nThe core principle of the Empirical Mode Decomposition (EMD) is to sequentially extract oscillatory components from a signal, starting with the one that has the highest local frequency, or equivalently, the shortest local time scale. The process is entirely data-driven and adaptive.\n\nThe signal is $x(t) = \\cos(2\\pi f_1 t) + \\cos(2\\pi f_2 t)$. Given the constraint $f_2 = 5f_1$, it is clear that the component $\\cos(2\\pi f_2 t)$ oscillates at a much higher frequency than the component $\\cos(2\\pi f_1 t)$. The signal $x(t)$ can be conceptualized as a high-frequency oscillation, $\\cos(2\\pi f_2 t)$, superimposed on a slowly varying carrier, $\\cos(2\\pi f_1 t)$.\n\nThe EMD sifting process begins by identifying all local extrema (maxima and minima) of the signal $x(t)$. Due to the significant separation in frequencies ($f_2$ is $5$ times $f_1$), the locations of these local extrema are primarily determined by the high-frequency component, $\\cos(2\\pi f_2 t)$. The local maxima of $x(t)$ will occur near the peaks of $\\cos(2\\pi f_2 t)$, where the value of this component is $+1$. At these time instances, the value of the composite signal is approximately $x(t_{max}) \\approx \\cos(2\\pi f_1 t_{max}) + 1$. Similarly, the local minima of $x(t)$ will occur near the troughs of $\\cos(2\\pi f_2 t)$, where its value is $-1$, making the composite signal value approximately $x(t_{min}) \\approx \\cos(2\\pi f_1 t_{min}) - 1$.\n\nThe first step in sifting is to construct the upper envelope, $e_{up}(t)$, by interpolating through the local maxima, and the lower envelope, $e_{low}(t)$, by interpolating through the local minima. Under the idealization of perfect interpolation, the upper envelope will be a smooth function that closely follows $e_{up}(t) \\approx \\cos(2\\pi f_1 t) + 1$, and the lower envelope will closely follow $e_{low}(t) \\approx \\cos(2\\pi f_1 t) - 1$.\n\nThe mean envelope, $m_1(t)$, is then computed as the pointwise average of the two envelopes:\n$$m_1(t) = \\frac{e_{up}(t) + e_{low}(t)}{2}$$\nUsing our approximations, this becomes:\n$$m_1(t) \\approx \\frac{(\\cos(2\\pi f_1 t) + 1) + (\\cos(2\\pi f_1 t) - 1)}{2} = \\frac{2\\cos(2\\pi f_1 t)}{2} = \\cos(2\\pi f_1 t)$$\nIn the idealized case described, this approximation becomes an equality. The mean envelope is exactly the low-frequency component.\n\nThe first proto-IMF, $h_1(t)$, is obtained by subtracting this mean from the original signal:\n$$h_1(t) = x(t) - m_1(t) = (\\cos(2\\pi f_1 t) + \\cos(2\\pi f_2 t)) - \\cos(2\\pi f_1 t) = \\cos(2\\pi f_2 t)$$\nThe sifting process requires iterating this procedure on $h_1(t)$ until it satisfies the IMF conditions. However, $h_1(t) = \\cos(2\\pi f_2 t)$ is a pure sinusoid. Its upper envelope is the constant $1$ and its lower envelope is the constant $-1$. The mean of these envelopes is $(1 - 1)/2 = 0$. Since the mean is identically zero, the sifting process has converged on the very first iteration. Thus, the first Intrinsic Mode Function is:\n$$c_1(t) = \\cos(2\\pi f_2 t)$$\nThis demonstrates the fundamental behavior of EMD: it isolates the highest-frequency mode first.\n\nNext, we find the first residue, $r_1(t)$, by subtracting the first IMF from the original signal:\n$$r_1(t) = x(t) - c_1(t) = (\\cos(2\\pi f_1 t) + \\cos(2\\pi f_2 t)) - \\cos(2\\pi f_2 t) = \\cos(2\\pi f_1 t)$$\nThis residue, $r_1(t)$, becomes the input for the next stage of the decomposition. We must check if $r_1(t)$ is itself an IMF. As $r_1(t) = \\cos(2\\pi f_1 t)$ is a pure sinusoid, its upper envelope is $1$ and its lower envelope is $-1$. Its mean is identically zero. It also satisfies the condition on the number of extrema and zero-crossings. Therefore, $r_1(t)$ is already an IMF and no further sifting is required. The second Intrinsic Mode Function is:\n$$c_2(t) = r_1(t) = \\cos(2\\pi f_1 t)$$\n\nFinally, we determine the instantaneous frequency for each IMF using the Hilbert transform. The instantaneous frequency $f(t)$ is derived from the phase of the analytic signal $z(t) = s(t) + i\\mathcal{H}\\{s(t)\\} = A(t)\\exp(i\\phi(t))$, where $\\mathcal{H}$ denotes the Hilbert transform operator. The frequency is given by $f(t) = \\frac{1}{2\\pi}\\frac{d\\phi(t)}{dt}$.\n\nFor the first IMF, $c_1(t) = \\cos(2\\pi f_2 t)$:\nThe Hilbert transform is $\\mathcal{H}\\{c_1(t)\\} = \\sin(2\\pi f_2 t)$.\nThe analytic signal is $z_1(t) = \\cos(2\\pi f_2 t) + i\\sin(2\\pi f_2 t) = \\exp(i(2\\pi f_2 t))$.\nThe phase is $\\phi_1(t) = 2\\pi f_2 t$.\nThe instantaneous frequency is constant:\n$$f_{\\text{IMF1}} = \\frac{1}{2\\pi}\\frac{d}{dt}(2\\pi f_2 t) = f_2$$\n\nFor the second IMF, $c_2(t) = \\cos(2\\pi f_1 t)$:\nThe Hilbert transform is $\\mathcal{H}\\{c_2(t)\\} = \\sin(2\\pi f_1 t)$.\nThe analytic signal is $z_2(t) = \\cos(2\\pi f_1 t) + i\\sin(2\\pi f_1 t) = \\exp(i(2\\pi f_1 t))$.\nThe phase is $\\phi_2(t) = 2\\pi f_1 t$.\nThe instantaneous frequency is constant:\n$$f_{\\text{IMF2}} = \\frac{1}{2\\pi}\\frac{d}{dt}(2\\pi f_1 t) = f_1$$\n\nThe ordered pair of instantaneous frequencies is $(f_{\\text{IMF1}}, f_{\\text{IMF2}}) = (f_2, f_1)$. This is to be reported as a $1\\times 2$ row matrix.", "answer": "$$ \\boxed{\\begin{pmatrix} f_2 & f_1 \\end{pmatrix}} $$", "id": "2869022"}, {"introduction": "Moving from ideal theory to real-world application, we must confront the challenges of implementing EMD for finite-length signals, the most significant of which is the \"end effect.\" Since the envelopes are constructed using spline interpolation, their behavior at the signal's boundaries is undefined without additional information, and this choice can propagate errors inward. This comprehensive coding exercise [@problem_id:2868999] challenges you to implement the EMD sifting process and directly compare three common endpoint extension techniques, quantifying their impact on the final decomposition using an orthogonality index. This practice develops crucial skills for robustly applying EMD to practical data analysis tasks.", "problem": "Consider a finite-length, discrete-time signal $x[n]$ of length $N=512$ sampled at uniform intervals, with $n \\in \\{0,1,\\dots, N-1\\}$. The goal is to extract the first Intrinsic Mode Function (IMF) via Empirical Mode Decomposition (EMD) using three endpoint extension schemes and to quantify the interaction between the extracted IMF and its residual by the orthogonality index.\n\nStart from the core definitions of Empirical Mode Decomposition (EMD) and sifting: An Intrinsic Mode Function (IMF) is a function whose number of extrema and number of zero crossings differ at most by one, and whose local mean (defined by the mean of the upper and lower envelopes obtained from local maxima and minima, respectively) is approximately zero. The EMD sifting process constructs these envelopes by interpolating the local maxima and minima and iteratively subtracts their mean from the current signal until the IMF conditions are met according to a specified stopping criterion. For envelope construction, use cubic spline interpolation through the detected extrema. For this problem, all trigonometric arguments must be in radians.\n\nImplement the following precise algorithmic specifications:\n\n- Envelope construction:\n  - Detect local maxima and minima by sign changes of the first difference of the signal. When a first difference equals zero, treat it as an infinitesimal positive value for sign determination.\n  - Construct the upper and lower envelopes as cubic splines (not-a-knot boundary condition) through the local maxima and minima, respectively.\n  - To mitigate end effects, build envelopes on an extended signal of length $N+2M$ with extension length $M=64$, then restrict the envelopes back to indices $n \\in \\{0,\\dots,N-1\\}$.\n- Endpoint extensions for the extended signal $x_{\\text{ext}}[m]$, $m \\in \\{0,\\dots, N+2M-1\\}$, with the original $x[n]$ placed at indices $m \\in \\{M,\\dots, M+N-1\\}$:\n  - Mirror extension (reflect without duplicating the endpoint):\n    - For $i \\in \\{0,\\dots, M-1\\}$, set $x_{\\text{ext}}[i] = x[M - i]$ and $x_{\\text{ext}}[M+N+i] = x[N-2 - i]$.\n  - Even extension (symmetric with endpoint duplication):\n    - For $i \\in \\{0,\\dots, M-1\\}$, set $x_{\\text{ext}}[i] = x[M-1 - i]$ and $x_{\\text{ext}}[M+N+i] = x[N-1 - i]$.\n  - Odd extension (antisymmetric about the endpoint value):\n    - For $i \\in \\{0,\\dots, M-1\\}$, set $x_{\\text{ext}}[i] = 2x[0] - x[M - i]$ and $x_{\\text{ext}}[M+N+i] = 2x[N-1] - x[N-2 - i]$.\n- Sifting process to extract the first IMF $c_1[n]$ from $x[n]$:\n  - Initialize $h^{(0)}[n] = x[n]$.\n  - For iterations $k=1,2,\\dots$:\n    - On $h^{(k-1)}[n]$, compute upper and lower envelopes $u^{(k-1)}[n]$ and $\\ell^{(k-1)}[n]$ via the above extension and cubic splines, and define the mean $m^{(k-1)}[n] = \\tfrac{1}{2}\\left(u^{(k-1)}[n] + \\ell^{(k-1)}[n]\\right)$.\n    - Update $h^{(k)}[n] = h^{(k-1)}[n] - m^{(k-1)}[n]$.\n    - Let $E^{(k)}$ be the number of extrema of $h^{(k)}[n]$ and $Z^{(k)}$ its number of zero crossings. Define the normalized standard deviation $SD^{(k)} = \\dfrac{\\sum_{n=0}^{N-1} \\left(h^{(k-1)}[n] - h^{(k)}[n]\\right)^2}{\\sum_{n=0}^{N-1} \\left(h^{(k-1)}[n]\\right)^2}$.\n    - Stop sifting and set $c_1[n] = h^{(k)}[n]$ if simultaneously $\\left|E^{(k)} - Z^{(k)}\\right| \\le 1$ and $SD^{(k)} < 0.2$, or if a hard limit of $100$ sifts is reached.\n  - Define the residual $r_1[n] = x[n] - c_1[n]$.\n- Orthogonality index between $c_1[n]$ and $r_1[n]$:\n  - Compute $\\mathrm{OI}(c_1,r_1) = \\dfrac{\\sum_{n=0}^{N-1} c_1[n]\\, r_1[n]}{\\sum_{n=0}^{N-1} \\left(c_1[n]^2 + r_1[n]^2\\right)}$.\n\nTest suite. Use $N=512$ and the following three deterministic signals:\n\n- Case A (amplitude/frequency modulation plus trend): $x_A[n] = \\left(1 + 0.5 \\cos\\!\\left(2\\pi \\dfrac{n}{64}\\right)\\right)\\cos\\!\\left(2\\pi \\dfrac{n}{8} + 0.02\\, \\dfrac{n^2}{N}\\right) + 0.3 \\cos\\!\\left(2\\pi \\dfrac{n}{32}\\right) + 0.5 \\dfrac{n}{N}$.\n- Case B (weak oscillation with strong monotonic component): $x_B[n] = 0.002 \\left(\\dfrac{n - N/2}{N}\\right)^3 N + 0.2 \\cos\\!\\left(2\\pi \\dfrac{n}{64}\\right)$. Note that the polynomial term is scaled to produce a noticeable trend across the record.\n- Case C (high-frequency narrowband): $x_C[n] = \\cos\\!\\left(2\\pi \\cdot 0.45 \\cdot n\\right)$.\n\nFor each of the three cases, extract the first IMF using each of the three endpoint extension schemes (mirror, even, odd), compute the residual, and then compute the orthogonality index. Round the orthogonality index values to six decimal places.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of the three orthogonality indices for mirror, even, and odd extensions for a given test signal, in the order A, B, C. For example, the required shape is exactly of the form $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$, where each symbol denotes a real number rounded to six decimals and printed as a floating-point literal.", "solution": "The user has provided a well-defined problem in the domain of signal processing, specifically concerning the implementation of the Empirical Mode Decomposition (EMD) sifting process. The problem has been validated and found to be scientifically grounded, well-posed, and objective. It contains precise algorithmic specifications, including signal definitions, endpoint extension schemes, envelope construction methods, a sifting stopping criterion, and the final evaluation metric. While there is a minor ambiguity in the definition of \"zero crossings\" for a discrete signal and a non-standard definition for \"mirror\" extension, the problem provides sufficient detail—including explicit formulae for the extensions—to permit a unique and verifiable solution. A standard, robust interpretation will be adopted for any minor unspecified details. The problem is therefore deemed **valid**.\n\nThe solution will be implemented by following the specified algorithmic steps. The core of the task is to extract the first Intrinsic Mode Function (IMF), denoted as $c_1[n]$, from three different test signals using a sifting process. This process is repeated for three distinct endpoint extension techniques: a non-standard but explicitly defined \"mirror\" extension, a standard \"even\" (symmetric) extension, and a standard \"odd\" (antisymmetric) extension.\n\nThe process for each signal and each extension method is as follows:\n\n1.  **Signal Generation**: The input signal $x[n]$ of length $N=512$ is generated according to its mathematical formula.\n\n2.  **Sifting for the First IMF**: The first IMF, $c_1[n]$, is extracted from $x[n]$ through an iterative sifting process.\n    -   Initialize a temporary signal $h^{(0)}[n] = x[n]$.\n    -   In each iteration $k=1, 2, \\dots$, the following sub-steps are performed:\n        a.  **Endpoint Extension**: The current signal $h^{(k-1)}[n]$ is extended at both ends by a length of $M=64$. The specific formulae for \"mirror\", \"even\", and \"odd\" extensions are applied as per the problem statement. This creates an extended signal $h^{(k-1)}_{\\text{ext}}$ of length $N+2M$.\n        b.  **Extrema Identification**: Local maxima and minima of the extended signal $h^{(k-1)}_{\\text{ext}}$ are identified. This is done by finding sign changes in its first-order difference, where a difference of zero is treated as positive, per the problem specification. This method correctly identifies peaks, troughs, and relevant saddle points.\n        c.  **Envelope Construction**: An upper envelope $u^{(k-1)}_{\\text{ext}}$ and a lower envelope $\\ell^{(k-1)}_{\\text{ext}}$ are constructed by fitting cubic splines with \"not-a-knot\" boundary conditions through the identified maxima and minima, respectively. These splines are evaluated over the entire domain of the extended signal.\n        d.  **Mean Envelope Calculation**: The envelopes are restricted to the original signal's domain, yielding $u^{(k-1)}[n]$ and $\\ell^{(k-1)}[n]$. The mean envelope is calculated as $m^{(k-1)}[n] = \\frac{1}{2}\\left(u^{(k-1)}[n] + \\ell^{(k-1)}[n]\\right)$.\n        e.  **Sifting Update**: The next iteration's signal is computed by subtracting the mean envelope: $h^{(k)}[n] = h^{(k-1)}[n] - m^{(k-1)}[n]$.\n    -   **Stopping Criterion**: After each iteration, a two-part stopping criterion is checked. The process halts if both conditions are met:\n        1.  The number of extrema $E^{(k)}$ and the number of zero crossings $Z^{(k)}$ of $h^{(k)}[n]$ differ by at most one, i.e., $|E^{(k)} - Z^{(k)}| \\le 1$.\n        2.  The normalized standard deviation, $SD^{(k)} = \\frac{\\sum (m^{(k-1)}[n])^2}{\\sum (h^{(k-1)}[n])^2}$, falls below the threshold of $0.2$.\n        A hard limit of $100$ iterations is also enforced to prevent an infinite loop.\n    -   Once the sifting process stops at iteration $k$, the resulting signal is designated as the first IMF: $c_1[n] = h^{(k)}[n]$.\n\n3.  **Residual Calculation**: The first residual signal is computed as the difference between the original signal and the first IMF: $r_1[n] = x[n] - c_1[n]$.\n\n4.  **Orthogonality Index**: The degree of orthogonality between the extracted IMF $c_1[n]$ and its residual $r_1[n]$ is quantified using the specified orthogonality index (OI):\n    $$\n    \\mathrm{OI}(c_1, r_1) = \\frac{\\sum_{n=0}^{N-1} c_1[n] r_1[n]}{\\sum_{n=0}^{N-1} (c_1[n]^2 + r_1[n]^2)}\n    $$\n    A value of $\\mathrm{OI}$ close to $0$ indicates good orthogonality, which is a desirable property of the EMD decomposition.\n\nThis entire procedure is applied to all three test cases (A, B, and C) for each of the three extension modes (mirror, even, odd). The final results, rounded to six decimal places, are collected and presented in the specified nested list format.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the EMD problem by extracting the first IMF using three different\n    endpoint extension schemes and calculating the orthogonality index.\n    \"\"\"\n\n    def extend_signal(signal: np.ndarray, M: int, mode: str) -> np.ndarray:\n        \"\"\"Applies endpoint extension to the signal.\"\"\"\n        N = len(signal)\n        # The problem statement's parameters (N=512, M=64) ensure N > M+1,\n        # so simplified slicing is safe.\n        if mode == 'mirror':\n            left_ext = signal[1:M + 1][::-1]\n            right_ext = signal[N - M - 1:N - 1][::-1]\n        elif mode == 'even':\n            left_ext = signal[0:M][::-1]\n            right_ext = signal[N - M:N][::-1]\n        elif mode == 'odd':\n            left_ext = 2 * signal[0] - signal[1:M + 1][::-1]\n            right_ext = 2 * signal[N - 1] - signal[N - M - 1:N - 1][::-1]\n        else:\n            raise ValueError(\"Invalid extension mode specified.\")\n        \n        return np.concatenate([left_ext, signal, right_ext])\n\n    def compute_mean_envelope(h: np.ndarray, M: int, ext_mode: str) -> np.ndarray:\n        \"\"\"Computes the mean of the upper and lower envelopes.\"\"\"\n        N = len(h)\n        h_ext = extend_signal(h, M, ext_mode)\n        \n        d_ext = np.diff(h_ext)\n        max_idx = np.where((d_ext[:-1] >= 0) & (d_ext[1:] < 0))[0] + 1\n        min_idx = np.where((d_ext[:-1] < 0) & (d_ext[1:] >= 0))[0] + 1\n\n        if len(max_idx) < 2 or len(min_idx) < 2:\n            return np.zeros_like(h)\n\n        t_ext = np.arange(N + 2 * M)\n        try:\n            spl_upper = CubicSpline(max_idx, h_ext[max_idx], bc_type='not-a-knot', extrapolate=True)\n            spl_lower = CubicSpline(min_idx, h_ext[min_idx], bc_type='not-a-knot', extrapolate=True)\n        except ValueError:\n            # This can happen if extrema are not unique, though unlikely\n            return np.zeros_like(h)\n\n        env_upper_ext = spl_upper(t_ext)\n        env_lower_ext = spl_lower(t_ext)\n        \n        mean_env_ext = (env_upper_ext + env_lower_ext) / 2.0\n        \n        return mean_env_ext[M : M + N]\n\n    def get_imf1(x: np.ndarray, M: int, ext_mode: str, sd_thresh: float, max_sifts: int) -> np.ndarray:\n        \"\"\"Performs the sifting process to extract the first IMF.\"\"\"\n        h = x.copy()\n        \n        for _ in range(max_sifts):\n            h_prev = h.copy()\n            \n            m = compute_mean_envelope(h_prev, M, ext_mode)\n            \n            if not np.any(m):\n                break\n\n            h = h_prev - m\n            \n            sd_num = np.sum(m**2)\n            sd_den = np.sum(h_prev**2)\n            sd = sd_num / sd_den if sd_den > 1e-12 else 0.0\n\n            d = np.diff(h)\n            num_max = np.sum((d[:-1] >= 0) & (d[1:] < 0))\n            num_min = np.sum((d[:-1] < 0) & (d[1:] >= 0))\n            E = num_max + num_min\n            \n            Z = len(np.where(np.diff(np.sign(h)))[0])\n\n            if abs(E - Z) <= 1 and sd < sd_thresh:\n                break\n                \n        return h\n\n    def calculate_oi(c1: np.ndarray, r1: np.ndarray) -> float:\n        \"\"\"Calculates the orthogonality index.\"\"\"\n        numerator = np.sum(c1 * r1)\n        denominator = np.sum(c1**2 + r1**2)\n        return numerator / denominator if denominator != 0 else 0.0\n\n    # Main execution\n    N = 512\n    M = 64\n    n = np.arange(N)\n    sd_thresh = 0.2\n    max_sifts = 100\n\n    # Define test signals\n    x_A = (1 + 0.5 * np.cos(2 * np.pi * n / 64)) * np.cos(2 * np.pi * n / 8 + 0.02 * n**2 / N) \\\n          + 0.3 * np.cos(2 * np.pi * n / 32) + 0.5 * n / N\n    x_B = 0.002 * ((n - N / 2) / N)**3 * N + 0.2 * np.cos(2 * np.pi * n / 64)\n    x_C = np.cos(2 * np.pi * 0.45 * n)\n\n    test_signals = [x_A, x_B, x_C]\n    ext_modes = ['mirror', 'even', 'odd']\n    \n    all_results = []\n    \n    for x in test_signals:\n        case_results = []\n        for mode in ext_modes:\n            c1 = get_imf1(x, M, mode, sd_thresh, max_sifts)\n            r1 = x - c1\n            oi = calculate_oi(c1, r1)\n            case_results.append(round(oi, 6))\n        all_results.append(case_results)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2868999"}, {"introduction": "Once a signal has been decomposed into a set of Intrinsic Mode Functions (IMFs), the final step of the Hilbert-Huang Transform is to perform Hilbert Spectral Analysis. This involves computing the instantaneous frequency and amplitude for each IMF, which requires first constructing its corresponding analytic signal. This problem [@problem_id:2868956] focuses on the practical, computational foundation of this step: building the discrete analytic signal in the frequency domain using the Fast Fourier Transform (FFT). By working through cases including non-bin-centered sinusoids and the boundary conditions of DC and Nyquist frequencies, you will solidify your understanding of this essential digital signal processing technique.", "problem": "Consider the construction of the analytic signal used in Hilbert spectral analysis within the Hilbert-Huang Transform (HHT). Given a real, finite-length, discrete-time sequence $x[n]$ of length $N$, the analytic signal $z[n]$ is a complex sequence whose Discrete-Time Fourier Transform (DTFT) is supported only on nonnegative angular frequencies. In the discrete, finite-length setting, one can realize this by a frequency-domain construction using the Discrete Fourier Transform (DFT) implemented by the Fast Fourier Transform (FFT).\n\nYour task is to implement, from first principles, the FFT-based construction of the analytic signal for length-$N$ real sequences and then determine which one-sided frequency bins are effectively nonzero in the DFT of the analytic signal.\n\nBase your derivation and implementation only on the following well-tested facts:\n- The Discrete Fourier Transform (DFT) and its inverse are defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-j \\frac{2\\pi}{N} kn}, \\quad k=0,\\dots,N-1,\n$$\n$$\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{j \\frac{2\\pi}{N} kn}, \\quad n=0,\\dots,N-1.\n$$\n- The analytic signal $z[n] = x[n] + j\\,\\hat{x}[n]$ is characterized in the continuous-time frequency domain by suppressing negative frequencies and preserving nonnegative frequencies appropriately. In particular, for a real signal, the continuous-time analytic spectrum $Z(\\omega)$ satisfies $Z(\\omega)=0$ for $\\omega < 0$, and $Z(\\omega)$ agrees with $X(\\omega)$ on $\\omega=0$ and retains the positive-frequency content in a way that ensures $z[n]$ is complex with $x[n]$ as its real part.\n- Real signals have conjugate-symmetric DFTs: if $x[n] \\in \\mathbb{R}$, then $X[k] = \\overline{X[(-k)\\bmod N]}$.\n\nYour program must:\n1. For each specified test case, form $x[n]$ for $n=0,\\dots,N-1$ with $N=64$, compute its DFT $X[k]$, construct the frequency-domain analytic spectrum via a frequency-domain window derived from the continuous signum-law characterization of the Hilbert transform, and then compute the analytic signal $z[n]$ via the inverse DFT of that windowed spectrum.\n2. From the analytic spectrum, extract the one-sided DFT magnitude on the bins $k=0,1,\\dots,N/2$ (since $N$ is even). Declare a bin $k$ as “effectively nonzero” if its magnitude exceeds a relative threshold $\\tau$ defined by\n$$\n\\tau = 10^{-12}\\,\\max_{0\\leq k \\leq N-1} |Z[k]|,\n$$\nwhere $Z[k]$ denotes the DFT of the analytic signal. Report the integer indices $k$ in the one-sided set $\\{0,1,\\dots,N/2\\}$ whose magnitudes exceed $\\tau$.\n3. Use angular frequency in radians per sample throughout. No physical units are involved, and there are no angles to convert between radians and degrees other than the specified angular frequencies.\n\nTest suite (all with $N=64$ and $n=0,\\dots,63$):\n- Case $1$ (general non-bin-centered cosine): $x[n] = \\cos(0.2\\pi\\, n)$.\n- Case $2$ (bin-centered cosine): $x[n] = \\cos(0.25\\pi\\, n)$.\n- Case $3$ (direct current signal): $x[n] = \\cos(0\\, n)$.\n- Case $4$ (Nyquist-frequency cosine): $x[n] = \\cos(\\pi\\, n)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a bracketed, comma-separated list of the integer indices of the effectively nonzero one-sided bins. For example, a valid output format is\n$[ [k\\_0^{(1)},k\\_1^{(1)},\\dots], [k\\_0^{(2)},\\dots], [\\dots], [\\dots] ]$\nbut printed with no spaces. Concretely, your program must print exactly one line in the form\n`[[...],[...],[...],[...]]`\nwith integer indices and no spaces anywhere in the line.\n\nYour implementation must be self-contained and must not require any user input. The only outputs to be graded are the lists of indices as described above. The correctness criterion encompasses:\n- Correct derivation and use of the frequency-domain window that suppresses negative frequencies in the DFT while preserving $k=0$ and $k=N/2$ appropriately for even $N$.\n- Correct identification of one-sided, effectively nonzero bins under the relative threshold $\\tau$ for all test cases, including the boundary cases at direct current and the Nyquist frequency.", "solution": "The problem posed is valid, as it is self-contained, scientifically grounded in the principles of digital signal processing, and mathematically well-posed. It requires the implementation of a standard, albeit nuanced, procedure for constructing the analytic signal for a discrete-time sequence. We shall proceed with the derivation and solution.\n\nThe analytic signal $z[n]$ corresponding to a real signal $x[n]$ is a complex signal whose frequency content is restricted to the non-negative frequencies. For discrete signals of finite length $N$, this construction is most efficiently performed in the frequency domain using the Discrete Fourier Transform (DFT).\n\nThe DFT of a sequence $x[n]$ of length $N$ is given by\n$$ X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-j \\frac{2\\pi}{N} kn}, \\quad k=0,\\dots,N-1 $$\nFor a real-valued signal $x[n]$, its DFT exhibits conjugate symmetry: $X[k] = \\overline{X[(-k)\\bmod N]}$. For an even length $N$, this implies $X[k] = \\overline{X[N-k]}$ for $k=1, \\dots, N-1$. The components $X[0]$ and $X[N/2]$ are necessarily real. The DFT bins from $k=1$ to $k=N/2-1$ represent positive frequencies, while the bins from $k=N/2+1$ to $k=N-1$ represent the corresponding negative frequencies. The bins $k=0$ (Direct Current, DC) and $k=N/2$ (Nyquist frequency) are their own negative frequency counterparts and are treated as boundary cases.\n\nTo construct the DFT of the analytic signal, $Z[k]$, we must suppress the negative frequency components. This is achieved by applying a specific windowing operation to the spectrum $X[k]$. The procedure, consistent with the continuous-time definition and ensuring that $\\operatorname{Re}\\{\\text{IDFT}(Z[k])\\} = x[n]$, is as follows for an even length $N$:\n\n1.  **Positive Frequencies ($1 \\le k < N/2$):** Both positive and negative frequency components of a real sinusoid contribute to its amplitude. To confine the total energy to the positive frequency range, we must double the amplitude of these components.\n    $$ Z[k] = 2X[k] \\quad \\text{for } 1 \\leq k < N/2 $$\n\n2.  **Negative Frequencies ($N/2 < k < N$):** These components are entirely suppressed.\n    $$ Z[k] = 0 \\quad \\text{for } N/2 < k < N $$\n\n3.  **Boundary Frequencies ($k=0$ and $k=N/2$):** The DC and Nyquist frequencies do not have distinct negative-frequency partners. Their energy is not split. Thus, they must not be doubled. We retain their original spectral values.\n    $$ Z[0] = X[0] $$\n    $$ Z[N/2] = X[N/2] $$\n\nThis completes the definition of $Z[k]$. The inverse DFT of $Z[k]$ would yield the complex analytic signal $z[n]$.\n\nThe problem requires us to identify which frequency bins in the one-sided spectrum, $k \\in \\{0, 1, \\dots, N/2\\}$, are \"effectively nonzero.\" A bin $k$ is deemed as such if its magnitude $|Z[k]|$ exceeds a relative threshold $\\tau$, defined as\n$$ \\tau = 10^{-12}\\,\\max_{0\\leq i \\leq N-1} |Z[i]| $$\nThis threshold is extremely low, meaning that any bin containing energy not diminished by more than a factor of $10^{12}$ relative to the peak will be included.\n\nWe now apply this methodology to the four specified test cases with $N=64$.\n\n**Case 1: $x[n] = \\cos(0.2\\pi\\, n)$**\nThe angular frequency $\\omega_0 = 0.2\\pi$ corresponds to a DFT index of $k_0 = \\omega_0 N / (2\\pi) = 0.2\\pi \\cdot 64 / (2\\pi) = 6.4$. Since this is not an integer, the signal is not periodic over the $N=64$ sample window. The DFT of this signal will exhibit spectral leakage, where the energy is centered around $k=6$ and $k=7$ but spreads across all other frequency bins. The DFT of a finite-length sinusoid is equivalent to the convolution of the ideal sinusoid's spectrum (two Dirac delta impulses) with the spectrum of the implicit rectangular window (a sinc function). The sinc function's magnitude decays slowly and never reaches zero. Consequently, when using double-precision floating-point arithmetic, all bins of the DFT, $X[k]$, will be numerically non-zero. After constructing $Z[k]$, and given the extremely small relative threshold $\\tau$, it is expected that all bins in the one-sided spectrum from $k=0$ to $k=N/2=32$ will have magnitudes exceeding $\\tau$.\n\n**Case 2: $x[n] = \\cos(0.25\\pi\\, n)$**\nThe angular frequency $\\omega_0 = 0.25\\pi$ corresponds to a DFT index of $k_0 = 0.25\\pi \\cdot 64 / (2\\pi) = 8$. This frequency is a bin center. As a result, there is no spectral leakage. The DFT, $X[k]$, will have exactly two non-zero components: $X[8]$ and its conjugate at $X[64-8] = X[56]$. According to our construction, $Z[8] = 2X[8]$ and all other $Z[k]$ will be zero (within machine precision). Therefore, only the bin $k=8$ will be identified as effectively nonzero.\n\n**Case 3: $x[n] = \\cos(0\\, n) = 1$**\nThis is a pure DC signal. Its frequency is $\\omega_0=0$, corresponding to the DFT index $k_0=0$. Its spectrum $X[k]$ is non-zero only at $k=0$, where $X[0]=N$. Our construction rule states $Z[0] = X[0]$. Thus, only the bin $k=0$ will be effectively nonzero.\n\n**Case 4: $x[n] = \\cos(\\pi\\, n)$**\nThis signal corresponds to the Nyquist frequency, $\\omega_0=\\pi$. The DFT index is $k_0 = \\pi \\cdot 64 / (2\\pi) = 32$. This is the special $k=N/2$ bin. The spectrum $X[k]$ is non-zero only at $k=32$. Our construction rule states $Z[N/2] = X[N/2]$. Therefore, only the bin $k=32$ will be effectively nonzero.\n\nThe implementation will proceed by calculating the DFT of each signal, constructing the analytic spectrum $Z[k]$ according to the derived rules, calculating the threshold $\\tau$, and comparing the magnitudes $|Z[k]|$ for $k=0, \\dots, 32$ against this threshold.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the effectively nonzero one-sided DFT bins of the analytic signal\n    for several test cases, based on the principles of the Hilbert-Huang Transform.\n    \"\"\"\n\n    def construct_analytic_spectrum(X):\n        \"\"\"\n        Constructs the DFT of the analytic signal from the DFT of a real signal.\n        This implementation is for even-length signals as specified in the problem.\n        \n        Args:\n            X (np.ndarray): The DFT of a real-valued signal x[n].\n        \n        Returns:\n            np.ndarray: The DFT of the corresponding analytic signal z[n].\n        \"\"\"\n        N = len(X)\n        Z = np.zeros_like(X, dtype=np.complex128)\n\n        if N % 2 == 0:\n            # For even N, as is the case here (N=64)\n            # Retain DC component\n            Z[0] = X[0]\n            # Double positive frequency components\n            Z[1:N//2] = 2.0 * X[1:N//2]\n            # Retain Nyquist component\n            Z[N//2] = X[N//2]\n            # Zero out negative frequency components (already zero by initialization)\n        else:\n            # Fallback for odd N (not used in this problem)\n            Z[0] = X[0]\n            Z[1:(N+1)//2] = 2.0 * X[1:(N+1)//2]\n\n        return Z\n\n    # Define common parameters for all test cases\n    N = 64\n    n = np.arange(N)\n\n    # Define the test signals as per the problem statement\n    test_cases = [\n        # Case 1: General non-bin-centered cosine\n        np.cos(0.2 * np.pi * n),\n        # Case 2: Bin-centered cosine\n        np.cos(0.25 * np.pi * n),\n        # Case 3: Direct current signal\n        np.cos(0.0 * n),\n        # Case 4: Nyquist-frequency cosine\n        np.cos(np.pi * n),\n    ]\n\n    results_all_cases = []\n    \n    for x in test_cases:\n        # Step 1: Compute the DFT of the signal\n        X = np.fft.fft(x)\n\n        # Step 2: Construct the DFT of the analytic signal\n        Z = construct_analytic_spectrum(X)\n        \n        # Step 3: Define the threshold for being 'effectively nonzero'\n        max_magnitude = np.max(np.abs(Z))\n        # Handle the case of an all-zero signal to prevent tau from being 0.\n        if max_magnitude == 0.0:\n            tau = 1.0 \n        else:\n            tau = 1e-12 * max_magnitude\n\n        # Step 4: Identify indices of effectively nonzero bins in the one-sided spectrum\n        # The one-sided spectrum includes bins k = 0, 1, ..., N/2\n        one_sided_magnitudes = np.abs(Z[0 : N//2 + 1])\n        nonzero_indices = np.where(one_sided_magnitudes > tau)[0].tolist()\n        \n        results_all_cases.append(nonzero_indices)\n\n    # Format the final output string as specified: [[...],[...],...] with no spaces.\n    list_of_strings = []\n    for sublist in results_all_cases:\n        list_of_strings.append(f\"[{','.join(map(str, sublist))}]\")\n    \n    final_output_string = f\"[{','.join(list_of_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2868956"}]}