{"hands_on_practices": [{"introduction": "The most direct way to understand time-invariance is to apply its definition rigorously. Does the order of operations—shifting the input versus shifting the output—matter? This first practice challenges you to move beyond intuition by formalizing this question for a discrete-time system with a time-dependent gain. By deriving a \"discrepancy operator,\" you will quantify the exact difference between shifting-then-transforming and transforming-then-shifting, providing an irrefutable proof of the system's time-varying nature [@problem_id:2910346].", "problem": "Let $T$ be a discrete-time system acting on an input sequence $x[n]$ to produce an output sequence $y[n]$ via the rule $y[n] = T\\{x\\}[n] = (-1)^{n} x[n]$. Consider the time-shift operator $S_{n_0}$ defined by $(S_{n_0}\\{x\\})[n] = x[n - n_0]$ for an integer shift $n_0 \\in \\mathbb{Z}$. Using only the fundamental definition of time invariance in discrete time—namely, that a system is time-invariant if shifting the input by $n_0$ and then applying the system yields the same output as applying the system first and then shifting the output by $n_0$—determine whether $T$ is time-invariant. To quantify any failure of time invariance, define the discrepancy operator\n$$\n\\Delta_{n_0}\\{x\\}[n] \\triangleq T\\{S_{n_0}\\{x\\}\\}[n] - S_{n_0}\\{T\\{x\\}\\}[n].\n$$\nDerive a closed-form expression for $\\Delta_{n_0}\\{x\\}[n]$ in terms of $x[n]$ and $n_0$. Your derivation must start from the definition of $S_{n_0}$ and the given input-output relation for $T$, and rely only on the fundamental definition of time invariance. As part of your reasoning, identify a specific choice of $x[n]$ and $n_0$ for which $\\Delta_{n_0}\\{x\\}[n] \\neq 0$ to conclude that $T$ is not time-invariant. \n\nProvide, as your final answer, the single closed-form analytic expression for $\\Delta_{n_0}\\{x\\}[n]$. No numerical evaluation, units, or rounding are required.", "solution": "The problem statement is subjected to validation before any attempt at a solution.\n\nStep 1: Extract Givens\nThe givens are listed verbatim from the problem statement:\n- The discrete-time system $T$ is defined by the input-output relation: $y[n] = T\\{x\\}[n] = (-1)^{n} x[n]$.\n- The input sequence is denoted by $x[n]$.\n- The output sequence is denoted by $y[n]$.\n- The time-shift operator $S_{n_0}$ is defined by $(S_{n_0}\\{x\\})[n] = x[n - n_0]$ for an integer shift $n_0 \\in \\mathbb{Z}$.\n- The fundamental definition of time invariance is that a system is time-invariant if shifting the input by $n_0$ and then applying the system yields the same output as applying the system first and then shifting the output by $n_0$. Formally, $T\\{S_{n_0}\\{x\\}\\} = S_{n_0}\\{T\\{x\\}\\}$.\n- The discrepancy operator is defined as $\\Delta_{n_0}\\{x\\}[n] \\triangleq T\\{S_{n_0}\\{x\\}\\}[n] - S_{n_0}\\{T\\{x\\}\\}[n]$.\n- The task is to determine if $T$ is time-invariant, to derive a closed-form expression for $\\Delta_{n_0}\\{x\\}[n]$, and to provide a specific counterexample where $\\Delta_{n_0}\\{x\\}[n] \\neq 0$.\n\nStep 2: Validate Using Extracted Givens\nThe problem is analyzed against the specified criteria.\n- **Scientifically Grounded:** The problem is a standard exercise in the field of digital signal processing and systems theory. The concepts of discrete-time systems, operators, and the property of time invariance are fundamental and well-defined within this domain. The problem is scientifically sound.\n- **Well-Posed:** The problem provides all necessary definitions for the system and operators, and it clearly states the tasks to be performed. A unique analytical expression for the discrepancy operator can be derived. The problem is well-posed.\n- **Objective:** The problem is stated using precise mathematical language, free from ambiguity, subjectivity, or opinion-based claims.\n\nThe problem does not exhibit any of the flaws listed (Scientific Unsoundness, Non-Formalizable, Incomplete Setup, Unrealistic, Ill-Posed, Pseudo-Profound, Outside Verifiability).\n\nStep 3: Verdict and Action\nThe problem is deemed valid. A complete, reasoned solution will now be provided.\n\nThe objective is to determine if the system $T$ defined by $y[n] = (-1)^{n} x[n]$ is time-invariant. The criterion for time invariance is that the output due to a shifted input must be equal to the shifted output. That is, the system is time-invariant if and only if $T\\{S_{n_0}\\{x\\}\\}[n] = S_{n_0}\\{T\\{x\\}\\}[n]$ for all possible input signals $x[n]$ and all integer time shifts $n_0$. We will compute both terms and find the discrepancy $\\Delta_{n_0}\\{x\\}[n]$.\n\nFirst, we compute the output from a time-shifted input. Let the shifted input be $x_1[n] = (S_{n_0}\\{x\\})[n] = x[n - n_0]$. The system $T$ acts on this input $x_1[n]$ to produce an output $y_1[n]$:\n$$y_1[n] = T\\{x_1\\}[n] = (-1)^{n} x_1[n]$$\nSubstituting the definition of $x_1[n]$, we get the first term of the discrepancy operator:\n$$T\\{S_{n_0}\\{x\\}\\}[n] = (-1)^{n} x[n - n_0]$$\n\nSecond, we compute the time-shifted output. The original output of the system for an input $x[n]$ is $y[n] = T\\{x\\}[n] = (-1)^{n} x[n]$. Now, we apply the time-shift operator $S_{n_0}$ to this output signal $y[n]$. The result, let us call it $y_2[n]$, is:\n$$y_2[n] = (S_{n_0}\\{y\\})[n] = y[n - n_0]$$\nTo find the explicit form, we substitute the definition of $y[n]$ into this expression. It is crucial to replace every instance of the time index $n$ in the expression for $y[n]$ with $(n - n_0)$:\n$$S_{n_0}\\{T\\{x\\}\\}[n] = (-1)^{n - n_0} x[n - n_0]$$\n\nNow we can compute the discrepancy operator $\\Delta_{n_0}\\{x\\}[n]$ as defined:\n$$\\Delta_{n_0}\\{x\\}[n] = T\\{S_{n_0}\\{x\\}\\}[n] - S_{n_0}\\{T\\{x\\}\\}[n]$$\n$$\\Delta_{n_0}\\{x\\}[n] = (-1)^{n} x[n - n_0] - (-1)^{n - n_0} x[n - n_0]$$\nWe can factor out the common term $x[n - n_0]$:\n$$\\Delta_{n_0}\\{x\\}[n] = \\left( (-1)^{n} - (-1)^{n - n_0} \\right) x[n - n_0]$$\nTo simplify the expression in the parenthesis, we use the property of exponents $(-1)^{a-b} = (-1)^a (-1)^{-b}$. Since $-1 = (-1)^{-1}$, we have $(-1)^{-b} = (-1)^b$. Thus, $(-1)^{n-n_0} = (-1)^n (-1)^{-n_0} = (-1)^n (-1)^{n_0}$.\nSubstituting this back into the expression for the discrepancy:\n$$\\Delta_{n_0}\\{x\\}[n] = \\left( (-1)^{n} - (-1)^{n} (-1)^{n_0} \\right) x[n - n_0]$$\nFactoring out the term $(-1)^{n}$ yields the final closed-form expression:\n$$\\Delta_{n_0}\\{x\\}[n] = (-1)^{n} \\left( 1 - (-1)^{n_0} \\right) x[n - n_0]$$\n\nFor the system to be time-invariant, $\\Delta_{n_0}\\{x\\}[n]$ must be identically zero for all $x[n]$, all $n$, and all integer shifts $n_0$. This requires the factor $(1 - (-1)^{n_0})$ to be zero for all $n_0 \\in \\mathbb{Z}$.\nIf $n_0$ is an even integer, $n_0 = 2k$ for some integer $k$, then $(-1)^{n_0} = (-1)^{2k} = 1$, and $(1 - (-1)^{n_0}) = 1 - 1 = 0$.\nHowever, if $n_0$ is an odd integer, $n_0 = 2k + 1$, then $(-1)^{n_0} = (-1)^{2k+1} = -1$, and $(1 - (-1)^{n_0}) = 1 - (-1) = 2$.\nSince the factor is not zero for all integer shifts $n_0$, the discrepancy $\\Delta_{n_0}\\{x\\}[n]$ is not identically zero. Therefore, the system $T$ is not time-invariant; it is time-varying.\n\nTo provide a specific counterexample, we must choose an input $x[n]$ and an odd shift $n_0$ such that the result is non-zero. Let us choose a simple non-trivial input, the Kronecker delta function $x[n] = \\delta[n]$, and an odd shift, $n_0 = 1$.\nThe discrepancy is:\n$$\\Delta_{1}\\{\\delta\\}[n] = (-1)^{n} \\left( 1 - (-1)^{1} \\right) \\delta[n - 1]$$\n$$\\Delta_{1}\\{\\delta\\}[n] = (-1)^{n} \\left( 1 - (-1) \\right) \\delta[n - 1] = 2 (-1)^{n} \\delta[n - 1]$$\nThis expression is zero for all $n \\neq 1$. At $n = 1$, we have:\n$$\\Delta_{1}\\{\\delta\\}[1] = 2 (-1)^{1} \\delta[1 - 1] = -2 \\delta[0] = -2$$\nSince $\\Delta_{1}\\{\\delta\\}[1] = -2 \\neq 0$, we have a specific counterexample that confirms the system is not time-invariant. The derivation of the general formula for the discrepancy operator is the primary result requested.", "answer": "$$\n\\boxed{(-1)^{n} (1 - (-1)^{n_{0}}) x[n - n_{0}]}\n$$", "id": "2910346"}, {"introduction": "A common pitfall in analyzing system properties is mistaking a special case for a general rule. A system might coincidentally behave as if it is time-invariant for a specific set of time shifts, yet fail the general test. This exercise explores that subtlety with a system whose gain varies periodically, forcing a careful examination of the \"for every shift $\\tau$\" condition in the definition of time-invariance [@problem_id:2910380]. This practice demonstrates that commutation with some shifts is not enough, reinforcing the strictness of the time-invariance property.", "problem": "Let $\\mathcal{X}$ denote the vector space of real-valued, continuous-time signals $x : \\mathbb{R} \\to \\mathbb{R}$. For $\\tau \\in \\mathbb{R}$, define the time-shift operator $S_{\\tau} : \\mathcal{X} \\to \\mathcal{X}$ by $[S_{\\tau} x](t) = x(t - \\tau)$ for all $t \\in \\mathbb{R}$. A system (operator) $T : \\mathcal{X} \\to \\mathcal{X}$ is called time-invariant if, for every $\\tau \\in \\mathbb{R}$ and every $x \\in \\mathcal{X}$, the identity $T S_{\\tau} x = S_{\\tau} T x$ holds pointwise in $t$. These are the only permitted starting points.\n\nConsider the operator $T : \\mathcal{X} \\to \\mathcal{X}$ given by\n$$\n[T x](t) = \\cos(\\omega_{0} t)\\, x(t),\n$$\nwhere $\\omega_{0}  0$ is a fixed constant.\n\n1. Using only the definitions above and first principles, determine all values of $\\tau \\in \\mathbb{R}$ for which $T$ and $S_{\\tau}$ commute, that is, for which $T S_{\\tau} = S_{\\tau} T$ as operators on $\\mathcal{X}$. Provide the set of such $\\tau$ in closed form.\n\n2. Explain rigorously why $T$ is not time-invariant, even though there exist nonzero shift values for which $T$ and $S_{\\tau}$ commute.\n\n3. Let $\\tau_{0}  0$ denote the smallest positive value of $\\tau$ for which $T$ and $S_{\\tau}$ commute. Define $\\tau_{\\star} = \\tau_{0}/2$. For the input $x(t) = \\exp(-a t^{2})$ with $a  0$, compute the commutator output\n$$\ny(t) = [T S_{\\tau_{\\star}} x](t) - [S_{\\tau_{\\star}} T x](t)\n$$\nin closed form as a function of $t$, $a$, and $\\omega_{0}$. Your final answer must be a single closed-form analytic expression. Do not approximate or round.", "solution": "The problem as stated is well-defined, scientifically sound, and internally consistent. It poses a standard inquiry into the properties of linear operators in the context of signal processing theory. We will proceed to solve it based entirely on the provided definitions and first principles.\n\nThe system is defined by the operator $T$ such that $[T x](t) = \\cos(\\omega_{0} t)\\, x(t)$, where $\\omega_{0}  0$. The time-shift operator is $[S_{\\tau} x](t) = x(t - \\tau)$.\n\n1. We first seek all values of $\\tau \\in \\mathbb{R}$ for which the operators commute, i.e., $T S_{\\tau} = S_{\\tau} T$. This operator equality must hold for any input signal $x \\in \\mathcal{X}$. We evaluate the action of both sides of the equation on an arbitrary signal $x(t)$.\n\nThe left-hand side is $[T S_{\\tau} x](t)$. First, we apply the shift operator:\n$$\n[S_{\\tau} x](t) = x(t - \\tau).\n$$\nThen we apply the system operator $T$ to this new signal, $S_{\\tau} x$:\n$$\n[T (S_{\\tau} x)](t) = \\cos(\\omega_{0} t) [S_{\\tau} x](t) = \\cos(\\omega_{0} t) x(t - \\tau).\n$$\n\nThe right-hand side is $[S_{\\tau} T x](t)$. First, we apply the system operator $T$:\n$$\n[T x](t) = \\cos(\\omega_{0} t) x(t).\n$$\nThen we apply the shift operator $S_{\\tau}$ to this new signal, $T x$:\n$$\n[S_{\\tau} (T x)](t) = [T x](t - \\tau) = \\cos(\\omega_{0} (t - \\tau)) x(t - \\tau).\n$$\n\nFor the operators to commute, the results must be identical for all $x \\in \\mathcal{X}$ and all $t \\in \\mathbb{R}$:\n$$\n\\cos(\\omega_{0} t) x(t - \\tau) = \\cos(\\omega_{0} (t - \\tau)) x(t - \\tau).\n$$\nThis equation can be rearranged as:\n$$\n[\\cos(\\omega_{0} t) - \\cos(\\omega_{0} (t - \\tau))] x(t - \\tau) = 0.\n$$\nSince this identity must hold for any continuous signal $x(t)$, we can choose a signal $x(t)$ that is not identically zero. For instance, let $x(t)$ be a Gaussian function centered at some point such that $x(t-\\tau)$ is not zero for a range of $t$ values. For the equality to hold for an arbitrary choice of $x$, the coefficient must be identically zero for all $t \\in \\mathbb{R}$:\n$$\n\\cos(\\omega_{0} t) - \\cos(\\omega_{0} (t - \\tau)) = 0.\n$$\nThis implies $\\cos(\\omega_{0} t) = \\cos(\\omega_{0} t - \\omega_{0} \\tau)$ for all $t \\in \\mathbb{R}$. The general solution to $\\cos(A) = \\cos(B)$ is $A = \\pm B + 2 \\pi k$ for some integer $k \\in \\mathbb{Z}$.\n\nCase 1: $\\omega_{0} t = (\\omega_{0} t - \\omega_{0} \\tau) + 2 \\pi k$.\nThis simplifies to $\\omega_{0} \\tau = 2 \\pi k$, or $\\tau = \\frac{2 \\pi k}{\\omega_{0}}$. This condition is independent of $t$.\n\nCase 2: $\\omega_{0} t = -(\\omega_{0} t - \\omega_{0} \\tau) + 2 \\pi k$.\nThis simplifies to $2 \\omega_{0} t = \\omega_{0} \\tau + 2 \\pi k$. This equality must hold for all $t \\in \\mathbb{R}$. However, the left side is a function of $t$, while the right side is a constant for a fixed $\\tau$ and $k$. This is only possible if the coefficient of $t$ is zero, i.e., $2 \\omega_{0} = 0$, which contradicts the given condition $\\omega_{0}  0$. Thus, this case yields no solutions.\n\nThe only valid condition is $\\tau = \\frac{2 \\pi k}{\\omega_{0}}$ for $k \\in \\mathbb{Z}$. The set of all such $\\tau$ is therefore $\\left\\{ \\frac{2 \\pi k}{\\omega_{0}} \\mid k \\in \\mathbb{Z} \\right\\}$.\n\n2. The definition of time-invariance requires that $T S_{\\tau} = S_{\\tau} T$ for **every** $\\tau \\in \\mathbb{R}$. From our analysis in part 1, we have proven that this commutation relation holds only for a discrete, countably infinite set of values $\\tau = \\frac{2 \\pi k}{\\omega_{0}}$. Because the condition does not hold for all real numbers $\\tau$, the system $T$ is not time-invariant.\n\nTo be rigorous, we must show a counterexample. Choose a value of $\\tau$ not in the set, for instance, $\\tau = \\frac{\\pi}{\\omega_{0}}$. For this shift, we have:\n$$\n[T S_{\\pi/\\omega_{0}} x](t) = \\cos(\\omega_{0} t) x\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)\n$$\nand\n$$\n[S_{\\pi/\\omega_{0}} T x](t) = \\cos\\left(\\omega_{0}\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)\\right) x\\left(t - \\frac{\\pi}{\\omega_{0}}\\right) = \\cos(\\omega_{0} t - \\pi) x\\left(t - \\frac{\\pi}{\\omega_{0}}\\right) = -\\cos(\\omega_{0} t) x\\left(t - \\frac{\\pi}{\\omega_{0}}\\right).\n$$\nEquating these two expressions, $\\cos(\\omega_{0} t) = -\\cos(\\omega_{0} t)$, implies $2\\cos(\\omega_{0} t) = 0$. This is not true for all $t \\in \\mathbb{R}$. Therefore, for $\\tau = \\frac{\\pi}{\\omega_{0}}$, $T S_{\\tau} \\neq S_{\\tau} T$. The existence of even one such $\\tau$ for which commutation fails is sufficient to prove that the system is not time-invariant.\n\n3. We are asked to compute the commutator output $y(t) = [T S_{\\tau_{\\star}} x](t) - [S_{\\tau_{\\star}} T x](t)$ for a specific case.\nFirst, we identify $\\tau_{0}$, the smallest positive value of $\\tau$ for which the operators commute. From the set $\\left\\{ \\frac{2 \\pi k}{\\omega_{0}} \\mid k \\in \\mathbb{Z} \\right\\}$, the positive values are obtained for $k = 1, 2, 3, \\dots$. The smallest such value corresponds to $k=1$, so $\\tau_{0} = \\frac{2 \\pi}{\\omega_{0}}$.\n\nNext, we define $\\tau_{\\star} = \\frac{\\tau_{0}}{2} = \\frac{1}{2} \\left( \\frac{2 \\pi}{\\omega_{0}} \\right) = \\frac{\\pi}{\\omega_{0}}$.\n\nThe input signal is given as $x(t) = \\exp(-a t^{2})$ for $a0$.\n\nWe compute the two terms of the commutator output $y(t)$:\nThe first term is $[T S_{\\tau_{\\star}} x](t)$.\n$$\n[S_{\\tau_{\\star}} x](t) = x(t-\\tau_{\\star}) = \\exp(-a(t-\\tau_{\\star})^{2}).\n$$\n$$\n[T S_{\\tau_{\\star}} x](t) = \\cos(\\omega_{0} t) [S_{\\tau_{\\star}} x](t) = \\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right).\n$$\n\nThe second term is $[S_{\\tau_{\\star}} T x](t)$.\n$$\n[T x](t) = \\cos(\\omega_{0} t) x(t) = \\cos(\\omega_{0} t) \\exp(-at^{2}).\n$$\n$$\n[S_{\\tau_{\\star}} T x](t) = [T x](t - \\tau_{\\star}) = \\cos(\\omega_{0}(t - \\tau_{\\star})) \\exp(-a(t - \\tau_{\\star})^{2}).\n$$\nSubstituting $\\tau_{\\star} = \\frac{\\pi}{\\omega_{0}}$, the trigonometric factor becomes:\n$$\n\\cos(\\omega_{0}(t - \\tau_{\\star})) = \\cos\\left(\\omega_{0}\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)\\right) = \\cos(\\omega_{0} t - \\pi) = -\\cos(\\omega_{0} t).\n$$\nSo, the second term is:\n$$\n[S_{\\tau_{\\star}} T x](t) = -\\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right).\n$$\n\nFinally, we compute the difference $y(t)$:\n$$\ny(t) = [T S_{\\tau_{\\star}} x](t) - [S_{\\tau_{\\star}} T x](t)\n$$\n$$\ny(t) = \\left( \\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right) \\right) - \\left( -\\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right) \\right)\n$$\n$$\ny(t) = \\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right) + \\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right)\n$$\n$$\ny(t) = 2 \\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right).\n$$\nThis is the final closed-form expression for the commutator output.", "answer": "$$\n\\boxed{2 \\cos(\\omega_{0} t) \\exp\\left(-a\\left(t - \\frac{\\pi}{\\omega_{0}}\\right)^{2}\\right)}\n$$", "id": "2910380"}, {"introduction": "In practical signal processing, systems are often treated as \"black boxes\" that must be characterized through experimentation. This final practice bridges the gap between abstract theory and computational verification, tasking you with designing a numerical experiment to classify several systems. You will implement the formal definitions of time-invariance and linearity in code to test systems on finite-length signals, a process that mirrors real-world system identification [@problem_id:2910382]. The challenge lies not only in testing for time-invariance but also in designing tests that rigorously separate it from the distinct property of linearity.", "problem": "You are given the task of designing and implementing an identification experiment that separates violations of time invariance from violations of linearity for discrete-time systems by using time-shifted replicas and scaling/superposition tests on the same system. Work in the framework of discrete-time signal processing with sequences that are finite-length and zero-extended outside their nominal support. The fundamental base for your derivation and algorithm must be built from the following definitions.\n\nA discrete-time system is an operator that maps an input sequence to an output sequence. Let the system operator be denoted by $T$. Let the shift operator $S_k$ for integer $k$ act on a sequence $x[n]$ as $$(S_k x)[n] \\triangleq x[n-k],$$ and assume sequences are zero-extended outside the index set under consideration. The system $T$ is:\n- time-invariant if and only if for every input $x[n]$ and every integer shift $k$, $$T\\{S_k x\\}[n] = S_k \\{T x\\}[n],$$ where equality holds for all $n$.\n- linear if and only if for every pair of inputs $x_1[n]$, $x_2[n]$ and scalars $a$, $b$, $$T\\{a x_1 + b x_2\\}[n] = a T\\{x_1\\}[n] + b T\\{x_2\\}[n],$$ where equality holds for all $n$.\n\nYour program must implement a numerical experiment that uses the above definitions and finite-length sequences with zero extension to determine, for each of the systems listed below, whether it is time-invariant and whether it is linear, reported as booleans. The experiment must use both time-shifted replicas to test time invariance and scaling/superposition tests to test linearity. The logic must rigorously separate the two properties: failures in the time-shift test should be attributed to time-variance, and failures in the superposition/homogeneity tests should be attributed to nonlinearity.\n\nAll computations must be carried out on the finite index set $\\{0,1,2,\\dots,N-1\\}$ with $N = 64$, with the understanding that any reference to $x[n]$ at indices $n \\notin \\{0,\\dots,N-1\\}$ evaluates to $0$ (zero extension).\n\nSystems under test. For each system, interpret $x[n-k]$ for $n-k$ outside $\\{0,\\dots,N-1\\}$ as $0$:\n1. $T_1\\{x\\}[n] = 0.3\\,x[n] - 0.2\\,x[n-1] + 0.1\\,x[n-3]$.\n2. $T_2\\{x\\}[n] = \\bigl(1 + 0.01\\,n\\bigr)\\,x[n] + 0.5\\,x[n-1]$.\n3. $T_3\\{x\\}[n] = x[n]^2 + x[n-1]^2$.\n4. $T_4\\{x\\}[n] = x[n] + 1$.\n5. $T_5\\{x\\}[n] = x\\bigl[n - (-1)^n\\bigr]$.\n\nTest signals, shifts, and coefficients. Define the following input sequences on $\\{0,\\dots,N-1\\}$:\n- $\\delta[n-n_0]$ denotes the Kronecker delta, equal to $1$ at $n=n_0$ and $0$ otherwise.\n- $x^{(A)}[n] = \\sin(0.23\\pi n) + 0.4\\cos(0.07\\pi n) + \\delta[n-10]$,\n- $x^{(B)}[n] = \\cos(0.31\\pi n) - 0.3\\sin(0.11\\pi n) + 0.5\\,\\delta[n-3]$,\n- $x^{(C)}[n] = (-0.9)^n$.\n\nUse the integer shifts $k \\in \\{7, -5\\}$ in the time-invariance test, and the scalars $a = 0.7$, $b = -1.1$, $c = 1.5$ in the linearity tests. For numerical comparison, use the supremum norm (maximum absolute difference over all $n$) and declare equality if the supremum norm of the difference is less than or equal to $\\varepsilon$, where $\\varepsilon = 10^{-9}$.\n\nExperiment design requirements:\n- Time-invariance test: For each system $T_i$, and for each test input $x \\in \\{x^{(A)}, x^{(B)}\\}$ and each $k \\in \\{7, -5\\}$, verify whether $$T_i\\{S_k x\\}[n] \\stackrel{?}{=} S_k\\{T_i x\\}[n]$$ holds for all $n$ within the tolerance $\\varepsilon$. The system passes the time-invariance test if all such checks pass.\n- Linearity test: For each system $T_i$, verify both superposition and homogeneity using the same system:\n  - Superposition: check whether $$T_i\\{a x^{(A)} + b x^{(B)}\\}[n] \\stackrel{?}{=} a\\,T_i\\{x^{(A)}\\}[n] + b\\,T_i\\{x^{(B)}\\}[n]$$ holds for all $n$ within the tolerance $\\varepsilon$.\n  - Homogeneity: check whether $$T_i\\{c\\,x^{(C)}\\}[n] \\stackrel{?}{=} c\\,T_i\\{x^{(C)}\\}[n]$$ holds for all $n$ within the tolerance $\\varepsilon$.\n  The system passes the linearity test only if both checks pass.\n\nPhysical units are not applicable. Angles in trigonometric functions are in radians. All reported booleans must be exact logical values and not strings or numbers.\n\nTest suite and required output. Apply the above experiment to all five systems. The final output of your program must be a single line containing a comma-separated list of five entries, one per system in the order $T_1$ through $T_5$. Each entry must itself be a two-element list of booleans in the order $[\\text{time\\_invariant}, \\text{linear}]$. The line must have no spaces and must be enclosed in square brackets. For example, an output for two systems would look like $[[\\text{True},\\text{False}],[\\text{False},\\text{True}]]$; for this problem with five systems, your program must print a single line in that exact nested-list format with booleans.", "solution": "The problem requires the design and implementation of a numerical experiment to classify five discrete-time systems based on the properties of time-invariance and linearity. The validation of these properties must be performed according to the strict mathematical definitions provided, operating on finite-length sequences over the index set $n \\in \\{0, 1, \\dots, N-1\\}$ where $N=64$. The problem is well-posed, scientifically grounded, and provides all necessary specifications for a unique, verifiable solution.\n\nThe core of the solution is the translation of the abstract definitions of system properties into a concrete computational algorithm. A discrete-time system $T$ is a mapping from an input sequence $x[n]$ to an output sequence $y[n] = T\\{x\\}[n]$.\n\nFirst, we define the fundamental operators and signals. The index range is $n \\in \\{0, 1, \\dots, 63\\}$. All signals are represented as numerical arrays of length $N=64$.\n\nThe shift operator, $S_k$, is defined as $(S_k x)[n] \\triangleq x[n-k]$. For a finite-length sequence $x[n]$ defined on $\\{0, \\dots, N-1\\}$ and assumed to be zero elsewhere (zero-extension), the shifted sequence $y[n] = (S_k x)[n]$ is also defined on $\\{0, \\dots, N-1\\}$. This is implemented by creating a new zero-initialized array $y$ of length $N$. If $k  0$ (a delay), the elements $x[0], \\dots, x[N-1-k]$ are copied to $y[k], \\dots, y[N-1]$. If $k  0$ (an advance), let $k' = -k$. The elements $x[k'], \\dots, x[N-1]$ are copied to $y[0], \\dots, y[N-1-k']$.\n\nThe test signals $x^{(A)}[n]$, $x^{(B)}[n]$, and $x^{(C)}[n]$ are generated over the discrete domain $n \\in \\{0, \\dots, 63\\}$ according to their definitions:\n- $x^{(A)}[n] = \\sin(0.23\\pi n) + 0.4\\cos(0.07\\pi n) + \\delta[n-10]$\n- $x^{(B)}[n] = \\cos(0.31\\pi n) - 0.3\\sin(0.11\\pi n) + 0.5\\,\\delta[n-3]$\n- $x^{(C)}[n] = (-0.9)^n$\nHere, $\\delta[n-n_0]$ is the Kronecker delta sequence, which is $1$ at $n=n_0$ and $0$ otherwise.\n\nNext, each system $T_i$ is implemented as a function that takes an input array $x$ and returns an output array $y$. The definitions must be carefully implemented respecting the zero-extension rule for shifted inputs like $x[n-k]$.\n1. $T_1\\{x\\}[n] = 0.3\\,x[n] - 0.2\\,x[n-1] + 0.1\\,x[n-3]$. This is implemented as $y[n] = 0.3\\,x[n] - 0.2\\,(S_1 x)[n] + 0.1\\,(S_3 x)[n]$.\n2. $T_2\\{x\\}[n] = \\bigl(1 + 0.01\\,n\\bigr)\\,x[n] + 0.5\\,x[n-1]$. The time-dependent coefficient $(1+0.01n)$ is applied element-wise. $y[n] = (1 + 0.01n)x[n] + 0.5\\,(S_1 x)[n]$.\n3. $T_3\\{x\\}[n] = x[n]^2 + x[n-1]^2$. The squaring operation is applied element-wise. $y[n] = (x[n])^2 + ((S_1 x)[n])^2$.\n4. $T_4\\{x\\}[n] = x[n] + 1$. This is a simple element-wise addition of a constant.\n5. $T_5\\{x\\}[n] = x\\bigl[n - (-1)^n\\bigr]$. This system involves a time-varying index lookup. For each output index $n$, the source index is $j = n - (-1)^n$. The output $y[n]$ is set to $x[j]$ if $j$ is within the valid range $\\{0, \\dots, N-1\\}$, and $0$ otherwise.\n\nWith the operators and systems defined, we construct the tests for time-invariance and linearity.\n\nThe time-invariance test verifies the commutation property $T\\{S_k x\\} = S_k\\{T x\\}$. For a given system $T$, we compute the left-hand side (LHS), $y_{LHS}[n] = T\\{S_k x\\}[n]$, and the right-hand side (RHS), $y_{RHS}[n] = S_k\\{T x\\}[n]$. Equality is tested by computing the supremum norm of the difference, $\\|y_{LHS} - y_{RHS}\\|_{\\infty} = \\max_n |y_{LHS}[n] - y_{RHS}[n]|$. If this error is less than or equal to the tolerance $\\varepsilon = 10^{-9}$, the system passes the check for that specific input $x$ and shift $k$. To be classified as time-invariant by this experiment, the system must pass this check for all specified inputs, $x \\in \\{x^{(A)}, x^{(B)}\\}$, and all specified shifts, $k \\in \\{7, -5\\}$. A single failure leads to a classification of time-varying.\n\nThe linearity test verifies that the system satisfies the superposition principle, $T\\{a x_1 + b x_2\\} = a T\\{x_1\\} + b T\\{x_2\\}$. The problem specifies two distinct checks.\n1. Superposition: We test $T\\{a x^{(A)} + b x^{(B)}\\} = a T\\{x^{(A)}\\} + b T\\{x^{(B)}\\}$ with scalars $a = 0.7$ and $b = -1.1$. The LHS is $y_{LHS}[n] = T\\{a x^{(A)} + b x^{(B)}\\}[n]$, and the RHS is $y_{RHS}[n] = a T\\{x^{(A)}\\}[n] + b T\\{x^{(B)}\\}[n]$. The error is measured using the supremum norm.\n2. Homogeneity: We test $T\\{c x^{(C)}\\} = c T\\{x^{(C)}\\}$ with scalar $c = 1.5$. The LHS is $y_{LHS}[n] = T\\{c x^{(C)}\\}[n]$, and the RHS is $y_{RHS}[n] = c T\\{x^{(C)}\\}[n]$. Again, the error is checked against $\\varepsilon$.\n\nA system is classified as linear if and only if it passes both the superposition and homogeneity checks.\n\nFinally, the complete experiment is performed by applying both the time-invariance and linearity tests to each of the five systems, $T_1$ through $T_5$. The boolean results, $[\\text{is\\_time\\_invariant}, \\text{is\\_linear}]$, for each system are collected and formatted into the required nested list structure for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical experiment to test for time-invariance and linearity\n    for five discrete-time systems.\n    \"\"\"\n    # Define problem constants and parameters\n    N = 64\n    epsilon = 1e-9\n    k_vals = [7, -5]\n    a, b, c = 0.7, -1.1, 1.5\n    n_indices = np.arange(N)\n\n    # Generate test signals\n    delta_10 = np.zeros(N)\n    delta_10[10] = 1.0\n    delta_3 = np.zeros(N)\n    delta_3[3] = 1.0\n\n    x_A = np.sin(0.23 * np.pi * n_indices) + 0.4 * np.cos(0.07 * np.pi * n_indices) + delta_10\n    x_B = np.cos(0.31 * np.pi * n_indices) - 0.3 * np.sin(0.11 * np.pi * n_indices) + 0.5 * delta_3\n    x_C = (-0.9)**n_indices\n\n    test_signals_ti = [x_A, x_B]\n\n    # Helper function for the shift operator S_k\n    def shift_op(x, k):\n        \"\"\"\n        Applies the shift operator S_k to a sequence x.\n        y[n] = x[n-k] with zero-extension.\n        \"\"\"\n        y = np.zeros_like(x)\n        if k == 0:\n            return np.copy(x)\n        elif k  0:  # Delay\n            if k  N:\n                y[k:] = x[:N - k]\n        else:  # Advance\n            k_abs = -k\n            if k_abs  N:\n                y[:N - k_abs] = x[k_abs:]\n        return y\n\n    # System definitions\n    def T1(x):\n        return 0.3 * x - 0.2 * shift_op(x, 1) + 0.1 * shift_op(x, 3)\n\n    def T2(x):\n        return (1 + 0.01 * n_indices) * x + 0.5 * shift_op(x, 1)\n    \n    def T3(x):\n        return x**2 + shift_op(x, 1)**2\n\n    def T4(x):\n        return x + 1.0\n\n    def T5(x):\n        # Vectorized implementation for x[n - (-1)^n]\n        indices = n_indices - ((-1)**n_indices)\n        y = np.zeros_like(x)\n        \n        valid_mask = (indices = 0)  (indices  N)\n        dest_indices = n_indices[valid_mask]\n        source_indices = indices[valid_mask].astype(int)\n        \n        y[dest_indices] = x[source_indices]\n        return y\n\n    systems = [T1, T2, T3, T4, T5]\n\n    # Test functions\n    def test_time_invariance(system_func):\n        \"\"\"Tests a system for time-invariance.\"\"\"\n        for x in test_signals_ti:\n            for k in k_vals:\n                lhs = system_func(shift_op(x, k))\n                rhs = shift_op(system_func(x), k)\n                error = np.max(np.abs(lhs - rhs))\n                if error  epsilon:\n                    return False\n        return True\n\n    def test_linearity(system_func):\n        \"\"\"Tests a system for linearity using superposition and homogeneity.\"\"\"\n        # Superposition check\n        lhs_super = system_func(a * x_A + b * x_B)\n        rhs_super = a * system_func(x_A) + b * system_func(x_B)\n        error_super = np.max(np.abs(lhs_super - rhs_super))\n        if error_super  epsilon:\n            return False\n\n        # Homogeneity check\n        lhs_homo = system_func(c * x_C)\n        rhs_homo = c * system_func(x_C)\n        error_homo = np.max(np.abs(lhs_homo - rhs_homo))\n        if error_homo  epsilon:\n            return False\n            \n        return True\n\n    results = []\n    for system in systems:\n        is_time_invariant = test_time_invariance(system)\n        is_linear = test_linearity(system)\n        results.append([is_time_invariant, is_linear])\n\n    # Format the final result string without spaces, as specified.\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "2910382"}]}