{"hands_on_practices": [{"introduction": "This first practice takes us back to the fundamentals by deriving a set of shape functions from first principles. It is a foundational exercise designed to illustrate how the required interpolation properties directly dictate the polynomial form of the shape functions. By working through this derivation for a one-dimensional quadratic element, you will gain a concrete understanding of the partition of unity and polynomial reproduction capabilities that are essential for ensuring element accuracy and convergence [@problem_id:2635745].", "problem": "A one-dimensional bar element is used to approximate the axial displacement field in the Finite Element Method (FEM). Consider the parent (isoparametric) coordinate $\\xi \\in [-1,1]$ with three nodes located at $\\xi_1=-1$, $\\xi_2=0$, and $\\xi_3=1$. Let the approximate displacement be interpolated using three quadratic Lagrange shape functions $N_1(\\xi)$, $N_2(\\xi)$, and $N_3(\\xi)$, each a polynomial of degree at most $2$, such that they satisfy the Kronecker-delta interpolation conditions $N_i(\\xi_j)=\\delta_{ij}$ for $i,j\\in\\{1,2,3\\}$.\n\nStarting from the core definition of nodal interpolation and polynomial completeness, derive explicit expressions for $N_1(\\xi)$, $N_2(\\xi)$, and $N_3(\\xi)$ by enforcing the nodal conditions and the quadratic polynomial requirement. Then, verify two essential properties expected from such an interpolation:\n- Polynomial reproduction up to degree $2$: for any quadratic polynomial displacement field $u(\\xi)=a_0+a_1\\,\\xi+a_2\\,\\xi^2$, show that the interpolant $u^h(\\xi)=\\sum_{i=1}^3 N_i(\\xi)\\,u(\\xi_i)$ equals $u(\\xi)$ identically for all $\\xi\\in[-1,1]$.\n- Partition of unity: show that $\\sum_{i=1}^3 N_i(\\xi)=1$ for all $\\xi\\in[-1,1]$.\n\nProvide your final answer as the single row vector $\\left[N_1(\\xi)\\;N_2(\\xi)\\;N_3(\\xi)\\right]$ consisting of closed-form analytic expressions in terms of $\\xi$. No numerical rounding is required. Do not include units in your final answer.", "solution": "The problem presented is a standard exercise in the theory of the Finite Element Method. It is scientifically grounded, well-posed, objective, and complete. It contains no inconsistencies or fallacies. Therefore, I will proceed with its solution.\n\nThe task is to derive the quadratic Lagrange shape functions for a one-dimensional, three-noded parent element and verify two of their fundamental properties. The element is defined on the isoparametric coordinate domain $\\xi \\in [-1, 1]$, with nodes located at $\\xi_1 = -1$, $\\xi_2 = 0$, and $\\xi_3 = 1$.\n\nThe shape functions, denoted by $N_i(\\xi)$ for $i \\in \\{1, 2, 3\\}$, are polynomials of degree at most $2$. They are defined by the Kronecker-delta property at the nodal locations:\n$$ N_i(\\xi_j) = \\delta_{ij} = \\begin{cases} 1 & \\text{if } i=j \\\\ 0 & \\text{if } i \\neq j \\end{cases} $$\nWe shall derive each function by assuming a general quadratic form, $N(\\xi) = a\\xi^2 + b\\xi + c$, and solving for the coefficients $a$, $b$, and $c$ by enforcing these nodal conditions.\n\nDerivation of $N_1(\\xi)$:\nThe conditions for $N_1(\\xi)$ are $N_1(\\xi_1) = 1$, $N_1(\\xi_2) = 0$, and $N_1(\\xi_3) = 0$.\nLet $N_1(\\xi) = a_1\\xi^2 + b_1\\xi + c_1$.\n1.  At node $\\xi_2=0$: $N_1(0) = a_1(0)^2 + b_1(0) + c_1 = c_1 = 0$.\n2.  At node $\\xi_3=1$: $N_1(1) = a_1(1)^2 + b_1(1) + c_1 = a_1 + b_1 + 0 = 0$. This implies $b_1 = -a_1$.\n3.  At node $\\xi_1=-1$: $N_1(-1) = a_1(-1)^2 + b_1(-1) + c_1 = a_1 - b_1 + 0 = 1$.\nSubstituting $b_1 = -a_1$ into the third equation gives $a_1 - (-a_1) = 2a_1 = 1$, which yields $a_1 = \\frac{1}{2}$. Consequently, $b_1 = -\\frac{1}{2}$.\nThus, the expression for $N_1(\\xi)$ is:\n$$ N_1(\\xi) = \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi = \\frac{1}{2}\\xi(\\xi-1) $$\n\nDerivation of $N_2(\\xi)$:\nThe conditions for $N_2(\\xi)$ are $N_2(\\xi_1) = 0$, $N_2(\\xi_2) = 1$, and $N_2(\\xi_3) = 0$.\nLet $N_2(\\xi) = a_2\\xi^2 + b_2\\xi + c_2$.\n1.  At node $\\xi_2=0$: $N_2(0) = a_2(0)^2 + b_2(0) + c_2 = c_2 = 1$.\n2.  At node $\\xi_3=1$: $N_2(1) = a_2(1)^2 + b_2(1) + c_2 = a_2 + b_2 + 1 = 0$.\n3.  At node $\\xi_1=-1$: $N_2(-1) = a_2(-1)^2 + b_2(-1) + c_2 = a_2 - b_2 + 1 = 0$.\nWe have a system of two linear equations for $a_2$ and $b_2$:\n$$ a_2 + b_2 = -1 $$\n$$ a_2 - b_2 = -1 $$\nAdding these two equations gives $2a_2 = -2$, so $a_2 = -1$. Substituting this into the first equation gives $-1 + b_2 = -1$, so $b_2 = 0$.\nThus, the expression for $N_2(\\xi)$ is:\n$$ N_2(\\xi) = (-1)\\xi^2 + (0)\\xi + 1 = 1 - \\xi^2 $$\n\nDerivation of $N_3(\\xi)$:\nThe conditions for $N_3(\\xi)$ are $N_3(\\xi_1) = 0$, $N_3(\\xi_2) = 0$, and $N_3(\\xi_3) = 1$.\nLet $N_3(\\xi) = a_3\\xi^2 + b_3\\xi + c_3$.\n1.  At node $\\xi_2=0$: $N_3(0) = a_3(0)^2 + b_3(0) + c_3 = c_3 = 0$.\n2.  At node $\\xi_1=-1$: $N_3(-1) = a_3(-1)^2 + b_3(-1) + c_3 = a_3 - b_3 + 0 = 0$. This implies $b_3 = a_3$.\n3.  At node $\\xi_3=1$: $N_3(1) = a_3(1)^2 + b_3(1) + c_3 = a_3 + b_3 + 0 = 1$.\nSubstituting $b_3 = a_3$ into the third equation gives $a_3 + a_3 = 2a_3 = 1$, which yields $a_3 = \\frac{1}{2}$. Consequently, $b_3 = \\frac{1}{2}$.\nThus, the expression for $N_3(\\xi)$ is:\n$$ N_3(\\xi) = \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi = \\frac{1}{2}\\xi(\\xi+1) $$\n\nNow, we verify the two required properties.\n\nVerification of the Partition of Unity:\nWe must show that $\\sum_{i=1}^3 N_i(\\xi) = 1$ for all $\\xi \\in [-1, 1]$.\n$$ \\sum_{i=1}^3 N_i(\\xi) = N_1(\\xi) + N_2(\\xi) + N_3(\\xi) $$\n$$ = \\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + (1 - \\xi^2) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) $$\nCollect terms with like powers of $\\xi$:\n$$ = \\left(\\frac{1}{2} - 1 + \\frac{1}{2}\\right)\\xi^2 + \\left(-\\frac{1}{2} + \\frac{1}{2}\\right)\\xi + 1 $$\n$$ = (0)\\xi^2 + (0)\\xi + 1 = 1 $$\nThe partition of unity property is satisfied identically for all $\\xi$.\n\nVerification of Polynomial Reproduction:\nWe must show that for an arbitrary quadratic polynomial $u(\\xi) = a_0 + a_1\\xi + a_2\\xi^2$, the interpolant $u^h(\\xi) = \\sum_{i=1}^3 N_i(\\xi)u(\\xi_i)$ is identical to $u(\\xi)$.\nFirst, evaluate the nodal values of $u(\\xi)$:\n$u(\\xi_1) = u(-1) = a_0 - a_1 + a_2$\n$u(\\xi_2) = u(0) = a_0$\n$u(\\xi_3) = u(1) = a_0 + a_1 + a_2$\nNow, construct the interpolant $u^h(\\xi)$:\n$$ u^h(\\xi) = N_1(\\xi)(a_0 - a_1 + a_2) + N_2(\\xi)(a_0) + N_3(\\xi)(a_0 + a_1 + a_2) $$\nRearrange the expression by factoring out the coefficients $a_0$, $a_1$, and $a_2$:\n$$ u^h(\\xi) = a_0 [N_1(\\xi)+N_2(\\xi)+N_3(\\xi)] + a_1 [-N_1(\\xi)+N_3(\\xi)] + a_2 [N_1(\\xi)+N_3(\\xi)] $$\nLet us analyze the coefficient of each $a_k$:\nThe coefficient of $a_0$ is $\\sum_{i=1}^3 N_i(\\xi)$, which we have already proven to be $1$.\nThe coefficient of $a_1$ is $-N_1(\\xi)+N_3(\\xi)$:\n$$ -N_1(\\xi)+N_3(\\xi) = -\\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) = -\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi + \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi = \\xi $$\nThe coefficient of $a_2$ is $N_1(\\xi)+N_3(\\xi)$:\n$$ N_1(\\xi)+N_3(\\xi) = \\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) = \\xi^2 $$\nSubstituting these results back into the expression for $u^h(\\xi)$:\n$$ u^h(\\xi) = a_0(1) + a_1(\\xi) + a_2(\\xi^2) = a_0 + a_1\\xi + a_2\\xi^2 $$\nThis is identical to $u(\\xi)$. The capacity to reproduce any quadratic polynomial is confirmed. This is a direct consequence of the fact that the basis functions $\\{N_i(\\xi)\\}$ can represent the monomials $\\{1, \\xi, \\xi^2\\}$, which we have just demonstrated.\n\nThe derivations and verifications are complete. The final answer is the set of explicit expressions for the shape functions.", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{1}{2}\\xi(\\xi-1) & 1-\\xi^2 & \\frac{1}{2}\\xi(\\xi+1) \\end{pmatrix} } $$", "id": "2635745"}, {"introduction": "With a grasp of how to construct shape functions, the next logical step is to use them in a mechanical context. This practice demonstrates the procedure for constructing the crucial strain-displacement matrix, commonly known as the $\\mathbf{B}$ matrix, which is a cornerstone of the finite element method for stress analysis. This exercise forges the critical link between the abstract interpolation of the displacement field and the tangible calculation of strains within an element, forming a bridge to the element stiffness formulation [@problem_id:2635683].", "problem": "Consider a two-dimensional, small-deformation, plane strain setting for an isoparametric four-node bilinear quadrilateral (Q4) finite element. Let the displacement field within the element be interpolated from its nodal values using scalar shape functions $N_{i}(x,y)$, $i=1,2,3,4$, as\n$u(x,y) = \\sum_{i=1}^{4} N_{i}(x,y)\\,u_{i}$ and $v(x,y) = \\sum_{i=1}^{4} N_{i}(x,y)\\,v_{i}$,\nwhere $u$ and $v$ are the Cartesian displacement components in the $x$- and $y$-directions, respectively, and $u_{i}$ and $v_{i}$ are the nodal displacement degrees of freedom at node $i$. Adopt the infinitesimal strain tensor definition from small-strain kinematics, and use the engineering strain vector for plane strain,\n$\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix}$,\nwith $\\varepsilon_{xx} = \\partial u/\\partial x$, $\\varepsilon_{yy} = \\partial v/\\partial y$, and $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$. Let the element nodal displacement vector be ordered as\n$\\mathbf{d} = \\begin{pmatrix} u_{1} & v_{1} & u_{2} & v_{2} & u_{3} & v_{3} & u_{4} & v_{4} \\end{pmatrix}^{\\mathsf{T}}$.\nStarting from these definitions alone, derive the strain-displacement matrix $\\mathbf{B}$ such that $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\,\\mathbf{d}$, and express $\\mathbf{B}$ entirely in terms of the spatial derivatives $\\partial N_{i}/\\partial x$ and $\\partial N_{i}/\\partial y$ for $i=1,2,3,4$. Your final answer must be a single closed-form analytic expression for $\\mathbf{B}$. Do not compute any numerical values. Do not introduce any constitutive relations. Provide the final $\\mathbf{B}$ matrix expression only; no intermediate steps are to appear in the final answer. No units are required for the final answer.", "solution": "The derivation begins from the fundamental kinematics of infinitesimal strain in two dimensions. In small-deformation theory, the infinitesimal strain tensor $\\boldsymbol{\\epsilon}$ is the symmetric gradient of the displacement vector field $\\mathbf{u} = (u,v)^{\\mathsf{T}}$, specifically\n$$\n\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\epsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\epsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right).\n$$\nThe engineering shear strain is defined as $ \\gamma_{xy} = 2\\,\\epsilon_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$. Thus, the engineering strain vector for plane problems is\n$$\n\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix}\n= \\begin{pmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{pmatrix}.\n$$\n\nNext, we use the finite element interpolation of the displacement field over the Q4 element. With scalar shape functions $N_{i}(x,y)$ and nodal displacement components $u_{i}$ and $v_{i}$ for $i=1,2,3,4$, the displacement components are interpolated as\n$$\nu(x,y) = \\sum_{i=1}^{4} N_{i}(x,y)\\,u_{i}, \\qquad\nv(x,y) = \\sum_{i=1}^{4} N_{i}(x,y)\\,v_{i}.\n$$\nTaking spatial derivatives yields\n$$\n\\frac{\\partial u}{\\partial x} = \\sum_{i=1}^{4} \\frac{\\partial N_{i}}{\\partial x}\\,u_{i}, \\qquad\n\\frac{\\partial v}{\\partial y} = \\sum_{i=1}^{4} \\frac{\\partial N_{i}}{\\partial y}\\,v_{i},\n$$\nand\n$$\n\\frac{\\partial u}{\\partial y} = \\sum_{i=1}^{4} \\frac{\\partial N_{i}}{\\partial y}\\,u_{i}, \\qquad\n\\frac{\\partial v}{\\partial x} = \\sum_{i=1}^{4} \\frac{\\partial N_{i}}{\\partial x}\\,v_{i}.\n$$\nSubstituting these into the engineering strain components, we obtain\n$$\n\\varepsilon_{xx} = \\sum_{i=1}^{4} \\frac{\\partial N_{i}}{\\partial x}\\,u_{i}, \\qquad\n\\varepsilon_{yy} = \\sum_{i=1}^{4} \\frac{\\partial N_{i}}{\\partial y}\\,v_{i}, \\qquad\n\\gamma_{xy} = \\sum_{i=1}^{4} \\left( \\frac{\\partial N_{i}}{\\partial y}\\,u_{i} + \\frac{\\partial N_{i}}{\\partial x}\\,v_{i} \\right).\n$$\n\nWe now collect terms with respect to the nodal displacement vector ordered as\n$$\n\\mathbf{d} = \\begin{pmatrix} u_{1} & v_{1} & u_{2} & v_{2} & u_{3} & v_{3} & u_{4} & v_{4} \\end{pmatrix}^{\\mathsf{T}}.\n$$\nThe mapping $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\,\\mathbf{d}$ identifies the strain-displacement matrix $\\mathbf{B}$. From the expressions above, the contributions of $(u_{i}, v_{i})$ to each strain component are:\n- To $\\varepsilon_{xx}$: coefficient of $u_{i}$ is $\\dfrac{\\partial N_{i}}{\\partial x}$ and coefficient of $v_{i}$ is $0$.\n- To $\\varepsilon_{yy}$: coefficient of $u_{i}$ is $0$ and coefficient of $v_{i}$ is $\\dfrac{\\partial N_{i}}{\\partial y}$.\n- To $\\gamma_{xy}$: coefficient of $u_{i}$ is $\\dfrac{\\partial N_{i}}{\\partial y}$ and coefficient of $v_{i}$ is $\\dfrac{\\partial N_{i}}{\\partial x}$.\n\nAssembling these coefficients across the four nodes in the specified degree-of-freedom order produces the $3 \\times 8$ matrix\n$$\n\\mathbf{B} =\n\\begin{pmatrix}\n\\dfrac{\\partial N_{1}}{\\partial x} & 0 & \\dfrac{\\partial N_{2}}{\\partial x} & 0 & \\dfrac{\\partial N_{3}}{\\partial x} & 0 & \\dfrac{\\partial N_{4}}{\\partial x} & 0 \\\\\n0 & \\dfrac{\\partial N_{1}}{\\partial y} & 0 & \\dfrac{\\partial N_{2}}{\\partial y} & 0 & \\dfrac{\\partial N_{3}}{\\partial y} & 0 & \\dfrac{\\partial N_{4}}{\\partial y} \\\\\n\\dfrac{\\partial N_{1}}{\\partial y} & \\dfrac{\\partial N_{1}}{\\partial x} & \\dfrac{\\partial N_{2}}{\\partial y} & \\dfrac{\\partial N_{2}}{\\partial x} & \\dfrac{\\partial N_{3}}{\\partial y} & \\dfrac{\\partial N_{3}}{\\partial x} & \\dfrac{\\partial N_{4}}{\\partial y} & \\dfrac{\\partial N_{4}}{\\partial x}\n\\end{pmatrix}.\n$$\nThis $\\mathbf{B}$ is expressed purely in terms of the physical derivatives $\\partial N_{i}/\\partial x$ and $\\partial N_{i}/\\partial y$. In an isoparametric formulation, these physical derivatives are obtained from the parent-coordinate derivatives via the Jacobian matrix of the mapping; however, such details are not required here because the requested result is explicitly in terms of $\\partial N_{i}/\\partial x$ and $\\partial N_{i}/\\partial y$. The same kinematic $\\mathbf{B}$ applies to both plane stress and plane strain; the distinction between these cases lies in the constitutive matrix, not in $\\mathbf{B}$.", "answer": "$$\\boxed{\\begin{pmatrix}\n\\dfrac{\\partial N_{1}}{\\partial x} & 0 & \\dfrac{\\partial N_{2}}{\\partial x} & 0 & \\dfrac{\\partial N_{3}}{\\partial x} & 0 & \\dfrac{\\partial N_{4}}{\\partial x} & 0 \\\\\n0 & \\dfrac{\\partial N_{1}}{\\partial y} & 0 & \\dfrac{\\partial N_{2}}{\\partial y} & 0 & \\dfrac{\\partial N_{3}}{\\partial y} & 0 & \\dfrac{\\partial N_{4}}{\\partial y} \\\\\n\\dfrac{\\partial N_{1}}{\\partial y} & \\dfrac{\\partial N_{1}}{\\partial x} & \\dfrac{\\partial N_{2}}{\\partial y} & \\dfrac{\\partial N_{2}}{\\partial x} & \\dfrac{\\partial N_{3}}{\\partial y} & \\dfrac{\\partial N_{3}}{\\partial x} & \\dfrac{\\partial N_{4}}{\\partial y} & \\dfrac{\\partial N_{4}}{\\partial x}\n\\end{pmatrix}}$$", "id": "2635683"}, {"introduction": "Theoretical understanding is best solidified through practical implementation and rigorous verification. This final practice moves from analytical derivation to computational application, challenging you to build a unit test suite for several common element types. By translating the core properties of shape functions—partition of unity, Kronecker-delta interpolation, and polynomial reproduction—into executable tests, you will develop a robust and generalizable understanding of what makes any set of shape functions valid and effective in a computational framework [@problem_id:2635700].", "problem": "You are tasked with writing a complete, runnable program that implements and validates element shape functions used in the finite element method for solid mechanics through a principled unit test suite. The tests must verify, for each implemented shape function set, the following three properties derived from the nodal interpolation paradigm: partition of unity, the Kronecker delta property at nodes, and polynomial reproduction up to the completeness of the element. Your program must produce a single line of output in the specified format.\n\nThe fundamental base of this problem is the standard nodal finite element interpolation, where an approximate field $u_h$ is represented as $u_h(\\mathbf{x}) = \\sum_{i=1}^{n} N_i(\\mathbf{x})\\, u_i$, with $N_i$ denoting the shape functions and $u_i$ the nodal values. From this representation and the definition of interpolation, three core properties follow:\n\n- Partition of unity: $\\sum_{i=1}^{n} N_i(\\mathbf{x}) = 1$ for all $\\mathbf{x}$ in the reference domain.\n- Kronecker delta at nodes: $N_i(\\mathbf{x}_j) = \\delta_{ij}$ for all node locations $\\mathbf{x}_j$.\n- Polynomial reproduction: For a prescribed polynomial set $\\mathcal{P}$ consistent with the element’s completeness, $\\sum_{i=1}^{n} N_i(\\mathbf{x})\\, p(\\mathbf{x}_i) = p(\\mathbf{x})$ for all $p \\in \\mathcal{P}$ and all $\\mathbf{x}$ in the reference domain.\n\nImplement the following three reference elements and their shape functions on their standard reference domains. You must not assume or use any external data; all definitions must be self-contained in your code.\n\n- One-dimensional, two-node line element (denoted L$2$) on the interval $\\xi \\in [-1,1]$ with nodes at $\\xi = -1$ and $\\xi = 1$. Use the local coordinate $\\xi$.\n- Two-dimensional, four-node bilinear quadrilateral (denoted Q$4$) on the square $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ with nodes at $(\\xi,\\eta) \\in \\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$. Use the local coordinates $(\\xi,\\eta)$.\n- Two-dimensional, six-node quadratic triangle (denoted T$6$) on the right triangle with vertices $(x,y) \\in \\{(0,0),(1,0),(0,1)\\}$ and midside nodes at $(x,y) \\in \\{(1/2,0),(1/2,1/2),(0,1/2)\\}$. Use the local coordinates $(x,y)$ on this reference triangle.\n\nFor each element type, implement a test suite that evaluates the three properties above on a prescribed set of evaluation points and with a specified polynomial set for the reproduction test. Use absolute tolerance $\\varepsilon = 10^{-12}$ for all boolean assertions.\n\nSpecify the test suite as follows.\n\n- L$2$:\n  - Nodes: $\\{-1, 1\\}$.\n  - Evaluation points: $\\{-1, -1/2, 0, 1/2, 1\\}$.\n  - Polynomial set: $\\{1, \\xi\\}$, meaning constants and linear functions in $\\xi$.\n\n- Q$4$:\n  - Nodes: $\\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$.\n  - Evaluation points: $\\{(-1,-1),(0,0),(1,1),(1,-1),(-1,1),(1/2,-1/2)\\}$.\n  - Polynomial set: $\\{1, \\xi, \\eta, \\xi \\eta\\}$.\n\n- T$6$:\n  - Nodes: $\\{(0,0),(1,0),(0,1),(1/2,0),(1/2,1/2),(0,1/2)\\}$.\n  - Evaluation points: $\\{(0,0),(1,0),(0,1),(1/4,1/4),(3/5,1/5),(0,1/2)\\}$.\n  - Polynomial set: $\\{1, x, y, x^2, x y, y^2\\}$.\n\nYour program must:\n- Implement the shape functions for L$2$, Q$4$, and T$6$ on their reference domains.\n- For each element, and for each evaluation point in the prescribed test suite, verify:\n  - Partition of unity: $\\left|\\sum_i N_i(\\mathbf{x}) - 1\\right| \\le \\varepsilon$.\n  - Kronecker delta: If $A$ is the matrix with entries $A_{ij} = N_i(\\mathbf{x}_j)$, then $\\max_{i,j} |A_{ij} - \\delta_{ij}| \\le \\varepsilon$.\n  - Polynomial reproduction: For each polynomial $p$ in the specified set and for each evaluation point $\\mathbf{x}$, compute $\\widehat{p}(\\mathbf{x}) = \\sum_i N_i(\\mathbf{x})\\,p(\\mathbf{x}_i)$ and verify $\\max |\\,\\widehat{p}(\\mathbf{x}) - p(\\mathbf{x})\\,| \\le \\varepsilon$ over all polynomials and evaluation points.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of $9$ boolean results enclosed in square brackets. The order must be:\n  - L$2$ partition of unity, L$2$ Kronecker delta, L$2$ polynomial reproduction,\n  - Q$4$ partition of unity, Q$4$ Kronecker delta, Q$4$ polynomial reproduction,\n  - T$6$ partition of unity, T$6$ Kronecker delta, T$6$ polynomial reproduction.\nFor example, an output line could look like $[{\\tt True},{\\tt True},{\\tt True},{\\tt True},{\\tt True},{\\tt True},{\\tt True},{\\tt True},{\\tt True}]$. No additional text should be printed.", "solution": "The problem requires the implementation and validation of shape functions for three common finite elements: the $2$-node linear line element (L$2$), the $4$-node bilinear quadrilateral element (Q$4$), and the $6$-node quadratic triangular element (T$6$). Validation must be performed by writing a unit test suite that verifies three fundamental properties inherent to finite element shape functions used for nodal interpolation. These properties are the partition of unity, the Kronecker delta property at the nodal locations, and the ability to exactly reproduce polynomials up to the order of the element's completeness. The entire verification will be conducted using numerical computation with a specified absolute tolerance of $\\varepsilon = 10^{-12}$.\n\nAn approximate field, $u_h(\\mathbf{x})$, within an element is interpolated from its nodal values, $u_i$, using the shape functions $N_i(\\mathbf{x})$:\n$$u_h(\\mathbf{x}) = \\sum_{i=1}^{n} N_i(\\mathbf{x}) u_i$$\nwhere $n$ is the number of nodes in the element. From this definition, the following properties must hold:\n$1$. Partition of Unity: The sum of the shape functions must be unity at any point $\\mathbf{x}$ within the element domain. This ensures that a constant field is reproduced exactly.\n$$\\sum_{i=1}^{n} N_i(\\mathbf{x}) = 1$$\n$2$. Kronecker Delta Property: The value of the $i$-th shape function, $N_i$, must be unity at its own node, $\\mathbf{x}_i$, and zero at all other nodes, $\\mathbf{x}_j$ where $j \\neq i$.\n$$N_i(\\mathbf{x}_j) = \\delta_{ij} = \\begin{cases} 1 & \\text{if } i=j \\\\ 0 & \\text{if } i \\neq j \\end{cases}$$\n$3$. Polynomial Reproduction: The interpolation scheme must be able to reproduce any polynomial $p(\\mathbf{x})$ belonging to the basis set $\\mathcal{P}$ for which the element is complete.\n$$\\sum_{i=1}^{n} N_i(\\mathbf{x}) p(\\mathbf{x}_i) = p(\\mathbf{x})$$\n\nThe implementation will proceed by defining the shape functions for each element and subjecting them to a rigorous test suite as specified.\n\n**$1$. L$2$: $2$-Node Linear Line Element**\n\nThis element is defined on the reference interval $\\xi \\in [-1, 1]$. It possesses $2$ nodes, located at the endpoints:\n- Node $1$: $\\xi_1 = -1$\n- Node $2$: $\\xi_2 = 1$\n\nThe shape functions are linear Lagrange polynomials:\n$$N_1(\\xi) = \\frac{1}{2}(1 - \\xi)$$\n$$N_2(\\xi) = \\frac{1}{2}(1 + \\xi)$$\nThe test suite for the L$2$ element uses evaluation points $\\xi \\in \\{-1, -1/2, 0, 1/2, 1\\}$ and a polynomial set $\\mathcal{P} = \\{1, \\xi\\}$. The tests verify the partition of unity, Kronecker delta, and polynomial reproduction properties for these specified conditions.\n\n**$2$. Q$4$: $4$-Node Bilinear Quadrilateral Element**\n\nThis element is defined on the reference square domain $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$. The $4$ nodes are located at the corners, numbered counter-clockwise:\n- Node $1$: $(\\xi_1, \\eta_1) = (-1, -1)$\n- Node $2$: $(\\xi_2, \\eta_2) = (1, -1)$\n- Node $3$: $(\\xi_3, \\eta_3) = (1, 1)$\n- Node $4$: $(\\xi_4, \\eta_4) = (-1, 1)$\n\nThe shape functions are derived from the product of $1$D linear Lagrange polynomials, resulting in a bilinear form:\n$$N_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i \\xi)(1 + \\eta_i \\eta)$$\nwhere $(\\xi_i, \\eta_i)$ are the coordinates of node $i$. The test suite for the Q$4$ element uses evaluation points $(\\xi, \\eta) \\in \\{(-1,-1), (0,0), (1,1), (1,-1), (-1,1), (1/2,-1/2)\\}$ and a polynomial set $\\mathcal{P} = \\{1, \\xi, \\eta, \\xi\\eta\\}$, which constitutes the basis of bilinear functions.\n\n**$3$. T$6$: $6$-Node Quadratic Triangular Element**\n\nThis element is defined on a reference right triangle with vertices at $(0,0)$, $(1,0)$, and $(0,1)$. It has $6$ nodes: $3$ at the vertices and $3$ at the midpoints of the sides.\n- Vertex Nodes: $(0,0)$, $(1,0)$, $(0,1)$\n- Midside Nodes: $(1/2,0)$, $(1/2,1/2)$, $(0,1/2)$\nThe specified node ordering is:\n- Node $1$: $(0,0)$, Node $2$: $(1,0)$, Node $3$: $(0,1)$\n- Node $4$: $(1/2,0)$, Node $5$: $(1/2,1/2)$, Node $6$: $(0,1/2)$\n\nThe shape functions are most conveniently expressed using area coordinates $(L_1, L_2, L_3)$, which for this reference triangle are:\n$$L_1(x,y) = 1 - x - y$$\n$$L_2(x,y) = x$$\n$$L_3(x,y) = y$$\nThe quadratic shape functions for the vertex nodes ($i=1, 2, 3$) are given by $N_i = L_i(2L_i - 1)$, and for the midside nodes ($i=4, 5, 6$) by $N_i = 4 L_j L_k$, where $j$ and $k$ are the indices of the vertices bounding the side. The explicit formulas for the specified node ordering are:\n- $N_1(x,y) = L_1(2L_1-1) = (1-x-y)(1-2x-2y)$\n- $N_2(x,y) = L_2(2L_2-1) = x(2x-1)$\n- $N_3(x,y) = L_3(2L_3-1) = y(2y-1)$\n- $N_4(x,y) = 4L_1 L_2 = 4x(1-x-y)$\n- $N_5(x,y) = 4L_2 L_3 = 4xy$\n- $N_6(x,y) = 4L_3 L_1 = 4y(1-x-y)$\n\nThe test suite for the T$6$ element uses evaluation points $(x,y) \\in \\{(0,0), (1,0), (0,1), (1/4,1/4), (3/5,1/5), (0,1/2)\\}$ and the complete quadratic polynomial set $\\mathcal{P} = \\{1, x, y, x^2, xy, y^2\\}$.\n\nThe following program implements these elements and test suites, systematically verifying each property to the specified tolerance and producing the required boolean output array.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to implement, test, and validate FEM shape functions.\n    \"\"\"\n    # Define the absolute tolerance for all floating-point comparisons.\n    TOL = 1.0e-12\n\n    # --- Element Shape Function Implementations ---\n\n    def shape_l2(point):\n        \"\"\"\n        Evaluates shape functions for a 2-node line element (L2).\n        Domain: xi in [-1, 1]\n        Nodes: -1, 1\n        \"\"\"\n        xi = point[0]\n        N1 = 0.5 * (1.0 - xi)\n        N2 = 0.5 * (1.0 + xi)\n        return np.array([N1, N2])\n\n    def shape_q4(point):\n        \"\"\"\n        Evaluates shape functions for a 4-node quad element (Q4).\n        Domain: (xi, eta) in [-1, 1] x [-1, 1]\n        Nodes: (-1,-1), (1,-1), (1,1), (-1,1)\n        \"\"\"\n        xi, eta = point[0], point[1]\n        # Nodal coordinates for the standard Q4 element\n        xi_nodes = np.array([-1.0, 1.0, 1.0, -1.0])\n        eta_nodes = np.array([-1.0, -1.0, 1.0, 1.0])\n        # Vectorized formula: N_i = 1/4 * (1 + xi*xi_i) * (1 + eta*eta_i)\n        N = 0.25 * (1.0 + xi * xi_nodes) * (1.0 + eta * eta_nodes)\n        return N\n\n    def shape_t6(point):\n        \"\"\"\n        Evaluates shape functions for a 6-node quadratic triangle (T6).\n        Domain: Right triangle with vertices (0,0), (1,0), (0,1)\n        Nodes: (0,0), (1,0), (0,1), (1/2,0), (1/2,1/2), (0,1/2)\n        \"\"\"\n        x, y = point[0], point[1]\n        # Area coordinates\n        L1 = 1.0 - x - y\n        L2 = x\n        L3 = y\n        \n        # Shape functions based on area coordinates and node ordering\n        N1 = L1 * (2.0 * L1 - 1.0)  # Node 1: (0,0)\n        N2 = L2 * (2.0 * L2 - 1.0)  # Node 2: (1,0)\n        N3 = L3 * (2.0 * L3 - 1.0)  # Node 3: (0,1)\n        N4 = 4.0 * L1 * L2          # Node 4: (1/2,0)\n        N5 = 4.0 * L2 * L3          # Node 5: (1/2,1/2)\n        N6 = 4.0 * L3 * L1          # Node 6: (0,1/2)\n        \n        return np.array([N1, N2, N3, N4, N5, N6])\n\n    # --- Generic Test Runner ---\n\n    def run_tests(shape_func, nodes, eval_points, poly_funcs):\n        \"\"\"\n        Runs the standard test suite for a given element.\n        \"\"\"\n        num_nodes = nodes.shape[0]\n\n        # 1. Partition of Unity Test\n        pu_ok = True\n        for point in eval_points:\n            N_vals = shape_func(point)\n            if abs(np.sum(N_vals) - 1.0) > TOL:\n                pu_ok = False\n                break\n        \n        # 2. Kronecker Delta Test\n        kd_ok = True\n        kd_matrix = np.zeros((num_nodes, num_nodes))\n        for i in range(num_nodes):\n            kd_matrix[:, i] = shape_func(nodes[i])\n        \n        if np.max(np.abs(kd_matrix - np.identity(num_nodes))) > TOL:\n            kd_ok = False\n            \n        # 3. Polynomial Reproduction Test\n        pr_ok = True\n        for p_func in poly_funcs:\n            p_nodal = np.array([p_func(n) for n in nodes])\n            \n            for point in eval_points:\n                N_vals = shape_func(point)\n                p_interp = np.dot(N_vals, p_nodal)\n                p_exact = p_func(point)\n                \n                if abs(p_interp - p_exact) > TOL:\n                    pr_ok = False\n                    break\n            if not pr_ok:\n                break\n                \n        return pu_ok, kd_ok, pr_ok\n\n    # --- Test Suite Data Definitions ---\n\n    test_cases = [\n        # L2 Element Data\n        {\n            \"shape_func\": shape_l2,\n            \"nodes\": np.array([[-1.0], [1.0]]),\n            \"eval_points\": np.array([[-1.0], [-0.5], [0.0], [0.5], [1.0]]),\n            \"poly_funcs\": [lambda p: 1.0, lambda p: p[0]],\n        },\n        # Q4 Element Data\n        {\n            \"shape_func\": shape_q4,\n            \"nodes\": np.array([[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0]]),\n            \"eval_points\": np.array([[-1.0, -1.0], [0.0, 0.0], [1.0, 1.0], [1.0, -1.0], [-1.0, 1.0], [0.5, -0.5]]),\n            \"poly_funcs\": [lambda p: 1.0, lambda p: p[0], lambda p: p[1], lambda p: p[0] * p[1]],\n        },\n        # T6 Element Data\n        {\n            \"shape_func\": shape_t6,\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.0], [0.5, 0.5], [0.0, 0.5]]),\n            \"eval_points\": np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1./4., 1./4.], [3./5., 1./5.], [0.0, 1./2.]]),\n            \"poly_funcs\": [lambda p: 1.0, lambda p: p[0], lambda p: p[1], lambda p: p[0]**2, lambda p: p[0] * p[1], lambda p: p[1]**2],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        test_results = run_tests(\n            case[\"shape_func\"],\n            case[\"nodes\"],\n            case[\"eval_points\"],\n            case[\"poly_funcs\"]\n        )\n        results.extend(test_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2635700"}]}