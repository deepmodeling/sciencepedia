{"hands_on_practices": [{"introduction": "This first practice provides a direct application of the core concepts. By taking a given Cauchy stress tensor $\\boldsymbol{\\sigma}$ and a specific plane defined by its normal $\\boldsymbol{n}$, you will compute the traction vector $\\boldsymbol{t}$ and decompose it into its physical normal and shear components. Mastering this fundamental calculation is the first step toward understanding how the abstract state of stress at a point translates into tangible forces acting on surfaces within a material [@problem_id:2694348].", "problem": "A homogeneous continuum at a point is characterized by the Cauchy stress tensor $\\boldsymbol{\\sigma}$ (symmetric second-order tensor with units of megapascals) and a plane through the point with unit normal $\\boldsymbol{n}$. Starting only from the balance of linear momentum (Cauchy’s stress principle that the traction depends linearly on the unit normal) and the balance of angular momentum (symmetry of the Cauchy stress tensor), derive the expression for the traction vector $\\boldsymbol{t}(\\boldsymbol{n})$ acting on the plane with normal $\\boldsymbol{n}$, and its orthogonal decomposition into a normal component and a shear component. Then, evaluate these quantities for\n$$\n\\boldsymbol{\\sigma}=\\begin{bmatrix}100 & 30 & -20\\\\ 30 & 50 & 0\\\\ -20 & 0 & 80\\end{bmatrix}\\ \\text{(in MPa)},\\qquad \\boldsymbol{n}=\\tfrac{1}{\\sqrt{14}}(1,2,3).\n$$\nSpecifically compute:\n- the traction vector $\\boldsymbol{t}(\\boldsymbol{n})$,\n- the normal stress $\\sigma_{nn}$ on the plane,\n- the shear (tangential) traction vector $\\boldsymbol{\\tau}$ on the plane, and\n- the magnitude $\\|\\boldsymbol{\\tau}\\|$.\n\nExpress all stress quantities in megapascals (MPa). Provide exact values in simplest radical form; do not approximate. Report the final answer as an eight-entry row in the order $(t_1, t_2, t_3, \\sigma_{nn}, \\tau_1, \\tau_2, \\tau_3, \\|\\boldsymbol{\\tau}\\|)$, and omit units in the final boxed answer.", "solution": "The problem will be validated before any attempt at a solution.\n\nGivens are extracted verbatim from the problem statement:\n1.  A homogeneous continuum is characterized by the Cauchy stress tensor $\\boldsymbol{\\sigma}$, a symmetric second-order tensor.\n2.  A plane through a point is defined by its unit normal vector $\\boldsymbol{n}$.\n3.  The governing principles are the balance of linear momentum (Cauchy's stress principle: the traction vector $\\boldsymbol{t}$ depends linearly on $\\boldsymbol{n}$) and the balance of angular momentum (which implies the symmetry of $\\boldsymbol{\\sigma}$).\n4.  The specific stress tensor is given as\n$$\n\\boldsymbol{\\sigma}=\\begin{bmatrix}100 & 30 & -20\\\\ 30 & 50 & 0\\\\ -20 & 0 & 80\\end{bmatrix}\n$$\nwith units of megapascals (MPa).\n5.  The specific unit normal vector is given as $\\boldsymbol{n}=\\tfrac{1}{\\sqrt{14}}(1,2,3)$.\n6.  The required calculations are: the traction vector $\\boldsymbol{t}(\\boldsymbol{n})$, the normal stress $\\sigma_{nn}$, the shear traction vector $\\boldsymbol{\\tau}$, and the magnitude of the shear traction $\\|\\boldsymbol{\\tau}\\|$.\n7.  The final answer must be in exact simplest radical form and presented as an eight-entry row matrix.\n\nThe problem is subjected to validation.\n-   **Scientific Grounding**: The problem is fundamentally sound. It is a standard application of Cauchy's stress theorem, a cornerstone of continuum mechanics. All concepts—stress tensor, traction vector, normal and shear components—are well-established.\n-   **Well-Posedness**: The problem is well-posed. A unique solution exists for the requested quantities, which are determined by the given stress tensor and normal vector.\n-   **Objectivity**: The language is precise and objective, free of any subjectivity.\n-   **Completeness and Consistency**: The problem is self-contained. The provided stress tensor $\\boldsymbol{\\sigma}$ is symmetric, consistent with the balance of angular momentum for a non-polar continuum. The provided vector $\\boldsymbol{n}$ is a valid unit vector, as $\\|\\boldsymbol{n}\\| = \\sqrt{(\\frac{1}{\\sqrt{14}})^2 + (\\frac{2}{\\sqrt{14}})^2 + (\\frac{3}{\\sqrt{14}})^2} = \\sqrt{\\frac{1}{14} + \\frac{4}{14} + \\frac{9}{14}} = \\sqrt{\\frac{14}{14}} = 1$. The data are consistent and sufficient.\n-   **Feasibility**: The stress values are physically realistic for engineering materials.\n\nThe verdict is that the problem is valid. A solution will be constructed.\n\nFirst, we establish the theoretical framework. The balance of linear momentum, when applied to an infinitesimal tetrahedron, yields the relationship between the traction vector $\\boldsymbol{t}$ acting on a surface with unit normal $\\boldsymbol{n}$ and the Cauchy stress tensor $\\boldsymbol{\\sigma}$ at that point. This is known as Cauchy's stress theorem:\n$$\n\\boldsymbol{t}(\\boldsymbol{n}) = \\boldsymbol{\\sigma} \\boldsymbol{n}\n$$\nThe balance of angular momentum further constrains the stress tensor to be symmetric, i.e., $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^T$. The provided tensor adheres to this principle.\n\nThe traction vector $\\boldsymbol{t}$ can be decomposed into two orthogonal components: one normal to the plane, $\\boldsymbol{\\sigma}_{n}$, and one tangential (or shear) to the plane, $\\boldsymbol{\\tau}$.\n$$\n\\boldsymbol{t} = \\boldsymbol{\\sigma}_{n} + \\boldsymbol{\\tau}\n$$\nThe normal component $\\boldsymbol{\\sigma}_{n}$ is the vector projection of $\\boldsymbol{t}$ onto the direction of the unit normal vector $\\boldsymbol{n}$:\n$$\n\\boldsymbol{\\sigma}_{n} = (\\boldsymbol{t} \\cdot \\boldsymbol{n}) \\boldsymbol{n}\n$$\nThe scalar magnitude of this vector is the normal stress, denoted $\\sigma_{nn}$:\n$$\n\\sigma_{nn} = \\boldsymbol{t} \\cdot \\boldsymbol{n} = (\\boldsymbol{\\sigma}\\boldsymbol{n}) \\cdot \\boldsymbol{n} = \\boldsymbol{n}^T \\boldsymbol{\\sigma} \\boldsymbol{n}\n$$\nThe shear traction vector $\\boldsymbol{\\tau}$ is obtained by subtracting the normal component from the total traction vector:\n$$\n\\boldsymbol{\\tau} = \\boldsymbol{t} - \\boldsymbol{\\sigma}_{n} = \\boldsymbol{t} - \\sigma_{nn} \\boldsymbol{n}\n$$\nBy construction, $\\boldsymbol{\\tau}$ is orthogonal to $\\boldsymbol{n}$, as $\\boldsymbol{\\tau} \\cdot \\boldsymbol{n} = (\\boldsymbol{t} - \\sigma_{nn} \\boldsymbol{n}) \\cdot \\boldsymbol{n} = \\boldsymbol{t} \\cdot \\boldsymbol{n} - \\sigma_{nn} (\\boldsymbol{n} \\cdot \\boldsymbol{n}) = \\sigma_{nn} - \\sigma_{nn}(1) = 0$.\nThe magnitude of the shear traction, $\\|\\boldsymbol{\\tau}\\|$, can be found from the Pythagorean theorem, since $\\boldsymbol{\\sigma}_{n}$ and $\\boldsymbol{\\tau}$ are orthogonal:\n$$\n\\|\\boldsymbol{t}\\|^2 = \\|\\boldsymbol{\\sigma}_{n}\\|^2 + \\|\\boldsymbol{\\tau}\\|^2 = (\\sigma_{nn})^2 + \\|\\boldsymbol{\\tau}\\|^2\n$$\nThis gives $\\|\\boldsymbol{\\tau}\\| = \\sqrt{\\|\\boldsymbol{t}\\|^2 - (\\sigma_{nn})^2}$.\n\nNow, we evaluate these quantities for the given $\\boldsymbol{\\sigma}$ and $\\boldsymbol{n}$.\nThe stress tensor is\n$$\n\\boldsymbol{\\sigma} = \\begin{bmatrix}100 & 30 & -20\\\\ 30 & 50 & 0\\\\ -20 & 0 & 80\\end{bmatrix} \\text{ MPa}\n$$\nand the normal vector is $\\boldsymbol{n} = \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}$.\n\n1.  **Traction vector $\\boldsymbol{t}(\\boldsymbol{n})$**:\n$$\n\\boldsymbol{t} = \\boldsymbol{\\sigma}\\boldsymbol{n} = \\begin{bmatrix}100 & 30 & -20\\\\ 30 & 50 & 0\\\\ -20 & 0 & 80\\end{bmatrix} \\left( \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 100(1) + 30(2) - 20(3) \\\\ 30(1) + 50(2) + 0(3) \\\\ -20(1) + 0(2) + 80(3) \\end{pmatrix}\n$$\n$$\n\\boldsymbol{t} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 100 + 60 - 60 \\\\ 30 + 100 \\\\ -20 + 240 \\end{pmatrix} = \\frac{1}{\\sqrt{14}} \\begin{pmatrix} 100 \\\\ 130 \\\\ 220 \\end{pmatrix}\n$$\nIn component form, rationalizing the denominator:\n$t_1 = \\frac{100}{\\sqrt{14}} = \\frac{100\\sqrt{14}}{14} = \\frac{50\\sqrt{14}}{7}$\n$t_2 = \\frac{130}{\\sqrt{14}} = \\frac{130\\sqrt{14}}{14} = \\frac{65\\sqrt{14}}{7}$\n$t_3 = \\frac{220}{\\sqrt{14}} = \\frac{220\\sqrt{14}}{14} = \\frac{110\\sqrt{14}}{7}$\n\n2.  **Normal stress $\\sigma_{nn}$**:\n$$\n\\sigma_{nn} = \\boldsymbol{t} \\cdot \\boldsymbol{n} = \\left(\\frac{1}{\\sqrt{14}} \\begin{pmatrix} 100 \\\\ 130 \\\\ 220 \\end{pmatrix}\\right) \\cdot \\left(\\frac{1}{\\sqrt{14}} \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}\\right) = \\frac{1}{14} (100(1) + 130(2) + 220(3))\n$$\n$$\n\\sigma_{nn} = \\frac{1}{14} (100 + 260 + 660) = \\frac{1020}{14} = \\frac{510}{7}\n$$\n\n3.  **Shear traction vector $\\boldsymbol{\\tau}$**:\n$$\n\\boldsymbol{\\tau} = \\boldsymbol{t} - \\sigma_{nn} \\boldsymbol{n} = \\frac{1}{\\sqrt{14}}\\begin{pmatrix} 100 \\\\ 130 \\\\ 220 \\end{pmatrix} - \\frac{510}{7} \\left(\\frac{1}{\\sqrt{14}}\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}\\right)\n$$\nWe factor out $\\frac{1}{7\\sqrt{14}}$:\n$$\n\\boldsymbol{\\tau} = \\frac{1}{7\\sqrt{14}} \\left( 7 \\begin{pmatrix} 100 \\\\ 130 \\\\ 220 \\end{pmatrix} - 510 \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix} \\right) = \\frac{1}{7\\sqrt{14}} \\begin{pmatrix} 700 - 510 \\\\ 910 - 1020 \\\\ 1540 - 1530 \\end{pmatrix} = \\frac{1}{7\\sqrt{14}} \\begin{pmatrix} 190 \\\\ -110 \\\\ 10 \\end{pmatrix}\n$$\nIn component form, rationalizing the denominator:\n$\\tau_1 = \\frac{190}{7\\sqrt{14}} = \\frac{190\\sqrt{14}}{7 \\times 14} = \\frac{190\\sqrt{14}}{98} = \\frac{95\\sqrt{14}}{49}$\n$\\tau_2 = \\frac{-110}{7\\sqrt{14}} = \\frac{-110\\sqrt{14}}{98} = -\\frac{55\\sqrt{14}}{49}$\n$\\tau_3 = \\frac{10}{7\\sqrt{14}} = \\frac{10\\sqrt{14}}{98} = \\frac{5\\sqrt{14}}{49}$\n\n4.  **Magnitude of shear traction $\\|\\boldsymbol{\\tau}\\|$**:\nWe use $\\|\\boldsymbol{\\tau}\\|^2 = \\|\\boldsymbol{t}\\|^2 - (\\sigma_{nn})^2$.\n$$\n\\|\\boldsymbol{t}\\|^2 = \\left(\\frac{100}{\\sqrt{14}}\\right)^2 + \\left(\\frac{130}{\\sqrt{14}}\\right)^2 + \\left(\\frac{220}{\\sqrt{14}}\\right)^2 = \\frac{10000 + 16900 + 48400}{14} = \\frac{75300}{14} = \\frac{37650}{7}\n$$\n$$\n(\\sigma_{nn})^2 = \\left(\\frac{510}{7}\\right)^2 = \\frac{260100}{49}\n$$\n$$\n\\|\\boldsymbol{\\tau}\\|^2 = \\frac{37650}{7} - \\frac{260100}{49} = \\frac{7 \\times 37650}{49} - \\frac{260100}{49} = \\frac{263550 - 260100}{49} = \\frac{3450}{49}\n$$\n$$\n\\|\\boldsymbol{\\tau}\\| = \\sqrt{\\frac{3450}{49}} = \\frac{\\sqrt{3450}}{7}\n$$\nTo simplify the radical, we factorize $3450$: $3450 = 345 \\times 10 = (5 \\times 69) \\times (2 \\times 5) = 2 \\times 5^2 \\times (3 \\times 23) = 25 \\times 138$.\nThus, $\\sqrt{3450} = \\sqrt{25 \\times 138} = 5\\sqrt{138}$.\n$$\n\\|\\boldsymbol{\\tau}\\| = \\frac{5\\sqrt{138}}{7}\n$$\n\nThe final quantities, expressed in MPa, are:\n-   $\\boldsymbol{t} = \\begin{pmatrix} \\frac{50\\sqrt{14}}{7} & \\frac{65\\sqrt{14}}{7} & \\frac{110\\sqrt{14}}{7} \\end{pmatrix}^T$\n-   $\\sigma_{nn} = \\frac{510}{7}$\n-   $\\boldsymbol{\\tau} = \\begin{pmatrix} \\frac{95\\sqrt{14}}{49} & -\\frac{55\\sqrt{14}}{49} & \\frac{5\\sqrt{14}}{49} \\end{pmatrix}^T$\n-   $\\|\\boldsymbol{\\tau}\\| = \\frac{5\\sqrt{138}}{7}$\n\nThese results will be compiled into the required eight-entry row matrix.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{50\\sqrt{14}}{7} & \\frac{65\\sqrt{14}}{7} & \\frac{110\\sqrt{14}}{7} & \\frac{510}{7} & \\frac{95\\sqrt{14}}{49} & -\\frac{55\\sqrt{14}}{49} & \\frac{5\\sqrt{14}}{49} & \\frac{5\\sqrt{138}}{7}\n\\end{pmatrix}\n}\n$$", "id": "2694348"}, {"introduction": "Physical laws must be independent of the observer's reference frame, a principle known as objectivity. This exercise challenges you to demonstrate this fundamental axiom for stress-derived quantities by proving that the scalar normal stress $\\sigma_{nn}$ and shear magnitude $\\tau$ are invariant under rigid body rotations. You will translate this proof into a numerical algorithm, providing a concrete verification that these physically meaningful scalars are not artifacts of the chosen coordinate system [@problem_id:2694315].", "problem": "You are to verify the objectivity (frame-indifference) of computed tractions for three-dimensional Cauchy stress states under superposed rigid body rotations. The fundamental base you must use is Cauchy’s traction theorem: for a continuum with Cauchy stress tensor $\\boldsymbol{\\sigma}$ and a plane with unit normal $\\boldsymbol{n}$, the traction vector on that plane is $\\boldsymbol{t}(\\boldsymbol{n}) = \\boldsymbol{\\sigma}\\,\\boldsymbol{n}$. Under a proper orthogonal rotation $\\boldsymbol{Q}$, physical objectivity requires that if both the tensor and the normal are rotated consistently, that is, $\\boldsymbol{\\sigma}' = \\boldsymbol{Q}\\,\\boldsymbol{\\sigma}\\,\\boldsymbol{Q}^{\\mathsf{T}}$ and $\\boldsymbol{n}' = \\boldsymbol{Q}\\,\\boldsymbol{n}$, then the scalar normal traction and the scalar shear traction magnitude computed from $\\boldsymbol{\\sigma}$ on $\\boldsymbol{n}$ must equal those computed from $\\boldsymbol{\\sigma}'$ on $\\boldsymbol{n}'$.\n\nTasks:\n- Starting from Cauchy’s traction theorem and the decomposition of a vector into components parallel and perpendicular to a unit vector, derive explicit expressions for the scalar normal traction $\\,\\sigma_{nn}\\,$ and the scalar shear traction magnitude $\\,\\tau\\,$ on a plane with unit normal $\\boldsymbol{n}$, in terms of $\\boldsymbol{\\sigma}$ and $\\boldsymbol{n}$. Do not assume any specific form of $\\boldsymbol{\\sigma}$ beyond symmetry of the Cauchy stress tensor and do not use any pre-derived transformation laws other than the definition of a proper orthogonal rotation (orthogonality and unit determinant). Express all steps using linear algebra identities and the properties of dot products.\n- Using your derivation, design an algorithm that, for any given $\\boldsymbol{\\sigma}$, $\\boldsymbol{n}$, and proper orthogonal $\\boldsymbol{Q}$, computes $\\,\\sigma_{nn}\\,$ and $\\,\\tau\\,$ before and after rotation and returns a boolean indicating whether both quantities are invariant within a prescribed tolerance $\\,\\varepsilon\\,$.\n\nAll stress components are given in megapascals (MPa). Although your program will internally compute quantities in MPa, the program’s final outputs are booleans and therefore unitless. All rotation angles provided below are in radians.\n\nTest suite:\nFor each test case, normalize any provided $\\boldsymbol{n}$, construct the rotation matrix $\\boldsymbol{Q}$ as specified (use the axis–angle representation and the Rodrigues rotation formula for non-identity rotations), compute the invariance checks for $\\,\\sigma_{nn}\\,$ and $\\,\\tau\\,$, and return a single boolean that is true if and only if both checks pass with absolute error not exceeding $\\varepsilon = 10^{-10}$.\n\nUse the following five test cases. In each case, the Cauchy stress tensor $\\boldsymbol{\\sigma}$ is symmetric.\n\n- Case $1$ (general off-diagonal stress, arbitrary plane, generic rotation):\n  - $\\boldsymbol{\\sigma} = \\begin{bmatrix} 120 & 30 & -15 \\\\ 30 & 80 & 25 \\\\ -15 & 25 & 50 \\end{bmatrix}$ (MPa)\n  - $\\boldsymbol{n} = [2,\\,-1,\\,3]$ (to be normalized)\n  - Rotation axis $\\boldsymbol{a} = [1,\\,1,\\,1]$ (to be normalized), angle $\\theta = \\pi/5$\n- Case $2$ (hydrostatic stress, arbitrary plane, rotation about $z$):\n  - $\\boldsymbol{\\sigma} = 70\\,\\boldsymbol{I} = \\begin{bmatrix} 70 & 0 & 0 \\\\ 0 & 70 & 0 \\\\ 0 & 0 & 70 \\end{bmatrix}$ (MPa)\n  - $\\boldsymbol{n} = [0.3,\\,0.4,\\,0.8660254037844386]$ (to be normalized)\n  - Rotation axis $\\boldsymbol{a} = [0,\\,0,\\,1]$, angle $\\theta = \\pi/3$\n- Case $3$ (pure shear, plane normal along a coordinate axis, rotation about $y$ by right angle):\n  - $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0 & 40 & 0 \\\\ 40 & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}$ (MPa)\n  - $\\boldsymbol{n} = [1,\\,0,\\,0]$ (already unit)\n  - Rotation axis $\\boldsymbol{a} = [0,\\,1,\\,0]$, angle $\\theta = \\pi/2$\n- Case $4$ (generic symmetric stress, identity rotation as boundary case):\n  - $\\boldsymbol{\\sigma} = \\begin{bmatrix} 35 & -10 & 5 \\\\ -10 & 60 & -20 \\\\ 5 & -20 & 90 \\end{bmatrix}$ (MPa)\n  - $\\boldsymbol{n} = [-2,\\,1,\\,2]$ (to be normalized)\n  - $\\boldsymbol{Q} = \\boldsymbol{I}$ (identity rotation)\n- Case $5$ (diagonal stress with distinct principal values, $180$-degree rotation about $y$):\n  - $\\boldsymbol{\\sigma} = \\operatorname{diag}(200,\\,100,\\,50)$ (MPa)\n  - $\\boldsymbol{n} = [-0.5,\\,0.7,\\,-0.5]$ (to be normalized)\n  - Rotation axis $\\boldsymbol{a} = [0,\\,1,\\,0]$, angle $\\theta = \\pi$\n\nFinal output format:\n- Your program must produce a single line of output containing a Python-style list of booleans, one per test case in the order given above, with no spaces, for example, \"[True,False,True,True,False]\".", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of continuum mechanics, well-posed with a unique and verifiable solution path, and formulated with objective, unambiguous terminology. It constitutes a standard exercise in demonstrating the principle of material frame-indifference for scalar quantities derived from the Cauchy stress tensor. I will proceed with the required derivation and algorithmic solution.\n\nThe task is to first derive analytical expressions for the scalar normal traction, $\\sigma_{nn}$, and the scalar shear traction magnitude, $\\tau$, and then to demonstrate their invariance under a rigid body rotation. This invariance is a manifestation of the principle of objectivity, which mandates that constitutive laws and derived physical quantities must be independent of the observer's reference frame.\n\nThe derivation begins with Cauchy's traction theorem, which relates the traction vector $\\boldsymbol{t}$ acting on a surface to the Cauchy stress tensor $\\boldsymbol{\\sigma}$ and the unit normal vector $\\boldsymbol{n}$ of the surface:\n$$ \\boldsymbol{t}(\\boldsymbol{n}) = \\boldsymbol{\\sigma}\\boldsymbol{n} $$\nHere, $\\boldsymbol{\\sigma}$ is a symmetric second-order tensor. The traction vector $\\boldsymbol{t}$ can be decomposed into two orthogonal components: a normal component $\\boldsymbol{t}_n$ parallel to $\\boldsymbol{n}$, and a shear component $\\boldsymbol{t}_s$ perpendicular to $\\boldsymbol{n}$.\n$$ \\boldsymbol{t} = \\boldsymbol{t}_n + \\boldsymbol{t}_s $$\n\nThe scalar normal traction, $\\sigma_{nn}$, is the component of the traction vector $\\boldsymbol{t}$ in the direction of the unit normal $\\boldsymbol{n}$. It is obtained by the scalar projection of $\\boldsymbol{t}$ onto $\\boldsymbol{n}$:\n$$ \\sigma_{nn} = \\boldsymbol{t} \\cdot \\boldsymbol{n} $$\nSubstituting the expression for $\\boldsymbol{t}$ from Cauchy's theorem gives the explicit formula for $\\sigma_{nn}$ in terms of $\\boldsymbol{\\sigma}$ and $\\boldsymbol{n}$:\n$$ \\sigma_{nn} = (\\boldsymbol{\\sigma}\\boldsymbol{n}) \\cdot \\boldsymbol{n} $$\nIn matrix notation, where vectors are columns, this dot product is equivalent to $\\boldsymbol{n}^{\\mathsf{T}}(\\boldsymbol{\\sigma}\\boldsymbol{n})$. Thus, we have:\n$$ \\sigma_{nn} = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{\\sigma}\\boldsymbol{n} $$\n\nThe shear traction vector is $\\boldsymbol{t}_s = \\boldsymbol{t} - \\boldsymbol{t}_n$. The normal traction vector is $\\boldsymbol{t}_n = \\sigma_{nn}\\boldsymbol{n}$. Because the decomposition is into orthogonal components, we can apply the Pythagorean theorem to the magnitudes of the vectors:\n$$ \\|\\boldsymbol{t}\\|^2 = \\|\\boldsymbol{t}_n\\|^2 + \\|\\boldsymbol{t}_s\\|^2 $$\nThe scalar shear traction magnitude, $\\tau$, is defined as the magnitude of the shear traction vector, $\\tau = \\|\\boldsymbol{t}_s\\|$. The squared magnitude of the normal component is $\\|\\boldsymbol{t}_n\\|^2 = (\\sigma_{nn}\\boldsymbol{n}) \\cdot (\\sigma_{nn}\\boldsymbol{n}) = \\sigma_{nn}^2 (\\boldsymbol{n} \\cdot \\boldsymbol{n}) = \\sigma_{nn}^2$, since $\\boldsymbol{n}$ is a unit vector.\nTherefore, the squared shear traction magnitude is:\n$$ \\tau^2 = \\|\\boldsymbol{t}\\|^2 - \\sigma_{nn}^2 $$\nThe squared magnitude of the total traction vector is $\\|\\boldsymbol{t}\\|^2 = \\boldsymbol{t} \\cdot \\boldsymbol{t} = (\\boldsymbol{\\sigma}\\boldsymbol{n}) \\cdot (\\boldsymbol{\\sigma}\\boldsymbol{n})$. In matrix notation, this is $(\\boldsymbol{\\sigma}\\boldsymbol{n})^{\\mathsf{T}}(\\boldsymbol{\\sigma}\\boldsymbol{n}) = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{\\sigma}^{\\mathsf{T}}\\boldsymbol{\\sigma}\\boldsymbol{n}$.\nSo, the final expression for the scalar shear traction magnitude is:\n$$ \\tau = \\sqrt{\\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{\\sigma}^{\\mathsf{T}}\\boldsymbol{\\sigma}\\boldsymbol{n} - \\left(\\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{\\sigma}\\boldsymbol{n}\\right)^2} $$\n\nNext, we must demonstrate the objectivity of these scalar quantities. Under a rigid body rotation described by a proper orthogonal matrix $\\boldsymbol{Q}$ (where $\\boldsymbol{Q}^{\\mathsf{T}}\\boldsymbol{Q} = \\boldsymbol{I}$ and $\\det(\\boldsymbol{Q}) = 1$), the stress tensor and normal vector transform as:\n$$ \\boldsymbol{\\sigma}' = \\boldsymbol{Q}\\boldsymbol{\\sigma}\\boldsymbol{Q}^{\\mathsf{T}} $$\n$$ \\boldsymbol{n}' = \\boldsymbol{Q}\\boldsymbol{n} $$\nWe must show that $\\sigma'_{nn} = \\sigma_{nn}$ and $\\tau' = \\tau$.\n\nFor the normal traction, $\\sigma'_{nn}$, we substitute the transformed quantities into its definition:\n$$ \\sigma'_{nn} = (\\boldsymbol{n}')^{\\mathsf{T}}\\boldsymbol{\\sigma}'\\boldsymbol{n}' = (\\boldsymbol{Q}\\boldsymbol{n})^{\\mathsf{T}} (\\boldsymbol{Q}\\boldsymbol{\\sigma}\\boldsymbol{Q}^{\\mathsf{T}}) (\\boldsymbol{Q}\\boldsymbol{n}) $$\nUsing the transpose property $(\\boldsymbol{A}\\boldsymbol{B})^{\\mathsf{T}} = \\boldsymbol{B}^{\\mathsf{T}}\\boldsymbol{A}^{\\mathsf{T}}$, we have $(\\boldsymbol{Q}\\boldsymbol{n})^{\\mathsf{T}} = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{Q}^{\\mathsf{T}}$. The expression becomes:\n$$ \\sigma'_{nn} = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{Q}^{\\mathsf{T}} \\boldsymbol{Q}\\boldsymbol{\\sigma}\\boldsymbol{Q}^{\\mathsf{T}} \\boldsymbol{Q}\\boldsymbol{n} $$\nSince $\\boldsymbol{Q}$ is orthogonal, $\\boldsymbol{Q}^{\\mathsf{T}}\\boldsymbol{Q} = \\boldsymbol{I}$, the identity matrix. This simplifies the expression to:\n$$ \\sigma'_{nn} = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{I}\\boldsymbol{\\sigma}\\boldsymbol{I}\\boldsymbol{n} = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{\\sigma}\\boldsymbol{n} = \\sigma_{nn} $$\nThis proves that the scalar normal traction is invariant under rigid body rotations.\n\nFor the shear traction magnitude, $\\tau'$, its squared value is $(\\tau')^2 = \\|\\boldsymbol{t}'\\|^2 - (\\sigma'_{nn})^2$. We have already proven that $\\sigma'_{nn} = \\sigma_{nn}$. We now need to show that the squared magnitude of the traction vector, $\\|\\boldsymbol{t}\\|^2$, is also invariant. The transformed traction vector $\\boldsymbol{t}'$ is:\n$$ \\boldsymbol{t}' = \\boldsymbol{\\sigma}'\\boldsymbol{n}' = (\\boldsymbol{Q}\\boldsymbol{\\sigma}\\boldsymbol{Q}^{\\mathsf{T}})(\\boldsymbol{Q}\\boldsymbol{n}) = \\boldsymbol{Q}\\boldsymbol{\\sigma}(\\boldsymbol{Q}^{\\mathsf{T}}\\boldsymbol{Q})\\boldsymbol{n} = \\boldsymbol{Q}\\boldsymbol{\\sigma}\\boldsymbol{I}\\boldsymbol{n} = \\boldsymbol{Q}(\\boldsymbol{\\sigma}\\boldsymbol{n}) = \\boldsymbol{Q}\\boldsymbol{t} $$\nThe transformed traction vector is simply the original traction vector rotated by $\\boldsymbol{Q}$. The magnitude of a vector is invariant under rotation. Formally:\n$$ \\|\\boldsymbol{t}'\\|^2 = \\boldsymbol{t}' \\cdot \\boldsymbol{t}' = (\\boldsymbol{Q}\\boldsymbol{t}) \\cdot (\\boldsymbol{Q}\\boldsymbol{t}) = (\\boldsymbol{Q}\\boldsymbol{t})^{\\mathsf{T}}(\\boldsymbol{Q}\\boldsymbol{t}) = \\boldsymbol{t}^{\\mathsf{T}}\\boldsymbol{Q}^{\\mathsf{T}}\\boldsymbol{Q}\\boldsymbol{t} = \\boldsymbol{t}^{\\mathsf{T}}\\boldsymbol{I}\\boldsymbol{t} = \\boldsymbol{t}^{\\mathsf{T}}\\boldsymbol{t} = \\|\\boldsymbol{t}\\|^2 $$\nSince both terms in the expression for $\\tau^2$ are invariant, $\\tau^2$ itself is invariant:\n$$ (\\tau')^2 = \\|\\boldsymbol{t}'\\|^2 - (\\sigma'_{nn})^2 = \\|\\boldsymbol{t}\\|^2 - \\sigma_{nn}^2 = \\tau^2 $$\nTherefore, $\\tau' = \\tau$, proving the invariance of the scalar shear traction magnitude.\n\nThe algorithm to verify this numerically for each test case is as follows:\n$1$. For a given stress tensor $\\boldsymbol{\\sigma}$, a raw normal vector $\\boldsymbol{n}_{raw}$, and rotation parameters (axis $\\boldsymbol{a}_{raw}$, angle $\\theta$), first normalize the vectors: $\\boldsymbol{n} = \\boldsymbol{n}_{raw} / \\|\\boldsymbol{n}_{raw}\\|$ and, if applicable, $\\boldsymbol{a} = \\boldsymbol{a}_{raw} / \\|\\boldsymbol{a}_{raw}\\|$.\n$2$. Calculate the pre-rotation quantities: $\\sigma_{nn} = \\boldsymbol{n}^{\\mathsf{T}}\\boldsymbol{\\sigma}\\boldsymbol{n}$ and $\\tau = \\sqrt{(\\boldsymbol{\\sigma}\\boldsymbol{n})^{\\mathsf{T}}(\\boldsymbol{\\sigma}\\boldsymbol{n}) - \\sigma_{nn}^2}$.\n$3$. Construct the rotation matrix $\\boldsymbol{Q}$. For a rotation about axis $\\boldsymbol{a}$ by angle $\\theta$, use the Rodrigues' rotation formula: $\\boldsymbol{Q} = \\boldsymbol{I} + \\sin(\\theta)\\boldsymbol{K} + (1 - \\cos(\\theta))\\boldsymbol{K}^2$, where $\\boldsymbol{K}$ is the cross-product matrix of $\\boldsymbol{a}$. For an identity rotation, $\\boldsymbol{Q} = \\boldsymbol{I}$.\n$4$. Compute the transformed quantities: $\\boldsymbol{\\sigma}' = \\boldsymbol{Q}\\boldsymbol{\\sigma}\\boldsymbol{Q}^{\\mathsf{T}}$ and $\\boldsymbol{n}' = \\boldsymbol{Q}\\boldsymbol{n}$.\n$5$. Calculate the post-rotation quantities: $\\sigma'_{nn} = (\\boldsymbol{n}')^{\\mathsf{T}}\\boldsymbol{\\sigma}'\\boldsymbol{n}'$ and $\\tau' = \\sqrt{(\\boldsymbol{\\sigma}'\\boldsymbol{n}')^{\\mathsf{T}}(\\boldsymbol{\\sigma}'\\boldsymbol{n}') - (\\sigma'_{nn})^2}$.\n$6$. Compare the pre- and post-rotation values. The invariance check passes if $|\\sigma_{nn} - \\sigma'_{nn}| \\le \\varepsilon$ and $|\\tau - \\tau'| \\le \\varepsilon$, where the tolerance $\\varepsilon = 10^{-10}$. A single boolean `True` is returned if both checks pass, otherwise `False`.\n\nThis procedure will be implemented for all provided test cases. Since the principle of objectivity is a fundamental axiom of continuum mechanics, we expect the invariance to hold true for all cases, and the program should return `True` for each.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the objectivity of scalar normal and shear tractions\n    for given Cauchy stress states under rigid body rotations.\n    \"\"\"\n\n    # Tolerance for floating-point comparisons\n    epsilon = 1e-10\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (sigma, n_raw, rotation_params).\n    # rotation_params is either (axis, angle) or None for identity.\n    test_cases = [\n        # Case 1\n        (\n            [[120, 30, -15], [30, 80, 25], [-15, 25, 50]],\n            [2, -1, 3],\n            ([1, 1, 1], np.pi / 5)\n        ),\n        # Case 2\n        (\n            [[70, 0, 0], [0, 70, 0], [0, 0, 70]],\n            [0.3, 0.4, 0.8660254037844386],\n            ([0, 0, 1], np.pi / 3)\n        ),\n        # Case 3\n        (\n            [[0, 40, 0], [40, 0, 0], [0, 0, 0]],\n            [1, 0, 0],\n            ([0, 1, 0], np.pi / 2)\n        ),\n        # Case 4\n        (\n            [[35, -10, 5], [-10, 60, -20], [5, -20, 90]],\n            [-2, 1, 2],\n            None  # Indicates identity rotation_params\n        ),\n        # Case 5\n        (\n            [[200, 0, 0], [0, 100, 0], [0, 0, 50]],\n            [-0.5, 0.7, -0.5],\n            ([0, 1, 0], np.pi)\n        ),\n    ]\n\n    def build_rodrigues_q(axis_raw, angle):\n        \"\"\"Builds a rotation matrix using Rodrigues' formula.\"\"\"\n        axis = np.asarray(axis_raw, dtype=float)\n        norm_axis = np.linalg.norm(axis)\n        if norm_axis  1e-12:  # Handle zero vector case\n            return np.eye(3)\n        axis = axis / norm_axis\n        \n        a_x, a_y, a_z = axis\n        \n        # Cross-product matrix K\n        K = np.array([\n            [0, -a_z, a_y],\n            [a_z, 0, -a_x],\n            [-a_y, a_x, 0]\n        ])\n        \n        I = np.eye(3)\n        # Rodrigues' formula: Q = I + sin(theta)*K + (1-cos(theta))*K^2\n        Q = I + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n        return Q\n\n    def calculate_tractions(sigma, n):\n        \"\"\"Calculates scalar normal and shear tractions.\"\"\"\n        # Ensure n is a unit vector for correct calculations\n        # Normalization is expected to be done prior to calling this function.\n        t = sigma @ n\n        sigma_nn = n @ t\n        # tau^2 = ||t||^2 - sigma_nn^2\n        tau_squared = np.dot(t, t) - sigma_nn**2\n        # Handle potential small negative values from floating point error\n        tau = np.sqrt(max(0, tau_squared))\n        return sigma_nn, tau\n\n    results = []\n    for case in test_cases:\n        sigma_raw, n_raw, rotation_params = case\n        \n        sigma = np.array(sigma_raw, dtype=float)\n        n = np.array(n_raw, dtype=float)\n        # Normalize the normal vector n\n        n = n / np.linalg.norm(n)\n        \n        # --- Pre-rotation calculations ---\n        sigma_nn_pre, tau_pre = calculate_tractions(sigma, n)\n        \n        # --- Construct rotation matrix Q ---\n        if rotation_params is None: # Case 4: Q = I\n            Q = np.eye(3)\n        else:\n            axis_raw, angle = rotation_params\n            Q = build_rodrigues_q(axis_raw, angle)\n            \n        # --- Post-rotation calculations ---\n        # Transform stress tensor and normal vector\n        sigma_prime = Q @ sigma @ Q.T\n        n_prime = Q @ n\n        \n        # Calculate tractions for the rotated state\n        sigma_nn_post, tau_post = calculate_tractions(sigma_prime, n_prime)\n\n        # --- Invariance check ---\n        is_invariant_sigma_nn = np.abs(sigma_nn_pre - sigma_nn_post) = epsilon\n        is_invariant_tau = np.abs(tau_pre - tau_post) = epsilon\n        \n        results.append(is_invariant_sigma_nn and is_invariant_tau)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2694315"}, {"introduction": "This final practice connects the algebraic problem of finding principal stresses to the calculus problem of finding the extrema of a function. You will derive the gradient of the normal stress field on the unit sphere and use it to design an iterative optimization scheme that converges to the principal directions of stress. This advanced exercise demonstrates that the principal directions are precisely the orientations that experience maximum or minimum normal stress, providing a powerful computational method for their discovery [@problem_id:2694371].", "problem": "Consider a symmetric Cauchy stress tensor field in a rigid body, represented at a point by a second-order tensor $\\boldsymbol{\\sigma}$ with components $\\sigma_{ij}$ in a fixed orthonormal basis. For a unit normal direction $\\boldsymbol{n}$ on the unit sphere $\\mathbb{S}^2 \\subset \\mathbb{R}^3$, the traction vector is $\\boldsymbol{t}(\\boldsymbol{n}) = \\boldsymbol{\\sigma}\\cdot \\boldsymbol{n}$ and the normal stress is the scalar field $\\sigma_{nn}(\\boldsymbol{n}) = \\boldsymbol{n}\\cdot \\boldsymbol{\\sigma}\\cdot \\boldsymbol{n}$ restricted to $\\mathbb{S}^2$. Starting only from the definitions of the Cauchy traction and the normal stress, and from the definition of the Riemannian gradient on a smooth manifold as the orthogonal projection of the ambient gradient onto the tangent space, do the following:\n\n- Derive the Riemannian gradient of the scalar field $\\sigma_{nn}(\\boldsymbol{n})$ on the unit sphere $\\mathbb{S}^2$ at an arbitrary unit vector $\\boldsymbol{n}$.\n\n- Using your gradient expression, design a projected-gradient iterative scheme on $\\mathbb{S}^2$ that, given an initial unit vector $\\boldsymbol{n}_0$, converges to a principal direction of $\\boldsymbol{\\sigma}$ by maximizing or minimizing $\\sigma_{nn}(\\boldsymbol{n})$ under the constraint $\\lVert \\boldsymbol{n} \\rVert = 1$. Your update should enforce the unit-length constraint and use only operations valid in Euclidean space, plus projection and normalization. The stopping criteria must be based on a quantitative smallness condition on the gradient norm or on the change in the objective value.\n\n- Implement your method in a program that computes, for each test case below, one scalar quantity that certifies either convergence to the correct principal direction (through an alignment measure) or the correct extremal value (through a Rayleigh quotient check), as specified. All outputs are dimensionless.\n\nTest suite specification (each $\\boldsymbol{\\sigma}$ is symmetric and each initial direction $\\boldsymbol{n}_0$ is a unit vector obtained by normalizing the listed components):\n- Case $1$ (distinct principal stresses; ascent to maximum): \n  $$\\boldsymbol{\\sigma}_1 = \\begin{bmatrix} 100  20  -10 \\\\ 20  150  30 \\\\ -10  30  200 \\end{bmatrix},\\quad \\boldsymbol{n}_{0,1} \\propto \\begin{bmatrix} 1 \\\\ 0.2 \\\\ -0.1 \\end{bmatrix}.$$\n  Output the scalar $r_1 = 1 - \\big|\\boldsymbol{n}_{\\max}\\cdot \\boldsymbol{v}_{\\max}\\big|$, where $\\boldsymbol{n}_{\\max}$ is the final unit direction from your ascent scheme and $\\boldsymbol{v}_{\\max}$ is the unit eigenvector corresponding to the largest eigenvalue of $\\boldsymbol{\\sigma}_1$ (choose either sign for $\\boldsymbol{v}_{\\max}$ to maximize the absolute dot product).\n- Case $2$ (repeated principal stresses; ascent to a degenerate maximum): \n  $$\\boldsymbol{\\sigma}_2 = \\begin{bmatrix} 50  0  0 \\\\ 0  50  0 \\\\ 0  0  10 \\end{bmatrix},\\quad \\boldsymbol{n}_{0,2} \\propto \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}.$$\n  Output the scalar $r_2 = \\dfrac{\\big|\\boldsymbol{n}_{\\max}^{\\top}\\boldsymbol{\\sigma}_2 \\boldsymbol{n}_{\\max} - \\lambda_{\\max}\\big|}{\\max\\{1,|\\lambda_{\\max}|\\}}$, where $\\lambda_{\\max}$ is the largest eigenvalue of $\\boldsymbol{\\sigma}_2$.\n- Case $3$ (mixed signs; descent to minimum): \n  $$\\boldsymbol{\\sigma}_3 = \\begin{bmatrix} -10  1  0 \\\\ 1  5  -2 \\\\ 0  -2  -3 \\end{bmatrix},\\quad \\boldsymbol{n}_{0,3} \\propto \\begin{bmatrix} 1 \\\\ 0.1 \\\\ -0.2 \\end{bmatrix}.$$\n  Output the scalar $r_3 = 1 - \\big|\\boldsymbol{n}_{\\min}\\cdot \\boldsymbol{v}_{\\min}\\big|$, where $\\boldsymbol{n}_{\\min}$ is the final unit direction from your descent scheme and $\\boldsymbol{v}_{\\min}$ is the unit eigenvector corresponding to the smallest eigenvalue of $\\boldsymbol{\\sigma}_3$ (choose either sign for $\\boldsymbol{v}_{\\min}$ to maximize the absolute dot product).\n- Case $4$ (zero stress; stationary field): \n  $$\\boldsymbol{\\sigma}_4 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad \\boldsymbol{n}_{0,4} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.$$\n  Output the scalar $r_4 = \\lVert \\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}_{0,4}) \\rVert_2.$\n- Case $5$ (near-degenerate maxima; ascent to maximum): \n  $$\\boldsymbol{\\sigma}_5 = \\begin{bmatrix} 1  0  0 \\\\ 0  1+10^{-6}  0 \\\\ 0  0  1-10^{-6} \\end{bmatrix},\\quad \\boldsymbol{n}_{0,5} \\propto \\begin{bmatrix} 0.3 \\\\ 0.4 \\\\ 0.5 \\end{bmatrix}.$$\n  Output the scalar $r_5 = 1 - \\big|\\boldsymbol{n}_{\\max}\\cdot \\boldsymbol{v}_{\\max}\\big|$, defined as in Case $1$ for $\\boldsymbol{\\sigma}_5$.\n- Case $6$ (tangency check of the gradient on $\\mathbb{S}^2$): \n  $$\\boldsymbol{\\sigma}_6 = \\begin{bmatrix} 3  -1  0.5 \\\\ -1  2  0.3 \\\\ 0.5  0.3  1 \\end{bmatrix},\\quad \\boldsymbol{n}_{0,6} \\propto \\begin{bmatrix} 0.3 \\\\ -0.7 \\\\ 0.65 \\end{bmatrix}.$$\n  Output the scalar $r_6 = \\big|\\boldsymbol{n}_{0,6}\\cdot \\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}_{0,6})\\big|.$\n\nYour program should implement the gradient on $\\mathbb{S}^2$ derived in the first part, and a projected-gradient method with backtracking line search that monotonically increases (for ascent) or decreases (for descent) the objective $\\sigma_{nn}(\\boldsymbol{n})$ while re-normalizing to unit length at each iteration. Use a stopping tolerance of $10^{-12}$ based on either the Euclidean norm of the Riemannian gradient or the absolute change in the objective per step, and use a maximum of $10^4$ iterations. All outputs are dimensionless.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\,[\\text{result}_1,\\text{result}_2,\\dots]\\,)$ in the order $[r_1,r_2,r_3,r_4,r_5,r_6]$.", "solution": "The problem requires the derivation of the Riemannian gradient for the normal stress field on the unit sphere, the design of a projected-gradient optimization scheme to find its extrema, and the implementation of this method to solve a series of test cases. The core of the problem lies in translating a standard eigenvalue problem into the language of optimization on a manifold.\n\nFirst, we address the derivation of the Riemannian gradient. The scalar field of interest is the normal stress $\\sigma_{nn}(\\boldsymbol{n})$ defined for any unit vector $\\boldsymbol{n} \\in \\mathbb{S}^2 \\subset \\mathbb{R}^3$. This function is the restriction of the ambient quadratic form $f(\\boldsymbol{x}) = \\boldsymbol{x}^{\\top}\\boldsymbol{\\sigma}\\boldsymbol{x}$ to the unit sphere, where $\\boldsymbol{\\sigma}$ is the symmetric Cauchy stress tensor. In index notation, with summation implied over repeated indices, $f(\\boldsymbol{x}) = \\sigma_{ij}x_i x_j$.\n\nThe Riemannian gradient on a submanifold is defined as the orthogonal projection of the ambient Euclidean gradient onto the tangent space of the submanifold. We begin by computing the ambient gradient of $f(\\boldsymbol{x})$ in $\\mathbb{R}^3$. The $k$-th component of the gradient vector, $\\nabla_{\\mathbb{R}^3}f$, is given by:\n$$\n(\\nabla_{\\mathbb{R}^3}f)_k = \\frac{\\partial}{\\partial x_k}(\\sigma_{ij}x_i x_j) = \\sigma_{ij}(\\delta_{ik}x_j + x_i\\delta_{jk}) = \\sigma_{kj}x_j + \\sigma_{ik}x_i\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta. Since the stress tensor $\\boldsymbol{\\sigma}$ is symmetric, $\\sigma_{ik} = \\sigma_{ki}$. Thus, the second term is $\\sigma_{ki}x_i$. Relabeling the summation index $i$ to $j$, this becomes $\\sigma_{kj}x_j$. The $k$-th component of the gradient is therefore:\n$$\n(\\nabla_{\\mathbb{R}^3}f)_k = \\sigma_{kj}x_j + \\sigma_{kj}x_j = 2\\sigma_{kj}x_j\n$$\nIn vector notation, this is succinctly written as:\n$$\n\\nabla_{\\mathbb{R}^3}f(\\boldsymbol{x}) = 2\\boldsymbol{\\sigma}\\boldsymbol{x}\n$$\nThe tangent space to the unit sphere $\\mathbb{S}^2$ at a point $\\boldsymbol{n} \\in \\mathbb{S}^2$ is the set of vectors orthogonal to $\\boldsymbol{n}$: $T_{\\boldsymbol{n}}\\mathbb{S}^2 = \\{\\boldsymbol{v} \\in \\mathbb{R}^3 \\mid \\boldsymbol{v} \\cdot \\boldsymbol{n} = 0\\}$. The operator $P_{\\boldsymbol{n}}$ that projects an ambient vector $\\boldsymbol{v}$ onto $T_{\\boldsymbol{n}}\\mathbb{S}^2$ is given by $P_{\\boldsymbol{n}}(\\boldsymbol{v}) = \\boldsymbol{v} - (\\boldsymbol{v} \\cdot \\boldsymbol{n})\\boldsymbol{n}$.\n\nApplying this projection to the ambient gradient $\\nabla_{\\mathbb{R}^3}f$ evaluated at $\\boldsymbol{n}$ yields the Riemannian gradient of $\\sigma_{nn}(\\boldsymbol{n})$:\n$$\n\\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}) = P_{\\boldsymbol{n}}(\\nabla_{\\mathbb{R}^3}f(\\boldsymbol{n})) = P_{\\boldsymbol{n}}(2\\boldsymbol{\\sigma}\\boldsymbol{n})\n$$\n$$\n\\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}) = 2\\boldsymbol{\\sigma}\\boldsymbol{n} - (2\\boldsymbol{\\sigma}\\boldsymbol{n} \\cdot \\boldsymbol{n})\\boldsymbol{n}\n$$\nThe scalar product term is $2(\\boldsymbol{n}^{\\top}\\boldsymbol{\\sigma}\\boldsymbol{n})$, which is precisely $2\\sigma_{nn}(\\boldsymbol{n})$. Substituting this back, we obtain the final expression:\n$$\n\\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}) = 2(\\boldsymbol{\\sigma}\\boldsymbol{n} - \\sigma_{nn}(\\boldsymbol{n})\\boldsymbol{n})\n$$\nThis result has a clear physical interpretation. The vector $\\boldsymbol{\\sigma}\\boldsymbol{n}$ is the traction vector $\\boldsymbol{t}(\\boldsymbol{n})$. The term $\\sigma_{nn}(\\boldsymbol{n})\\boldsymbol{n}$ is the normal component of this traction vector. Their difference, $\\boldsymbol{t}(\\boldsymbol{n}) - \\sigma_{nn}(\\boldsymbol{n})\\boldsymbol{n}$, is the shear stress vector, which lies in the tangent plane. The Riemannian gradient is thus twice the shear stress vector, indicating that the normal stress changes most rapidly in the direction of shear. The critical points of $\\sigma_{nn}(\\boldsymbol{n})$, where $\\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}) = \\boldsymbol{0}$, are the vectors $\\boldsymbol{n}$ for which the shear stress is zero. This occurs when $\\boldsymbol{\\sigma}\\boldsymbol{n} = \\sigma_{nn}(\\boldsymbol{n})\\boldsymbol{n}$, which is the definition of an eigenvector of $\\boldsymbol{\\sigma}$. The critical points are therefore the principal directions of stress.\n\nNext, we design the iterative scheme. The goal is to find an extremum of $f(\\boldsymbol{n}) = \\sigma_{nn}(\\boldsymbol{n})$ subject to the constraint $\\lVert\\boldsymbol{n}\\rVert_2 = 1$. A projected gradient method is suitable. At each iteration $k$, starting from a point $\\boldsymbol{n}_k \\in \\mathbb{S}^2$:\n$1$. The search direction $\\boldsymbol{p}_k$ is chosen along the direction of steepest ascent or descent on the manifold. This is the Riemannian gradient $\\boldsymbol{g}_k = \\operatorname{grad}_{\\mathbb{S}^2}\\sigma_{nn}(\\boldsymbol{n}_k)$ for maximization (ascent), or its negative, $-\\boldsymbol{g}_k$, for minimization (descent). We can write this as $\\boldsymbol{p}_k = s \\cdot \\boldsymbol{g}_k$ where $s=+1$ for ascent and $s=-1$ for descent.\n$2$. A trial point is found by taking a step of size $\\alpha_k$ along this tangent direction: $\\boldsymbol{n}_{\\text{trial}} = \\boldsymbol{n}_k + \\alpha_k \\boldsymbol{p}_k$.\n$3$. This trial point is not on the sphere. A retraction operation is required to map it back to the manifold $\\mathbb{S}^2$. The most natural retraction is normalization: $\\boldsymbol{n}_{k+1} = \\boldsymbol{n}_{\\text{trial}} / \\lVert \\boldsymbol{n}_{\\text{trial}} \\rVert_2$.\n$4$. The step size $\\alpha_k$ is determined using a backtracking line search to ensure convergence and monotonic improvement. Starting with a sufficiently large initial $\\alpha$, the step size is successively reduced by a factor $\\beta \\in (0,1)$ until the Armijo condition is satisfied. For ascent, this condition is $f(\\boldsymbol{n}_{k+1}) \\ge f(\\boldsymbol{n}_k) + c \\alpha_k \\boldsymbol{g}_k^{\\top}\\boldsymbol{p}_k = f(\\boldsymbol{n}_k) + c \\alpha_k \\lVert \\boldsymbol{g}_k \\rVert_2^2$ for a small constant $c \\in (0,1)$. For descent, the inequality is reversed. This ensures that each step provides a sufficient increase (or decrease) in the objective function.\n$5$. The iteration terminates when the norm of the Riemannian gradient $\\lVert \\boldsymbol{g}_k \\rVert_2$ falls below a tolerance $\\epsilon = 10^{-12}$, signifying that a critical point has been reached, or when the absolute change in the objective function per step, $|f(\\boldsymbol{n}_{k+1}) - f(\\boldsymbol{n}_k)|$, is less than $\\epsilon$. A maximum iteration count ($10^4$) serves as a safeguard.\n\nThis algorithm is implemented to solve the given test cases. For Cases $1$, $2$, $3$, and $5$, the algorithm is run until convergence to find a specific extremum. The resulting vector $\\boldsymbol{n}_{\\text{final}}$ is then compared against the true eigenvector (for alignment error, $r_1, r_3, r_5$) or the true eigenvalue (for Rayleigh quotient error, $r_2$). Eigenvectors and eigenvalues for comparison are computed using a standard numerical library function. For Case $4$, the gradient is computed at the initial point to confirm that for a zero stress tensor, the normal stress field is constant and its gradient is zero. For Case $6$, the dot product between the gradient vector and the position vector $\\boldsymbol{n}$ is computed to numerically verify the fundamental property that the Riemannian gradient is tangent to the sphere, i.e., orthogonal to $\\boldsymbol{n}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a projected gradient method on the unit sphere\n    to find extrema of the normal stress field for given stress tensors.\n    \"\"\"\n\n    def normalize(v):\n        \"\"\"Normalizes a vector to unit length.\"\"\"\n        norm = np.linalg.norm(v)\n        if norm == 0:\n            return v\n        return v / norm\n\n    def compute_objective(sigma, n):\n        \"\"\"Computes the normal stress sigma_nn(n) = n^T * sigma * n.\"\"\"\n        return n.T @ sigma @ n\n\n    def compute_riemannian_gradient(sigma, n):\n        \"\"\"Computes the Riemannian gradient of the normal stress on S^2.\"\"\"\n        traction_vector = sigma @ n\n        normal_stress = n.T @ traction_vector\n        gradient = 2 * (traction_vector - normal_stress * n)\n        return gradient\n\n    def projected_gradient_sphere(sigma, n0, mode, tol=1e-12, max_iter=10000):\n        \"\"\"\n        Performs projected gradient ascent/descent on the unit sphere S^2.\n\n        Args:\n            sigma (np.ndarray): The 3x3 symmetric stress tensor.\n            n0 (np.ndarray): The initial 3x1 unit vector.\n            mode (str): 'ascent' for maximization, 'descent' for minimization.\n            tol (float): The tolerance for stopping criteria.\n            max_iter (int): The maximum number of iterations.\n\n        Returns:\n            np.ndarray: The final unit vector n that extremizes the objective.\n        \"\"\"\n        n = normalize(n0)\n        \n        s = 1.0 if mode == 'ascent' else -1.0\n        \n        # Backtracking line search parameters\n        alpha_init = 1.0\n        beta = 0.5  # Reduction factor\n        c_armijo = 1e-4  # Armijo condition constant\n        \n        f_prev = compute_objective(sigma, n)\n        \n        for k in range(max_iter):\n            grad = compute_riemannian_gradient(sigma, n)\n            grad_norm = np.linalg.norm(grad)\n            \n            if grad_norm  tol:\n                break\n            \n            # Search direction (tangent vector)\n            p = s * grad\n            \n            # Backtracking line search to find step size alpha\n            alpha = alpha_init\n            while True:\n                n_trial_unnorm = n + alpha * p\n                n_next = normalize(n_trial_unnorm)\n                f_next = compute_objective(sigma, n_next)\n                \n                # Armijo condition for sufficient increase/decrease\n                armijo_rhs = f_prev + c_armijo * alpha * np.dot(grad, p)\n\n                if (s == 1.0 and f_next >= armijo_rhs) or \\\n                   (s == -1.0 and f_next = armijo_rhs):\n                    break # Found suitable alpha\n                \n                alpha *= beta\n                if alpha  tol * tol: # Step size too small\n                    break\n            \n            n = n_next\n            f_current = f_next\n            \n            if abs(f_current - f_prev)  tol:\n                break\n            \n            f_prev = f_current\n            \n        return n\n\n    results = []\n\n    # Case 1: Ascent to maximum\n    sigma1 = np.array([[100, 20, -10], [20, 150, 30], [-10, 30, 200]], dtype=float)\n    n0_1 = np.array([1, 0.2, -0.1], dtype=float)\n    n_max_1 = projected_gradient_sphere(sigma1, n0_1, 'ascent')\n    eigvals, eigvecs = np.linalg.eigh(sigma1)\n    v_max_1 = eigvecs[:, -1] # Eigenvector for largest eigenvalue\n    r1 = 1.0 - np.abs(np.dot(n_max_1, v_max_1))\n    results.append(r1)\n\n    # Case 2: Ascent to degenerate maximum\n    sigma2 = np.array([[50, 0, 0], [0, 50, 0], [0, 0, 10]], dtype=float)\n    n0_2 = np.array([1, 2, 3], dtype=float)\n    n_max_2 = projected_gradient_sphere(sigma2, n0_2, 'ascent')\n    eigvals, _ = np.linalg.eigh(sigma2)\n    lambda_max_2 = eigvals[-1]\n    rayleigh_quotient_2 = compute_objective(sigma2, n_max_2)\n    r2 = np.abs(rayleigh_quotient_2 - lambda_max_2) / max(1.0, np.abs(lambda_max_2))\n    results.append(r2)\n\n    # Case 3: Descent to minimum\n    sigma3 = np.array([[-10, 1, 0], [1, 5, -2], [0, -2, -3]], dtype=float)\n    n0_3 = np.array([1, 0.1, -0.2], dtype=float)\n    n_min_3 = projected_gradient_sphere(sigma3, n0_3, 'descent')\n    eigvals, eigvecs = np.linalg.eigh(sigma3)\n    v_min_3 = eigvecs[:, 0] # Eigenvector for smallest eigenvalue\n    r3 = 1.0 - np.abs(np.dot(n_min_3, v_min_3))\n    results.append(r3)\n\n    # Case 4: Zero stress, stationary field\n    sigma4 = np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=float)\n    n0_4 = np.array([1, 0, 0], dtype=float) # Already normalized\n    grad4 = compute_riemannian_gradient(sigma4, n0_4)\n    r4 = np.linalg.norm(grad4)\n    results.append(r4)\n\n    # Case 5: Near-degenerate maxima\n    sigma5 = np.array([[1, 0, 0], [0, 1 + 1e-6, 0], [0, 0, 1 - 1e-6]], dtype=float)\n    n0_5 = np.array([0.3, 0.4, 0.5], dtype=float)\n    n_max_5 = projected_gradient_sphere(sigma5, n0_5, 'ascent')\n    eigvals, eigvecs = np.linalg.eigh(sigma5)\n    v_max_5 = eigvecs[:, -1]\n    r5 = 1.0 - np.abs(np.dot(n_max_5, v_max_5))\n    results.append(r5)\n\n    # Case 6: Tangency check of the gradient\n    sigma6 = np.array([[3, -1, 0.5], [-1, 2, 0.3], [0.5, 0.3, 1]], dtype=float)\n    n0_6_unnorm = np.array([0.3, -0.7, 0.65], dtype=float)\n    n0_6 = normalize(n0_6_unnorm)\n    grad6 = compute_riemannian_gradient(sigma6, n0_6)\n    r6 = np.abs(np.dot(n0_6, grad6))\n    results.append(r6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2694371"}]}