{"hands_on_practices": [{"introduction": "Before tackling the full complexity of Loop Transfer Recovery (LTR) in a multi-state system, it is invaluable to master the fundamental mechanism at its core. This exercise isolates the direct relationship between the Kalman filter's noise parameters and its resulting loop shape for a simple integrator plant. By solving for the required noise ratio to meet a target loop specification, you will gain first-principles intuition on how designers use stochastic parameters for deterministic loop shaping.", "problem": "Consider the single-input single-output continuous-time plant with state-space realization\n$$\n\\dot{x}(t) = 0 \\cdot x(t) + u(t) + w(t), \\quad y(t) = 1 \\cdot x(t) + v(t),\n$$\nwhere $x(t) \\in \\mathbb{R}$, $u(t) \\in \\mathbb{R}$, and $y(t) \\in \\mathbb{R}$. The disturbance $w(t)$ and the measurement noise $v(t)$ are mutually independent, zero-mean, white Gaussian processes with constant spectral densities (covariances per unit time) $W_0  0$ and $V_0  0$, respectively. For the steady-state Kalman-Bucy filter (KBF), denote the steady-state error covariance by $P$ and the steady-state Kalman gain by $K_f$. The algebraic Riccati equation for $P$ is\n$$\n0 \\cdot P + P \\cdot 0 - P \\cdot 1 \\cdot V_0^{-1} \\cdot 1 \\cdot P + W_0 = 0,\n$$\nand the steady-state Kalman gain is\n$$\nK_f = P \\cdot 1 \\cdot V_0^{-1}.\n$$\nIn the context of Linear Quadratic Gaussian (LQG) loop transfer recovery (LTR) at the plant output, the Kalman filter loop is defined as\n$$\nL_f(s) = 1 \\cdot (s I - 0)^{-1} K_f = \\frac{K_f}{s}.\n$$\nSuppose that a rational target loop with relative degree one and $-20$ dB/decade roll-off is specified as\n$$\nL_d(s) = \\frac{\\omega_c}{s},\n$$\nwith desired crossover frequency $\\omega_c  0$, so that $|L_d(\\mathrm{j}\\,\\omega_c)| = 1$ and $\\arg L_d(\\mathrm{j}\\,\\omega_c) = -\\frac{\\pi}{2}$. Using only first principles (the algebraic Riccati equation and the definition of the Kalman-Bucy gain), choose $W_0$ and $V_0$ so that $L_f(s)$ matches $L_d(s)$ in both magnitude and phase at $\\omega = \\omega_c$. Derive a closed-form expression for the minimal design parameter\n$$\nr \\equiv \\frac{W_0}{V_0}\n$$\nthat achieves this matching. Express your final answer as a symbolic function of $\\omega_c$ (dimensionless). No numerical rounding is required and no physical units should be included in the final expression.", "solution": "The problem as stated is scientifically sound, self-contained, and well-posed within the framework of linear control theory. It constitutes a standard exercise in designing an observer for Loop Transfer Recovery (LTR). All provided definitions and equations are consistent with established theory. Therefore, we proceed to the solution.\n\nThe system is a single-input single-output (SISO) continuous-time plant described by the state-space equations:\n$$\n\\dot{x}(t) = A x(t) + B u(t) + G w(t)\n$$\n$$\ny(t) = C x(t) + v(t)\n$$\nFrom the problem statement, the system matrices are scalar and given by $A=0$, the process noise input matrix is $G=1$, and the output matrix is $C=1$. The state $x(t)$, input $u(t)$, and output $y(t)$ are all in $\\mathbb{R}$. The process noise $w(t)$ and measurement noise $v(t)$ are white Gaussian processes with spectral densities $W_0  0$ and $V_0  0$, respectively.\n\nThe objective is to find the ratio $r \\equiv \\frac{W_0}{V_0}$ that makes the Kalman filter loop transfer function, $L_f(s)$, match a desired target loop transfer function, $L_d(s)$, at a specific frequency $\\omega_c$.\n\nFirst, we solve the algebraic Riccati equation (ARE) for the steady-state error covariance $P$. For this scalar system, the ARE is given as:\n$$\nA P + P A^T - P C^T V_0^{-1} C P + G W_0 G^T = 0\n$$\nSubstituting the given scalar values $A=0$, $C=1$, and $G=1$:\n$$\n0 \\cdot P + P \\cdot 0 - P \\cdot 1 \\cdot V_0^{-1} \\cdot 1 \\cdot P + 1 \\cdot W_0 \\cdot 1 = 0\n$$\nThis simplifies to a scalar algebraic equation for $P$:\n$$\nW_0 - \\frac{P^2}{V_0} = 0\n$$\n$$\nP^2 = W_0 V_0\n$$\nSince the error covariance $P$ must be non-negative, we take the positive root:\n$$\nP = \\sqrt{W_0 V_0}\n$$\nNext, we determine the steady-state Kalman gain, $K_f$. The formula is:\n$$\nK_f = P C^T V_0^{-1}\n$$\nSubstituting $P = \\sqrt{W_0 V_0}$ and $C=1$:\n$$\nK_f = (\\sqrt{W_0 V_0}) \\cdot 1 \\cdot V_0^{-1} = \\frac{\\sqrt{W_0 V_0}}{V_0}\n$$\nThis can be simplified by bringing $V_0$ inside the square root:\n$$\nK_f = \\sqrt{\\frac{W_0 V_0}{V_0^2}} = \\sqrt{\\frac{W_0}{V_0}}\n$$\nUsing the definition of the design parameter $r \\equiv \\frac{W_0}{V_0}$, the Kalman gain is expressed as:\n$$\nK_f = \\sqrt{r}\n$$\nThe Kalman filter loop transfer function, broken at the plant output, is given by $L_f(s) = C(sI - A)^{-1} K_f$. For this scalar system, $I=1$.\n$$\nL_f(s) = 1 \\cdot (s \\cdot 1 - 0)^{-1} K_f = \\frac{K_f}{s}\n$$\nSubstituting the expression for $K_f$:\n$$\nL_f(s) = \\frac{\\sqrt{r}}{s}\n$$\nThe target loop is specified as $L_d(s) = \\frac{\\omega_c}{s}$. The problem requires matching $L_f(s)$ and $L_d(s)$ in magnitude and phase at the frequency $\\omega = \\omega_c$.\n\nLet us examine the frequency response of both loops by substituting $s = \\mathrm{j}\\omega$:\n$$\nL_f(\\mathrm{j}\\omega) = \\frac{\\sqrt{r}}{\\mathrm{j}\\omega}, \\quad L_d(\\mathrm{j}\\omega) = \\frac{\\omega_c}{\\mathrm{j}\\omega}\n$$\nThe phase of both functions is:\n$$\n\\arg(L_f(\\mathrm{j}\\omega)) = \\arg(L_d(\\mathrm{j}\\omega)) = \\arg\\left(\\frac{1}{\\mathrm{j}}\\right) = -\\frac{\\pi}{2}\n$$\nfor any $\\omega  0$. Therefore, the phase matching condition at $\\omega = \\omega_c$ is satisfied automatically due to the identical structure of the two transfer functions.\n\nThe remaining condition is to match the magnitudes at $\\omega = \\omega_c$:\n$$\n|L_f(\\mathrm{j}\\omega_c)| = |L_d(\\mathrm{j}\\omega_c)|\n$$\nWe evaluate the magnitudes of both sides:\n$$\n|L_f(\\mathrm{j}\\omega_c)| = \\left|\\frac{\\sqrt{r}}{\\mathrm{j}\\omega_c}\\right| = \\frac{\\sqrt{r}}{\\omega_c}\n$$\n$$\n|L_d(\\mathrm{j}\\omega_c)| = \\left|\\frac{\\omega_c}{\\mathrm{j}\\omega_c}\\right| = \\left|\\frac{1}{\\mathrm{j}}\\right| = 1\n$$\nEquating the two magnitudes yields the equation for $r$:\n$$\n\\frac{\\sqrt{r}}{\\omega_c} = 1\n$$\nSolving for $r$:\n$$\n\\sqrt{r} = \\omega_c\n$$\nSince $\\omega_c  0$, we can square both sides without ambiguity:\n$$\nr = \\omega_c^2\n$$\nThis is the closed-form expression for the design parameter $r$ that achieves the specified loop transfer recovery objective.", "answer": "$$\n\\boxed{\\omega_c^{2}}\n$$", "id": "2721063"}, {"introduction": "Building on the foundational concept of loop shaping, this practice transitions from simple analytics to a complete computational workflow for a more complex plant. You will implement a program to automate and quantify the LTR process for both the input and output loops, systematically observing how the loop transfer function converges to its target as the tuning parameter $\\rho$ is swept. This exercise develops practical skills in implementing LQG/LTR and introduces the use of the $\\mathcal{H}_{\\infty}$-norm as a formal metric to measure the recovery error.", "problem": "Design and implement a complete, runnable program that automates a Loop Transfer Recovery (LTR) sweep with respect to a scalar tuning parameter $\\rho$, and monitors recovery by approximating the $\\mathcal{H}_{\\infty}$-norm of the loop-transfer mismatch over a frequency grid. Your program must compute, for each specified $\\rho$, the grid-based approximation of either $\\| L_{y}(j\\omega) - L_{f}(j\\omega) \\|_{\\infty}$ (output LTR) or $\\| L_{u}(j\\omega) - L_{K}(j\\omega) \\|_{\\infty}$ (input LTR), and output the results aggregated across a test suite.\n\nThe problem context is as follows. Consider a continuous-time, single-input single-output, linear time-invariant plant given in state-space form:\n$$\n\\dot{x}(t) = A x(t) + B u(t), \\quad y(t) = C x(t) + D u(t),\n$$\nwith the following specific matrices:\n$$\nA = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ -1  -2  -3 \\end{bmatrix}, \\quad\nB = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}, \\quad\nC = \\begin{bmatrix} 1  0  0 \\end{bmatrix}, \\quad\nD = \\begin{bmatrix} 0 \\end{bmatrix}.\n$$\nYou will use the classical Linear Quadratic Gaussian (LQG) framework with Loop Transfer Recovery (LTR). Begin from the foundational definitions:\n\n- Linear Quadratic Regulator (LQR) state-feedback gain $F$ is obtained by solving the continuous-time Algebraic Riccati Equation (ARE) for the regulator cost with positive semidefinite state cost matrix $Q$ and positive definite control cost matrix $R$, and then\n$$\nF = R^{-1} B^{\\top} P,\n$$\nwhere $P$ solves\n$$\nA^{\\top} P + P A - P B R^{-1} B^{\\top} P + Q = 0.\n$$\n\n- The steady-state Kalman filter (minimum-variance estimator) gain $L$ is obtained by solving the estimator continuous-time Algebraic Riccati Equation\n$$\nA P_{e} + P_{e} A^{\\top} - P_{e} C^{\\top} V^{-1} C P_{e} + W = 0,\n$$\nand then\n$$\nL = P_{e} C^{\\top} V^{-1},\n$$\nwhere $W \\succeq 0$ and $V \\succ 0$ are the process and measurement noise covariances, respectively.\n\n- The observer-based controller (LQG) maps $y$ to $u$ with transfer matrix\n$$\nK(s) = -F \\left(s I - (A - B F - L C)\\right)^{-1} L.\n$$\n\n- The plant transfer matrix is\n$$\nG(s) = C (s I - A)^{-1} B + D.\n$$\n\nDefine the loop transfer at the plant input as\n$$\nL_{u}(s) = K(s) G(s),\n$$\nand define the full-information (state-feedback) input loop as\n$$\nL_{K}(s) = F (s I - A)^{-1} B.\n$$\n\nFor output LTR, define the estimator loop (at the plant output) for a fixed estimator gain $L_{0}$ as\n$$\nL_{f}(s) = C (s I - A)^{-1} L_{0},\n$$\nand form the LQG loop with a regulator gain $F_{\\rho}$ produced by scaling the LQR state cost.\n\nThe LTR ideas you must implement are:\n\n- Input LTR: Fix an LQR state-feedback $F$ using $Q = C^{\\top} C$ and $R = I$. For each $\\rho$, obtain an estimator gain $L_{\\rho}$ by solving the estimator ARE with $W = \\rho I$ and $V = I$. Form $K_{\\rho}(s)$ from $F$ and $L_{\\rho}$ and compute $L_{u,\\rho}(s) = K_{\\rho}(s) G(s)$. Monitor the recovery by approximating\n$$\n\\left\\| L_{u,\\rho}(j\\omega) - L_{K}(j\\omega) \\right\\|_{\\infty} \\approx \\max_{\\omega \\in \\Omega} \\sigma_{\\max}\\!\\left( L_{u,\\rho}(j\\omega) - L_{K}(j\\omega) \\right),\n$$\nusing a frequency grid $\\Omega$.\n\n- Output LTR: Fix an estimator gain $L_{0}$ by setting $W = I$ and $V = I$. For each $\\rho$, obtain an LQR gain $F_{\\rho}$ by solving the regulator ARE with $Q_{\\rho} = \\rho\\, C^{\\top} C$ and $R = I$. Form $K_{\\rho}(s)$ from $F_{\\rho}$ and $L_{0}$ and compute $L_{y,\\rho}(s) = G(s) K_{\\rho}(s)$. Monitor the recovery by approximating\n$$\n\\left\\| L_{y,\\rho}(j\\omega) - L_{f}(j\\omega) \\right\\|_{\\infty} \\approx \\max_{\\omega \\in \\Omega} \\sigma_{\\max}\\!\\left( L_{y,\\rho}(j\\omega) - L_{f}(j\\omega) \\right),\n$$\nusing the same frequency grid $\\Omega$.\n\nApproximate the $\\mathcal{H}_{\\infty}$-norm by sampling the frequency response on a logarithmic grid\n$$\n\\Omega = \\left\\{ \\omega_{k} \\right\\}_{k=1}^{N}, \\quad \\omega_{k} \\text{ in radians per second},\n$$\nand taking the maximum of the largest singular value over the grid. In this problem, the plant is single-input single-output, so this reduces to the maximum of the magnitude over the grid.\n\nYour program must implement the following fixed settings for numerical evaluation:\n\n- Frequency grid: logarithmically spaced from $\\omega_{\\min} = 10^{-2}$ radians per second to $\\omega_{\\max} = 10^{2}$ radians per second, with $N = 400$ points.\n\n- Test Suite:\n    1. Input LTR with $\\rho \\in \\{ 1.0, 10.0, 100.0, 1000.0 \\}$.\n    2. Output LTR with $\\rho \\in \\{ 1.0, 10.0, 100.0, 1000.0 \\}$.\n    3. Input LTR edge case with $\\rho \\in \\{ 0.1, 10000.0 \\}$.\n\nFor each test, compute the grid-based approximation of the corresponding $\\mathcal{H}_{\\infty}$-norm of the loop transfer mismatch for every $\\rho$ listed in that test. Aggregate all results, in the order listed above, into a single flat list of floating-point numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[a,b,c,...]\"). All numeric answers are unitless magnitudes derived from frequency response, and the frequency grid is in radians per second. No user input is allowed; all parameters are as specified above and must be hard-coded. The final output type must be a list of floats, ordered as:\n$$\n\\left[ \\text{InputLTR}(\\rho{=}1.0), \\text{InputLTR}(\\rho{=}10.0), \\text{InputLTR}(\\rho{=}100.0), \\text{InputLTR}(\\rho{=}1000.0), \\text{OutputLTR}(\\rho{=}1.0), \\text{OutputLTR}(\\rho{=}10.0), \\text{OutputLTR}(\\rho{=}100.0), \\text{OutputLTR}(\\rho{=}1000.0), \\text{InputLTR}(\\rho{=}0.1), \\text{InputLTR}(\\rho{=}10000.0) \\right].\n$$", "solution": "The problem as stated is valid. It presents a well-posed, standard exercise in modern control theory, specifically concerning the design and analysis of Linear-Quadratic-Gaussian controllers with Loop Transfer Recovery (LQG/LTR). The physical system is defined by a linear time-invariant (LTI) state-space model, and all parameters, objectives, and constraints are specified with sufficient mathematical precision. There are no scientific inaccuracies, contradictions, or ambiguities. We shall proceed with a complete solution.\n\nThe core task is to numerically demonstrate the Loop Transfer Recovery phenomenon for a given plant. The LTR procedure aims to recover the desirable robustness properties of a state-feedback design (either LQR or a Kalman filter loop) within an observer-based control framework (LQG). The plant is given by the state-space representation:\n$$\n\\dot{x}(t) = A x(t) + B u(t), \\quad y(t) = C x(t)\n$$\nwith matrices:\n$$\nA = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ -1  -2  -3 \\end{bmatrix}, \\quad\nB = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}, \\quad\nC = \\begin{bmatrix} 1  0  0 \\end{bmatrix}, \\quad\nD = \\begin{bmatrix} 0 \\end{bmatrix}.\n$$\nThis is a single-input, single-output (SISO) system of order $n=3$. For LTR to be effective, the plant must be minimum-phase, meaning all its transmission zeros must lie in the open left-half of the complex plane. The plant transfer function is $G(s) = C(sI - A)^{-1}B = \\frac{1}{s^3 + 3s^2 + 2s + 1}$. This system has no finite zeros, thus it is trivially minimum-phase, a necessary condition for successful LTR. The system is also both controllable and observable, ensuring that stabilizing solutions to the relevant Algebraic Riccati Equations (AREs) exist.\n\nWe will analyze two distinct LTR procedures: input LTR and output LTR.\n\n**1. Input Loop Transfer Recovery (Input LTR)**\n\nThe objective of input LTR is to make the loop transfer function at the plant input, $L_u(s) = K(s)G(s)$, converge to a target loop transfer function, $L_K(s)$, which is defined by a full-state feedback LQR design.\n\nFirst, we design the target loop. The LQR state-feedback gain $F$ is found by solving the controller ARE:\n$$\nA^{\\top} P + P A - P B R^{-1} B^{\\top} P + Q = 0\n$$\nwhere we set the weighting matrices to $Q = C^{\\top} C$ and $R=I$. This choice of $Q$ penalizes the output, which is a common practice. The gain is then $F = R^{-1} B^{\\top} P$. The target loop transfer function, representing the loop broken at the plant input under ideal state feedback, is:\n$$\nL_K(s) = F(sI - A)^{-1}B.\n$$\nThis defines our performance and robustness goal.\n\nNext, we design a family of LQG controllers. Since we cannot measure the full state $x$, we use a Kalman filter to generate an estimate $\\hat{x}$. The LQG controller combines this estimator with the LQR gain $F$. The Kalman filter gain $L_{\\rho}$ is found by solving the filter ARE:\n$$\nA P_{e} + P_{e} A^{\\top} - P_{e} C^{\\top} V^{-1} C P_{e} + W = 0,\n$$\nwith filter gain $L_{\\rho} = P_{e} C^{\\top} V^{-1}$. The LTR tuning parameter $\\rho$ is introduced by setting the process noise covariance $W = \\rho I$ and measurement noise covariance $V=I$. As $\\rho \\to \\infty$, the filter becomes \"faster\" and its state estimate $\\hat{x}$ converges more rapidly to the true state $x$.\n\nThe resulting LQG controller has the transfer function:\n$$\nK_{\\rho}(s) = -F (s I - (A - B F - L_{\\rho} C))^{-1} L_{\\rho}.\n$$\nThe actual loop transfer at the plant input is $L_{u,\\rho}(s) = K_{\\rho}(s)G(s)$. The theory of LTR states that for a minimum-phase plant, as $\\rho \\to \\infty$, $L_{u,\\rho}(s) \\to L_K(s)$. We quantify this convergence by computing the $\\mathcal{H}_{\\infty}$-norm of the mismatch, approximated over a discrete frequency grid $\\Omega$:\n$$\n\\left\\| L_{u,\\rho}(j\\omega) - L_{K}(j\\omega) \\right\\|_{\\infty} \\approx \\max_{\\omega_k \\in \\Omega} \\left| L_{u,\\rho}(j\\omega_k) - L_K(j\\omega_k) \\right|.\n$$\nThe absolute value is sufficient because the system is SISO, for which the maximum singular value $\\sigma_{\\max}$ of a scalar is its magnitude.\n\n**2. Output Loop Transfer Recovery (Output LTR)**\n\nThis is the dual procedure. The goal is to make the loop transfer function at the plant output, $L_y(s) = G(s)K(s)$, converge to a target loop transfer function, $L_f(s)$, which is defined by the loop of the Kalman filter itself.\n\nFirst, we design a fixed, nominal Kalman filter. The gain $L_0$ is obtained from the filter ARE with $W=I$ and $V=I$. The target loop, representing the loop broken at the plant output, is:\n$$\nL_f(s) = C(sI - A)^{-1}L_0.\n$$\n\nNext, we design a family of LQR gains $F_{\\rho}$ by solving the controller ARE with $R=I$ and a scaled state-weighting matrix $Q_{\\rho} = \\rho C^{\\top}C$. As $\\rho \\to \\infty$, the LQR becomes more \"aggressive\", moving its poles to cancel the plant's stable zeros and pushing the remaining poles to infinity.\n\nThe LQG controller is formed using the fixed filter gain $L_0$ and the varying LQR gain $F_{\\rho}$:\n$$\nK_{\\rho}(s) = -F_{\\rho} (s I - (A - B F_{\\rho} - L_0 C))^{-1} L_0.\n$$\nThe loop at the plant output is $L_{y,\\rho}(s) = G(s)K_{\\rho}(s)$. For a minimum-phase plant, as $\\rho \\to \\infty$, we have $L_{y,\\rho}(s) \\to L_f(s)$. The recovery error is measured by:\n$$\n\\left\\| L_{y,\\rho}(j\\omega) - L_{f}(j\\omega) \\right\\|_{\\infty} \\approx \\max_{\\omega_k \\in \\Omega} \\left| L_{y,\\rho}(j\\omega_k) - L_f(j\\omega_k) \\right|.\n$$\n\n**Numerical Implementation**\n\nThe program will execute these procedures for the specified test suite.\n- The frequency grid $\\Omega$ consists of $N=400$ logarithmically spaced points from $\\omega_{\\min} = 10^{-2}$ to $\\omega_{\\max} = 10^{2}$ radians per second.\n- The Algebraic Riccati Equations are solved using `scipy.linalg.solve_continuous_are`. The dual (filter) ARE is solved by providing transposed matrices to this function.\n- Frequency responses of all relevant transfer functions are computed by evaluating their state-space representations at $s=j\\omega_k$ for each $\\omega_k \\in \\Omega$.\n- The program will execute three tests: one for input LTR, one for output LTR, and a final one for input LTR with edge cases of $\\rho$. The resulting $10$ values for the mismatch norm will be collected and presented in the required format.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_continuous_are\nfrom scipy.signal import StateSpace\n\ndef evaluate_freq_response(ss_system, omega):\n    \"\"\"\n    Evaluates the frequency response of a state-space system.\n\n    Args:\n        ss_system: A tuple (A, B, C, D) representing the state-space system.\n        omega: A numpy array of frequencies (in rad/s).\n\n    Returns:\n        A numpy array of the complex frequency response H(j*omega).\n    \"\"\"\n    A, B, C, D = ss_system\n    # For SISO systems, signal.StateSpace is efficient.\n    # For MIMO, it would also work correctly.\n    sys = StateSpace(A, B, C, D)\n    _, h = sys.freqresp(w=omega)\n    return h\n\ndef perform_input_ltr_sweep(A, B, C, D, rho_values, omega):\n    \"\"\"\n    Performs an Input LTR sweep and computes the H-infinity norm of the mismatch.\n    \"\"\"\n    results = []\n    num_inputs = B.shape[1]\n    num_states = A.shape[0]\n\n    # 1. Design the fixed target LQR loop L_K(s) = F(sI - A)^-1 B\n    Q_lqr = C.T @ C\n    R_lqr = np.eye(num_inputs)\n    P_lqr = solve_continuous_are(A, B, Q_lqr, R_lqr)\n    F = np.linalg.inv(R_lqr) @ B.T @ P_lqr\n    \n    # Target loop transfer function L_K(s) has state-space (A, B, F, 0)\n    lk_sys = (A, B, F, np.zeros((F.shape[0], B.shape[1])))\n    lk_freq = evaluate_freq_response(lk_sys, omega)\n\n    # Plant transfer function G(s)\n    g_sys = (A, B, C, D)\n    g_freq = evaluate_freq_response(g_sys, omega)\n\n    for rho in rho_values:\n        # 2. Design the Kalman filter gain L_rho for the current rho\n        # We solve the dual ARE by passing transposes to the solver\n        # A_dual = A.T, B_dual = C.T, Q_dual = W, R_dual = V\n        W_kf = rho * np.eye(num_states)\n        V_kf = np.eye(C.shape[0])\n        Pe = solve_continuous_are(A.T, C.T, W_kf, V_kf)\n        L = Pe @ C.T @ np.linalg.inv(V_kf)\n\n        # 3. Form the LQG controller K_rho(s)\n        # K(s) = -F(sI - (A-BF-LC))^{-1}L\n        A_k = A - B @ F - L @ C\n        B_k = L\n        C_k = -F\n        D_k = np.zeros((C_k.shape[0], B_k.shape[1]))\n        k_rho_sys = (A_k, B_k, C_k, D_k)\n        k_rho_freq = evaluate_freq_response(k_rho_sys, omega)\n        \n        # 4. Compute the loop L_u(s) = K(s)G(s) and the mismatch\n        lu_rho_freq = k_rho_freq * g_freq  # SISO specific\n        mismatch_freq = lu_rho_freq - lk_freq\n        \n        # 5. Approximate H-infinity norm\n        h_inf_norm = np.max(np.abs(mismatch_freq))\n        results.append(h_inf_norm)\n        \n    return results\n\ndef perform_output_ltr_sweep(A, B, C, D, rho_values, omega):\n    \"\"\"\n    Performs an Output LTR sweep and computes the H-infinity norm of the mismatch.\n    \"\"\"\n    results = []\n    num_inputs = B.shape[1]\n    num_states = A.shape[0]\n\n    # 1. Design the fixed target filter loop L_f(s) = C(sI - A)^-1 L_0\n    W_kf = np.eye(num_states)\n    V_kf = np.eye(C.shape[0])\n    Pe = solve_continuous_are(A.T, C.T, W_kf, V_kf)\n    L0 = Pe @ C.T @ np.linalg.inv(V_kf)\n\n    # Target loop transfer function L_f(s) has state-space (A, L0, C, 0)\n    lf_sys = (A, L0, C, np.zeros((C.shape[0], L0.shape[1])))\n    lf_freq = evaluate_freq_response(lf_sys, omega)\n    \n    # Plant transfer function G(s)\n    g_sys = (A, B, C, D)\n    g_freq = evaluate_freq_response(g_sys, omega)\n\n    for rho in rho_values:\n        # 2. Design the LQR gain F_rho for the current rho\n        Q_lqr = rho * C.T @ C\n        R_lqr = np.eye(num_inputs)\n        P_lqr = solve_continuous_are(A, B, Q_lqr, R_lqr)\n        F_rho = np.linalg.inv(R_lqr) @ B.T @ P_lqr\n        \n        # 3. Form the LQG controller K_rho(s)\n        # K(s) = -F_rho(sI - (A-B*F_rho-L0*C))^{-1}L0\n        A_k = A - B @ F_rho - L0 @ C\n        B_k = L0\n        C_k = -F_rho\n        D_k = np.zeros((C_k.shape[0], B_k.shape[1]))\n        k_rho_sys = (A_k, B_k, C_k, D_k)\n        k_rho_freq = evaluate_freq_response(k_rho_sys, omega)\n        \n        # 4. Compute the loop L_y(s) = G(s)K(s) and the mismatch\n        ly_rho_freq = g_freq * k_rho_freq # SISO specific\n        mismatch_freq = ly_rho_freq - lf_freq\n        \n        # 5. Approximate H-infinity norm\n        h_inf_norm = np.max(np.abs(mismatch_freq))\n        results.append(h_inf_norm)\n        \n    return results\n\n\ndef solve():\n    # Plant state-space matrices\n    A = np.array([[0, 1, 0], [0, 0, 1], [-1, -2, -3]])\n    B = np.array([[0], [0], [1]])\n    C = np.array([[1, 0, 0]])\n    D = np.array([[0]])\n\n    # Numerical settings\n    omega_min = 1e-2\n    omega_max = 1e2\n    n_points = 400\n    omega = np.logspace(np.log10(omega_min), np.log10(omega_max), n_points)\n\n    # Test Suite\n    # Test 1: Input LTR\n    rho_input_1 = [1.0, 10.0, 100.0, 1000.0]\n    results_input_1 = perform_input_ltr_sweep(A, B, C, D, rho_input_1, omega)\n\n    # Test 2: Output LTR\n    rho_output = [1.0, 10.0, 100.0, 1000.0]\n    results_output = perform_output_ltr_sweep(A, B, C, D, rho_output, omega)\n\n    # Test 3: Input LTR (edge cases)\n    rho_input_2 = [0.1, 10000.0]\n    results_input_2 = perform_input_ltr_sweep(A, B, C, D, rho_input_2, omega)\n\n    # Aggregate results in the specified order\n    all_results = results_input_1 + results_output + results_input_2\n    \n    # Format the final output string\n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```", "id": "2721057"}, {"introduction": "Theoretical convergence is a powerful guide, but it is not the entire story in practical control engineering. This final exercise serves as a crucial cautionary tale, demonstrating the potential fragility of controllers designed via LTR. You will analyze a scenario where the high-gain feedback, resulting from an aggressive recovery attempt, interacts with unmodeled high-frequency dynamics, leading to a dangerous peak in the closed-loop response. This practice underscores the critical importance of robustness analysis and highlights the trade-offs between nominal performance and stability in the face of model uncertainty.", "problem": "Consider a single-input single-output plant used in an output loop transfer recovery (LTR) design within a linear quadratic Gaussian (LQG) framework. The nominal plant model is \n$$\nP_{\\mathrm{nom}}(s) \\;=\\; \\frac{1}{s(s+1)},\n$$\nbut the true plant has an unmodeled high-frequency pole at frequency $\\omega_{h}$, so that\n$$\nP_{\\mathrm{true}}(s) \\;=\\; \\frac{1}{s(s+1)\\left(1+\\frac{s}{\\omega_{h}}\\right)} \\;=\\; \\frac{1}{s(s+1)} \\cdot \\frac{1}{1+\\frac{s}{\\omega_{h}}}.\n$$\nIn an LTR design, it is assumed that the controller is tuned by a parameter $\\rho$, such that the recovered nominal loop behaves like a first-order integrator with a crossover frequency that scales inversely with the square root of $\\rho$:\n$$\nL_{\\mathrm{nom}}(s;\\rho) \\;\\approx\\; \\frac{\\omega_{c}(\\rho)}{s}, \n\\quad \\text{with} \\quad \\omega_{c}(\\rho) \\;=\\; \\frac{k}{\\sqrt{\\rho}},\n$$\nfor some constant $k0$. Assume the effective controller $K_{\\mathrm{eff}}(s;\\rho)$ to achieve this shaping for the nominal loop $L_{\\mathrm{nom}}(s;\\rho) = K_{\\mathrm{eff}}(s;\\rho)\\,P_{\\mathrm{nom}}(s)$ is:\n$$\nK_{\\mathrm{eff}}(s;\\rho) \\;=\\; \\omega_{c}(\\rho)\\,(s+1).\n$$\nConsequently, when applied to the true plant (which contains the unmodeled high-frequency pole at $\\omega_{h}$), the actual loop transfer becomes\n$$\nL_{\\mathrm{true}}(s;\\rho) \\;=\\; K_{\\mathrm{eff}}(s;\\rho)\\,P_{\\mathrm{true}}(s) \\;=\\; \\frac{\\omega_{c}(\\rho)}{s}\\cdot \\frac{1}{1+\\frac{s}{\\omega_{h}}}\n\\;=\\; \\frac{\\omega_{c}(\\rho)\\,\\omega_{h}}{s\\,(s+\\omega_{h})}.\n$$\nLet the complementary sensitivity function be defined by\n$$\nT_{\\mathrm{true}}(s;\\rho) \\;=\\; \\frac{L_{\\mathrm{true}}(s;\\rho)}{1 + L_{\\mathrm{true}}(s;\\rho)}.\n$$\nA designer starts from a benign nominal operating point with $\\rho=1$ and $k=100$, and then naively reduces $\\rho$ while keeping the nominal shaping paradigm unchanged, in an attempt to “improve” loop transfer recovery. Suppose the true plant’s unmodeled pole is at $\\omega_{h}=1000$ rad/s, and the designer reduces the tuning parameter to $\\rho = 0.0025$.\n\nUsing only fundamental definitions and well-tested facts, derive $T_{\\mathrm{true}}(s;\\rho)$ for the true plant, compute its frequency response magnitude, and determine the exact peak magnitude of $\\left|T_{\\mathrm{true}}(\\mathrm{j}\\omega;\\rho)\\right|$ for $\\rho = 0.0025$ with the given parameters. Your answer must be a single unitless number corresponding to the peak magnitude rounded to four significant figures.", "solution": "The problem will first be validated for scientific soundness, self-consistency, and well-posedness.\n\nStep 1: Extract Givens.\nThe explicit givens are:\n- Nominal plant model: $P_{\\mathrm{nom}}(s) = \\frac{1}{s(s+1)}$\n- True plant model: $P_{\\mathrm{true}}(s) = \\frac{1}{s(s+1)\\left(1+\\frac{s}{\\omega_{h}}\\right)}$\n- Nominal loop transfer approximation: $L_{\\mathrm{nom}}(s;\\rho) \\approx \\frac{\\omega_{c}(\\rho)}{s}$\n- Crossover frequency scaling: $\\omega_{c}(\\rho) = \\frac{k}{\\sqrt{\\rho}}$\n- Effective controller for LTR shaping: $K_{\\mathrm{eff}}(s;\\rho) = \\omega_{c}(\\rho)\\,(s+1)$\n- True loop transfer function: $L_{\\mathrm{true}}(s;\\rho) = \\frac{\\omega_{c}(\\rho)\\,\\omega_{h}}{s\\,(s+\\omega_{h})}$\n- Complementary sensitivity function definition: $T_{\\mathrm{true}}(s;\\rho) = \\frac{L_{\\mathrm{true}}(s;\\rho)}{1 + L_{\\mathrm{true}}(s;\\rho)}$\n- Constant $k$: $k=100$\n- Unmodeled pole frequency: $\\omega_{h}=1000$ rad/s\n- Tuning parameter: $\\rho = 0.0025$\n- Task: Determine the peak magnitude of $\\left|T_{\\mathrm{true}}(\\mathrm{j}\\omega;\\rho)\\right|$ for the given parameters, rounded to four significant figures.\n\nStep 2: Validate Using Extracted Givens.\nThe problem statement describes a standard scenario in robust control theory, specifically the fragility of Loop Transfer Recovery (LTR) when controllers become too aggressive and interact with unmodeled high-frequency dynamics. The transfer functions, definitions, and relationships are all standard in the field of linear control systems. The values provided are numerically consistent and do not violate any physical or mathematical principles. The problem is well-posed, asking for a specific, calculable quantity (the peak magnitude of a frequency response) for a well-defined system. All necessary data is provided. The problem is scientifically grounded, objective, and complete.\n\nStep 3: Verdict and Action.\nThe problem is deemed valid. A solution will be derived.\n\nThe objective is to compute the peak magnitude of the frequency response of the true complementary sensitivity function, $M_p = \\max_{\\omega} |T_{\\mathrm{true}}(\\mathrm{j}\\omega;\\rho)|$, for the specified parameters.\n\nFirst, we calculate the crossover frequency $\\omega_{c}(\\rho)$ using the provided values $k=100$ and $\\rho=0.0025$.\n$$\n\\omega_{c}(\\rho) = \\frac{k}{\\sqrt{\\rho}} = \\frac{100}{\\sqrt{0.0025}} = \\frac{100}{0.05} = 2000 \\text{ rad/s}\n$$\nNext, we formulate the true complementary sensitivity function, $T_{\\mathrm{true}}(s;\\rho)$. The true loop transfer function $L_{\\mathrm{true}}(s;\\rho)$ is given as:\n$$\nL_{\\mathrm{true}}(s;\\rho) = \\frac{\\omega_{c}(\\rho)\\,\\omega_{h}}{s\\,(s+\\omega_{h})}\n$$\nSubstituting the values $\\omega_c = 2000$ and $\\omega_h = 1000$:\n$$\nL_{\\mathrm{true}}(s) = \\frac{2000 \\cdot 1000}{s(s+1000)} = \\frac{2 \\times 10^{6}}{s^{2} + 1000s}\n$$\nThe complementary sensitivity function is defined as $T_{\\mathrm{true}}(s) = \\frac{L_{\\mathrm{true}}(s)}{1 + L_{\\mathrm{true}}(s)}$. Substituting the expression for $L_{\\mathrm{true}}(s)$:\n$$\nT_{\\mathrm{true}}(s) = \\frac{\\frac{\\omega_{c}\\omega_{h}}{s(s+\\omega_{h})}}{1 + \\frac{\\omega_{c}\\omega_{h}}{s(s+\\omega_{h})}} = \\frac{\\omega_{c}\\omega_{h}}{s(s+\\omega_{h}) + \\omega_{c}\\omega_{h}} = \\frac{\\omega_{c}\\omega_{h}}{s^2 + \\omega_{h}s + \\omega_{c}\\omega_{h}}\n$$\nThis is a standard second-order low-pass system of the form:\n$$\nT(s) = \\frac{\\omega_{n}^2}{s^2 + 2\\zeta\\omega_{n}s + \\omega_{n}^2}\n$$\nBy comparing the coefficients of $T_{\\mathrm{true}}(s)$ with the standard form, we identify the natural frequency $\\omega_n$ and the damping ratio $\\zeta$.\nThe squared natural frequency is:\n$$\n\\omega_{n}^2 = \\omega_{c}\\omega_{h} = (2000)(1000) = 2 \\times 10^{6} \\; (\\text{rad/s})^2\n$$\nThus, the natural frequency is:\n$$\n\\omega_n = \\sqrt{2 \\times 10^{6}} = 1000\\sqrt{2} \\text{ rad/s}\n$$\nThe term with the damping ratio is:\n$$\n2\\zeta\\omega_{n} = \\omega_{h}\n$$\nSolving for $\\zeta$:\n$$\n\\zeta = \\frac{\\omega_{h}}{2\\omega_{n}} = \\frac{1000}{2(1000\\sqrt{2})} = \\frac{1}{2\\sqrt{2}}\n$$\nThe peak magnitude, $M_p$, of the frequency response for a second-order system is a well-tested fact, given by the formula:\n$$\nM_p = \\frac{1}{2\\zeta\\sqrt{1-\\zeta^2}}\n$$\nThis formula is valid for $0  \\zeta  \\frac{1}{\\sqrt{2}}$. We check if our value of $\\zeta$ falls in this range.\n$$\n\\zeta = \\frac{1}{2\\sqrt{2}} \\approx 0.3536\n$$\nThe upper limit is $\\frac{1}{\\sqrt{2}} \\approx 0.7071$. Since $0  0.3536  0.7071$, the condition is satisfied, and a resonant peak exists.\n\nWe now compute $M_p$ using the exact value of $\\zeta$. First, we compute $\\zeta^2$:\n$$\n\\zeta^2 = \\left(\\frac{1}{2\\sqrt{2}}\\right)^2 = \\frac{1}{8}\n$$\nNow substitute this into the formula for $M_p$:\n$$\nM_p = \\frac{1}{2\\left(\\frac{1}{2\\sqrt{2}}\\right)\\sqrt{1 - \\frac{1}{8}}} = \\frac{1}{\\frac{1}{\\sqrt{2}}\\sqrt{\\frac{7}{8}}} = \\frac{1}{\\frac{1}{\\sqrt{2}}\\frac{\\sqrt{7}}{\\sqrt{8}}} = \\frac{1}{\\frac{\\sqrt{7}}{\\sqrt{16}}} = \\frac{1}{\\frac{\\sqrt{7}}{4}} = \\frac{4}{\\sqrt{7}}\n$$\nTo provide the numerical answer, we compute the value of this expression and round to four significant figures as required.\n$$\nM_p = \\frac{4}{\\sqrt{7}} \\approx \\frac{4}{2.6457513...} \\approx 1.51185789...\n$$\nRounding to four significant figures gives:\n$$\nM_p \\approx 1.512\n$$\nThis result demonstrates the danger of naive LTR; the aggressive recovery attempt (low $\\rho$) leads to a significant peak in the closed-loop frequency response, indicating poor robustness and a tendency toward oscillatory behavior or instability due to unmodeled dynamics.", "answer": "$$\n\\boxed{1.512}\n$$", "id": "2721122"}]}