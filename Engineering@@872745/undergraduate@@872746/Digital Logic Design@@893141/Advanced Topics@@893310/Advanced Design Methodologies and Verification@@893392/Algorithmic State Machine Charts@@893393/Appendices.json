{"hands_on_practices": [{"introduction": "Algorithmic State Machine (ASM) charts are an essential tool for translating a behavioral description into a formal sequential logic design. This first practice problem asks you to design a controller for a common household device, using a Moore-type state machine where outputs are dependent only on the current state [@problem_id:1908113]. You will explore how to manage inputs and timed events, including the key technique of using a dedicated state to generate a precise single-cycle pulse output. This exercise solidifies your ability to convert a set of operational rules into a robust and correct state diagram.", "problem": "You are tasked with designing a digital controller for an automated bathroom ventilation system using a Moore-type Algorithmic State Machine (ASM). The system controls a light and a fan based on a single wall switch and an external timer.\n\n**System Components and Signals:**\n\n*   **Inputs:**\n    *   `S`: A single-bit input from the wall switch. `S=1` when the switch is ON, and `S=0` when it is OFF.\n    *   `T`: A single-bit input from a timer module. The timer asserts `T=1` for one clock cycle when its countdown is complete. Otherwise, `T=0`.\n\n*   **Outputs:**\n    *   `L`: A single-bit output to control the light. `L=1` turns the light ON, `L=0` turns it OFF.\n    *   `F`: A single-bit output to control the fan. `F=1` turns the fan ON, `F=0` turns it OFF.\n    *   `Start_Timer`: A single-bit output that, when asserted (`Start_Timer=1`), instructs the external timer module to begin its countdown. This signal should be a single-cycle pulse.\n\n**Required Behavior:**\n\n1.  Initially, both the light and the fan are off.\n2.  When the user turns the switch ON (`S=1`), both the light and the fan turn on immediately. They remain on as long as the switch is ON.\n3.  When the user turns the switch OFF (`S=0`), the light turns off immediately. The fan, however, remains on.\n4.  Simultaneously with the switch being turned OFF, the controller must send a single-cycle start signal to the timer module.\n5.  The fan will continue to run until the timer completes its cycle (indicated by `T=1`), at which point the fan turns off.\n6.  If the user turns the switch back ON (`S=1`) while the fan is in this post-light \"overrun\" period (i.e., before the timer has completed), the system should immediately return to the state where both the light and fan are on, effectively cancelling the timer countdown.\n\nWhich of the following descriptions accurately represents a Moore-type ASM for this controller?\n\nA. The ASM has four states: `IDLE`, `ACTIVE`, `START_DELAY`, and `FAN_OVERRUN`.\n    - `IDLE`: Outputs are `L=0`, `F=0`, `Start_Timer=0`. If `S=1`, transitions to `ACTIVE`.\n    - `ACTIVE`: Outputs are `L=1`, `F=1`, `Start_Timer=0`. If `S=0`, transitions to `START_DELAY`.\n    - `START_DELAY`: Outputs are `L=0`, `F=1`, `Start_Timer=1`. Unconditionally transitions to `FAN_OVERRUN`.\n    - `FAN_OVERRUN`: Outputs are `L=0`, `F=1`, `Start_Timer=0`. If `S=1`, transitions to `ACTIVE`. If `S=0` and `T=1`, transitions to `IDLE`.\n\nB. The ASM has three states: `OFF`, `ON`, and `OVERRUN`.\n    - `OFF`: Outputs are `L=0`, `F=0`, `Start_Timer=0`. If `S=1`, transitions to `ON`.\n    - `ON`: Outputs are `L=1`, `F=1`, `Start_Timer=0`. If `S=0`, transitions to `OVERRUN`.\n    - `OVERRUN`: Outputs are `L=0`, `F=1`, `Start_Timer=1`. If `S=1`, transitions to `ON`. If `S=0` and `T=1`, transitions to `OFF`.\n\nC. The ASM has four states: `IDLE`, `ACTIVE`, `START_DELAY`, and `FAN_OVERRUN`.\n    - `IDLE`: Outputs are `L=0`, `F=0`, `Start_Timer=0`. If `S=1`, transitions to `ACTIVE`.\n    - `ACTIVE`: Outputs are `L=1`, `F=1`, `Start_Timer=0`. If `S=0`, transitions to `START_DELAY`.\n    - `START_DELAY`: Outputs are `L=0`, `F=1`, `Start_Timer=1`. Unconditionally transitions to `FAN_OVERRUN`.\n    - `FAN_OVERRUN`: Outputs are `L=0`, `F=1`, `Start_Timer=0`. If `T=1`, transitions to `IDLE`.\n\nD. The ASM has three states: `IDLE`, `ACTIVE`, and `FAN_WAIT`.\n    - `IDLE`: Outputs are `L=0`, `F=0`. If `S=1`, transitions to `ACTIVE`.\n    - `ACTIVE`: Outputs are `L=1`, `F=1`. Upon transition where `S` becomes 0, it outputs `Start_Timer=1` and enters `FAN_WAIT`.\n    - `FAN_WAIT`: Outputs are `L=0`, `F=1`. If `S=1`, transitions to `ACTIVE`. If `T=1`, transitions to `IDLE`.", "solution": "We model the controller as a Moore-type ASM, where by definition outputs depend only on the current state. The required behaviors imply the following constraints on the ASM structure:\n1) Initially both light and fan are off, so there must be an initial state with outputs $L=0$ and $F=0$.\n2) When $S=1$, both $L$ and $F$ must be $1$ as long as $S=1$, so there must be a state with $L=1$ and $F=1$ and a transition from the initial state to this state when $S=1$.\n3) When $S$ changes to $0$, the light must turn off immediately and the fan remain on. In a Moore machine, this means the next state must have outputs $L=0$ and $F=1$.\n4) Simultaneously when $S$ goes to $0$, a single-cycle $Start\\_Timer$ pulse must be produced. In a Moore ASM, a standard way to produce a one-clock pulse is to enter a dedicated transient state whose outputs include $Start\\_Timer=1$, then unconditionally transition on the next clock to the steady overrun state where $Start\\_Timer=0$. Therefore, we need a state with outputs $(L, F, \\text{Start\\_Timer}) = (0, 1, 1)$ that unconditionally transitions to a state with $(0, 1, 0)$.\n5) The fan runs until the timer asserts $T=1$, at which point the fan turns off, so from the overrun state $(L, F)=(0, 1)$ we must transition to the idle $(0, 0)$ state when $T=1$ and $S=0$.\n6) If the user turns $S$ back to $1$ during overrun (i.e., before $T=1$), the system must immediately return to the state with $(L, F)=(1, 1)$, cancelling the timer. In a Moore ASM, this means from any overrun-related state we must prioritize a transition to the $(1, 1)$ state when $S=1$.\n\nNow evaluate the options against these Moore constraints:\n- Option A provides four states: `IDLE` with $(L,F,\\text{Start\\_Timer})=(0,0,0)$; `ACTIVE` with $(1,1,0)$; `START_DELAY` with $(0,1,1)$; and `FAN_OVERRUN` with $(0,1,0)$. The transition from `ACTIVE` on $S=0$ goes to `START_DELAY`, which asserts `Start_Timer=1` for exactly one cycle because of the unconditional transition to `FAN_OVERRUN` on the next clock. In `FAN_OVERRUN`, if $S=1$ the transition goes back to `ACTIVE` (cancelling the timer immediately), and if $S=0$ and $T=1$ the transition goes to `IDLE` (fan turns off). All outputs are state-based, so this is a valid Moore ASM and it satisfies the single-cycle `Start_Timer` requirement and all behaviors 1–6.\n- Option B sets `Start_Timer=1` throughout the `OVERRUN` state, which lasts multiple cycles until $T=1$, violating the single-cycle pulse requirement. Hence it is incorrect.\n- Option C lacks the transition from the overrun state to the active state when $S=1$, violating the requirement to immediately return to both on and cancel the timer during overrun. Thus it is incorrect.\n- Option D asserts `Start_Timer` “upon transition where $S$ becomes 0,” which makes `Start_Timer` transition-dependent rather than purely state-dependent. This is not a Moore specification. Therefore it is not a valid Moore-type ASM.\n\nOnly Option A satisfies the Moore-type requirement and all specified behaviors, including generating a single-cycle `Start_Timer` pulse via a dedicated transient state and correctly handling cancellation on $S=1$ during overrun.", "answer": "$$\\boxed{A}$$", "id": "1908113"}, {"introduction": "After designing an ASM chart, the next step is implementation. This practice problem bridges the gap between the abstract diagram and a physical circuit by tackling the real-world issue of switch debouncing [@problem_id:1957151]. You will translate the logic of a debouncer's state machine, defined by its states and transitions, into the specific Boolean expressions for the flip-flop inputs that determine the next state. This exercise provides crucial hands-on experience in hardware realization, turning a high-level algorithmic description into the concrete logic that drives a sequential circuit.", "problem": "In digital logic design, interfacing with mechanical components like push-buttons presents a challenge known as contact bounce. When a mechanical switch is pressed or released, its metal contacts physically bounce, creating a series of rapid, spurious electrical pulses instead of a single, clean transition. A common solution is to use a debouncing circuit implemented as a Finite State Machine (FSM).\n\nYou are tasked with designing the combinational logic for such an FSM. The FSM has two inputs and two outputs:\n- **Inputs:**\n  - `S`: The raw signal from the switch. `S=1` when pressed, `S=0` when released. This signal is \"bouncy.\"\n  - `T`: A signal from an external timer. `T=1` indicates that a pre-defined stabilization period has elapsed. `T=0` otherwise.\n- **Outputs:**\n  - `Z`: The debounced, clean output signal. It should be a single pulse, active high for exactly one clock cycle, after a valid button press is confirmed.\n  - `E`: An enable signal for the external timer. `E=1` starts or runs the timer.\n\nThe FSM follows this behavior, captured by an Algorithmic State Machine (ASM) chart:\n1.  Start in an `IDLE` state (`S0`), waiting for the switch to be pressed (`S=1`). In this state, `Z=0` and `E=0`.\n2.  Upon detecting `S=1`, transition to a `WAIT` state (`S1`). In this state, enable the timer by setting `E=1`. Keep `Z=0`.\n3.  Stay in the `WAIT` state until the timer is done (`T=1`).\n4.  Once `T=1`, check the switch input `S` again.\n    - If `S=1` (the press is stable), transition to a `PULSE` state (`S2`).\n    - If `S=0` (it was a bounce/noise), transition back to the `IDLE` state.\n5.  In the `PULSE` state, assert the clean output `Z=1` for one clock cycle. The timer should be disabled (`E=0`).\n6.  After the single pulse cycle, transition to a `HELD` state (`S3`), where the machine waits for the user to release the switch (`S=0`). In this state, `Z=0` and `E=0`.\n7.  Once `S=0` in the `HELD` state, transition back to the `IDLE` state to await the next press.\n\nThe FSM is to be implemented using two D-type flip-flops, with state variables `Q1` and `Q0`. The state assignment is as follows:\n- `S0` (IDLE): `Q1Q0 = 00`\n- `S1` (WAIT): `Q1Q0 = 01`\n- `S2` (PULSE): `Q1Q0 = 10`\n- `S3` (HELD): `Q1Q0 = 11`\n\nYour task is to determine the correct set of simplified, sum-of-products Boolean expressions for the flip-flop inputs, `D1` and `D0`, and for the debounced output, `Z`. In the expressions below, `·` denotes logical AND, `+` denotes logical OR, and a prime `'` denotes logical NOT.\n\nWhich of the following options provides the correct set of equations?\n\nA.\n*   $D1 = Q1 \\cdot Q0' + Q1 \\cdot Q0 \\cdot S + Q0 \\cdot S \\cdot T$\n*   $D0 = Q1 \\cdot Q0' + Q1' \\cdot Q0 \\cdot T' + Q1' \\cdot Q0' \\cdot S + Q1 \\cdot Q0 \\cdot S$\n*   $Z = Q1 \\cdot Q0'$\n\nB.\n*   $D1 = Q1 + S \\cdot T$\n*   $D0 = Q1 \\cdot Q0' + Q1' \\cdot Q0 \\cdot T' + Q0' \\cdot S$\n*   $Z = Q1 \\cdot Q0'$\n\nC.\n*   $D1 = Q1 \\cdot Q0' + Q1 \\cdot Q0 \\cdot S + Q0 \\cdot S \\cdot T$\n*   $D0 = Q1 \\cdot Q0' + Q1' \\cdot Q0 \\cdot T' + Q1' \\cdot Q0' \\cdot S + Q1 \\cdot Q0 \\cdot S$\n*   $Z = Q1$\n\nD.\n*   $D1 = Q1 \\cdot Q0' + Q0 \\cdot T$\n*   $D0 = Q1' \\cdot S + Q1 \\cdot Q0' + Q1' \\cdot Q0$\n*   $Z = Q1 \\cdot Q0'$\n\nE.\n*   $D1 = Q1 \\cdot Q0' + Q1' \\cdot Q0 \\cdot S \\cdot T$\n*   $D0 = Q1' \\cdot Q0' \\cdot S + Q1 \\cdot Q0'$\n*   $Z = Q1 \\cdot Q0'$", "solution": "We denote the present-state bits by $Q_1$ and $Q_0$, and the next-state bits (the D inputs) by $D_1 = Q_1^+$ and $D_0 = Q_0^+$. The inputs are $S$ (switch) and $T$ (timer done). States are encoded as:\n- $S_0$ (IDLE): $Q_1Q_0 = 00$\n- $S_1$ (WAIT): $Q_1Q_0 = 01$\n- $S_2$ (PULSE): $Q_1Q_0 = 10$\n- $S_3$ (HELD): $Q_1Q_0 = 11$\n\nFrom the ASM description, the transition behavior is:\n- From $00$ (IDLE): if $S=0$ then stay $00$; if $S=1$ then go to $01$.\n- From $01$ (WAIT): if $T=0$ then stay $01$; if $T=1$ then if $S=1$ go to $10$, else ($S=0$) go to $00$.\n- From $10$ (PULSE): unconditionally go to $11$ on the next clock.\n- From $11$ (HELD): if $S=1$ then stay $11$; if $S=0$ then go to $00$.\n\nWe now derive $D_1$ and $D_0$ as sum-of-products.\n\nFirst, $D_1=1$ exactly when the next state has $Q_1^+=1$. Enumerating the cases:\n- From state $01$ ($Q_1'Q_0$) with inputs $S=1$ and $T=1$: the next state is $10$, so $Q_1^+=1$. This yields the term $Q_1'Q_0ST$.\n- From state $10$ ($Q_1Q_0'$): the next state is $11$ regardless of inputs, so $Q_1^+=1$. This yields the term $Q_1Q_0'$.\n- From state $11$ ($Q_1Q_0$) with input $S=1$: the next state is $11$, so $Q_1^+=1$. This yields the term $Q_1Q_0S$.\nThe full expression for $D_1$ is $D_1 = Q_1'Q_0ST + Q_1Q_0' + Q_1Q_0S$. The expression in Option A, $D_1 = Q_1Q_0' + Q_1Q_0S + Q_0ST$, is logically equivalent as $Q_0ST = Q_1'Q_0ST + Q_1Q_0ST$, and the $Q_1Q_0ST$ term is covered by the existing $Q_1Q_0S$ term.\n$$\nD_1 = Q_1 Q_0' + Q_1 Q_0 S + Q_0 S T\n$$\n\nNext, $D_0=1$ exactly when the next state has $Q_0^+=1$. Enumerating the cases:\n- From state $00$ ($Q_1'Q_0'$) with input $S=1$: the next state is $01$, so $Q_0^+=1$. This yields $Q_1'Q_0'S$.\n- From state $01$ ($Q_1'Q_0$) with input $T=0$: the next state is $01$, so $Q_0^+=1$. This yields $Q_1'Q_0T'$.\n- From state $10$ ($Q_1Q_0'$): the next state is $11$ regardless of inputs, so $Q_0^+=1$. This yields $Q_1Q_0'$.\n- From state $11$ ($Q_1Q_0$) with input $S=1$: the next state is $11$, so $Q_0^+=1$. This yields $Q_1Q_0S$.\nTherefore,\n$$\nD_0 = Q_1 Q_0' + Q_1' Q_0 T' + Q_1' Q_0' S + Q_1 Q_0 S\n$$\n\nFinally, the debounced output $Z$ must be asserted only in the PULSE state $S_2$ ($Q_1Q_0=10$), thus\n$$\nZ = Q_1 Q_0'\n$$\n\nComparing with the options, these expressions match option A exactly.", "answer": "$$\\boxed{A}$$", "id": "1957151"}, {"introduction": "ASM charts excel at orchestrating complex, multi-cycle algorithms that operate on a separate datapath. This advanced exercise challenges you to design a controller for the non-restoring division algorithm, a fundamental operation in computer arithmetic [@problem_id:1908116]. The task involves sequencing control signals to manage data flow between an accumulator $A$, a quotient register $Q$, and an ALU, based on status signals like the sign bit $A_{\\text{sign}}$. This practice demonstrates how ASM charts function as the \"brain\" for sophisticated digital systems, a vital skill for designing processors and custom hardware accelerators.", "problem": "You are tasked with designing a controller for a dedicated hardware unit that performs division of two N-bit unsigned integers, a dividend and a divisor, using the multi-cycle non-restoring division algorithm.\n\n**Datapath and Control Signals:**\nThe datapath controlled by your Algorithmic State Machine (ASM) includes an (N+1)-bit register `A` (accumulator, initialized to zero), an N-bit shift register `Q` (for the dividend/quotient), an N-bit register `M` (for the divisor), and an N-bit down-counter `n`. The controller receives the following status inputs:\n- `start`: A single-cycle signal that initiates the division process.\n- `n_zero`: A signal that is high when the counter `n` is zero.\n- `A_sign`: The most significant bit (MSB) of register `A`, indicating its sign (0 for positive, 1 for negative).\n\nThe controller must generate the following control signals:\n- `Init_Cycle`: A signal to perform the initialization tasks in a single cycle.\n- `n_dec`: Decrements the counter `n` by one.\n- `AQ_shift_left`: Performs a 1-bit logical left shift on the concatenated register `{A, Q}`.\n- `A_load_from_ALU`: Loads register `A` with the output of the datapath's Arithmetic Logic Unit (ALU).\n- `ALU_op_is_add`: A signal for the ALU. If high, the ALU computes `A + M`; if low, it computes `A - M`.\n- `Q0_write_enable`: Enables the least significant bit of `Q`, `Q[0]`, to be updated. The datapath is hardwired to write the value `NOT(ALU_output_sign)` into `Q[0]` when this signal is active.\n- `A_load_correction`: A signal that loads register `A` with the result of `A + M` for the final correction step.\n- `Done`: A signal that is asserted upon completion of the algorithm.\n\n**Algorithm Specification:**\nThe controller must implement the following multi-cycle algorithm:\n1.  **Idle Phase:** The controller waits in an `IDLE` state until the `start` signal is asserted.\n2.  **Initialization Cycle:** Upon receiving `start`, the controller transitions to an `INIT` state for one cycle, asserting the `Init_Cycle` signal. This signal causes the datapath to load `A` with 0, `Q` with the dividend, `M` with the divisor, and the counter `n` with `N`.\n3.  **Iteration Loop (2 cycles per bit):** The controller then enters a loop that repeats `N` times. Each iteration consists of two sequential cycles (two states):\n    a. **Shift Cycle:** The `{A, Q}` register is shifted left by one bit, and the counter `n` is decremented.\n    b. **ALU Cycle:** Based on the sign of `A` after the shift (`A_sign`), an ALU operation is performed and the result is stored back in `A`. Specifically, if `A_sign` is 0, the operation is `A - M`. If `A_sign` is 1, the operation is `A + M`. Concurrently, the new quotient bit is written to `Q[0]`.\n4.  **Correction Cycle:** After `N` iterations (detected when `n_zero` is high), the controller checks the sign of the final remainder in `A`. If `A` is negative (`A_sign = 1`), a single-cycle correction step is performed where `A` is updated with `A + M`. If `A` is non-negative, this cycle is skipped.\n5.  **Done Phase:** The controller asserts the `Done` signal for one cycle and returns to the `IDLE` state.\n\n**Question:**\nFor a minimal ASM controller designed according to these specifications, identify the complete set of control signals that are asserted as **Moore outputs** in the state corresponding to the **ALU Cycle** (Step 3b) of the algorithm. A Moore output is a control signal that is asserted based solely on being in a particular state and is independent of the status inputs (`start`, `n_zero`, `A_sign`) evaluated during that cycle.\n\nA. `{AQ_shift_left, n_dec}`\nB. `{A_load_from_ALU, Q0_write_enable}`\nC. `{n_dec, A_load_from_ALU}`\nD. `{A_load_from_ALU, Q0_write_enable, ALU_op_is_add}`\nE. `{A_load_correction}`", "solution": "We must identify which control signals are asserted in the ALU Cycle state (Step 3b) purely because the controller is in that state, i.e., Moore outputs, independent of the current values of the status inputs.\n\nAccording to the algorithm, the ALU Cycle performs, for every iteration:\n- An ALU operation on $A$ with $M$, chosen based on $A_{\\text{sign}}$: if $A_{\\text{sign}}=0$, compute $A - M$; if $A_{\\text{sign}}=1$, compute $A + M$.\n- Load the result back into $A$.\n- Concurrently write the new quotient bit into $Q[0]$, by enabling `Q0_write_enable`; the datapath hardwiring writes $\\text{NOT}(\\text{ALU_output_sign})$ when enabled.\n\nFrom this, the signals that must be asserted in every ALU Cycle, regardless of $A_{\\text{sign}}$, `n_zero`, or `start`, are:\n- `A_load_from_ALU`: required to store the ALU result into $A$ in this cycle, unconditionally for each iteration’s ALU phase.\n- `Q0_write_enable`: required to write the quotient bit in this cycle, unconditionally for each iteration’s ALU phase.\n\nThe signal `ALU_op_is_add` is determined by $A_{\\text{sign}}$ in this same cycle (it selects between $A+M$ and $A-M$), hence it is not a Moore output; it is a Mealy-dependent control. The signals `AQ_shift_left` and `n_dec` belong to the Shift Cycle, not the ALU Cycle. The signal `A_load_correction` belongs only to the final Correction Cycle. None of these are asserted solely by being in the ALU Cycle state.\n\nTherefore, the complete set of Moore outputs asserted in the ALU Cycle is exactly `{A_load_from_ALU, Q0_write_enable}`, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1908116"}]}