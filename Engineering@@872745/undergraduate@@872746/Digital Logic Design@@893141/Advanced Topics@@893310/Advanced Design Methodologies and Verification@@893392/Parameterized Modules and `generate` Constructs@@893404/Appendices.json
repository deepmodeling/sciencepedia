{"hands_on_practices": [{"introduction": "Mastering parameterized design often begins with simple, regular structures. This first practice exercise focuses on a fundamental task: reversing the bits of a vector. By implementing a bit reverser [@problem_id:1950959], you will learn the core syntax of the `generate for` loop to create parallel, non-interacting logic, providing a solid foundation for building more complex scalable hardware.", "problem": "In modern digital logic design, creating flexible and reusable hardware modules is a key principle. Verilog provides `parameter` and `generate` constructs for this purpose. A `parameter` allows a module's characteristics, such as the width of a data bus, to be defined at instantiation time rather than being hardcoded. A `generate` block allows for the creation of repetitive logic structures based on these parameters, which is evaluated during the elaboration phase before simulation or synthesis.\n\nConsider the design of a parameterized `BitReverser` module. This module takes an N-bit input vector, `data_in`, and produces an N-bit output vector, `data_out`, where the bits of `data_in` are in the reverse order. For example, if `N=8` and `data_in` is `8'b11001010`, `data_out` should be `8'b01010011`.\n\nThe module is declared as follows:\n```verilog\nmodule BitReverser #(parameter N = 8) (\n    input  wire [N-1:0] data_in,\n    output wire [N-1:0] data_out\n);\n\n    // Implementation to be inserted here\n\nendmodule\n```\n\nWhich of the following Verilog code snippets, when inserted into the module, correctly implements the bit-reversal logic for any positive integer value of the parameter `N`?\n\nA.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    for (integer i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nC.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-i];\n    end\nendgenerate\n```\n\nE.\n```verilog\nalways @(*) begin\n    for (integer i = 0; i  N; i = i + 1) begin\n        data_out[i] = data_in[N-1-i];\n    end\nend\n```", "solution": "We need to connect each output bit to the corresponding mirrored input bit: for every index $i$ with $0 \\leq i \\leq N-1$, the correct mapping is $data\\_out[i] = data\\_in[N-1-i]$. This is a purely combinational wiring pattern that is entirely determined at elaboration time and should be implemented with a generate-for loop using a genvar index, producing continuous assignments.\n\nEvaluate each option against Verilog-2001 rules and the required mapping:\n\n- Option A:\n  - Uses a generate-for loop with a genvar index $i$, which is the correct construct for elaboration-time replication.\n  - Uses a named generate block begin : reverse_loop, which is the recommended and standard-compliant style.\n  - Implements the correct index expression $N-1-i$.\n  - This is correct.\n\n- Option B:\n  - Uses an integer loop variable inside a generate-for loop. In Verilog-2001 generate-for, the loop variable must be declared as genvar, not integer. Hence this is not standard-compliant and is incorrect.\n\n- Option C:\n  - Uses genvar correctly and implements the correct mapping $N-1-i$, but omits the label on the generate block. In standard Verilog-2001, the for-generate body should be a named generate block to be compliant and avoid tool issues. This omission makes it noncompliant in strict Verilog-2001 usage. Therefore, it is not the best correct answer.\n\n- Option D:\n  - Uses $N-i$ instead of $N-1-i$, which causes an out-of-range index when $i=0$ (accessing $data\\_in[N]$) and an off-by-one mapping overall. Incorrect.\n\n- Option E:\n  - Uses a procedural always @(*) block assigning to data_out, but data_out is declared as wire; procedural assignment requires reg. As given, this does not compile. Also, this is not using the generate construct as intended for elaboration-time structure. Incorrect as written.\n\nTherefore, the only fully correct and standard-compliant implementation among the options is A.", "answer": "$$\\boxed{A}$$", "id": "1950959"}, {"introduction": "Building on the concept of generating parallel logic, this next exercise introduces a dependency between generated elements. You will design a flexible parity generator [@problem_id:1950971] that creates a chain of XOR gates, where each stage depends on the previous one. This practice demonstrates how to construct serial logic structures and use parameters not just for size, but also to control the module's core function, in this case switching between even and odd parity.", "problem": "You are tasked with designing a flexible parity generator circuit in Verilog. The module, named `ParityGenerator`, should be parameterized to handle an input data vector of variable width and to produce either even or odd parity.\n\nThe module must have the following specifications:\n-   A parameter `WIDTH` that defines the bit-width of the input data vector.\n-   A parameter `PARITY_TYPE`, where a value of `0` specifies **even parity** and a value of `1` specifies **odd parity**.\n-   An input port `data_in` of `WIDTH` bits.\n-   A single-bit output port `parity_out`.\n\nThe functionality is defined as follows:\n-   For **even parity** (`PARITY_TYPE = 0`), the `parity_out` bit should be set such that the total number of '1's in the combination of `data_in` and `parity_out` is even. This is equivalent to `parity_out` being the XOR sum of all bits in `data_in`.\n-   For **odd parity** (`PARITY_TYPE = 1`), the `parity_out` bit should be set such that the total number of '1's in the combination of `data_in` and `parity_out` is odd. This is equivalent to `parity_out` being the XNOR sum of all bits in `data_in`.\n\nYour implementation must use a `generate` `for` loop to create the necessary combinational logic structure. Which of the following Verilog code snippets correctly implements the specified `ParityGenerator` module?\n\nA.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = 0;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH] | PARITY_TYPE;\nendmodule\n```\n\nB.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    integer i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nC.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nD.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i+1];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nE.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output reg parity_out\n);\n    reg [WIDTH-1:0] p_temp;\n\n    genvar i;\n    generate\n        always @(*) begin\n            p_temp[0] = data_in[0];\n            for (i = 1; i  WIDTH; i = i + 1) begin\n                p_temp[i] = p_temp[i-1] ^ data_in[i];\n            end\n            parity_out = p_temp[WIDTH-1] ^ PARITY_TYPE;\n        end\n    endgenerate\nendmodule\n```", "solution": "Let the input vector be $d=\\text{data\\_in}$ with bits $d_{i}$ for $i=0,\\dots,\\text{WIDTH}-1$. Define the bitwise XOR reduction of the data as\n$$\ns=\\bigoplus_{i=0}^{\\text{WIDTH}-1} d_{i}.\n$$\nThe parity bit $p=\\text{parity\\_out}$ must satisfy the specification:\n- For even parity $\\text{PARITY\\_TYPE}=0$, the total number of ones in $(d,p)$ is even, which requires $s \\oplus p=0$. Hence,\n$$\np=s.\n$$\n- For odd parity $\\text{PARITY\\_TYPE}=1$, the total number of ones in $(d,p)$ is odd, which requires $s \\oplus p=1$. Hence,\n$$\np=\\overline{s}=s \\oplus 1.\n$$\n\nCombining both cases in one expression using $\\text{PARITY\\_TYPE}\\in\\{0,1\\}$ gives\n$$\np = s \\oplus \\text{PARITY\\_TYPE}.\n$$\nA structural implementation using a generate for-loop can realize this by forming an XOR chain initialized with $\\text{PARITY\\_TYPE}$:\n- Initialize $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$.\n- For each $i$ from $0$ to $\\text{WIDTH}-1$, compute $p\\_{\\text{chain}}[i+1]=p\\_{\\text{chain}}[i]\\oplus d_{i}$.\n- Output $p=p\\_{\\text{chain}}[\\text{WIDTH}]$.\n\nThis yields $p\\_{\\text{chain}}[\\text{WIDTH}]=\\left(\\bigoplus_{i=0}^{\\text{WIDTH}-1} d_{i}\\right)\\oplus \\text{PARITY\\_TYPE}=s\\oplus \\text{PARITY\\_TYPE}$, which matches the required behavior for both even and odd parity.\n\nNow evaluate the options:\n- A computes $p=s$ via the chain, then sets $\\text{parity\\_out}=s \\lor \\text{PARITY\\_TYPE}$, which for $\\text{PARITY\\_TYPE}=1$ yields $1$ instead of $\\overline{s}$, so it is incorrect.\n- B uses $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$ and computes $p=s\\oplus \\text{PARITY\\_TYPE}$ logically correctly, but declares the loop variable as an integer inside a generate for-loop; a generate loop requires a compile-time genvar, so this does not meet the requirement.\n- C uses $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$ with a genvar-based generate for-loop to compute $p\\_{\\text{chain}}[\\text{WIDTH}]=s\\oplus \\text{PARITY\\_TYPE}$ and sets $\\text{parity\\_out}$ to that value; this satisfies both functionality and the generate requirement.\n- D uses $d_{i+1}$, which both skips $d_{0}$ and accesses out-of-bounds at $i=\\text{WIDTH}-1$, so it is incorrect.\n- E mixes an always block with a genvar in a procedural for-loop, which is illegal; moreover, it does not properly use a generate for-loop to create structural logic as required.\n\nTherefore, the only correct implementation among the options is C.", "answer": "$$\\boxed{C}$$", "id": "1950971"}, {"introduction": "This final practice advances to a more sophisticated and common design pattern: priority logic. You will implement a module to find the first '0' bit in a vector [@problem_id:1950986], which is a form of priority encoding essential in arbiters and resource managers. This exercise showcases how `generate` constructs can build complex, cascading decision-making circuits, moving beyond simple chains to create powerful, scalable control logic.", "problem": "You are tasked with designing a parameterized Verilog module, `find_first_zero`, which is a common component in systems that need to process status flags or masks. The module must identify the index of the first '0' bit found when searching from the least significant bit (LSB) of an input vector.\n\n**Module Specifications:**\n*   **Module Name**: `find_first_zero`\n*   **Parameter**: An integer `WIDTH` that defines the bit-width of the input vector.\n*   **Input**: `data_in`, a logic vector of size `[WIDTH-1:0]`.\n*   **Output**: `index`, a logic vector of size `[$clog2(WIDTH+1)-1:0]`.\n*   **Functionality**:\n    *   The `index` output must hold the bit position of the first '0' encountered when scanning `data_in` from index 0 (LSB) towards index `WIDTH-1`, the Most Significant Bit (MSB).\n    *   In the specific case where `data_in` contains no '0' bits (i.e., all bits are '1'), the `index` output must be set to the value `WIDTH`.\n\nBelow are four different Verilog code snippets proposed for the body of this module. Which one correctly implements the specified functionality?\n\nA.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i = 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? i : index_stage[i+1];\n    end\n    assign index = index_stage[0];\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[0] = WIDTH;\n    for (i = 0; i  WIDTH; i=i+1) begin: priority_chain\n        assign index_stage[i+1] = (~data_in[i]) ? i : index_stage[i];\n    end\n    assign index = index_stage[WIDTH];\nendgenerate\n```\n\nC.\n```verilog\ngenerate\n    genvar i;\n    for (i = 0; i  WIDTH; i=i+1) begin: priority_chain\n        always @(*) begin\n            if (~data_in[i])\n                index = i;\n        end\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i = 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? index_stage[i+1] : i;\n    end\n    assign index = index_stage[0];\nendgenerate\n```", "solution": "We need a combinational module that, for an input vector $data\\_in[WIDTH-1:0]$, returns the smallest index $j \\in \\{0,\\dots,WIDTH-1\\}$ such that $data\\_in[j]=0$ when scanning from least significant bit to most significant bit. If no such $j$ exists, the output must be $WIDTH$. Define the target function\n$$\nf(i)=\\begin{cases}\n\\min\\{j \\mid j\\in [i, WIDTH-1],\\ data\\_in[j]=0\\},  \\text{if such } j \\text{ exists},\\\\\nWIDTH,  \\text{otherwise}.\n\\end{cases}\n$$\nThe desired output is $f(0)$.\n\nAnalyze each option:\n\nOption A:\nIt defines a chain $index\\_stage[i]$ with boundary $index\\_stage[WIDTH]=WIDTH$, and for $i$ from $WIDTH-1$ down to $0$:\n$$\nindex\\_stage[i] = \\begin{cases}\ni,  \\text{if } \\lnot data\\_in[i],\\\\\nindex\\_stage[i+1],  \\text{otherwise}.\n\\end{cases}\n$$\nThis recurrence matches the definition of $f(i)$: clearly $index\\_stage[WIDTH]=f(WIDTH)=WIDTH$. For $i$ descending, if $data\\_in[i]=0$, then the first zero at or above $i$ is $i$, so $f(i)=i$. Otherwise, the first zero at or above $i$ is the same as at or above $i+1$, so $f(i)=f(i+1)$. Therefore by induction $index\\_stage[i]=f(i)$ for all $i$, and the final assignment $index=index\\_stage[0]=f(0)$ is exactly the required behavior, including the all-ones case yielding $WIDTH$.\n\nOption B:\nIt sets $index\\_stage[0]=WIDTH$ and for $i$ from $0$ up to $WIDTH-1$:\n$$\nindex\\_stage[i+1] = \\begin{cases}\ni,  \\text{if } \\lnot data\\_in[i],\\\\\nindex\\_stage[i],  \\text{otherwise}.\n\\end{cases}\n$$\nThis logic overwrites the stored index whenever a new zero is encountered, thus $index\\_stage[WIDTH]$ becomes the largest index $i$ with $data\\_in[i]=0$, i.e., the last zero when scanning from LSB to MSB. For example, with $data\\_in= \\dots 1 0 0$ at positions $2:0$, the result becomes $1$ instead of the correct $0$. Hence it is incorrect.\n\nOption C:\nIt creates multiple always blocks, each potentially assigning to the same signal $index$ without a default assignment. This causes multiple procedural drivers on $index$ and no defined priority to select the first zero. It also fails the all-ones case, since $index$ would remain unassigned. It does not implement the specified functionality.\n\nOption D:\nIt uses $index\\_stage[WIDTH]=WIDTH$ and for $i$ descending:\n$$\nindex\\_stage[i] = \\begin{cases}\nindex\\_stage[i+1],  \\text{if } \\lnot data\\_in[i],\\\\\ni,  \\text{otherwise}.\n\\end{cases}\n$$\nThis is inverted from the needed recurrence. For instance, with all ones, one obtains $index\\_stage[0]=0$ instead of $WIDTH$, violating the specification. Therefore it is incorrect.\n\nThus, only Option A correctly implements the required functionality, including the boundary case where no zero is found.", "answer": "$$\\boxed{A}$$", "id": "1950986"}]}