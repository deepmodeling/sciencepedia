{"hands_on_practices": [{"introduction": "The heart of an FPGA's reconfigurable logic is the Look-Up Table (LUT), a small memory that can be programmed to implement any Boolean function. This exercise provides a foundational understanding of how a truth table for a desired function translates directly into the configuration bits stored within a LUT. By determining the configuration string for a majority function, you will see firsthand how abstract logic becomes concrete hardware configuration [@problem_id:1938016].", "problem": "In the design of modern digital systems, Field-Programmable Gate Arrays (FPGAs) are commonly used for their flexibility. The fundamental building block of an FPGA is the configurable logic block, which often contains several Look-Up Tables (LUTs). A $k$-input LUT is a small memory that can be configured to implement any Boolean function of $k$ variables. For a 3-input LUT, this memory stores $2^3 = 8$ bits of data, forming an 8-bit \"configuration string.\" When the three inputs to the LUT are applied, they are treated as an address to this memory, and the bit stored at that address becomes the output of the LUT.\n\nConsider a simple fault-tolerant system that uses three redundant sensors to monitor a critical condition. Let the binary outputs of these sensors be $A$, $B$, and $C$. To generate a reliable signal, a \"3-input majority\" function is required. This function outputs a `1` if and only if two or more of its inputs are `1`; otherwise, it outputs a `0`.\n\nYou are tasked with implementing this 3-input majority function using a single 3-input LUT. The inputs to the LUT are $A$, $B$, and $C$. These inputs are interpreted as a 3-bit binary number, CBA, to form an address, where $C$ is the most significant bit (MSB) and $A$ is the least significant bit (LSB). The 8-bit configuration string is defined as the sequence of memory values from address 7 down to address 0. That is, the string is `{mem[7], mem[6], mem[5], mem[4], mem[3], mem[2], mem[1], mem[0]}`.\n\nWhich of the following represents the correct 8-bit configuration string required to implement the 3-input majority function?\n\nA. 00010111\n\nB. 11101000\n\nC. 10000000\n\nD. 11111110\n\nE. 10010110", "solution": "To solve this problem, we need to determine the 8-bit configuration string for a 3-input Look-Up Table (LUT) that implements a 3-input majority function. Let the inputs be $A$, $B$, and $C$, and the output be $F(A, B, C)$.\n\nThe first step is to construct the truth table for the 3-input majority function. The function's output is 1 if two or more inputs are 1, and 0 otherwise. The inputs $C$, $B$, and $A$ also form the address for the LUT's memory, where $C$ is the most significant bit (MSB) and $A$ is the least significant bit (LSB). The integer value of the binary number $CBA$ corresponds to the memory address.\n\nLet's build the truth table, including the decimal address corresponding to each input combination.\n\n| Address (Decimal) | Input $C$ | Input $B$ | Input $A$ | Number of '1's | Output $F$ |\n|-------------------|-----------|-----------|-----------|----------------|------------|\n| 0                 | 0         | 0         | 0         | 0              | 0          |\n| 1                 | 0         | 0         | 1         | 1              | 0          |\n| 2                 | 0         | 1         | 0         | 1              | 0          |\n| 3                 | 0         | 1         | 1         | 2              | 1          |\n| 4                 | 1         | 0         | 0         | 1              | 0          |\n| 5                 | 1         | 0         | 1         | 2              | 1          |\n| 6                 | 1         | 1         | 0         | 2              | 1          |\n| 7                 | 1         | 1         | 1         | 3              | 1          |\n\nThe output column $F$ represents the bit that should be stored at each corresponding memory address in the LUT. So, we have:\n- `mem[0]` = 0\n- `mem[1]` = 0\n- `mem[2]` = 0\n- `mem[3]` = 1\n- `mem[4]` = 0\n- `mem[5]` = 1\n- `mem[6]` = 1\n- `mem[7]` = 1\n\nThe problem specifies that the configuration string is the sequence of memory values from address 7 down to address 0. This means the string is formed by concatenating the memory bits in the order `mem[7] mem[6] mem[5] mem[4] mem[3] mem[2] mem[1] mem[0]`.\n\nUsing the values we derived from the truth table:\n- `mem[7]` = 1\n- `mem[6]` = 1\n- `mem[5]` = 1\n- `mem[4]` = 0\n- `mem[3]` = 1\n- `mem[2]` = 0\n- `mem[1]` = 0\n- `mem[0]` = 0\n\nAssembling these bits in the specified order gives the 8-bit configuration string: `11101000`.\n\nComparing this result with the given options:\nA. 00010111 (This is the reverse order, from address 0 to 7. A common mistake.)\nB. 11101000 (This matches our derived string.)\nC. 10000000 (This would implement a 3-input AND gate.)\nD. 11111110 (This would implement a 3-input OR gate.)\nE. 10010110 (This would implement a 3-input XOR gate.)\n\nThus, the correct configuration string is `11101000`, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1938016"}, {"introduction": "Beyond simple combinational logic, FPGAs excel at implementing complex sequential circuits. This is possible because a typical Logic Element (LE) pairs a versatile LUT with a D-type flip-flop. This practice challenges you to configure the LUT to control the flip-flop's behavior, effectively designing a custom T-flip-flop with a synchronous enable, a common building block in digital systems. This demonstrates the powerful synergy between the combinational and sequential resources within a single LE [@problem_id:1938061].", "problem": "A specialized Logic Element (LE) within a Field-Programmable Gate Array (FPGA) is designed to be highly flexible. This particular LE consists of a single three-input Look-Up Table (LUT) and one D-type flip-flop (DFF). The output of the LUT directly feeds the $D$ input of the DFF. The registered output of the DFF, denoted as $Q$, is available as an output of the LE and can also be used as a feedback input to the LUT.\n\nYour task is to configure this LE to function as a T-type flip-flop (T-FF) with a synchronous, active-high clock enable signal, $CE$. The three inputs available to the LUT are the toggle signal $T$, the clock enable signal $CE$, and the current state of the flip-flop, $Q$.\n\nThe LUT must be programmed to implement a specific Boolean function, $D = F(CE, T, Q)$, that makes the entire LE behave as a T-FF with synchronous enable. This means:\n1.  When $CE$ is low (0), the flip-flop must hold its current state $Q$ on the next active clock edge.\n2.  When $CE$ is high (1), the flip-flop must behave as a standard T-FF on the next active clock edge (i.e., hold its state if $T=0$ and toggle its state if $T=1$).\n\nWhich of the following Boolean expressions for $D$ correctly implement this functionality? Select all that apply. In the options below, $\\land$ denotes the logical AND operation, $\\lor$ denotes the logical OR operation, $\\neg$ denotes the logical NOT operation, and $\\oplus$ denotes the logical XOR operation.\n\nA. $D = (CE \\land (T \\oplus Q)) \\lor (\\neg CE \\land Q)$\n\nB. $D = (CE \\land T) \\oplus Q$\n\nC. $D = CE \\land (T \\oplus Q)$\n\nD. $D = (\\neg CE \\land Q) \\lor (CE \\land T)$\n\nE. $D = \\neg ( (\\neg CE \\land Q) \\lor (CE \\land (T \\oplus Q)) )$", "solution": "Let $Q^{+}$ denote the next registered state, so the LUT must implement $D=Q^{+}$ as a function of $(CE,T,Q)$ with the required behavior:\n- If $CE=0$, then $Q^{+}=Q$ (hold).\n- If $CE=1$, then $Q^{+}=Q \\oplus T$ (T flip-flop behavior).\n\nThis conditional behavior can be written as the Boolean multiplexer form\n$$\nD \\;=\\; (\\neg CE \\land Q)\\; \\lor\\; \\big(CE \\land (Q \\oplus T)\\big).\n$$\nThis matches option A exactly, so A is correct.\n\nNow show that option B implements the same function. Consider\n$$\nD \\;=\\; (CE \\land T) \\oplus Q.\n$$\nBy case analysis on $CE$:\n- If $CE=0$, then $D=(0\\land T)\\oplus Q=0\\oplus Q=Q$, which matches the required hold.\n- If $CE=1$, then $D=(1\\land T)\\oplus Q=T\\oplus Q=Q\\oplus T$, which matches the required T-FF behavior.\nHence B is correct.\n\nFor completeness, we can also prove algebraic equivalence between A and B. Starting from A:\n$$\nD \\;=\\; CE\\land(Q \\oplus T)\\; \\lor\\; \\neg CE \\land Q\n\\;=\\; CE\\big(\\neg Q \\land T \\;\\lor\\; Q \\land \\neg T\\big)\\; \\lor\\; \\neg CE \\land Q\n$$\n$$\n=\\; CE \\land \\neg Q \\land T \\;\\lor\\; CE \\land Q \\land \\neg T \\;\\lor\\; \\neg CE \\land Q\n$$\nGroup the terms containing $Q$:\n$$\n=\\; CE \\land \\neg Q \\land T \\;\\lor\\; Q\\big(CE \\land \\neg T \\;\\lor\\; \\neg CE\\big).\n$$\nUse $\\neg CE \\lor (CE \\land \\neg T) = (\\neg CE \\lor CE)\\land(\\neg CE \\lor \\neg T)=1\\land(\\neg CE \\lor \\neg T)=\\neg CE \\lor \\neg T$ to get\n$$\nD \\;=\\; CE \\land \\neg Q \\land T \\;\\lor\\; Q(\\neg CE \\lor \\neg T)\n\\;=\\; CE \\land T \\land \\neg Q \\;\\lor\\; \\neg CE \\land Q \\;\\lor\\; \\neg T \\land Q.\n$$\nRecognize this as the standard XOR form:\n$$\nD \\;=\\; \\big(\\neg(CE\\land T)\\land Q\\big) \\;\\lor\\; \\big(CE\\land T \\land \\neg Q\\big)\n\\;=\\; (CE\\land T)\\oplus Q,\n$$\nwhich is option B.\n\nNow test the remaining options against the required behavior:\n\nOption C: $D=CE \\land (T \\oplus Q)$. If $CE=0$, then $D=0$, which in general is not equal to $Q$; thus C is incorrect.\n\nOption D: $D=(\\neg CE \\land Q)\\lor(CE \\land T)$. If $CE=1$, then $D=T$, but the required behavior is $Q \\oplus T$. For example, with $Q=1$ and $T=0$, the required next state is $1$, but $D$ evaluates to $0$; thus D is incorrect.\n\nOption E: $D=\\neg\\big((\\neg CE \\land Q)\\lor(CE \\land (T \\oplus Q))\\big)$ is the logical negation of A, so it inverts the required behavior. For example, with $CE=0$ and $Q=1$, the required next state is $1$, but $D=\\neg(1)=0$; thus E is incorrect.\n\nTherefore, the correct options are A and B.", "answer": "$$\\boxed{AB}$$", "id": "1938061"}, {"introduction": "A single LUT has a fixed number of inputs, so how do FPGAs implement functions that are much larger? The answer lies in the programmable interconnect that links many logic elements together. This final practice explores the crucial concept of logic decomposition, where a larger function is broken down and implemented across multiple LUTs. By manually constructing a 5-to-1 multiplexer using only 4-input LUTs, you will gain insight into the process that synthesis tools perform automatically to map complex designs onto the FPGA fabric [@problem_id:1938052].", "problem": "In modern digital design, Field-Programmable Gate Arrays (FPGAs) are commonly used for prototyping and implementing custom logic circuits. The fundamental building block of many FPGAs is a K-input Look-Up Table (LUT), which is a small memory capable of implementing any arbitrary Boolean function of K variables.\n\nConsider a digital system that must be implemented on an FPGA whose logic is based exclusively on 4-input Look-Up Tables (4-LUTs). Your task is to design a 5-to-1 multiplexer (MUX). This MUX has five data inputs, labeled $I_0, I_1, I_2, I_3,$ and $I_4$, and three select inputs, labeled $S_2, S_1,$ and $S_0$. The output of the multiplexer, $Y$, should be equal to the data input $I_k$, where $k$ is the integer value represented by the binary number $S_2S_1S_0$. For example, if the select inputs are $S_2S_1S_0 = 100$, the output $Y$ is $I_4$. For select input combinations that are not used (i.e., $k > 4$), the output is a don't-care.\n\nWhat is the minimum number of 4-input LUTs required to construct this 5-to-1 multiplexer, assuming you can only use 4-LUTs and standard wiring?\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. 5", "solution": "We are restricted to 4-input LUTs. A 4-LUT can implement any Boolean function of at most 4 inputs.\n\nDefine the 2:1 multiplexer primitive as the Boolean function\n$$\n\\operatorname{mux}(s,a,b) \\equiv \\overline{s}\\,a + s\\,b.\n$$\nA 2:1 MUX uses 3 inputs $\\{s,a,b\\}$ and therefore fits in one 4-LUT.\n\nTarget behavior of the 5-to-1 MUX:\n- Let the three select lines form a binary number $S_{2}S_{1}S_{0}$.\n- For $S_{2}S_{1}S_{0}\\in\\{000,001,010,011,100\\}$, we require $Y=I_{k}$ for $k\\in\\{0,1,2,3,4\\}$, respectively.\n- For $S_{2}S_{1}S_{0}\\in\\{101,110,111\\}$, $Y$ is a don't-care, hence can be assigned arbitrarily.\n\nSufficiency (constructive upper bound with 4 LUTs):\nImplement the standard MUX tree using 2:1 MUXs, each realizable by one 4-LUT:\n- First level:\n$$\nA=\\operatorname{mux}(S_{0}, I_{0}, I_{1}),\\quad B=\\operatorname{mux}(S_{0}, I_{2}, I_{3}).\n$$\n- Second level (select between $A$ and $B$):\n$$\nC=\\operatorname{mux}(S_{1}, A, B).\n$$\n- Final level (insert $I_{4}$ under $S_{2}$):\n$$\nY=\\operatorname{mux}(S_{2}, C, I_{4}).\n$$\nWhen $S_{2}=0$, $Y=C$ implements the required 4-to-1 selection among $I_{0},I_{1},I_{2},I_{3}$ by $S_{1},S_{0}$. When $S_{2}=1$, $Y=I_{4}$ irrespective of $S_{1},S_{0}$, which exactly satisfies the required case $S_{2}S_{1}S_{0}=100$ and is acceptable for $S_{2}S_{1}S_{0}\\in\\{101,110,111\\}$ due to don't-cares. This uses exactly $4$ LUTs, proving that $4$ LUTs suffice.\n\nNecessity (why $3$ LUTs cannot suffice):\n- Consider the cofactor for $S_{2}=0$: the function reduces to a 4-to-1 MUX among $I_{0},I_{1},I_{2},I_{3}$ selected by $\\{S_{1},S_{0}\\}$. A single 4-LUT cannot realize this, because that would require a function of $6$ independent inputs $\\{S_{1},S_{0},I_{0},I_{1},I_{2},I_{3}\\}$, exceeding the 4-input capacity. The minimal implementation via 2:1 MUX decomposition requires three 2:1 MUXs (two for the first stage on $S_{0}$ and one for the second stage on $S_{1}$), that is, $3$ LUTs.\n- With only these $3$ LUTs, the final LUT in that structure already consumes inputs for $\\{S_{1},A,B\\}$, where $A$ and $B$ are the first-stage outputs. It has only one remaining input pin. To also realize the $I_{4}$ case, the decision point must have access to both $S_{2}$ (to detect that the $I_{4}$ branch is required) and $I_{4}$ (to output its value). That would require at least two additional inputs $\\{S_{2},I_{4}\\}$ at the final decision point, exceeding the 4-input limit. Pushing $\\{S_{2},I_{4}\\}$ into earlier LUTs forces at least one of those LUTs to depend on $\\{S_{0},I_{x},I_{y},S_{2}\\}$ and also pass $I_{4}$, which would be $5$ inputs, again impossible for a 4-LUT. Hence $3$ LUTs are insufficient.\n\nTherefore, the minimum number of 4-input LUTs required is $4$.", "answer": "$$\\boxed{D}$$", "id": "1938052"}]}