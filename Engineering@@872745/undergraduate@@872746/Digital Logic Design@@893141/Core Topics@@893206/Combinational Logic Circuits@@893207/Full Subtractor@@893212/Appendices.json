{"hands_on_practices": [{"introduction": "To truly understand a digital circuit, it's essential to be able to construct it from the most basic building blocks. This first practice challenges you to implement a full subtractor using only 2-input NAND gates, which are known as universal gates. Mastering this skill demonstrates a deep understanding of Boolean logic and the principles of gate-level design optimization. [@problem_id:1939071]", "problem": "A full subtractor is a fundamental combinational logic circuit that performs subtraction of three bits. It takes three inputs: a minuend bit $A$, a subtrahend bit $B$, and a borrow-in bit $B_{in}$ from a previous, less-significant stage. It produces two outputs: the difference bit $D$ and a borrow-out bit $B_{out}$ for the next, more-significant stage. The relationship is governed by the arithmetic operation $A - B - B_{in}$, where the result is a two-bit number represented by the pair ($B_{out}$, $D$). For example, if $A=0$, $B=1$, and $B_{in}=1$, then $0 - 1 - 1 = -2$, which in this binary representation is $B_{out}=1$ and $D=0$.\n\nYour task is to design a circuit that implements a full subtractor using exclusively 2-input NAND gates. Assume you have an unlimited supply of these gates. Determine the minimum number of 2-input NAND gates required to construct the full subtractor circuit that correctly generates both the difference bit $D$ and the borrow-out bit $B_{out}$ from the inputs $A$, $B$, and $B_{in}$.", "solution": "We seek a 2-input NAND-only realization of the full subtractor with inputs $A$, $B$, $B_{in}$ and outputs $D$ and $B_{out}$. The arithmetic relation is $A - B - B_{in}$, giving the difference bit $D$ and borrow-out $B_{out}$.\n\nFirst, write the canonical Boolean forms:\n- The difference bit is the odd-parity of the three inputs:\n$$\nD \\;=\\; A \\oplus B \\oplus B_{in}.\n$$\n- A standard, minimal borrow expression is\n$$\nB_{out} \\;=\\; \\overline{A}B \\;+\\; B_{in}\\,\\overline{A \\oplus B}.\n$$\nTo implement with NANDs efficiently, we will compute $X_{1}=A \\oplus B$ once and reuse its internal NAND signals to realize $B_{out}$ with a single extra NAND gate.\n\nRealize $X_{1}=A \\oplus B$ using the minimal 4-NAND construction. Define the intermediate NAND nodes:\n$$\nN_{1}=\\overline{AB},\\quad N_{2}=\\overline{A N_{1}},\\quad N_{3}=\\overline{B N_{1}},\\quad X_{1}=\\overline{N_{2}N_{3}}.\n$$\nOne can verify by Boolean algebra that $N_{2}=\\overline{A\\cdot\\overline{AB}}=\\overline{A(\\overline{A}+\\overline{B})} = \\overline{A\\overline{A} + A\\overline{B}} = \\overline{A\\overline{B}} = A+\\overline{B}$ and $N_{3}=\\overline{B}+A$, and that $X_{1}=A \\oplus B$ as required.\n\nNext, compute $D=X_{1}\\oplus B_{in}$ with the same 4-NAND pattern, introducing the intermediate nodes:\n$$\nS_{1}=\\overline{X_{1}B_{in}},\\quad S_{2}=\\overline{X_{1}S_{1}},\\quad S_{3}=\\overline{B_{in}S_{1}},\\quad D=\\overline{S_{2}S_{3}}.\n$$\nBy the same reasoning, $D=X_{1}\\oplus B_{in}=A\\oplus B\\oplus B_{in}$.\n\nNow express $B_{out}$ using already available NAND nodes. From the first XOR block, $\\overline{N_{3}}=\\overline{A+\\overline{B}}=\\overline{A}B$. From the second XOR block, \n$$\nS_{3}=\\overline{B_{in}\\,S_{1}}=\\overline{B_{in}\\,\\overline{X_{1}B_{in}}}=\\overline{B_{in}\\,(\\overline{X_{1}}\\,+\\,\\overline{B_{in}})}=\\overline{B_{in}\\,\\overline{X_{1}}} \\;=\\; \\overline{B_{in}\\,\\overline{A\\oplus B}}.\n$$\nTherefore $\\overline{S_{3}}=B_{in}\\,\\overline{A\\oplus B}$. Using these two facts,\n$$\nB_{out}\\;=\\;\\overline{A}B\\;+\\;B_{in}\\,\\overline{A\\oplus B}\\;=\\;\\overline{N_{3}}\\;+\\;\\overline{S_{3}}\\;=\\;\\overline{N_{3}\\,S_{3}}.\n$$\nHence $B_{out}$ is obtained by one final 2-input NAND gate with inputs $N_{3}$ and $S_{3}$.\n\nGate-count summary:\n- $X_{1}=A\\oplus B$ uses $4$ NAND gates.\n- $D=X_{1}\\oplus B_{in}$ uses $4$ NAND gates.\n- $B_{out}=\\overline{N_{3}S_{3}}$ uses $1$ additional NAND gate, reusing $N_{3}$ and $S_{3}$ from the two XOR networks.\n\nTotal number of 2-input NAND gates is $4+4+1=9$. A lower bound argument: a 2-input XOR requires at least $4$ 2-input NAND gates, so computing $D=(A\\oplus B)\\oplus B_{in}$ requires at least $8$ NAND gates. Since $B_{out}$ is not identically equal to any single intermediate node of those two XOR networks, at least one more 2-input NAND is necessary to form it. Thus $9$ is the minimum, which is achieved by the construction above.", "answer": "$$\\boxed{9}$$", "id": "1939071"}, {"introduction": "Ideal circuits exist only on paper; real-world components can have manufacturing defects. In this exercise, you'll step into the role of a test engineer to analyze a full subtractor with a \"stuck-at-1\" fault on one of its inputs. This practice will sharpen your analytical skills and deepen your understanding of the circuit's behavior by exploring how its logic responds to an internal failure. [@problem_id:1939103]", "problem": "A digital full subtractor is a combinational logic circuit that performs the binary subtraction of three input bits: the minuend $A$, the subtrahend $B$, and the borrow-in from a previous stage, $B_{in}$. The circuit produces two outputs: the difference bit $D$ and the borrow-out bit $B_{out}$, which represents the borrow for the next more significant stage.\n\nConsider a particular full subtractor integrated circuit that has a manufacturing defect. This defect causes the input line for the subtrahend $B$ to be \"stuck-at-1\". This means that the internal circuitry connected to this input always operates as if the input $B$ is a logic '1', regardless of the actual logic level applied to the external pin for $B$. The inputs $A$ and $B_{in}$ function correctly.\n\nIdentify the complete set of all possible input combinations of $(A, B, B_{in})$ for which this faulty subtractor will produce an incorrect value for the `Difference` output, $D$.\n\nA. (0,0,0), (0,0,1), (1,0,0), (1,0,1)\n\nB. (0,1,0), (0,1,1), (1,1,0), (1,1,1)\n\nC. (0,0,1), (0,1,0), (1,0,0), (1,1,1)\n\nD. (0,0,0), (0,1,1), (1,0,1), (1,1,0)\n\nE. (0,0,0), (0,1,0), (1,0,0), (1,1,0)", "solution": "A full subtractor’s difference output is given by the XOR of its three inputs:\n$$D_{\\text{ideal}}=A \\oplus B \\oplus B_{in}.$$\nWith the defect “$B$ stuck-at-1,” the internal circuitry always sees $B=1$, so the faulty difference is\n$$D_{\\text{faulty}}=A \\oplus 1 \\oplus B_{in}.$$\nTo find when the output is incorrect, compute the XOR of the faulty and ideal outputs:\n$$E = D_{\\text{faulty}} \\oplus D_{\\text{ideal}} = (A \\oplus 1 \\oplus B_{in}) \\oplus (A \\oplus B \\oplus B_{in}).$$\nUsing associativity, commutativity, and the cancellation property $X \\oplus X = 0$, we get\n$$E = (A \\oplus A) \\oplus (B_{in} \\oplus B_{in}) \\oplus 1 \\oplus B = 0 \\oplus 0 \\oplus 1 \\oplus B = 1 \\oplus B.$$\nAn incorrect output occurs when $E=1$, which is when $B=0$. Therefore, all input combinations with $B=0$ yield an incorrect difference:\n$$(A,B,B_{in}) \\in \\{(0,0,0),(0,0,1),(1,0,0),(1,0,1)\\}.$$\nThis corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1939103"}, {"introduction": "Digital systems are often built by connecting smaller, modular circuits into larger functional units. This practice examines an n-bit ripple-borrow subtractor, which is a chain of full subtractors. Your task is to identify the specific input conditions that create the longest signal propagation delay, a crucial factor that determines the maximum operational speed of the entire circuit. [@problem_id:1939084]", "problem": "In digital logic design, an $n$-bit ripple-borrow subtractor is constructed by cascading $n$ full subtractor stages. A single full subtractor stage, indexed by $i$, takes three inputs: the minuend bit $A_i$, the subtrahend bit $B_i$, and the borrow-in bit from the previous stage, $B_{in,i}$. It produces two outputs: the difference bit $D_i$ and the borrow-out bit $B_{out,i}$, which serves as the borrow-in for the next stage, i.e., $B_{in,i+1} = B_{out,i}$. For the entire $n$-bit operation, the minuend is $A = A_{n-1}A_{n-2}...A_0$, the subtrahend is $B = B_{n-1}B_{n-2}...B_0$, and the initial borrow-in to the least significant stage (stage 0), $B_{in,0}$, is held at 0.\n\nThe overall speed of this subtractor is limited by the propagation of the borrow signal through the cascade. The worst-case delay scenario for computing the final borrow-out, $B_{out,n-1}$, occurs when the borrow signal must propagate sequentially through the maximum number of stages. This maximum propagation path is established when the borrow-out of each stage $i$ (for $i=0$ to $n-1$) is directly dependent on its borrow-in, $B_{in,i}$.\n\nWhich of the following relationships between the $n$-bit minuend $A$ and the $n$-bit subtrahend $B$ ensures this worst-case propagation condition is met for all $n$ stages?\n\nA. The bits of $A$ and $B$ are identical, i.e., $A_i = B_i$ for all $i \\in \\{0, ..., n-1\\}$.\n\nB. The bits of $A$ are the logical inverse of the bits of $B$, i.e., $A_i = \\overline{B_i}$ for all $i \\in \\{0, ..., n-1\\}$.\n\nC. The minuend $A$ is zero ($A_i=0$ for all $i$) and the subtrahend $B$ is the maximum unsigned value ($B_i=1$ for all $i$).\n\nD. The minuend $A$ is the two's complement of the subtrahend $B$.", "solution": "To solve this problem, we analyze the condition for borrow propagation in a single full subtractor stage. The worst-case delay occurs when the borrow signal must ripple through all stages, meaning the borrow-out of each stage ($B_{out,i}$) depends solely on its borrow-in ($B_{in,i}$).\n\nThe borrow-out function can be expressed in a \"generate-propagate\" form:\n$$B_{out,i} = g_i + p_i \\cdot B_{in,i}$$\nwhere $g_i$ is the \"borrow generate\" term and $p_i$ is the \"borrow propagate\" term. From the full subtractor's logic, these are defined as:\n- $g_i = \\overline{A_i}B_i$: A borrow is generated within the stage if $A_i=0$ and $B_i=1$.\n- $p_i = \\overline{A_i \\oplus B_i}$ (which is $A_i \\odot B_i$): The stage propagates the borrow-in to the borrow-out if the inputs $A_i$ and $B_i$ are equal.\n\nFor the borrow signal to propagate through stage $i$, the output $B_{out,i}$ must be equal to the input $B_{in,i}$. This occurs when the stage is in \"propagate\" mode, which requires two conditions:\n1. The generate term must be false: $g_i = \\overline{A_i}B_i = 0$. This ensures the stage does not generate a borrow on its own.\n2. The propagate term must be true: $p_i = \\overline{A_i \\oplus B_i} = 1$.\n\nThe condition $p_i = 1$ is satisfied only when $A_i \\oplus B_i = 0$, which means $A_i = B_i$.\nLet's check if this single condition ($A_i = B_i$) also satisfies $g_i=0$.\nIf $A_i = B_i$, then either $(A_i, B_i) = (0,0)$ or $(A_i, B_i) = (1,1)$.\n- For $(0,0)$, the generate term is $g_i = \\overline{0} \\cdot 0 = 0$.\n- For $(1,1)$, the generate term is $g_i = \\overline{1} \\cdot 1 = 0$.\nIn both cases where $A_i=B_i$, the generate condition $g_i=0$ is met.\n\nTherefore, the condition for a stage to propagate a borrow is simply $A_i = B_i$. For the borrow to ripple through all $n$ stages, this must be true for every stage $i \\in \\{0, ..., n-1\\}$. This means the $n$-bit minuend $A$ must be identical to the $n$-bit subtrahend $B$.\n\nThis corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1939084"}]}