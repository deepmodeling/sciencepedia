{"hands_on_practices": [{"introduction": "To truly grasp the concept of a ripple-carry adder, it is essential to work through its step-by-step operation. This first exercise provides a direct way to visualize the \"ripple\" effect by having you manually trace the carry bits as they propagate from one full-adder stage to the next [@problem_id:1958696]. Mastering this fundamental calculation is the first step toward analyzing the adder's performance and behavior in more complex scenarios.", "problem": "A 5-bit ripple-carry adder is a digital circuit that adds two 5-bit binary numbers, which we denote as $A = A_4A_3A_2A_1A_0$ and $B = B_4B_3B_2B_1B_0$. The adder is composed of a chain of full adders, where the stage for bit position $i$ receives inputs $A_i$, $B_i$, and a carry-in from the previous stage, $C_i$, to produce a sum bit $S_i$ and a carry-out bit $C_{i+1}$. For the least significant bit (position 0), the carry-in $C_0$ is provided externally.\n\nYou are given the two input numbers $A = 11011_2$ and $B = 01110_2$. The initial carry-in to the adder is $C_0 = 0$.\n\nDetermine the values of the intermediate carry bits $C_1, C_2, C_3,$ and $C_4$ produced during the operation.", "solution": "We use the full-adder carry-out relation at bit position $i$:\n$$\nC_{i+1} = A_i \\cdot B_i + (A_i \\oplus B_i) \\cdot C_i,\n$$\nwhere $+$ denotes Boolean OR, $\\cdot$ denotes Boolean AND, and $\\oplus$ denotes XOR. The bits are $A=11011_{2}$, so $A_{4}=1$, $A_{3}=1$, $A_{2}=0$, $A_{1}=1$, $A_{0}=1$, and $B=01110_{2}$, so $B_{4}=0$, $B_{3}=1$, $B_{2}=1$, $B_{1}=1$, $B_{0}=0$, with $C_{0}=0$.\n\nFor $i=0$: $A_{0}=1$, $B_{0}=0$, $C_{0}=0$.\n$$\nA_{0} \\cdot B_{0}=0,\\quad A_{0}\\oplus B_{0}=1,\\quad C_{1}=0+(1)\\cdot 0=0.\n$$\n\nFor $i=1$: $A_{1}=1$, $B_{1}=1$, $C_{1}=0$.\n$$\nA_{1} \\cdot B_{1}=1,\\quad A_{1}\\oplus B_{1}=0,\\quad C_{2}=1+(0)\\cdot 0=1.\n$$\n\nFor $i=2$: $A_{2}=0$, $B_{2}=1$, $C_{2}=1$.\n$$\nA_{2} \\cdot B_{2}=0,\\quad A_{2}\\oplus B_{2}=1,\\quad C_{3}=0+(1)\\cdot 1=1.\n$$\n\nFor $i=3$: $A_{3}=1$, $B_{3}=1$, $C_{3}=1$.\n$$\nA_{3} \\cdot B_{3}=1,\\quad A_{3}\\oplus B_{3}=0,\\quad C_{4}=1+(0)\\cdot 1=1.\n$$\n\nThus the intermediate carry bits are $C_{1}=0$, $C_{2}=1$, $C_{3}=1$, $C_{4}=1$.", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 1 & 1\\end{pmatrix}}$$", "id": "1958696"}, {"introduction": "Having seen how carries propagate, we now turn to the most significant characteristic of a ripple-carry adder: its performance limitations. The total time required for an addition is dictated by the longest possible path a carry signal must travel. This practice challenges you to identify the specific input conditions that create this worst-case delay, forcing a carry to ripple through every stage of the adder [@problem_id:1958659]. Understanding this bottleneck is key to appreciating the motivation behind more advanced adder architectures like carry-lookahead adders.", "problem": "A 4-bit ripple-carry adder is used to calculate the sum $S = A + B$. The inputs are two 4-bit unsigned binary numbers, $A = A_3A_2A_1A_0$ and $B = B_3B_2B_1B_0$. This adder is built by cascading four identical Full-Adder (FA) modules. For each stage $i$ (from 0 to 3), the FA module computes the sum bit $S_i$ and the carry-out bit $C_{i+1}$ based on its inputs $A_i$, $B_i$, and the carry-in $C_i$. The carry-out of one stage is connected to the carry-in of the next, and the initial carry-in to the first stage, $C_0$, is fixed at 0.\n\nThe time it takes for any output bit of an FA to stabilize is its propagation delay. The total time for the addition is determined by the longest signal path from the primary inputs ($A, B, C_0$) to the final outputs ($S, C_4$). This worst-case scenario occurs when a change in the least significant input bits causes a carry that \"ripples\" through every single FA module to affect the final sum and carry-out.\n\nYour task is to identify which of the following input pairs $(A, B)$ creates this longest possible carry propagation chain.\n\nA. $A = 1111_2, B = 0001_2$\n\nB. $A = 1010_2, B = 0101_2$\n\nC. $A = 1111_2, B = 1111_2$\n\nD. $A = 0000_2, B = 0001_2$\n\nE. $A = 1000_2, B = 1000_2$", "solution": "In a ripple-carry adder, each full adder obeys\n$$S_{i} = A_{i} \\oplus B_{i} \\oplus C_{i}, \\quad C_{i+1} = A_{i} \\cdot B_{i} + (A_{i} \\oplus B_{i}) \\cdot C_{i}.$$\nDefine generate and propagate signals:\n$$G_{i} = A_{i} \\cdot B_{i}, \\quad P_{i} = A_{i} \\oplus B_{i}, \\quad \\text{so } C_{i+1} = G_{i} + P_{i} \\cdot C_{i}.$$\nWith $C_{0}=0$, the longest carry propagation chain from least significant bit to most significant bit requires:\n- At $i=0$: a generated carry, i.e., $G_{0}=1 \\Rightarrow A_{0}=1$ and $B_{0}=1$, so that $C_{1}=1$ despite $C_{0}=0$.\n- For $i=1,2,3$: pure propagation without generate or kill, i.e., $P_{i}=1$ and $G_{i}=0$, which requires $A_{i} \\neq B_{i}$ (complementary bits).\n\nCheck the options:\n- A: $A=1111_{2}, B=0001_{2}$. Bitwise:\n  - $i=0$: $(A_{0},B_{0})=(1,1) \\Rightarrow G_{0}=1$ generates $C_{1}$.\n  - $i=1,2,3$: $(1,0)$ each, so $P_{i}=1$, $G_{i}=0$ propagate the carry through all stages. This yields the full ripple to $C_{4}$.\n- B: $A_{0}=0$, $B_{0}=1 \\Rightarrow G_{0}=0$ and with $C_{0}=0$ no initial carry is produced; no ripple chain starts.\n- C: All bits have $G_{i}=1$, so $C_{i+1}=1$ independent of $C_{i}$; the dependency on the initial carry is cut, so no long ripple chain.\n- D: $A_{0}=0$, $B_{0}=1 \\Rightarrow G_{0}=0$; no initial carry.\n- E: $A_{0}=0$, $B_{0}=0 \\Rightarrow G_{0}=0$; no initial carry.\n\nTherefore only option A creates the longest possible carry propagation chain.", "answer": "$$\\boxed{A}$$", "id": "1958659"}, {"introduction": "The utility of an adder extends far beyond simple addition. With a clever arrangement, the same ripple-carry structure can be adapted to perform subtraction. This final exercise demonstrates this versatility by tasking you with setting up an adder-subtractor circuit [@problem_id:1958663]. By controlling the inputs and the initial carry-in, you will learn how to implement two's complement arithmetic, a foundational technique used in virtually all modern processors.", "problem": "A 4-bit digital circuit is designed to function as an adder-subtractor for two 4-bit unsigned integers, denoted as `A = A_3A_2A_1A_0` and `B = B_3B_2B_1B_0`. The specific operation is selected by a single-bit control input `M`. When the control input `M` is set to 0, the circuit computes the sum `S = A + B`. When `M` is set to 1, the circuit computes the difference `D = A - B` by calculating the two's complement of `B` and adding it to `A`.\n\nDetermine the binary values for each of the nine individual input bits (`A_3, A_2, A_1, A_0, B_3, B_2, B_1, B_0`, and `M`) that must be supplied to the circuit to perform the calculation `7 - 5`.\n\nPresent your answer as a single row matrix containing nine binary digits, with the bits ordered from left to right as `A_3, A_2, A_1, A_0, B_3, B_2, B_1, B_0, M`.", "solution": "We use the standard two's-complement adder-subtractor principle: to compute $A-B$ with a single adder, set the mode bit $M=1$, bitwise invert $B$ (denoted $\\overline{B}$), and add $1$ as the carry-in, so that\n$$\nA-B = A + \\overline{B} + 1.\n$$\nA 4-bit unsigned $7$ is represented as $(0111)_{2}$, so with $A=A_{3}A_{2}A_{1}A_{0}$ we have\n$$\nA_{3}=0,\\quad A_{2}=1,\\quad A_{1}=1,\\quad A_{0}=1.\n$$\nA 4-bit unsigned $5$ is represented as $(0101)_{2}$, so with $B=B_{3}B_{2}B_{1}B_{0}$ we have\n$$\nB_{3}=0,\\quad B_{2}=1,\\quad B_{1}=0,\\quad B_{0}=1.\n$$\nTo perform subtraction, set the control input $M=1$.\n\nOptional check of correctness via two's complement addition:\n$$\n\\overline{B} = 1010,\\quad \\overline{B}+1 = 1011,\\quad A + (\\overline{B}+1) = 0111 + 1011 = 10010,\n$$\nwhose lower $4$ bits are $0010$, i.e., $(2)_{10}$, consistent with $7-5=2$.\n\nTherefore, the required input row (ordered as $A_{3},A_{2},A_{1},A_{0},B_{3},B_{2},B_{1},B_{0},M$) is\n$$\n\\begin{pmatrix}\n0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1\\end{pmatrix}}$$", "id": "1958663"}]}