{"hands_on_practices": [{"introduction": "Many fundamental digital components, like counters, can be elegantly designed as finite state machines. This exercise [@problem_id:1938557] guides you through the synthesis of a 2-bit up/down counter, a practical circuit that changes its counting sequence based on a control input $X$. By determining the logic for the JK flip-flop inputs, you will practice translating a state-dependent behavioral description into a concrete hardware implementation, a core skill in digital design.", "problem": "Design a synchronous 2-bit binary counter using two JK flip-flops. The counter has a single control input, denoted as $X$. The two output bits of the counter are $Q_1$ (most significant bit, MSB) and $Q_0$ (least significant bit, LSB).\n\nThe behavior of the counter is determined by the input $X$ as follows:\n- If $X=0$, the counter counts up through the sequence: 00, 01, 10, 11, and then wraps around to 00.\n- If $X=1$, the counter counts down through the sequence: 00, 11, 10, 01, and then wraps around to 00.\n\nThe state of the counter is represented by the flip-flop outputs $Q_1Q_0$. The JK inputs for the MSB flip-flop are $J_1$ and $K_1$, and for the LSB flip-flop are $J_0$ and $K_0$. Your task is to determine the simplified Boolean expressions for these four inputs as functions of $Q_1$, $Q_0$, and $X$.\n\nWhich of the following sets of equations correctly implements the specified counter?\n\nA. $J_1 = Q_0\\overline{X} + \\overline{Q_0}X$, $K_1 = Q_0\\overline{X} + \\overline{Q_0}X$, $J_0 = 1$, $K_0 = 1$\n\nB. $J_1 = 1$, $K_1 = 1$, $J_0 = Q_1\\overline{X} + \\overline{Q_1}X$, $K_0 = Q_1\\overline{X} + \\overline{Q_1}X$\n\nC. $J_1 = \\overline{Q_0}\\overline{X} + Q_0X$, $K_1 = \\overline{Q_0}\\overline{X} + Q_0X$, $J_0 = 1$, $K_0 = 1$\n\nD. $J_1 = Q_0$, $K_1 = Q_0$, $J_0 = X$, $K_0 = X$\n\nE. $J_1 = Q_0 \\oplus X$, $K_1 = Q_0$, $J_0 = 1$, $K_0 = 1$", "solution": "We design a synchronous 2-bit up/down counter with control input $X$ using two JK flip-flops with outputs $Q_{1}$ (MSB) and $Q_{0}$ (LSB). When a flip-flop must toggle ($Q^{+}=\\overline{Q}$), we can enforce this by setting its inputs $J=K=1$; when it must hold ($Q^{+}=Q$), we can set $J=K=0$.\n\nFirst determine the next-state functions.\n\n1) For the LSB $Q_{0}$:\nFrom both sequences (up and down), $Q_{0}$ toggles every clock. Therefore,\n$$\nQ_{0}^{+} = \\overline{Q_{0}}.\n$$\nTo implement unconditional toggling with a JK flip-flop, choose\n$$\nJ_{0} = 1, \\quad K_{0} = 1.\n$$\n\n2) For the MSB $Q_{1}$:\nCompute $Q_{1}^{+}$ as a function of $Q_{1}$, $Q_{0}$, and $X$.\n\n- If $X=0$ (up): the sequence is $00 \\to 01 \\to 10 \\to 11 \\to 00$, which yields\n$$\nQ_{1}^{+} = Q_{1} \\oplus Q_{0}.\n$$\n- If $X=1$ (down): the sequence is $00 \\to 11 \\to 10 \\to 01 \\to 00$, which yields\n$$\nQ_{1}^{+} = \\overline{Q_{1} \\oplus Q_{0}}.\n$$\nCombining these by multiplexing with $X$,\n$$\nQ_{1}^{+} = (Q_{1} \\oplus Q_{0}) \\oplus X.\n$$\n\nTo drive a JK flip-flop via a toggle signal, use the fact that the toggle condition is $T_{1} = Q_{1} \\oplus Q_{1}^{+}$. Thus,\n$$\nT_{1} = Q_{1} \\oplus \\big((Q_{1} \\oplus Q_{0}) \\oplus X\\big) = Q_{0} \\oplus X,\n$$\nusing associativity and cancellation of $\\oplus$. Therefore set\n$$\nJ_{1} = K_{1} = T_{1} = Q_{0} \\oplus X.\n$$\nIn sum:\n$$\nJ_{1} = K_{1} = Q_{0} \\oplus X = Q_{0}\\,\\overline{X} + \\overline{Q_{0}}\\,X, \\quad J_{0} = 1, \\quad K_{0} = 1.\n$$\nComparing with the options, this matches option A.", "answer": "$$\\boxed{A}$$", "id": "1938557"}, {"introduction": "Finite state machines excel at recognizing specific patterns within a stream of data. This practice [@problem_id:1938558] challenges you to design a Mealy FSM that detects the sequence '011' from a serial input. You will learn to map the detection logic to state transitions and determine the JK flip-flop inputs required to build a circuit that responds to a specific pattern, a key concept in everything from network packet processing to command recognition.", "problem": "A digital system is required to monitor a serial binary input stream, represented by the variable $x$. The system must generate an output $z=1$ for one clock cycle upon the detection of the specific non-overlapping sequence '011'. For any other input, the output $z$ must be 0. The detection process must be implemented as a Mealy-type Finite State Machine (FSM). If the sequence is broken at any point, the machine should reset to a state that allows for the detection of a new sequence starting with '0'. For example, if the input is '010', the final '0' is considered the beginning of a new potential sequence.\n\nThe FSM is to be synthesized using two JK flip-flops, with their outputs denoted as $Q_1$ and $Q_0$. The states are assigned as follows:\n- `S0` (Initial state): $Q_1Q_0 = 00$\n- `S1` (First '0' detected): $Q_1Q_0 = 01$\n- `S2` ('01' detected): $Q_1Q_0 = 11$\n\nThe state $Q_1Q_0 = 10$ is unused. Determine the correct set of simplified Boolean expressions for the flip-flop inputs ($J_1, K_1, J_0, K_0$) and the machine output ($z$). The complement of a variable $A$ is denoted as $\\overline{A}$.\n\nWhich of the following options represents the correct set of logic equations?\n\nA. $J_1 = Q_0 x$, $K_1 = 1$, $J_0 = \\overline{x}$, $K_0 = x$, $z = Q_1 x$\n\nB. $J_1 = Q_0 x$, $K_1 = Q_1$, $J_0 = \\overline{Q_1}\\overline{x}$, $K_0 = Q_1 x$, $z = Q_1 Q_0$\n\nC. $J_1 = Q_0 x$, $K_1 = Q_1$, $J_0 = \\overline{Q_1}\\overline{x}$, $K_0 = Q_1 x$, $z = Q_1 Q_0 x$\n\nD. $J_1 = Q_1$, $K_1 = Q_0 x$, $J_0 = \\overline{Q_1}\\overline{x}$, $K_0 = Q_1 x$, $z = Q_1 Q_0 x$\n\nE. $J_1 = \\overline{Q_0} x$, $K_1 = Q_1$, $J_0 = \\overline{x}$, $K_0 = \\overline{Q_1} x$, $z = Q_0 x$", "solution": "We design a Mealy FSM to detect the non-overlapping pattern 011, with state encoding $Q_{1}Q_{0}$ as $S0=00$, $S1=01$, $S2=11$ and $10$ unused. The required state transitions consistent with non-overlap and the given example are:\n- From $S0$ $(00)$: if $x=0$ then go to $S1$ $(01)$; if $x=1$ then stay at $S0$ $(00)$.\n- From $S1$ $(01)$: if $x=1$ then go to $S2$ $(11)$; if $x=0$ then stay at $S1$ $(01)$ (the new $0$ can be the start).\n- From $S2$ $(11)$: if $x=1$ then the sequence 011 is detected, produce $z=1$ for this clock and go to $S0$ $(00)$ (non-overlap); if $x=0$ then go to $S1$ $(01)$ (the trailing $0$ is a new start, as in the example 010).\n\nThus, the next-state/output table over used states is:\n- $(Q_{1},Q_{0},x)=(0,0,0)\\rightarrow (Q_{1}^{+},Q_{0}^{+})=(0,1),\\ z=0$.\n- $(0,0,1)\\rightarrow (0,0),\\ z=0$.\n- $(0,1,0)\\rightarrow (0,1),\\ z=0$.\n- $(0,1,1)\\rightarrow (1,1),\\ z=0$.\n- $(1,1,0)\\rightarrow (0,1),\\ z=0$.\n- $(1,1,1)\\rightarrow (0,0),\\ z=1$.\n\nUsing the JK flip-flop excitation conditions:\n- For $Q=0\\to Q^{+}=0$: $J=0$ (with $K$ don't care).\n- For $Q=0\\to Q^{+}=1$: $J=1$ (with $K$ don't care).\n- For $Q=1\\to Q^{+}=0$: $K=1$ (with $J$ don't care).\n- For $Q=1\\to Q^{+}=1$: $K=0$ (with $J$ don't care).\n\nDerive $J_{1},K_{1}$ from the rows for $Q_{1}$:\n- When $Q_{1}=0$ and $(Q_{1}^{+}=1)$ occurs only at $(Q_{1},Q_{0},x)=(0,1,1)$, so $J_{1}=1$ only there. A minimal form using used/don't-care rows is\n$$\nJ_{1}=\\overline{Q}_{1}Q_{0}x \\ \\text{which simplifies (using don't cares when }Q_{1}=1\\text{) to}\\ J_{1}=Q_{0}x.\n$$\n- When $Q_{1}=1$ we always require $Q_{1}^{+}=0$ (both inputs in $S2$ go to $Q_{1}^{+}=0$), hence $K_{1}=1$ for $Q_{1}=1$. A minimal expression is\n$$\nK_{1}=Q_{1}.\n$$\n\nDerive $J_{0},K_{0}$ from the rows for $Q_{0}$:\n- When $Q_{0}=0$, $(Q_{0}^{+}=1)$ at $(0,0,0)$ and $(Q_{0}^{+}=0)$ at $(0,0,1)$, hence\n$$\nJ_{0}=\\overline{Q}_{0}\\overline{x}.\n$$\nUsing don't cares in unused states, this is equivalently written as\n$$\nJ_{0}=\\overline{Q}_{1}\\overline{x}.\n$$\n- When $Q_{0}=1$, we require $Q_{0}^{+}=0$ only at $(1,1,1)$, hence\n$$\nK_{0}=Q_{1}x.\n$$\n\nMealy output is asserted only when in $S2$ and $x=1$, therefore\n$$\nz=Q_{1}Q_{0}x.\n$$\n\nCollecting the simplified Boolean expressions that respect used-state behavior and allow simplification with unused/don't-care state, we have\n$$\nJ_{1}=Q_{0}x,\\quad K_{1}=Q_{1},\\quad J_{0}=\\overline{Q}_{1}\\overline{x},\\quad K_{0}=Q_{1}x,\\quad z=Q_{1}Q_{0}x,\n$$\nwhich matches option C.", "answer": "$$\\boxed{C}$$", "id": "1938558"}, {"introduction": "Real-world digital systems often require FSMs that perform multiple functions simultaneously, such as tracking state and processing data. This advanced exercise [@problem_id:1938550] involves creating a Mealy FSM for a serial communication protocol that checks for transmission errors. You will design a system that uses state bits to count incoming data bits while concurrently using another flip-flop to calculate a running parity, providing a practical demonstration of how FSMs are used to ensure data integrity.", "problem": "You are tasked with designing a digital logic circuit that functions as a Mealy-type Finite State Machine (FSM). This FSM is intended for a custom serial communication protocol where data is organized into 4-bit words, arriving one bit per clock cycle on a single input line $X$. The FSM's purpose is to act as an error checker by generating an output signal $E$. The error signal $E$ must be asserted to logic high (1) if and only if, upon the arrival of the fourth bit of a word, that bit's value is not equal to the exclusive-OR (XOR) of the first three bits of the same word. At all other times, and if the check on the fourth bit is successful, $E$ must be logic low (0). After checking each 4-bit word, the FSM must automatically reset to its initial state to correctly process the next word.\n\nThe FSM is to be implemented using three JK flip-flops. Their outputs are labeled $Q_A$, $Q_B$, and $Q_C$. The flip-flops with outputs $Q_A$ and $Q_B$ will function as a state counter to track the position within the 4-bit word. The flip-flop with output $Q_C$ will be used to store the running parity (XOR sum) of the incoming data bits. The FSM begins in a reset state where $Q_A = Q_B = Q_C = 0$. The state assignments for the counter are defined as follows: State S0 (initial) corresponds to $Q_AQ_B=00$, State S1 (after 1 bit) is $Q_AQ_B=01$, State S2 (after 2 bits) is $Q_AQ_B=10$, and State S3 (after 3 bits) is $Q_AQ_B=11$.\n\nDerive the simplified Boolean logic expressions for the inputs ($J_A, K_A, J_B, K_B, J_C, K_C$) of the three JK flip-flops and the expression for the Mealy output $E$. Select the option that correctly provides all seven expressions.\n\nA.\n$J_A=Q_B$\n$K_A=Q_B$\n$J_B=1$\n$K_B=1$\n$J_C=(\\overline{Q_A}+\\overline{Q_B})X$\n$K_C=Q_A Q_B + X(Q_A \\oplus Q_B) + \\overline{X}\\overline{Q_A}\\overline{Q_B}$\n$E=Q_A Q_B(Q_C \\oplus X)$\n\nB.\n$J_A=Q_B$\n$K_A=Q_B$\n$J_B=1$\n$K_B=1$\n$J_C=X$\n$K_C=X$\n$E=Q_A Q_B(Q_C \\oplus X)$\n\nC.\n$J_A=Q_B$\n$K_A=Q_B$\n$J_B=1$\n$K_B=1$\n$J_C=(\\overline{Q_A}+\\overline{Q_B})X$\n$K_C=(\\overline{Q_A}+\\overline{Q_B})\\overline{X} + Q_A Q_B$\n$E=Q_A Q_B(Q_C \\oplus X)$\n\nD.\n$J_A=Q_B$\n$K_A=Q_B$\n$J_B=1$\n$K_B=1$\n$J_C=(\\overline{Q_A}+\\overline{Q_B})X$\n$K_C=Q_A Q_B + X(Q_A \\oplus Q_B) + \\overline{X}\\overline{Q_A}\\overline{Q_B}$\n$E=Q_A Q_B$\n\nE.\n$J_A = Q_A \\oplus Q_B$\n$K_A = \\overline{Q_A \\oplus Q_B}$\n$J_B = \\overline{Q_B}$\n$K_B = Q_B$\n$J_C=X$\n$K_C=X$\n$E=Q_A Q_B(Q_C \\oplus X)$", "solution": "Let the JK flip-flop characteristic equation be\n$$\nQ^{+} = J\\overline{Q} + \\overline{K}Q.\n$$\nA JK flip-flop thus implements: J=K=0 hold, J=1,K=0 set, J=0,K=1 reset, J=K=1 toggle.\n\nCounter with $Q_A,Q_B$ for states S0=00, S1=01, S2=10, S3=11:\n- Choose $J_B=1$, $K_B=1$ so $Q_B$ toggles every clock.\n- Choose $J_A=Q_B$, $K_A=Q_B$ so $Q_A$ toggles when $Q_B=1$ and holds when $Q_B=0$.\nStarting at $Q_AQ_B=00$, this yields the synchronous sequence $00 \\to 01 \\to 10 \\to 11 \\to 00$, as required for counting bits modulo 4.\n\nMealy output condition: On the arrival of the fourth bit (i.e., when the present state is S3 so $Q_AQ_B=11$), assert error if and only if $X \\neq$ parity of the first three bits. Let $Q_C$ hold the running parity before the current input is incorporated, so at S3 it equals the XOR of the first three bits. Therefore,\n$$\nE = Q_A Q_B \\,(Q_C \\oplus X).\n$$\n\nNext-state specification for $Q_C$ within a word:\n- At S0 (before first bit), desired $Q_C^{+} = X$ so that parity after receiving the first bit equals $X$.\n- At S1 and S2, desired $Q_C^{+} = Q_C \\oplus X$ to accumulate parity.\n- At S3 (fourth bit), after checking we must reset parity for the next word, so desired $Q_C^{+} = 0$.\n\nTranslate these into JK controls per state:\n- To force $Q_C^{+} = X$ regardless of $Q_C$ (S0), use $J_C=X$, $K_C=\\overline{X}$ since\n$$\nQ_C^{+} = X\\,\\overline{Q_C} + X\\,Q_C = X.\n$$\n- To implement $Q_C^{+} = Q_C \\oplus X$ (S1,S2), use $J_C=X$, $K_C=X$ (toggle on $X=1$, hold on $X=0$).\n- To force $Q_C^{+} = 0$ (S3), use $J_C=0$, $K_C=1$.\n\nEncode these piecewise controls using the state decoder signals:\n- S0 is $\\overline{Q_A}\\,\\overline{Q_B}$.\n- S1 is $\\overline{Q_A}\\,Q_B$.\n- S2 is $Q_A\\,\\overline{Q_B}$.\n- S3 is $Q_A\\,Q_B$.\n\nFor $J_C$: it must be $X$ in S0,S1,S2 and $0$ in S3. Since S3 is the only state with $Q_AQ_B=11$, the indicator for S0,S1,S2 is $(\\overline{Q_A}+\\overline{Q_B})$. Hence\n$$\nJ_C = (\\overline{Q_A}+\\overline{Q_B})\\,X.\n$$\n\nFor $K_C$: combine the three cases:\n- S0 contributes $\\overline{X}\\,\\overline{Q_A}\\,\\overline{Q_B}$.\n- S1 or S2 contributes $X(\\overline{Q_A}Q_B + Q_A\\overline{Q_B}) = X\\,(Q_A \\oplus Q_B)$.\n- S3 contributes $Q_AQ_B$.\nThus\n$$\nK_C = \\overline{X}\\,\\overline{Q_A}\\,\\overline{Q_B} + X\\,(Q_A \\oplus Q_B) + Q_AQ_B.\n$$\n\nCollecting all, the expressions are\n$$\nJ_A=Q_B,\\quad K_A=Q_B,\\quad J_B=1,\\quad K_B=1,\n$$\n$$\nJ_C=(\\overline{Q_A}+\\overline{Q_B})X,\\quad K_C=Q_A Q_B + X(Q_A \\oplus Q_B) + \\overline{X}\\,\\overline{Q_A}\\,\\overline{Q_B},\n$$\n$$\nE=Q_A Q_B(Q_C \\oplus X),\n$$\nwhich matches option A.", "answer": "$$\\boxed{A}$$", "id": "1938550"}]}