{"hands_on_practices": [{"introduction": "Let's begin with a fundamental building block in digital systems: an edge detector. This exercise challenges you to design a simple Finite State Machine (FSM) that signals when a serial input changes from one clock cycle to the next. This practice [@problem_id:1938276] is an excellent way to grasp the core function of a state element as a one-cycle memory, as the FSM must \"remember\" the previous input to compare it with the current one. You will synthesize a Mealy-type machine, where the output is a direct function of both the state and the current input.", "problem": "A digital circuit is required to monitor a single-bit serial data line, denoted by the input variable $X$. The circuit must generate a high output, $Z=1$, for exactly one clock cycle whenever the input bit $X$ changes its value compared to the previous clock cycle. If the input bit $X$ remains the same as its value in the preceding cycle, the output $Z$ must be low, $Z=0$. This behavior is characteristic of an \"edge detector\".\n\nYou are tasked with designing a Mealy-type Finite State Machine (FSM) to implement this logic. The FSM will be built using a single D-type flip-flop. The state of the FSM, represented by the state variable $S$, is the output of this D flip-flop. The input to the flip-flop is denoted by $D$.\n\nDetermine the minimal Boolean logic expressions for the flip-flop input $D$ and the machine output $Z$ as functions of the machine's present state $S$ and input $X$. Your answer should be selected from the options below.\n\nLet the state $S=0$ correspond to the previous input being 0, and $S=1$ correspond to the previous input being 1. Use the symbol $\\oplus$ to denote the Exclusive OR (XOR) operation.\n\nA. $D = X$; $Z = S \\oplus X$\n\nB. $D = S$; $Z = S \\oplus X$\n\nC. $D = X$; $Z = \\overline{(S \\oplus X)}$\n\nD. $D = S \\oplus X$; $Z = X$\n\nE. $D = \\overline{X}$; $Z = S$", "solution": "We model the FSM with a single D flip-flop whose state is $S$. By the problem’s definition, $S$ encodes the previous input value: if the last input bit was $0$, then $S=0$; if it was $1$, then $S=1$. Thus, at each clock, the next state must update to the current input so that on the next cycle it still represents the previous input. For a D flip-flop, $S^{+}=D$. Hence the requirement that the next state equals the current input is\n$$\nS^{+}=X \\quad \\Rightarrow \\quad D=X.\n$$\nThe output $Z$ must be high exactly when the current input differs from the previous input, and low otherwise. Since $S$ is the previous input, this condition is\n$$\nZ=1 \\;\\text{iff}\\; X \\neq S.\n$$\nThis is precisely the exclusive-OR relation, so\n$$\nZ=S \\oplus X.\n$$\n\nTo verify via explicit state-input cases, for each pair $(S,X)$ we require:\n$$\n(S,X)=(0,0)\\;\\Rightarrow\\; Z=0,\\; S^{+}=0; \\quad\n(S,X)=(0,1)\\;\\Rightarrow\\; Z=1,\\; S^{+}=1;\\\\\n(S,X)=(1,0)\\;\\Rightarrow\\; Z=1,\\; S^{+}=0; \\quad\n(S,X)=(1,1)\\;\\Rightarrow\\; Z=0,\\; S^{+}=1.\n$$\nThese map to\n$$\nZ=\\overline{S}X+S\\overline{X}=S \\oplus X, \\quad S^{+}=X \\Rightarrow D=X.\n$$\nTherefore, the minimal Boolean expressions are $D=X$ and $Z=S \\oplus X$, which correspond to option A.", "answer": "$$\\boxed{A}$$", "id": "1938276"}, {"introduction": "Beyond detecting patterns, FSMs are powerful tools for implementing counters. In this next practice, we move from a Mealy to a Moore machine design to build a counter that tracks the number of '1's in an input stream, modulo 4. This exercise [@problem_id:1938252] will help you practice with multi-bit state representations and understand the characteristics of a Moore FSM, where the output is determined exclusively by the machine's current state. This is a crucial skill for designing circuits that perform sequential arithmetic operations.", "problem": "A digital system is designed to monitor a serial data stream. A component of this system acts as a counter that must continuously count the total number of '1's that have appeared on a single input line, $X$, since the system was last reset. The count is performed modulo 4. The system is to be implemented as a synchronous Moore-type Finite State Machine (FSM).\n\nThe state of the FSM is stored in two D-type flip-flops, with present state outputs $Q_1$ and $Q_0$. The state assignment is chosen to directly represent the count, where the state $(Q_1, Q_0)$ corresponds to the binary representation of the count. For example, a count of 3 is represented by state $(Q_1, Q_0) = (1, 1)$. The machine has a two-bit output, which is not the focus of this problem.\n\nYour task is to determine the minimal sum-of-products (SOP) Boolean expression for the input to the most significant flip-flop, $D_1$. The expression should be in terms of the machine's external input $X$ and its present state variables $Q_1$ and $Q_0$. In your expression, use an overbar to represent negation (e.g., $\\overline{A}$).", "solution": "The machine counts the number of ones modulo 4, with state encoding $(Q_{1},Q_{0}) \\in \\{00,01,10,11\\}$ representing counts $0,1,2,3$, respectively. On each clock:\n- If $X=0$, the count holds: $(Q_{1}^{+},Q_{0}^{+})=(Q_{1},Q_{0})$.\n- If $X=1$, the count increments modulo $4$: $(Q_{1}^{+},Q_{0}^{+})=(Q_{1},Q_{0})+1 \\bmod 4$.\n\nSince the flip-flops are D-type, $D_{1}=Q_{1}^{+}$. Enumerating $Q_{1}^{+}$ for all present states and inputs:\n- From $00$: $X=0 \\Rightarrow 00$ so $Q_{1}^{+}=0$; $X=1 \\Rightarrow 01$ so $Q_{1}^{+}=0$.\n- From $01$: $X=0 \\Rightarrow 01$ so $Q_{1}^{+}=0$; $X=1 \\Rightarrow 10$ so $Q_{1}^{+}=1$.\n- From $10$: $X=0 \\Rightarrow 10$ so $Q_{1}^{+}=1$; $X=1 \\Rightarrow 11$ so $Q_{1}^{+}=1$.\n- From $11$: $X=0 \\Rightarrow 11$ so $Q_{1}^{+}=1$; $X=1 \\Rightarrow 00$ so $Q_{1}^{+}=0$.\n\nThus the minterms where $Q_{1}^{+}=1$ are $(Q_{1},Q_{0},X)=(0,1,1),(1,0,0),(1,0,1),(1,1,0)$, giving the SOP\n$$\nD_{1}=Q_{1}^{+}\n=\\overline{Q_{1}}\\,Q_{0}\\,X+Q_{1}\\,\\overline{Q_{0}}\\,\\overline{X}+Q_{1}\\,\\overline{Q_{0}}\\,X+Q_{1}\\,Q_{0}\\,\\overline{X}.\n$$\nThis expression is minimized by finding prime implicants, for example using a Karnaugh map. The minimal SOP form is:\n$$\nD_{1}=Q_{1}\\,\\overline{Q_{0}}+Q_{1}\\,\\overline{X}+\\overline{Q_{1}}\\,Q_{0}\\,X\n$$\nThis is the sum of the three essential prime implicants required to cover all the minterms.", "answer": "$$\\boxed{Q_{1}\\,\\overline{Q_{0}}+Q_{1}\\,\\overline{X}+\\overline{Q_{1}}\\,Q_{0}\\,X}$$", "id": "1938252"}, {"introduction": "Now, let's apply our skills to a more comprehensive and interactive system: a strategic Rock-Paper-Scissors player. This final practice [@problem_id:1938256] asks you to synthesize an FSM that implements a specific game strategy, responding to an opponent's moves. This problem integrates everything we've covered, requiring you to manage multiple input and output bits, define states that represent past events, and implement conditional state transitions. It’s a great example of how FSMs are used to build intelligent and responsive digital systems.", "problem": "You are tasked with designing a synchronous Mealy Finite State Machine (FSM) for a specialized Rock-Paper-Scissors player. The FSM will be implemented using D flip-flops and will follow a specific defensive strategy.\n\n**System Specification:**\n\n1.  **Inputs and Outputs:** The FSM interacts with an opponent through a two-bit input $(I_1, I_0)$ and produces a two-bit output $(Z_1, Z_0)$. The move encoding is as follows:\n    *   Rock: 01\n    *   Paper: 10\n    *   Scissors: 11\n    The input combination $(I_1, I_0) = (0, 0)$ represents an \"idle\" state where the opponent makes no move.\n\n2.  **Strategy:** The FSM's strategy is to always play the move that would have defeated the opponent's *immediately preceding* valid move. Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.\n    *   For the very first move, when there is no preceding opponent move, the FSM will play Rock as its default move.\n\n3.  **State Machine Behavior:**\n    *   The FSM must remember the opponent's last valid move.\n    *   The FSM transitions to a new state corresponding to the opponent's current move only when a valid move (Rock, Paper, or Scissors) is input.\n    *   If the input is \"idle\" `(0, 0)`, the FSM must remain in its current state.\n\n4.  **Implementation Details:**\n    *   The FSM uses two D flip-flops, with present state variables $(Q_1, Q_0)$.\n    *   The state assignment is defined as:\n        *   $S_0$ (Initial state): $(Q_1, Q_0) = (0, 0)$\n        *   $S_R$ (Opponent's last move was Rock): $(Q_1, Q_0) = (0, 1)$\n        *   $S_P$ (Opponent's last move was Paper): $(Q_1, Q_0) = (1, 0)$\n        *   $S_S$ (Opponent's last move was Scissors): $(Q_1, Q_0) = (1, 1)$\n\n**Task:**\n\nDerive the simplified boolean expressions for the D flip-flop inputs, $D_1$ and $D_0$, and the FSM outputs, $Z_1$ and $Z_0$, in terms of the inputs $I_1, I_0$ and the present state variables $Q_1, Q_0$. Choose the option that correctly represents the set of all four expressions. Note that $A \\oplus B$ represents the XOR operation $A\\overline{B} + \\overline{A}B$.\n\nA.\n$D_1 = I_1 + Q_1 \\overline{I_1} \\overline{I_0}$\n$D_0 = I_0 + Q_0 \\overline{I_1} \\overline{I_0}$\n$Z_1 = Q_1 \\oplus Q_0$\n$Z_0 = Q_1 + \\overline{Q_0}$\n\nB.\n$D_1 = I_1$\n$D_0 = I_0$\n$Z_1 = Q_1 \\oplus Q_0$\n$Z_0 = Q_1 + \\overline{Q_0}$\n\nC.\n$D_1 = I_1 + Q_1 \\overline{I_1} \\overline{I_0}$\n$D_0 = I_0 + Q_0 \\overline{I_1} \\overline{I_0}$\n$Z_1 = Q_1$\n$Z_0 = Q_0$\n\nD.\n$D_1 = I_1 + Q_1 \\overline{I_1} \\overline{I_0}$\n$D_0 = I_0 + Q_0 \\overline{I_1} \\overline{I_0}$\n$Z_1 = Q_1 \\oplus Q_0$\n$Z_0 = \\overline{Q_1} + \\overline{Q_0}$", "solution": "The first step in designing the Finite State Machine (FSM) is to create a complete state table that describes its behavior. The state table includes the present state ($Q_1, Q_0$), the input from the opponent ($I_1, I_0$), the next state ($D_1, D_0$), and the machine's output move ($Z_1, Z_0$).\n\n**1. Determining the Next State ($D_1, D_0$)**\n\nThe next state is determined by the opponent's current input. The state variables $(Q_1, Q_0)$ are used to remember the opponent's last move, so the next state should become the encoding of the opponent's current move.\n- If the input $(I_1, I_0)$ is Rock (01), the next state $(D_1, D_0)$ will be $S_R$ (01).\n- If the input is Paper (10), the next state will be $S_P$ (10).\n- If the input is Scissors (11), the next state will be $S_S$ (11).\n- If the input is \"idle\" (00), the FSM remains in its current state, so $(D_1, D_0) = (Q_1, Q_0)$.\n\nThis logic is independent of the present state, except for the idle case.\n\n**2. Determining the Output ($Z_1, Z_0$)**\n\nThe output is the move that beats the opponent's *previous* move, which is stored in the *present state*.\n- Present State $S_0$ (00, Initial): The FSM plays its default move, Rock (01). So, $(Z_1, Z_0) = (0, 1)$.\n- Present State $S_R$ (01, last move was Rock): The FSM must play Paper (10) to win. So, $(Z_1, Z_0) = (1, 0)$.\n- Present State $S_P$ (10, last move was Paper): The FSM must play Scissors (11) to win. So, $(Z_1, Z_0) = (1, 1)$.\n- Present State $S_S$ (11, last move was Scissors): The FSM must play Rock (01) to win. So, $(Z_1, Z_0) = (0, 1)$.\n\nThe output depends only on the present state, $(Q_1, Q_0)$.\n\n**3. Constructing the State Table**\n\nBased on the logic above, we can construct the full state table.\n\n| Present State | Input | Next State | Output |\n| :---: | :---: | :---: | :---: |\n| $Q_1 Q_0$ | $I_1 I_0$ | $D_1 D_0$ | $Z_1 Z_0$ |\n|---|---|---|---|\n| 0 0 ($S_0$) | 0 0 | 0 0 | 0 1 |\n| 0 0 ($S_0$) | 0 1 | 0 1 | 0 1 |\n| 0 0 ($S_0$) | 1 0 | 1 0 | 0 1 |\n| 0 0 ($S_0$) | 1 1 | 1 1 | 0 1 |\n|---|---|---|---|\n| 0 1 ($S_R$) | 0 0 | 0 1 | 1 0 |\n| 0 1 ($S_R$) | 0 1 | 0 1 | 1 0 |\n| 0 1 ($S_R$) | 1 0 | 1 0 | 1 0 |\n| 0 1 ($S_R$) | 1 1 | 1 1 | 1 0 |\n|---|---|---|---|\n| 1 0 ($S_P$) | 0 0 | 1 0 | 1 1 |\n| 1 0 ($S_P$) | 0 1 | 0 1 | 1 1 |\n| 1 0 ($S_P$) | 1 0 | 1 0 | 1 1 |\n| 1 0 ($S_P$) | 1 1 | 1 1 | 1 1 |\n|---|---|---|---|\n| 1 1 ($S_S$) | 0 0 | 1 1 | 0 1 |\n| 1 1 ($S_S$) | 0 1 | 0 1 | 0 1 |\n| 1 1 ($S_S$) | 1 0 | 1 0 | 0 1 |\n| 1 1 ($S_S$) | 1 1 | 1 1 | 0 1 |\n\n**4. Deriving Boolean Expressions using Karnaugh Maps**\n\nWe use 4-variable K-maps for $D_1$, $D_0$, $Z_1$, and $Z_0$ with inputs $Q_1, Q_0, I_1, I_0$.\n\n**For $D_1$:**\nThe K-map for $D_1$ based on the state table is:\n| $Q_1Q_0 \\setminus I_1I_0$ | 00 | 01 | 11 | 10 |\n|---|---|---|---|---|\n| 00 | 0 | 0 | 1 | 1 |\n| 01 | 0 | 0 | 1 | 1 |\n| 10 | 1 | 0 | 1 | 1 |\n| 11 | 1 | 0 | 1 | 1 |\n\nWe can form two main groups:\n- A group of eight 1s covering the columns where $I_1=1$. This term is $I_1$.\n- A group of two 1s in the $I_1I_0 = 00$ column, where $Q_1=1$. This term is $Q_1 \\overline{I_1} \\overline{I_0}$.\nCombining these gives the Sum-of-Products expression: $D_1 = I_1 + Q_1 \\overline{I_1} \\overline{I_0}$.\n\n**For $D_0$:**\nThe K-map for $D_0$ is:\n| $Q_1Q_0 \\setminus I_1I_0$ | 00 | 01 | 11 | 10 |\n|---|---|---|---|---|\n| 00 | 0 | 1 | 1 | 0 |\n| 01 | 1 | 1 | 1 | 0 |\n| 10 | 0 | 1 | 1 | 0 |\n| 11 | 1 | 1 | 1 | 0 |\n\nWe can form two main groups:\n- A group of eight 1s covering the columns where $I_0=1$. This term is $I_0$.\n- A group of two 1s in the $I_1I_0 = 00$ column, where $Q_0=1$. This term is $Q_0 \\overline{I_1} \\overline{I_0}$.\nCombining these gives: $D_0 = I_0 + Q_0 \\overline{I_1} \\overline{I_0}$.\n\n**For $Z_1$:**\nThe K-map for $Z_1$ is:\n| $Q_1Q_0 \\setminus I_1I_0$ | 00 | 01 | 11 | 10 |\n|---|---|---|---|---|\n| 00 | 0 | 0 | 0 | 0 |\n| 01 | 1 | 1 | 1 | 1 |\n| 10 | 1 | 1 | 1 | 1 |\n| 11 | 0 | 0 | 0 | 0 |\n\nThe output only depends on $Q_1$ and $Q_0$.\n- The row $Q_1Q_0 = 01$ is all 1s, giving the term $\\overline{Q_1}Q_0$.\n- The row $Q_1Q_0 = 10$ is all 1s, giving the term $Q_1\\overline{Q_0}$.\nCombining these gives $Z_1 = \\overline{Q_1}Q_0 + Q_1\\overline{Q_0}$, which is the exclusive-OR operation, $Z_1 = Q_1 \\oplus Q_0$.\n\n**For $Z_0$:**\nThe K-map for $Z_0$ is:\n| $Q_1Q_0 \\setminus I_1I_0$ | 00 | 01 | 11 | 10 |\n|---|---|---|---|---|\n| 00 | 1 | 1 | 1 | 1 |\n| 01 | 0 | 0 | 0 | 0 |\n| 10 | 1 | 1 | 1 | 1 |\n| 11 | 1 | 1 | 1 | 1 |\n\nThe output only depends on $Q_1$ and $Q_0$.\nWe can group the 1s. A large group of eight 1s can be formed by combining the top row ($\\overline{Q_1}\\overline{Q_0}$) and the third row ($Q_1\\overline{Q_0}$). This group corresponds to $\\overline{Q_0}$.\nAnother group of eight 1s can be formed by combining the bottom two rows ($Q_1\\overline{Q_0}$ and $Q_1Q_0$). This group corresponds to $Q_1$.\nThe minimal expression is the OR of these two prime implicants: $Z_0 = Q_1 + \\overline{Q_0}$.\n\n**Conclusion:**\nThe four derived expressions are:\n$D_1 = I_1 + Q_1 \\overline{I_1} \\overline{I_0}$\n$D_0 = I_0 + Q_0 \\overline{I_1} \\overline{I_0}$\n$Z_1 = Q_1 \\oplus Q_0$\n$Z_0 = Q_1 + \\overline{Q_0}$\n\nThis set of equations matches option A.", "answer": "$$\\boxed{A}$$", "id": "1938256"}]}