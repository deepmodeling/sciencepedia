{"hands_on_practices": [{"introduction": "A state table is the blueprint for a sequential circuit's behavior. The most fundamental skill is to read this blueprint and trace the machine's journey through its states given a sequence of inputs. This exercise [@problem_id:1962855] will test your ability to simulate a finite-state machine's operation step-by-step, a crucial process for debugging and understanding any sequential system.", "problem": "A synchronous sequential circuit acts as the core controller for a simple material sorting system. The behavior of this controller is described by a finite-state machine. The machine has four distinct states, denoted `A`, `B`, `C`, and `D`. The transitions between these states are governed by a single-bit input `X`, which comes from a sensor that distinguishes between two types of materials.\n\nThe state transition table for the machine is provided below. The table shows the next state (NS) for each current present state (PS) and for each possible value of the input `X`.\n\n| Present State (PS) | Next State (NS) for X=0 | Next State (NS) for X=1 |\n|:------------------:|:-----------------------:|:-----------------------:|\n|         A          |            B            |            C            |\n|         B          |            A            |            D            |\n|         C          |            D            |            B            |\n|         D          |            C            |            A            |\n\nThe machine is initialized to state `A` before operation begins. An input sequence `X = 1011` is then fed to the machine, with one bit of the sequence being processed per clock cycle. The first bit of the sequence (`1`) is the input during the first clock cycle, the second bit (`0`) is the input during the second clock cycle, and so on.\n\nDetermine the sequence of states that the machine occupies at the end of the first, second, third, and fourth clock cycles, respectively.\n\nSelect the correct sequence from the options below.\n\nA. A, C, D, A\n\nB. B, D, A, B\n\nC. C, B, A, C\n\nD. C, D, A, B\n\nE. C, D, A, C", "solution": "A synchronous finite-state machine updates its state at each clock edge according to a next-state function $f(\\text{PS},X)$ defined by the transition table. From the table, the next-state function is:\n$$\nf(\\text{A},0)=\\text{B},\\quad f(\\text{A},1)=\\text{C},\\quad\nf(\\text{B},0)=\\text{A},\\quad f(\\text{B},1)=\\text{D},\\quad\nf(\\text{C},0)=\\text{D},\\quad f(\\text{C},1)=\\text{B},\\quad\nf(\\text{D},0)=\\text{C},\\quad f(\\text{D},1)=\\text{A}.\n$$\nThe machine starts in state $\\text{A}$ before the first clock, so let $S_{0}=\\text{A}$. The input sequence per cycle is $X_{1}=1$, $X_{2}=0$, $X_{3}=1$, $X_{4}=1$. The state at the end of cycle $k$ is $S_{k}=f(S_{k-1},X_{k})$.\n\nStep-by-step:\n- End of first cycle: $S_{1}=f(\\text{A},1)=\\text{C}$.\n- End of second cycle: $S_{2}=f(\\text{C},0)=\\text{D}$.\n- End of third cycle: $S_{3}=f(\\text{D},1)=\\text{A}$.\n- End of fourth cycle: $S_{4}=f(\\text{A},1)=\\text{C}$.\n\nTherefore, the sequence is $\\text{C}, \\text{D}, \\text{A}, \\text{C}$, which corresponds to option E.", "answer": "$$\\boxed{E}$$", "id": "1962855"}, {"introduction": "Beyond just reading state tables, a key skill is using them as a design tool to implement a specific function. This practice [@problem_id:1962874] challenges you to think like a designer, using logical deduction to complete a state table for a modulo-3 counter. You will see how the required cyclic behavior dictates the missing piece of the design.", "problem": "A synchronous sequential circuit is designed to function as a modulo-3 counter. The circuit has two state variables, $Q_1$ and $Q_0$, which define the present state of the counter. It has a single control input, $EN$. The behavior of the circuit is as follows: if $EN=0$, the counter remains in its current state; if $EN=1$, the counter transitions to the next state in its designated counting sequence.\n\nThe three states used for the modulo-3 count are represented by the binary values $Q_1Q_0$. The mapping of the count values to these binary states is not necessarily in standard binary order. A partial state table describing the circuit's behavior is provided below, but one of the next-state entries is missing and is denoted by `??`.\n\n**Partial State Table:**\n\n| Present State ($Q_1Q_0$) | Input ($EN$) | Next State ($Q_1'Q_0'$) |\n| :---: | :---: | :---: |\n| 00 | 0 | 00 |\n| 00 | 1 | 11 |\n| 01 | 0 | 01 |\n| 01 | 1 | 00 |\n| 11 | 0 | 11 |\n| 11 | 1 | ?? |\n\nWhat is the correct two-bit binary value for the missing next-state entry `??`?\n\nA. 00\n\nB. 01\n\nC. 10\n\nD. 11", "solution": "A modulo-3 counter uses exactly three distinct states and, when enabled with $EN=1$, must advance through these states in a single 3-cycle permutation. From the table, the three valid states are $00$, $01$, and $11$, so the state set is $S=\\{00,01,11\\}$. With $EN=0$, the next state equals the present state, which is already satisfied by the given rows.\n\nFor $EN=1$, the next-state mapping must be a bijection on $S$ forming a single 3-cycle. The given entries specify\n$$\nf(00)=11, \\quad f(01)=00,\n$$\nwhere $f$ is the next-state function under $EN=1$. Starting from $01$ and applying $f$ successively gives\n$$\n01 \\xrightarrow{f} 00 \\xrightarrow{f} 11 \\xrightarrow{f} \\, ?.\n$$\nTo complete a 3-cycle over $S$ without repeating images or leaving $S$, the only consistent choice is\n$$\nf(11)=01.\n$$\nThis yields the cycle $01 \\to 00 \\to 11 \\to 01$, which is a valid modulo-3 counting sequence over the three specified states. Any other choice would either map outside $S$ (e.g., $10$), create a fixed point under $EN=1$ (e.g., $11$), or violate bijectivity by duplicating an image (e.g., mapping to $00$ which is already $f(01)$).\n\nTherefore, the missing next state is $01$, corresponding to option B.", "answer": "$$\\boxed{B}$$", "id": "1962874"}, {"introduction": "In digital design, efficiency is paramount, and minimizing the number of states can lead to smaller, faster circuits. This advanced exercise [@problem_id:1962866] introduces state reduction, a powerful optimization technique. You will learn how to strategically use \"don't care\" conditions to make states compatible, allowing them to be merged into a single, more efficient state.", "problem": "A synchronous sequential circuit is partially described by the state table below. The circuit has one input `x` and one output `z`. The \"don't care\" entries are denoted by `-`.\n\n| Present State | Next State, x=0 | Next State, x=1 | Output, z, x=0 | Output, z, x=1 |\n| :-----------: | :---------------: | :---------------: | :--------------: | :--------------: |\n|       A       |         B         |         C         |        1         |        0         |\n|       B       |         A         |         D         |        0         |        1         |\n|       C       |         E         |         -         |        -         |        0         |\n|       D       |         -         |         A         |        1         |        -         |\n|       E       |         -         |         B         |        1         |        0         |\n\nIn digital logic design, state reduction is a crucial optimization technique. Two states are considered compatible (or mergeable) if their output and next-state specifications do not conflict for any input. Specifically, for any input `x`, their outputs must be identical or one/both must be a \"don't care\". Similarly, their next states must either be identical or form a new pair of compatible states.\n\nYour task is to enable the merging of states `C` and `D` by appropriately defining the \"don't care\" entries in their respective rows. Once these assignments are made, states `C` and `D` are to be merged into a single new state, which we will call `(CD)`. Determine the complete row in the reduced state table for this new state `(CD)`.\n\nWhich of the following represents the row for the merged state `(CD)` in the format `(Next State for x=0, Next State for x=1, Output for x=0, Output for x=1)`?\n\nA. `(E, A, 1, 0)`\n\nB. `(E, A, 1, 1)`\n\nC. `(B, C, 0, 0)`\n\nD. `(E, D, 1, 0)`\n\nE. States C and D cannot be made compatible.", "solution": "To solve this problem, we need to determine the assignments for the \"don't care\" entries (`-`) that will make states `C` and `D` compatible. Two states `S_i` and `S_j` are compatible if, for every input value, their outputs are not contradictory and their next states are a compatible pair.\n\nLet's analyze the compatibility requirements for the pair `(C, D)` for each input `x`.\n\n**Case 1: Input `x = 0`**\n\n1.  **Outputs**: We compare the outputs `z(C, 0)` and `z(D, 0)`.\n    - From the table, `z(C, 0) = -` and `z(D, 0) = 1`.\n    - For these to be compatible, they must not conflict. Since `z(C, 0)` is a \"don't care\", we can assign it the value of `z(D, 0)`.\n    - **Assignment 1**: We must set `z(C, 0) = 1`.\n\n2.  **Next States**: We compare the next states `NS(C, 0)` and `NS(D, 0)`.\n    - From the table, `NS(C, 0) = E` and `NS(D, 0) = -`.\n    - For compatibility, we can assign the \"don't care\" next state to match the specified one.\n    - **Assignment 2**: We must set `NS(D, 0) = E`.\n    - This creates an implied pair requirement that the next states, `(E, E)`, must be compatible. A pair of identical states is always compatible.\n\n**Case 2: Input `x = 1`**\n\n1.  **Outputs**: We compare the outputs `z(C, 1)` and `z(D, 1)`.\n    - From the table, `z(C, 1) = 0` and `z(D, 1) = -`.\n    - For compatibility, we must assign `z(D, 1)` to match `z(C, 1)`.\n    - **Assignment 3**: We must set `z(D, 1) = 0`.\n\n2.  **Next States**: We compare the next states `NS(C, 1)` and `NS(D, 1)`.\n    - From the table, `NS(C, 1) = -` and `NS(D, 1) = A`.\n    - For compatibility, we must assign `NS(C, 1)` a value such that the resulting pair of next states is compatible. The simplest way to achieve this is to assign `NS(C, 1)` to be the same as `NS(D, 1)`.\n    - **Assignment 4**: We set `NS(C, 1) = A`.\n    - This implies that the pair `(A, A)` must be compatible, which is always true. Any other choice for `NS(C, 1)` would introduce a new compatibility requirement on a different state pair, which would need to be checked for conflicts. For instance, setting `NS(C, 1) = B` would require checking the pair `(B, A)`, which have conflicting outputs for `x=0` (`z(B,0)=0`, `z(A,0)=1`), making them incompatible. Thus, setting `NS(C, 1) = A` is the correct and most direct approach.\n\n**Summary of Assignments:**\n- `z(C, 0)` is set to `1`.\n- `NS(D, 0)` is set to `E`.\n- `z(D, 1)` is set to `0`.\n- `NS(C, 1)` is set to `A`.\n\nNow we can write the fully specified rows for states `C` and `D` after these assignments:\n- **Row for C**:\n  - `NS(C, 0) = E` (given)\n  - `NS(C, 1) = A` (assigned)\n  - `z(C, 0) = 1` (assigned)\n  - `z(C, 1) = 0` (given)\n  - Resulting row for C: `(E, A, 1, 0)`\n\n- **Row for D**:\n  - `NS(D, 0) = E` (assigned)\n  - `NS(D, 1) = A` (given)\n  - `z(D, 0) = 1` (given)\n  - `z(D, 1) = 0` (assigned)\n  - Resulting row for D: `(E, A, 1, 0)`\n\nSince both rows are now identical, the states `C` and `D` can be merged into a single new state `(CD)`. The row for this merged state is the common row they both now share.\n\nThe row for the merged state `(CD)` in the format `(Next State for x=0, Next State for x=1, Output for x=0, Output for x=1)` is `(E, A, 1, 0)`.\n\nComparing this result with the given options:\nA. `(E, A, 1, 0)` - Matches our result.\nB. `(E, A, 1, 1)` - Incorrect output for `x=1`.\nC. `(B, C, 0, 0)` - Incorrect next states and outputs.\nD. `(E, D, 1, 0)` - Incorrect next state for `x=1`.\nE. States C and D cannot be made compatible. - Incorrect, we have shown they can.\n\nTherefore, the correct option is A.", "answer": "$$\\boxed{A}$$", "id": "1962866"}]}