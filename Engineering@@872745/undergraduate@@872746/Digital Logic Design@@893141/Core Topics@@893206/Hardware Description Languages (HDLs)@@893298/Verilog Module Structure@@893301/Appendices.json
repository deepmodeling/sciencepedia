{"hands_on_practices": [{"introduction": "The cornerstone of any Verilog design is the `module`, which acts as a black box with a well-defined interface. The module header is this interface's blueprint, specifying the module's name and its ports—the channels through which it communicates with the outside world. This first practice focuses on correctly constructing this header, paying close attention to port names, directions (`input`/`output`), and data widths, which are the essential first steps in creating any hardware component. [@problem_id:1975481]", "problem": "In the design of a digital control system for an automated warehouse, a key component is a module that compares the measured weight of a package against a pre-set reference weight. You are tasked with writing the Verilog module declaration for this digital comparator.\n\nThe module must be named `weight_comparator`. It has the following ports:\n- Two 8-bit inputs: `measured_w` (representing the measured package weight) and `reference_w` (representing the reference weight).\n- Three 1-bit outputs: `is_heavier` (asserted high if `measured_w`  `reference_w`), `is_lighter` (asserted high if `measured_w`  `reference_w`), and `is_equal` (asserted high if `measured_w` == `reference_w`).\n\nWhich of the following Verilog code snippets correctly and completely declares the module and its ports according to these specifications?\n\nA.\n```verilog\nmodule weight_comparator(\n    input [7:0] measured_w,\n    input [7:0] reference_w,\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```\n\nB.\n```verilog\nmodule weight_comparator(\n    input [8:0] measured_w,\n    input [8:0] reference_w,\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```\n\nC.\n```verilog\nmodule weight_comparator(\n    output [7:0] measured_w,\n    output [7:0] reference_w,\n    input is_heavier,\n    input is_lighter,\n    input is_equal\n);\nendmodule\n```\n\nD.\n```verilog\nmodule comparator(\n    input [7:0] measured_w,\n    input [7:0] reference_w,\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```\n\nE.\n```verilog\nmodule weight_comparator(\n    input [7:0] measured_w,\n    input [7:0] reference_w\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```", "solution": "The specification requires:\n- The module name must be exactly weight_comparator.\n- There must be two 8-bit inputs, so each must be declared as input [7:0] measured_w and input [7:0] reference_w.\n- There must be three 1-bit outputs, which can be declared simply as output is_heavier, output is_lighter, and output is_equal.\n- The port list must be syntactically correct, including commas between all port declarations inside the parentheses and a semicolon closing the list.\n\nEvaluate each option:\n- Option A uses the correct module name, declares both inputs as 8-bit with [7:0], declares all three outputs as 1-bit, and the port list syntax is correct with commas after each port and a semicolon after the closing parenthesis. This matches the specification.\n- Option B declares inputs as [8:0], which are 9-bit wide, violating the 8-bit requirement.\n- Option C reverses directions, making the weights outputs and the comparison flags inputs, which contradicts the specification.\n- Option D uses the wrong module name (comparator instead of weight_comparator), violating the naming requirement.\n- Option E omits the comma between the second input and the first output in the port list, making the declaration syntactically incorrect.\n\nTherefore, only Option A is correct and complete.", "answer": "$$\\boxed{A}$$", "id": "1975481"}, {"introduction": "Digital systems are rarely monolithic; they are hierarchical designs built by connecting smaller, reusable modules together. This process, known as instantiation, is how you create a copy of a module and wire it into a larger circuit. This exercise will guide you through using named port connections, a robust and highly recommended practice that makes your code more readable and less prone to errors by explicitly linking ports by name rather than by their order. [@problem_id:1975499]", "problem": "In a digital logic design project, you are tasked with creating a top-level module, named `eight_bit_alu_section`, which utilizes a pre-existing 4-bit adder component. The Verilog module declaration for this adder is provided as follows:\n\n```verilog\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output reg [3:0] sum,\n    output reg cout\n);\n// Internal logic for the 4-bit adder is defined here.\n// You do not need to know the internal logic to solve this problem.\nendmodule\n```\n\nYour `eight_bit_alu_section` module must instantiate one instance of the `four_bit_adder`. The Arithmetic Logic Unit (ALU) section has its own set of ports, which must be connected to the adder instance. The module definition for your design is:\n\n```verilog\nmodule eight_bit_alu_section (\n    input [3:0] operand_X,\n    input [3:0] operand_Y,\n    input initial_carry,\n    output [3:0] result_bus,\n    output final_carry\n);\n// You must place the instantiation code here.\nendmodule\n```\n\nYour task is to instantiate the `four_bit_adder` module within the `eight_bit_alu_section` module. The instance name must be `U1_adder`. The instantiation must use **named port connections** exclusively.\n\nWhich of the following code snippets correctly performs this instantiation?\n\nA.\n```verilog\nfour_bit_adder U1_adder (\n    operand_X,\n    operand_Y,\n    initial_carry,\n    result_bus,\n    final_carry\n);\n```\n\nB.\n```verilog\nfour_bit_adder U1_adder (\n    .operand_X(a),\n    .operand_Y(b),\n    .initial_carry(cin),\n    .result_bus(sum),\n    .final_carry(cout)\n);\n```\n\nC.\n```verilog\nfour_bit_adder U1_adder (\n    .cout(final_carry),\n    .sum(result_bus),\n    .cin(initial_carry),\n    .b(operand_Y),\n    .a(operand_X)\n);\n```\n\nD.\n```verilog\nfour_bit_adder U1_adder (\n    .a(operand_X),\n    .b(operand_Y),\n    .cin(initial_carry),\n    .sum(result_bus)\n);\n```", "solution": "We are given a pre-defined module `four_bit_adder` with formal port names `a`, `b`, `cin`, `sum`, and `cout`. We must instantiate it inside `eight_bit_alu_section` using named port connections, with instance name `U1_adder`, and connect the ALU section’s ports to the adder’s ports as follows:\n- The adder input `a` must connect to `operand_X`.\n- The adder input `b` must connect to `operand_Y`.\n- The adder input `cin` must connect to `initial_carry`.\n- The adder output `sum` must connect to `result_bus`.\n- The adder output `cout` must connect to `final_carry`.\n\nIn Verilog named port association, the left-hand side of each connection is the formal port name of the instantiated module, and the right-hand side is the signal in the enclosing module. Order does not matter when using named connections, but all required ports should be connected to satisfy the intended design.\n\nEvaluate the options:\n- Option A uses positional connections rather than named connections, violating the requirement to use named port connections exclusively. Therefore, A is incorrect.\n- Option B uses named associations but incorrectly uses the enclosing module’s port names on the left-hand side (e.g., `.operand_X(a)`), which is invalid because the left-hand side must be the formal port names of `four_bit_adder` (`a`, `b`, `cin`, `sum`, `cout`). Additionally, the right-hand side identifiers like `a`, `b`, etc., are not defined in `eight_bit_alu_section`. Therefore, B is incorrect.\n- Option C uses named associations with the correct formal port names on the left-hand side and correctly maps them to the enclosing module’s signals: `.cout(final_carry)`, `.sum(result_bus)`, `.cin(initial_carry)`, `.b(operand_Y)`, `.a(operand_X)`. Order is irrelevant for named connections, and all ports are connected. Therefore, C is correct.\n- Option D omits the connection for `cout` (does not connect `final_carry`), leaving an essential output unconnected, which does not satisfy the requirement to connect the module’s ports to the adder instance. Therefore, D is incorrect.\n\nHence, the only correct instantiation is given in option C.", "answer": "$$\\boxed{C}$$", "id": "1975499"}, {"introduction": "A frequent source of bugs for new and experienced designers alike stems from a misunderstanding of port directions and how they relate to data flow. The distinction between an `input`, which receives a signal, and an `output`, which drives a signal, is fundamental to the Verilog concurrency model. In this practice problem, you'll diagnose a common compilation error caused by an incorrect port declaration, reinforcing your understanding of how internal signals drive outputs. [@problem_id:1975461]", "problem": "A junior digital design engineer is tasked with debugging a simple 4-bit Arithmetic Logic Unit (ALU) implemented in Verilog. The module is intended to perform either addition or subtraction on two 4-bit inputs, `A` and `B`, based on a control signal `sub`. When `sub` is 0, it should compute `A + B`. When `sub` is 1, it should compute `A - B`. The results are a 4-bit sum/difference `S` and a single-bit carry-out/borrow-out `C_out`.\n\nDuring compilation, an error is reported, indicating that a net cannot be driven by more than one source. The engineer suspects an error in the module's port direction declarations. Identify the incorrect port declaration in the Verilog code provided below.\n\n```verilog\nmodule adder_subtractor(\n  input  [3:0] A, B,\n  input  sub,\n  input  [3:0] S,\n  output C_out\n);\n\n  // Perform addition or subtraction based on the 'sub' signal\n  assign {C_out, S} = sub ? (A - B) : (A + B);\n\nendmodule\n```\n\nWhich of the following lines contains the incorrect port declaration?\n\nA. `input  [3:0] A, B,`\nB. `input  sub,`\nC. `input  [3:0] S,`\nD. `output C_out`", "solution": "We analyze the port directions in relation to the continuous assignment statement.\n\n- In Verilog, an input port is driven from outside the module and must not be driven by internal assignments. A continuous assignment using the assign keyword drives the net on its left-hand side from within the module.\n- The line assign {C_out, S} = sub ? (A - B) : (A + B); drives both C_out and S internally because they appear on the left-hand side of the assignment.\n- Therefore, any signal on the left-hand side must be declared as an output (or inout), not as an input.\n- In the given declarations:\n  - A and B are used only as sources in the expression; declaring them as inputs is correct.\n  - sub is used only as a control input; declaring it as an input is correct.\n  - C_out appears on the left-hand side and is declared as output; this is correct.\n  - S appears on the left-hand side but is incorrectly declared as input. This causes a multiple-driver error because an input net would be driven both by the external environment and by the internal assign statement.\n\nHence, the incorrect port declaration is the line declaring S as input, which corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1975461"}]}