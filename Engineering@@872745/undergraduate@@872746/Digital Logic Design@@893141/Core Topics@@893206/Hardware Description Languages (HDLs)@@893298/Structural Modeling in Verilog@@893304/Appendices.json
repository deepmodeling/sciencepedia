{"hands_on_practices": [{"introduction": "Structural modeling is akin to building with digital LEGOs, connecting pre-defined blocks to create more complex circuits. This first practice puts that principle into action by tasking you with constructing a 1-bit Arithmetic Logic Unit (ALU) slice [@problem_id:1964327]. By instantiating a full-adder module and wiring it together with primitive logic gates, you will learn how to guide data flow using a control signal to create a versatile component that can perform both arithmetic and logical operations.", "problem": "You are tasked with creating a 1-bit processing slice module in Verilog named `ALU_slice`. This module should be implemented using structural modeling by instantiating gate-level primitives and a provided `full_adder` module.\n\n**Module specification:**\n\nThe `ALU_slice` module has the following ports:\n- Inputs: `a` (1-bit), `b` (1-bit), `cin` (1-bit carry-in), `op` (1-bit operation select).\n- Outputs: `result` (1-bit), `cout` (1-bit carry-out).\n\n**Functional behavior:**\n\nThe module must perform one of two operations based on the `op` signal:\n1.  If `op` is `0`, the module performs a logical XOR operation.\n    - `result` should be `a XOR b`.\n    - `cout` should be `0`.\n2.  If `op` is `1`, the module performs an arithmetic ADD operation.\n    - `result` should be the sum of `a`, `b`, and `cin`.\n    - `cout` should be the carry-out from the addition.\n\n**Structural constraints:**\n\nYour design must structurally instantiate and connect the following components:\n- One `full_adder` module (Verilog code provided below).\n- One primitive `xor` gate for the logical operation.\n- One primitive `and` gate to correctly generate the final `cout` signal.\n- The logic equivalent of a 2-to-1 multiplexer, built from primitive `and`, `or`, `not` gates, to select the final `result`.\n\n**Provided `full_adder` module:**\n\nYou must use the following `full_adder` module without modification.\n\n```verilog\n// full_adder module\n// Outputs: sum, cout\n// Inputs: x, y, z\nmodule full_adder(sum, cout, x, y, z);\n  output sum, cout;\n  input  x, y, z;\n  wire   w1, w2, w3;\n\n  xor(w1, x, y);\n  xor(sum, w1, z);\n  and(w2, x, y);\n  and(w3, w1, z);\n  or(cout, w2, w3);\nendmodule\n```\n\n**Question:**\n\nWhich of the following Verilog code blocks correctly implements the `ALU_slice` module according to all specifications?\n\n**A.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, fa_sum, s_not); // MUX path for op=0 connected to fa_sum\n  and A2(w1, xor_out, op);   // MUX path for op=1 connected to xor_out\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**B.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  assign cout = fa_cout; // Incorrect cout logic\nendmodule\n```\n\n**C.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not); // MUX path for op=0\n  and A2(w1, fa_sum, op);     // MUX path for op=1\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**D.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  // Incorrect port mapping for full_adder\n  full_adder FA(fa_sum, fa_cout, a, b, op); \n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```", "solution": "We need a 1-bit ALU slice that, under control of $op$, selects between:\n- Logical XOR when $op=0$: $result = a \\oplus b$, $cout=0$.\n- Arithmetic add when $op=1$: $result = sum(a,b,cin)$, $cout = carry\\_out(a,b,cin)$.\n\nLet the full adder outputs be $fa\\_sum$ and $fa\\_cout$ for inputs $(a,b,cin)$, so:\n- $fa\\_sum$ is the sum bit of $a+b+cin$,\n- $fa\\_cout$ is the carry-out bit.\n\nWe also instantiate one primitive XOR gate producing $xor\\_out = a \\oplus b$.\n\nThe final $result$ must be selected by a $2$-to-$1$ multiplexer built from primitive gates to satisfy:\n$$\nresult = (\\lnot op) \\cdot (a \\oplus b) \\;\\; \\lor \\;\\; op \\cdot fa\\_sum.\n$$\nThis is realized structurally with one NOT to form $s\\_not=\\lnot op$, two ANDs:\n$$\nw0 = (a \\oplus b) \\cdot (\\lnot op), \\quad w1 = fa\\_sum \\cdot op,\n$$\nand one OR:\n$$\nresult = w0 \\lor w1.\n$$\n\nThe required $cout$ behavior is:\n$$\ncout =\n\\begin{cases}\n0, & op=0, \\\\\nfa\\_cout, & op=1,\n\\end{cases}\n$$\nwhich is exactly the gated expression\n$$\ncout = op \\cdot fa\\_cout,\n$$\nand uses a single primitive AND gate for the final $cout$ as required.\n\nNow check each option against these equations and structural constraints:\n\n- Option A connects the MUX paths as $w0 = fa\\_sum \\cdot (\\lnot op)$ and $w1 = (a \\oplus b) \\cdot op$, giving\n$$\nresult = (\\lnot op)\\cdot fa\\_sum \\;\\lor\\; op \\cdot (a \\oplus b),\n$$\nwhich inverts the required selection. Thus it fails the functional behavior.\n\n- Option B implements the correct MUX:\n$$\nresult = (\\lnot op)\\cdot (a \\oplus b) \\;\\lor\\; op \\cdot fa\\_sum,\n$$\nbut sets $cout = fa\\_cout$ unconditionally, violating $cout=0$ when $op=0$ and the requirement to use a primitive AND for the final $cout$.\n\n- Option C matches exactly:\n  - Full adder on $(a,b,cin)$,\n  - $xor\\_out = a \\oplus b$,\n  - MUX as $result = (\\lnot op)\\cdot (a \\oplus b) \\;\\lor\\; op \\cdot fa\\_sum$ using NOT/AND/OR,\n  - $cout = op \\cdot fa\\_cout$ using one AND.\n  It satisfies both functional behavior and structural constraints.\n\n- Option D incorrectly feeds $op$ as the third input to the full adder instead of $cin$, so the addition ignores $cin$ and is functionally incorrect.\n\nTherefore, the only correct implementation is Option C.", "answer": "$$\\boxed{C}$$", "id": "1964327"}, {"introduction": "Effective digital design relies heavily on hierarchy and reuse, where complex systems are built by composing and enhancing simpler modules. This next exercise focuses on this concept by asking you to design a 4-bit saturating adder [@problem_id:1964323]. Starting with a standard 4-bit adder, you will add a structural layer of logic that detects overflow and clamps the output to its maximum value, a technique crucial for robust arithmetic circuits.", "problem": "You are tasked with designing a 4-bit unsigned saturating adder using structural Verilog. Saturating arithmetic is a version of arithmetic in which operations that would result in an overflow are clamped to the maximum (or minimum) representable value. For this problem, involving a 4-bit unsigned addition, the output should saturate to the maximum value of `4'b1111` upon overflow.\n\nYou are provided with a pre-existing 4-bit ripple-carry adder module, which you can treat as a black box with the following definition:\n\n```verilog\n// Provided 4-bit ripple-carry adder module\nmodule four_bit_adder (\n    output [3:0] sum,\n    output cout,\n    input [3:0] a,\n    input [3:0] b,\n    input cin\n);\n    // The internal implementation correctly performs the operation\n    // {cout, sum} = a + b + cin;\nendmodule\n```\n\nYour task is to design a new module named `saturating_adder` with the following interface:\n\n`module saturating_adder (output [3:0] saturated_sum, input [3:0] a, input [3:0] b);`\n\nThis module must perform the addition of inputs `a` and `b`. For this operation, assume the initial carry-in is `0`. An overflow is defined to have occurred if the 4-bit addition produces a carry-out. If an overflow occurs, the output `saturated_sum` must be clamped to `4'b1111`. Otherwise, `saturated_sum` should be the 4-bit result of the addition.\n\nYour implementation must be purely structural, meaning it should be built by instantiating the provided `four_bit_adder` module and connecting it with fundamental logic (e.g., using primitive gates or continuous assignment statements with bitwise operators). Behavioral constructs like `always` blocks or `if-else` statements are not permitted.\n\nWhich of the following Verilog code snippets correctly implements the `saturating_adder` module according to these specifications?\n\nA.\n```verilog\nmodule saturating_adder (\n    output reg [3:0] saturated_sum,\n    input [3:0] a,\n    input [3:0] b\n);\n    wire [4:0] temp_result;\n    assign temp_result = {1'b0, a} + {1'b0, b};\n    always @(*) begin\n        if (temp_result[4] == 1'b1) begin\n            saturated_sum = 4'b1111;\n        end else begin\n            saturated_sum = temp_result[3:0];\n        end\n    end\nendmodule\n```\n\nB.\n```verilog\nmodule saturating_adder (\n    output [3:0] saturated_sum,\n    input [3:0] a,\n    input [3:0] b\n);\n    wire [3:0] sum_internal;\n    wire overflow;\n    wire not_overflow;\n\n    four_bit_adder adder_inst (\n        .sum(sum_internal), .cout(overflow),\n        .a(a), .b(b), .cin(1'b0)\n    );\n\n    not inv (not_overflow, overflow);\n    assign saturated_sum = (sum_internal & {4{overflow}}) | (4'b1111 & {4{not_overflow}});\nendmodule\n```\n\nC.\n```verilog\nmodule saturating_adder (\n    output [3:0] saturated_sum,\n    input [3:0] a,\n    input [3:0] b\n);\n    wire [3:0] sum_internal;\n    wire overflow;\n    wire not_overflow;\n\n    four_bit_adder adder_inst (\n        .sum(sum_internal), .cout(overflow),\n        .a(a), .b(b), .cin(1'b0)\n    );\n\n    not inv (not_overflow, overflow);\n    assign saturated_sum = (sum_internal & {4{not_overflow}}) | (4'b1111 & {4{overflow}});\nendmodule\n```\n\nD.\n```verilog\nmodule saturating_adder (\n    output [3:0] saturated_sum,\n    input [3:0] a,\n    input [3:0] b\n);\n    wire [3:0] sum_internal;\n    wire overflow;\n    wire not_overflow;\n\n    four_bit_adder adder_inst (\n        .sum(sum_internal), .cout(overflow),\n        .a(a), .b(b)\n    );\n\n    not inv (not_overflow, overflow);\n    assign saturated_sum = (sum_internal & {4{not_overflow}}) | (4'b1111 & {4{overflow}});\nendmodule\n```\n\nE.\n```verilog\nmodule saturating_adder (\n    output [3:0] saturated_sum,\n    input [3:0] a,\n    input [3:0] b\n);\n    wire [3:0] sum_internal;\n    wire overflow;\n    wire not_overflow;\n\n    four_bit_adder adder_inst (\n        .sum(sum_internal), .cout(overflow),\n        .a(a), .b(b), .cin(1'b0)\n    );\n\n    not inv (not_overflow, overflow);\n    assign saturated_sum = (sum_internal & {4{not_overflow}}) | (4'b0000 & {4{overflow}});\nendmodule\n```", "solution": "We need a purely structural module that: (1) instantiates the provided 4-bit adder with carry-in tied to $0$, (2) detects overflow via the adder’s carry-out $cout$, and (3) outputs either the 4-bit sum when there is no overflow, or $4'b1111$ when there is overflow. Structurally, this is a 2-to-1 multiplexer per bit, controlled by the overflow flag. Using bitwise logic and replication, the required equation for the 4-bit output is\n$$\n\\text{saturated\\_sum} = \\left(\\text{sum\\_internal} \\,\\&\\, \\{4\\{\\lnot \\text{overflow}\\}\\}\\right) \\;|\\; \\left(4'b1111 \\,\\&\\, \\{4\\{\\text{overflow}\\}\\}\\right),\n$$\nwhere $\\&$ and $|$ denote bitwise AND and OR, and $\\{4\\{x\\}\\}$ replicates the scalar $x$ into a 4-bit vector.\n\nCheck each option:\n\n- Option A uses an always block and a behavioral if-else, and it does not instantiate the provided adder. This violates the purely structural requirement and the requirement to use the given adder, so it is incorrect.\n\n- Option B instantiates the adder correctly with $\\text{cin}=1'b0$, but its selection logic is inverted:\n$$\n\\text{saturated\\_sum} = \\left(\\text{sum\\_internal} \\,\\&\\, \\{4\\{\\text{overflow}\\}\\}\\right) \\;|\\; \\left(4'b1111 \\,\\&\\, \\{4\\{\\lnot \\text{overflow}\\}\\}\\right).\n$$\nFor $\\text{overflow}=1$, it yields $\\text{sum\\_internal}$ instead of $4'b1111$, and for $\\text{overflow}=0$, it yields $4'b1111$ instead of $\\text{sum\\_internal}$. Therefore, incorrect.\n\n- Option C instantiates the adder with $\\text{cin}=1'b0$ and uses exactly the correct structural selection:\n$$\n\\text{saturated\\_sum} = \\left(\\text{sum\\_internal} \\,\\&\\, \\{4\\{\\lnot \\text{overflow}\\}\\}\\right) \\;|\\; \\left(4'b1111 \\,\\&\\, \\{4\\{\\text{overflow}\\}\\}\\right),\n$$\nwhich outputs $\\text{sum\\_internal}$ when $\\text{overflow}=0$ and $4'b1111$ when $\\text{overflow}=1$. This matches the specification and is purely structural. Therefore, correct.\n\n- Option D omits the $\\text{cin}$ connection in the adder instantiation. The interface requires $\\text{cin}$, and the problem specifies the initial carry-in is $0$. Leaving $\\text{cin}$ unconnected violates this requirement and leads to an undefined or incorrect value for the carry-in. Therefore, incorrect.\n\n- Option E instantiates correctly but forces $4'b0000$ on overflow:\n$$\n\\text{saturated\\_sum} = \\left(\\text{sum\\_internal} \\,\\&\\, \\{4\\{\\lnot \\text{overflow}\\}\\}\\right) \\;|\\; \\left(4'b0000 \\,\\&\\, \\{4\\{\\text{overflow}\\}\\}\\right),\n$$\nwhich yields $4'b0000$ when $\\text{overflow}=1$ instead of $4'b1111$. Therefore, incorrect.\n\nThus, only Option C satisfies all specifications.", "answer": "$$\\boxed{C}$$", "id": "1964323"}, {"introduction": "Our journey into structural modeling culminates with the introduction of state, the memory that allows circuits to perform operations over time. This final practice challenges you to build a bit-serial adder, a design that elegantly combines combinational logic with sequential elements [@problem_id:1964345]. By connecting a single full-adder to a flip-flop that stores the carry between clock cycles, you will master the essential technique of building stateful systems structurally, paving the way for designing more complex sequential machines.", "problem": "You are tasked with designing a 4-bit bit-serial adder in Verilog. A bit-serial adder processes multi-bit numbers one bit at a time on each clock cycle, starting from the least significant bit (LSB). This design must be purely structural, using a pre-defined `full_adder` module and flip-flops for state-holding.\n\nThe `serial_adder` module you are designing has the following interface:\n- **Inputs**:\n    - `clk`: A 1-bit clock signal.\n    - `reset`: A 1-bit active-high asynchronous reset signal. When asserted, the adder should be initialized for a new 4-bit addition.\n    - `a`, `b`: 1-bit inputs representing the current bits of the two numbers being added.\n- **Outputs**:\n    - `s`: A 1-bit output for the current sum bit.\n    - `done`: A 1-bit signal that should be asserted high for exactly one clock cycle, coinciding with the cycle when the most significant bit (MSB) sum is produced.\n\nYou are provided with a `full_adder` module with the following interface:\n`module full_adder(input a, b, cin, output s, cout);`\n\nYour `serial_adder` must be implemented according to these rules:\n1.  It must instantiate exactly one `full_adder`.\n2.  The carry-out from one bit addition must be stored and used as the carry-in for the next bit addition on the subsequent clock cycle. The initial carry-in for the LSB must be 0. This state-holding must be implemented using a register.\n3.  A 2-bit counter must be used to keep track of the bit position being processed (from bit 0 to bit 3). This counter must also be reset by the `reset` signal.\n\nBelow are four potential implementations for the body of the `serial_adder` module. Select the single option that correctly implements the specified 4-bit bit-serial adder.\n\n**Module Header:**\n`module serial_adder(input clk, reset, a, b, output s, done);`\n\n**Code Fragments:**\n\n**A.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b0;\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else if (count == 2'b11)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**B.**\n```verilog\nwire carry;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry), .s(s), .cout(carry));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**C.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b1; // Reset carry to 1\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**D.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(s)); // Incorrect connection\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b0;\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b10); // Incorrect done logic\n```", "solution": "We first restate the required behavior of the 4-bit bit-serial adder:\n\n- Exactly one full adder must be instantiated, with the carry-out from the current bit stored in a register and used as the carry-in on the next clock cycle. The initial carry-in for the least significant bit must be zero, enforced by reset, so the carry register must be asynchronously reset to zero.\n- A 2-bit counter must track the bit index from $0$ through $3$. The counter must be asynchronously reset by the reset signal. The signal $done$ must be asserted high for exactly one clock cycle coincident with the production of the most significant bit sum, i.e., when the current bit index equals $3$.\n\nWe evaluate each option against these rules.\n\nOption A:\n- It instantiates exactly one full adder with connections: $cin$ driven by the registered carry, and $cout$ captured into the carry register on the next clock. The carry register is asynchronously reset to zero:\n  - On $reset$: $carry\\_reg \\leftarrow 0$, satisfying the initial carry-in requirement for the least significant bit.\n  - On each positive clock edge: $carry\\_reg \\leftarrow carry\\_out$, correctly pipelining the carry between bit times.\n- It uses a 2-bit counter with asynchronous reset to zero. On each clock:\n  - If the current count equals $3$, it loads $0$; otherwise, it increments by $1$. This implements the cycle $0 \\to 1 \\to 2 \\to 3 \\to 0 \\to \\dots$ after reset.\n- $done$ is assigned combinationally as $(count == 3)$. Since $s$ in the current cycle is the sum for the current bit index, asserting $done$ when $count=3$ coincides with the MSB sum being produced, and because the counter resets to $0$ on the next cycle, $done$ is high for exactly one cycle per four-bit addition sequence. This matches the requirement.\n\nTherefore, A satisfies all constraints.\n\nOption B:\n- The carry is a wire fed both into $cin$ and from $cout$, which creates a combinational loop and, more importantly, does not implement the required registered carry with initial zero. There is no register to hold carry and no reset of carry to zero, violating the state-holding requirement and the initial carry-in requirement.\n- Although a 2-bit counter exists and $done$ is asserted when $count=3$, the lack of a carry register disqualifies this option.\n\nOption C:\n- The carry register is asynchronously reset to one, i.e., on $reset$: $carry\\_reg \\leftarrow 1$, which violates the requirement that the initial carry-in for the least significant bit must be zero.\n- The counter increments each cycle and is asynchronously reset to zero; even though the 2-bit width causes natural wrap-around, the incorrect carry initialization already makes this option invalid.\n\nOption D:\n- The full adder’s $cout$ is incorrectly connected to the $s$ port, and the declared $carry\\_out$ is not connected to the full adder’s $cout$, making the carry register update meaningless.\n- The $done$ logic asserts when $count=2$, not when $count=3$, so it does not coincide with the MSB sum.\n- These wiring and logic errors violate the specified behavior.\n\nFrom this analysis, only Option A correctly implements the specified 4-bit bit-serial adder: it uses exactly one full adder, correctly registers and resets the carry to zero, employs a resettable 2-bit counter that sequences through $0$ to $3$, and asserts $done$ exactly when the MSB sum bit is produced for exactly one cycle.", "answer": "$$\\boxed{A}$$", "id": "1964345"}]}