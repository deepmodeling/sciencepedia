{"hands_on_practices": [{"introduction": "A Parallel-In, Parallel-Out (PIPO) register has two primary modes: loading new data in parallel and holding its current data. This first practice exercise [@problem_id:1950446] is designed to solidify your understanding of these fundamental operations, which are controlled by the `LOAD` signal. By tracing the state of a register through a simple sequence of load and hold commands, you will master the basic behavior that is the foundation for using PIPO registers in digital systems.", "problem": "A 4-bit synchronous digital register has a 4-bit parallel data input $D = D_3D_2D_1D_0$ and a 4-bit parallel output $Q = Q_3Q_2Q_1Q_0$. The state of the register updates on the rising edge of a clock signal. The behavior of the register is controlled by a signal named `LOAD`. The next state of the register, denoted as $Q_{next}$, is determined by the current state, $Q_{current}$, and the input data, $D$, as follows:\n- If `LOAD` is high (logic 1), the register performs a parallel load operation on the next clock edge: $Q_{next} = D$.\n- If `LOAD` is low (logic 0), the register holds its current value on the next clock edge: $Q_{next} = Q_{current}$.\n\nConsider the following sequence of events:\n1. Initially, before any clock pulses, the output of the register is $Q = 1011_2$.\n2. The parallel data input is held constant at $D = 1101_2$.\n3. The `LOAD` signal is set to high for the duration of the first clock cycle. It is then set to low for the duration of the second clock cycle.\n4. The system is clocked twice.\n\nWhat is the 4-bit binary value of the output $Q$ immediately after the second clock pulse? Express your answer as a 4-bit binary string (e.g., 1001).", "solution": "We model the synchronous register update on each rising clock edge using the specified control:\n- If LOAD is high, then on the next rising edge $Q_{next} = D$.\n- If LOAD is low, then on the next rising edge $Q_{next} = Q_{current}$ (hold).\n\nLet $Q^{(k)}$ denote the register output immediately after the $k$-th clock pulse. The initial condition before any clock pulses is given by\n$$\nQ^{(0)} = 1011_{2}.\n$$\nThe input data is constant,\n$$\nD = 1101_{2}.\n$$\nDuring the first clock cycle, LOAD is high. Therefore, on the first rising edge,\n$$\nQ^{(1)} = Q_{next} = D = 1101_{2}.\n$$\nDuring the second clock cycle, LOAD is low. Therefore, on the second rising edge, the register holds its current value:\n$$\nQ^{(2)} = Q_{next} = Q_{current} = Q^{(1)} = 1101_{2}.\n$$\nThus, immediately after the second clock pulse, the output is $1101$.", "answer": "$$\\boxed{1101}$$", "id": "1950446"}, {"introduction": "Building on the basic operations, it's crucial to understand the architectural principles that govern a register's behavior. This next exercise [@problem_id:1950439] moves from calculation to conceptual reasoning, asking why a standard PIPO register cannot simultaneously load new data into some bits while holding the existing data in others. Answering this question deepens your understanding of how a single, shared control signal acts globally across all the register's flip-flops.", "problem": "A digital systems engineer is designing a special-purpose 4-bit data buffer for a control system. A standard 4-bit Parallel-In, Parallel-Out (PIPO) register is available for use. This PIPO register is constructed from four edge-triggered D-type flip-flops and has four parallel data inputs ($D_3, D_2, D_1, D_0$) and four parallel data outputs ($Q_3, Q_2, Q_1, Q_0$). All four flip-flops are connected to a common clock (CLK) signal. The register's loading behavior is governed by a single, active-high load enable (LOAD) control line that is also common to all flip-flops. When LOAD is asserted (logic high), the data on the parallel inputs is loaded into the flip-flops on the next active clock edge. When LOAD is de-asserted (logic low), the flip-flops hold their currently stored values, ignoring the inputs.\n\nThe design specification requires a \"selective update\" operation. During this operation, the two most significant bits (MSBs) of the buffer, corresponding to outputs $Q_3$ and $Q_2$, must be updated with new values from their respective inputs, $D_3$ and $D_2$. Simultaneously, the two least significant bits (LSBs), corresponding to outputs $Q_1$ and $Q_0$, must retain their current stored values, unaffected by any data on inputs $D_1$ and $D_0$. The engineer attempts to implement this functionality using the single, standard PIPO register described.\n\nWhich of the following statements correctly identifies the fundamental reason why this implementation using a single, standard PIPO register will fail to achieve the desired selective update? Select the single best answer.\n\nA. The common clock signal forces all flip-flops to change their state on every active edge, making it impossible to hold any bits.\n\nB. The propagation delay through the flip-flops for the LSBs and MSBs is inherently different, leading to a race condition that corrupts the data.\n\nC. A PIPO register is only capable of loading data serially; it cannot update multiple bits in parallel.\n\nD. The single, shared LOAD enable signal acts globally on all flip-flops, preventing a mix of load and hold operations within the same clock cycle.\n\nE. D-type flip-flops are incapable of holding their previous state and will always pass the D input to the Q output when clocked.", "solution": "Let the common load enable be denoted by $L$, the common clock be CLK, and consider each bit $i \\in \\{3,2,1,0\\}$ with input $D_{i}$ and output $Q_{i}$. For a standard edge-triggered D-type flip-flop with a synchronous load enable, the next-state function for each bit is governed by the same enable $L$:\n$$\nQ_{i}^{+} = L D_{i} + \\overline{L}\\, Q_{i}.\n$$\nThis Boolean relation states that when $L=1$ (LOAD asserted), the next state equals the input ($Q_{i}^{+}=D_{i}$), and when $L=0$ (LOAD de-asserted), the next state equals the present state ($Q_{i}^{+}=Q_{i}$), i.e., hold.\n\nBecause the same $L$ is common to all four flip-flops in the single PIPO register, the transition for all bits is globally determined by the single value of $L$ during a given clock edge:\n- If $L=1$, then for all $i \\in \\{3,2,1,0\\}$, $Q_{i}^{+}=D_{i}$, so all four bits load.\n- If $L=0$, then for all $i \\in \\{3,2,1,0\\}$, $Q_{i}^{+}=Q_{i}$, so all four bits hold.\n\nThe required selective update specifies that $Q_{3}$ and $Q_{2}$ must load ($Q_{3}^{+}=D_{3}$ and $Q_{2}^{+}=D_{2}$) while simultaneously $Q_{1}$ and $Q_{0}$ must hold ($Q_{1}^{+}=Q_{1}$ and $Q_{0}^{+}=Q_{0}$) on the same clock edge. From the equation above, achieving $Q_{3}^{+}=D_{3}$ and $Q_{2}^{+}=D_{2}$ requires $L=1$, but achieving $Q_{1}^{+}=Q_{1}$ and $Q_{0}^{+}=Q_{0}$ requires $L=0$. A single, shared $L$ cannot be both $1$ and $0$ at the same clock edge. Therefore, with one standard PIPO register and a single global LOAD line, it is impossible to realize the mix of load and hold in the same cycle.\n\nEvaluating the options:\n- A is incorrect because edge-triggered D flip-flops do hold when the synchronous load path is disabled; the clock alone does not force a change in state.\n- B is incorrect; propagation delay differences do not create the fundamental impossibility of selective update with a single global enable.\n- C is incorrect; a PIPO register inherently supports parallel loading.\n- D is correct; the single, shared LOAD enable acts globally, preventing mixed load/hold behavior within the same clock edge.\n- E is incorrect; D flip-flops can hold their previous state when the input path is not selected by the synchronous enable.\n\nHence, the fundamental reason is the global nature of the single LOAD signal.", "answer": "$$\\boxed{D}$$", "id": "1950439"}, {"introduction": "Real-world digital systems are not always perfect; manufacturing defects can introduce faults that alter a component's behavior. This final practice [@problem_id:1950454] challenges you to apply your knowledge in a diagnostic scenario by analyzing a PIPO register with an internal fault. By predicting the output of the faulty device, you will sharpen your troubleshooting skills and gain a deeper appreciation for the connection between a register's logical function and its physical implementation using multiplexers and flip-flops.", "problem": "An 8-bit Parallel-In, Parallel-Out (PIPO) shift register, with outputs labeled $Q_7, Q_6, \\dots, Q_0$, is constructed from eight positive-edge-triggered D flip-flops. The register has a single control signal, `LOAD`. The behavior of the register is determined by the `LOAD` signal as follows:\n- If `LOAD = 1`, the register performs a parallel load operation on the next rising clock edge. Each flip-flop $Q_i$ is updated with the value from the corresponding parallel data input $D_i$.\n- If `LOAD = 0`, the register holds its current state. Each flip-flop $Q_i$ retains its value on the next rising clock edge.\n\nInternally, this logic is implemented using a 2-to-1 multiplexer for each D flip-flop. The multiplexer selects between the external data input $D_i$ (for loading) and the flip-flop's own output $Q_i$ (for holding). A manufacturing defect has occurred in the register: the multiplexer corresponding to the flip-flop for bit $Q_4$ is faulty. It is permanently stuck selecting the 'hold' input path (i.e., its output is always connected to $Q_4$), regardless of the state of the `LOAD` signal. All other bits ($Q_7, Q_6, Q_5, Q_3, Q_2, Q_1, Q_0$) function correctly according to the `LOAD` signal.\n\nThe register is initialized to the state $Q = 10101010$. It is then subjected to a sequence of three clock pulses with the following control and data inputs:\n1.  **Clock Pulse 1:** `LOAD` = 1, Parallel Data `D` = 11110000.\n2.  **Clock Pulse 2:** `LOAD` = 0.\n3.  **Clock Pulse 3:** `LOAD` = 1, Parallel Data `D` = 00001111.\n\nDetermine the 8-bit binary value stored in the register, represented as the string $Q_7Q_6Q_5Q_4Q_3Q_2Q_1Q_0$, immediately after the third clock pulse. Present your answer as an 8-bit binary string.", "solution": "The register uses positive-edge-triggered D flip-flops with a 2-to-1 multiplexer at each input. For each bit $i \\in \\{0,1,\\dots,7\\}$, the ideal update rule on a rising edge is:\n$$\nQ_{i}^{+}=\n\\begin{cases}\nD_{i}, & \\text{if LOAD}=1,\\\\\nQ_{i}, & \\text{if LOAD}=0,\n\\end{cases}\n$$\nwhere $Q_{i}^{+}$ denotes the value after the clock edge. Due to the defect, the multiplexer for bit $i=4$ is stuck selecting the hold path, so its update rule is:\n$$\nQ_{4}^{+}=Q_{4} \\quad \\text{for all values of LOAD and } D_{4}.\n$$\n\nInitial state: $Q_{7}Q_{6}Q_{5}Q_{4}Q_{3}Q_{2}Q_{1}Q_{0}=10101010$, so $Q_{7}=1$, $Q_{6}=0$, $Q_{5}=1$, $Q_{4}=0$, $Q_{3}=1$, $Q_{2}=0$, $Q_{1}=1$, $Q_{0}=0$.\n\nClock pulse 1 with LOAD $=1$ and $D=11110000$ (i.e., $D_{7}=1$, $D_{6}=1$, $D_{5}=1$, $D_{4}=1$, $D_{3}=0$, $D_{2}=0$, $D_{1}=0$, $D_{0}=0$):\n- For $i \\neq 4$: $Q_{i}^{+}=D_{i}$.\n- For $i=4$: $Q_{4}^{+}=Q_{4}=0$.\nThus after pulse 1,\n$$\nQ=Q_{7}\\dots Q_{0}=11100000.\n$$\n\nClock pulse 2 with LOAD $=0$:\n- For all $i$: $Q_{i}^{+}=Q_{i}$ (and specifically $Q_{4}^{+}=Q_{4}$).\nThus after pulse 2,\n$$\nQ=11100000.\n$$\n\nClock pulse 3 with LOAD $=1$ and $D=00001111$ (i.e., $D_{7}=0$, $D_{6}=0$, $D_{5}=0$, $D_{4}=0$, $D_{3}=1$, $D_{2}=1$, $D_{1}=1$, $D_{0}=1$):\n- For $i \\neq 4$: $Q_{i}^{+}=D_{i}$.\n- For $i=4$: $Q_{4}^{+}=Q_{4}=0$.\nThus after pulse 3,\n$$\nQ=00001111.\n$$\n\nTherefore, immediately after the third clock pulse, the 8-bit value stored is $00001111$.", "answer": "$$\\boxed{00001111}$$", "id": "1950454"}]}