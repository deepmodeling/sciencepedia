{"hands_on_practices": [{"introduction": "The utility of a shift register extends far beyond simple data transport. By creating a feedback loop that connects the serial output back to the serial input, we transform the register into a \"ring counter.\" This exercise [@problem_id:1959699] challenges you to predict the long-term behavior of such a circuit, revealing its inherent periodic nature which is fundamental for generating timing signals and control sequences in digital systems.", "problem": "A digital system employs an $N$-bit Serial-In, Serial-Out (SISO) shift register. This register consists of a chain of $N$ flip-flops, where the output of one flip-flop serves as the input to the next. The register is configured to be a right-shift register, meaning that on each active clock edge, the bit in position $i$ (for $i=1, 2, ..., N-1$) moves to position $i+1$. A new bit is loaded into position 1, designated as the Most Significant Bit (MSB), and the bit from position $N$, the Least Significant Bit (LSB), is shifted out as the serial output.\n\nIn a specific application, the register has $N=12$ bits. It is initially loaded with the binary pattern `110100101110`, where the leftmost bit is the MSB. A feedback loop is then implemented by permanently connecting the serial output from the LSB (position 12) back to the serial input for the MSB (position 1).\n\nAfter this modification, the system's clock is allowed to run for $k=987$ cycles. Which of the following 12-bit binary strings represents the state of the register (from MSB to LSB) after the completion of the 987th clock cycle?\n\nA. `110110100101`\n\nB. `100101110110`\n\nC. `101101001011`\n\nD. `110100101110`\n\nE. `111110100101`", "solution": "A right-shift register with the LSB fed back to the MSB performs a cyclic right rotation of the entire $N$-bit word on each clock. Let the initial $12$-bit state be denoted by $S^{(0)}$. After $k$ clock cycles, the state is the initial word rotated right by $k \\bmod 12$ positions, because the mapping is periodic with period $N=12$:\n$$\nk \\equiv r \\pmod{12} \\;\\;\\Rightarrow\\;\\; S^{(k)}=\\text{RotateRight}\\big(S^{(0)},\\, r\\big).\n$$\nCompute the residue:\n$$\n987 = 12 \\cdot 82 + 3 \\;\\;\\Rightarrow\\;\\; 987 \\equiv 3 \\pmod{12}.\n$$\nThus the register state after $987$ cycles is the initial word rotated right by $3$ positions. The initial word is 110100101110; its last three bits are 110 and the first nine bits are 110100101, so the three-right-rotation yields\n$$\n\\text{RotateRight}\\big(110100101110,\\,3\\big) = 110\\,110100101 = 110110100101,\n$$\nwhich matches option A.", "answer": "$$\\boxed{A}$$", "id": "1959699"}, {"introduction": "Shift registers are cornerstone components in building computer arithmetic circuits. This practice [@problem_id:1908895] delves into one of their most significant applications: performing binary multiplication using the classic \"add-and-shift\" algorithm. By tracing the state of the accumulator and multiplier registers through each clock cycle, you will gain a concrete understanding of how complex operations are broken down into a sequence of simple, hardware-level micro-operations.", "problem": "Consider a digital circuit designed to multiply two 4-bit unsigned binary numbers. The multiplier uses an add-and-shift algorithm implemented with the following components:\n- Register `M`: A 4-bit register that holds the constant multiplicand.\n- Register `A`: A 4-bit accumulator, initialized to `0000`.\n- Register `Q`: A 4-bit shift register that is initially loaded with the multiplier.\n- Register `C`: A 1-bit carry register, initialized to `0`.\n\nThe multiplication process is synchronous and controlled by a clock. At each clock cycle, the following sequence of micro-operations occurs:\n1.  The least significant bit of register `Q`, denoted `Q_0`, is examined.\n2.  If `Q_0` is `1`, the multiplicand `M` is added to the accumulator `A`. The 4-bit result is stored back in `A`, and the carry-out of the addition is stored in the carry register `C`. If `Q_0` is `0`, `A` and `C` are unchanged.\n3.  The combined 9-bit register formed by `C`, `A`, and `Q` (in the order `C:A:Q`) is shifted one bit to the right. The bit from `C` shifts into the most significant bit of `A` (`A_3`), the least significant bit of `A` (`A_0`) shifts into the most significant bit of `Q` (`Q_3`), and the least significant bit of `Q` (`Q_0`) is discarded.\n4.  After the shift, the carry register `C` is reset to `0` to prepare for the next cycle's potential addition.\n\nSuppose the multiplicand register `M` is loaded with the value `1101` and the multiplier register `Q` is loaded with `1011`. The system is initialized with `A = 0000` and `C = 0` before the first clock cycle.\n\nDetermine the contents of registers `A` and `Q` after the system has completed exactly three full clock cycles. Present your answer as a single 8-bit binary string, representing the concatenation of the contents of register `A` followed by the contents of register `Q`. For example, if at some point `A = 0001` and `Q = 1010`, the corresponding string would be `00011010`.", "solution": "We simulate the specified add-and-shift multiplication for three cycles with $M=1101$, initial $A=0000$, $Q=1011$, and $C=0$. At each cycle:\n- If $Q_{0}=1$, compute the 4-bit sum $A \\leftarrow A+M$ with carry-out to $C$; if $Q_{0}=0$, leave $A$ and $C$ unchanged.\n- Perform a right shift of the 9-bit $C:A:Q$:\n  $$A_{3} \\leftarrow C,\\quad A_{2} \\leftarrow A_{3},\\quad A_{1} \\leftarrow A_{2},\\quad A_{0} \\leftarrow A_{1},$$\n  $$Q_{3} \\leftarrow A_{0}\\ \\text{(old)},\\quad Q_{2} \\leftarrow Q_{3},\\quad Q_{1} \\leftarrow Q_{2},\\quad Q_{0} \\leftarrow Q_{1},$$\n  then reset $C \\leftarrow 0$.\n\nCycle 1:\n- $Q_{0}=1$, so add $M$ to $A$:\n  $$A \\leftarrow 0000+1101=1101,\\quad C \\leftarrow 0.$$\n- Shift right $C:A:Q = 0:1101:1011$:\n  $$A \\leftarrow 0110,\\quad Q \\leftarrow 1101,\\quad C \\leftarrow 0.$$\n\nCycle 2:\n- $Q_{0}=1$, so add $M$ to $A$:\n  $$A \\leftarrow 0110+1101=0011,\\quad C \\leftarrow 1.$$\n- Shift right $C:A:Q = 1:0011:1101$:\n  $$A \\leftarrow 1001,\\quad Q \\leftarrow 1110,\\quad C \\leftarrow 0.$$\n\nCycle 3:\n- $Q_{0}=0$, so no addition:\n  $$A \\leftarrow 1001,\\quad C \\leftarrow 0.$$\n- Shift right $C:A:Q = 0:1001:1110$:\n  $$A \\leftarrow 0100,\\quad Q \\leftarrow 1111,\\quad C \\leftarrow 0.$$\n\nAfter exactly three full clock cycles, the contents are $A=0100$ and $Q=1111$, so the requested 8-bit string (concatenation $A$ followed by $Q$) is $01001111$.", "answer": "$$\\boxed{01001111}$$", "id": "1908895"}, {"introduction": "Bringing a digital design from concept to reality requires translating its logic into a Hardware Description Language (HDL) like Verilog. However, this translation has subtleties that can lead to unexpected behavior. This problem [@problem_id:1915890] presents a seemingly correct but flawed Verilog implementation of a shift register, challenging you to diagnose the issue by understanding the critical difference between blocking (`=`) and non-blocking (`<=`) assignmentsâ€”a vital skill for any digital designer.", "problem": "A junior engineer is designing a 4-bit register as part of a larger digital system using a Hardware Description Language (HDL), specifically Verilog. The register has a synchronous reset, a parallel load capability, and a serial shift-right function. The engineer produced the following code snippet, which contains a subtle but critical flaw.\n\nThe relevant signals and registers are declared as follows:\n- `clk`: The master clock signal.\n- `rst`: A synchronous, active-high reset signal.\n- `load`: A control signal that, when high, enables parallel loading of data.\n- `p_in`: A 4-bit input `[3:0]` for parallel loading.\n- `s_in`: A 1-bit serial input for the shift operation.\n- `q3`, `q2`, `q1`, `q0`: Four 1-bit registers that form the 4-bit state of the system.\n\nThe sequential logic is described by the following `always` block:\n```verilog\nalways @(posedge clk) begin\n    if (rst) begin\n        q3 = 1'b0;\n        q2 = 1'b0;\n        q1 = 1'b0;\n        q0 = 1'b0;\n    end else if (load) begin\n        q3 = p_in[3];\n        q2 = p_in[2];\n        q1 = p_in[1];\n        q0 = p_in[0];\n    end else begin\n        // Intended shift-right operation\n        q3 = s_in;\n        q2 = q3;\n        q1 = q2;\n        q0 = q1;\n    end\nend\n```\nThe state of the register is represented by the concatenated value `{q3, q2, q1, q0}`, where `q3` is the most significant bit (MSB). Initially, the state of the registers is unknown. The system is then subjected to the following input sequence, which is sampled at the positive edge of `clk`:\n\n- At the 1st positive clock edge: `rst = 1'b1`.\n- At the 2nd positive clock edge: `rst = 1'b0`, `load = 1'b1`, `p_in = 4'b1011`.\n- At the 3rd positive clock edge: `rst = 1'b0`, `load = 1'b0`, `s_in = 1'b1`.\n\nWhat is the decimal value of the register, interpreted as `{q3, q2, q1, q0}`, immediately after the 3rd positive clock edge?\n\nA. 11\n\nB. 13\n\nC. 14\n\nD. 15\n\nE. 8", "solution": "The problem requires us to trace the state of the four 1-bit registers (`q3`, `q2`, `q1`, `q0`) through three consecutive positive clock edges, based on a given Verilog code snippet. The key to solving this problem is to correctly interpret the behavior of the blocking assignments, denoted by the `=` operator, within the sequential `always` block.\n\n**Initial State:** Before the first clock edge, the values of `q3, q2, q1, q0` are unknown (`xxxx`).\n\n**1st Positive Clock Edge:**\nAt the first `posedge clk`, the inputs are sampled. The `rst` signal is high (`1'b1`).\nThe `if (rst)` condition in the `always` block is true.\nThe code executes the reset block:\n```verilog\nq3 = 1'b0;\nq2 = 1'b0;\nq1 = 1'b0;\nq0 = 1'b0;\n```\nAll four registers are assigned the value `0`.\nThe state of the register `{q3, q2, q1, q0}` becomes `4'b0000`.\n\n**2nd Positive Clock Edge:**\nAt the second `posedge clk`, the inputs `rst = 1'b0`, `load = 1'b1`, and `p_in = 4'b1011` are sampled.\n- The `if (rst)` condition is false.\n- The `else if (load)` condition is true.\nThe code executes the parallel load block:\n```verilog\nq3 = p_in[3]; // q3 = 1'b1\nq2 = p_in[2]; // q2 = 1'b0\nq1 = p_in[1]; // q1 = 1'b1\nq0 = p_in[0]; // q0 = 1'b1\n```\nThe registers are loaded with the parallel input data. Even though these are blocking assignments, there are no dependencies between the statements in this block (the value of `q3` is not used to determine `q2`, etc.), so the behavior is straightforward.\nThe state of the register `{q3, q2, q1, q0}` becomes `4'b1011`.\n\n**3rd Positive Clock Edge:**\nThis is the critical step for analysis. At the third `posedge clk`, the inputs `rst = 1'b0`, `load = 1'b0`, and `s_in = 1'b1` are sampled. The state of the register just before this clock edge is `4'b1011`.\n- The `if (rst)` condition is false.\n- The `else if (load)` condition is false.\nThe code executes the final `else` block, which contains the faulty shift implementation:\n```verilog\nq3 = s_in;\nq2 = q3;\nq1 = q2;\nq0 = q1;\n```\nBecause these are blocking assignments (`=`), each statement is executed sequentially, and the result of one assignment is immediately visible to the next statement within the same simulation time step. Let's trace the execution:\n1.  `q3 = s_in;`\n    The value of `s_in` is `1'b1`. The register `q3` is updated to `1`. The value of `q3` is now `1` for the subsequent statements in this block.\n\n2.  `q2 = q3;`\n    This statement reads the *new* value of `q3`, which was just set to `1`. Therefore, `q2` is updated to `1`. The value of `q2` is now `1` for the subsequent statements.\n\n3.  `q1 = q2;`\n    This statement reads the *new* value of `q2`, which was just set to `1`. Therefore, `q1` is updated to `1`. The value of `q1` is now `1` for the subsequent statements.\n\n4.  `q0 = q1;`\n    This statement reads the *new* value of `q1`, which was just set to `1`. Therefore, `q0` is updated to `1`.\n\nAfter all statements in the block have been executed, the final state of the registers is updated. The result is that the value of `s_in` (`1'b1`) has propagated through the entire chain of registers in a single clock cycle.\nThe state of the register `{q3, q2, q1, q0}` becomes `4'b1111`.\n\nThis behavior is incorrect for a shift register, which should shift the contents by one position per clock cycle. A correct implementation would use non-blocking assignments (`<=`), which schedule all updates to occur simultaneously at the end of the time step, using the values of the variables as they were at the beginning of the time step.\n\nFinally, we convert the binary result to decimal:\nThe binary value `1111_2` is calculated as $1 \\times 2^{3} + 1 \\times 2^{2} + 1 \\times 2^{1} + 1 \\times 2^{0} = 8 + 4 + 2 + 1 = 15$.\n\nTherefore, the decimal value of the register after the 3rd clock edge is 15. This corresponds to option D.\nThe common incorrect answer is 13, which would result from assuming the code implements a correct shift-right operation (yielding `{s_in, q3, q2, q1}` = `{1, 1, 0, 1}` = `4'b1101`) or from misinterpreting the blocking assignments as non-blocking.", "answer": "$$\\boxed{D}$$", "id": "1915890"}]}