{"hands_on_practices": [{"introduction": "Digital computers operate with a finite number of bits, which means the range of numbers they can represent is limited. This exercise explores a critical consequence of this limitation: arithmetic overflow. By working through a simple addition on a 4-bit processor, you will learn to identify when an overflow occurs and understand how the system stores the resulting, often misleading, value. [@problem_id:1914561]", "problem": "A prototype for a low-power environmental sensor uses a specialized 4-bit processor to perform initial data filtering. This processor represents signed integers using the 4-bit two's complement number system. In a test run, the processor is tasked with adding two sensor readings, which are represented by the binary values $X = 0110_2$ and $Y = 0100_2$. The sum is stored in a 4-bit register. Which of the following statements accurately describes the outcome of this addition?\n\nA. The addition results in the correct decimal value of +10, and no overflow occurs.\n\nB. The addition results in an overflow, and the stored 4-bit binary value represents the decimal value -6.\n\nC. The addition results in an overflow, and the stored 4-bit binary value represents the decimal value +2.\n\nD. The addition does not result in an overflow, and the stored 4-bit binary value is $0000_2$.\n\nE. The addition results in an overflow, and the stored 4-bit binary value is identical to the representation of the largest possible negative number in this system.", "solution": "In a 4-bit two's complement system, the representable range is given by $[-2^{n-1},\\,2^{n-1}-1]$ with $n=4$, hence $[-8,\\,7]$. The given operands are $X=0110_{2}$ and $Y=0100_{2}$, both with most significant bit $0$, so both are nonnegative. Converting to decimal, $0110_{2}=+6$ and $0100_{2}=+4$, so the true mathematical sum is $+10$, which lies outside the representable range, indicating overflow is expected.\n\nPerform the 4-bit addition:\n- Bit $0$: $0+0=0$, carry $0$.\n- Bit $1$: $1+0=1$, carry $0$.\n- Bit $2$: $1+1=0$ with carry $1$.\n- Bit $3$ (MSB): $0+0+\\text{carry }1=1$ with carry out $0$.\n\nThus the 4-bit stored result is\n$$0110_{2}+0100_{2}=1010_{2}.$$\nOverflow detection in two's complement can be checked by either rule: adding two operands with the same sign yields a result with the opposite sign, or the carry into the MSB differs from the carry out of the MSB. Here, both operands have sign bit $0$ and the result has sign bit $1$, so overflow occurs. Equivalently, the carry into the MSB is $1$ while the carry out is $0$, so overflow occurs.\n\nInterpret the stored 4-bit value $1010_{2}$ in two's complement: since the MSB is $1$, it is negative. Its magnitude is obtained by two's complementing:\n$$\\text{invert}(1010_{2})=0101_{2},\\quad 0101_{2}+0001_{2}=0110_{2},$$\nso $1010_{2}$ represents $-6$ in decimal.\n\nTherefore, the addition results in an overflow, and the stored 4-bit binary value represents the decimal value $-6$, matching option B.", "answer": "$$\\boxed{B}$$", "id": "1914561"}, {"introduction": "In digital systems, it is common to move data between components with different bit-widths, requiring numbers to be \"extended\". This practice delves into the crucial distinction between zero-extension and sign-extension, two methods that yield vastly different results. This exercise will solidify your understanding of how the interpretation of a number—as signed or unsigned—dictates the correct extension procedure and affects subsequent calculations. [@problem_id:1914502]", "problem": "A digital system's 8-bit Arithmetic Logic Unit (ALU) operates on signed integers using the 2's complement representation. The ALU is designed to perform the addition of two 8-bit operands, $X$ and $Y$.\n\nFor a particular operation, the first operand is fixed as $X = 01011010_2$.\n\nThe second operand, $Y$, is derived from a 4-bit input value $B = 1100_2$. Before the addition can occur, $B$ must be extended to 8 bits. Two different extension methods are being evaluated:\n\n1.  **Zero-Extension**: The 4-bit value $B$ is extended to an 8-bit operand, $Y_{zero}$, by padding it with four leading zeros.\n2.  **Sign-Extension**: The 4-bit value $B$ is interpreted as a 4-bit 2's complement number and extended to an 8-bit operand, $Y_{sign}$, using the standard sign-extension procedure.\n\nThe ALU calculates two separate results: $R_{zero} = X + Y_{zero}$ and $R_{sign} = X + Y_{sign}$. The results $R_{zero}$ and $R_{sign}$ are both stored as 8-bit signed 2's complement numbers.\n\nCalculate the difference between the decimal integer values of the two results, defined as $Value(R_{zero}) - Value(R_{sign})$. Provide the final answer as a single decimal integer.", "solution": "The 8-bit signed two's complement range is $[-2^{7},\\,2^{7}-1]=[-128,\\,127]$. The 4-bit signed two's complement range is $[-2^{3},\\,2^{3}-1]=[-8,\\,7]$.\n\nThe fixed operand is $X=01011010_{2}$. Since the most significant bit is $0$, $X$ is nonnegative. Its value is computed by place values:\n$$\nX=0\\cdot 2^{7}+1\\cdot 2^{6}+0\\cdot 2^{5}+1\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=64+16+8+2=90.\n$$\n\nThe 4-bit input is $B=1100_{2}$.\n- Zero-extension pads four leading zeros: $Y_{\\text{zero}}=00001100_{2}$. Interpreted as an 8-bit signed integer with most significant bit $0$, its value is\n$$\nY_{\\text{zero}}=0\\cdot 2^{7}+0\\cdot 2^{6}+0\\cdot 2^{5}+0\\cdot 2^{4}+1\\cdot 2^{3}+1\\cdot 2^{2}+0\\cdot 2^{1}+0\\cdot 2^{0}=8+4=12.\n$$\n- Sign-extension first interprets $B$ as a 4-bit two's complement number. Since the most significant bit of $B$ is $1$, it is negative. Using the signed-weight expansion,\n$$\nB=1\\cdot(-2^{3})+1\\cdot 2^{2}+0\\cdot 2^{1}+0\\cdot 2^{0}=-8+4=-4.\n$$\nSign-extending to 8 bits by replicating the sign bit yields $Y_{\\text{sign}}=11111100_{2}$, whose 8-bit two's complement value is also $-4$ (consistent with sign-extension preserving value).\n\nThe ALU results are\n$$\nR_{\\text{zero}}=X+Y_{\\text{zero}}=90+12=102,\\qquad R_{\\text{sign}}=X+Y_{\\text{sign}}=90+(-4)=86,\n$$\nboth of which lie within $[-128,127]$, so no overflow occurs.\n\nTherefore, the requested difference is\n$$\n\\text{Value}(R_{\\text{zero}})-\\text{Value}(R_{\\text{sign}})=102-86=16.\n$$\nEquivalently, by linearity,\n$$\n\\text{Value}(R_{\\text{zero}})-\\text{Value}(R_{\\text{sign}})=(X+Y_{\\text{zero}})-(X+Y_{\\text{sign}})=Y_{\\text{zero}}-Y_{\\text{sign}}=12-(-4)=16.\n$$", "answer": "$$\\boxed{16}$$", "id": "1914502"}, {"introduction": "Beyond basic arithmetic, bitwise operations provide a powerful toolkit for performing complex manipulations efficiently at the hardware level. This advanced problem challenges you to think like a computer scientist, using bitwise logic to implement a key function from an advanced data structure known as a Fenwick Tree. By analyzing different C-style expressions, you will discover elegant and non-obvious ways to isolate and modify specific bits within a number, a skill essential for performance optimization in software and hardware design. [@problem_id:1914548]", "problem": "In the study of data structures, the Binary Indexed Tree (BIT), also known as a Fenwick Tree, provides an efficient method for calculating prefix sums. A key operation within a BIT is finding the \"parent\" of a given index. For any positive integer index `i`, its parent, let's denote it as `p(i)`, is defined as the index obtained by turning off (i.e., changing from 1 to 0) the least significant set bit in the binary representation of `i`.\n\nFor example, if `i = 28`, its binary representation is `11100`. The least significant set bit is the rightmost '1', which corresponds to the value 4 (binary `100`). Turning this bit off results in the binary number `11000`, which is `24` in decimal. Therefore, `p(28) = 24`.\n\nConsider a programming language like C that uses a standard two's complement representation for signed integers. Your task is to identify which of the following C-style expressions correctly compute `p(i)` for any given positive integer `i`. Select all options that are mathematically equivalent to the definition of `p(i)`.\n\nA. `i  (i - 1)`\n\nB. `i ^ (i - 1)`\n\nC. `i + (i  -i)`\n\nD. `i  ~(i  -i)`\n\nE. `i ^ (i  -i)`\n\nF. `i | (i + 1)`", "solution": "The problem asks us to identify all C-style expressions that compute the parent `p(i)` of a positive integer index `i`. The parent `p(i)` is defined as the number obtained by turning off the least significant set bit (LSB) of `i`.\n\nLet's represent `i` in binary. Any positive integer `i` can be written in the form `i = X10...0`, where `X` represents the more significant bits and the `1` is the least significant set bit, followed by some number of zeros. Let `lsb(i)` denote the value of this least significant set bit. For example, if `i=28` (binary `11100`), `X` is `110`, the LSB is at position `2^2=4`, so `lsb(28) = 4` (binary `100`). The operation of turning off the LSB is equivalent to subtracting its value from the original number: `p(i) = i - lsb(i)`. For `i=28`, `p(28) = 28 - 4 = 24`.\n\nA well-known property of two's complement arithmetic is that the expression `i  -i` isolates the least significant set bit of `i`. Let's verify this. The value `-i` in two's complement is computed as `~i + 1`.\nIf `i = X10...0`, then `~i = (~X)01...1`.\nAdding 1 gives `~i + 1 = (~X)10...0`.\nThen `i  -i` is `(X10...0)  ((~X)10...0)`. Since `X  ~X` is `0`, the result is `0...010...0`, which is exactly `lsb(i)`.\n\nWe will now evaluate each option.\n\n**A. `i  (i - 1)`**\nIf `i` has the binary form `X10...0`, then `i - 1` has the form `X01...1`.\nThe bitwise AND operation `i  (i - 1)` performs `(X10...0)  (X01...1)`.\nThe result is `X00...0`. This is `i` with its LSB turned off. This matches the definition of `p(i)`.\nFor example, `i = 28` (`11100`). `i - 1 = 27` (`11011`). `28  27` is `11100  11011 = 11000`, which is 24.\n**Therefore, option A is correct.**\n\n**B. `i ^ (i - 1)`**\nThis expression computes the bitwise XOR between `i` and `i-1`.\nUsing the example `i = 28` (`11100`) and `i - 1 = 27` (`11011`):\n`28 ^ 27` is `11100 ^ 11011 = 00111`, which is 7. This is not 24.\n**Therefore, option B is incorrect.**\n\n**C. `i + (i  -i)`**\nAs established, `i  -i` is `lsb(i)`. So this expression is `i + lsb(i)`.\nThis operation adds the value of the LSB to `i`, which is used to find the \"next\" index in a Fenwick Tree update, not the parent.\nFor `i = 28`, `lsb(28) = 4`. The expression evaluates to `28 + 4 = 32`. This is not 24.\n**Therefore, option C is incorrect.**\n\n**D. `i  ~(i  -i)`**\nThe sub-expression `i  -i` resolves to `lsb(i)`.\nThe `~` operator performs a bitwise NOT. So, `~(i  -i)` creates a bitmask where all bits are 1 except for the bit at the position of the LSB of `i`, which is 0.\nPerforming a bitwise AND between `i` and this mask (`i  mask`) will keep all bits of `i` as they are, except for the LSB, which will be forced to 0. This is the definition of `p(i)`.\nFor `i = 28` (`11100`), `lsb(28) = 4` (`00100` in 5 bits). `~4` is `11011`. `28  ~4` is `11100  11011 = 11000`, which is 24.\n**Therefore, option D is correct.**\n\n**E. `i ^ (i  -i)`**\nThis expression is `i ^ lsb(i)`.\nThe bitwise XOR operation `a ^ b` flips the bits in `a` where the corresponding bits in `b` are 1.\nSince `lsb(i)` is a power of two, its binary representation has exactly one bit set to 1.\n`i ^ lsb(i)` will therefore flip only one bit in `i`: the one at the LSB's position. By definition, this bit is 1 in `i`, so XORing with `lsb(i)` will change it to 0, leaving all other bits of `i` unchanged. This matches the definition of `p(i)`.\nFor `i = 28`, `lsb(28) = 4`. `28 ^ 4` is `11100 ^ 00100 = 11000`, which is 24.\n**Therefore, option E is correct.**\n\n**F. `i | (i + 1)`**\nThis expression computes the bitwise OR between `i` and `i+1`.\nUsing the example `i = 28` (`11100`) and `i + 1 = 29` (`11101`):\n`28 | 29` is `11100 | 11101 = 11101`, which is 29. This is not 24.\n**Therefore, option F is incorrect.**\n\nIn summary, the expressions that correctly compute `p(i)` are A, D, and E.", "answer": "$$\\boxed{ADE}$$", "id": "1914548"}]}