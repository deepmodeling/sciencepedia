{"hands_on_practices": [{"introduction": "Before performing complex arithmetic, it is essential to master the fundamentals of number representation. This first exercise focuses on the crucial skill of converting a binary number from one's complement format back into its familiar decimal form. By working through this problem, you will practice the core rule of checking the sign bit and, if necessary, performing a bitwise inversion to determine the number's true magnitude [@problem_id:1949333].", "problem": "An engineer is analyzing data from a legacy digital control system. This system uses a 6-bit word length for its internal registers and represents signed integers using the one's complement number system. A particular register holds the binary value $110110_2$. Determine the decimal (base-10) equivalent of this 6-bit one's complement number.", "solution": "The system uses 6-bit one's complement. In one's complement, the most significant bit indicates the sign: a leading $1$ means the number is negative, and the magnitude is obtained by bitwise complementing the code word.\n\nGiven $110110$, the MSB is $1$, so the value is negative. Complement all bits to obtain the magnitude bits:\n$$\\overline{110110}=001001.$$\nConvert $001001$ to decimal:\n$$001001=0\\cdot 2^{5}+0\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+0\\cdot 2^{1}+1\\cdot 2^{0}=8+1=9.$$\nTherefore, the represented value is\n$$-9.$$\nAs a cross-check using the one's complement mapping $V=W-(2^{n}-1)$ for codes with MSB $=1$, with $n=6$ and unsigned $W=54$:\n$$V=54-(2^{6}-1)=54-63=-9,$$\nconsistent with the result above.", "answer": "$$\\boxed{-9}$$", "id": "1949333"}, {"introduction": "Moving from static representation to arithmetic, we now explore the most distinctive feature of one's complement operations: the \"end-around carry.\" This sequential problem has you increment a negative number multiple times, forcing you to apply this unique carry rule to ensure the calculation remains correct. This practice is key to understanding how one's complement arithmetic logically handles transitions across the zero boundary [@problem_id:1949343].", "problem": "A legacy 4-bit microprocessor is under analysis. This processor uses one's complement representation for signed integers. In this system, negative numbers are formed by taking the bitwise complement (inverting all bits) of their positive counterparts. Addition is performed using standard binary arithmetic, with the critical rule that if an addition operation results in a carry-out from the most significant bit, this carry bit must be added to the least significant bit of the result. This procedure is known as an end-around carry.\n\nA specific register in this processor is initialized with the value corresponding to the decimal number $-2$. Subsequently, the processor executes an \"increment\" instruction three times in succession. Each \"increment\" instruction performs a binary addition of the value $+1$ (represented as `0001` in 4-bit binary) to the current value stored in the register.\n\nLet $R_0$ be the initial 4-bit binary value in the register representing $-2$. Let $R_1$, $R_2$, and $R_3$ be the 4-bit binary values in the register after the first, second, and third increment operations, respectively. Which of the following options correctly lists the sequence of binary values $(R_1, R_2, R_3)$?\n\nA. `(1110, 1111, 0001)`\n\nB. `(1110, 1111, 0000)`\n\nC. `(1111, 0000, 0001)`\n\nD. `(1011, 1100, 1101)`\n\nE. `(1111, 0001, 0010)`", "solution": "In a 4-bit one's complement system, a negative number is formed by bitwise complementing the positive magnitude. The positive value $+2$ is $0010_{2}$, so the initial register value representing $-2$ is\n$$\nR_{0} = \\overline{0010} = 1101_{2}.\n$$\nEach increment adds $+1$, represented as $0001_{2}$, using binary addition with an end-around carry: if there is a carry-out from the most significant bit, that carry is added to the least significant bit of the sum.\n\nFirst increment:\n$$\nR_{1} = R_{0} + 0001_{2} = 1101_{2} + 0001_{2} = 1110_{2},\n$$\nwith no carry-out, so $R_{1} = 1110$.\n\nSecond increment:\n$$\nR_{2} = R_{1} + 0001_{2} = 1110_{2} + 0001_{2} = 1111_{2},\n$$\nwith no carry-out, so $R_{2} = 1111$.\n\nThird increment:\n$$\nR_{3} = R_{2} + 0001_{2} = 1111_{2} + 0001_{2} = 0000_{2} \\text{ with carry-out } 1.\n$$\nApply end-around carry:\n$$\n0000_{2} + 0001_{2} = 0001_{2},\n$$\nso $R_{3} = 0001$.\n\nTherefore, the sequence is $(R_{1}, R_{2}, R_{3}) = (1110, 1111, 0001)$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1949343"}, {"introduction": "Every fixed-width number system has its limits, and understanding them is critical for reliable computation. This final practice confronts the issue of \"overflow,\" which occurs when a calculation's result is too large to be stored correctly. By adding two positive numbers that produce an invalid negative result, you will learn the fundamental method for detecting overflow: checking if the sign of the result is inconsistent with the signs of the operands [@problem_id:1949378].", "problem": "An engineer is tasked with verifying the behavior of a legacy 8-bit microprocessor, which is known to use one's complement representation for signed integers. In this system, positive numbers have a sign bit of 0, while negative numbers have a sign bit of 1 and are represented by the bitwise NOT of their positive counterparts.\n\nThe engineer performs a test operation by instructing the processor's Arithmetic Logic Unit (ALU) to add the decimal values $+70$ and $+80$. The ALU performs the addition and stores the output in an 8-bit register. An overflow flag is set if the addition of two numbers with the same sign results in a number with the opposite sign.\n\nBased on the rules of 8-bit one's complement arithmetic, determine the decimal value corresponding to the binary pattern in the result register and whether an overflow occurred.\n\nA: The result is -105, and an overflow has occurred.\n\nB: The result is -106, and an overflow has occurred.\n\nC: The result is -105, and no overflow has occurred.\n\nD: The result is +150, and an overflow has occurred.\n\nE: The result is -106, and no overflow has occurred.", "solution": "In 8-bit one's complement, positive values have sign bit $0$ and are represented in standard binary; negative values have sign bit $1$ and are represented as the bitwise NOT of the corresponding positive magnitude. The representable range is from $-127$ to $+127$.\n\nEncode the operands:\n$+70$ in 8-bit binary is $0100\\,0110_{2}$, and $+80$ is $0101\\,0000_{2}$.\n\nPerform the 8-bit binary addition (with possible end-around carry if there is a carry out of the most significant bit):\n$$0100\\,0110_{2} + 0101\\,0000_{2} = 1001\\,0110_{2}.$$\nThere is no carry out of the most significant bit, so no end-around carry is added.\n\nInterpret the result $1001\\,0110_{2}$ in one's complement. Since the sign bit is $1$, it is negative. Its magnitude is obtained by bitwise NOT:\n$$\\text{NOT}(1001\\,0110_{2}) = 0110\\,1001_{2}.$$\nCompute the magnitude:\n$$0110\\,1001_{2} = 64 + 32 + 8 + 1 = 105.$$\nHence, the stored result corresponds to $-105$.\n\nDetermine overflow. The given rule states that an overflow flag is set if adding two numbers with the same sign yields a result with the opposite sign. Both inputs are positive (sign bit $0$), and the result has sign bit $1$, so overflow occurred. Equivalently, the carry into the sign bit is $1$ while the carry out is $0$, which also indicates overflow in one's complement addition.\n\nTherefore, the correct choice is that the result is $-105$ and an overflow has occurred.", "answer": "$$\\boxed{A}$$", "id": "1949378"}]}