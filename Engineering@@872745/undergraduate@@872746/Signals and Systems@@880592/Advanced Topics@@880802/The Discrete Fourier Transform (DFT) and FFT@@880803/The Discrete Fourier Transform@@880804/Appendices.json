{"hands_on_practices": [{"introduction": "The Discrete Fourier Transform (DFT) acts as a prism for digital signals, separating them into their constituent frequencies. To grasp this fundamental principle, our first practice involves analyzing a signal that is itself one of the DFT's core building blocksâ€”a pure complex exponential. By calculating the DFT of this ideal 'tone', you will directly observe how the transform pinpoints the frequency content of a signal with perfect precision. [@problem_id:1759639]", "problem": "In digital signal processing, the Discrete Fourier Transform (DFT) is a fundamental tool for analyzing the frequency content of a finite-length signal. Consider a simplified model of a pure tone signal after sampling. This signal, denoted as $x[n]$, is represented by a single complex exponential.\n\nThe signal is a sequence of length $N$ defined as:\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\nfor the time index $n = 0, 1, \\ldots, N-1$. Here, $k_0$ is an integer constant representing the normalized frequency of the tone, and it satisfies $0 \\le k_0  N$.\n\nYour task is to compute the $N$-point DFT of this signal. The DFT, denoted by $X[k]$, is defined by the analysis equation:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\nwhere $k$ is the frequency index, taking integer values from $k = 0, 1, \\ldots, N-1$.\n\nFind a single, closed-form analytic expression for $X[k]$ in terms of $N$, $k$, and $k_0$.", "solution": "We start from the DFT analysis equation and substitute the given signal. By definition,\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\nWith $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$, this becomes\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\nDefine the ratio\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\nThen\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\nThis is a finite geometric series. Using the geometric series sum,\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r},  r \\neq 1, \\\\\nN,  r = 1,\n\\end{cases}\n$$\nand noting that\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\nwe have:\n- If $r \\neq 1$ (equivalently $k \\neq k_{0}$ for $k,k_{0}\\in\\{0,\\ldots,N-1\\}$), then $1 - r^{N} = 0$ while $1 - r \\neq 0$, so $X[k] = 0$.\n- If $r = 1$ (equivalently $k = k_{0}$), then every term of the sum equals $1$, so $X[k] = N$.\n\nCombining these cases gives the closed-form expression\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\nwhere $\\delta_{k,k_{0}}$ is the Kronecker delta, equal to $1$ if $k=k_{0}$ and $0$ otherwise.", "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$", "id": "1759639"}, {"introduction": "Once a signal is transformed into the frequency domain, its DFT is represented by magnitude and phase values for each frequency component. This exercise challenges you to investigate the relative importance of these two pieces of information by hypothetically reconstructing a signal using only one of them. Through this thought experiment, you will gain a deeper intuition for why signal processing experts often say that phase carries the crucial structural information of a signal. [@problem_id:2387193]", "problem": "Consider a real-valued, length-$N$ discrete-time sequence $x[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$ with indices understood modulo $N$. Its Discrete Fourier Transform (DFT) $X[k]$ and inverse DFT (IDFT) are defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-j \\frac{2\\pi}{N}kn}, \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\n$$\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{j \\frac{2\\pi}{N}kn}, \\quad n \\in \\{0,1,\\dots,N-1\\}.\n$$\nWrite $X[k] = |X[k]|\\, e^{j\\phi[k]}$ with $|X[k]|\\ge 0$ and $\\phi[k]\\in \\mathbb{R}$ the magnitude and phase, and adopt the convention that if $|X[k]|=0$ then $\\phi[k]=0$.\n\nDefine two reconstructions:\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} |X[k]|\\, e^{j \\frac{2\\pi}{N}kn}, \\quad\nz[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} e^{j\\phi[k]} \\, e^{j \\frac{2\\pi}{N}kn}.\n$$\nLet the periodic discrete-time autocorrelation of a sequence $u[n]$ be\n$$\nr_u[m] = \\sum_{n=0}^{N-1} u[n]\\, \\overline{u[n-m]}, \\quad m \\in \\{0,1,\\dots,N-1\\},\n$$\nwith indices modulo $N$. Let $\\delta[n-n_0]$ denote the $N$-periodic Kronecker delta that equals $1$ when $n \\equiv n_0 \\pmod{N}$ and $0$ otherwise.\n\nSelect all statements that are correct:\n\nA. If $x[n] = \\delta[n-n_0]$ for some $n_0 \\in \\{0,1,\\dots,N-1\\}$, then $z[n] = \\delta[n-n_0]$ and $y[n] = \\delta[n]$.\n\nB. For any real $x[n]$, $y[n]\\ge 0$ for all $n$.\n\nC. If $x[n]$ is real and even (that is, $x[n]=x[-n]$ for all $n$), then $\\phi[k]\\in\\{0,\\pi\\}$ for all $k$, hence $y[n]=x[n]$.\n\nD. For any real $x[n]$, the sequence $z[n]$ is real-valued for all $n$.\n\nE. The autocorrelation is preserved by magnitude-only reconstruction: $r_y[m]=r_x[m]$ for all $m$.", "solution": "The problem statement has been validated and is deemed scientifically sound, well-posed, and objective. It presents a standard set of definitions from discrete signal processing and asks for the verification of several propositions based on these definitions. We shall proceed with a rigorous evaluation of each statement.\n\nThe core definitions are:\nThe Discrete Fourier Transform (DFT) of a sequence $x[n]$ is $X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-j \\frac{2\\pi}{N}kn}$.\nThe Inverse DFT (IDFT) is $x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{j \\frac{2\\pi}{N}kn}$.\nThe DFT of $x[n]$ can be written in polar form as $X[k] = |X[k]|\\, e^{j\\phi[k]}$.\nThe magnitude-only reconstruction is $y[n] = \\text{IDFT}\\{|X[k]|\\}$.\nThe phase-only reconstruction is $z[n] = \\text{IDFT}\\{e^{j\\phi[k]}\\}$.\nThe periodic autocorrelation is $r_u[m] = \\sum_{n=0}^{N-1} u[n]\\, \\overline{u[n-m]}$. An essential property connecting the DFT and autocorrelation is the Wiener-Khinchin theorem, which states that the DFT of the autocorrelation sequence is the squared magnitude of the DFT of the original sequence: $\\text{DFT}\\{r_u[m]\\} = |U[k]|^2$.\n\nWe now analyze each statement.\n\nA. If $x[n] = \\delta[n-n_0]$ for some $n_0 \\in \\{0,1,\\dots,N-1\\}$, then $z[n] = \\delta[n-n_0]$ and $y[n] = \\delta[n]$.\n\nFirst, we compute the DFT of $x[n] = \\delta[n-n_0]$.\n$$\nX[k] = \\sum_{n=0}^{N-1} \\delta[n-n_0]\\, e^{-j \\frac{2\\pi}{N}kn} = e^{-j \\frac{2\\pi}{N}kn_0}.\n$$\nFrom this, we extract the magnitude and phase. The magnitude is $|X[k]| = |e^{-j \\frac{2\\pi}{N}kn_0}| = 1$ for all $k \\in \\{0, 1, \\dots, N-1\\}$.\nThe phase is $\\phi[k] = -\\frac{2\\pi}{N}kn_0$.\n\nNow, we construct $y[n]$. The DFT of $y[n]$ is $|X[k]| = 1$.\n$$\ny[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} |X[k]|\\, e^{j \\frac{2\\pi}{N}kn} = \\frac{1}{N}\\sum_{k=0}^{N-1} 1 \\cdot e^{j \\frac{2\\pi}{N}kn}.\n$$\nThis summation is a standard identity, equal to $N\\delta[n]$. Thus, $y[n] = \\frac{1}{N} (N\\delta[n]) = \\delta[n]$. The second part of the statement is correct.\n\nNext, we construct $z[n]$. The DFT of $z[n]$ is $e^{j\\phi[k]} = e^{-j \\frac{2\\pi}{N}kn_0}$.\n$$\nz[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} e^{j\\phi[k]} \\, e^{j \\frac{2\\pi}{N}kn} = \\frac{1}{N}\\sum_{k=0}^{N-1} e^{-j \\frac{2\\pi}{N}kn_0} \\, e^{j \\frac{2\\pi}{N}kn} = \\frac{1}{N}\\sum_{k=0}^{N-1} e^{j \\frac{2\\pi}{N}k(n-n_0)}.\n$$\nThis summation is $N\\delta[n-n_0]$. Thus, $z[n] = \\frac{1}{N} (N\\delta[n-n_0]) = \\delta[n-n_0]$. The first part of the statement, $z[n] = \\delta[n-n_0]$, is also correct.\nSince both claims in the statement are true, the statement is **Correct**.\n\nB. For any real $x[n]$, $y[n]\\ge 0$ for all $n$.\n\nThe sequence $y[n]$ is the IDFT of the magnitude spectrum $|X[k]|$. Since $x[n]$ is real, its DFT satisfies $X[k] = \\overline{X[-k]}$, which implies $|X[k]| = |X[-k]|$. This means the spectrum $|X[k]|$ is a real and even sequence. The IDFT of a real and even sequence is a real and even sequence. However, this does not guarantee that the sequence is non-negative.\nLet us construct a counterexample. Consider $N=2$ and the real sequence $x[n] = \\{1, -1\\}$.\nIts DFT is:\n$X[0] = x[0] + x[1] = 1 - 1 = 0$.\n$X[1] = x[0]e^{-j0} + x[1]e^{-j\\pi} = 1 + (-1)(-1) = 2$.\nSo, $X[k] = \\{0, 2\\}$. The magnitude spectrum is $|X[k]| = \\{0, 2\\}$.\nNow, we compute $y[n]$:\n$$\ny[n] = \\frac{1}{2} \\sum_{k=0}^{1} |X[k]| e^{j\\pi kn} = \\frac{1}{2} \\left( |X[0]|e^0 + |X[1]|e^{j\\pi n} \\right) = \\frac{1}{2}(0 + 2e^{j\\pi n}) = e^{j\\pi n} = (-1)^n.\n$$\nThe sequence is $y[n] = \\{1, -1\\}$. For $n=1$, $y[1] = -1$, which is negative.\nThe statement is therefore falsified by this counterexample. It is **Incorrect**.\n\nC. If $x[n]$ is real and even (that is, $x[n]=x[-n]$ for all $n$), then $\\phi[k]\\in\\{0,\\pi\\}$ for all $k$, hence $y[n]=x[n]$.\n\nIf $x[n]$ is a real sequence, its DFT has Hermitian symmetry: $X[k] = \\overline{X[-k]}$.\nIf $x[n]$ is an even sequence ($x[n]=x[-n]$), its DFT is even: $X[k] = X[-k]$.\nCombining these two properties, we have $X[k] = \\overline{X[-k]} = \\overline{X[k]}$.\nA complex number that equals its own conjugate must be real. Therefore, $X[k]$ is a real-valued sequence for all $k$.\nFor a real number $a$, its polar representation $a = |a|e^{j\\theta}$ requires $e^{j\\theta}$ to be either $1$ (if $a0$) or $-1$ (if $a0$). If $a=0$, the phase is indeterminate, but the problem's convention sets it to $0$. Thus, the phase $\\phi[k]$ can only be $0$ (if $X[k]\\ge 0$) or $\\pi$ (if $X[k]0$). The first part of the statement, $\\phi[k]\\in\\{0,\\pi\\}$, is correct.\n\nNow we must evaluate the conclusion, \"hence $y[n]=x[n]$\".\nThe sequence $y[n]$ is the IDFT of $|X[k]|$. The sequence $x[n]$ is the IDFT of $X[k]$.\nFor $y[n]$ to be equal to $x[n]$, their DFTs must be equal, i.e., $|X[k]| = X[k]$ for all $k$. This is only true if $X[k] \\ge 0$ for all $k$.\nHowever, the DFT of a real and even sequence is not guaranteed to be non-negative.\nConsider the counterexample for $N=4$ with $x[n] = \\{1, 0, -1, 0\\}$. This sequence is real. It is also even: $x[0]=1, x[1]=0, x[-1]=x[3]=0, x[2]=-1, x[-2]=x[2]=-1$.\nIts DFT is:\n$X[k] = \\sum_{n=0}^{3} x[n] e^{-j\\frac{\\pi}{2}kn} = 1 - e^{-j\\pi k} = 1 - (-1)^k$.\n$X[0] = 1-1=0$.\n$X[1] = 1-(-1)=2$.\n$X[2] = 1-1=0$.\n$X[3] = 1-(-1)=2$.\nLet's try another counterexample. $x[n]=\\{0,1,0,1\\}$ from the scratchpad. This is real and even.\n$X[0]=2, X[1]=0, X[2]=-2, X[3]=0$.\nHere, $X[2]=-2$, which is negative.\nSo, $|X[k]| = \\{2, 0, 2, 0\\}$ is not equal to $X[k] = \\{2, 0, -2, 0\\}$.\nSince their DFTs are not identical, their IDFTs, $y[n]$ and $x[n]$, cannot be identical.\nThe conclusion is false, which makes the entire statement **Incorrect**.\n\nD. For any real $x[n]$, the sequence $z[n]$ is real-valued for all $n$.\n\nA sequence is real-valued if and only if its DFT possesses Hermitian symmetry. The sequence $z[n]$ is the IDFT of $Z[k] = e^{j\\phi[k]}$. We must check if $Z[k] = \\overline{Z[-k]}$ for all $k$.\nSince $x[n]$ is real, we know its DFT has Hermitian symmetry: $X[k] = \\overline{X[-k]}$.\nIn polar form, this is $|X[k]| e^{j\\phi[k]} = \\overline{|X[-k]| e^{j\\phi[-k]}}$.\nSince $|X[-k]|$ is real and non-negative, this becomes $|X[k]| e^{j\\phi[k]} = |X[-k]| e^{-j\\phi[-k]}$.\nBy comparing the magnitudes on both sides, we find $|X[k]| = |X[-k]|$.\nBy comparing the phase terms (for $|X[k]| \\neq 0$), we find $e^{j\\phi[k]} = e^{-j\\phi[-k]}$, which implies $\\phi[k] \\equiv -\\phi[-k] \\pmod{2\\pi}$. The phase spectrum is odd.\nNow we check the symmetry of $Z[k] = e^{j\\phi[k]}$. We must test if $Z[k] = \\overline{Z[-k]}$.\n$\\overline{Z[-k]} = \\overline{e^{j\\phi[-k]}} = e^{-j\\phi[-k]}$.\nThe condition becomes $e^{j\\phi[k]} = e^{-j\\phi[-k]}$. This is precisely the relation we derived from the reality of $x[n]$.\nIf $|X[k]|=0$, then $|X[-k]|=0$. By convention, $\\phi[k]=0$ and $\\phi[-k]=0$. In this case, $Z[k] = e^{j0}=1$ and $\\overline{Z[-k]} = \\overline{e^{j0}} = 1$. The symmetry still holds.\nSince the DFT of $z[n]$ has Hermitian symmetry, $z[n]$ must be a real-valued sequence. The statement is **Correct**.\n\nE. The autocorrelation is preserved by magnitude-only reconstruction: $r_y[m]=r_x[m]$ for all $m$.\n\nWe will use the Wiener-Khinchin theorem for periodic signals, which states that $\\text{DFT}\\{r_u[m]\\} = |U[k]|^2$. Two sequences are identical if and only if their DFTs are identical. Therefore, $r_y[m]=r_x[m]$ if and only if $\\text{DFT}\\{r_y[m]\\} = \\text{DFT}\\{r_x[m]\\}$.\nApplying the theorem to sequences $x[n]$ and $y[n]$:\n$\\text{DFT}\\{r_x[m]\\} = |X[k]|^2$.\n$\\text{DFT}\\{r_y[m]\\} = |Y[k]|^2$, where $Y[k]$ is the DFT of $y[n]$.\n\nBy definition, $y[n]$ is the IDFT of $|X[k]|$. Therefore, the DFT of $y[n]$ is $Y[k] = |X[k]|$.\nNow, we compute $|Y[k]|^2$:\n$|Y[k]|^2 = ||X[k]||^2$.\nSince $|X[k]|$ is a real, non-negative value, its magnitude is simply itself.\n$||X[k]||^2 = (|X[k]|)^2 = |X[k]|^2$.\nSo, we have shown that $\\text{DFT}\\{r_y[m]\\} = |Y[k]|^2 = |X[k]|^2 = \\text{DFT}\\{r_x[m]\\}$.\nSince their DFTs are equal, the sequences themselves must be equal. Thus, $r_y[m]=r_x[m]$ for all $m$.\nThe statement is **Correct**.", "answer": "$$\\boxed{ADE}$$", "id": "2387193"}, {"introduction": "The theoretical elegance of the DFT would be of limited practical use without an efficient way to compute it. This hands-on coding challenge guides you through the implementation of the celebrated Fast Fourier Transform (FFT) algorithm, a cornerstone of modern digital signal processing. By building the algorithm from scratch and verifying its properties, you will bridge the gap between mathematical theory and computational practice. [@problem_id:2387187]", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $\\mathcal{O}(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4i]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the area of signal processing. It requires the implementation and verification of the Discrete Fourier Transform (DFT), its inverse (IDFT), and fundamental associated theorems. The problem is complete, objective, and its resolution is verifiable. We will proceed with the solution.\n\nThe core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi j \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $\\mathcal{O}(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $\\mathcal{O}(N^2)$ to $\\mathcal{O}(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi j k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi j k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi j k m / (N/2)} + e^{-2\\pi j k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi j k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi j k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k  N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k  N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi j \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi j k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi j k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $\\mathcal{O}(N^2)$ DFT, a recursive $\\mathcal{O}(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N = 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}