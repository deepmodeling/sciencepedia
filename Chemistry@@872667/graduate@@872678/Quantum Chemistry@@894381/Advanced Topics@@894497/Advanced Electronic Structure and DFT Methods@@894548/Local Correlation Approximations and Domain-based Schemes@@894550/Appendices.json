{"hands_on_practices": [{"introduction": "The foundation of any local correlation method lies in transforming delocalized canonical orbitals into a basis of spatially compact Localized Molecular Orbitals (LMOs). This practice will guide you through the implementation of the classic Foster-Boys localization scheme, a method that minimizes the spatial variance of the orbitals. By coding the iterative Jacobi rotation procedure [@problem_id:2903150], you will gain direct, hands-on experience with the core algorithm used to reveal chemically intuitive bonding patterns and set the stage for subsequent local approximations.", "problem": "You are given orthonormal atomic orbital (AO) bases and sets of canonical occupied orbitals for small model systems. You will construct Boys localized occupied orbitals by unitary rotations within the occupied space and quantify localization using the Foster–Boys spread functional. All operators and coordinates are expressed in atomic units; distances are in Bohr and spreads in Bohr squared. Angles must be in radians.\n\nFundamental base and definitions to use:\n- The occupied molecular orbitals (MOs) are represented by the AO coefficient matrix $\\;C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}\\;$ with orthonormal columns, where $N_\\mathrm{AO}$ is the number of AOs and $N_\\mathrm{occ}$ is the number of occupied orbitals. Orthonormality is with respect to the AO overlap matrix $\\;S\\;$, here taken as the identity $\\;S = I\\;$.\n- A unitary transformation within the occupied space is represented by $\\;U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}\\;$ with $\\;U^\\top U = I\\;$, leading to transformed orbitals $\\;C' = C U\\;$.\n- The Boys localization aims to minimize the Foster–Boys spread\n$$\n\\Omega(C') \\;=\\; \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle \\;-\\; \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right),\n$$\nwhere $\\;\\phi_i\\;$ is the $i$-th occupied orbital, $\\;\\hat{\\mathbf{r}} = (\\hat{x},\\hat{y},\\hat{z})\\;$ is the position operator, and $\\;\\hat{\\mathbf{r}}^2 = \\hat{x}^2 + \\hat{y}^2 + \\hat{z}^2\\;$.\n- In an AO basis with highly localized and orthonormal functions centered at positions $\\;\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)\\;$, use the diagonal integral approximation\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}}),\\quad\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2).\n$$\n- For any column vector $\\;v\\;$ representing an MO in the AO basis, the centroid components and squared radius are computed as\n$$\nm_\\alpha(v) \\;=\\; v^\\top R_\\alpha\\, v \\quad (\\alpha \\in \\{x,y,z\\}), \\qquad\nr^2(v) \\;=\\; v^\\top R_2\\, v,\n$$\nand the orbital contribution to the spread is $\\;r^2(v) - \\big(m_x(v)^2 + m_y(v)^2 + m_z(v)^2\\big)\\;$.\n\nYour task is to write a program that, for each test case below, performs iterative Jacobi pairwise unitary rotations in the occupied space to minimize $\\;\\Omega(C')\\;$, using the following requirements:\n- Start from the given canonical occupied orbitals $\\;C\\;$.\n- Within each sweep, consider all distinct occupied orbital pairs $\\;(p,q)\\;$ with $\\;p < q\\;$ and choose a rotation angle $\\;\\theta\\;$ (in radians) that locally optimizes the Boys objective for that pair. Apply the $2\\times 2$ orthogonal rotation to columns $\\;p\\;$ and $\\;q\\;$ of $\\;C\\;$.\n- Iterate sweeps until convergence by the criterion that the maximum absolute applied rotation angle in a sweep is less than $\\;\\varepsilon = 10^{-10}\\;$, or until a maximum of $\\;K = 1000\\;$ sweeps is reached, whichever occurs first.\n- After convergence, compute the final spread $\\;\\Omega(C')\\;$ in Bohr squared.\n\nTest suite:\nImplement the above for the following three cases. In each case, the AO coordinates are given as a list $\\;[(x_\\mu,y_\\mu,z_\\mu)]\\;$ for $\\;\\mu = 1,\\dots,N_\\mathrm{AO}\\;$, and the canonical occupied orbitals $\\;C\\;$ are given as an $\\;N_\\mathrm{AO} \\times N_\\mathrm{occ}\\;$ real matrix with orthonormal columns.\n\n- Case A (happy path, delocalized over a linear triatomic):\n  - $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$.\n  - AO coordinates:\n    $[( -1, 0, 0 ),\\ ( 0, 0, 0 ),\\ ( 1, 0, 0 )]$.\n  - Canonical occupied $C$:\n    column $1$: $\\left[ \\frac{1}{\\sqrt{2}},\\ 0,\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$,\n    column $2$: $\\left[ \\frac{1}{2},\\ \\frac{1}{\\sqrt{2}},\\ -\\frac{1}{2} \\right]^\\top$.\n\n- Case B (boundary, single occupied orbital):\n  - $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$.\n  - AO coordinates:\n    $[( -\\frac{1}{2}, 0, 0 ),\\ ( \\frac{1}{2}, 0, 0 )]$.\n  - Canonical occupied $C$:\n    column $1$: $\\left[ \\frac{1}{\\sqrt{2}},\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$.\n\n- Case C (edge, symmetry and near-degeneracy on a cross):\n  - $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$.\n  - AO coordinates:\n    $[( -1, 0, 0 ),\\ ( 1, 0, 0 ),\\ ( 0, -1, 0 ),\\ ( 0, 1, 0 )]$.\n  - Canonical occupied $C$:\n    column $1$: $\\left[ \\frac{1}{\\sqrt{2}},\\ 0,\\ 0,\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$,\n    column $2$: $\\left[ 0,\\ \\frac{1}{\\sqrt{2}},\\ \\frac{1}{\\sqrt{2}},\\ 0 \\right]^\\top$.\n\nProgram requirements:\n- Construct $\\;R_x\\;$, $\\;R_y\\;$, $\\;R_z\\;$, and $\\;R_2\\;$ from the AO coordinates as specified above.\n- Implement the Jacobi rotation procedure on the occupied space to minimize $\\;\\Omega\\;$ with the convergence parameters $\\;\\varepsilon = 10^{-10}\\;$ and $\\;K = 1000\\;$.\n- For each case, report the final value of $\\;\\Omega\\;$ as a floating-point number in Bohr squared. Express the outputs as decimal numerals rounded to exactly six digits after the decimal point.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order Case A, Case B, Case C. For example, the output format must be\n$[r_A,r_B,r_C]$,\nwhere each of $\\;r_A,r_B,r_C\\;$ is the final $\\;\\Omega\\;$ value rounded to six decimal places, with no spaces anywhere in the line.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n**Step 1: Extract Givens**\n- **Model:** Orthonormal atomic orbital (AO) basis ($\\;S = I\\;$), Boys localization of canonical occupied molecular orbitals (MOs).\n- **MO Coefficient Matrix:** $\\;C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}\\;$ with orthonormal columns.\n- **Unitary Transformation:** $\\;C' = C U\\;$, where $\\;U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}\\;$ is an orthogonal matrix ($\\;U^\\top U = I\\;$).\n- **Foster–Boys Spread Functional:** $\\;\\Omega(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle - \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right)\\;$.\n- **Diagonal Integral Approximation:** The matrix representations of position operators $\\;\\hat{x},\\hat{y},\\hat{z}\\;$ and the squared position operator $\\;\\hat{\\mathbf{r}}^2\\;$ in the AO basis are diagonal matrices derived from AO center coordinates $\\;\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)\\;$:\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}})\n$$\n$$\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2)\n$$\n- **Orbital Properties:** For an MO column vector $\\;v\\;$, the centroid components are $\\;m_\\alpha(v) = v^\\top R_\\alpha v\\;$ and the squared radius is $\\;r^2(v) = v^\\top R_2 v\\;$.\n- **Optimization Procedure:** Iterative Jacobi pairwise rotations on columns of $\\;C\\;$.\n- **Convergence Criteria:** Maximum absolute rotation angle in a sweep $\\;|\\theta|_{\\max} < \\varepsilon = 10^{-10}\\;$, or maximum sweeps $\\;K = 1000\\;$.\n- **Test Cases:**\n  - **Case A:** $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$. AO coordinates: $\\;[(-1, 0, 0), (0, 0, 0), (1, 0, 0)]\\;$. $C$ columns: $\\;c_1 = [\\frac{1}{\\sqrt{2}}, 0, \\frac{1}{\\sqrt{2}}]^\\top\\;$, $\\;c_2 = [\\frac{1}{2}, \\frac{1}{\\sqrt{2}}, -\\frac{1}{2}]^\\top\\;$.\n  - **Case B:** $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$. AO coordinates: $\\;[(-\\frac{1}{2}, 0, 0), (\\frac{1}{2}, 0, 0)]\\;$. $C$ column: $\\;c_1 = [\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}]^\\top\\;$.\n  - **Case C:** $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$. AO coordinates: $\\;[(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0)]\\;$. $C$ columns: $\\;c_1 = [\\frac{1}{\\sqrt{2}}, 0, 0, \\frac{1}{\\sqrt{2}}]^\\top\\;$, $\\;c_2 = [0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}, 0]^\\top\\;$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, describing the standard Boys-Foster localization method under a specified diagonal integral approximation. This method is fundamental in quantum chemistry for transforming delocalized canonical orbitals into chemically intuitive localized orbitals, a precursor to many local electron correlation methods. The problem is well-posed, providing all necessary matrices, parameters, and a clearly defined, convergent algorithm (Jacobi sweeps). The initial MO coefficient matrices are verified to be orthonormal as stated. The problem is objective, quantitative, and free of ambiguity or contradiction. It falls squarely within the specified field.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be constructed.\n\n**Solution Derivation**\nThe objective is to minimize the Foster-Boys spread, $\\;\\Omega(C')$. The spread is comprised of two terms: a sum of squared radii and a sum of squared centroid norms.\nThe sum of squared radii, $\\;\\sum_i \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle = \\mathrm{Tr}(C'^\\top R_2 C')\\;$, is invariant under orthogonal transformations $\\;C' = CU\\;$:\n$$\n\\mathrm{Tr}((CU)^\\top R_2 (CU)) = \\mathrm{Tr}(U^\\top C^\\top R_2 C U) = \\mathrm{Tr}(C^\\top R_2 C U U^\\top) = \\mathrm{Tr}(C^\\top R_2 C)\n$$\nTherefore, minimizing the spread $\\;\\Omega\\;$ is equivalent to maximizing the sum of the squared norms of the orbital centroids:\n$$\nL(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\lVert \\langle \\phi'_i | \\hat{\\mathbf{r}} | \\phi'_i \\rangle \\rVert^2 = \\sum_{i=1}^{N_\\mathrm{occ}} \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2\n$$\nThe Jacobi method addresses this maximization by sequentially optimizing pairs of orbitals. For a pair of orbitals $\\;(\\phi_p, \\phi_q)\\;$, we apply a rotation:\n$$\n\\begin{pmatrix} \\phi'_p \\\\ \\phi'_q \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\phi_p \\\\ \\phi_q \\end{pmatrix}\n$$\nThis rotation only affects terms involving orbitals $\\;p\\;$ and $\\;q\\;$. We must find the angle $\\;\\theta\\;$ that maximizes $\\;\\|\\langle \\phi'_p | \\hat{\\mathbf{r}} | \\phi'_p \\rangle\\|^2 + \\|\\langle \\phi'_q | \\hat{\\mathbf{r}} | \\phi'_q \\rangle\\|^2\\;$.\n\nLet $\\;\\mathbf{A}_{ij}\\;$ be a vector of dipole matrix elements between orbitals $\\;i\\;$ and $\\;j\\;$:\n$$\n\\mathbf{A}_{ij} = (\\langle \\phi_i | \\hat{x} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{y} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{z} | \\phi_j \\rangle) = (c_i^\\top R_x c_j, c_i^\\top R_y c_j, c_i^\\top R_z c_j)\n$$\nNote that $\\;\\mathbf{A}_{ij} = \\mathbf{A}_{ji}\\;$ as the operators are real and symmetric. The maximization problem for the pair $\\;(p,q)\\;$ reduces to finding $\\;\\theta\\;$ that maximizes $\\;\\|\\mathbf{A}'_{pp}\\|^2 + \\|\\mathbf{A}'_{qq}\\|^2\\;$.\nThe transformed centroids $\\;\\mathbf{A}'_{pp}\\;$ and $\\;\\mathbf{A}'_{qq}\\;$ are expressed in terms of the original matrix elements and the rotation angle $\\;\\theta\\;$:\n$$\n\\mathbf{A}'_{pp} = \\mathbf{A}_{pp}\\cos^2\\theta + \\mathbf{A}_{qq}\\sin^2\\theta + 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\n$$\n\\mathbf{A}'_{qq} = \\mathbf{A}_{pp}\\sin^2\\theta + \\mathbf{A}_{qq}\\cos^2\\theta - 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\nLet $\\;\\mathbf{D} = \\mathbf{A}_{pp} - \\mathbf{A}_{qq}\\;$ and $\\;\\gamma = 2\\theta\\;$. The sum to be maximized can be written as:\n$$\nL(\\theta) = \\text{const} + \\frac{1}{2} \\left[ \\left(\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2\\right) \\cos^2\\gamma + 4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})\\sin\\gamma\\cos\\gamma \\right]\n$$\nSetting the derivative with respect to $\\;\\gamma\\;$ to zero yields the condition for the optimal angle:\n$$\n\\tan(2\\gamma) = \\tan(4\\theta) = \\frac{4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})}{\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2}\n$$\nLet the numerator be $\\;X = 4(\\mathbf{A}_{pp} - \\mathbf{A}_{qq})\\cdot\\mathbf{A}_{pq}\\;$ and the denominator be $\\;Y = \\|\\mathbf{A}_{pp} - \\mathbf{A}_{qq}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2\\;$. The optimal angle that maximizes the objective function is found via:\n$$\n\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)\n$$\nThe $\\;\\mathrm{atan2}(Y,X)\\;$ function is used here to correctly determine the quadrant for $\\;4\\theta\\;$ (in my convention, $\\mathrm{atan2}(y,x)$), ensuring movement towards a maximum. In the code, $\\mathrm{numpy.arctan2}(X, Y)$ is used which corresponds to this formulation.\n\n**Algorithm**\nFor each test case:\n1.  Construct the diagonal matrices $\\;R_x, R_y, R_z\\;$ and $\\;R_2\\;$ from the given AO coordinates.\n2.  Initialize the MO coefficient matrix $\\;C\\;$ and set sweep counter and convergence flags.\n3.  Begin iterative sweeps. In each sweep:\n    a. Initialize the maximum angle for the current sweep, $\\;|\\theta|_{\\max}^{\\text{sweep}}\\;$, to zero.\n    b. For each distinct pair of occupied orbitals $\\;(p, q)\\;$ with $\\;p < q\\;$:\n        i.   Compute the dipole matrix element vectors $\\;\\mathbf{A}_{pp}\\;$, $\\;\\mathbf{A}_{qq}\\;$, and $\\;\\mathbf{A}_{pq}\\;$ using the current $\\;c_p\\;$ and $\\;c_q\\;$.\n        ii.  Calculate the numerator $\\;X\\;$ and denominator $\\;Y\\;$ for the $\\;\\tan(4\\theta)\\;$ expression.\n        iii. Determine the rotation angle $\\;\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)\\;$.\n        iv.  Update the record for the maximum angle in the sweep: $\\;|\\theta|_{\\max}^{\\text{sweep}} = \\max(|\\theta|_{\\max}^{\\text{sweep}}, |\\theta|)\\;$.\n        v.   Apply the rotation to update the columns $\\;c_p\\;$ and $\\;c_q\\;$ of the matrix $\\;C\\;$:\n             $$\n             \\begin{pmatrix} c'_p & c'_q \\end{pmatrix} = \\begin{pmatrix} c_p & c_q \\end{pmatrix} \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n             $$\n    c. After iterating through all pairs, check for convergence. If $\\;|\\theta|_{\\max}^{\\text{sweep}} < \\varepsilon\\;$, or if the maximum number of sweeps $\\;K\\;$ is reached, terminate the iteration.\n4.  Once converged, calculate the final total spread $\\;\\Omega\\;$ using the final localized orbital matrix $\\;C'\\;$:\n    $$\n    \\Omega = \\sum_{i=0}^{N_\\mathrm{occ}-1} \\left[ (c'_i)^\\top R_2 c'_i - \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2 \\right]\n    $$\n5. Report the final $\\;\\Omega\\;$ value. For cases with $\\;N_\\mathrm{occ} \\le 1\\;$, no rotations are possible; the initial spread is the final spread.\n\nThis procedure is implemented for each of the three test cases specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Define convergence parameters from the problem statement.\n    EPSILON = 1e-10\n    MAX_SWEEPS = 1000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 1.0/2.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), -1.0/2.0]\n            ])\n        },\n        {\n            \"name\": \"Case B\",\n            \"ao_coords\": np.array([\n                [-0.5, 0.0, 0.0],\n                [0.5, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0)]\n            ])\n        },\n        {\n            \"name\": \"Case C\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 0.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), 0.0]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_localization(\n            case[\"ao_coords\"],\n            case[\"C_initial\"],\n            MAX_SWEEPS,\n            EPSILON\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef run_localization(ao_coords, C_initial, max_sweeps, epsilon):\n    \"\"\"\n    Performs Boys localization for a single case and returns the final spread.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C_initial (np.ndarray): Initial MO coefficient matrix, shape (N_AO, N_occ).\n        max_sweeps (int): Maximum number of sweeps.\n        epsilon (float): Convergence threshold for the maximum rotation angle.\n        \n    Returns:\n        float: The final minimized Foster-Boys spread.\n    \"\"\"\n    n_ao, n_occ = C_initial.shape\n    C = C_initial.copy()\n\n    # If N_occ <= 1, no localization is possible or needed.\n    if n_occ <= 1:\n        return calculate_spread(ao_coords, C)\n\n    # Construct the diagonal operator matrices R_x, R_y, R_z, R_2\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    \n    for sweep in range(max_sweeps):\n        max_angle_in_sweep = 0.0\n        \n        # Iterate over all distinct pairs of occupied orbitals (p, q)\n        for p in range(n_occ):\n            for q in range(p + 1, n_occ):\n                cp = C[:, p]\n                cq = C[:, q]\n\n                # Compute dipole matrix element vectors A_pp, A_qq, A_pq\n                A_pp = np.array([cp.T @ Rx @ cp, cp.T @ Ry @ cp, cp.T @ Rz @ cp])\n                A_qq = np.array([cq.T @ Rx @ cq, cq.T @ Ry @ cq, cq.T @ Rz @ cq])\n                A_pq = np.array([cp.T @ Rx @ cq, cp.T @ Ry @ cq, cp.T @ Rz @ cq])\n\n                # Calculate numerator and denominator for tan(4*theta)\n                D_vec = A_pp - A_qq\n                X_num = 4.0 * np.dot(D_vec, A_pq)\n                Y_den = np.dot(D_vec, D_vec) - 4.0 * np.dot(A_pq, A_pq)\n                \n                # Avoid division by zero when orbitals are already localized\n                if np.isclose(X_num, 0.0) and np.isclose(Y_den, 0.0):\n                    theta = 0.0\n                else:\n                    theta = 0.25 * np.arctan2(X_num, Y_den)\n\n                max_angle_in_sweep = max(max_angle_in_sweep, abs(theta))\n                \n                # Apply the rotation if the angle is significant\n                if abs(theta) > 1e-15: # A small threshold to avoid no-op\n                    c_theta = np.cos(theta)\n                    s_theta = np.sin(theta)\n                    \n                    # Original columns p and q\n                    cp_orig = C[:, p].copy()\n                    cq_orig = C[:, q].copy()\n                    \n                    # Update columns C_p and C_q\n                    C[:, p] = cp_orig * c_theta + cq_orig * s_theta\n                    C[:, q] = -cp_orig * s_theta + cq_orig * c_theta\n\n        # Check for convergence\n        if max_angle_in_sweep < epsilon:\n            break\n            \n    return calculate_spread(ao_coords, C)\n\n\ndef calculate_spread(ao_coords, C):\n    \"\"\"\n    Calculates the total Foster-Boys spread for a given set of orbitals.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C (np.ndarray): MO coefficient matrix, shape (N_AO, N_occ).\n        \n    Returns:\n        float: The total spread.\n    \"\"\"\n    n_ao, n_occ = C.shape\n\n    # Construct operator matrices\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    R2 = np.diag(r_a**2 + r_b**2 + r_c**2)\n\n    total_spread = 0.0\n    for i in range(n_occ):\n        ci = C[:, i]\n        \n        # Squared radius: <phi_i | r^2 | phi_i>\n        r2_i = ci.T @ R2 @ ci\n        \n        # Centroid components: <phi_i | r_alpha | phi_i>\n        mx_i = ci.T @ Rx @ ci\n        my_i = ci.T @ Ry @ ci\n        mz_i = ci.T @ Rz @ ci\n        \n        # Orbital spread contribution\n        orbital_spread = r2_i - (mx_i**2 + my_i**2 + mz_i**2)\n        total_spread += orbital_spread\n        \n    return total_spread\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903150"}, {"introduction": "After localizing occupied orbitals, the key to efficiency is to construct a compact, pair-specific virtual space using Pair Natural Orbitals (PNOs), which form the optimal basis for describing the correlation of a specific electron pair. In this exercise [@problem_id:2903183], you will calculate PNO occupation numbers for a model pair and see firsthand how sharply they decay, allowing for aggressive truncation of the virtual space with minimal loss of correlation energy. This calculation reveals the central principle behind the remarkable efficiency of methods like DLPNO-CCSD.", "problem": "In local correlation theories employing Pair Natural Orbitals (PNO), such as Domain-Based Local Pair Natural Orbital Coupled Cluster (DLPNO-CCSD), the PNOs for an occupied-occupied pair $\\{i,j\\}$ are defined as the eigenvectors of a virtual-virtual pair density matrix constructed from the pair doubles amplitudes. Consider a closed-shell system and a single occupied pair $\\{i,j\\}$ with real spin-adapted doubles amplitudes $t_{ij}^{ab}$ given (in an orthonormal canonical virtual basis) by the $4 \\times 4$ matrix $\\mathbf{T}$ with rows indexed by virtuals $a \\in \\{1,2,3,4\\}$ and columns by virtuals $b \\in \\{1,2,3,4\\}$:\n$$\n\\mathbf{T} \\equiv \\big(t_{ij}^{ab}\\big) \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 0 & 0\\\\\n10^{-3/2} & 0 & 0 & 0\\\\\n0 & 0 & 0 & 10^{-3}\\\\\n0 & 0 & 10^{-3} & 0\n\\end{pmatrix}.\n$$\nAdopt the standard model in which the pair density in the virtual space is defined by\n$$\n\\mathbf{D} \\equiv \\big(D_{ac}\\big) \\;=\\; \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb} \\;=\\; \\mathbf{T}\\,\\mathbf{T}^{\\top},\n$$\nand the PNO occupation numbers are the eigenvalues $\\{\\lambda_p\\}$ of $\\mathbf{D}$. Further assume the common approximation that the recoverable pair correlation energy is proportional to $\\mathrm{tr}(\\mathbf{D})$, and that retaining the $k$ largest PNOs recovers a fraction equal to\n$$\nf_k \\;=\\; \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}.\n$$\nTasks:\n1. Compute the PNO eigenvalues $\\{\\lambda_p\\}$ of $\\mathbf{D}$ and sort them in descending order.\n2. Determine the minimal number $k_{\\min}$ of PNOs required such that $f_{k_{\\min}} \\ge 0.999$.\n\nReport only the minimal number $k_{\\min}$ as your final answer. No units are required.", "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- **System:** A closed-shell system.\n- **Pair:** A single occupied pair $\\{i,j\\}$.\n- **Amplitudes:** A $4 \\times 4$ matrix $\\mathbf{T} \\equiv (t_{ij}^{ab})$ of real spin-adapted doubles amplitudes is provided:\n$$\n\\mathbf{T} \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 0 & 0\\\\\n10^{-3/2} & 0 & 0 & 0\\\\\n0 & 0 & 0 & 10^{-3}\\\\\n0 & 0 & 10^{-3} & 0\n\\end{pmatrix}\n$$\n- **Pair Density Matrix Definition:** The virtual-virtual pair density matrix $\\mathbf{D}$ is defined as $\\mathbf{D} \\equiv (D_{ac}) = \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb}$, which in matrix notation is $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$.\n- **PNO Occupation Numbers:** The eigenvalues $\\{\\lambda_p\\}$ of $\\mathbf{D}$.\n- **Energy Recovery Fraction:** The fraction of the pair correlation energy recovered by the first $k$ PNOs is $f_k = \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}$.\n- **Objective:** Find the minimal integer $k_{\\min}$ such that $f_{k_{\\min}} \\ge 0.999$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it employs standard definitions and approximations from the theory of local correlation methods in quantum chemistry, specifically PNO-based approaches. The definitions for the pair density matrix, PNO occupation numbers, and the energy recovery fraction are all conventional within this theoretical framework. The problem is well-posed, providing all necessary information, and its mathematical structure ensures that a unique and meaningful solution exists. There are no contradictions, ambiguities, or factual inaccuracies. The problem is a valid, formal exercise in computational chemistry theory.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\n**Solution Derivation**\nThe primary task is to find the eigenvalues of the pair density matrix $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$ and then determine the minimum number of these eigenvalues required to satisfy a given threshold.\n\nFirst, we compute the matrix $\\mathbf{D}$. The given amplitude matrix $\\mathbf{T}$ is:\n$$\n\\mathbf{T} =\n\\begin{pmatrix}\n0 & 1 & 0 & 0\\\\\n10^{-3/2} & 0 & 0 & 0\\\\\n0 & 0 & 0 & 10^{-3}\\\\\n0 & 0 & 10^{-3} & 0\n\\end{pmatrix}\n$$\nThis matrix has a block-diagonal structure:\n$$\n\\mathbf{T} = \\begin{pmatrix} \\mathbf{A} & \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2} & \\mathbf{B} \\end{pmatrix}, \\quad \\text{where } \\mathbf{A} = \\begin{pmatrix} 0 & 1 \\\\ 10^{-3/2} & 0 \\end{pmatrix} \\text{ and } \\mathbf{B} = \\begin{pmatrix} 0 & 10^{-3} \\\\ 10^{-3} & 0 \\end{pmatrix}\n$$\nThe transpose of $\\mathbf{T}$ is $\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}^{\\top} & \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2} & \\mathbf{B}^{\\top} \\end{pmatrix}$.\nThe density matrix $\\mathbf{D}$ is then also block-diagonal:\n$$\n\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}\\mathbf{A}^{\\top} & \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2} & \\mathbf{B}\\mathbf{B}^{\\top} \\end{pmatrix}\n$$\nWe compute the blocks $\\mathbf{A}\\mathbf{A}^{\\top}$ and $\\mathbf{B}\\mathbf{B}^{\\top}$ separately.\nFor the first block:\n$$\n\\mathbf{A}\\mathbf{A}^{\\top} = \\begin{pmatrix} 0 & 1 \\\\ 10^{-3/2} & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 10^{-3/2} \\\\ 1 & 0 \\end{pmatrix} = \\begin{pmatrix} (0)(0) + (1)(1) & (0)(10^{-3/2}) + (1)(0) \\\\ (10^{-3/2})(0) + (0)(1) & (10^{-3/2})(10^{-3/2}) + (0)(0) \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 10^{-3} \\end{pmatrix}\n$$\nFor the second block, note that $\\mathbf{B}$ is a symmetric matrix, so $\\mathbf{B}^{\\top} = \\mathbf{B}$.\n$$\n\\mathbf{B}\\mathbf{B}^{\\top} = \\mathbf{B}^2 = \\begin{pmatrix} 0 & 10^{-3} \\\\ 10^{-3} & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 10^{-3} \\\\ 10^{-3} & 0 \\end{pmatrix} = \\begin{pmatrix} (10^{-3})^2 & 0 \\\\ 0 & (10^{-3})^2 \\end{pmatrix} = \\begin{pmatrix} 10^{-6} & 0 \\\\ 0 & 10^{-6} \\end{pmatrix}\n$$\nCombining the blocks, the full density matrix $\\mathbf{D}$ is:\n$$\n\\mathbf{D} = \\begin{pmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 10^{-3} & 0 & 0\\\\\n0 & 0 & 10^{-6} & 0\\\\\n0 & 0 & 0 & 10^{-6}\n\\end{pmatrix}\n$$\nThe PNO occupation numbers $\\{\\lambda_p\\}$ are the eigenvalues of $\\mathbf{D}$. Since $\\mathbf{D}$ is a diagonal matrix, its eigenvalues are simply its diagonal elements.\nThe eigenvalues are $\\{1, 10^{-3}, 10^{-6}, 10^{-6}\\}$.\nSorting these in descending order gives:\n$\\lambda_1 = 1$\n$\\lambda_2 = 10^{-3}$\n$\\lambda_3 = 10^{-6}$\n$\\lambda_4 = 10^{-6}$\n\nNext, we must find the minimal integer $k_{\\min}$ such that the recovery fraction $f_{k_{\\min}} \\ge 0.999$.\nThe total sum of eigenvalues, which is the trace of $\\mathbf{D}$, is:\n$$\n\\sum_{p=1}^{4} \\lambda_p = 1 + 10^{-3} + 10^{-6} + 10^{-6} = 1 + 0.001 + 2 \\times 10^{-6} = 1.001002\n$$\nWe check the fraction $f_k$ for increasing values of $k$.\nFor $k=1$:\n$$\nf_1 = \\frac{\\lambda_1}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1}{1.001002}\n$$\nWe test the condition $f_1 \\ge 0.999$:\n$$\n\\frac{1}{1.001002} \\ge 0.999 \\iff 1 \\ge 0.999 \\times 1.001002\n$$\n$0.999 \\times 1.001002 = (1 - 10^{-3})(1 + 10^{-3} + 2 \\times 10^{-6}) = 1 + 10^{-3} + 2 \\times 10^{-6} - 10^{-3} - 10^{-6} - 2 \\times 10^{-9} = 1 + 10^{-6} - 2 \\times 10^{-9} = 1.000000998$.\nThe test is $1 \\ge 1.000000998$, which is false. An alternative calculation gives $f_1 \\approx 0.998999$, which is less than $0.999$.\n\nFor $k=2$:\n$$\nf_2 = \\frac{\\lambda_1 + \\lambda_2}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1 + 10^{-3}}{1.001002} = \\frac{1.001}{1.001002}\n$$\nWe test the condition $f_2 \\ge 0.999$:\n$$\n\\frac{1.001}{1.001002} \\ge 0.999 \\iff 1.001 \\ge 0.999 \\times 1.001002\n$$\nUsing the previous result, $0.999 \\times 1.001002 = 0.999990998$.\nThe test is $1.001 \\ge 0.999990998$. This inequality is true.\nSince the condition is met for $k=2$ but not for $k=1$, the minimal number of PNOs required is $2$.\nTherefore, $k_{\\min} = 2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "2903183"}, {"introduction": "To appreciate the true power of local correlation approximations, it is essential to understand their impact on computational cost. This practice [@problem_id:2903194] synthesizes the concepts of LMOs, domains, and PNOs into a complete computational cost model for a DLPNO-CCSD calculation. By implementing this model, you will quantify the computational savings at each step of the workflow, connecting the theoretical approximations to the practical feasibility of performing high-accuracy calculations on large molecular systems.", "problem": "You are tasked with constructing a principled, first-principles operation-count model for a Domain-based Local Pair Natural Orbital Coupled Cluster with Singles and Doubles (DLPNO-CCSD) workflow for a small molecular system. Your model must quantify the dominant floating-point operation (flop) counts from the following high-level steps of the workflow:\n1) generation of Localized Molecular Orbitals (LMOs),\n2) per-occupied pair diagonalization of the pair-density to generate Pair Natural Orbitals (PNOs),\n3) Resolution-of-Identity (RI) based three-index integral handling and transformation into the PNO basis,\n4) per-occupied pair doubles-amplitude updates in the PNO space.\n\nThe derivation must begin from fundamental, widely used computational cost models in numerical linear algebra and standard observations about PNO spectra:\n- Dense matrix-matrix multiplication on square matrices of size $n$ costs approximately $2n^3$ floating-point operations (flops).\n- Dense symmetric eigenvalue decomposition of a size-$n$ matrix by Householder tridiagonalization plus implicit QR iteration costs approximately $\\frac{10}{3} n^3$ flops.\n- The number of strong occupied-occupied pairs can be modeled by a local adjacency radius rule: only pairs $(i,j)$ with $1 \\le i < j \\le n_o$ and $|i-j| \\le r$ are treated as strong and explicitly correlated.\n- The pair domain size $m_{ij}$ can be modeled as $m_{ij} = \\min(n_v, \\max(1, m_i + m_j - o))$ where $n_v$ is the number of canonical virtual orbitals, $m_i$ and $m_j$ are the sizes of the occupied-specific domains (taken equal to a constant $m$ for all occupied orbitals in this problem), and $o$ is an average overlap parameter.\n- The spectrum of pair-density eigenvalues for a strong pair is well known to be strongly decaying; assume an exponential envelope $\\lambda_k = A \\exp(-\\alpha (k-1))$ for $k = 1,2,\\dots$, with $A \\in (0,1]$ and $\\alpha > 0$. Given a truncation threshold $\\tau \\in (0,1)$, keep $l_{ij}$ PNOs per pair, where $l_{ij}$ is the count of eigenvalues $\\lambda_k \\ge \\tau$, but it is always at least $1$ and cannot exceed $m_{ij}$.\n\nWithin this modeling framework, construct the following rough flop-count model (you must derive it from the above primitives in your solution, not treat it as a black box):\n- LMO generation: assume $s_{\\mathrm{loc}}$ sweeps, each dominated by one dense symmetric eigensolve of size $n_o$, for a cost $C_{\\mathrm{LMO}} \\approx \\frac{10}{3} s_{\\mathrm{loc}} n_o^3$.\n- Strong pair count: $N_{\\mathrm{pairs}} = \\sum_{k=1}^{\\min(r, n_o-1)} (n_o - k)$.\n- For every strong pair, with uniform $m_{ij} \\equiv m_p$ and resulting $l_{ij} \\equiv l$:\n  - Pair-density diagonalization: $C_{\\mathrm{PNO\\;eig}} \\approx \\frac{10}{3} m_p^3$.\n  - Resolution-of-Identity three-index handling and PNO transformation: model the dominant contractions as $C_{\\mathrm{RI}} \\approx 2 n_{\\mathrm{aux}} m_p l + n_{\\mathrm{aux}} l^2$, where $n_{\\mathrm{aux}}$ is the size of the auxiliary basis.\n  - Doubles amplitude updates in PNO space: one nonlinear iteration is modeled as $c_{\\mathrm{CC}} l^4$, and a fixed-point iteration count $n_{\\mathrm{it}}$ gives $C_{\\mathrm{CC}} \\approx c_{\\mathrm{CC}} n_{\\mathrm{it}} l^4$ flops per pair.\n\nYour program must implement the above and, for each test case, output a breakdown of integer flop counts as a list\n[LMO_cost, PNO_eig_cost_total, RI_cost_total, CC_cost_total, grand_total]\nwith all entries rounded to the nearest integer, where:\n- LMO_cost is $C_{\\mathrm{LMO}}$,\n- PNO_eig_cost_total is $N_{\\mathrm{pairs}} \\times C_{\\mathrm{PNO\\;eig}}$,\n- RI_cost_total is $N_{\\mathrm{pairs}} \\times C_{\\mathrm{RI}}$,\n- CC_cost_total is $N_{\\mathrm{pairs}} \\times C_{\\mathrm{CC}}$,\n- grand_total is the sum of the preceding four values.\n\nDetails you must implement:\n- Strong pairs: $N_{\\mathrm{pairs}} = \\sum_{k=1}^{\\min(r, n_o-1)} (n_o - k)$.\n- Pair-domain size: $m_p = \\min(n_v, \\max(1, 2m - o))$ with integers.\n- Retained PNOs per pair: if $A \\le 0$ or $\\alpha \\le 0$, set $l = 1$. Otherwise define the untruncated count $l^* = 1 + \\left\\lfloor \\frac{\\ln\\left(\\max(A,\\tau)/\\tau\\right)}{\\alpha} \\right\\rfloor$, then set $l = \\min(m_p, \\max(1, l^*))$.\n- Use natural logarithms. All intermediate counts must be treated as real numbers until rounding of the final costs to the nearest integer.\n\nTest Suite:\nImplement your program to solve exactly the following four test cases. Each test case is the tuple\n$(n_o, n_v, m, o, r, s_{\\mathrm{loc}}, \\alpha, A, \\tau, n_{\\mathrm{it}}, c_{\\mathrm{CC}}, n_{\\mathrm{aux}})$\nwith all quantities dimensionless:\n1) $(10, 40, 20, 8, 2, 3, 1.2, 0.5, 10^{-4}, 6, 12, 150)$\n2) $(2, 5, 3, 1, 1, 2, 0.8, 0.7, 10^{-2}, 4, 8, 30)$\n3) $(12, 60, 50, 30, 3, 4, 1.0, 0.6, 10^{-5}, 8, 16, 200)$\n4) $(8, 20, 10, 12, 0, 2, 1.0, 0.3, 10^{-3}, 5, 10, 80)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, where each element is the list [LMO_cost, PNO_eig_cost_total, RI_cost_total, CC_cost_total, grand_total] for one test case in the same order as above. For example, it must look like:\n[[a1,b1,c1,d1,t1],[a2,b2,c2,d2,t2],[a3,b3,c3,d3,t3],[a4,b4,c4,d4,t4]]\nAll outputs are pure integers (unitless flop counts) obtained by rounding to the nearest integer as specified.", "solution": "The problem as stated constitutes a valid exercise in the formulation of a simplified, first-principles operation-count model for a local correlation method in quantum chemistry. It is scientifically grounded, well-posed, and free from ambiguity. I will now proceed to construct the model and its components as requested.\n\nThe total computational cost of the Domain-based Local Pair Natural Orbital Coupled Cluster with Singles and Doubles (DLPNO-CCSD) workflow is modeled as the sum of costs for its dominant steps. We will derive the cost expression for each step based on the provided primitives.\n\nLet the number of occupied molecular orbitals be $n_o$ and the number of canonical virtual orbitals be $n_v$.\n\n**1. LMO Generation Cost ($C_{\\mathrm{LMO}}$)**\n\nThe generation of Localized Molecular Orbitals (LMOs) is assumed to require an iterative procedure. The problem states this takes $s_{\\mathrm{loc}}$ sweeps, with each sweep's cost dominated by a single dense symmetric eigenvalue decomposition of a matrix of size $n_o \\times n_o$. The fundamental cost for such an eigensolve is given as approximately $\\frac{10}{3} n^3$ floating-point operations (flops) for a matrix of size $n$. Applying this primitive with $n = n_o$ and multiplying by the number of sweeps $s_{\\mathrm{loc}}$, we obtain the cost for LMO generation:\n$$ C_{\\mathrm{LMO}} = s_{\\mathrm{loc}} \\cdot \\frac{10}{3} n_o^3 $$\n\n**2. Number of Strong Pairs ($N_{\\mathrm{pairs}}$)**\n\nLocal correlation methods exploit the spatial locality of electron correlation. The DLPNO-CCSD method treats only \"strong\" pairs of occupied orbitals $(i,j)$ with a high-level correlation method. The problem defines strong pairs using a simple adjacency rule based on orbital indices: a pair $(i,j)$ with $1 \\le i < j \\le n_o$ is considered strong if the distance between their indices, $|i-j|$, does not exceed a radius $r$.\n\nThe total number of such pairs, $N_{\\mathrm{pairs}}$, is found by summing over all possible index distances $k = |i-j|$ from $1$ up to $r$. For a given distance $k$, there are $(n_o - k)$ pairs $(i,j)$ with $j-i=k$ (for instance, $(1, 1+k), (2, 2+k), \\dots, (n_o-k, n_o)$). The maximum possible distance is $n_o-1$. Thus, the total number of strong pairs is the sum over allowed distances $k$:\n$$ N_{\\mathrm{pairs}} = \\sum_{k=1}^{\\min(r, n_o-1)} (n_o - k) $$\nThis sum corresponds to an arithmetic series. If $r=0$, the sum is empty and $N_{\\mathrm{pairs}}=0$.\n\n**3. Pair-Specific Quantities: Domain Size ($m_p$) and PNO Count ($l$)**\n\nFor each strong pair, the calculation is performed within a truncated virtual space specific to that pair. This space is constructed from a \"pair domain\" and then further truncated using Pair Natural Orbitals (PNOs).\n\n**a. Pair Domain Size ($m_p$)**\nThe initial domain for a pair $(i,j)$ is formed by combining the individual domains of occupied orbitals $i$ and $j$. The size of an individual domain is given as a constant, $m$. The problem provides a model for the combined pair domain size $m_{ij}$ as $m_{ij} = \\min(n_v, \\max(1, m_i + m_j - o))$, where $o$ is an overlap parameter accounting for the fact that domains of nearby orbitals are not disjoint. Since we assume uniform domain sizes $m_i = m_j = m$, this simplifies to a uniform pair domain size $m_p$ for all strong pairs:\n$$ m_p = \\min(n_v, \\max(1, 2m - o)) $$\nThe $\\max(1, \\dots)$ ensures the domain size is at least $1$, and the $\\min(n_v, \\dots)$ ensures it cannot exceed the total number of available virtual orbitals.\n\n**b. Number of Retained PNOs ($l$)**\nPNOs are obtained by diagonalizing the pair-density matrix, which is of size $m_p \\times m_p$. The resulting eigenvalues, or PNO \"occupation numbers\", typically exhibit rapid decay. This allows for a significant truncation of the PNO space. The problem models the eigenvalues as $\\lambda_k = A \\exp(-\\alpha (k-1))$ for the $k$-th PNO.\n\nPNOs are retained if their eigenvalue $\\lambda_k$ is greater than or equal to a truncation threshold $\\tau$. We seek the largest integer $k$ for which this condition holds.\n$$ A \\exp(-\\alpha (k-1)) \\ge \\tau $$\nAssuming $A > 0$ and $\\alpha > 0$, we can solve for $k$:\n$$ \\exp(-\\alpha (k-1)) \\ge \\frac{\\tau}{A} $$\n$$ -\\alpha (k-1) \\ge \\ln\\left(\\frac{\\tau}{A}\\right) $$\n$$ \\alpha (k-1) \\le -\\ln\\left(\\frac{\\tau}{A}\\right) = \\ln\\left(\\frac{A}{\\tau}\\right) $$\n$$ k \\le 1 + \\frac{\\ln(A/\\tau)}{\\alpha} $$\nSince $k$ must be an integer, the number of PNOs to keep is the floor of this expression. The problem statement provides a robust formulation for this number, which we denote $l^*$:\n$$ l^* = 1 + \\left\\lfloor \\frac{\\ln\\left(\\max(A,\\tau)/\\tau\\right)}{\\alpha} \\right\\rfloor $$\nThe use of $\\max(A, \\tau)$ handles the case where $A  \\tau$. In this scenario, $\\max(A,\\tau) = \\tau$, the argument of the logarithm becomes $1$, so $\\ln(1)=0$, yielding $l^*=1$. This correctly indicates that if the very first eigenvalue is below the threshold, we still keep one PNO, as per the rules.\n\nThe final number of PNOs, $l$, is subject to two constraints: it must be at least $1$ and cannot exceed the parent domain size $m_p$. This leads to the final expression for $l$:\n$$ l = \\min(m_p, \\max(1, l^*)) $$\nThe problem also specifies that if $A \\le 0$ or $\\alpha \\le 0$, which are physically unmotivated parameter regimes for this model, we default to $l=1$. This ensures a well-defined procedure. We assume a uniform PNO count $l$ for all strong pairs.\n\n**4. Total Costs for Pair-Dependent Steps**\n\nThe following costs are incurred for each of the $N_{\\mathrm{pairs}}$ strong pairs. The total cost for each step is the per-pair cost multiplied by $N_{\\mathrm{pairs}}$.\n\n**a. Total PNO Eigensolver Cost ($C_{\\mathrm{PNO\\;eig, total}}$)**\nGenerating PNOs for one pair requires the diagonalization of its pair-density matrix of size $m_p \\times m_p$. Using the primitive for a symmetric eigensolve, the cost per pair is:\n$$ C_{\\mathrm{PNO\\;eig}} = \\frac{10}{3} m_p^3 $$\nThe total cost over all strong pairs is:\n$$ C_{\\mathrm{PNO\\;eig, total}} = N_{\\mathrm{pairs}} \\cdot C_{\\mathrm{PNO\\;eig}} = N_{\\mathrm{pairs}} \\cdot \\frac{10}{3} m_p^3 $$\n\n**b. Total RI Integral Transformation Cost ($C_{\\mathrm{RI, total}}$)**\nThe use of the Resolution-of-Identity (RI) approximation introduces an auxiliary basis set of size $n_{\\mathrm{aux}}$. Computationally, this involves handling three-index quantities and transforming them to the PNO basis. A simplified cost model is provided:\n$$ C_{\\mathrm{RI}} = 2 n_{\\mathrm{aux}} m_p l + n_{\\mathrm{aux}} l^2 $$\nThis expression plausibly models tensor contractions. For example, a transformation of a matrix of size $n_{\\mathrm{aux}} \\times m_p$ by a PNO coefficient matrix of size $m_p \\times l$ scales as $n_{\\mathrm{aux}} m_p l$. While a simplification, it captures the correct dependencies on the basis and truncation sizes. The total cost is:\n$$ C_{\\mathrm{RI, total}} = N_{\\mathrm{pairs}} \\cdot C_{\\mathrm{RI}} = N_{\\mathrm{pairs}} \\cdot (2 n_{\\mathrm{aux}} m_p l + n_{\\mathrm{aux}} l^2) $$\n\n**c. Total Coupled Cluster Amplitude Update Cost ($C_{\\mathrm{CC, total}}$)**\nThe core of the coupled cluster calculation is iteratively solving the amplitude equations. For doubles amplitudes within the PNO space for a single pair, the dominant computational cost scales as the fourth power of the number of PNOs, $l$. The problem models the cost of one iteration as $c_{\\mathrm{CC}} l^4$. Assuming a fixed number of iterations, $n_{\\mathrm{it}}$, the cost per pair is:\n$$ C_{\\mathrm{CC}} = c_{\\mathrm{CC}} n_{\\mathrm{it}} l^4 $$\nThis $O(l^4)$ scaling is characteristic of the dominant diagrams in the CCSD equations evaluated in a PNO basis. The total cost over all pairs is:\n$$ C_{\\mathrm{CC, total}} = N_{\\mathrm{pairs}} \\cdot C_{\\mathrm{CC}} = N_{\\mathrm{pairs}} \\cdot c_{\\mathrm{CC}} n_{\\mathrm{it}} l^4 $$\n\n**5. Grand Total Cost**\n\nThe grand total computational cost is the sum of the costs of all modeled steps:\n$$ C_{\\mathrm{total}} = C_{\\mathrm{LMO}} + C_{\\mathrm{PNO\\;eig, total}} + C_{\\mathrm{RI, total}} + C_{\\mathrm{CC, total}} $$\n\nThe numerical implementation will proceed by calculating these quantities for each test case using the specified parameters and formulas, rounding the final cost components to the nearest integer.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_costs(params):\n    \"\"\"\n    Calculates the DLPNO-CCSD flop counts for a single set of parameters.\n\n    Args:\n        params (tuple): A tuple containing all the model parameters:\n            (n_o, n_v, m, o, r, s_loc, alpha, A, tau, n_it, c_CC, n_aux)\n\n    Returns:\n        list: A list of integer flop counts:\n              [LMO_cost, PNO_eig_cost_total, RI_cost_total, CC_cost_total, grand_total]\n    \"\"\"\n    n_o, n_v, m, o, r, s_loc, alpha, A, tau, n_it, c_CC, n_aux = params\n\n    # Step 1: LMO Generation Cost\n    lmo_cost = (10.0 / 3.0) * s_loc * n_o**3\n\n    # Step 2: Number of Strong Pairs (N_pairs)\n    # The sum is over k from 1 to min(r, n_o - 1)\n    max_k = min(r, n_o - 1)\n    if max_k  1:\n        n_pairs = 0\n    else:\n        n_pairs = sum(n_o - k for k in range(1, int(max_k) + 1))\n    \n    # If there are no pairs, the pair-dependent costs are zero.\n    if n_pairs == 0:\n        pno_eig_cost_total = 0.0\n        ri_cost_total = 0.0\n        cc_cost_total = 0.0\n    else:\n        # Step 3a: Pair Domain Size (m_p)\n        m_p = min(n_v, max(1, 2 * m - o))\n\n        # Step 3b: Number of Retained PNOs (l)\n        if A = 0 or alpha = 0:\n            l = 1\n        else:\n            # Calculate l_star from the eigenvalue decay model\n            log_arg = max(A, tau) / tau\n            l_star = 1 + np.floor(np.log(log_arg) / alpha)\n            l = min(m_p, max(1, l_star))\n        \n        # Ensure m_p and l are integers for subsequent calculations\n        m_p = int(m_p)\n        l = int(l)\n\n        # Step 4: Total Costs for Pair-Dependent Steps\n        # 4a: PNO Eigensolver Cost\n        pno_eig_cost_per_pair = (10.0 / 3.0) * m_p**3\n        pno_eig_cost_total = n_pairs * pno_eig_cost_per_pair\n\n        # 4b: RI Integral Transformation Cost\n        ri_cost_per_pair = 2 * n_aux * m_p * l + n_aux * l**2\n        ri_cost_total = n_pairs * ri_cost_per_pair\n\n        # 4c: Coupled Cluster Amplitude Update Cost\n        cc_cost_per_pair = c_CC * n_it * float(l)**4\n        cc_cost_total = n_pairs * cc_cost_per_pair\n    \n    # Step 5: Grand Total Cost\n    grand_total = lmo_cost + pno_eig_cost_total + ri_cost_total + cc_cost_total\n\n    # Round all final costs to the nearest integer as per problem spec\n    return [\n        int(round(lmo_cost)),\n        int(round(pno_eig_cost_total)),\n        int(round(ri_cost_total)),\n        int(round(cc_cost_total)),\n        int(round(grand_total))\n    ]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 40, 20, 8, 2, 3, 1.2, 0.5, 1e-4, 6, 12, 150),\n        (2, 5, 3, 1, 1, 2, 0.8, 0.7, 1e-2, 4, 8, 30),\n        (12, 60, 50, 30, 3, 4, 1.0, 0.6, 1e-5, 8, 16, 200),\n        (8, 20, 10, 12, 0, 2, 1.0, 0.3, 1e-3, 5, 10, 80)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_costs(case)\n        results.append(result)\n\n    # Format the final output string precisely as required: [[...],[...],...]\n    inner_list_strs = []\n    for res_list in results:\n        # Create string for inner list, e.g., \"[1,2,3]\" without spaces\n        inner_list_strs.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Join the inner list strings and enclose in the outermost brackets\n    final_output_str = f\"[{','.join(inner_list_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2903194"}]}