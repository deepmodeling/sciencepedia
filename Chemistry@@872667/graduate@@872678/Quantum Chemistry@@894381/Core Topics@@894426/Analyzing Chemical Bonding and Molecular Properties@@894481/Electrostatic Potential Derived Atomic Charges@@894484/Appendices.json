{"hands_on_practices": [{"introduction": "This foundational exercise explores the conceptual and numerical differences between two major families of atomic charge models: those based on partitioning the electronic wavefunction (Mulliken and Löwdin) and those derived from fitting to a physical observable (Restrained Electrostatic Potential, or RESP). By applying these distinct schemes to a minimal, well-defined diatomic model, you will gain hands-on insight into how the underlying mathematical formalism of a charge model dictates the resulting atomic charges [@problem_id:2889438]. This practice is essential for appreciating why different computational chemistry programs can report different charge values and for making informed decisions when choosing a charge model.", "problem": "You are given a minimal, mathematically well-defined model of a closed-shell diatomic molecule with two atom-centered basis functions. The electron density is represented in an atom-centered orbital (AO) basis by a symmetric, spin-summed density matrix, and the AO overlap is represented by a symmetric, positive-definite overlap matrix. Your task is to compute four sets of atomic partial charges for each test case:\n- Mulliken charges,\n- Löwdin charges,\n- Natural Bond Orbital (NBO) charges in the minimal-basis two-AO limit (as explained below),\n- Restrained Electrostatic Potential (RESP) charges from a regularized least-squares fit to a given set of electrostatic potential values.\n\nAll computations must be performed in atomic units. Distances must be taken in bohr, electrostatic potentials in atomic units of potential (Hartree per unit charge), and charges in units of the elementary charge.\n\nFundamental base and core definitions to use:\n- The total number of electrons in a closed-shell system described by an AO density matrix is given by $N_{\\mathrm{e}} = \\mathrm{Tr}\\!\\left(\\mathbf{P}\\mathbf{S}\\right)$, where $\\mathbf{P}$ is the spin-summed AO density matrix and $\\mathbf{S}$ is the AO overlap matrix.\n- For a two-function AO basis $\\{\\chi_1,\\chi_2\\}$, the overlap matrix is $\\mathbf{S} = \\begin{pmatrix} 1  s \\\\ s  1 \\end{pmatrix}$ with $|s|  1$ to ensure positive definiteness. A normalized occupied molecular orbital $\\phi = c_1 \\chi_1 + c_2 \\chi_2$ satisfies $\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c} = 1$, and the spin-summed density is $\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\top}$.\n- Mulliken gross atomic population on atom $A$ with AO index set $\\mathcal{A}$ is $N_A^{\\mathrm{Mul}} = \\sum_{\\mu \\in \\mathcal{A}} \\left(\\mathbf{P}\\mathbf{S}\\right)_{\\mu\\mu}$. The Mulliken charge is $q_A^{\\mathrm{Mul}} = Z_A - N_A^{\\mathrm{Mul}}$, where $Z_A$ is the nuclear charge on atom $A$.\n- Löwdin population analysis proceeds via symmetric orthogonalization. Let $\\mathbf{S} = \\mathbf{U}\\,\\boldsymbol{\\sigma}\\,\\mathbf{U}^{\\top}$ be the eigendecomposition with $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_1,\\sigma_2)$ and $\\sigma_i  0$. Define $\\mathbf{S}^{1/2} = \\mathbf{U}\\,\\boldsymbol{\\sigma}^{1/2}\\,\\mathbf{U}^{\\top}$. The Löwdin-orthogonal density is $\\mathbf{P}_L = \\mathbf{S}^{1/2}\\mathbf{P}\\mathbf{S}^{1/2}$. The Löwdin gross atomic population on atom $A$ equals the sum of diagonal elements of $\\mathbf{P}_L$ over AOs on $A$. For the two-AO diatomic with one AO per atom, $N_A^{\\mathrm{Low}} = \\left(\\mathbf{P}_L\\right)_{11}$ and $N_B^{\\mathrm{Low}} = \\left(\\mathbf{P}_L\\right)_{22}$. The Löwdin charge is $q_A^{\\mathrm{Low}} = Z_A - N_A^{\\mathrm{Low}}$.\n- In the minimal two-AO limit, Natural Bond Orbital (NBO) charges reduce to Natural Population Analysis (NPA) charges evaluated in a set of natural atomic orbitals very close to Löwdin-orthogonalized AOs; hence, for this two-function model, you must take $q_A^{\\mathrm{NBO}} = q_A^{\\mathrm{Low}}$.\n- Restrained Electrostatic Potential (RESP) charges are obtained by fitting atom-centered point charges to reproduce the molecular electrostatic potential (ESP) on a grid of $m$ points with quadratic restraint. Given grid distances $r_{iA}$ and $r_{iB}$ from point $i$ to atoms $A$ and $B$, and ESP values $V_i$, define the $m \\times 2$ matrix $\\mathbf{A}$ with $A_{i1} = 1/r_{iA}$ and $A_{i2} = 1/r_{iB}$. For a restraint parameter $\\alpha \\ge 0$ and target net charge $Q_{\\mathrm{tot}}$, solve the constrained Tikhonov-regularized least squares\n$$\n\\min_{\\mathbf{q}\\in\\mathbb{R}^2}\\ \\|\\mathbf{A}\\mathbf{q} - \\mathbf{V}\\|_2^2 + \\alpha \\|\\mathbf{q}\\|_2^2\\quad \\text{subject to}\\quad \\mathbf{c}^{\\top}\\mathbf{q} = Q_{\\mathrm{tot}},\n$$\nwhere $\\mathbf{c} = (1,1)^{\\top}$. The Karush–Kuhn–Tucker system is\n$$\n\\begin{pmatrix}\n\\mathbf{H}  \\mathbf{c} \\\\\n\\mathbf{c}^{\\top}  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{b} \\\\\nQ_{\\mathrm{tot}}\n\\end{pmatrix},\\quad\n\\mathbf{H} = \\mathbf{A}^{\\top}\\mathbf{A} + \\alpha \\mathbf{I}_2,\\quad \\mathbf{b} = \\mathbf{A}^{\\top}\\mathbf{V},\n$$\nwhich yields the RESP charges $\\mathbf{q}^{\\mathrm{RESP}}$.\n\nTask details:\n1. For each test case, you are given a scalar AO overlap off-diagonal parameter $s$, a non-normalized molecular orbital coefficient vector $\\mathbf{u} = (u_1,u_2)^{\\top}$, nuclear charges $(Z_A,Z_B)$, and a RESP fitting grid with tuples $(r_{iA}, r_{iB}, V_i)$ for $i=1,\\dots,m$, along with a restraint parameter $\\alpha$. Construct the overlap matrix $\\mathbf{S} = \\begin{pmatrix} 1  s \\\\ s  1 \\end{pmatrix}$. Normalize the MO coefficient as $\\mathbf{c} = \\mathbf{u}/\\sqrt{\\mathbf{u}^{\\top}\\mathbf{S}\\mathbf{u}}$, then form the spin-summed density $\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\top}$.\n2. Compute $q_A^{\\mathrm{Mul}}, q_B^{\\mathrm{Mul}}$ from the Mulliken scheme.\n3. Compute $q_A^{\\mathrm{Low}}, q_B^{\\mathrm{Low}}$ from the Löwdin scheme.\n4. Set $q_A^{\\mathrm{NBO}} = q_A^{\\mathrm{Low}}$ and $q_B^{\\mathrm{NBO}} = q_B^{\\mathrm{Low}}$, justified by the minimal two-AO limit as specified above.\n5. Compute RESP charges $(q_A^{\\mathrm{RESP}}, q_B^{\\mathrm{RESP}})$ by solving the constrained system with target net charge $Q_{\\mathrm{tot}} = Z_A + Z_B - N_{\\mathrm{e}}$, where $N_{\\mathrm{e}} = \\mathrm{Tr}(\\mathbf{P}\\mathbf{S})$.\n\nTest suite:\nProvide results for the following three test cases. In all cases, distances are in bohr and potentials in atomic units; the restraint target charges are zero by construction because $Z_A + Z_B = N_{\\mathrm{e}}$.\n- Case 1 (homonuclear, symmetric):\n  - $s = 0.30$, $\\mathbf{u} = (1.0, 1.0)^{\\top}$, $(Z_A,Z_B) = (1.0, 1.0)$,\n  - RESP grid: $\\{(r_{iA}, r_{iB}, V_i)\\}_{i=1}^4 = \\{(2.0, 2.0, 0.0),\\ (2.5, 2.5, 0.0),\\ (3.0, 3.0, 0.0),\\ (4.0, 4.0, 0.0)\\}$,\n  - $\\alpha = 0.10$.\n- Case 2 (heteronuclear-like, polarized density and informative ESP):\n  - $s = 0.20$, $\\mathbf{u} = (0.35, 1.00)^{\\top}$, $(Z_A,Z_B) = (1.0, 1.0)$,\n  - RESP grid: $\\{(2.0, 1.2, 0.0833333333),\\ (2.5, 1.3, 0.0923076923),\\ (3.0, 2.0, 0.0416666667),\\ (2.2, 4.0, -0.0511363636),\\ (5.0, 1.5, 0.1166666667)\\}$,\n  - $\\alpha = 0.01$.\n- Case 3 (pathological overlap near linear dependence):\n  - $s = 0.95$, $\\mathbf{u} = (1.0, 0.2)^{\\top}$, $(Z_A,Z_B) = (1.0, 1.0)$,\n  - RESP grid: $\\{(2.0, 3.0, 0.0),\\ (3.0, 2.0, 0.0),\\ (4.0, 4.0, 0.0)\\}$,\n  - $\\alpha = 0.10$.\n\nAngle units do not apply. No percentages are involved.\n\nRequired final output format:\n- Your program must produce a single line of output containing a list of results for each test case, in order. Each test case result must be a list of four lists $[q^{\\mathrm{Mul}}, q^{\\mathrm{Low}}, q^{\\mathrm{NBO}}, q^{\\mathrm{RESP}}]$, and each of those is a two-element list $[q_A, q_B]$.\n- All numbers must be printed as decimal floats rounded to six digits after the decimal point.\n- The final printed form must therefore be a single line like\n$[[[q_{A,1}^{\\mathrm{Mul}},q_{B,1}^{\\mathrm{Mul}}],[q_{A,1}^{\\mathrm{Low}},q_{B,1}^{\\mathrm{Low}}],[q_{A,1}^{\\mathrm{NBO}},q_{B,1}^{\\mathrm{NBO}}],[q_{A,1}^{\\mathrm{RESP}},q_{B,1}^{\\mathrm{RESP}}]],\\ \\dots\\ ,[[q_{A,3}^{\\mathrm{Mul}},q_{B,3}^{\\mathrm{Mul}}],[q_{A,3}^{\\mathrm{Low}},q_{B,3}^{\\mathrm{Low}}],[q_{A,3}^{\\mathrm{NBO}},q_{B,3}^{\\mathrm{NBO}}],[q_{A,3}^{\\mathrm{RESP}},q_{B,3}^{\\mathrm{RESP}}]]]$ with commas delimiting elements and no additional text.\n\nScientific realism and constraints:\n- Work entirely within the given matrices and grids; do not assume any additional basis functions or external data.\n- The diatomic is closed-shell with $N_{\\mathrm{e}}=2$ electrons by construction via $\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\top}$ and $\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c} = 1$.\n- The difference between Mulliken and Löwdin arises from how overlap is partitioned versus orthogonalized. In the minimal two-AO limit used here, Natural Bond Orbital charges coincide with Löwdin charges. Discrepancies with RESP stem from fitting the Electrostatic Potential (ESP) under a charge-conservation constraint with regularization.\n\nYour program must implement the above definitions exactly and produce the required single-line output in the exact format described.", "solution": "The problem presented is a well-defined exercise in computational quantum chemistry, requiring the calculation of four types of atomic partial charges for a minimal two-orbital model of a diatomic molecule. The problem is scientifically grounded in established theories, mathematically consistent, and provides all necessary data for a unique solution. It is therefore deemed valid. We proceed with a systematic derivation of the solution.\n\nThe entire procedure is executed for each test case, which provides the atomic orbital (AO) overlap parameter $s$, an unnormalized molecular orbital (MO) coefficient vector $\\mathbf{u}$, the nuclear charges $(Z_A, Z_B)$, a grid for Restrained Electrostatic Potential (RESP) fitting, and the RESP regularization parameter $\\alpha$. All calculations are performed in atomic units.\n\n**Step 1: Construction of the Density Matrix**\n\nFirst, we construct the fundamental matrices required for all population analyses.\n\n1.  **Overlap Matrix ($\\mathbf{S}$):** Given the off-diagonal overlap element $s$, the $2 \\times 2$ AO overlap matrix $\\mathbf{S}$ is constructed as:\n    $$\n    \\mathbf{S} = \\begin{pmatrix} 1  s \\\\ s  1 \\end{pmatrix}\n    $$\n    For $\\mathbf{S}$ to be positive-definite, a physical requirement for a basis set overlap, it must hold that $|s|  1$, which is true for all test cases.\n\n2.  **MO Coefficient Normalization:** The given MO coefficient vector $\\mathbf{u} = (u_1, u_2)^{\\top}$ is defined in the non-orthogonal AO basis. Normalization of the corresponding MO, $\\phi = \\sum_{\\mu} c_{\\mu} \\chi_{\\mu}$, requires that $\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c} = 1$. The normalization factor is $N = (\\mathbf{u}^{\\top}\\mathbf{S}\\mathbf{u})^{-1/2}$.\n    The inner product is computed as:\n    $$\n    \\mathbf{u}^{\\top}\\mathbf{S}\\mathbf{u} = \\begin{pmatrix} u_1  u_2 \\end{pmatrix} \\begin{pmatrix} 1  s \\\\ s  1 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} = u_1^2 + u_2^2 + 2su_1u_2\n    $$\n    The normalized coefficient vector is then $\\mathbf{c} = \\mathbf{u} / \\sqrt{u_1^2 + u_2^2 + 2su_1u_2}$.\n\n3.  **Density Matrix ($\\mathbf{P}$):** For a closed-shell system with one doubly occupied MO, the spin-summed density matrix $\\mathbf{P}$ in the AO basis is given by $\\mathbf{P} = 2\\mathbf{c}\\mathbf{c}^{\\top}$.\n    $$\n    \\mathbf{P} = 2 \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} \\begin{pmatrix} c_1  c_2 \\end{pmatrix} = 2 \\begin{pmatrix} c_1^2  c_1c_2 \\\\ c_1c_2  c_2^2 \\end{pmatrix}\n    $$\n    The total number of electrons is $N_{\\mathrm{e}} = \\mathrm{Tr}(\\mathbf{P}\\mathbf{S})$. By construction, $\\mathrm{Tr}(\\mathbf{P}\\mathbf{S}) = \\mathrm{Tr}(2\\mathbf{c}\\mathbf{c}^{\\top}\\mathbf{S}) = 2\\,\\mathrm{Tr}(\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c}) = 2(1) = 2$, which is consistent with the problem description.\n\n**Step 2: Mulliken Population Analysis**\n\nMulliken analysis partitions the electron density by assigning diagonal contributions of the density-overlap product matrix, $(\\mathbf{PS})$, to individual atoms and splitting the off-diagonal (overlap population) terms equally. The gross atomic population on atom $A$ (associated with basis function $\\chi_1$) and atom $B$ (associated with $\\chi_2$) is:\n$N_A^{\\mathrm{Mul}} = (\\mathbf{P}\\mathbf{S})_{11}$ and $N_B^{\\mathrm{Mul}} = (\\mathbf{P}\\mathbf{S})_{22}$.\n\nThe matrix product $\\mathbf{P}\\mathbf{S}$ is:\n$$\n\\mathbf{P}\\mathbf{S} = 2 \\begin{pmatrix} c_1^2  c_1c_2 \\\\ c_1c_2  c_2^2 \\end{pmatrix} \\begin{pmatrix} 1  s \\\\ s  1 \\end{pmatrix} = 2 \\begin{pmatrix} c_1^2 + sc_1c_2  sc_1^2 + c_1c_2 \\\\ sc_2^2 + c_1c_2  c_2^2 + sc_1c_2 \\end{pmatrix}\n$$\nThe populations are thus:\n$$\nN_A^{\\mathrm{Mul}} = 2(c_1^2 + sc_1c_2)\n$$\n$$\nN_B^{\\mathrm{Mul}} = 2(c_2^2 + sc_1c_2)\n$$\nThe Mulliken partial charges are then calculated as $q_A = Z_A - N_A$:\n$$\nq_A^{\\mathrm{Mul}} = Z_A - 2(c_1^2 + sc_1c_2)\n$$\n$$\nq_B^{\\mathrm{Mul}} = Z_B - 2(c_2^2 + sc_1c_2)\n$$\n\n**Step 3: Löwdin and NBO Population Analysis**\n\nLöwdin analysis first transforms the basis to an orthogonal one using symmetric orthogonalization, $\\boldsymbol{\\chi}' = \\boldsymbol{\\chi} \\mathbf{S}^{-1/2}$, and then computes populations.\n\n1.  **Symmetric Orthogonalization Matrix:** We require the matrix $\\mathbf{S}^{1/2}$. This is computed from the eigendecomposition of $\\mathbf{S} = \\mathbf{U}\\boldsymbol{\\sigma}\\mathbf{U}^{\\top}$ as $\\mathbf{S}^{1/2} = \\mathbf{U}\\boldsymbol{\\sigma}^{1/2}\\mathbf{U}^{\\top}$. For the given $2 \\times 2$ matrix $\\mathbf{S}$, this can be calculated analytically or numerically. We will use a numerical library function for robustness.\n\n2.  **Löwdin-Transformed Density:** The density matrix in the Löwdin-orthogonalized basis, $\\mathbf{P}_L$, is given by:\n    $$\n    \\mathbf{P}_L = \\mathbf{S}^{1/2} \\mathbf{P} \\mathbf{S}^{1/2}\n    $$\n\n3.  **Löwdin Populations and Charges:** In the orthogonal basis, the gross atomic populations are simply the diagonal elements of $\\mathbf{P}_L$:\n    $$\n    N_A^{\\mathrm{Low}} = (\\mathbf{P}_L)_{11}\n    $$\n    $$\n    N_B^{\\mathrm{Low}} = (\\mathbf{P}_L)_{22}\n    $$\n    The charges follow as:\n    $$\n    q_A^{\\mathrm{Low}} = Z_A - N_A^{\\mathrm{Low}} \\quad \\text{and} \\quad q_B^{\\mathrm{Low}} = Z_B - N_B^{\\mathrm{Low}}\n    $$\n\n4.  **NBO Charges:** The problem states that for this minimal two-AO model, the Natural Bond Orbital (NBO) charges are equivalent to the Löwdin charges. This is a simplification, as true NBO analysis involves a more complex procedure of identifying natural atomic orbitals and lone pairs. We thus set:\n    $$\n    q_A^{\\mathrm{NBO}} = q_A^{\\mathrm{Low}} \\quad \\text{and} \\quad q_B^{\\mathrm{NBO}} = q_B^{\\mathrm{Low}}\n    $$\n\n**Step 4: RESP Charge Calculation**\n\nRESP charges, $\\mathbf{q} = (q_A, q_B)^{\\top}$, are determined by a least-squares fit to the molecular electrostatic potential (ESP) on a grid of $m$ points, subject to a charge conservation constraint and Tikhonov regularization. This is a constrained optimization problem, which is solved via the Karush-Kuhn-Tucker (KKT) system of equations.\n\n1.  **System Formulation:** The KKT system is specified as:\n    $$\n    \\begin{pmatrix}\n    \\mathbf{H}  \\mathbf{c_q} \\\\\n    \\mathbf{c_q}^{\\top}  0\n    \\end{pmatrix}\n    \\begin{pmatrix}\n    \\mathbf{q} \\\\\n    \\lambda\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    \\mathbf{b} \\\\\n    Q_{\\mathrm{tot}}\n    \\end{pmatrix}\n    $$\n    where $\\mathbf{c_q} = (1, 1)^{\\top}$ and $\\lambda$ is a Lagrange multiplier.\n\n2.  **Component Construction:**\n    *   The total target charge is $Q_{\\mathrm{tot}} = Z_A + Z_B - N_{\\mathrm{e}} = (1.0+1.0) - 2.0 = 0$ for all test cases.\n    *   The ESP design matrix $\\mathbf{A}$ ($m \\times 2$) is built from the grid point distances: $A_{i1} = 1/r_{iA}$ and $A_{i2} = 1/r_{iB}$.\n    *   The ESP value vector $\\mathbf{V}$ ($m \\times 1$) consists of the given $V_i$ values.\n    *   The regularized Hessian is $\\mathbf{H} = \\mathbf{A}^{\\top}\\mathbf{A} + \\alpha \\mathbf{I}_2$.\n    *   The gradient vector is $\\mathbf{b} = \\mathbf{A}^{\\top}\\mathbf{V}$.\n\n3.  **Solution:** The $3 \\times 3$ KKT linear system is constructed and solved for the vector $(\\mathbf{q}^{\\top}, \\lambda)^{\\top}$. The first two elements are the desired RESP charges, $(q_A^{\\mathrm{RESP}}, q_B^{\\mathrm{RESP}})$. Given $\\alpha  0$ and non-collinear grid points, the KKT matrix is invertible, guaranteeing a unique solution.\n\nThis completes the theoretical framework. The implementation will follow these steps precisely for each of the three test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import sqrtm\n\ndef format_results(results):\n    \"\"\"\n    Formats the final results into the precise string representation required.\n    All numbers are rounded to six decimal places.\n    \"\"\"\n    case_strings = []\n    for case_result in results:\n        # case_result is a list of 4 charge pairs, e.g., [q_mul, q_low, q_nbo, q_resp]\n        charge_type_strings = []\n        for charge_pair in case_result:\n            # charge_pair is [q_A, q_B]\n            q_a, q_b = charge_pair\n            charge_type_strings.append(f\"[{q_a:.6f},{q_b:.6f}]\")\n        case_strings.append(f\"[{','.join(charge_type_strings)}]\")\n    return f\"[{','.join(case_strings)}]\"\n\ndef calculate_charges(s, u_vec, z_charges, resp_grid, alpha):\n    \"\"\"\n    Calculates Mulliken, Löwdin, NBO, and RESP charges for a single test case.\n    \"\"\"\n    u_vec = np.array(u_vec, dtype=float)\n    z_charges = np.array(z_charges, dtype=float)\n\n    # --- Step 1: Construct Density Matrix ---\n    S = np.array([[1.0, s], [s, 1.0]], dtype=float)\n    \n    # Normalize MO coefficients: c = u / sqrt(u^T * S * u)\n    norm_sq = u_vec.T @ S @ u_vec\n    c_vec = u_vec / np.sqrt(norm_sq)\n    \n    # Construct density matrix: P = 2 * c * c^T\n    P = 2 * np.outer(c_vec, c_vec)\n    \n    # --- Step 2: Mulliken Charges ---\n    PS = P @ S\n    N_mul = np.diag(PS)\n    q_mul = z_charges - N_mul\n\n    # --- Step 3: Löwdin and NBO Charges ---\n    # S_half is S^(1/2)\n    S_half = sqrtm(S)\n    P_L = S_half @ P @ S_half\n    N_low = np.diag(P_L)\n    q_low = z_charges - N_low\n    \n    # NBO charges are equal to Löwdin charges for this minimal model\n    q_nbo = q_low\n\n    # --- Step 4: RESP Charges ---\n    N_e = np.trace(PS).round(10) # Should be 2.0\n    Q_tot = np.sum(z_charges) - N_e\n\n    m = len(resp_grid) # Number of grid points\n    A = np.zeros((m, 2), dtype=float)\n    V = np.zeros(m, dtype=float)\n\n    for i, (r_iA, r_iB, V_i) in enumerate(resp_grid):\n        A[i, 0] = 1.0 / r_iA\n        A[i, 1] = 1.0 / r_iB\n        V[i] = V_i\n        \n    H = A.T @ A + alpha * np.identity(2)\n    b = A.T @ V\n\n    # Solve the 3x3 KKT system\n    kkt_matrix = np.zeros((3, 3), dtype=float)\n    kkt_matrix[:2, :2] = H\n    kkt_matrix[2, :2] = 1.0\n    kkt_matrix[:2, 2] = 1.0\n    \n    rhs_vector = np.zeros(3, dtype=float)\n    rhs_vector[:2] = b\n    rhs_vector[2] = Q_tot\n    \n    solution = np.linalg.solve(kkt_matrix, rhs_vector)\n    q_resp = solution[:2]\n\n    return [q_mul.tolist(), q_low.tolist(), q_nbo.tolist(), q_resp.tolist()]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"s\": 0.30,\n            \"u\": [1.0, 1.0],\n            \"Z\": [1.0, 1.0],\n            \"resp_grid\": [\n                (2.0, 2.0, 0.0), (2.5, 2.5, 0.0), \n                (3.0, 3.0, 0.0), (4.0, 4.0, 0.0)\n            ],\n            \"alpha\": 0.10,\n        },\n        {\n            \"s\": 0.20,\n            \"u\": [0.35, 1.00],\n            \"Z\": [1.0, 1.0],\n            \"resp_grid\": [\n                (2.0, 1.2, 0.0833333333), (2.5, 1.3, 0.0923076923),\n                (3.0, 2.0, 0.0416666667), (2.2, 4.0, -0.0511363636),\n                (5.0, 1.5, 0.1166666667)\n            ],\n            \"alpha\": 0.01,\n        },\n        {\n            \"s\": 0.95,\n            \"u\": [1.0, 0.2],\n            \"Z\": [1.0, 1.0],\n            \"resp_grid\": [\n                (2.0, 3.0, 0.0), (3.0, 2.0, 0.0), (4.0, 4.0, 0.0)\n            ],\n            \"alpha\": 0.10,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_charges(\n            case[\"s\"], case[\"u\"], case[\"Z\"], case[\"resp_grid\"], case[\"alpha\"]\n        )\n        results.append(result)\n\n    final_output = format_results(results)\n    print(final_output)\n\nsolve()\n```", "id": "2889438"}, {"introduction": "Building upon the concept of ESP-fitted charges, this practice delves into the mechanics of the least-squares fitting procedure itself. You will investigate the critical role of imposing physical constraints, such as the conservation of total molecular charge, by comparing an unconstrained fit with a constrained one implemented via a Lagrange multiplier system [@problem_id:2889373]. Furthermore, this exercise highlights a key aspect of model validation: assessing how errors in the fitted parameters (atomic charges) propagate to errors in other important calculated properties, such as the molecular dipole moment.", "problem": "Consider the task of deriving electrostatic potential (ESP) fitted atomic charges for a monovalent ion from first principles. Work entirely in atomic units: lengths in Bohr radius $a_0$, charges in elementary charge $e$, and electrostatic potential in Hartree per $e$ (so that Coulomb’s law reads simply as $V(\\mathbf{r}) = \\sum_i q_i / \\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert$). The electric dipole moment is therefore $\\boldsymbol{\\mu} = \\sum_i q_i \\mathbf{R}_i$ in units of $e\\,a_0$. Assume measurement noise is additive, independent, and identically distributed, with zero mean and specified standard deviation. The forward model for $M$ grid points is\n$$\nV_j = \\sum_{i=1}^{N} \\frac{q_i}{\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert} + \\eta_j,\\quad j = 1,\\dots, M,\n$$\nwhere $N$ is the number of atoms, $\\mathbf{R}_i$ are the nuclear positions, $q_i$ are the unknown atomic charges to be fitted, $\\mathbf{r}_j$ are the grid points, and $\\eta_j$ are noise samples.\n\nStarting from Coulomb’s law and the least-squares principle, you must:\n- Implement the unconstrained least-squares fit for $\\mathbf{q}$ that minimizes $\\sum_{j=1}^{M} \\left(V_j - \\sum_{i=1}^N q_i / \\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert\\right)^2$.\n- Implement the equality-constrained least-squares fit that enforces the total charge constraint $\\sum_{i=1}^{N} q_i = Q_{\\text{tot}}$ using a mathematically sound method derived from first principles (e.g., a Lagrange multiplier Karush–Kuhn–Tucker system).\n- For each fit, compute:\n  1. The total charge from the unconstrained fit, $\\sum_i \\hat{q}_i^{(\\text{uncon})}$ (a float).\n  2. The electric dipole vector error for the unconstrained fit, $\\lVert \\sum_i (\\hat{q}_i^{(\\text{uncon})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$ (a float, in $e\\,a_0$).\n  3. The electric dipole vector error for the constrained fit, $\\lVert \\sum_i (\\hat{q}_i^{(\\text{con})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$ (a float, in $e\\,a_0$).\n\nUse the following test suite. In all cases, generate the observed potentials by $V_j = \\sum_i q_i^{(\\text{true})}/\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert + \\eta_j$, where $\\eta_j$ are independent Gaussian samples with the stated standard deviation, drawn using a fixed random seed for reproducibility. All coordinates are in $a_0$, all charges in $e$, all potentials in atomic units, and all dipole errors must be reported in $e\\,a_0$.\n\n- Test case A (general overdetermined, cation, moderate noise):\n  - $N = 3$, $Q_{\\text{tot}} = +1$.\n  - Nuclear positions $\\mathbf{R}_i$: $[(0,0,0),\\ (1,0,0),\\ (0,1,0)]$.\n  - True charges $\\mathbf{q}^{(\\text{true})}$: $[0.3,\\ 0.5,\\ 0.2]$.\n  - Grid points $\\mathbf{r}_j$: $[(2,0,0),\\ (0,2,0),\\ (2,2,0),\\ (1,1,1),\\ (-1,-1,0.5),\\ (3,1,0),\\ (1,3,0),\\ (1,1,-1)]$.\n  - Noise: Gaussian with standard deviation $\\sigma = 10^{-4}$; random seed $123$.\n\n- Test case B (exactly determined, collinear geometry, very low noise):\n  - $N = 3$, $Q_{\\text{tot}} = +1$.\n  - Nuclear positions $\\mathbf{R}_i$: $[(0,0,0),\\ (1.2,0,0),\\ (2.4,0,0)]$.\n  - True charges $\\mathbf{q}^{(\\text{true})}$: $[0.7,\\ 0.2,\\ 0.1]$.\n  - Grid points $\\mathbf{r}_j$: $[(0,2,0),\\ (1.2,2,0),\\ (2.4,2,0)]$.\n  - Noise: Gaussian with standard deviation $\\sigma = 10^{-6}$; random seed $321$.\n\n- Test case C (overdetermined, anion, stronger noise and a far-field point):\n  - $N = 3$, $Q_{\\text{tot}} = -1$.\n  - Nuclear positions $\\mathbf{R}_i$: $[(0,0,0),\\ (1,0,0),\\ (0,0,1)]$.\n  - True charges $\\mathbf{q}^{(\\text{true})}$: $[-0.6,\\ -0.2,\\ -0.2]$.\n  - Grid points $\\mathbf{r}_j$: $[(2,0,0),\\ (0,2,0),\\ (2,2,0),\\ (1,1,1),\\ (-1,-1,1),\\ (3,0,0),\\ (10,10,10)]$.\n  - Noise: Gaussian with standard deviation $\\sigma = 5\\times 10^{-4}$; random seed $999$.\n\nYour program should:\n- Construct the design matrix with entries $A_{j i} = 1/\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert$ for each test case.\n- Generate $V_j$ with the specified noise using the given seeds.\n- Compute the unconstrained and constrained fits as specified above.\n- Compute, for each test case, the three required floats in the order described.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of three lists, one per test case, in the order A, B, C. Each inner list must be of the form $[\\sum_i \\hat{q}_i^{(\\text{uncon})},\\ \\text{dipole\\_error}^{(\\text{uncon})},\\ \\text{dipole\\_error}^{(\\text{con})}]$, where the dipole errors are in $e\\,a_0$.\n- For example: $[[x_A,y_A,z_A],[x_B,y_B,z_B],[x_C,y_C,z_C]]$ where each $x,y,z$ is a float.", "solution": "The problem of determining atomic charges from electrostatic potential data is a classic inverse problem in computational chemistry. We are given a set of nuclear positions $\\{\\mathbf{R}_i\\}_{i=1}^N$, a set of grid points $\\{\\mathbf{r}_j\\}_{j=1}^M$, and the corresponding electrostatic potentials $\\{V_j\\}_{j=1}^M$ measured at these grid points. The forward model, based on Coulomb's law in atomic units, relates the unknown atomic charges $\\{q_i\\}_{i=1}^N$ to the potentials via a linear system of equations, corrupted by noise:\n$$\nV_j = \\sum_{i=1}^{N} \\frac{q_i}{\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert} + \\eta_j\n$$\nThis can be expressed in matrix form as:\n$$\n\\mathbf{V} = A \\mathbf{q} + \\boldsymbol{\\eta}\n$$\nHere, $\\mathbf{V}$ is the $M \\times 1$ column vector of observed potentials, $\\mathbf{q}$ is the $N \\times 1$ column vector of unknown charges, and $\\boldsymbol{\\eta}$ is the $M \\times 1$ vector of unknown noise samples. The $M \\times N$ matrix $A$, known as the design matrix, has entries $A_{ji} = 1 / \\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert$. Our objective is to estimate $\\mathbf{q}$ from $\\mathbf{V}$ and $A$.\n\nFirst, we consider the unconstrained least-squares fit. The goal is to find the vector of charges $\\hat{\\mathbf{q}}^{(\\text{uncon})}$ that minimizes the sum of squared residuals, $S(\\mathbf{q}) = \\sum_{j=1}^M (V_j - (A\\mathbf{q})_j)^2$. In matrix notation, this is equivalent to minimizing the squared Euclidean norm of the residual vector:\n$$\nS(\\mathbf{q}) = \\lVert \\mathbf{V} - A\\mathbf{q} \\rVert_2^2 = (\\mathbf{V} - A\\mathbf{q})^T (\\mathbf{V} - A\\mathbf{q})\n$$\nTo find the minimum, we compute the gradient of $S(\\mathbf{q})$ with respect to $\\mathbf{q}$ and set it to zero.\n$$\n\\nabla_{\\mathbf{q}} S(\\mathbf{q}) = \\nabla_{\\mathbf{q}} (\\mathbf{V}^T\\mathbf{V} - 2\\mathbf{V}^T A\\mathbf{q} + \\mathbf{q}^T A^T A\\mathbf{q}) = -2 A^T \\mathbf{V} + 2 A^T A \\mathbf{q}\n$$\nSetting $\\nabla_{\\mathbf{q}} S(\\mathbf{q}) = \\mathbf{0}$ yields the well-known normal equations:\n$$\n(A^T A) \\mathbf{q} = A^T \\mathbf{V}\n$$\nAssuming the matrix $A^T A$ is invertible (which is true if $A$ has full column rank, a condition met in non-degenerate molecular geometries), the unconstrained least-squares solution is:\n$$\n\\hat{\\mathbf{q}}^{(\\text{uncon})} = (A^T A)^{-1} A^T \\mathbf{V}\n$$\nThe matrix $(A^T A)^{-1} A^T$ is the Moore-Penrose pseudoinverse of $A$. Computationally, this system is solved using stable numerical methods such as QR decomposition, as implemented in standard linear algebra libraries.\n\nSecond, we address the equality-constrained least-squares fit. We must minimize the same objective function $S(\\mathbf{q})$ subject to the physical constraint that the sum of atomic charges equals the total charge of the ion, $Q_{\\text{tot}}$. This constraint is linear:\n$$\n\\sum_{i=1}^{N} q_i = Q_{\\text{tot}} \\quad \\text{or} \\quad \\mathbf{c}^T \\mathbf{q} = Q_{\\text{tot}}, \\quad \\text{where } \\mathbf{c} = [1, 1, \\dots, 1]^T\n$$\nThis constrained optimization problem is solved using the method of Lagrange multipliers. We define the Lagrangian function $\\mathcal{L}(\\mathbf{q}, \\lambda)$:\n$$\n\\mathcal{L}(\\mathbf{q}, \\lambda) = \\frac{1}{2}\\lVert \\mathbf{V} - A\\mathbf{q} \\rVert_2^2 + \\lambda (\\mathbf{c}^T \\mathbf{q} - Q_{\\text{tot}})\n$$\nThe factor of $1/2$ is for algebraic convenience. The solution $(\\hat{\\mathbf{q}}^{(\\text{con})}, \\lambda^*)$ is found at a stationary point of $\\mathcal{L}$. We set the partial derivatives with respect to $\\mathbf{q}$ and $\\lambda$ to zero.\n$$\n\\nabla_{\\mathbf{q}} \\mathcal{L} = -A^T(\\mathbf{V} - A\\mathbf{q}) + \\lambda \\mathbf{c} = \\mathbf{0} \\implies (A^T A)\\mathbf{q} + \\lambda \\mathbf{c} = A^T \\mathbf{V}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = \\mathbf{c}^T \\mathbf{q} - Q_{\\text{tot}} = 0 \\implies \\mathbf{c}^T \\mathbf{q} = Q_{\\text{tot}}\n$$\nThese two equations form a system of $N+1$ linear equations in $N+1$ unknowns ($\\mathbf{q}$ and $\\lambda$). This is known as a Karush-Kuhn-Tucker (KKT) system, which can be expressed in block matrix form:\n$$\n\\begin{pmatrix}\nA^T A  \\mathbf{c} \\\\\n\\mathbf{c}^T  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nA^T \\mathbf{V} \\\\\nQ_{\\text{tot}}\n\\end{pmatrix}\n$$\nSolving this system yields the constrained charge vector $\\hat{\\mathbf{q}}^{(\\text{con})}$ and the Lagrange multiplier $\\lambda$.\n\nFor each test case, the procedure is as follows:\n$1$. Construct the $M \\times N$ matrix $A$ from the atomic coordinates $\\mathbf{R}_i$ and grid point coordinates $\\mathbf{r}_j$.\n$2$. Generate the \"observed\" potential vector $\\mathbf{V}$ by computing the true potential $A\\mathbf{q}^{(\\text{true})}$ and adding Gaussian noise with the specified standard deviation $\\sigma$ and random seed.\n$3$. Solve for the unconstrained charges $\\hat{\\mathbf{q}}^{(\\text{uncon})}$ using a numerical least-squares solver.\n$4$. Solve the KKT system for the constrained charges $\\hat{\\mathbf{q}}^{(\\text{con})}$.\n$5$. Calculate the required quantities:\n   a. Total unconstrained charge: $Q_{\\text{uncon}} = \\sum_{i=1}^N \\hat{q}_i^{(\\text{uncon})}$.\n   b. Unconstrained dipole error: $\\lVert \\sum_i (\\hat{q}_i^{(\\text{uncon})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$. The summation represents the error dipole vector $\\boldsymbol{\\mu}_{\\text{err}}^{(\\text{uncon})}$, so we compute its Euclidean norm.\n   c. Constrained dipole error: $\\lVert \\sum_i (\\hat{q}_i^{(\\text{con})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$, the norm of the error dipole vector $\\boldsymbol{\\mu}_{\\text{err}}^{(\\text{con})}$.\nThis rigorous, principle-based approach ensures a correct and robust implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for ESP-fitted charges using unconstrained and constrained least-squares\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"N\": 3, \"Q_tot\": 1.0,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"q_true\": np.array([0.3, 0.5, 0.2]),\n            \"r_grid\": np.array([\n                [2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 1.0, 1.0],\n                [-1.0, -1.0, 0.5], [3.0, 1.0, 0.0], [1.0, 3.0, 0.0], [1.0, 1.0, -1.0]\n            ]),\n            \"sigma\": 1e-4, \"seed\": 123\n        },\n        {\n            \"name\": \"B\",\n            \"N\": 3, \"Q_tot\": 1.0,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.2, 0.0, 0.0], [2.4, 0.0, 0.0]]),\n            \"q_true\": np.array([0.7, 0.2, 0.1]),\n            \"r_grid\": np.array([[0.0, 2.0, 0.0], [1.2, 2.0, 0.0], [2.4, 2.0, 0.0]]),\n            \"sigma\": 1e-6, \"seed\": 321\n        },\n        {\n            \"name\": \"C\",\n            \"N\": 3, \"Q_tot\": -1.0,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"q_true\": np.array([-0.6, -0.2, -0.2]),\n            \"r_grid\": np.array([\n                [2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 1.0, 1.0],\n                [-1.0, -1.0, 1.0], [3.0, 0.0, 0.0], [10.0, 10.0, 10.0]\n            ]),\n            \"sigma\": 5e-4, \"seed\": 999\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        R_atoms = case[\"R\"]\n        q_true = case[\"q_true\"]\n        r_grid = case[\"r_grid\"]\n        Q_tot = case[\"Q_tot\"]\n        sigma = case[\"sigma\"]\n        seed = case[\"seed\"]\n        N = case[\"N\"]\n        M = r_grid.shape[0]\n\n        # 1. Construct the design matrix A\n        # A_ji = 1 / ||r_j - R_i||\n        # Using broadcasting for efficiency:\n        distances = np.linalg.norm(r_grid[:, np.newaxis, :] - R_atoms[np.newaxis, :, :], axis=2)\n        A = 1.0 / distances\n\n        # 2. Generate the observed potential vector V\n        V_true = A @ q_true\n        rng = np.random.default_rng(seed)\n        eta = rng.normal(loc=0.0, scale=sigma, size=M)\n        V_obs = V_true + eta\n\n        # 3. Unconstrained least-squares fit\n        q_uncon = np.linalg.lstsq(A, V_obs, rcond=None)[0]\n\n        # 4. Constrained least-squares fit using KKT system\n        # | A^T*A   c | |  q_con  | = | A^T*V |\n        # |  c^T    0 | | lambda  |   | Q_tot |\n        \n        ATA = A.T @ A\n        ATV = A.T @ V_obs\n        \n        # Build KKT matrix (N+1 x N+1)\n        KKT_matrix = np.zeros((N + 1, N + 1))\n        KKT_matrix[:N, :N] = ATA\n        c = np.ones(N)\n        KKT_matrix[:N, N] = c\n        KKT_matrix[N, :N] = c\n\n        # Build RHS vector (N+1)\n        rhs = np.zeros(N + 1)\n        rhs[:N] = ATV\n        rhs[N] = Q_tot\n\n        # Solve the KKT system\n        solution_kkt = np.linalg.solve(KKT_matrix, rhs)\n        q_con = solution_kkt[:N]\n\n        # 5. Compute required quantities\n        # a. Total charge from unconstrained fit\n        total_q_uncon = np.sum(q_uncon)\n\n        # b. Dipole error for unconstrained fit\n        dipole_err_uncon_vec = (q_uncon - q_true) @ R_atoms\n        dipole_err_uncon_norm = np.linalg.norm(dipole_err_uncon_vec)\n        \n        # c. Dipole error for constrained fit\n        dipole_err_con_vec = (q_con - q_true) @ R_atoms\n        dipole_err_con_norm = np.linalg.norm(dipole_err_con_vec)\n\n        all_results.append([\n            total_q_uncon,\n            dipole_err_uncon_norm,\n            dipole_err_con_norm\n        ])\n\n    # Final print statement in the exact required format\n    # produces [[...],[...],[...]] without spaces\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2889373"}, {"introduction": "This advanced exercise addresses a crucial numerical issue that arises in practical ESP charge calculations: the potential for numerical instability due to ill-conditioning of the least-squares equations. This instability often originates from spatial redundancy in the grid points used for the potential fitting. You will implement a robust, principled grid de-duplication algorithm based on kernel correlation to proactively identify and remove redundant points, thereby improving the condition number of the normal equations matrix and ensuring a stable, reliable charge determination [@problem_id:2889411]. This practice provides valuable experience in developing robust numerical methods for computational chemistry applications.", "problem": "You are given a standard Electrostatic Potential (ESP) charge fitting setup from quantum chemistry. The total externally computed electrostatic potential at a set of grid points is modeled as the Coulomb potential generated by fixed point charges located at given atomic positions. Let there be $M$ atoms at positions $\\{\\mathbf{R}_A\\}_{A=1}^{M}$ in three-dimensional space, with unknown charges $\\{q_A\\}_{A=1}^{M}$, and let there be $N$ grid points at positions $\\{\\mathbf{r}_i\\}_{i=1}^{N}$. The Coulomb kernel induced feature vector at a grid point is defined by the component-wise mapping $\\phi_A(\\mathbf{r}) = 1 / \\|\\mathbf{r} - \\mathbf{R}_A\\|$, where the norm is the Euclidean norm. Using this definition, the linear system matrix $\\mathbf{A} \\in \\mathbb{R}^{N \\times M}$ has entries $A_{iA} = \\phi_A(\\mathbf{r}_i)$. In standard least squares fitting of ESP-derived atomic charges, the normal equations involve the matrix $\\mathbf{A}^\\top \\mathbf{A}$. When rows of $\\mathbf{A}$ are nearly linearly dependent, $\\mathbf{A}^\\top \\mathbf{A}$ becomes ill-conditioned and the fitted charges become numerically unstable.\n\nYour task is to design and implement a principled grid de-duplication strategy that removes grid points that are redundant with respect to the Coulomb kernel. Two grid points $\\mathbf{r}_i$ and $\\mathbf{r}_j$ are considered redundant if the cosine correlation between their kernel feature vectors exceeds a specified threshold. For any two grid points $\\mathbf{r}_i$ and $\\mathbf{r}_j$, define the kernel correlation\n$$\nc(i,j) \\;=\\; \\frac{\\langle \\boldsymbol{\\phi}(\\mathbf{r}_i), \\boldsymbol{\\phi}(\\mathbf{r}_j) \\rangle}{\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2 \\, \\|\\boldsymbol{\\phi}(\\mathbf{r}_j)\\|_2} \\;=\\; \\frac{\\sum_{A=1}^{M} \\frac{1}{\\|\\mathbf{r}_i-\\mathbf{R}_A\\|} \\cdot \\frac{1}{\\|\\mathbf{r}_j-\\mathbf{R}_A\\|}}{\\left(\\sum_{A=1}^{M} \\frac{1}{\\|\\mathbf{r}_i-\\mathbf{R}_A\\|^2}\\right)^{1/2}\\left(\\sum_{A=1}^{M} \\frac{1}{\\|\\mathbf{r}_j-\\mathbf{R}_A\\|^2}\\right)^{1/2}} \\,,\n$$\nwhich lies in $[0,1]$ for strictly positive features. For a user-specified threshold $\\tau \\in [0,1]$, the de-duplication strategy must construct a subset $S \\subset \\{1,\\dots,N\\}$ of retained grid indices such that for all distinct $i,j \\in S$ one has $c(i,j) \\le \\tau$, while attempting to retain as many informative points as possible to avoid loss of resolution. You must justify mathematically why imposing an upper bound $\\tau$ on all pairwise correlations controls near-linear dependence among rows of $\\mathbf{A}$ and improves the conditioning of the least squares problem. Your algorithm should be deterministic, and in case of potential ties it should prefer retaining points with larger feature norm $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$.\n\nFundamental starting points that you may use include: the Coulomb law potential $V(\\mathbf{r}) = \\sum_{A=1}^{M} q_A / \\|\\mathbf{r} - \\mathbf{R}_A\\|$, the Euclidean inner product and norm, properties of the Gram matrix, Gershgorin’s circle theorem, and basic linear least squares conditioning facts. Do not assume any pre-given de-duplication formula; derive the logic from these bases.\n\nYour program must implement the following deterministic greedy selection strategy: sort grid points in descending order of $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$, then sequentially retain a point if and only if its correlation $c(i,j)$ with every previously retained point $j$ is $\\le \\tau$. If $\\tau \\ge 1$, retain all points. If $\\tau \\le 0$, retain at most one point (specifically, the first in the sorted order). Use a strict inequality $c(i,j)  \\tau$ as the criterion to discard a candidate $i$.\n\nPhysical units: all positions $\\mathbf{R}_A$ and $\\mathbf{r}_i$ are specified in ångström ($\\AA$). The algorithm’s output is unitless.\n\nTest suite: use the following atomic centers and grid sets.\n- Atom centers $\\{\\mathbf{R}_A\\}_{A=1}^{M}$ with $M = 3$: \n  - $\\mathbf{R}_1 = (0.0000,\\, 0.0000,\\, 0.0000)$,\n  - $\\mathbf{R}_2 = (0.9572,\\, 0.0000,\\, 0.0000)$,\n  - $\\mathbf{R}_3 = (-0.2390,\\, 0.9270,\\, 0.0000)$.\n- Define five test cases, each a triple $(\\text{grid}, \\tau, \\text{name})$:\n  - Case $1$ (clustered far-field, moderate threshold): grid points $\\mathbf{r}_i$ equal to $(3.00,\\,0.00,\\,0.00)$, $(3.05,\\,0.00,\\,0.00)$, $(3.10,\\,0.00,\\,0.00)$, $(0.00,\\,3.00,\\,0.00)$, $(-3.00,\\,0.00,\\,0.00)$ with $\\tau = 0.95$.\n  - Case $2$ (duplicate points, high threshold): grid points $\\mathbf{r}_i$ equal to $(2.50,\\,0.00,\\,0.00)$, $(2.50,\\,0.00,\\,0.00)$, $(0.00,\\,2.50,\\,0.00)$, $(0.00,\\,2.50,\\,0.00)$, $(0.00,\\,0.00,\\,2.50)$ with $\\tau = 0.99$.\n  - Case $3$ (near-nuclear cluster, stricter threshold): grid points $\\mathbf{r}_i$ equal to $(0.20,\\,0.00,\\,0.00)$, $(0.25,\\,0.00,\\,0.00)$, $(0.30,\\,0.00,\\,0.00)$, $(0.00,\\,0.20,\\,0.00)$, $(0.00,\\,0.00,\\,0.20)$ with $\\tau = 0.90$.\n  - Case $4$ (boundary keep-all): grid points $\\mathbf{r}_i$ equal to $(1.50,\\,0.50,\\,0.00)$, $(-1.50,\\,-0.50,\\,0.00)$, $(0.00,\\,0.00,\\,1.50)$ with $\\tau = 1.00$.\n  - Case $5$ (boundary keep-one): grid points $\\mathbf{r}_i$ equal to $(4.00,\\,0.00,\\,0.00)$, $(0.00,\\,4.00,\\,0.00)$, $(0.00,\\,0.00,\\,4.00)$ with $\\tau = 0.00$.\n\nFor each test case, your program must compute the number of retained grid points after applying the specified de-duplication strategy. Your final program output must be a single line containing the results for cases $1$ through $5$ as a comma-separated list enclosed in square brackets, for example $[n_1,n_2,n_3,n_4,n_5]$, where $n_k$ is the integer number of retained grid points for case $k$.", "solution": "The problem is first subjected to a rigorous validation.\n\n**Step 1: Extract Givens**\n\nThe givens are extracted verbatim from the problem statement:\n- Number of atoms: $M$.\n- Atomic positions: $\\{\\mathbf{R}_A\\}_{A=1}^{M}$.\n- Number of grid points: $N$.\n- Grid point positions: $\\{\\mathbf{r}_i\\}_{i=1}^{N}$.\n- Unknown atomic charges: $\\{q_A\\}_{A=1}^{M}$.\n- Coulomb kernel feature vector component: $\\phi_A(\\mathbf{r}) = 1 / \\|\\mathbf{r} - \\mathbf{R}_A\\|$, where $\\|\\cdot\\|$ is the Euclidean norm.\n- The feature vector for a grid point $\\mathbf{r}_i$ is $\\boldsymbol{\\phi}(\\mathbf{r}_i) \\in \\mathbb{R}^M$ with components $[\\phi_A(\\mathbf{r}_i)]_{A=1}^{M}$.\n- Linear system matrix: $\\mathbf{A} \\in \\mathbb{R}^{N \\times M}$ with entries $A_{iA} = \\phi_A(\\mathbf{r}_i)$. The $i$-th row of $\\mathbf{A}$ is $\\boldsymbol{\\phi}(\\mathbf{r}_i)^\\top$.\n- Kernel correlation: $$c(i,j) \\;=\\; \\frac{\\langle \\boldsymbol{\\phi}(\\mathbf{r}_i), \\boldsymbol{\\phi}(\\mathbf{r}_j) \\rangle}{\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2 \\, \\|\\boldsymbol{\\phi}(\\mathbf{r}_j)\\|_2}$$\n- De-duplication threshold: $\\tau \\in [0,1]$.\n- De-duplication rule: The subset of retained indices $S$ must satisfy $c(i,j) \\le \\tau$ for all distinct $i,j \\in S$.\n- Algorithmic specification: A deterministic greedy selection strategy is prescribed.\n  1. Sort grid point indices $i$ in descending order of the feature vector norm $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$.\n  2. Sequentially iterate through the sorted indices. A point $i$ is retained if and only if for every previously retained point $j$, the correlation $c(i,j) \\le \\tau$. The criterion for discarding is strictly $c(i,j)  \\tau$.\n- Atomic positions for test cases ($M=3$): $\\mathbf{R}_1=(0.0000, 0.0000, 0.0000)$, $\\mathbf{R}_2=(0.9572, 0.0000, 0.0000)$, $\\mathbf{R}_3=(-0.2390, 0.9270, 0.0000)$, in units of ångström.\n- Five test cases are provided, each specifying a set of grid points $\\{\\mathbf{r}_i\\}$ and a threshold $\\tau$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is set in the context of quantum chemistry, specifically Electrostatic Potential (ESP) derived atomic charge fitting. This is a standard and well-established computational chemistry method. The mathematical formulation, involving Coulomb's law, linear least squares, normal equations ($\\mathbf{A}^\\top \\mathbf{A}$), and matrix conditioning, is entirely sound and fundamental to numerical scientific computing. The use of cosine similarity (kernel correlation) to identify and remove redundant data vectors is a standard technique in data analysis and numerical linear algebra to combat ill-conditioning. The problem is scientifically grounded.\n- **Well-Posed**: The problem statement clearly defines the inputs (atomic coordinates, grid coordinates, threshold), the exact procedure to follow (a deterministic greedy algorithm), and the required output (the number of retained points). Given the deterministic nature of the algorithm, a unique solution exists for each test case. The problem is well-posed.\n- **Objective**: All definitions are mathematical and precise. The criteria for redundancy and selection are quantitative. The problem is expressed in objective language, free of ambiguity or subjective claims.\n\nThe problem does not exhibit any of the listed invalidity flaws. It is mathematically and scientifically coherent, complete, and formalizable.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be provided.\n\n**Mathematical Justification**\n\nThe task requires a justification for why bounding the pairwise correlation $c(i,j)$ improves the conditioning of the least-squares problem. The least-squares solution for the charges $\\mathbf{q}$ is found by solving the normal equations $(\\mathbf{A}^\\top \\mathbf{A}) \\mathbf{q} = \\mathbf{A}^\\top \\mathbf{v}$, where $\\mathbf{v}$ is the vector of electrostatic potentials at the grid points. The numerical stability of this solution is governed by the condition number of the matrix $\\mathbf{A}^\\top \\mathbf{A}$. A large condition number signifies an ill-conditioned problem, where small perturbations in the input can lead to large changes in the solution $\\mathbf{q}$.\n\nThe de-duplication strategy creates a subset of grid points, which corresponds to selecting a subset of rows from the matrix $\\mathbf{A}$ to form a new matrix, let us call it $\\mathbf{A}_S$. The rows of $\\mathbf{A}_S$ are the feature vectors $\\{\\boldsymbol{\\phi}(\\mathbf{r}_i)\\}_{i \\in S}$ for the set of retained grid points $S$. The new normal equations involve the matrix $\\mathbf{A}_S^\\top \\mathbf{A}_S$. We analyze its conditioning.\n\nThe non-zero eigenvalues of $\\mathbf{A}_S^\\top \\mathbf{A}_S$ are identical to the non-zero eigenvalues of the Gram matrix $\\mathbf{G} = \\mathbf{A}_S \\mathbf{A}_S^\\top$. The entries of this Gram matrix are the inner products of the selected feature vectors: $G_{ij} = \\langle \\boldsymbol{\\phi}(\\mathbf{r}_i), \\boldsymbol{\\phi}(\\mathbf{r}_j) \\rangle$ for $i,j \\in S$. The condition number of $\\mathbf{A}_S^\\top \\mathbf{A}_S$ is related to the ratio of the largest to the smallest eigenvalue of $\\mathbf{G}$.\n\nThe prescribed algorithm controls the off-diagonal elements of the *normalized* Gram matrix, $\\mathbf{G}'$, whose entries are $G'_{ij} = c(i,j)$. By construction, for all distinct $i,j \\in S$, we have $|G'_{ij}| = |c(i,j)| \\le \\tau$. The diagonal elements are $G'_{ii} = c(i,i) = 1$.\n\nWe can apply Gershgorin's circle theorem to the matrix $\\mathbf{G}'$. The theorem states that every eigenvalue of $\\mathbf{G}'$ lies within at least one of the Gershgorin disks $D(G'_{ii}, R_i)$ in the complex plane, where the center is $G'_{ii}$ and the radius is $R_i = \\sum_{j \\neq i} |G'_{ij}|$.\nFor our matrix $\\mathbf{G}'$ of size $k \\times k$ (where $k = |S|$ is the number of retained points), we have:\n- Center of the disk: $G'_{ii} = 1$.\n- Radius of the disk: $R_i = \\sum_{j \\in S, j \\neq i} |c(i,j)| \\le \\sum_{j \\in S, j \\neq i} \\tau = (k-1)\\tau$.\n\nSince $\\mathbf{G}'$ is a real symmetric matrix, its eigenvalues $\\lambda$ are real. Thus, all eigenvalues must lie in the union of the real intervals $[1 - R_i, 1 + R_i]$. This implies:\n$$ \\lambda_{\\min}(\\mathbf{G}') \\ge 1 - \\max_i R_i \\ge 1 - (k-1)\\tau $$\n$$ \\lambda_{\\max}(\\mathbf{G}') \\le 1 + \\max_i R_i \\le 1 + (k-1)\\tau $$\nThe condition number of $\\mathbf{G}'$ is $\\kappa(\\mathbf{G}') = \\lambda_{\\max}(\\mathbf{G}') / \\lambda_{\\min}(\\mathbf{G}')$. We can bound it as:\n$$ \\kappa(\\mathbf{G}') \\le \\frac{1 + (k-1)\\tau}{1 - (k-1)\\tau} $$\nThis bound is meaningful if $1 - (k-1)\\tau  0$, i.e., $\\tau  1/(k-1)$. By enforcing a small threshold $\\tau$, we ensure that the rows of $\\mathbf{A}_S$ are far from being linearly dependent. This keeps the eigenvalues of the normalized Gram matrix $\\mathbf{G}'$ away from zero, which bounds its condition number. Bounding the condition number of $\\mathbf{G}'$ is a standard method for ensuring the underlying matrix $\\mathbf{G}$ is well-conditioned. Since $\\mathbf{A}_S^\\top \\mathbf{A}_S$ shares its non-zero eigenvalues with $\\mathbf{G}$, this procedure directly improves the conditioning of the normal equations matrix, leading to a numerically stable and reliable computation of the ESP charges.\n\n**Algorithmic Design**\n\nThe implementation follows the prescribed deterministic greedy selection strategy.\n\n1.  **Preprocessing**: For a given test case (atomic coordinates $\\{\\mathbf{R}_A\\}$, grid points $\\{\\mathbf{r}_i\\}$), we first compute the necessary data for each grid point $i \\in \\{1,\\dots,N\\}$.\n    -   The feature vector $\\boldsymbol{\\phi}(\\mathbf{r}_i) \\in \\mathbb{R}^M$, where the $A$-th component is $1/\\|\\mathbf{r}_i - \\mathbf{R}_A\\|_2$.\n    -   The L2-norm of the feature vector, $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$.\n    This is best done by creating an $N \\times M$ matrix of feature vectors and an $N$-dimensional array of their norms.\n\n2.  **Sorting**: The original indices of the grid points, $\\{0, 1, \\dots, N-1\\}$, are sorted in descending order based on the pre-calculated norms $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$. This establishes the prioritized order in which points are considered for retention.\n\n3.  **Greedy Selection Loop**:\n    -   An empty list, `retained_indices`, is initialized to store the indices of the grid points that are kept.\n    -   The algorithm iterates through the sorted indices. For each candidate index `current_idx`:\n        a. A flag `is_redundant` is set to `False`.\n        b. The algorithm then iterates through the indices already present in `retained_indices`. Let one such index be `retained_idx`.\n        c. The kernel correlation $c(\\text{current\\_idx}, \\text{retained\\_idx})$ is computed using the pre-calculated feature vectors and norms.\n        $$ c(\\text{current\\_idx}, \\text{retained\\_idx}) = \\frac{\\boldsymbol{\\phi}(\\mathbf{r}_{\\text{current\\_idx}}) \\cdot \\boldsymbol{\\phi}(\\mathbf{r}_{\\text{retained\\_idx}})}{\\|\\boldsymbol{\\phi}(\\mathbf{r}_{\\text{current\\_idx}})\\|_2 \\|\\boldsymbol{\\phi}(\\mathbf{r}_{\\text{retained\\_idx}})\\|_2} $$\n        d. If this correlation is greater than the threshold $\\tau$, i.e., $c(\\text{current\\_idx}, \\text{retained\\_idx})  \\tau$, the candidate point is deemed redundant with respect to an already-retained point. The `is_redundant` flag is set to `True`, and the inner loop (over `retained_indices`) is terminated.\n        e. After checking against all `retained_indices`, if the `is_redundant` flag remains `False`, the `current_idx` is added to the `retained_indices` list.\n    -   This process is repeated for all candidate indices.\n\n4.  **Result**: The final result for the test case is the size of the `retained_indices` list. This procedure is applied for each of the five test cases, and the results are collected.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid de-duplication problem for the given test cases.\n    \"\"\"\n    \n    # Define atomic centers as specified in the problem.\n    atom_centers = np.array([\n        [0.0000, 0.0000, 0.0000],\n        [0.9572, 0.0000, 0.0000],\n        [-0.2390, 0.9270, 0.0000]\n    ])\n\n    # Define the five test cases. Each is a tuple of (grid_points, threshold).\n    test_cases = [\n        (np.array([\n            [3.00, 0.00, 0.00], [3.05, 0.00, 0.00], [3.10, 0.00, 0.00],\n            [0.00, 3.00, 0.00], [-3.00, 0.00, 0.00]\n        ]), 0.95),  # Case 1\n        (np.array([\n            [2.50, 0.00, 0.00], [2.50, 0.00, 0.00],\n            [0.00, 2.50, 0.00], [0.00, 2.50, 0.00],\n            [0.00, 0.00, 2.50]\n        ]), 0.99),  # Case 2\n        (np.array([\n            [0.20, 0.00, 0.00], [0.25, 0.00, 0.00], [0.30, 0.00, 0.00],\n            [0.00, 0.20, 0.00], [0.00, 0.00, 0.20]\n        ]), 0.90),  # Case 3\n        (np.array([\n            [1.50, 0.50, 0.00], [-1.50, -0.50, 0.00], [0.00, 0.00, 1.50]\n        ]), 1.00),  # Case 4\n        (np.array([\n            [4.00, 0.00, 0.00], [0.00, 4.00, 0.00], [0.00, 0.00, 4.00]\n        ]), 0.00)   # Case 5\n    ]\n\n    results = []\n    \n    for grid_points, threshold in test_cases:\n        num_grid_points = grid_points.shape[0]\n        num_atoms = atom_centers.shape[0]\n\n        # Step 1: Preprocessing - Calculate feature vectors and their norms.\n        feature_vectors = np.zeros((num_grid_points, num_atoms))\n        for i in range(num_grid_points):\n            for a in range(num_atoms):\n                dist = np.linalg.norm(grid_points[i] - atom_centers[a])\n                # Handle the case where a grid point is exactly on an atom, though not in test data.\n                if dist > 1e-9:\n                    feature_vectors[i, a] = 1.0 / dist\n                else: # To avoid division by zero, assign a large but finite value.\n                    feature_vectors[i, a] = 1e9\n\n        feature_norms = np.linalg.norm(feature_vectors, axis=1)\n\n        # Step 2: Sorting - Sort indices by descending norm.\n        # Use negative norms for ascending sort to get descending order.\n        # np.argsort is stable, which handles ties correctly based on original order.\n        sorted_indices = np.argsort(-feature_norms, kind='stable')\n\n        # Step 3: Greedy Selection\n        retained_indices = []\n        for i in sorted_indices:\n            is_redundant = False\n            # Check correlation with already retained points.\n            for j in retained_indices:\n                # Handle perfect duplicates to avoid division by zero if norms are zero (not an issue here)\n                if feature_norms[i] == 0 or feature_norms[j] == 0:\n                    correlation = 1.0 if i == j else 0.0\n                else:\n                    dot_product = np.dot(feature_vectors[i], feature_vectors[j])\n                    correlation = dot_product / (feature_norms[i] * feature_norms[j])\n\n                if correlation > threshold:\n                    is_redundant = True\n                    break\n            \n            if not is_redundant:\n                retained_indices.append(i)\n\n        results.append(len(retained_indices))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2889411"}]}