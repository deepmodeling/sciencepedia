{"hands_on_practices": [{"introduction": "The foundation of the Quantum Theory of Atoms in Molecules (QTAIM) rests upon the topological analysis of the electron density, $\\rho(\\mathbf{r})$. This first exercise is designed to solidify the fundamental mathematical definition of a bond critical point (BCP) as a rank-3 critical point with signature $(-1)$. By working through an idealized analytical model for a diatomic molecule, you will directly apply the criteria of a vanishing gradient ($\\nabla\\rho=\\mathbf{0}$) and a Hessian matrix with two negative and one positive eigenvalue, confirming the presence and nature of a BCP without the complexities of numerical software [@problem_id:2876140].", "problem": "Consider a homonuclear diatomic molecule aligned along the $z$-axis and modeled by a cylindrically symmetric, analytic electron density given by\n$$\n\\rho(x,y,z) \\;=\\; A\\left[\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z-\\frac{R}{2}\\right)^{2}\\right)\\right) \\;+\\; \\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z+\\frac{R}{2}\\right)^{2}\\right)\\right)\\right],\n$$\nwhere $A0$, $\\alpha0$, and $R0$. Work in atomic units, where lengths are in Bohr $a_{0}$, electron density is in $a_{0}^{-3}$, and Hessian elements of the density have units $a_{0}^{-5}$. Use the following parameter values: $A=1.0\\,a_{0}^{-3}$, $\\alpha=1.0\\,a_{0}^{-2}$, and $R=2.0\\,a_{0}$. In the Quantum Theory of Atoms in Molecules (QTAIM), a bond critical point (BCP) is a point where the gradient of the electron density $\\nabla \\rho(\\mathbf{r})$ vanishes and the Hessian of the density, $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$, has eigenvalues with two negative curvatures transverse to the bond and one positive curvature along the bond.\n\nStarting from the fundamental definitions of a critical point and the Hessian of a scalar field:\n- A critical point satisfies $\\nabla \\rho(\\mathbf{r})=\\mathbf{0}$.\n- The Hessian is the $3\\times 3$ matrix with entries $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$.\n- The eigenvalues of $H$ determine the local curvature of $\\rho$.\n\nDo the following:\n1. By symmetry and direct evaluation of first derivatives, locate the bond critical point along the internuclear axis for the given $\\rho(x,y,z)$.\n2. Compute the Hessian matrix $H_{ij}$ at that point.\n3. Determine its three eigenvalues and use their signs to identify the point’s topological type in the QTAIM sense.\n\nReport the ordered eigenvalues $\\lambda_{1}\\le \\lambda_{2}\\le \\lambda_{3}$ as a single row vector in atomic units. No rounding is required; provide exact symbolic expressions.", "solution": "We begin from the definitions. A critical point of the scalar field $\\rho(\\mathbf{r})$ is a point where the gradient $\\nabla \\rho(\\mathbf{r})=\\mathbf{0}$. The Hessian $H$ is the matrix of second derivatives with entries $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$. The eigenvalues of $H$ characterize curvature along principal directions.\n\nStep 1: Locate the bond critical point. The electron density is\n$$\n\\rho(x,y,z)=A\\left[\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z-\\frac{R}{2}\\right)^{2}\\right)\\right)+\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z+\\frac{R}{2}\\right)^{2}\\right)\\right)\\right],\n$$\nwhich is invariant under $(x,y)\\mapsto(-x,-y)$ and under $z\\mapsto -z$ because the two terms are centered symmetrically at $z=\\pm R/2$. By cylindrical symmetry, the point $(x,y,z)=(0,0,0)$ is a candidate for a critical point. We verify by computing first derivatives.\n\nLet $z_{0}=R/2$. Define\n$$\n\\rho_{+}(x,y,z)=A\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z-z_{0})^{2}\\right)\\right),\\quad\n\\rho_{-}(x,y,z)=A\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z+z_{0})^{2}\\right)\\right),\n$$\nso $\\rho=\\rho_{+}+\\rho_{-}$. The first derivatives are\n$$\n\\frac{\\partial \\rho_{\\pm}}{\\partial x}=-2\\alpha x\\,\\rho_{\\pm},\\quad\n\\frac{\\partial \\rho_{\\pm}}{\\partial y}=-2\\alpha y\\,\\rho_{\\pm},\\quad\n\\frac{\\partial \\rho_{+}}{\\partial z}=-2\\alpha (z-z_{0})\\,\\rho_{+},\\quad\n\\frac{\\partial \\rho_{-}}{\\partial z}=-2\\alpha (z+z_{0})\\,\\rho_{-}.\n$$\nAt $(0,0,0)$, we have $x=0$, $y=0$, and\n$$\n\\left.\\frac{\\partial \\rho}{\\partial x}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial \\rho}{\\partial y}\\right|_{\\mathbf{0}}=0,\n$$\nand\n$$\n\\left.\\frac{\\partial \\rho}{\\partial z}\\right|_{\\mathbf{0}}=-2\\alpha\\left[-z_{0}\\,\\rho_{+}(0,0,0)+z_{0}\\,\\rho_{-}(0,0,0)\\right]=0,\n$$\nbecause $\\rho_{+}(0,0,0)=\\rho_{-}(0,0,0)=A\\exp(-\\alpha z_{0}^{2})$. Thus $\\nabla \\rho(0,0,0)=\\mathbf{0}$, so $(0,0,0)$ is a critical point. In a symmetric diatomic, this is the bond critical point along the bond axis.\n\nStep 2: Compute the Hessian at the BCP. We compute second derivatives of $\\rho_{\\pm}$. For $x$ and $y$ directions,\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x^{2}}=\\frac{\\partial}{\\partial x}\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=-2\\alpha\\,\\rho_{\\pm}+(-2\\alpha x)\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=\\left(-2\\alpha+4\\alpha^{2}x^{2}\\right)\\rho_{\\pm},\n$$\nand similarly\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial y^{2}}=\\left(-2\\alpha+4\\alpha^{2}y^{2}\\right)\\rho_{\\pm}.\n$$\nFor the $z$ direction,\n$$\n\\frac{\\partial^{2}\\rho_{+}}{\\partial z^{2}}\n=\\frac{\\partial}{\\partial z}\\left(-2\\alpha(z-z_{0})\\,\\rho_{+}\\right)\n=-2\\alpha\\,\\rho_{+}+(-2\\alpha)(z-z_{0})\\left(-2\\alpha(z-z_{0})\\,\\rho_{+}\\right)\n=\\left(-2\\alpha+4\\alpha^{2}(z-z_{0})^{2}\\right)\\rho_{+},\n$$\nand\n$$\n\\frac{\\partial^{2}\\rho_{-}}{\\partial z^{2}}\n=\\left(-2\\alpha+4\\alpha^{2}(z+z_{0})^{2}\\right)\\rho_{-}.\n$$\nThe mixed second derivatives are\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x\\,\\partial y}\n=\\frac{\\partial}{\\partial x}\\left(-2\\alpha y\\,\\rho_{\\pm}\\right)\n=(-2\\alpha y)\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=4\\alpha^{2}xy\\,\\rho_{\\pm},\n$$\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x\\,\\partial z}\n=\\frac{\\partial}{\\partial x}\\left(-2\\alpha(z\\mp z_{0})\\,\\rho_{\\pm}\\right)\n=(-2\\alpha)(z\\mp z_{0})\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=4\\alpha^{2}x(z\\mp z_{0})\\,\\rho_{\\pm},\n$$\nand similarly for $\\partial^{2}\\rho_{\\pm}/\\partial y\\,\\partial z$.\n\nEvaluating at $(0,0,0)$, we have $x=0$, $y=0$, and $\\rho_{+}(0,0,0)=\\rho_{-}(0,0,0)=A\\exp(-\\alpha z_{0}^{2})$. Therefore,\n$$\n\\rho(0,0,0)=\\rho_{+}(0,0,0)+\\rho_{-}(0,0,0)=2A\\exp(-\\alpha z_{0}^{2}).\n$$\nThe diagonal second derivatives are\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x^{2}}\\right|_{\\mathbf{0}}\n=\\sum_{\\pm}\\left(-2\\alpha+4\\alpha^{2}x^{2}\\right)\\rho_{\\pm}\\bigg|_{\\mathbf{0}}\n=\\sum_{\\pm}(-2\\alpha)\\rho_{\\pm}(0,0,0)\n=-2\\alpha\\,\\rho(0,0,0),\n$$\nand identically,\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial y^{2}}\\right|_{\\mathbf{0}}\n=-2\\alpha\\,\\rho(0,0,0).\n$$\nFor $z$,\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial z^{2}}\\right|_{\\mathbf{0}}\n=\\left[\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho_{+}(0,0,0)\\right]+\\left[\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho_{-}(0,0,0)\\right]\n=\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0).\n$$\nAll mixed derivatives vanish at $(0,0,0)$ because each contains a factor of $x$, $y$, or $z$, which is zero there:\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x\\,\\partial y}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x\\,\\partial z}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial^{2}\\rho}{\\partial y\\,\\partial z}\\right|_{\\mathbf{0}}=0.\n$$\nHence, the Hessian at the BCP is diagonal in the $(x,y,z)$ basis:\n$$\nH(0,0,0)=\\begin{pmatrix}\n-2\\alpha\\,\\rho(0,0,0)  0  0\\\\\n0  -2\\alpha\\,\\rho(0,0,0)  0\\\\\n0  0  \\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0)\n\\end{pmatrix}.\n$$\n\nStep 3: Eigenvalues and their signs for the specified parameters. Using $A=1.0$, $\\alpha=1.0$, and $R=2.0$, we have $z_{0}=R/2=1.0$ and\n$$\n\\rho(0,0,0)=2A\\exp(-\\alpha z_{0}^{2})=2\\exp(-1).\n$$\nTherefore,\n$$\n\\lambda_{x}=\\left.\\frac{\\partial^{2}\\rho}{\\partial x^{2}}\\right|_{\\mathbf{0}}=-2\\alpha\\,\\rho(0,0,0)=-2\\cdot 1\\cdot 2\\exp(-1)=-4\\exp(-1),\n$$\n$$\n\\lambda_{y}=\\left.\\frac{\\partial^{2}\\rho}{\\partial y^{2}}\\right|_{\\mathbf{0}}=-4\\exp(-1),\n$$\n$$\n\\lambda_{z}=\\left.\\frac{\\partial^{2}\\rho}{\\partial z^{2}}\\right|_{\\mathbf{0}}=\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0)=\\left(-2+4\\cdot 1\\cdot 1\\right)\\cdot 2\\exp(-1)=4\\exp(-1).\n$$\nThe ordered eigenvalues are $\\lambda_{1}=\\lambda_{x}=-4\\exp(-1)$, $\\lambda_{2}=\\lambda_{y}=-4\\exp(-1)$, and $\\lambda_{3}=\\lambda_{z}=4\\exp(-1)$. Two are negative (transverse curvatures) and one is positive (along the bond), identifying a $(3,-1)$ bond critical point in the Quantum Theory of Atoms in Molecules sense. All values are in atomic units, with Hessian elements in $a_{0}^{-5}$.", "answer": "$$\\boxed{\\begin{pmatrix}-4\\exp(-1)  -4\\exp(-1)  4\\exp(-1)\\end{pmatrix}}$$", "id": "2876140"}, {"introduction": "Having established the analytical definition of a BCP, we now move to a more practical computational scenario involving a realistic molecular geometry. This exercise requires you to implement a QTAIM analysis for a model of the water molecule, connecting the topological features of the electron density to local energetic properties derived from the local virial theorem. This practice demonstrates how QTAIM provides a powerful bridge from the abstract topology of $\\rho(\\mathbf{r})$ to chemically meaningful quantities, such as model interatomic interaction energies [@problem_id:2876091].", "problem": "You are to write a complete, runnable program that, for a model of the water molecule (oxygen and two hydrogens) in atomic units, locates the bond critical points (BCPs) on the oxygen–hydrogen lines, evaluates topological and local energetic indicators at each BCP, and computes a model Interacting Quantum Atoms (IQA) interatomic energy estimator for the oxygen–hydrogen pairs. Your derivation and implementation must begin only from fundamental definitions in the Quantum Theory of Atoms in Molecules (QTAIM) and well-tested approximate formulas; do not assume any specialized pre-derived correlations beyond these bases.\n\nUse the following scientifically standard bases for Quantum Theory of Atoms in Molecules (QTAIM) and local energetic indicators:\n- The electron density field is denoted by $\\rho(\\mathbf{r})$.\n- A critical point $\\mathbf{r}_c$ is a point where $\\nabla \\rho(\\mathbf{r}_c) = \\mathbf{0}$. A bond critical point (BCP) is a rank-$3$, signature $(-1)$ critical point, i.e., the Hessian of $\\rho$ at $\\mathbf{r}_b$ has eigenvalues $\\lambda_1  \\lambda_2  0  \\lambda_3$.\n- The total energy density is $H(\\mathbf{r}) = G(\\mathbf{r}) + V(\\mathbf{r})$, where $G(\\mathbf{r})$ is the positive-definite kinetic energy density and $V(\\mathbf{r})$ is the potential energy density.\n- The local form of the virial theorem (valid for bound stationary states) relates $G(\\mathbf{r})$, $V(\\mathbf{r})$, and the Laplacian of the density, $\\nabla^2 \\rho(\\mathbf{r})$, via $2 G(\\mathbf{r}) + V(\\mathbf{r}) = \\dfrac{1}{4}\\nabla^2 \\rho(\\mathbf{r})$.\n- To close the problem numerically without a many-electron wavefunction, approximate $H(\\mathbf{r})$ by a widely used local functional of the density combining the Thomas–Fermi kinetic energy density and the local (Dirac) exchange energy density:\n$$H(\\mathbf{r}) \\approx \\tau_{\\mathrm{TF}}(\\rho(\\mathbf{r})) + \\epsilon_x(\\rho(\\mathbf{r})),$$\nwith $\\tau_{\\mathrm{TF}}(\\rho) = c_F \\,\\rho^{5/3}$ and $\\epsilon_x(\\rho) = -c_x \\,\\rho^{4/3}$, where $c_F = \\dfrac{3}{10} (3\\pi^2)^{2/3}$ and $c_x = \\dfrac{3}{4}\\left(\\dfrac{3}{\\pi}\\right)^{1/3}$. All quantities are in atomic units (Hartree for energy, Bohr for length).\n- Use the local virial theorem and the definition of $H(\\mathbf{r})$ to algebraically eliminate $G(\\mathbf{r})$ and express $V(\\mathbf{r})$ in terms of $H(\\mathbf{r})$ and $\\nabla^2 \\rho(\\mathbf{r})$.\n\nFor the electron density, use a promolecular Slater-type superposition model that preserves total electron counts at the nuclei. Let the atomic contribution centered at nucleus $A$ located at $\\mathbf{R}_A$ be\n$$\\rho_A(\\mathbf{r}) = N_A \\left(\\dfrac{\\zeta_A^3}{\\pi}\\right) \\exp\\!\\left(-2 \\zeta_A \\,|\\mathbf{r}-\\mathbf{R}_A|\\right),$$\nso that the total density is $\\rho(\\mathbf{r}) = \\sum_A \\rho_A(\\mathbf{r})$, where $N_A$ is the electron count associated with nucleus $A$ and $\\zeta_A$ is a Slater exponent controlling radial decay.\n\nGeometry and parameters. Place the oxygen nucleus at the origin $\\mathbf{R}_{\\mathrm{O}} = (0,0,0)$, one hydrogen on the $x$-axis at $\\mathbf{R}_{\\mathrm{H}_1} = (R_{\\mathrm{OH}}, 0, 0)$, and the second hydrogen in the $xy$-plane at $\\mathbf{R}_{\\mathrm{H}_2} = (R_{\\mathrm{OH}}\\cos\\theta, R_{\\mathrm{OH}}\\sin\\theta, 0)$, so that the $\\angle \\mathrm{H}\\!-\\!\\mathrm{O}\\!-\\!\\mathrm{H}$ angle is $\\theta$. Use $N_{\\mathrm{O}} = 8$, $N_{\\mathrm{H}} = 1$ for each hydrogen. Treat all lengths in Bohr and $\\theta$ in degrees. Your code must compute, for each $\\mathrm{O}\\!-\\!\\mathrm{H}$ pair separately:\n- The BCP position $\\mathbf{r}_b$ restricted to the internuclear line segment joining the oxygen and that hydrogen, by solving for the internal coordinate $s \\in (0, R_{\\mathrm{OH}})$ where the directional derivative of $\\rho(\\mathbf{r})$ along the O–H axis vanishes. Then verify the bond critical point signature at $\\mathbf{r}_b$ by computing the full Hessian of $\\rho$ and checking that it has two negative and one positive eigenvalues.\n- The topological indicators $\\rho_b = \\rho(\\mathbf{r}_b)$ and $H_b = H(\\mathbf{r}_b)$.\n- The Laplacian $\\nabla^2 \\rho(\\mathbf{r}_b)$ as the trace of the Hessian.\n- The potential energy density $V(\\mathbf{r}_b)$ by eliminating $G(\\mathbf{r}_b)$ in favor of $H(\\mathbf{r}_b)$ and $\\nabla^2 \\rho(\\mathbf{r}_b)$ using the two relations given above.\n- A model interatomic energy estimator for the $\\mathrm{O}\\!-\\!\\mathrm{H}$ pair defined as $E_{\\mathrm{IQA}}^{\\mathrm{(est)}} = \\kappa \\, V(\\mathbf{r}_b)$ with $\\kappa = \\dfrac{1}{2}$ (atomic units). Report this quantity in Hartree.\n\nNumerical implementation requirements:\n- Treat all computations in atomic units. Report energies in Hartree and densities in electrons per $\\mathrm{Bohr}^3$.\n- Use a robust one-dimensional root-finding method to locate the BCP along each O–H line by solving $d\\rho/ds = 0$ for $s \\in (0,R_{\\mathrm{OH}})$, where $s$ is the distance from the oxygen along the O–H direction. Compute the directional derivative by contracting the gradient $\\nabla \\rho$ with the O–H unit vector.\n- Compute the gradient and Hessian of the promolecular density analytically. For a spherically symmetric contribution $f(r_A)$ centered at $\\mathbf{R}_A$ with $r_A = |\\mathbf{r}-\\mathbf{R}_A|$, use the standard tensor form\n$$\\nabla f = f'(r_A) \\,\\hat{\\mathbf{e}}_{r_A}, \\qquad \\nabla\\nabla f = f''(r_A) \\,\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top + \\dfrac{f'(r_A)}{r_A}\\left(\\mathbf{I}-\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top\\right),$$\nwith $f(r_A) = N_A (\\zeta_A^3/\\pi)\\exp(-2\\zeta_A r_A)$, $f'(r_A) = -2\\zeta_A f(r_A)$, and $f''(r_A) = 4\\zeta_A^2 f(r_A)$.\n\nTest suite. Your program must evaluate the following four parameter sets, each defining a distinct water model, and aggregate the results:\n- Case $1$: $R_{\\mathrm{OH}} = 1.81$ (Bohr), $\\theta = 104.5$ (degrees), $\\zeta_{\\mathrm{O}} = 2.2$, $\\zeta_{\\mathrm{H}} = 1.24$.\n- Case $2$: $R_{\\mathrm{OH}} = 2.00$ (Bohr), $\\theta = 104.5$ (degrees), $\\zeta_{\\mathrm{O}} = 2.2$, $\\zeta_{\\mathrm{H}} = 1.24$.\n- Case $3$: $R_{\\mathrm{OH}} = 1.60$ (Bohr), $\\theta = 104.5$ (degrees), $\\zeta_{\\mathrm{O}} = 2.2$, $\\zeta_{\\mathrm{H}} = 1.24$.\n- Case $4$: $R_{\\mathrm{OH}} = 1.81$ (Bohr), $\\theta = 104.5$ (degrees), $\\zeta_{\\mathrm{O}} = 2.0$, $\\zeta_{\\mathrm{H}} = 1.24$.\n\nFor each case, compute the ordered six-tuple of floats\n$$\\left[E_{\\mathrm{IQA}}^{\\mathrm{(est)}}(\\mathrm{O}\\!-\\!\\mathrm{H}_1),\\,E_{\\mathrm{IQA}}^{\\mathrm{(est)}}(\\mathrm{O}\\!-\\!\\mathrm{H}_2),\\,\\rho_b(\\mathrm{O}\\!-\\!\\mathrm{H}_1),\\,\\rho_b(\\mathrm{O}\\!-\\!\\mathrm{H}_2),\\,H_b(\\mathrm{O}\\!-\\!\\mathrm{H}_1),\\,H_b(\\mathrm{O}\\!-\\!\\mathrm{H}_2)\\right],$$\nin the stated order and in the atomic units described above.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated Python-style list of lists, one inner list per case, preserving the case order as given above. For example, your output must look like\n$[\\,[x_{11},x_{12},x_{13},x_{14},x_{15},x_{16}],[x_{21},\\dots],[x_{31},\\dots],[x_{41},\\dots]\\,]$,\nwith each $x_{ij}$ a floating-point number. Angles must be treated in degrees as stated. No additional text may be printed.", "solution": "The problem requires the implementation of a computational model based on the Quantum Theory of Atoms in Molecules (QTAIM) to analyze the bonding characteristics of a simplified water molecule. The analysis involves locating the bond critical points (BCPs) for the oxygen-hydrogen bonds, computing several topological and energetic indicators at these points, and finally evaluating a model interatomic energy. The entire calculation is performed in atomic units.\n\nThe foundation of the model is the promolecular electron density, $\\rho(\\mathbf{r})$, which is a superposition of spherically symmetric atomic densities:\n$$\n\\rho(\\mathbf{r}) = \\sum_{A} \\rho_A(\\mathbf{r})\n$$\nwhere the sum is over the three nuclei: oxygen ($O$), hydrogen $1$ ($H_1$), and hydrogen $2$ ($H_2$). Each atomic contribution, centered at nucleus $A$ at position $\\mathbf{R}_A$, is given by a Slater-type function:\n$$\n\\rho_A(\\mathbf{r}) = N_A \\left(\\dfrac{\\zeta_A^3}{\\pi}\\right) \\exp\\!\\left(-2 \\zeta_A \\,|\\mathbf{r}-\\mathbf{R}_A|\\right)\n$$\nHere, $N_A$ is the number of electrons for atom $A$ ($N_O=8$, $N_H=1$), and $\\zeta_A$ is the corresponding Slater exponent. We denote the pre-exponential factor as $C_A = N_A (\\zeta_A^3/\\pi)$. The geometry is defined with the oxygen atom at the origin $\\mathbf{R}_O=(0,0,0)$, the first hydrogen at $\\mathbf{R}_{H_1}=(R_{OH}, 0, 0)$, and the second hydrogen at $\\mathbf{R}_{H_2}=(R_{OH}\\cos\\theta, R_{OH}\\sin\\theta, 0)$.\n\nFirst, we locate the bond critical point (BCP) along each O-H internuclear axis. A BCP is a point $\\mathbf{r}_b$ where the gradient of the electron density vanishes, $\\nabla\\rho(\\mathbf{r}_b) = \\mathbf{0}$, and the Hessian matrix of the density, $\\nabla\\nabla\\rho(\\mathbf{r}_b)$, has a signature of $(-1)$, corresponding to two negative eigenvalues ($\\lambda_1, \\lambda_2$) and one positive eigenvalue ($\\lambda_3$).\n\nDue to the symmetry of the water molecule model, the scalar properties calculated at the BCP of the O-H$_1$ bond will be identical to those for the O-H$_2$ bond. We can therefore focus our derivation on the O-H$_1$ bond, which lies on the $x$-axis. The BCP for this bond, $\\mathbf{r}_{b,1}$, must also lie on this axis, so its coordinates are $(s,0,0)$ for some distance $s \\in (0, R_{OH})$. The condition $\\nabla\\rho(\\mathbf{r}_{b,1})=\\mathbf{0}$ simplifies to finding the point where the $x$-component of the gradient is zero, as the other components are zero by symmetry on the $x$-axis. The gradient of the total density is the sum of the atomic contributions, $\\nabla\\rho = \\sum_A \\nabla\\rho_A$. The gradient of a single atomic density $\\rho_A(r_A)$ where $r_A=|\\mathbf{r}-\\mathbf{R}_A|$ is given by $\\nabla\\rho_A = \\frac{d\\rho_A}{dr_A} \\nabla r_A = \\rho_A'(r_A) \\hat{\\mathbf{e}}_{r_A}$, where $\\hat{\\mathbf{e}}_{r_A} = (\\mathbf{r}-\\mathbf{R}_A)/r_A$. With $\\rho_A'(r_A) = -2\\zeta_A \\rho_A(r_A)$, the $x$-component of the gradient at $\\mathbf{r}=(s,0,0)$ is:\n$$\n(\\nabla\\rho)_x(s,0,0) = \\sum_{A} \\left(-2\\zeta_A \\rho_A(r_A(s))\\right) \\frac{s - x_A}{r_A(s)} = 0\n$$\nwhere $\\mathbf{R}_A = (x_A, y_A, z_A)$ and $r_A(s) = |\\mathbf{r} - \\mathbf{R}_A|$. This nonlinear equation in $s$ is solved numerically using a robust root-finding algorithm over the interval $(0, R_{OH})$ to find the BCP distance, $s_b$. The BCP location is then $\\mathbf{r}_b = (s_b, 0, 0)$.\n\nOnce $\\mathbf{r}_b$ is found, we compute the necessary indicators. The density at the BCP is $\\rho_b = \\rho(\\mathbf{r}_b)$. The Hessian matrix, $\\mathbf{H} = \\nabla\\nabla\\rho(\\mathbf{r}_b)$, is computed by summing the analytical Hessians for each atom:\n$$\n\\nabla\\nabla\\rho_A = \\rho_A''(r_A) \\,\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top + \\dfrac{\\rho_A'(r_A)}{r_A}\\left(\\mathbf{I}-\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top\\right)\n$$\nwith $\\rho_A'(r_A) = -2\\zeta_A \\rho_A(r_A)$ and $\\rho_A''(r_A) = 4\\zeta_A^2 \\rho_A(r_A)$. The eigenvalues of the total Hessian matrix are computed to verify the $(-1)$ signature. The Laplacian of the density at the BCP, $\\nabla^2 \\rho(\\mathbf{r}_b)$, is the trace of the Hessian matrix.\n\nThe local total energy density, $H(\\mathbf{r})$, is approximated using a local density functional:\n$$\nH(\\mathbf{r}) \\approx c_F \\rho(\\mathbf{r})^{5/3} - c_x \\rho(\\mathbf{r})^{4/3}\n$$\nwith the constants $c_F = \\frac{3}{10} (3\\pi^2)^{2/3}$ and $c_x = \\frac{3}{4}(\\frac{3}{\\pi})^{1/3}$.\n\nThe potential energy density, $V(\\mathbf{r})$, is derived from two fundamental relations: the definition of the total energy density, $H(\\mathbf{r}) = G(\\mathbf{r}) + V(\\mathbf{r})$, and the local virial theorem, $2G(\\mathbf{r}) + V(\\mathbf{r}) = \\frac{1}{4}\\nabla^2\\rho(\\mathbf{r})$. Eliminating the kinetic energy density $G(\\mathbf{r})$ yields an expression for $V(\\mathbf{r})$ in terms of $H(\\mathbf{r})$ and the Laplacian:\n$$\nV(\\mathbf{r}_b) = 2 H(\\mathbf{r}_b) - \\frac{1}{4} \\nabla^2\\rho(\\mathbf{r}_b)\n$$\nFinally, we compute the model Interacting Quantum Atoms (IQA) energy estimator for the O-H interaction as:\n$$\nE_{\\mathrm{IQA}}^{\\mathrm{(est)}} = \\kappa V(\\mathbf{r}_b)\n$$\nwith the provided constant $\\kappa = 1/2$. All calculations are performed for the given test cases, and due to symmetry, the results for the O-H$_1$ and O-H$_2$ bonds are identical for each case. The final output is structured as a list of six-tuples containing the results for each case.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the QTAIM problem for different water molecule models.\n    \"\"\"\n\n    # --- Constants in atomic units ---\n    # Thomas-Fermi kinetic energy density constant\n    C_F = 0.3 * (3 * np.pi**2)**(2.0/3.0)\n    # Dirac exchange energy density constant\n    C_X = 0.75 * (3 / np.pi)**(1.0/3.0)\n    # IQA energy estimator constant\n    KAPPA = 0.5\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: R_OH, theta_deg, zeta_O, zeta_H\n        (1.81, 104.5, 2.2, 1.24),\n        # Case 2\n        (2.00, 104.5, 2.2, 1.24),\n        # Case 3\n        (1.60, 104.5, 2.2, 1.24),\n        # Case 4\n        (1.81, 104.5, 2.0, 1.24),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        R_OH, theta_deg, zeta_O, zeta_H = case\n        theta_rad = np.deg2rad(theta_deg)\n        N_O, N_H = 8.0, 1.0\n\n        # --- Define Atomic System ---\n        atoms = [\n            # atom_params: [position, N, zeta, C]\n            {'pos': np.array([0.0, 0.0, 0.0]), 'N': N_O, 'zeta': zeta_O},      # Oxygen\n            {'pos': np.array([R_OH, 0.0, 0.0]), 'N': N_H, 'zeta': zeta_H},   # Hydrogen 1\n            {'pos': np.array([R_OH * np.cos(theta_rad), \n                               R_OH * np.sin(theta_rad), 0.0]), \n             'N': N_H, 'zeta': zeta_H} # Hydrogen 2\n        ]\n        \n        for atom in atoms:\n            atom['C'] = atom['N'] * atom['zeta']**3 / np.pi\n\n        # --- Helper functions for QTAIM calculations ---\n        def get_atomic_rho(r_dist, C, zeta):\n            return C * np.exp(-2.0 * zeta * r_dist)\n\n        def get_total_rho(r_vec, atoms_list):\n            total_rho = 0.0\n            for atom in atoms_list:\n                r_dist = np.linalg.norm(r_vec - atom['pos'])\n                if r_dist  1e-9: return np.inf # Avoid singularity at nucleus\n                total_rho += get_atomic_rho(r_dist, atom['C'], atom['zeta'])\n            return total_rho\n        \n        def grad_rho_x_on_axis(s, atoms_list, R):\n            \"\"\"\n            Calculates the x-component of the gradient of rho on the O-H1 axis.\n            This is the function whose root we need to find.\n            \"\"\"\n            r_vec = np.array([s, 0.0, 0.0])\n            grad_x_sum = 0.0\n\n            for atom in atoms_list:\n                v = r_vec - atom['pos']\n                r_dist = np.linalg.norm(v)\n                if r_dist  1e-9: return np.inf\n                \n                rho_val = get_atomic_rho(r_dist, atom['C'], atom['zeta'])\n                # Directional derivative component: -2*zeta*rho*(v_x/r_dist)\n                grad_x_sum += -2.0 * atom['zeta'] * rho_val * (v[0] / r_dist)\n            \n            return grad_x_sum\n            \n        def get_hessian(r_vec, atoms_list):\n            hessian = np.zeros((3, 3))\n            I = np.identity(3)\n            for atom in atoms_list:\n                v = r_vec - atom['pos']\n                r_dist = np.linalg.norm(v)\n\n                if r_dist  1e-9: continue\n\n                rho_val = get_atomic_rho(r_dist, atom['C'], atom['zeta'])\n                zeta = atom['zeta']\n                v_outer_v = np.outer(v, v)\n\n                # rho_A''(r) part\n                term1_coeff = 4 * zeta**2\n                # rho_A'(r)/r part\n                term2_coeff = -2 * zeta / r_dist\n\n                H_A = (term1_coeff * rho_val) * (v_outer_v / r_dist**2) + \\\n                      (term2_coeff * rho_val) * (I - v_outer_v / r_dist**2)\n                \n                hessian += H_A\n            return hessian\n\n        # --- BCP Location ---\n        # Search for BCP on the O-H1 bond axis (x-axis)\n        try:\n            # A small epsilon is added to the lower bound to avoid the nucleus\n            s_b = brentq(lambda s: grad_rho_x_on_axis(s, atoms, R_OH), 1e-6, R_OH - 1e-6)\n        except ValueError:\n            # Handle cases where no BCP is found in the interval, although unlikely for these systems\n            all_results.append([np.nan] * 6)\n            continue\n            \n        r_b = np.array([s_b, 0.0, 0.0])\n\n        # --- QTAIM Indicator Calculation at BCP ---\n        # Density at BCP\n        rho_b = get_total_rho(r_b, atoms)\n\n        # Hessian and Laplacian at BCP\n        Hessian_b = get_hessian(r_b, atoms)\n        \n        # Eigenvalue check for BCP signature (optional, for validation)\n        eigvals = np.linalg.eigvalsh(Hessian_b)\n        # assert np.sum(eigvals  0) == 2, f\"Invalid BCP signature: {eigvals}\"\n\n        # Laplacian\n        laplacian_b = np.trace(Hessian_b)\n\n        # Total energy density at BCP\n        H_b = C_F * rho_b**(5.0/3.0) - C_X * rho_b**(4.0/3.0)\n\n        # Potential energy density at BCP\n        V_b = 2.0 * H_b - 0.25 * laplacian_b\n\n        # IQA energy estimator\n        E_IQA_est = KAPPA * V_b\n\n        # --- Assemble results ---\n        # Due to symmetry, results for O-H1 and O-H2 are identical\n        case_result = [E_IQA_est, E_IQA_est, rho_b, rho_b, H_b, H_b]\n        all_results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # Manually format the list of lists string to avoid whitespace issues\n    # and ensure it matches the required Python-style list of lists string.\n    output_str = '[' + ','.join([str(res) for res in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2876091"}, {"introduction": "A key application of QTAIM is the development of empirical models that correlate topological indicators, such as the density at the BCP ($\\rho_b$), with macroscopic properties like bond energy. This final practice challenges you to think like a practicing scientist by evaluating the robustness and transferability of such correlations. By performing regression analysis on hypothetical datasets for different chemical families, you will investigate a crucial question: how universal are these structure-property relationships, and what are their predictive limitations [@problem_id:2876039]?", "problem": "You are given three chemical families for which the electron density at the bond critical point (BCP), denoted $ \\rho_b $ in units of electrons per cubic bohr ($\\mathrm{e/bohr^3}$), and reference bond energies $ E $ in kilojoules per mole ($\\mathrm{kJ/mol}$) have been compiled. In the framework of Quantum Theory of Atoms in Molecules (QTAIM), a bond critical point is a point on the bond path where the gradient of the electron density $ \\nabla \\rho(\\mathbf{r}) $ vanishes and the Hessian of $ \\rho $ has signature consistent with a bond saddle point. We focus on the empirical practice of correlating $ \\rho_b $ to $ E $ and want to evaluate the transferability of such correlations across chemical families. Your task is to formalize this evaluation as a mathematically well-posed regression and error analysis problem and implement it as a program.\n\nStart from the following foundations:\n- The electron density $ \\rho(\\mathbf{r}) $ is a scalar field over space, and a bond critical point is a stationary point of $ \\rho(\\mathbf{r}) $ along the bond path.\n- We are given data pairs $ (\\rho_b, E) $ for several bonds within each family.\n- Empirical structure–property models often take the power-law form $ E = k \\, \\rho_b^{\\alpha} $, where $ k  0 $ and $ \\alpha $ are parameters to be learned from data.\n- The method of ordinary least squares for linear regression is a well-tested procedure to estimate parameters when a linear relationship is specified.\n\nTasks:\n1) Adopt the model $ E = k \\, \\rho_b^{\\alpha} $. Estimate the parameters $ k $ and $ \\alpha $ from training data by applying ordinary least squares to the logarithmically transformed variables, i.e., regress $ \\ln E $ against $ \\ln \\rho_b $, so that $ \\ln E = \\ln k + \\alpha \\ln \\rho_b $. Use the unique least-squares solution that minimizes the sum of squared residuals in the transformed space.\n2) Define the root-mean-square error (RMSE) on a test set as $ \\mathrm{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (E_i - \\hat{E}_i)^2} $, where $ \\hat{E}_i $ is the predicted energy for $ \\rho_{b,i} $ using the trained model, and $ n $ is the number of test points.\n3) To quantify within-family predictive error (a baseline for noise and model adequacy), compute leave-one-out cross-validation (LOOCV) RMSE within a family: for each point in that family, fit the model on the remaining points and compute the squared prediction error on the left-out point; aggregate across all left-out points to yield the LOOCV RMSE.\n4) To assess transferability across families, train the model on one family and evaluate RMSE on a different family without refitting.\n\nData (each pair is $ (\\rho_b, E) $ with $ \\rho_b $ in $ \\mathrm{e/bohr^3} $ and $ E $ in $ \\mathrm{kJ/mol} $):\n- Family Covalent (C): $[(0.12, 125.2), (0.15, 176.0), (0.18, 227.0), (0.22, 312.0), (0.26, 395.0), (0.30, 497.0), (0.34, 590.0), (0.38, 706.0)]$.\n- Family Ionic/Dative (I): $[(0.06, 78.0), (0.08, 111.0), (0.10, 152.0), (0.12, 189.0), (0.14, 235.0), (0.16, 279.0)]$.\n- Family Hydrogen-bonded (H): $[(0.010, 3.2), (0.015, 5.1), (0.020, 7.4), (0.030, 12.0), (0.040, 16.6), (0.050, 22.3)]$.\n\nTest suite:\n- Cross-family RMSE cases (train family $\\rightarrow$ test family):\n  1) $ \\mathrm{C} \\rightarrow \\mathrm{I} $\n  2) $ \\mathrm{I} \\rightarrow \\mathrm{C} $\n  3) $ \\mathrm{C} \\rightarrow \\mathrm{H} $\n  4) $ \\mathrm{H} \\rightarrow \\mathrm{C} $\n  5) $ \\mathrm{H} \\rightarrow \\mathrm{I} $\n  6) $ \\mathrm{I} \\rightarrow \\mathrm{H} $\n- Within-family LOOCV RMSE cases:\n  7) $ \\mathrm{C} \\rightarrow \\mathrm{C} $ (LOOCV)\n  8) $ \\mathrm{H} \\rightarrow \\mathrm{H} $ (LOOCV)\n  9) $ \\mathrm{I} \\rightarrow \\mathrm{I} $ (LOOCV)\n\nImplementation and output requirements:\n- Use natural logarithms for the regression in the transformed space.\n- All RMSE values must be computed in $ \\mathrm{kJ/mol} $ and reported in $ \\mathrm{kJ/mol} $.\n- Your program must produce a single line of output containing the nine RMSE values corresponding to the test suite above, in the specified order, rounded to three decimal places, as a comma-separated list enclosed in square brackets. For example, an output should look like $[\\dots]$ with exactly nine decimal-formatted numbers.\n- Angles are not involved. No percentages are involved.\n\nYour program must be a complete, runnable implementation that hardcodes the data above and performs the calculations with no external input. The final printed output must be a single line in the exact format described.", "solution": "The problem is scientifically well-posed and provides a complete set of instructions for a computational task in the domain of quantum chemistry and data analysis. It is based on the established practice of correlating topological properties of the electron density, such as the value at a bond critical point ($\\rho_b$), with macroscopic chemical properties like bond energy ($E$). The problem is validated as sound, and a solution is provided below.\n\nThe core of the problem is to quantify the predictive power and transferability of an empirical power-law model, $E = k \\, \\rho_b^{\\alpha}$, which connects the bond energy $E$ to the electron density at the bond critical point, $\\rho_b$. The parameters $k$ and $\\alpha$ are specific to the chemical environment and must be determined from experimental or computational data.\n\nTo estimate these parameters, we linearize the model by taking the natural logarithm of both sides:\n$$ \\ln(E) = \\ln(k \\, \\rho_b^{\\alpha}) = \\ln(k) + \\alpha \\ln(\\rho_b) $$\nThis equation is in the form of a straight line, $y = c + m x$, where the variables are $y = \\ln(E)$ and $x = \\ln(\\rho_b)$. The slope of the line is $m = \\alpha$, and the y-intercept is $c = \\ln(k)$. This transformation allows us to use the method of ordinary least squares (OLS) to find the optimal values for $\\alpha$ and $\\ln(k)$ that minimize the sum of squared differences between the observed and predicted values of $\\ln(E)$.\n\nFor a given training dataset of $n$ points, $\\{(\\rho_{b,i}, E_i)\\}_{i=1}^n$, we first transform it into a set of logarithmic points $\\{x_i, y_i\\}_{i=1}^n$, where $x_i = \\ln(\\rho_{b,i})$ and $y_i = \\ln(E_i)$. The OLS solution for the slope $\\alpha$ and intercept $\\ln(k)$ is given by:\n$$ \\alpha = \\frac{n \\sum_{i=1}^{n} (x_i y_i) - (\\sum_{i=1}^{n} x_i) (\\sum_{i=1}^{n} y_i)}{n \\sum_{i=1}^{n} (x_i^2) - (\\sum_{i=1}^{n} x_i)^2} $$\n$$ \\ln(k) = \\bar{y} - \\alpha \\bar{x} $$\nwhere $\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i$ and $\\bar{y} = \\frac{1}{n} \\sum_{i=1}^{n} y_i$ are the sample means. The parameter $k$ is then found by exponentiation: $k = e^{\\ln(k)}$.\n\nOnce the model parameters $(\\alpha, k)$ are determined from a training set, we can predict the energy $\\hat{E}_j$ for any new value of electron density $\\rho_{b,j}$ using the original power-law relationship:\n$$ \\hat{E}_j = k \\, (\\rho_{b,j})^{\\alpha} $$\nThe performance of the model is assessed using the Root-Mean-Square Error (RMSE) on a test set of $N$ points, which is defined as:\n$$ \\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{j=1}^{N} (E_j - \\hat{E}_j)^2} $$\nThis metric provides a measure of the average magnitude of the prediction error in the original units of energy ($\\mathrm{kJ/mol}$).\n\nThe problem requires two types of model evaluation:\n$1$. **Cross-Family Transferability**: This assesses how well a model trained on one chemical family (e.g., Covalent) predicts the energies for a different family (e.g., Ionic). This is a direct test of the model's generality. The procedure involves fitting the model parameters $(\\alpha, k)$ using all data from the training family and then calculating the RMSE on the entire test family.\n\n$2$. **Within-Family Predictive Error**: This is evaluated using Leave-One-Out Cross-Validation (LOOCV). This technique provides a robust estimate of how well the model predicts new data from *within the same family*, serving as a baseline for the model's inherent accuracy and stability. For a family with $n$ data points, the process is repeated $n$ times. In each iteration $i$, the $i$-th data point is held out as a test point, and the model is trained on the remaining $n-1$ points. A prediction $\\hat{E}_i$ is made for the held-out point. The final LOOCV RMSE is calculated over all $n$ such predictions, $\\{ (E_i, \\hat{E}_i) \\}_{i=1}^n$.\n\nThe implementation will systematically perform these calculations for the nine specified test cases. The provided data for the Covalent (C), Ionic/Dative (I), and Hydrogen-bonded (H) families will be used. The regression is performed using `scipy.stats.linregress` on the log-transformed data, which provides a numerically stable implementation of OLS. The resulting parameters are then used to compute predictions and RMSE values as defined.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the QTAIM regression and error analysis problem.\n    \"\"\"\n    # Define the data for the three chemical families.\n    # Each entry is a numpy array of (rho_b, E) pairs.\n    data = {\n        'C': np.array([\n            (0.12, 125.2), (0.15, 176.0), (0.18, 227.0), (0.22, 312.0),\n            (0.26, 395.0), (0.30, 497.0), (0.34, 590.0), (0.38, 706.0)\n        ]),\n        'I': np.array([\n            (0.06, 78.0), (0.08, 111.0), (0.10, 152.0), (0.12, 189.0),\n            (0.14, 235.0), (0.16, 279.0)\n        ]),\n        'H': np.array([\n            (0.010, 3.2), (0.015, 5.1), (0.020, 7.4), (0.030, 12.0),\n            (0.040, 16.6), (0.050, 22.3)\n        ])\n    }\n\n    def fit_model(training_data):\n        \"\"\"\n        Fits the power-law model E = k * rho_b^alpha by linear regression\n        on log-transformed data.\n        \n        Args:\n            training_data (np.ndarray): Array of (rho_b, E) pairs.\n            \n        Returns:\n            tuple: A tuple (alpha, k) representing the model parameters.\n        \"\"\"\n        rho_b = training_data[:, 0]\n        E = training_data[:, 1]\n        \n        log_rho_b = np.log(rho_b)\n        log_E = np.log(E)\n        \n        # OLS on log-transformed data: ln(E) = alpha * ln(rho_b) + ln(k)\n        slope, intercept, _, _, _ = linregress(log_rho_b, log_E)\n        \n        alpha = slope\n        k = np.exp(intercept)\n        \n        return alpha, k\n\n    def predict_E(model, rho_b_values):\n        \"\"\"\n        Predicts bond energies E using a fitted power-law model.\n        \n        Args:\n            model (tuple): A tuple (alpha, k) of model parameters.\n            rho_b_values (np.ndarray): Array of rho_b values.\n            \n        Returns:\n            np.ndarray: Array of predicted E values.\n        \"\"\"\n        alpha, k = model\n        return k * (rho_b_values ** alpha)\n\n    def calculate_rmse(E_true, E_pred):\n        \"\"\"\n        Calculates the Root-Mean-Square Error.\n        \n        Args:\n            E_true (np.ndarray): Array of true energy values.\n            E_pred (np.ndarray): Array of predicted energy values.\n            \n        Returns:\n            float: The RMSE value.\n        \"\"\"\n        return np.sqrt(np.mean((E_true - E_pred)**2))\n\n    def loocv_rmse(family_data):\n        \"\"\"\n        Calculates the Leave-One-Out Cross-Validation RMSE for a family.\n        \n        Args:\n            family_data (np.ndarray): Array of (rho_b, E) pairs for one family.\n            \n        Returns:\n            float: The LOOCV RMSE value.\n        \"\"\"\n        n_points = len(family_data)\n        squared_errors = []\n        \n        for i in range(n_points):\n            # Create leave-one-out training set by deleting the i-th row\n            lo_train_data = np.delete(family_data, i, axis=0)\n            \n            # The left-out point is the test set\n            lo_test_point = family_data[i]\n            \n            # Fit model on the (n-1) training points\n            model = fit_model(lo_train_data)\n            \n            # Predict on the single left-out point\n            rho_b_test = lo_test_point[0]\n            E_true = lo_test_point[1]\n            E_pred = predict_E(model, np.array([rho_b_test]))[0]\n            \n            squared_errors.append((E_true - E_pred)**2)\n            \n        return np.sqrt(np.mean(squared_errors))\n\n    # Define the 9 test cases from the problem statement.\n    test_suite = [\n        # Cross-family RMSE cases (train - test)\n        ('C', 'I'),  # 1\n        ('I', 'C'),  # 2\n        ('C', 'H'),  # 3\n        ('H', 'C'),  # 4\n        ('H', 'I'),  # 5\n        ('I', 'H'),  # 6\n        # Within-family LOOCV RMSE cases\n        ('C', 'C'),  # 7\n        ('H', 'H'),  # 8\n        ('I', 'I')   # 9\n    ]\n\n    results = []\n    for train_fam, test_fam in test_suite:\n        if train_fam == test_fam:\n            # This is an LOOCV case\n            family_data = data[train_fam]\n            rmse = loocv_rmse(family_data)\n        else:\n            # This is a cross-family transferability case\n            train_data = data[train_fam]\n            test_data = data[test_fam]\n            \n            # Fit model on the entire training family\n            model = fit_model(train_data)\n            \n            # Test model on the entire testing family\n            rho_b_test = test_data[:, 0]\n            E_true_test = test_data[:, 1]\n            E_pred_test = predict_E(model, rho_b_test)\n            \n            rmse = calculate_rmse(E_true_test, E_pred_test)\n            \n        results.append(rmse)\n\n    # Format the results to three decimal places and print in the required format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2876039"}]}