{"hands_on_practices": [{"introduction": "A powerful strategy in computational polymer science is coarse-graining, where complex atomistic details are simplified into a more computationally tractable bead-spring model. The success of such a model hinges on its parameters being carefully chosen to reproduce key physical properties of the system it represents. This exercise guides you through the process of calibrating a coarse-grained model, connecting fundamental principles of statistical mechanics to the practical challenge of parameterization, ensuring your simplified model is physically meaningful [@problem_id:2909623].", "problem": "You are given a coarse-grained bead-spring model of a linear homopolymer for use in Molecular Dynamics (MD) or Monte Carlo (MC) simulations. Each chain has $N$ beads and $M = N-1$ bonds. The bonded interaction is modeled by the finitely extensible nonlinear elastic (FENE) potential with parameters spring constant $k$ and maximum bond extension $R_0$. Nonbonded interactions between beads are modeled by the Weeks-Chandler-Andersen (WCA) truncation of the Lennard-Jones (LJ) potential, with energy scale $\\epsilon$ and LJ length $\\sigma$. You are to calibrate the parameters $k$, $R_0$, and $\\epsilon$ so that the model reproduces a target mean-square end-to-end distance $\\langle R^2 \\rangle$ of the chain and a target isothermal compressibility $\\kappa_T$ measured in an atomistic simulation, using a principled derivation from statistical mechanics.\n\nAll quantities in this problem are expressed in reduced Lennard-Jones units at a fixed temperature. Specifically: length is measured in units of $\\sigma$ (so any length $x$ is rendered dimensionless as $x^\\star = x / \\sigma$), energy is measured in units of $k_{\\mathrm{B}} T$ (so any energy $E$ is rendered dimensionless as $E^\\star = E / (k_{\\mathrm{B}} T)$), number density is measured in units of $\\sigma^{-3}$ (so $\\rho^\\star = \\rho \\, \\sigma^3$), and isothermal compressibility is measured in units of $\\sigma^3 / (k_{\\mathrm{B}} T)$ (so $\\kappa_T^\\star = \\kappa_T \\, k_{\\mathrm{B}} T / \\sigma^3$). In these reduced units, denote the dimensionless parameters by $k^\\star = k \\, \\sigma^2 / (k_{\\mathrm{B}} T)$, $R_0^\\star = R_0 / \\sigma$, and $\\epsilon^\\star = \\epsilon / (k_{\\mathrm{B}} T)$; the target observables are $\\langle R^2 \\rangle^\\star = \\langle R^2 \\rangle / \\sigma^2$ and $\\kappa_T^\\star$ at number density $\\rho^\\star$.\n\nFundamental bases and assumptions:\n- The single-bond FENE potential is $U_{\\mathrm{FENE}}(r) = -\\tfrac{1}{2} k R_0^2 \\ln\\!\\left(1 - \\frac{r^2}{R_0^2}\\right)$ for $0 \\le r  R_0$, where $r$ is the bond length. The Boltzmann weight $e^{-\\beta U}$ governs the bond-length statistics, with $\\beta = 1/(k_{\\mathrm{B}} T)$.\n- The partition function for a single FENE bond in three dimensions yields a radial probability density proportional to $r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r))$ for $0 \\le r  R_0$. Using the substitution $x = r^2/R_0^2$ and properties of the Beta function, the single-bond mean-square length can be computed exactly at equilibrium.\n- In the ideal-chain limit (no angular correlations and no excluded-volume effects), the mean-square end-to-end distance satisfies $\\langle R^2 \\rangle = \\sum_{i=1}^{M} \\langle \\mathbf{b}_i^2 \\rangle = M \\langle r^2 \\rangle$, where $\\mathbf{b}_i$ is the $i$-th bond vector and $r = \\|\\mathbf{b}_i\\|$.\n- The isothermal compressibility obeys the compressibility equation $S(0) = \\rho \\, k_{\\mathrm{B}} T \\, \\kappa_T$, where $S(0)$ is the zero-wavevector static structure factor. In the dilute regime where two-body interactions dominate (consistent with the second-virial approximation or a low-wavevector limit of the Random Phase Approximation (RPA) in field-theoretic treatments), $S(0)$ and the second virial coefficient $B_2$ satisfy\n$$\n\\frac{1}{S(0)} = 1 + 2 B_2 \\rho + \\mathcal{O}(\\rho^2).\n$$\nTherefore, in reduced units,\n$$\n\\rho^\\star \\, \\kappa_T^\\star \\approx \\frac{1}{1 + 2 B_2^\\star \\rho^\\star},\n$$\nwith $B_2^\\star = B_2 / \\sigma^3$. The second virial coefficient is given by the Mayer integral\n$$\nB_2 = -2\\pi \\int_0^\\infty \\left(e^{-\\beta u(r)} - 1\\right) r^2 \\, dr.\n$$\n- The Weeks-Chandler-Andersen truncation of the Lennard-Jones potential is $u_{\\mathrm{WCA}}(r) = 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] + \\epsilon$ for $0 \\le r \\le r_c$, with $r_c = 2^{1/6}\\sigma$, and $u_{\\mathrm{WCA}}(r) = 0$ for $r  r_c$.\n\nTasks to derive and implement:\n1) Starting from the Boltzmann distribution and the exact integrals for a single FENE bond in three dimensions, derive the closed-form expression for the single-bond mean-square length in reduced units,\n$$\n\\langle r^2 \\rangle^\\star = R_0^{\\star 2} \\, \\frac{3}{k^\\star R_0^{\\star 2} + 5}.\n$$\nThen, invoking the ideal-chain additivity $\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star$, show how to compute $k^\\star$ given $R_0^\\star$, $M$, and $\\langle R^2 \\rangle^\\star$.\n2) Connect the reduced compressibility $\\kappa_T^\\star$ to the reduced second virial coefficient $B_2^\\star$ via\n$$\nB_2^\\star = \\frac{1}{2\\rho^\\star}\\left(\\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1\\right),\n$$\nand compute $B_2^\\star$ from the WCA potential by numerical quadrature of\n$$\nB_2^\\star(\\epsilon^\\star) = -2\\pi \\int_0^{r_c^\\star} \\left[\\exp\\!\\left(-u^\\star(r^\\star)\\right) - 1 \\right] r^{\\star 2} \\, dr^\\star,\n$$\nwhere $u^\\star(r^\\star) = 4 \\epsilon^\\star \\left[\\left(\\frac{1}{r^\\star}\\right)^{12} - \\left(\\frac{1}{r^\\star}\\right)^6\\right] + \\epsilon^\\star$ for $0 \\le r^\\star \\le r_c^\\star$ and $u^\\star(r^\\star) = 0$ otherwise, with $r_c^\\star = 2^{1/6}$. Use monotone root finding to invert $B_2^\\star(\\epsilon^\\star)$ and obtain $\\epsilon^\\star$ from the target $B_2^\\star$ computed from $\\rho^\\star$ and $\\kappa_T^\\star$.\n3) To close the system, assume the atomistic simulation provides the chain contour length $L_c$ (the maximum end-to-end length at full extension). In reduced units, impose the finite extensibility constraint $L_c^\\star = M \\, R_0^\\star$ to set $R_0^\\star = L_c^\\star / M$.\n\nYour program must take a predefined test suite of target values and, for each case, compute and return $k^\\star$, $R_0^\\star$, and $\\epsilon^\\star$. You must use the reduced-unit framework described above and express the outputs as follows: $k^\\star$ is dimensionless and corresponds to $k \\, \\sigma^2 / (k_{\\mathrm{B}} T)$, $R_0^\\star$ is dimensionless as $R_0 / \\sigma$, and $\\epsilon^\\star$ is dimensionless as $\\epsilon / (k_{\\mathrm{B}} T)$.\n\nTest suite of input parameter sets $(N, \\langle R^2 \\rangle^\\star, \\rho^\\star, \\kappa_T^\\star, L_c^\\star)$ to be hard-coded in your program:\n- Case A (general case): $(20, 200.0, 0.1, 8.0, 95.0)$.\n- Case B (ideal-gas limit for compressibility): $(10, 50.0, 0.05, 20.0, 30.0)$.\n- Case C (short chain, moderate density): $(5, 9.0, 0.2, 4.0, 8.0)$.\n- Case D (long chain, very low density): $(50, 200.0, 0.01, 99.0, 147.0)$.\n\nEdge and validation considerations:\n- To ensure physical consistency of the FENE calibration, the target must satisfy $\\langle R^2 \\rangle^\\star  \\frac{3}{5} M R_0^{\\star 2}$; otherwise the inferred $k^\\star$ would be non-positive. Your program should assume the provided test suite respects this bound.\n- For the WCA potential, the reduced second virial coefficient is bounded above by $B_{2,\\max}^\\star = \\frac{2\\pi}{3} r_c^{\\star 3} = \\frac{2\\pi}{3} 2^{1/2}$. The program should solve for $\\epsilon^\\star$ using bracketing and bisection; if the target $B_2^\\star$ is non-positive, set $\\epsilon^\\star = 0$; if the target exceeds the numerical value attained at a very large $\\epsilon^\\star$, return that large value as an approximation.\n\nFinal output format:\n- Your program should produce a single line of output containing, for each case in the order A, B, C, D, a list of the three calibrated parameters $[k^\\star, R_0^\\star, \\epsilon^\\star]$. Aggregate these into a single list and print exactly one line in the form\n\"[ [kA,R0A,epsA],[kB,R0B,epsB],[kC,R0C,epsC],[kD,R0D,epsD] ]\"\nwith no additional whitespace requirements enforced beyond syntactic correctness.\n\nAll angles are irrelevant to this task. All physical quantities are expressed in reduced Lennard-Jones units as defined, so no additional unit conversions are required. The output entries should be floating-point numbers.", "solution": "The problem presented is a task in parameterizing a coarse-grained polymer model. The objective is to determine the parameters of a bead-spring chain, specifically the FENE bond parameters $k^\\star$ and $R_0^\\star$, and the WCA non-bonded interaction parameter $\\epsilon^\\star$, such that the model reproduces a target mean-square end-to-end distance $\\langle R^2 \\rangle^\\star$ and isothermal compressibility $\\kappa_T^\\star$. The problem is well-posed, scientifically grounded in the principles of statistical mechanics, and provides a clear, step-by-step procedure for the calibration. It is therefore deemed valid. We proceed with the solution.\n\nThe overall strategy is to decouple the problem. First, we determine the bonded interaction parameters ($k^\\star, R_0^\\star$) by relating them to the chain's structural properties ($\\langle R^2 \\rangle^\\star, L_c^\\star$). Second, we determine the non-bonded interaction parameter ($\\epsilon^\\star$) by relating it to the system's bulk thermodynamic properties ($\\kappa_T^\\star, \\rho^\\star$). All calculations will be performed in the specified reduced units.\n\n**1. Calibration of Bonded Interaction Parameters ($R_0^\\star$ and $k^\\star$)**\n\nThe problem specifies two inputs related to the single-chain structure: the contour length $L_c^\\star$ and the mean-square end-to-end distance $\\langle R^2 \\rangle^\\star$.\n\nFirst, we determine the maximum bond extension $R_0^\\star$. The contour length $L_c$ of a chain with $M = N-1$ bonds of maximum length $R_0$ is $L_c = M R_0$. In reduced units, this becomes $L_c^\\star = M R_0^\\star$. This provides a direct expression for $R_0^\\star$:\n$$\nR_0^\\star = \\frac{L_c^\\star}{M} = \\frac{L_c^\\star}{N-1}\n$$\n\nNext, we establish the relationship between the FENE spring constant $k^\\star$ and the mean-square end-to-end distance $\\langle R^2 \\rangle^\\star$. The problem states that in the ideal-chain limit, where there are no correlations between bond vectors, the total mean-square end-to-end distance is the sum of the individual mean-square bond lengths:\n$$\n\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star\n$$\nwhere $\\langle r^2 \\rangle^\\star$ is the mean-square length of a single bond. We must derive the expression for $\\langle r^2 \\rangle^\\star$ for a single FENE bond.\n\nThe probability distribution of the bond length $r$ is governed by the Boltzmann factor. In three dimensions, the normalized probability density for finding a bond of length $r$ is $P(r) = (4\\pi/Z) r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r))$, where $Z$ is the single-bond partition function. The mean-square bond length is given by:\n$$\n\\langle r^2 \\rangle = \\int_0^{R_0} r^2 P(r) dr = \\frac{\\int_0^{R_0} r^4 \\exp(-\\beta U_{\\mathrm{FENE}}(r)) dr}{\\int_0^{R_0} r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r)) dr}\n$$\nThe FENE potential is $U_{\\mathrm{FENE}}(r) = -\\frac{1}{2} k R_0^2 \\ln(1 - r^2/R_0^2)$. Substituting this into the Boltzmann factor gives:\n$$\n\\exp(-\\beta U_{\\mathrm{FENE}}(r)) = \\exp\\left(\\frac{1}{2}\\beta k R_0^2 \\ln\\left(1 - \\frac{r^2}{R_0^2}\\right)\\right) = \\left(1 - \\frac{r^2}{R_0^2}\\right)^{\\frac{1}{2}\\beta k R_0^2}\n$$\nWe perform a change of variables to $x = (r/R_0)^2$, so $r = R_0 x^{1/2}$ and $dr = \\frac{1}{2} R_0 x^{-1/2} dx$. The integrals become:\n$$\n\\int_0^{R_0} r^n \\left(1 - \\frac{r^2}{R_0^2}\\right)^{\\alpha} dr = \\int_0^1 (R_0 x^{1/2})^n (1-x)^\\alpha \\left(\\frac{1}{2} R_0 x^{-1/2} dx\\right) = \\frac{R_0^{n+1}}{2} \\int_0^1 x^{(n-1)/2} (1-x)^\\alpha dx\n$$\nwhere $\\alpha = \\frac{1}{2}\\beta k R_0^2$. The integral is related to the Beta function $B(p,q) = \\int_0^1 t^{p-1}(1-t)^{q-1}dt$.\n\nFor the denominator ($n=2$): $p-1 = (2-1)/2 = 1/2 \\implies p=3/2$. $q-1=\\alpha \\implies q=\\alpha+1$. The integral is $\\frac{R_0^3}{2} B(3/2, \\alpha+1)$.\nFor the numerator ($n=4$): $p-1 = (4-1)/2 = 3/2 \\implies p=5/2$. $q-1=\\alpha \\implies q=\\alpha+1$. The integral is $\\frac{R_0^5}{2} B(5/2, \\alpha+1)$.\n\nThus, the mean-square length is:\n$$\n\\langle r^2 \\rangle = \\frac{\\frac{R_0^5}{2} B(5/2, \\alpha+1)}{\\frac{R_0^3}{2} B(3/2, \\alpha+1)} = R_0^2 \\frac{B(5/2, \\alpha+1)}{B(3/2, \\alpha+1)}\n$$\nUsing the identity $B(p,q) = \\frac{\\Gamma(p)\\Gamma(q)}{\\Gamma(p+q)}$ and the property $\\Gamma(z+1) = z\\Gamma(z)$, we have:\n$$\n\\frac{B(5/2, q)}{B(3/2, q)} = \\frac{\\Gamma(5/2)/\\Gamma(3/2)}{\\Gamma(5/2+q)/\\Gamma(3/2+q)} = \\frac{3/2}{3/2+q}\n$$\nSubstituting $q = \\alpha+1 = \\frac{1}{2}\\beta k R_0^2 + 1$:\n$$\n\\langle r^2 \\rangle = R_0^2 \\frac{3/2}{3/2 + (\\frac{1}{2}\\beta k R_0^2+1)} = R_0^2 \\frac{3/2}{5/2 + \\frac{1}{2}\\beta k R_0^2} = R_0^2 \\frac{3}{5 + \\beta k R_0^2}\n$$\nIn reduced units, $\\beta k R_0^2 = (\\beta k \\sigma^2)(R_0/\\sigma)^2 = k^\\star R_0^{\\star 2}$. This yields the expression provided in the problem statement:\n$$\n\\langle r^2 \\rangle^\\star = \\frac{\\langle r^2 \\rangle}{\\sigma^2} = \\frac{R_0^2}{\\sigma^2} \\frac{3}{5 + k^\\star R_0^{\\star 2}} = R_0^{\\star 2} \\frac{3}{k^\\star R_0^{\\star 2} + 5}\n$$\nNow we can solve for $k^\\star$. Substituting this into the ideal-chain relation:\n$$\n\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star = M R_0^{\\star 2} \\frac{3}{k^\\star R_0^{\\star 2} + 5}\n$$\nRearranging to solve for $k^\\star$:\n$$\nk^\\star R_0^{\\star 2} + 5 = \\frac{3 M R_0^{\\star 2}}{\\langle R^2 \\rangle^\\star} \\implies k^\\star = \\frac{1}{R_0^{\\star 2}} \\left( \\frac{3 M R_0^{\\star 2}}{\\langle R^2 \\rangle^\\star} - 5 \\right) = \\frac{3M}{\\langle R^2 \\rangle^\\star} - \\frac{5}{R_0^{\\star 2}}\n$$\nWith $R_0^\\star$ known, this equation determines $k^\\star$.\n\n**2. Calibration of Non-Bonded Interaction Parameter ($\\epsilon^\\star$)**\n\nThe parameter $\\epsilon^\\star$ for the non-bonded WCA potential is determined from the bulk isothermal compressibility $\\kappa_T^\\star$. The problem provides the connection through the compressibility equation in the low-density limit, which relates $\\kappa_T$ to the second virial coefficient $B_2$. In reduced units:\n$$\n\\rho^\\star \\kappa_T^\\star \\approx \\frac{1}{1 + 2 B_2^\\star \\rho^\\star}\n$$\nWe invert this equation to find the target value of the reduced second virial coefficient, $B_{2,\\text{target}}^\\star$:\n$$\n1 + 2 B_2^\\star \\rho^\\star = \\frac{1}{\\rho^\\star \\kappa_T^\\star} \\implies B_{2,\\text{target}}^\\star = \\frac{1}{2\\rho^\\star} \\left( \\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1 \\right)\n$$\nThe second virial coefficient is defined by the Mayer integral over the pair potential $u(r)$:\n$$\nB_2 = -2\\pi \\int_0^\\infty \\left(e^{-\\beta u(r)} - 1\\right) r^2 dr\n$$\nFor the WCA potential, $u(r) = 0$ for $r > r_c = 2^{1/6}\\sigma$, so the integral is truncated at $r_c$. In reduced units, the expression for $B_2^\\star = B_2 / \\sigma^3$ becomes:\n$$\nB_2^\\star(\\epsilon^\\star) = -2\\pi \\int_0^{r_c^\\star} \\left[ \\exp\\left(-u^\\star(r^\\star; \\epsilon^\\star)\\right) - 1 \\right] r^{\\star 2} dr^\\star\n$$\nwhere $r_c^\\star = 2^{1/6}$ and the reduced WCA potential is:\n$$\nu^\\star(r^\\star; \\epsilon^\\star) = 4 \\epsilon^\\star \\left[ \\left(\\frac{1}{r^\\star}\\right)^{12} - \\left(\\frac{1}{r^\\star}\\right)^6 \\right] + \\epsilon^\\star\n$$\nfor $0 \\le r^\\star \\le r_c^\\star$. The function $B_2^\\star(\\epsilon^\\star)$ is monotonic, increasing from $B_2^\\star(0) = 0$ to a maximum value $B_{2, \\text{max}}^\\star = \\frac{2\\pi}{3} (r_c^\\star)^3 = \\frac{2\\pi\\sqrt{2}}{3}$ as $\\epsilon^\\star \\to \\infty$. This corresponds to the hard-sphere limit where the potential is infinite for $r^\\star  r_c^\\star$.\n\nTo find the required $\\epsilon^\\star$, we must solve the equation $B_2^\\star(\\epsilon^\\star) = B_{2,\\text{target}}^\\star$. Since an analytical solution is not available, we use a numerical approach. We first calculate $B_{2,\\text{target}}^\\star$ from the input data.\n- If $B_{2,\\text{target}}^\\star \\le 0$, this implies non-repulsive or ideal-gas behavior, which within the WCA model corresponds to $\\epsilon^\\star = 0$.\n- If $0  B_{2,\\text{target}}^\\star  B_{2, \\text{max}}^\\star$, we must find the root of the function $f(\\epsilon^\\star) = B_2^\\star(\\epsilon^\\star) - B_{2,\\text{target}}^\\star$. This will be done using a numerical root-finding algorithm, such as bisection or Brent's method, which requires computing the integral for $B_2^\\star(\\epsilon^\\star)$ numerically at each step.\n\n**Summary of the Complete Procedure:**\nFor each given test case $(N, \\langle R^2 \\rangle^\\star, \\rho^\\star, \\kappa_T^\\star, L_c^\\star)$:\n1. Calculate the number of bonds $M = N-1$.\n2. Calculate the reduced maximum bond length: $R_0^\\star = L_c^\\star / M$.\n3. Calculate the reduced spring constant: $k^\\star = \\frac{3M}{\\langle R^2 \\rangle^\\star} - \\frac{5}{R_0^{\\star 2}}$.\n4. Calculate the target reduced second virial coefficient: $B_{2,\\text{target}}^\\star = \\frac{1}{2\\rho^\\star}(\\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1)$.\n5. If $B_{2,\\text{target}}^\\star \\le 0$, set $\\epsilon^\\star = 0$. Otherwise, numerically solve $B_2^\\star(\\epsilon^\\star) = B_{2,\\text{target}}^\\star$ for $\\epsilon^\\star$ by inverting the integral expression for $B_2^\\star$. This will be implemented using numerical quadrature and a root-finding algorithm.\nThe resulting triplet $[k^\\star, R_0^\\star, \\epsilon^\\star]$ comprises the calibrated model parameters.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Solves for the coarse-grained polymer model parameters based on target\n    observables, following the derivations from statistical mechanics.\n    \"\"\"\n    # Test suite of input parameter sets:\n    # (N, R^2*, rho*, kappa_T*, L_c*)\n    test_cases = [\n        (20, 200.0, 0.1, 8.0, 95.0),    # Case A\n        (10, 50.0, 0.05, 20.0, 30.0),   # Case B\n        (5, 9.0, 0.2, 4.0, 8.0),       # Case C\n        (50, 200.0, 0.01, 99.0, 147.0), # Case D\n    ]\n\n    # WCA potential constants\n    r_c_star = 2**(1/6)\n    \n    # Store results for all cases\n    results = []\n\n    for case in test_cases:\n        N, R2_star_target, rho_star, kappa_T_star, Lc_star = case\n        \n        # --- 1. Calibrate Bonded Interaction Parameters (k_star, R0_star) ---\n        \n        M = N - 1\n        \n        # Calculate R0_star from the contour length\n        R0_star = Lc_star / M\n        \n        # Calculate k_star from the mean-square end-to-end distance\n        # k_star = 3*M / R^2* - 5 / R0*^2\n        # A check for physical consistency is assumed to pass based on problem statement\n        k_star = (3 * M / R2_star_target) - (5 / R0_star**2)\n        \n        # --- 2. Calibrate Non-Bonded Interaction Parameter (epsilon_star) ---\n\n        # Calculate the target reduced second virial coefficient B2_star\n        # Handle the ideal gas case where rho* * kappa_T* = 1\n        if np.isclose(rho_star * kappa_T_star, 1.0):\n            B2_star_target = 0.0\n        else:\n            B2_star_target = (1 / (2 * rho_star)) * ((1 / (rho_star * kappa_T_star)) - 1)\n\n        epsilon_star = 0.0\n        if B2_star_target  0:\n            # Define the WCA potential u*(r*, epsilon*)\n            def u_wca_star(r_star, eps_star):\n                inv_r6 = (1 / r_star)**6\n                inv_r12 = inv_r6**2\n                return 4 * eps_star * (inv_r12 - inv_r6) + eps_star\n\n            # Define the integrand for B2*\n            def b2_integrand(r_star, eps_star):\n                potential = u_wca_star(r_star, eps_star)\n                return -2 * np.pi * (np.exp(-potential) - 1) * r_star**2\n\n            # Define a function to compute B2* for a given epsilon*\n            def compute_B2_star(eps_star):\n                val, _ = integrate.quad(b2_integrand, 0, r_c_star, args=(eps_star,))\n                return val\n\n            # Check if target is beyond the physical maximum for WCA\n            B2_max_star = (2 * np.pi / 3) * r_c_star**3\n            if B2_star_target = B2_max_star:\n                # Approximate with a large value for epsilon_star\n                epsilon_star = 100.0  \n            else:\n                # Define the objective function for the root finder\n                def objective_func(eps_star):\n                    return compute_B2_star(eps_star) - B2_star_target\n\n                # Use a robust root-finding algorithm (Brent's method)\n                try:\n                    # Bracket the root. We know B2*(eps*) is monotonic from 0 upwards.\n                    # A sufficiently large upper bound like 100 should be safe.\n                    epsilon_star = optimize.brentq(objective_func, 0.0, 100.0, xtol=1e-9, rtol=1e-9)\n                except ValueError:\n                    # This might happen if the target is out of bounds, though we check for it.\n                    # As a safeguard, if brentq fails, we handle it gracefully.\n                    if objective_func(0.0) * objective_func(100.0)  0:\n                        # Both ends have same sign, implies target is outside range [B2(0), B2(100)]\n                        if B2_star_target  compute_B2_star(100.0):\n                             epsilon_star = 100.0\n                        else:\n                             epsilon_star = 0.0\n                    else:\n                        # Some other numerical issue\n                        epsilon_star = np.nan # Should not happen with this problem\n        \n        # Store the calibrated parameter set\n        results.append([k_star, R0_star, epsilon_star])\n\n    # Final print statement in the exact required format\n    # Using repr().replace(\" \", \"\") to match the example format exactly\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2909623"}, {"introduction": "Polymer systems are characterized by a wide spectrum of time scales, from the rapid vibrations of chemical bonds to the slow, collective diffusion of entire chains. A standard Molecular Dynamics simulation is limited by the fastest motions, forcing the use of tiny time steps and making it difficult to observe long-time phenomena. This practice introduces the Reference System Propagator Algorithm (RESPA), a sophisticated multiple-time-step integration scheme that overcomes this limitation, allowing for significant computational speedups by applying different time steps to fast and slow forces [@problem_id:2909650].", "problem": "Consider a classical polymer melt modeled as a three-dimensional bead-spring system with pairwise nonbonded interactions and nearest-neighbor bonded interactions under periodic boundary conditions. Let the Hamiltonian be split into a kinetic term and two potential contributions,\n$$\nH = T(\\{\\mathbf{p}_i\\}) + U_{\\text{fast}}(\\{\\mathbf{r}_i\\}) + U_{\\text{slow}}(\\{\\mathbf{r}_i\\}),\n$$\nwhere $T = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2 m}$, $U_{\\text{fast}}$ represents bonded interactions that vary on a fast time scale, and $U_{\\text{slow}}$ represents nonbonded interactions that vary on a slower time scale. The goal is to formulate a time-reversible Reference System Propagator Algorithm (RESPA) multiple time step integrator for this split system and assess its stability for a bead-spring melt.\n\nYou must start from first principles appropriate for molecular dynamics: Newton’s second law, Hamilton’s equations, and the Liouville operator formalism, together with the second-order symmetric Trotter factorization of propagators, as the fundamental base. Do not assume any algorithmic update rule without deriving it from these bases. The system is defined as follows.\n\n- Beads: $N$ identical particles of mass $m$, positions $\\{\\mathbf{r}_i\\}$, and velocities $\\{\\mathbf{v}_i\\}$ live in a cubic periodic box of side $L$.\n- Bonded interactions (fast): Each chain is a sequence of beads connected by harmonic bonds with potential\n$$\nU_{\\text{bond}} = \\sum_{\\langle i,j \\rangle} \\frac{1}{2} k_{\\text{b}} \\left(r_{ij} - b_0\\right)^2,\n$$\nwhere $\\langle i,j \\rangle$ denotes nearest-neighbor bead pairs along each chain, $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ measured using the minimum image convention, $k_{\\text{b}}$ is the bond stiffness, and $b_0$ is the equilibrium bond length. Define $U_{\\text{fast}} \\equiv U_{\\text{bond}}$.\n- Nonbonded interactions (slow): All nonbonded bead pairs interact via the Weeks–Chandler–Andersen (WCA) potential,\n$$\nU_{\\text{WCA}}(r) = \n\\begin{cases}\n4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] + \\varepsilon,  \\text{if } r \\le r_c,\\\\\n0,  \\text{if } r  r_c,\n\\end{cases}\n$$\nwith cutoff $r_c = 2^{1/6}\\sigma$, where $r$ is the pair distance computed via the minimum image convention. Define $U_{\\text{slow}} \\equiv \\sum_{ij,\\, \\langle i,j \\rangle \\text{ excluded}} U_{\\text{WCA}}(r_{ij})$. Exclude directly bonded neighbors from $U_{\\text{slow}}$.\n\nAll quantities are in reduced Lennard–Jones units with $m = 1$, $\\varepsilon = 1$, and $\\sigma = 1$. There are no physical units to report; all outputs must therefore be unitless.\n\nTasks:\n1. From the Liouville operator factorization, derive a reversible second-order RESPA (Reference System Propagator Algorithm) scheme that evolves the system using an outer time step $\\Delta t_{\\text{slow}}$ for the slow forces and an inner time step $\\Delta t_{\\text{fast}} = \\Delta t_{\\text{slow}}/m_{\\text{sub}}$ for the fast forces, with $m_{\\text{sub}} \\in \\mathbb{N}$ inner substeps per outer step. Explicitly state and justify the sequence of velocity and position updates that ensures time-reversibility and second-order accuracy under this splitting.\n2. Implement the derived reversible RESPA integrator in a complete, runnable program that performs microcanonical (constant total energy) dynamics for a bead-spring melt with the following fixed system specification:\n   - Number of chains $N_{\\text{chains}} = 3$, chain length $N_{\\text{ch}} = 9$, total beads $N = 27$.\n   - Number density $\\rho = 0.7$, so that $L = (N/\\rho)^{1/3}$.\n   - Harmonic bonds with $k_{\\text{b}} = 1000$ and $b_0 = 0.96$.\n   - Weeks–Chandler–Andersen nonbonded parameters $\\varepsilon = 1$, $\\sigma = 1$, $r_c = 2^{1/6}$.\n   - Periodic boundary conditions in a cube of side $L$ using the minimum image convention.\n   - Initial positions: place all $N$ beads on a uniform $3 \\times 3 \\times 3$ grid spanning the box, then assign consecutive indices to form linear chains, bonding nearest neighbors within each chain by index. This ensures no initial overlaps.\n   - Initial velocities: draw from a Maxwell–Boltzmann distribution at temperature $T_0 = 0.1$ (with Boltzmann constant $k_{\\text{B}} = 1$) and remove the center-of-mass drift.\n3. Stability assessment: For each simulation, compute the total energy\n$$\nE(t) = \\sum_{i=1}^{N} \\frac{1}{2} m \\|\\mathbf{v}_i(t)\\|^2 + U_{\\text{bond}}(t) + U_{\\text{WCA}}(t),\n$$\nand evaluate the maximum relative drift over the trajectory,\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{|E(n\\Delta t_{\\text{slow}}) - E(0)|}{|E(0)|}.\n$$\nDefine a simulation as “stable” if $\\delta_{\\max} \\le 0.05$ and “unstable” otherwise. All outputs are dimensionless.\n4. Test suite: Use the following set of time step parameters and trajectory lengths to probe different stability regimes, including a happy path, near-boundary conditions, and an unstable case. For each case, report only a boolean indicating stability according to the above criterion.\n   - Case A: $\\Delta t_{\\text{slow}} = 0.01$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n   - Case B: $\\Delta t_{\\text{slow}} = 0.02$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n   - Case C: $\\Delta t_{\\text{slow}} = 0.04$, $m_{\\text{sub}} = 2$, $N_{\\text{steps}} = 2000$.\n   - Case D: $\\Delta t_{\\text{slow}} = 0.08$, $m_{\\text{sub}} = 2$, $N_{\\text{steps}} = 2000$.\n   - Case E: $\\Delta t_{\\text{slow}} = 0.06$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n   - Case F: $\\Delta t_{\\text{slow}} = 0.10$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$.\n5. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is a boolean corresponding to the stability of cases A through F in order.\n\nYour derivation must begin from Hamilton’s equations and the Liouville operator structure, using the symmetric Trotter factorization to obtain a time-reversible multiple time step scheme. You must not assume any pre-existing update formulas; instead, derive the algorithm logically and then implement it. All parameters above are dimensionless; report only boolean values with no units.", "solution": "We begin from Hamilton’s equations,\n$$\n\\dot{\\mathbf{r}}_i = \\frac{\\partial H}{\\partial \\mathbf{p}_i} = \\frac{\\mathbf{p}_i}{m}, \\quad\n\\dot{\\mathbf{p}}_i = -\\frac{\\partial H}{\\partial \\mathbf{r}_i} = \\mathbf{F}^{\\text{fast}}_i(\\{\\mathbf{r}\\}) + \\mathbf{F}^{\\text{slow}}_i(\\{\\mathbf{r}\\}),\n$$\nwhere $\\mathbf{F}^{\\text{fast}}_i = -\\partial U_{\\text{fast}}/\\partial \\mathbf{r}_i$ and $\\mathbf{F}^{\\text{slow}}_i = -\\partial U_{\\text{slow}}/\\partial \\mathbf{r}_i$. Introduce the Liouville operators $i\\mathcal{L}_T$ for the kinetic part and $i\\mathcal{L}_{U_{\\text{fast}}}$, $i\\mathcal{L}_{U_{\\text{slow}}}$ for the fast and slow potential parts, so that the full time evolution operator over a time $\\Delta t$ is\n$$\ne^{\\Delta t\\, i\\mathcal{L}}, \\quad i\\mathcal{L} = i\\mathcal{L}_T + i\\mathcal{L}_{U_{\\text{fast}}} + i\\mathcal{L}_{U_{\\text{slow}}}.\n$$\nThe operator $i\\mathcal{L}_T$ updates positions by free streaming at fixed momenta, while $i\\mathcal{L}_{U_{\\text{fast}}}$ and $i\\mathcal{L}_{U_{\\text{slow}}}$ update momenta (velocities) at fixed positions.\n\nA second-order time-reversible multiple time step scheme follows from a symmetric Trotter factorization (Strang splitting). For an outer slow time step $\\Delta t_{\\text{slow}}$ and $m_{\\text{sub}}$ inner fast substeps with $\\Delta t_{\\text{fast}} = \\Delta t_{\\text{slow}}/m_{\\text{sub}}$, apply\n$$\ne^{\\Delta t_{\\text{slow}}\\, i\\mathcal{L}} \\approx e^{\\frac{\\Delta t_{\\text{slow}}}{2}\\, i\\mathcal{L}_{U_{\\text{slow}}}}\n\\left[\ne^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}\ne^{\\Delta t_{\\text{fast}}\\, i\\mathcal{L}_T}\ne^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}\n\\right]^{m_{\\text{sub}}}\ne^{\\frac{\\Delta t_{\\text{slow}}}{2}\\, i\\mathcal{L}_{U_{\\text{slow}}}}.\n$$\nThis is time-reversible because it is symmetric under $\\Delta t \\to -\\Delta t$. Mapping these operators to updates yields the reversible RESPA velocity-Verlet structure:\n\n- A “slow half-kick”: update velocities by $\\frac{\\Delta t_{\\text{slow}}}{2 m}\\,\\mathbf{F}^{\\text{slow}}(\\{\\mathbf{r}\\})$.\n- Repeat $m_{\\text{sub}}$ inner “fast velocity-Verlet” steps with step $\\Delta t_{\\text{fast}}$:\n  - Fast half-kick: $\\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t_{\\text{fast}}}{2 m}\\,\\mathbf{F}^{\\text{fast}}(\\{\\mathbf{r}\\})$.\n  - Drift: $\\mathbf{r} \\leftarrow \\mathbf{r} + \\Delta t_{\\text{fast}}\\, \\mathbf{v}$ (with periodic boundary conditions).\n  - Recompute $\\mathbf{F}^{\\text{fast}}(\\{\\mathbf{r}\\})$ and apply another fast half-kick.\n- Recompute $\\mathbf{F}^{\\text{slow}}(\\{\\mathbf{r}\\})$ and apply a final slow half-kick.\n\nThe above is a direct consequence of the operator splitting: $e^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}$ maps to a half momentum update at fixed positions, $e^{\\Delta t_{\\text{fast}}\\, i\\mathcal{L}_T}$ to a drift update at fixed momenta, and the slow components similarly at the outer level. Because of the symmetric composition, the algorithm is second-order accurate for the split Liouvillians.\n\nFor the specific bead-spring model:\n\n- Positions and velocities obey Newton’s equations with forces split into bonded and nonbonded parts. The bonded forces are from harmonic bonds:\n$$\nU_{\\text{bond}} = \\sum_{\\langle i,j\\rangle} \\frac{1}{2} k_{\\text{b}} \\left(r_{ij} - b_0\\right)^2,\\quad\n\\mathbf{F}^{\\text{bond}}_{i} = -\\sum_{j \\in \\mathcal{N}(i)} k_{\\text{b}} \\left(1 - \\frac{b_0}{r_{ij}}\\right) (\\mathbf{r}_i - \\mathbf{r}_j)_{\\text{MIC}},\n$$\nwhere $(\\cdot)_{\\text{MIC}}$ applies the minimum image convention in the periodic box and $\\mathcal{N}(i)$ are bonded neighbors. We set $U_{\\text{fast}} \\equiv U_{\\text{bond}}$ and $\\mathbf{F}^{\\text{fast}} \\equiv \\mathbf{F}^{\\text{bond}}$.\n- The nonbonded WCA forces, excluding directly bonded neighbors, are\n$$\nU_{\\text{WCA}}(r) =\n\\begin{cases}\n4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] + \\varepsilon,  r \\le r_c,\\\\\n0,  r  r_c,\n\\end{cases}\n$$\nand the corresponding force between a pair is\n$$\n\\mathbf{F}_{ij}^{\\text{WCA}} =\n\\begin{cases}\n24 \\varepsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}_{ij}}{r^2},  r \\le r_c,\\\\\n\\mathbf{0},  r  r_c,\n\\end{cases}\n$$\nwith $\\mathbf{r}_{ij}$ the minimum-image displacement. We set $U_{\\text{slow}} \\equiv \\sum_{ij,\\, \\langle i,j \\rangle \\text{ excluded}} U_{\\text{WCA}}(r_{ij})$ and $\\mathbf{F}^{\\text{slow}}_i = \\sum_{j \\ne i} \\mathbf{F}^{\\text{WCA}}_{ij}$ excluding bonded pairs.\n\nImplementation details and algorithmic design:\n- Initialize a cubic periodic box of side $L = (N/\\rho)^{1/3}$ with $N = 27$ beads placed on a $3 \\times 3 \\times 3$ grid. Assign $N_{\\text{chains}} = 3$ chains of length $N_{\\text{ch}} = 9$ by consecutive indexing. Bonds connect consecutive indices within each chain.\n- Velocities are drawn from a Maxwell–Boltzmann distribution at temperature $T_0 = 0.1$ with standard deviation $\\sqrt{T_0/m}$ componentwise, and the center-of-mass velocity is removed to enforce zero net momentum.\n- Forces are computed using vectorized operations under the minimum image convention:\n  - For nonbonded WCA, construct pairwise displacement tensors and apply masks to exclude bonded neighbors and to apply the cutoff $r_c = 2^{1/6}$. Accumulate forces with $\\mathrm{add.at}$ into per-particle arrays to ensure correct antisymmetry $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$, and compute pair energies by summing over $ij$.\n  - For bonded forces, compute displacement vectors for each bond and evaluate harmonic forces and energies.\n- The reversible RESPA integrator proceeds as derived: for each outer step of size $\\Delta t_{\\text{slow}}$, a slow half-kick updates velocities with $\\mathbf{F}^{\\text{slow}}$, then $m_{\\text{sub}}$ inner fast velocity-Verlet steps of size $\\Delta t_{\\text{fast}}$ update positions and velocities using only $\\mathbf{F}^{\\text{fast}}$, followed by recomputation of $\\mathbf{F}^{\\text{slow}}$ and a final slow half-kick.\n- Stability assessment uses the energy $E(t)$ at each outer step to compute the maximum relative drift\n$$\n\\delta_{\\max} = \\max_{n} \\frac{|E(n\\Delta t_{\\text{slow}}) - E(0)|}{|E(0)|}.\n$$\nA simulation is stable if $\\delta_{\\max} \\le 0.05$.\n\nPrincipled stability reasoning:\n- For a harmonic bond degree of freedom with effective angular frequency $\\omega_{\\text{bond}} \\approx \\sqrt{k_{\\text{b}}/m}$ around equilibrium, the inner fast velocity-Verlet step is linearly stable if $\\Delta t_{\\text{fast}}  \\frac{2}{\\omega_{\\text{max}}}$, where $\\omega_{\\text{max}}$ is the largest relevant frequency. With $k_{\\text{b}} = 1000$ and $m = 1$, $\\omega_{\\text{bond}} \\approx \\sqrt{1000} \\approx 31.62$, implying a necessary condition $\\Delta t_{\\text{fast}} \\lesssim \\frac{2}{31.62} \\approx 0.063$. The test suite includes cases that keep $\\Delta t_{\\text{fast}}$ safely below this bound (happy paths), near the bound (boundary cases), and above it (unstable).\n- Additionally, multiple time step integrators may exhibit resonance instabilities when $\\Delta t_{\\text{slow}}$ commensurates with fast vibrational periods. The symmetric RESPA construction mitigates but does not eliminate such resonances; the test suite explores larger $\\Delta t_{\\text{slow}}$ values at fixed $\\Delta t_{\\text{fast}}$ to probe this effect.\n\nProgram output:\n- For each case A–F with parameters $\\left(\\Delta t_{\\text{slow}}, m_{\\text{sub}}, N_{\\text{steps}}\\right)$ equal to $\\left(0.01, 1, 2000\\right)$, $\\left(0.02, 1, 2000\\right)$, $\\left(0.04, 2, 2000\\right)$, $\\left(0.08, 2, 2000\\right)$, $\\left(0.06, 1, 2000\\right)$, and $\\left(0.10, 1, 2000\\right)$, the program computes $\\delta_{\\max}$ and reports a boolean indicating stability under the criterion $\\delta_{\\max} \\le 0.05$.\n- The final output is a single line containing a list $[b_A,b_B,b_C,b_D,b_E,b_F]$ where each $b_\\cdot$ is either $\\text{True}$ or $\\text{False}$, with no units.\n\nThis design integrates the foundational principles (Hamiltonian dynamics and operator splitting) with implementable algorithms (force computations under periodic boundary conditions and a symmetric reversible RESPA scheme) to test stability across multiple time scales in a polymer melt model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_system(N_chains=3, chain_len=9, rho=0.7, kbond=1000.0, b0=0.96, eps=1.0, sigma=1.0):\n    \"\"\"\n    Construct initial positions on a 3x3x3 grid and linear chains by consecutive indices.\n    Returns positions (N,3), velocities (N,3), box length L, bonds list (M,2), parameters dict.\n    \"\"\"\n    N = N_chains * chain_len\n    assert N == 27, \"This initializer assumes a 3x3x3 grid (N=27).\"\n    L = (N / rho) ** (1.0 / 3.0)\n    # Grid positions centered within each cell\n    grid_pts = []\n    ngrid = 3\n    cell = L / ngrid\n    for ix in range(ngrid):\n        for iy in range(ngrid):\n            for iz in range(ngrid):\n                grid_pts.append([(ix + 0.5) * cell, (iy + 0.5) * cell, (iz + 0.5) * cell])\n    R = np.array(grid_pts[:N], dtype=np.float64)\n    # Velocities: Maxwell-Boltzmann at T0, remove COM velocity\n    T0 = 0.1\n    mass = 1.0\n    v_std = np.sqrt(T0 / mass)\n    rng = np.random.default_rng(seed=12345)\n    V = rng.normal(0.0, v_std, size=(N, 3))\n    V -= V.mean(axis=0, keepdims=True)\n\n    # Bonds: consecutive indices per chain\n    bonds = []\n    for c in range(N_chains):\n        start = c * chain_len\n        for i in range(chain_len - 1):\n            bonds.append((start + i, start + i + 1))\n    bonds = np.array(bonds, dtype=np.int64)\n\n    params = {\n        \"N\": N,\n        \"L\": L,\n        \"rho\": rho,\n        \"mass\": mass,\n        \"kbond\": kbond,\n        \"b0\": b0,\n        \"eps\": eps,\n        \"sigma\": sigma,\n        \"rc\": 2 ** (1.0 / 6.0) * sigma,\n        \"T0\": T0,\n        \"ngr\": ngrid,\n    }\n    return R, V, L, bonds, params\n\ndef minimum_image(dr, L):\n    # Apply minimum image convention to displacement vectors\n    return dr - L * np.round(dr / L)\n\ndef bonded_forces_energy(R, bonds, L, kbond, b0):\n    \"\"\"\n    Compute harmonic bonded forces and energy.\n    R: (N,3) positions, bonds: (M,2) index pairs\n    Returns Fb: (N,3), Ub: float\n    \"\"\"\n    N = R.shape[0]\n    Fb = np.zeros_like(R)\n    if bonds.shape[0] == 0:\n        return Fb, 0.0\n    i = bonds[:, 0]\n    j = bonds[:, 1]\n    rij = minimum_image(R[i] - R[j], L)\n    r = np.linalg.norm(rij, axis=1)\n    # Avoid division by zero\n    r_safe = np.where(r  1e-12, r, 1e-12)\n    # Force on i due to j\n    coeff = -kbond * (1.0 - b0 / r_safe)\n    fij = (coeff[:, None]) * rij  # shape (M,3)\n    # Accumulate\n    np.add.at(Fb, i, fij)\n    np.add.at(Fb, j, -fij)\n    # Energy\n    Ub = 0.5 * kbond * np.sum((r - b0) ** 2)\n    return Fb, Ub\n\ndef wca_forces_energy(R, L, eps, sigma, rc, bonded_pairs_mask):\n    \"\"\"\n    Compute WCA nonbonded forces and energy using vectorized pair operations.\n    bonded_pairs_mask: (N,N) boolean matrix True for bonded pairs to exclude\n    Returns Fnb: (N,3), Unb: float\n    \"\"\"\n    N = R.shape[0]\n    F = np.zeros_like(R)\n    # Pairwise displacements\n    dR = R[:, None, :] - R[None, :, :]\n    dR = minimum_image(dR, L)\n    r2 = np.einsum('ijk,ijk-ij', dR, dR)\n    # Masks\n    iu = np.triu_indices(N, k=1)\n    mask = np.ones((N, N), dtype=bool)\n    mask[~np.triu(np.ones((N, N), dtype=bool), k=1)] = False  # ensure upper triangle only\n    mask = (~bonded_pairs_mask)\n    mask = (r2 = rc * rc)\n    # Selected pairs\n    I, J = np.where(mask)\n    if I.size == 0:\n        return F, 0.0\n    rij = dR[I, J, :]\n    r2_sel = r2[I, J]\n    r_sel = np.sqrt(r2_sel)\n    inv_r = 1.0 / np.where(r_sel  1e-12, r_sel, 1e-12)\n    sr = sigma * inv_r\n    sr6 = sr ** 6\n    sr12 = sr6 ** 2\n    # Force vector contribution: 24*eps*(2*sr12 - sr6) * (rij / r^2)\n    fcoef = 24.0 * eps * (2.0 * sr12 - sr6) / r2_sel\n    fij = (fcoef[:, None]) * rij\n    # Accumulate forces\n    np.add.at(F, I, fij)\n    np.add.at(F, J, -fij)\n    # Energy per pair: 4*eps*(sr12 - sr6) + eps\n    U_pairs = 4.0 * eps * (sr12 - sr6) + eps\n    U = np.sum(U_pairs)\n    return F, U\n\ndef kinetic_energy(V, mass):\n    return 0.5 * mass * np.sum(V * V)\n\ndef total_energy(R, V, L, bonds, params, bonded_pairs_mask):\n    Fb, Ub = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n    Fn, Un = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_pairs_mask)\n    Ek = kinetic_energy(V, params[\"mass\"])\n    return Ek + Ub + Un\n\ndef build_bonded_mask(N, bonds):\n    mask = np.zeros((N, N), dtype=bool)\n    for i, j in bonds:\n        mask[i, j] = True\n        mask[j, i] = True\n    return mask\n\ndef respa_simulation(dt_slow, m_sub, n_steps, stability_threshold=0.05):\n    # System\n    R, V, L, bonds, params = make_system()\n    N = params[\"N\"]\n    mass = params[\"mass\"]\n    # Precompute bonded adjacency mask\n    bonded_mask = build_bonded_mask(N, bonds)\n    # Initial slow force\n    F_slow, _ = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_mask)\n    # Energy initial\n    E0 = total_energy(R, V, L, bonds, params, bonded_mask)\n    if not np.isfinite(E0) or E0 == 0.0:\n        return False, np.inf  # safeguard\n    max_rel_drift = 0.0\n    dt_fast = dt_slow / float(m_sub)\n\n    # Run outer steps\n    for step in range(n_steps):\n        # Slow half-kick\n        V += 0.5 * dt_slow * F_slow / mass\n        # Inner fast steps\n        for _ in range(m_sub):\n            F_fast, _ = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n            V += 0.5 * dt_fast * F_fast / mass\n            # Drift with PBC\n            R += dt_fast * V\n            R %= L  # wrap into box\n            F_fast, _ = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n            V += 0.5 * dt_fast * F_fast / mass\n        # Slow half-kick\n        F_slow, _ = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_mask)\n        V += 0.5 * dt_slow * F_slow / mass\n\n        # Energy monitoring\n        E = total_energy(R, V, L, bonds, params, bonded_mask)\n        if not np.isfinite(E):\n            max_rel_drift = np.inf\n            break\n        rel_drift = abs(E - E0) / abs(E0)\n        if rel_drift  max_rel_drift:\n            max_rel_drift = rel_drift\n\n    stable = (max_rel_drift = stability_threshold)\n    return stable, max_rel_drift\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Delta t_slow, m_sub, N_steps)\n    test_cases = [\n        (0.01, 1, 2000),  # Case A\n        (0.02, 1, 2000),  # Case B\n        (0.04, 2, 2000),  # Case C\n        (0.08, 2, 2000),  # Case D\n        (0.06, 1, 2000),  # Case E (near stability limit)\n        (0.10, 1, 2000),  # Case F (expected unstable)\n    ]\n\n    results = []\n    # Run each case and append only the stability boolean as required\n    for dt_slow, m_sub, n_steps in test_cases:\n        stable, _ = respa_simulation(dt_slow, m_sub, n_steps, stability_threshold=0.05)\n        results.append(stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2909650"}, {"introduction": "After running a simulation and collecting data, a critical task is to quantify the statistical uncertainty of the calculated averages. Data points from a simulation are not independent; they are temporally correlated, and ignoring this fact leads to a severe underestimation of the true statistical error. This practice introduces the blocking method, a robust and widely used technique to analyze correlated time-series data and obtain reliable error estimates for your simulation results [@problem_id:2909657].", "problem": "In a Molecular Dynamics (MD) or Markov chain Monte Carlo (MCMC) simulation of a polymer melt, suppose you record a stationary, ergodic time series $\\{X_t\\}_{t=1}^N$ of a scalar observable (for example, pressure or end-to-end distance) at uniform sampling interval $\\Delta t$. Let the process have mean $\\mu$, variance $\\sigma^2 = \\gamma(0)$, and autocovariance function $\\gamma(k) = \\mathrm{Cov}(X_t, X_{t+k})$ with autocorrelation $\\rho(k) = \\gamma(k)/\\gamma(0)$. You wish to estimate the standard error of the sample mean $\\bar X = \\frac{1}{N}\\sum_{t=1}^N X_t$ despite temporal correlations.\n\nYou apply the blocking (batch means) method: partition the trajectory into $m$ contiguous, nonoverlapping blocks of equal length $b$ such that $N = m b$, define block means $Y_j = \\frac{1}{b}\\sum_{t=(j-1)b+1}^{j b} X_t$ for $j=1,\\dots,m$, compute the sample variance across blocks $s_Y^2 = \\frac{1}{m-1}\\sum_{j=1}^m (Y_j - \\bar Y)^2$ with $\\bar Y = \\frac{1}{m}\\sum_{j=1}^m Y_j = \\bar X$, and take the batch-means variance estimator of $\\bar X$ as $\\widehat{\\mathrm{Var}}(\\bar X) = s_Y^2/m$.\n\nStarting only from the definitions of variance and covariance, and the stationarity of $\\{X_t\\}$, derive the exact expression for $\\mathrm{Var}(Y_j)$ in terms of $\\gamma(k)$ and $b$, and show how this implies the asymptotic behavior of $\\mathbb{E}[s_Y^2/m]$ as $b$ increases while $N$ is large. In particular, use the integrated autocorrelation time $\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^\\infty \\rho(k)$ whenever the sums are absolutely convergent.\n\nWhich option best characterizes the large-$b$ behavior of the batch-means variance estimator and its convergence?\n\nA. For large $b$ under absolute summability of $\\sum_{k=0}^\\infty |\\rho(k)|$ and $\\sum_{k=1}^\\infty k\\,|\\rho(k)|$, one has $\\mathbb{E}[s_Y^2] = \\frac{1}{b}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right) + \\mathcal{O}\\!\\left(\\frac{1}{b^2}\\right)$, hence $\\mathbb{E}[s_Y^2/m] \\to \\frac{1}{N}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$ as $b\\to\\infty$ with $m\\to\\infty$ and $N=mb$, the bias of $b\\,s_Y^2$ as an estimator of $\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$ decays like $\\mathcal{O}\\!\\left(\\frac{1}{b}\\right)$, and $\\mathrm{Var}(s_Y^2)$ scales like $\\mathcal{O}\\!\\left(\\frac{1}{m}\\right)$.\n\nB. For large $b$, $\\mathbb{E}[s_Y^2] \\sim \\frac{\\sigma^2}{b^2}$ so that $\\mathbb{E}[s_Y^2/m] \\sim \\frac{\\sigma^2}{N b} \\to 0$, implying that blocking systematically underestimates $\\mathrm{Var}(\\bar X)$ as $b$ grows.\n\nC. Once $b$ exceeds the integrated autocorrelation time $\\tau_{\\mathrm{int}}$, the block means $Y_j$ are exactly independent, and therefore $s_Y^2/m$ equals the exact $\\mathrm{Var}(\\bar X)$ for any $m \\ge 2$.\n\nD. The expected value $\\mathbb{E}[s_Y^2/m]$ increases linearly with $b$ for large $b$ because averaging within blocks damps within-block correlations and amplifies between-block variability, so that $\\mathbb{E}[s_Y^2/m] \\propto b/N$.", "solution": "The problem statement is a valid and standard formulation of an issue in the statistical analysis of correlated time series data from computational physics simulations. It is scientifically grounded, well-posed, and objective. I will proceed with the derivation.\n\nThe task is to derive the variance of a block mean, $\\mathrm{Var}(Y_j)$, and then analyze the properties of the batch-means variance estimator, $\\widehat{\\mathrm{Var}}(\\bar X) = s_Y^2/m$.\n\n**Part 1: Derivation of $\\mathrm{Var}(Y_j)$**\n\nBy definition, a block mean is $Y_j = \\frac{1}{b}\\sum_{t=(j-1)b+1}^{j b} X_t$. The process $\\{X_t\\}$ is stationary, which implies that $\\mathrm{Var}(Y_j)$ is independent of the block index $j$. We can therefore compute $\\mathrm{Var}(Y_1)$ without loss of generality.\n$$ Y_1 = \\frac{1}{b}\\sum_{t=1}^b X_t $$\nThe variance of $Y_1$ is given by:\n$$ \\mathrm{Var}(Y_1) = \\mathrm{Var}\\left(\\frac{1}{b}\\sum_{t=1}^b X_t\\right) = \\frac{1}{b^2} \\mathrm{Var}\\left(\\sum_{t=1}^b X_t\\right) $$\nThe variance of a sum of correlated random variables is the sum of all elements in their covariance matrix:\n$$ \\mathrm{Var}\\left(\\sum_{t=1}^b X_t\\right) = \\sum_{t=1}^b \\sum_{s=1}^b \\mathrm{Cov}(X_t, X_s) $$\nDue to stationarity, the covariance depends only on the time lag, $\\mathrm{Cov}(X_t, X_s) = \\gamma(s-t)$.\n$$ \\mathrm{Var}(Y_1) = \\frac{1}{b^2} \\sum_{t=1}^b \\sum_{s=1}^b \\gamma(s-t) $$\nWe can re-index this double summation by the lag $k = s-t$. The lag $k$ ranges from $-(b-1)$ to $b-1$. For a given lag $k$, the number of pairs $(t, s)$ in the sum such that $1 \\le t, s \\le b$ and $s-t=k$ is $b - |k|$.\n$$ \\sum_{t=1}^b \\sum_{s=1}^b \\gamma(s-t) = \\sum_{k=-(b-1)}^{b-1} (b-|k|)\\gamma(k) $$\nSince the autocovariance function is even, $\\gamma(k) = \\gamma(-k)$, we can split the sum:\n$$ \\sum_{k=-(b-1)}^{b-1} (b-|k|)\\gamma(k) = (b-0)\\gamma(0) + \\sum_{k=1}^{b-1} (b-k)\\gamma(k) + \\sum_{k=-(b-1)}^{-1} (b-|k|)\\gamma(k) $$\n$$ = b\\gamma(0) + 2\\sum_{k=1}^{b-1} (b-k)\\gamma(k) $$\nSubstituting this back into the expression for $\\mathrm{Var}(Y_1)$:\n$$ \\mathrm{Var}(Y_j) = \\frac{1}{b^2} \\left[ b\\gamma(0) + 2\\sum_{k=1}^{b-1} (b-k)\\gamma(k) \\right] $$\nFactoring out $\\gamma(0) = \\sigma^2$ and $b$, and using the definition of the autocorrelation function $\\rho(k) = \\gamma(k)/\\gamma(0)$:\n$$ \\mathrm{Var}(Y_j) = \\frac{\\sigma^2}{b} \\left[ 1 + 2\\sum_{k=1}^{b-1} \\left(1 - \\frac{k}{b}\\right)\\rho(k) \\right] $$\nThis is the exact expression for the variance of a block mean.\n\n**Part 2: Asymptotic Behavior for Large Block Size $b$**\n\nWe now analyze the behavior of $\\mathrm{Var}(Y_j)$ as $b \\to \\infty$. The expression is:\n$$ b\\,\\mathrm{Var}(Y_j) = \\sigma^2 \\left[ 1 + 2\\sum_{k=1}^{b-1} \\rho(k) - \\frac{2}{b}\\sum_{k=1}^{b-1} k\\rho(k) \\right] $$\nThe problem states that the sums $\\sum_{k=0}^\\infty |\\rho(k)|$ and $\\sum_{k=1}^\\infty k\\,|\\rho(k)|$ are absolutely convergent. This allows us to take the limit $b \\to \\infty$.\nLet $S_\\rho = \\sum_{k=1}^{\\infty} \\rho(k)$ and $S_{k\\rho} = \\sum_{k=1}^{\\infty} k\\rho(k)$. As $b \\to \\infty$:\n$$ \\sum_{k=1}^{b-1} \\rho(k) \\to S_\\rho $$\n$$ \\sum_{k=1}^{b-1} k\\rho(k) \\to S_{k\\rho} $$\nThe integrated autocorrelation time is defined as $\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^\\infty \\rho(k) = \\frac{1}{2} + S_\\rho$. Therefore, $2S_\\rho = 2\\tau_{\\mathrm{int}} - 1$.\nTaking the limit of $b\\,\\mathrm{Var}(Y_j)$:\n$$ \\lim_{b\\to\\infty} b\\,\\mathrm{Var}(Y_j) = \\sigma^2 \\left[ 1 + 2S_\\rho - \\lim_{b\\to\\infty}\\frac{2S_{k\\rho}}{b} \\right] = \\sigma^2(1 + 2\\tau_{\\mathrm{int}} - 1) = \\sigma^2(2\\tau_{\\mathrm{int}}) $$\nFor large but finite $b$, we have:\n$$ b\\,\\mathrm{Var}(Y_j) \\approx \\sigma^2 \\left[ (1+2S_\\rho) - \\frac{2S_{k\\rho}}{b} \\right] = \\sigma^2(2\\tau_{\\mathrm{int}}) - \\frac{2\\sigma^2 S_{k\\rho}}{b} $$\nSo, $b\\,\\mathrm{Var}(Y_j) = \\sigma^2(2\\tau_{\\mathrm{int}}) + \\mathcal{O}(1/b)$. This implies:\n$$ \\mathrm{Var}(Y_j) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} + \\mathcal{O}\\left(\\frac{1}{b^2}\\right) $$\n\n**Part 3: Analysis of the Batch-Means Estimator**\n\nThe batch-means variance estimator of the mean $\\bar{X}$ is $\\widehat{\\mathrm{Var}}(\\bar X) = s_Y^2/m$. We are interested in its expectation, $\\mathbb{E}[s_Y^2/m]$.\nThe sample variance of the block means is $s_Y^2 = \\frac{1}{m-1}\\sum_{j=1}^m(Y_j - \\bar Y)^2$.\nThe expected value is $\\mathbb{E}[s_Y^2] = \\mathrm{Var}(Y_j) - \\frac{2}{m-1}\\sum_{p=1}^{m-1} (m-p)\\mathrm{Cov}(Y_j, Y_{j+p})$.\nFor large block size $b$, the block means $Y_j$ and $Y_{j+p}$ become increasingly uncorrelated, as $\\mathrm{Cov}(Y_j, Y_{j+p})$ involves correlations $\\gamma(k)$ for large lags $k \\ge (p-1)b+1$. Since $\\sum |\\gamma(k)|$ converges, these covariance terms vanish as $b \\to \\infty$. Thus, for large $b$, the correction term is small and $\\mathbb{E}[s_Y^2] \\approx \\mathrm{Var}(Y_j)$.\nTherefore, for large $b$:\n$$ \\mathbb{E}[s_Y^2] \\approx \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} + \\mathcal{O}\\left(\\frac{1}{b^2}\\right) $$\nThe expectation of the estimator for $\\mathrm{Var}(\\bar X)$ is:\n$$ \\mathbb{E}[\\widehat{\\mathrm{Var}}(\\bar X)] = \\mathbb{E}[s_Y^2/m] \\approx \\frac{1}{m} \\left( \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} \\right) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{mb} = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{N} $$\nThe true variance of the sample mean $\\bar X$ for large $N$ is $\\mathrm{Var}(\\bar X) \\approx \\frac{\\sigma^2}{N}(1 + 2\\sum_{k=1}^\\infty \\rho(k)) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{N}$. Thus, the batch means estimator is asymptotically unbiased.\n\n**Evaluation of Options**\n\nA. For large $b$ under absolute summability of $\\sum_{k=0}^\\infty |\\rho(k)|$ and $\\sum_{k=1}^\\infty k\\,|\\rho(k)|$, one has $\\mathbb{E}[s_Y^2] = \\frac{1}{b}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right) + \\mathcal{O}\\!\\left(\\frac{1}{b^2}\\right)$, hence $\\mathbb{E}[s_Y^2/m] \\to \\frac{1}{N}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$ as $b\\to\\infty$ with $m\\to\\infty$ and $N=mb$, the bias of $b\\,s_Y^2$ as an estimator of $\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$ decays like $\\mathcal{O}\\!\\left(\\frac{1}{b}\\right)$, and $\\mathrm{Var}(s_Y^2)$ scales like $\\mathcal{O}\\!\\left(\\frac{1}{m}\\right)$.\n- **Analysis**:\n    - $\\mathbb{E}[s_Y^2] \\approx \\mathrm{Var}(Y_j) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} + \\mathcal{O}(1/b^2)$. This is correct.\n    - $\\mathbb{E}[s_Y^2/m] = \\frac{1}{m} \\mathbb{E}[s_Y^2] \\approx \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{mb} = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{N}$. In the limit, this matches the true variance of the mean. This is correct.\n    - Bias of $b\\,s_Y^2$: $\\mathbb{E}[b\\,s_Y^2] - \\sigma^2(2\\tau_{\\mathrm{int}}) \\approx b\\,\\mathrm{Var}(Y_j) - \\sigma^2(2\\tau_{\\mathrm{int}})$. From our derivation, this bias is $\\approx -\\frac{2\\sigma^2 S_{k\\rho}}{b}$, which is $\\mathcal{O}(1/b)$. This is correct.\n    - Variance of the estimator $s_Y^2$: For large $b$, the block means $Y_j$ are approximately independent. $s_Y^2$ is the sample variance of $m$ such variables. The variance of a sample variance scales as $1/(m-1)$. So, $\\mathrm{Var}(s_Y^2) \\sim \\mathcal{O}(1/m)$. This is correct.\n- **Verdict**: **Correct**.\n\nB. For large $b$, $\\mathbb{E}[s_Y^2] \\sim \\frac{\\sigma^2}{b^2}$ so that $\\mathbb{E}[s_Y^2/m] \\sim \\frac{\\sigma^2}{N b} \\to 0$, implying that blocking systematically underestimates $\\mathrm{Var}(\\bar X)$ as $b$ grows.\n- **Analysis**: The leading term of $\\mathbb{E}[s_Y^2]$ scales as $1/b$, not $1/b^2$. The derivation proves this. The conclusion that the estimator systematically underestimates the variance to zero is incorrect; it is asymptotically unbiased.\n- **Verdict**: **Incorrect**.\n\nC. Once $b$ exceeds the integrated autocorrelation time $\\tau_{\\mathrm{int}}$, the block means $Y_j$ are exactly independent, and therefore $s_Y^2/m$ equals the exact $\\mathrm{Var}(\\bar X)$ for any $m \\ge 2$.\n- **Analysis**: This statement contains two fundamental errors. First, block means are never exactly independent for a process with an autocorrelation function that does not have finite support. The value $\\tau_{\\mathrm{int}}$ is an effective time scale, not a sharp cutoff. Second, $s_Y^2/m$ is a statistical estimator, a random variable. It fluctuates around its mean and is not equal to the true parameter $\\mathrm{Var}(\\bar X)$.\n- **Verdict**: **Incorrect**.\n\nD. The expected value $\\mathbb{E}[s_Y^2/m]$ increases linearly with $b$ for large $b$ because averaging within blocks damps within-block correlations and amplifies between-block variability, so that $\\mathbb{E}[s_Y^2/m] \\propto b/N$.\n- **Analysis**: For fixed total data size $N$, our derivation shows that $\\mathbb{E}[s_Y^2/m] \\approx \\sigma^2(2\\tau_{\\mathrm{int}})/N$, which is asymptotically constant as a function of $b$. It does not increase linearly with $b$. While $\\mathbb{E}[b s_Y^2]$ as a function of $b$ increases and then plateaus, $\\mathbb{E}[s_Y^2/m] = \\mathbb{E}[b s_Y^2] / N$ also plateaus. The linear growth claim is incorrect. The reasoning about amplifying variability is also spurious.\n- **Verdict**: **Incorrect**.\n\nIn conclusion, Option A provides a comprehensive and accurate summary of the asymptotic properties of the batch means method.", "answer": "$$\\boxed{A}$$", "id": "2909657"}]}