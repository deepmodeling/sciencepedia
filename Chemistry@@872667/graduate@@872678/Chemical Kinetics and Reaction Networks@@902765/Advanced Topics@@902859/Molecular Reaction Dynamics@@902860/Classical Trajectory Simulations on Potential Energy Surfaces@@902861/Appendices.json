{"hands_on_practices": [{"introduction": "Before simulating the dynamics of a chemical reaction, it is essential to first understand the landscape on which the reaction occurs: the potential energy surface (PES). The key features of this landscape are its stationary points—minima corresponding to stable molecules and saddle points corresponding to transition states. This exercise [@problem_id:2632278] guides you through the implementation of the Newton-Raphson method, a powerful algorithm for locating these critical points. By using the gradient and Hessian of the potential, you will not only find stationary points but also classify them by their index, a fundamental skill for identifying reaction bottlenecks.", "problem": "Consider a two-degree-of-freedom Potential Energy Surface (PES) defined by a twice continuously differentiable scalar potential function $V(q_1,q_2)$, where $q_1$ and $q_2$ are dimensionless generalized coordinates. In classical trajectory simulations on potential energy surfaces, the local structure of $V$ near stationary points (solutions of $\\nabla V = \\mathbf{0}$) governs reactive bottlenecks via the transition state, which is an index-$1$ saddle point. Your task is to implement a Newton–Raphson stationary-point search that uses the analytic gradient and Hessian of $V$, and then verify the stationary-point index by counting the number of negative eigenvalues of the Hessian at the converged point. Work entirely in mathematical terms with no external input.\n\nFundamental base to be used: Start from the Taylor expansion of the gradient and the condition for stationarity $\\nabla V(\\mathbf{q}^\\star) = \\mathbf{0}$. Do not assume any particular pre-derived update formula; implement the Newton–Raphson step by deriving it from first principles using the linearization of $\\nabla V$ about the current iterate. Because stationary points need not be minima, use step control that is consistent with convergence to stationary points (for example, by decreasing the norm of the gradient).\n\nImplement the following requirements:\n\n- Variables and operators:\n  - Let $\\mathbf{q} = (q_1,q_2)^\\top$.\n  - Let $\\mathbf{g}(\\mathbf{q}) = \\nabla V(\\mathbf{q}) \\in \\mathbb{R}^2$ be the gradient.\n  - Let $\\mathbf{H}(\\mathbf{q}) = \\nabla^2 V(\\mathbf{q}) \\in \\mathbb{R}^{2 \\times 2}$ be the Hessian.\n  - Use a convergence tolerance $\\varepsilon_{\\text{grad}} = 10^{-10}$ on the Euclidean norm $\\|\\mathbf{g}(\\mathbf{q})\\|_2$, a maximum of $N_{\\max} = 50$ iterations, and a line-search backtracking factor of $\\beta = \\tfrac{1}{2}$ if a full step fails to reduce $\\|\\mathbf{g}(\\mathbf{q})\\|_2$. If the Hessian is ill-conditioned or singular, regularize it by adding $\\mu \\mathbf{I}$ with $\\mu > 0$ chosen adaptively until a step can be computed.\n  - Determine the stationary-point index as the integer count of negative eigenvalues of $\\mathbf{H}(\\mathbf{q}^\\star)$ using an eigenvalue threshold $\\varepsilon_{\\lambda} = 10^{-8}$; that is, count eigenvalues $\\lambda$ with $\\lambda < -\\varepsilon_{\\lambda}$ as negative.\n- Units:\n  - The coordinates $q_1,q_2$ and energy $V$ are dimensionless. Report energies in the same arbitrary energy units as defined by $V$.\n- Output specification:\n  - For each test case, return a list $[q_1^\\star, q_2^\\star, \\text{index}, V^\\star]$ where $q_1^\\star$ and $q_2^\\star$ are the converged coordinates, $\\text{index}$ is an integer, and $V^\\star = V(q_1^\\star,q_2^\\star)$. Round $q_1^\\star$, $q_2^\\star$, and $V^\\star$ to $6$ decimal places.\n  - Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets; for example, $[r_1,r_2,r_3,\\ldots]$, where each $r_k$ is the list for test case $k$ as specified above.\n\nTest suite:\n\nImplement the Newton–Raphson search for the four analytic potentials below. For each potential, use the provided gradient $\\mathbf{g}$, Hessian $\\mathbf{H}$, and initial guess $\\mathbf{q}^{(0)}$, and produce a result $[q_1^\\star, q_2^\\star, \\text{index}, V^\\star]$.\n\n- Test case $1$ (indefinite quadratic with coupling, index-$1$ saddle):\n  - $V_1(q_1,q_2) = \\tfrac{1}{2}\\left(2 q_1^2 - 1\\cdot q_2^2\\right) + 0.3\\, q_1 q_2$.\n  - $\\mathbf{g}_1(q_1,q_2) = \\begin{bmatrix} 2 q_1 + 0.3 q_2 \\\\ - q_2 + 0.3 q_1 \\end{bmatrix}$.\n  - $\\mathbf{H}_1(q_1,q_2) = \\begin{bmatrix} 2 & 0.3 \\\\ 0.3 & -1 \\end{bmatrix}$.\n  - Initial guess $\\mathbf{q}^{(0)} = (1.0, 1.0)^\\top$.\n- Test case $2$ (quartic-confined maximum, index-$2$):\n  - $V_2(q_1,q_2) = -\\left(q_1^2 + 2 q_2^2\\right) + \\tfrac{1}{4}\\left(q_1^4 + q_2^4\\right)$.\n  - $\\mathbf{g}_2(q_1,q_2) = \\begin{bmatrix} -2 q_1 + q_1^3 \\\\ -4 q_2 + q_2^3 \\end{bmatrix}$.\n  - $\\mathbf{H}_2(q_1,q_2) = \\begin{bmatrix} -2 + 3 q_1^2 & 0 \\\\ 0 & -4 + 3 q_2^2 \\end{bmatrix}$.\n  - Initial guess $\\mathbf{q}^{(0)} = (0.2, -0.1)^\\top$.\n- Test case $3$ (double-well along $q_1$ crossed with harmonic $q_2$, index-$1$ saddle at the origin):\n  - $V_3(q_1,q_2) = \\left(q_1^2 - 1\\right)^2 + \\tfrac{1}{2} q_2^2$.\n  - $\\mathbf{g}_3(q_1,q_2) = \\begin{bmatrix} 4 q_1 \\left(q_1^2 - 1\\right) \\\\ q_2 \\end{bmatrix}$.\n  - $\\mathbf{H}_3(q_1,q_2) = \\begin{bmatrix} 12 q_1^2 - 4 & 0 \\\\ 0 & 1 \\end{bmatrix}$.\n  - Initial guess $\\mathbf{q}^{(0)} = (0.3, 0.4)^\\top$.\n- Test case $4$ (positive-definite quadratic with coupling, index-$0$ minimum):\n  - $V_4(q_1,q_2) = \\tfrac{1}{2}\\left(q_1^2 + q_2^2\\right) + 0.1\\, q_1 q_2$.\n  - $\\mathbf{g}_4(q_1,q_2) = \\begin{bmatrix} q_1 + 0.1 q_2 \\\\ q_2 + 0.1 q_1 \\end{bmatrix}$.\n  - $\\mathbf{H}_4(q_1,q_2) = \\begin{bmatrix} 1 & 0.1 \\\\ 0.1 & 1 \\end{bmatrix}$.\n  - Initial guess $\\mathbf{q}^{(0)} = (2.0, -1.0)^\\top$.\n\nAlgorithmic requirements:\n\n- Implement a Newton–Raphson iteration derived from linearizing $\\mathbf{g}(\\mathbf{q})$ about the current iterate to compute a trial step. If the Hessian is not solvable or is ill-conditioned, regularize it by adding $\\mu \\mathbf{I}$ with $\\mu$ increased as needed until a step can be obtained.\n- Use backtracking on the step length $\\alpha \\in (0,1]$ to ensure a decrease in $\\|\\mathbf{g}(\\mathbf{q})\\|_2$; for example, if $\\|\\mathbf{g}(\\mathbf{q} + \\alpha \\mathbf{s})\\|_2 \\ge \\|\\mathbf{g}(\\mathbf{q})\\|_2$, reduce $\\alpha \\leftarrow \\beta \\alpha$ with $\\beta = \\tfrac{1}{2}$, up to a reasonable minimum step length.\n- Stop when either $\\|\\mathbf{g}(\\mathbf{q})\\|_2 \\le \\varepsilon_{\\text{grad}}$, or the number of iterations reaches $N_{\\max}$, or the step length becomes too small to make progress.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a Python-style list of four lists, one per test case, each inner list in the order $[q_1^\\star, q_2^\\star, \\text{index}, V^\\star]$ with $q_1^\\star$, $q_2^\\star$, and $V^\\star$ rounded to $6$ decimals, and $\\text{index}$ an integer. For example: $[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$.", "solution": "The problem requires the implementation of a Newton–Raphson algorithm to locate stationary points on a two-dimensional potential energy surface, $V(q_1, q_2)$, and to characterize these points by their index. The foundation of this task lies in numerical optimization and linear algebra.\n\nA stationary point, denoted $\\mathbf{q}^\\star$, of a potential energy function $V(\\mathbf{q})$ is a point where the gradient of the function vanishes. For our two-dimensional system with coordinates $\\mathbf{q} = (q_1, q_2)^\\top$, this condition is expressed as:\n$$\n\\mathbf{g}(\\mathbf{q}^\\star) = \\nabla V(\\mathbf{q}^\\star) = \\begin{bmatrix} \\frac{\\partial V}{\\partial q_1} \\\\ \\frac{\\partial V}{\\partial q_2} \\end{bmatrix}_{\\mathbf{q}=\\mathbf{q}^\\star} = \\mathbf{0}\n$$\nThe Newton–Raphson method is an iterative procedure for finding roots of a system of nonlinear equations. Here, we apply it to find the roots of the gradient vector, $\\mathbf{g}(\\mathbf{q}) = \\mathbf{0}$.\n\nThe derivation begins with a first-order Taylor expansion of the gradient vector $\\mathbf{g}(\\mathbf{q})$ around the current iterate, $\\mathbf{q}^{(k)}$. Let $\\Delta\\mathbf{q} = \\mathbf{q}^{(k+1)} - \\mathbf{q}^{(k)}$ be the step to the next iterate. The gradient at the new point $\\mathbf{q}^{(k+1)}$ is approximated as:\n$$\n\\mathbf{g}(\\mathbf{q}^{(k+1)}) = \\mathbf{g}(\\mathbf{q}^{(k)} + \\Delta\\mathbf{q}) \\approx \\mathbf{g}(\\mathbf{q}^{(k)}) + \\mathbf{H}(\\mathbf{q}^{(k)}) \\Delta\\mathbf{q}\n$$\nwhere $\\mathbf{H}(\\mathbf{q}^{(k)})$ is the Hessian matrix of second partial derivatives of $V$ evaluated at $\\mathbf{q}^{(k)}$:\n$$\n\\mathbf{H}(\\mathbf{q}) = \\nabla^2 V(\\mathbf{q}) = \\begin{bmatrix} \\frac{\\partial^2 V}{\\partial q_1^2} & \\frac{\\partial^2 V}{\\partial q_1 \\partial q_2} \\\\ \\frac{\\partial^2 V}{\\partial q_2 \\partial q_1} & \\frac{\\partial^2 V}{\\partial q_2^2} \\end{bmatrix}\n$$\nTo find the stationary point, we set the gradient at the next iterate to zero, $\\mathbf{g}(\\mathbf{q}^{(k+1)}) = \\mathbf{0}$. This leads to the following linear system for the unknown step $\\Delta\\mathbf{q}$:\n$$\n\\mathbf{g}(\\mathbf{q}^{(k)}) + \\mathbf{H}(\\mathbf{q}^{(k)}) \\Delta\\mathbf{q} = \\mathbf{0}\n$$\nRearranging for $\\Delta\\mathbf{q}$, which we will call the Newton step $\\mathbf{s}^{(k)}$, gives:\n$$\n\\mathbf{H}(\\mathbf{q}^{(k)}) \\mathbf{s}^{(k)} = -\\mathbf{g}(\\mathbf{q}^{(k)})\n$$\nThe step $\\mathbf{s}^{(k)}$ is thus found by solving this system of linear equations. The next iterate is then proposed as $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} + \\mathbf{s}^{(k)}$.\n\nThe complete algorithm is as follows:\n\n1.  **Initialization**: Start with an initial guess $\\mathbf{q}^{(0)}$, a convergence tolerance $\\varepsilon_{\\text{grad}} = 10^{-10}$, a maximum number of iterations $N_{\\max} = 50$, and a backtracking factor $\\beta = \\frac{1}{2}$.\n\n2.  **Iteration**: For $k = 0, 1, 2, \\dots$ until convergence or $k = N_{\\max}$:\n    a.  **Evaluate**: Compute the gradient vector $\\mathbf{g}_k = \\mathbf{g}(\\mathbf{q}^{(k)})$ and the Hessian matrix $\\mathbf{H}_k = \\mathbf{H}(\\mathbf{q}^{(k)})$.\n    b.  **Check for Convergence**: Calculate the Euclidean norm of the gradient, $\\|\\mathbf{g}_k\\|_2$. If $\\|\\mathbf{g}_k\\|_2 \\le \\varepsilon_{\\text{grad}}$, the algorithm has converged. The stationary point is $\\mathbf{q}^\\star = \\mathbf{q}^{(k)}$. Terminate the iteration.\n    c.  **Compute Search Direction**: Solve the Newton system $\\mathbf{H}_k \\mathbf{s}_k = -\\mathbf{g}_k$ for the search direction $\\mathbf{s}_k$.\n        -   **Regularization**: If $\\mathbf{H}_k$ is singular or ill-conditioned, the system cannot be solved reliably. In such cases, the Hessian is regularized by adding a small multiple of the identity matrix, $\\mu\\mathbf{I}$, where $\\mu > 0$. We solve the modified system $(\\mathbf{H}_k + \\mu\\mathbf{I}) \\mathbf{s}_k = -\\mathbf{g}_k$. The value of $\\mu$ is chosen adaptively, starting at $\\mu=0$ and increasing it (e.g., by factors of $10$) until the matrix becomes invertible.\n    d.  **Line Search with Backtracking**: A full Newton step ($\\alpha=1$) may not lead to a reduction in the gradient norm, which is our measure of progress toward a stationary point. We introduce a step length $\\alpha_k \\in (0, 1]$ and update the position as $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} + \\alpha_k \\mathbf{s}_k$. We start with $\\alpha_k=1$ and check if the condition $\\|\\mathbf{g}(\\mathbf{q}^{(k)} + \\alpha_k \\mathbf{s}_k)\\|_2 < \\|\\mathbf{g}_k\\|_2$ is satisfied. If not, we reduce the step length by the backtracking factor, $\\alpha_k \\leftarrow \\beta \\alpha_k$, and repeat the check until the condition is met or $\\alpha_k$ becomes smaller than a minimum threshold, indicating a stall.\n    e.  **Update**: Set the next iterate $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} + \\alpha_k \\mathbf{s}_k$.\n\n3.  **Stationary Point Analysis**: After the algorithm converges to $\\mathbf{q}^\\star$, we analyze its nature. The index of a stationary point is defined as the number of negative eigenvalues of the Hessian matrix evaluated at that point, $\\mathbf{H}^\\star = \\mathbf{H}(\\mathbf{q}^\\star)$.\n    -   We compute the eigenvalues $\\lambda_i$ of the symmetric matrix $\\mathbf{H}^\\star$.\n    -   The index is the count of eigenvalues that are strictly negative, accounting for numerical precision. We count an eigenvalue $\\lambda_i$ as negative if $\\lambda_i < -\\varepsilon_{\\lambda}$, where $\\varepsilon_{\\lambda} = 10^{-8}$.\n    -   An index of $0$ corresponds to a minimum, an index of $2$ (for a $2$D system) to a maximum, and an index of $1$ to an index-$1$ saddle point, commonly known as a transition state.\n\n4.  **Final Output**: For each test case, we report the converged coordinates $[q_1^\\star, q_2^\\star]$, the integer index of the stationary point, and the potential energy $V^\\star = V(\\mathbf{q}^\\star)$ at that point.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the stationary point search\n    for all test cases and prints the final results.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    EPS_GRAD = 1e-10\n    MAX_ITER = 50\n    BETA = 0.5\n    EPS_LAMBDA = 1e-8\n    MIN_ALPHA = 1e-12\n    MU_INIT = 1e-8\n    MU_FACTOR = 10.0\n    \n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            \"V\": lambda q: 0.5 * (2 * q[0]**2 - q[1]**2) + 0.3 * q[0] * q[1],\n            \"g\": lambda q: np.array([2 * q[0] + 0.3 * q[1], -q[1] + 0.3 * q[0]]),\n            \"H\": lambda q: np.array([[2.0, 0.3], [0.3, -1.0]]),\n            \"q0\": np.array([1.0, 1.0]),\n        },\n        {\n            \"V\": lambda q: -(q[0]**2 + 2 * q[1]**2) + 0.25 * (q[0]**4 + q[1]**4),\n            \"g\": lambda q: np.array([-2 * q[0] + q[0]**3, -4 * q[1] + q[1]**3]),\n            \"H\": lambda q: np.array([[-2 + 3 * q[0]**2, 0.0], [0.0, -4 + 3 * q[1]**2]]),\n            \"q0\": np.array([0.2, -0.1]),\n        },\n        {\n            \"V\": lambda q: (q[0]**2 - 1)**2 + 0.5 * q[1]**2,\n            \"g\": lambda q: np.array([4 * q[0] * (q[0]**2 - 1), q[1]]),\n            \"H\": lambda q: np.array([[12 * q[0]**2 - 4, 0.0], [0.0, 1.0]]),\n            \"q0\": np.array([0.3, 0.4]),\n        },\n        {\n            \"V\": lambda q: 0.5 * (q[0]**2 + q[1]**2) + 0.1 * q[0] * q[1],\n            \"g\": lambda q: np.array([q[0] + 0.1 * q[1], q[1] + 0.1 * q[0]]),\n            \"H\": lambda q: np.array([[1.0, 0.1], [0.1, 1.0]]),\n            \"q0\": np.array([2.0, -1.0]),\n        },\n    ]\n\n    def find_stationary_point(V, g, H, q0):\n        \"\"\"\n        Implements the Newton-Raphson algorithm with regularization and backtracking.\n        \"\"\"\n        q = np.copy(q0)\n        \n        for _ in range(MAX_ITER):\n            grad_k = g(q)\n            norm_grad_k = np.linalg.norm(grad_k)\n\n            if norm_grad_k < EPS_GRAD:\n                break\n            \n            H_k = H(q)\n            \n            # --- Solve for Newton step with regularization ---\n            mu = 0.0\n            step = None\n            while step is None:\n                try:\n                    H_reg = H_k + mu * np.identity(2)\n                    step = np.linalg.solve(H_reg, -grad_k)\n                except np.linalg.LinAlgError:\n                    if mu == 0.0:\n                        mu = MU_INIT\n                    else:\n                        mu *= MU_FACTOR\n                    if mu > 1e6:  # Failsafe\n                        return None # Could not find a suitable step\n            \n            # --- Backtracking line search ---\n            alpha = 1.0\n            while alpha > MIN_ALPHA:\n                q_trial = q + alpha * step\n                grad_trial = g(q_trial)\n                if np.linalg.norm(grad_trial) < norm_grad_k:\n                    break\n                alpha *= BETA\n            else: # If alpha became too small, stall\n                break\n            \n            q = q + alpha * step\n\n        # --- Post-convergence analysis ---\n        q_star = q\n        H_star = H(q_star)\n        \n        # Eigenvalues of the real symmetric Hessian\n        eigenvalues = np.linalg.eigvalsh(H_star)\n        \n        # Count negative eigenvalues to find the index\n        index = np.sum(eigenvalues < -EPS_LAMBDA)\n        \n        V_star = V(q_star)\n        \n        return [\n            round(q_star[0], 6), \n            round(q_star[1], 6), \n            int(index), \n            round(V_star, 6)\n        ]\n\n    results = []\n    for case in test_cases:\n        result = find_stationary_point(case[\"V\"], case[\"g\"], case[\"H\"], case[\"q0\"])\n        results.append(result)\n\n    # Format output according to specification\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2632278"}, {"introduction": "Once a transition state is located, Transition State Theory (TST) defines a 'dividing surface' at this bottleneck to estimate reaction rates. A core assumption of TST is that reactive trajectories cross this surface exactly once, without 'recrossing' back to the reactant side. This practice [@problem_id:2632247] allows you to test this fundamental assumption in a dynamic simulation. By comparing the recrossing behavior on a dynamically optimal dividing surface versus a naive geometric one, you will gain a crucial, hands-on intuition for what constitutes a good reaction coordinate and appreciate the dynamic nature of reaction bottlenecks.", "problem": "You will implement and compare two configuration-space dividing surfaces (DS) for a two-degree-of-freedom Hamiltonian model of a barrier-crossing reaction and evaluate dynamical recrossing by counting trajectory crossings in a test ensemble of classical trajectories integrated on a quadratic potential energy surface (PES). The two DS are: (i) a surface orthogonal to the unstable mode at the saddle and (ii) a geometric surface at constant reaction coordinate along a chosen axis. You must derive the algorithm starting from Newton’s laws and Hamilton’s equations of motion.\n\nModel definition:\n- Consider a two-dimensional configuration vector $\\mathbf{q} = (x,y)^{\\mathsf{T}}$ and conjugate momentum $\\mathbf{p} = (p_x,p_y)^{\\mathsf{T}}$, with unit masses so that kinetic energy is $T(\\mathbf{p}) = \\tfrac{1}{2}(p_x^2 + p_y^2)$.\n- The potential energy surface is quadratic with one unstable and one stable mode, constructed by rotating the eigenbasis by an angle $\\theta$ (in radians). Let the rotation matrix be\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\phantom{-}\\cos\\theta\n\\end{pmatrix}.\n$$\n- Let the Hessian in the eigenbasis be $\\mathrm{diag}(-a, b)$ with $a>0$, $b>0$; the Hessian in the laboratory $(x,y)$ frame is then\n$$\n\\mathbf{H} = \\mathbf{R}(\\theta)\\,\\mathrm{diag}(-a, b)\\,\\mathbf{R}(\\theta)^{\\mathsf{T}}.\n$$\n- The potential is $V(\\mathbf{q}) = \\tfrac{1}{2}\\mathbf{q}^{\\mathsf{T}}\\mathbf{H}\\mathbf{q}$, which has a saddle at $\\mathbf{q}=\\mathbf{0}$ with barrier energy $0$ by construction.\n\nEquations of motion and integrator:\n- Hamilton’s equations read $\\dot{\\mathbf{q}} = \\mathbf{p}$ and $\\dot{\\mathbf{p}} = -\\nabla V(\\mathbf{q}) = -\\mathbf{H}\\mathbf{q}$.\n- Integrate trajectories with the velocity-Verlet algorithm with fixed time step $\\Delta t$:\n  1. $\\mathbf{p}_{n+\\tfrac{1}{2}} = \\mathbf{p}_n - \\tfrac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_n$,\n  2. $\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t\\,\\mathbf{p}_{n+\\tfrac{1}{2}}$,\n  3. $\\mathbf{p}_{n+1} = \\mathbf{p}_{n+\\tfrac{1}{2}} - \\tfrac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_{n+1}$.\n\nDividing surfaces to compare:\n- Define the rotation that maps lab-frame coordinates to eigenbasis coordinates by $\\mathbf{c} = (u,v)^{\\mathsf{T}} = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{q}$ and similarly for momenta $\\mathbf{\\pi} = (p_u,p_v)^{\\mathsf{T}} = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{p}$.\n- DS 1 (unstable-mode orthogonal DS): the level set $u=0$; count only forward crossings with $p_u>0$.\n- DS 2 (geometric DS at constant reaction coordinate): the level set $x=0$; count only forward crossings with $p_x>0$.\n- For a perfect no-recrossing DS, each reactive trajectory should have exactly one forward crossing. Define the recrossing count for a single trajectory as $\\max(0, N_+ - 1)$, where $N_+$ is the number of forward crossings. The total recrossing for an ensemble is the sum of these per-trajectory recrossing counts.\n\nInitial ensemble and energy:\n- Work in the eigenbasis to set initial conditions. Fix the initial unstable coordinate at $u(0) = s_0 < 0$ (reactant side) and draw the initial stable coordinate $v(0)$ from a normal distribution with mean $0$ and standard deviation $\\sigma$. Set the initial stable momentum $p_v(0)=0$.\n- Enforce a microcanonical total energy $E>0$ by solving for $p_u(0)>0$ from\n$$\nE = \\tfrac{1}{2}\\left(p_u(0)^2 + p_v(0)^2\\right) + \\tfrac{1}{2}\\left(-a\\,u(0)^2 + b\\,v(0)^2\\right).\n$$\nIf the right-hand side would make $p_u(0)$ imaginary for a sampled $v(0)$, reject that $v(0)$ and resample until feasible.\n- Transform initial conditions back to the lab frame via $\\mathbf{q}(0) = \\mathbf{R}(\\theta)\\,(u(0),v(0))^{\\mathsf{T}}$ and $\\mathbf{p}(0) = \\mathbf{R}(\\theta)\\,(p_u(0),0)^{\\mathsf{T}}$.\n\nTrajectory integration and crossing detection:\n- For each trajectory, integrate up to a maximum time $T_{\\max}$ or until the absolute unstable coordinate magnitude exceeds a cutoff $U_{\\mathrm{cut}}$ (to avoid numerical overflow), whichever occurs first.\n- Detect forward crossings for DS 1 by sign changes of $u$ from $\\le 0$ to $>0$ with $p_u>0$ at the detection time; similarly for DS 2 with $x$ and $p_x$.\n- The total recrossing count for a DS is the sum over the ensemble of $\\max(0,N_+ - 1)$ as defined above.\n\nNumerical units:\n- Use reduced dimensionless units with unit mass. Angles, including $\\theta$, must be in radians. Recrossing counts are unitless integers.\n\nTest suite, parameter coverage, and output format:\n- Implement exactly the following three test cases to probe different geometric alignments:\n  1. Case A (aligned, boundary): $a=2.0$, $b=1.0$, $\\theta=0.0$, $E=0.1$, $N=200$, $\\sigma=0.02$, $s_0=-0.05$, $\\Delta t=0.001$, $T_{\\max}=5.0$, $U_{\\mathrm{cut}}=20.0$.\n  2. Case B (moderate rotation): $a=2.0$, $b=1.0$, $\\theta=\\pi/6$, $E=0.1$, $N=200$, $\\sigma=0.02$, $s_0=-0.05$, $\\Delta t=0.001$, $T_{\\max}=5.0$, $U_{\\mathrm{cut}}=20.0$.\n  3. Case C (strong rotation): $a=2.0$, $b=1.0$, $\\theta=\\pi/3$, $E=0.1$, $N=200$, $\\sigma=0.02$, $s_0=-0.05$, $\\Delta t=0.001$, $T_{\\max}=5.0$, $U_{\\mathrm{cut}}=20.0$.\n- Your program must:\n  - Use a fixed random seed to make results deterministic.\n  - Produce, for each case, a list of two integers $[R_{\\mathrm{unstable}}, R_{\\mathrm{geo}}]$ equal to the total recrossing counts summed over the ensemble for DS 1 and DS 2, respectively.\n  - Print a single line containing a list of these per-case lists, in order, with no extra text. The exact format must be: \n    - $[[R_{\\mathrm{unstable}}^{(A)}, R_{\\mathrm{geo}}^{(A)}],[R_{\\mathrm{unstable}}^{(B)}, R_{\\mathrm{geo}}^{(B)}],[R_{\\mathrm{unstable}}^{(C)}, R_{\\mathrm{geo}}^{(C)}]]$.", "solution": "The problem presented is a well-defined exercise in computational chemical dynamics. It is scientifically sound, self-contained, and algorithmically specified. It addresses the fundamental concept of the dividing surface in reaction rate theory, a cornerstone of chemical kinetics. The comparison between the dynamically correct dividing surface and a naive geometric one is a classic and instructive demonstration. I shall proceed with the derivation and algorithmic design.\n\nThe system is described by a two-dimensional Hamiltonian for a particle of unit mass, $m=1$, moving in a quadratic potential energy surface (PES). The state of the system is given by the phase space vector $(\\mathbf{q}, \\mathbf{p})$, where $\\mathbf{q} = (x,y)^{\\mathsf{T}}$ are the configuration-space coordinates and $\\mathbf{p} = (p_x,p_y)^{\\mathsf{T}}$ are the conjugate momenta. The Hamiltonian $H(\\mathbf{q}, \\mathbf{p})$ is the sum of kinetic and potential energies, $H = T(\\mathbf{p}) + V(\\mathbf{q})$.\n\nThe kinetic energy is $T(\\mathbf{p}) = \\frac{1}{2m}\\mathbf{p}^{\\mathsf{T}}\\mathbf{p} = \\frac{1}{2}(p_x^2 + p_y^2)$, since $m=1$.\nThe potential energy is a quadratic form $V(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^{\\mathsf{T}}\\mathbf{H}\\mathbf{q}$, where $\\mathbf{H}$ is the Hessian matrix of second derivatives of the potential evaluated at the origin $\\mathbf{q}=\\mathbf{0}$. This PES has a saddle point at the origin.\n\nThe Hessian matrix $\\mathbf{H}$ is constructed from its diagonal form in the eigenbasis. Let the eigenvectors of the Hessian define a coordinate system $(u,v)$. The corresponding eigenvalues are $-a$ and $b$, with $a>0$ and $b>0$. The coordinate $u$ corresponds to the unstable mode (the reaction coordinate at the saddle point), and $v$ corresponds to the stable, transverse mode. In this eigenbasis, the Hessian is $\\mathbf{D} = \\mathrm{diag}(-a, b)$.\n\nThe laboratory frame $(x,y)$ is rotated with respect to the eigenbasis $(u,v)$ by an angle $\\theta$. The transformation is given by the rotation matrix $\\mathbf{R}(\\theta)$:\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\nA vector expressed in the eigenbasis, $\\mathbf{c} = (u,v)^{\\mathsf{T}}$, is transformed to the lab frame by $\\mathbf{q} = \\mathbf{R}(\\theta)\\mathbf{c}$. The Hessian in the lab frame is therefore obtained by a similarity transformation:\n$$\n\\mathbf{H} = \\mathbf{R}(\\theta)\\,\\mathbf{D}\\,\\mathbf{R}(\\theta)^{\\mathsf{T}}\n$$\nPerforming the matrix multiplication gives:\n$$\n\\mathbf{H} = \\begin{pmatrix} b\\sin^2\\theta - a\\cos^2\\theta & -(a+b)\\sin\\theta\\cos\\theta \\\\ -(a+b)\\sin\\theta\\cos\\theta & b\\cos^2\\theta - a\\sin^2\\theta \\end{pmatrix}\n$$\nThe dynamics of the system are governed by Hamilton's equations of motion:\n$$\n\\dot{\\mathbf{q}} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p} \\quad (\\text{since } m=1)\n$$\n$$\n\\dot{\\mathbf{p}} = -\\frac{\\partial H}{\\partial \\mathbf{q}} = -\\nabla V(\\mathbf{q}) = -\\mathbf{H}\\mathbf{q}\n$$\nThese coupled first-order ordinary differential equations will be integrated numerically using the specified velocity-Verlet algorithm, which is a second-order, time-reversible, and symplectic method suitable for Hamiltonian systems. For a time step $\\Delta t$, the state $(\\mathbf{q}_{n+1}, \\mathbf{p}_{n+1})$ at time $t_{n+1}$ is computed from the state $(\\mathbf{q}_n, \\mathbf{p}_n)$ at time $t_n$ as follows:\n$$\n\\mathbf{p}_{n+\\frac{1}{2}} = \\mathbf{p}_n - \\frac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_n\n$$\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t\\,\\mathbf{p}_{n+\\frac{1}{2}}\n$$\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+\\frac{1}{2}} - \\frac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_{n+1}\n$$\nThe simulation requires an ensemble of initial conditions generated from a microcanonical distribution at a fixed total energy $E > 0$. We prepare initial states in the eigenbasis for physical clarity. The trajectory starts on the reactant side of the barrier, $u(0) = s_0 < 0$. The initial displacement in the stable mode, $v(0)$, is sampled from a Gaussian distribution $\\mathcal{N}(0, \\sigma^2)$, simulating thermal fluctuations in the bath modes. The initial momentum of the stable mode is set to zero, $p_v(0) = 0$. The initial momentum along the unstable mode, $p_u(0)$, is determined by the total energy conservation equation:\n$$\nE = T + V = \\frac{1}{2}(p_u(0)^2 + p_v(0)^2) + \\frac{1}{2}(-a u(0)^2 + b v(0)^2)\n$$\nSolving for $p_u(0)^2$ yields:\n$$\np_u(0)^2 = 2E - p_v(0)^2 + a u(0)^2 - b v(0)^2 = 2E + a s_0^2 - b v(0)^2\n$$\nFor a physically meaningful initial momentum, $p_u(0)^2$ must be non-negative. If a sampled $v(0)$ violates this, it is discarded, and a new value is drawn. We choose the positive root $p_u(0) = \\sqrt{p_u(0)^2}$ to launch the trajectory towards the barrier.\n\nThe initial phase space vector in the eigenbasis, $(\\mathbf{c}(0), \\mathbf{\\pi}(0))$, where $\\mathbf{c}(0) = (s_0, v(0))^{\\mathsf{T}}$ and $\\mathbf{\\pi}(0) = (p_u(0), 0)^{\\mathsf{T}}$, is then transformed back to the laboratory frame for integration:\n$$\n\\mathbf{q}(0) = \\mathbf{R}(\\theta)\\mathbf{c}(0) \\quad \\text{and} \\quad \\mathbf{p}(0) = \\mathbf{R}(\\theta)\\mathbf{\\pi}(0)\n$$\nEach trajectory is integrated for a maximum time $T_{\\max}$ or until the coordinate $u$ exceeds a cutoff magnitude, $|u| > U_{\\mathrm{cut}}$, indicating the particle is far from the interaction region. To check this condition, the lab-frame coordinates must be transformed back to the eigenbasis at each step:\n$$\n\\mathbf{c}(t) = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{q}(t) \\quad \\text{and} \\quad \\mathbf{\\pi}(t) = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{p}(t)\n$$\nThis gives $u(t) = q_x(t)\\cos\\theta + q_y(t)\\sin\\theta$ and $p_u(t) = p_x(t)\\cos\\theta + p_y(t)\\sin\\theta$.\n\nWe monitor crossings of two dividing surfaces (DS).\n1.  **DS 1 (Unstable-mode orthogonal DS):** Defined by the plane $u=0$. This is the ideal dividing surface for a quadratic barrier, representing the true transition state. A forward crossing is counted if $u$ transitions from $u_n \\le 0$ to $u_{n+1} > 0$ and the corresponding momentum is positive, $p_u(t_{n+1}) > 0$.\n2.  **DS 2 (Geometric DS):** Defined by the plane $x=0$. This is a naive choice based on one of the lab-frame axes. A forward crossing is counted if $x$ transitions from $x_n \\le 0$ to $x_{n+1} > 0$ and the corresponding momentum is positive, $p_x(t_{n+1}) > 0$.\n\nFor each trajectory in an ensemble of size $N$, we count the number of forward crossings, $N_+$, for each DS. A perfect DS would be crossed exactly once by every reactive trajectory. The number of recrossings for a single trajectory is therefore $\\max(0, N_+ - 1)$. The total recrossing count for a DS is the sum of these values over the entire ensemble.\n\nThe algorithmic procedure is as follows:\nFor each test case with parameters $(a, b, \\theta, E, N, \\sigma, s_0, \\Delta t, T_{\\max}, U_{\\mathrm{cut}})$:\n1.  Initialize total recrossing counters $R_{\\mathrm{unstable}} \\to 0$ and $R_{\\mathrm{geo}} \\to 0$. Construct the Hessian $\\mathbf{H}$ and rotation matrix $\\mathbf{R}(\\theta)$.\n2.  For each of $N$ trajectories:\n    a. Generate valid initial conditions $(\\mathbf{q}(0), \\mathbf{p}(0))$ in the lab frame.\n    b. Initialize per-trajectory forward crossing counters $N_{+,u} \\to 0$ and $N_{+,x} \\to 0$.\n    c. Set initial state $(\\mathbf{q}_0, \\mathbf{p}_0) = (\\mathbf{q}(0), \\mathbf{p}(0))$ and determine initial check variables $u_{-1}, x_{-1}$.\n    d. Integrate the equations of motion using velocity-Verlet for up to $T_{\\max}/\\Delta t$ steps. In each step $n$:\n        i. Compute $(\\mathbf{q}_n, \\mathbf{p}_n)$.\n        ii. Transform to eigenbasis to get $u_n$ and $p_{u,n}$.\n        iii. Check for forward crossing of DS 1: if $u_{n-1} \\le 0$ and $u_n > 0$ and $p_{u,n} > 0$, increment $N_{+,u}$.\n        iv. Check for forward crossing of DS 2: if $x_{n-1} \\le 0$ and $x_n > 0$ and $p_{x,n} > 0$, increment $N_{+,x}$.\n        v. Check termination condition $|u_n| > U_{\\mathrm{cut}}$. If true, break the integration loop.\n        vi. Update $u_{n-1} \\to u_n$, $x_{n-1} \\to x_n$.\n    e. Calculate recrossings for this trajectory: $\\Delta R_{\\mathrm{unstable}} = \\max(0, N_{+,u}-1)$ and $\\Delta R_{\\mathrm{geo}} = \\max(0, N_{+,x}-1)$.\n    f. Add to totals: $R_{\\mathrm{unstable}} \\leftarrow R_{\\mathrm{unstable}} + \\Delta R_{\\mathrm{unstable}}$, $R_{\\mathrm{geo}} \\leftarrow R_{\\mathrm{geo}} + \\Delta R_{\\mathrm{geo}}$.\n3.  Store the pair $[R_{\\mathrm{unstable}}, R_{\\mathrm{geo}}]$ for the current test case.\nAfter all cases are processed, format the collected results as specified. A fixed random seed must be used for reproducibility.\n\nWhen $\\theta=0$, the lab and eigen-frames coincide ($x=u, y=v$), so DS 1 and DS 2 are identical. We expect minimal recrossing and identical counts for both. As $\\theta$ increases, the geometric DS ($x=0$) becomes increasingly misaligned with the true transition state ($u=0$), and we anticipate a significant increase in $R_{\\mathrm{geo}}$ while $R_{\\mathrm{unstable}}$ should remain near zero, as it is dynamically correct for this potential.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares two dividing surfaces for a 2-DOF Hamiltonian model\n    of a barrier-crossing reaction by simulating ensembles of classical trajectories.\n    \"\"\"\n\n    test_cases = [\n        # Case A (aligned, boundary): a=2.0, b=1.0, theta=0.0, E=0.1, N=200, sigma=0.02, s_0=-0.05, dt=0.001, Tmax=5.0, Ucut=20.0.\n        (2.0, 1.0, 0.0, 0.1, 200, 0.02, -0.05, 0.001, 5.0, 20.0),\n        # Case B (moderate rotation): a=2.0, b=1.0, theta=pi/6, E=0.1, N=200, sigma=0.02, s_0=-0.05, dt=0.001, Tmax=5.0, Ucut=20.0.\n        (2.0, 1.0, np.pi/6, 0.1, 200, 0.02, -0.05, 0.001, 5.0, 20.0),\n        # Case C (strong rotation): a=2.0, b=1.0, theta=pi/3, E=0.1, N=200, sigma=0.02, s_0=-0.05, dt=0.001, Tmax=5.0, Ucut=20.0.\n        (2.0, 1.0, np.pi/3, 0.1, 200, 0.02, -0.05, 0.001, 5.0, 20.0),\n    ]\n\n    all_results = []\n    \n    # Use a fixed random seed for reproducibility.\n    # The problem does not specify a seed, so one is chosen here.\n    rng = np.random.default_rng(seed=42)\n\n    for case in test_cases:\n        a, b, theta, E, N, sigma, s0, dt, Tmax, Ucut = case\n\n        # Construct Hessian and Rotation matrices\n        c, s = np.cos(theta), np.sin(theta)\n        H = np.array([\n            [b * s**2 - a * c**2, -(a + b) * s * c],\n            [-(a + b) * s * c, b * c**2 - a * s**2]\n        ])\n        R = np.array([[c, -s], [s, c]])\n        RT = R.T\n\n        total_recross_unstable = 0\n        total_recross_geo = 0\n\n        for _ in range(N):\n            # Generate initial conditions for one trajectory\n            q0, p0 = generate_initial_conditions(rng, a, b, E, s0, sigma, R)\n\n            # Run the trajectory and count forward crossings\n            n_cross_unstable, n_cross_geo = run_trajectory(q0, p0, H, RT, dt, Tmax, Ucut)\n            \n            # Sum the recrossing counts\n            total_recross_unstable += max(0, n_cross_unstable - 1)\n            total_recross_geo += max(0, n_cross_geo - 1)\n\n        all_results.append([total_recross_unstable, total_recross_geo])\n\n    # Final print statement in the exact required format.\n    # repr() creates a string representation, and .replace removes spaces.\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef generate_initial_conditions(rng, a, b, E, s0, sigma, R):\n    \"\"\"\n    Generates initial phase space coordinates (q0, p0) for a single trajectory.\n    \"\"\"\n    while True:\n        v0 = rng.normal(loc=0.0, scale=sigma)\n        # pv(0) is 0 as per problem spec\n        # E = 1/2(pu^2 + pv^2) + 1/2(-a*u^2 + b*v^2)\n        pu0_sq = 2 * E + a * s0**2 - b * v0**2\n        if pu0_sq >= 0:\n            pu0 = np.sqrt(pu0_sq)\n            break\n    \n    # Initial conditions in eigenbasis\n    c0 = np.array([s0, v0])      # (u(0), v(0))\n    pi0 = np.array([pu0, 0.0])   # (pu(0), pv(0))\n\n    # Transform to laboratory frame\n    q0 = R @ c0\n    p0 = R @ pi0\n    \n    return q0, p0\n\ndef run_trajectory(q, p, H, RT, dt, Tmax, Ucut):\n    \"\"\"\n    Integrates a single trajectory and counts forward crossings for both DS.\n    \"\"\"\n    num_steps = int(Tmax / dt)\n    \n    n_cross_unstable = 0\n    n_cross_geo = 0\n    \n    # Get initial values for crossing check.\n    # Lab frame variables\n    x_prev = q[0]\n    # Eigenbasis variables\n    c_prev = RT @ q\n    u_prev = c_prev[0]\n    \n    for _ in range(num_steps):\n        # Velocity-Verlet Integration Step\n        p_half = p - 0.5 * dt * (H @ q)\n        q_next = q + dt * p_half\n        p_next = p_half - 0.5 * dt * (H @ q_next)\n        \n        # Update state\n        q, p = q_next, p_next\n        \n        # Current state variables for checks\n        x_curr = q[0]\n        px_curr = p[0]\n        \n        c_curr = RT @ q\n        pi_curr = RT @ p\n        u_curr = c_curr[0]\n        pu_curr = pi_curr[0]\n        \n        # DS 1 (unstable-mode orthogonal): u=0\n        if u_prev <= 0 and u_curr > 0 and pu_curr > 0:\n            n_cross_unstable += 1\n            \n        # DS 2 (geometric): x=0\n        if x_prev <= 0 and x_curr > 0 and px_curr > 0:\n            n_cross_geo += 1\n            \n        # Update previous state values for next iteration's checks\n        u_prev = u_curr\n        x_prev = x_curr\n        \n        # Check termination condition based on unstable coordinate magnitude\n        if abs(u_curr) > Ucut:\n            break\n            \n    return n_cross_unstable, n_cross_geo\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2632247"}, {"introduction": "The ultimate power of classical trajectory simulations lies in their ability to predict experimentally measurable quantities. This final exercise [@problem_id:2632274] demonstrates how to bridge the gap from microscopic dynamics to macroscopic observables by calculating the vibrational energy distribution of reaction products. You will implement a 'quasiclassical' binning procedure to assign final quantum states based on the classical energy of the product molecule's vibration. This practice also tackles the notorious 'zero-point energy' problem in classical simulations, providing a deep insight into both the power and the limitations of applying classical mechanics to molecular phenomena.", "problem": "You are tasked with implementing a classical trajectory simulation for a two-degree-of-freedom Hamiltonian model of a collinear reaction and using it to predict product vibrational state distributions with and without enforcing Zero-Point Energy (ZPE) constraints. You will compare those classical distributions to a reference quantum scattering distribution and quantify the deviations.\n\nThe system has two canonical coordinates: the reaction coordinate $x$ and the product vibrational coordinate $q$. The canonical momenta are $p_x$ and $p_q$, and the masses are $m_x$ and $m_q$. The total Hamiltonian is\n$$\nH(x,q,p_x,p_q) \\equiv \\frac{p_x^2}{2 m_x} + \\frac{p_q^2}{2 m_q} + V(x,q),\n$$\nwith a potential energy surface defined as\n$$\nV(x,q) \\equiv V_b(x) + \\frac{1}{2} k \\left[q - q_0(x)\\right]^2,\n$$\nwhere $V_b(x)$ is an Eckart barrier and $q_0(x)$ is a smooth switching of the harmonic equilibrium position from reactants to products:\n- The barrier is\n$$\nV_b(x) \\equiv \\frac{V_0}{\\cosh^2(\\alpha x)}.\n$$\n- The equilibrium position is\n$$\nq_0(x) \\equiv q_r + S(x)\\,(q_p - q_r), \\quad S(x) \\equiv \\frac{1}{1 + e^{-\\beta (x - x_c)}}.\n$$\n\nDynamics follow Hamilton's equations,\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p_x} = \\frac{p_x}{m_x}, \\quad \\dot{q} = \\frac{\\partial H}{\\partial p_q} = \\frac{p_q}{m_q},\n$$\n$$\n\\dot{p}_x = -\\frac{\\partial H}{\\partial x} = -\\frac{\\partial V}{\\partial x}, \\quad \\dot{p}_q = -\\frac{\\partial H}{\\partial q} = -\\frac{\\partial V}{\\partial q}.\n$$\nWith the above $V(x,q)$,\n$$\n\\frac{\\partial V}{\\partial x} = \\frac{\\partial V_b}{\\partial x} - k \\left(q - q_0(x)\\right) \\frac{d q_0}{dx}, \\quad \\frac{\\partial V}{\\partial q} = k \\left(q - q_0(x)\\right).\n$$\nFor the Eckart barrier $V_b(x) = V_0 \\,\\mathrm{sech}^2(\\alpha x)$,\n$$\n\\frac{d V_b}{d x} = -2 \\alpha V_0 \\,\\mathrm{sech}^2(\\alpha x)\\,\\tanh(\\alpha x).\n$$\nFor the switching function $S(x)$,\n$$\n\\frac{d q_0}{d x} = (q_p - q_r)\\, \\beta \\, S(x)\\, \\left[1 - S(x)\\right].\n$$\n\nYou must integrate the equations of motion using a time-reversible symplectic scheme (for example, velocity-Verlet) for an ensemble of independent trajectories that differ only by the initial vibrational phase in the reactant well. At $t=0$, trajectories start in the reactant region ($x \\ll x_c$) with\n- $x(0) = x_\\mathrm{init}$,\n- $q(0) = q_r + A \\cos\\phi$,\n- $p_q(0) = - m_q \\omega A \\sin\\phi$,\n- $p_x(0) = +\\sqrt{2 m_x \\left(E_\\mathrm{tot} - E_v^\\mathrm{init} - V_b(x_\\mathrm{init})\\right)}$,\nwhere $\\phi$ is a uniformly distributed random phase in $[0, 2\\pi)$, $\\omega \\equiv \\sqrt{k/m_q}$ is the harmonic frequency in the product (and reactant, since $k$ is the same on both sides), and $E_v^\\mathrm{init}$ is the initial vibrational energy in the reactant well. Use the classical ZPE-mimicking choice $E_v^\\mathrm{init} \\equiv \\frac{1}{2} \\omega$, so that $A \\equiv \\sqrt{2 E_v^\\mathrm{init}/k}$.\n\nAfter propagation to the product region, the vibrational energy in the product well is\n$$\nE_v^\\mathrm{final} \\equiv \\frac{p_q^2}{2 m_q} + \\frac{1}{2} k \\left(q - q_p\\right)^2.\n$$\nFor a harmonic oscillator, the classical action is $I \\equiv E_v^\\mathrm{final}/\\omega$. You must assign a vibrational quantum number by quasiclassical binning as\n$$\nn \\equiv \\max\\left(0,\\ \\mathrm{round}\\left(I - \\frac{1}{2}\\right)\\right),\n$$\ncorresponding to the Einstein-Brillouin-Keller prescription for the harmonic oscillator in atomic units. Build a normalized histogram over the first $N_\\mathrm{levels}$ bins $n = 0, 1, \\dots, N_\\mathrm{levels}-1$.\n\nImplement two variants:\n- Without Zero-Point Energy constraint (no-ZPE): all trajectories are binned as above.\n- With Zero-Point Energy constraint (hard-ZPE): discard any trajectory for which $E_v^\\mathrm{final} < \\frac{1}{2}\\omega$ before binning; normalize the resulting histogram over the accepted trajectories. If no trajectory survives, define the distribution as the zero vector.\n\nCompare each classical distribution $p_\\mathrm{cl}$ to a given quantum scattering reference distribution $p_\\mathrm{qm}$ of the same length using the total variation distance\n$$\n\\Delta \\equiv \\frac{1}{2} \\sum_{n=0}^{N_\\mathrm{levels}-1} \\left| p_\\mathrm{cl}(n) - p_\\mathrm{qm}(n) \\right|.\n$$\n\nWork entirely in atomic units, where the reduced Planck constant is $ \\hbar = 1$. Therefore, energies are in Hartree, time in atomic time units, distances in Bohr radii, and masses in electron masses. Angles are in radians.\n\nUse the following fixed parameters for all simulations:\n- $m_x = 10$, $m_q = 5$, $k = 0.05$,\n- $V_0 = 0.08$, $\\alpha = 0.8$,\n- $q_r = 0.0$, $q_p = 1.2$,\n- $\\beta = 1.0$, $x_c = 0.0$,\n- $x_\\mathrm{init} = -10.0$,\n- time step $\\Delta t = 0.15$, number of steps $N_\\mathrm{steps} = 1800$,\n- number of trajectories in the ensemble $N_\\mathrm{traj} = 800$,\n- number of vibrational levels to report $N_\\mathrm{levels} = 6$.\n\nThe test suite consists of three total energies (total energy includes initial vibrational energy and potential energy at $x_\\mathrm{init}$ to within negligible tail of $V_b$):\n- Case $1$: $E_\\mathrm{tot} = V_0 + \\frac{1}{2}\\omega + 0.03$,\n- Case $2$: $E_\\mathrm{tot} = V_0 + \\frac{1}{2}\\omega + 0.10$,\n- Case $3$: $E_\\mathrm{tot} = V_0 + \\frac{1}{2}\\omega + 0.20$.\n\nFor each case $i \\in \\{1,2,3\\}$, use the following quantum scattering reference distributions over $n = 0,1,2,3,4,5$:\n- Case $1$: $p_\\mathrm{qm}^{(1)} = [0.75, 0.22, 0.03, 0.00, 0.00, 0.00]$,\n- Case $2$: $p_\\mathrm{qm}^{(2)} = [0.35, 0.40, 0.20, 0.05, 0.00, 0.00]$,\n- Case $3$: $p_\\mathrm{qm}^{(3)} = [0.20, 0.30, 0.27, 0.15, 0.06, 0.02]$.\n\nYour program must produce, for each case, two numbers: the total variation distance without ZPE constraint and the total variation distance with ZPE constraint, in that order. Aggregate the six numbers (two per case, ordered by case $1$ then case $2$ then case $3$) into a single list.\n\nFinal output format: Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets (for example, \"[$r_1,r_2,r_3,r_4,r_5,r_6$]\"). No other output is permitted.\n\nRequirements summary:\n- Implement Hamiltonian dynamics with the specified potential in atomic units.\n- Use velocity-Verlet integration with the specified parameters and an ensemble of independent random initial phases.\n- Compute product vibrational distributions with and without hard Zero-Point Energy (ZPE) constraints.\n- Compare to the provided quantum distributions using total variation distance.\n- Use the specified three test cases.\n- Print the six distances in the specified format as the only output line.", "solution": "The problem requires the implementation of a quasiclassical trajectory (QCT) simulation to study the dynamics of a collinear chemical reaction. The system is described by a two-degree-of-freedom Hamiltonian, and the goal is to compute the vibrational state distribution of the products and compare it against a known quantum mechanical result. The validity of the problem is confirmed as it represents a standard, well-posed problem in computational chemical physics, with all necessary parameters and procedures clearly defined and scientifically grounded.\n\nThe solution proceeds by following the established principles of classical mechanics and statistical simulation. The core components of the implementation are outlined below.\n\nFirst, we define the Hamiltonian of the system, which is the sum of kinetic and potential energies:\n$$\nH(x,q,p_x,p_q) = \\frac{p_x^2}{2 m_x} + \\frac{p_q^2}{2 m_q} + V(x,q)\n$$\nThe potential energy surface $V(x,q)$ is given by:\n$$\nV(x,q) = V_b(x) + \\frac{1}{2} k \\left[q - q_0(x)\\right]^2\n$$\nwhere $V_b(x) = V_0\\,\\mathrm{sech}^2(\\alpha x)$ is an Eckart potential barrier along the reaction coordinate $x$, and the second term describes a harmonic oscillator in the perpendicular coordinate $q$ whose equilibrium position $q_0(x)$ smoothly transitions from the reactant value $q_r$ to the product value $q_p$ as a function of $x$.\n\nThe classical dynamics of the system are governed by Hamilton's equations of motion:\n$$\n\\dot{\\mathbf{r}} = \\frac{\\partial H}{\\partial \\mathbf{p}}, \\quad \\dot{\\mathbf{p}} = -\\frac{\\partial H}{\\partial \\mathbf{r}}\n$$\nwhere $\\mathbf{r} = (x, q)$ and $\\mathbf{p} = (p_x, p_q)$. The forces required for the time evolution of the momenta are the negative gradients of the potential energy:\n$$\nF_x = -\\frac{\\partial V}{\\partial x}, \\quad F_q = -\\frac{\\partial V}{\\partial q}\n$$\nThe analytical expressions for these forces are provided in the problem statement and are implemented directly.\n\nTo propagate the trajectories in time, we employ the velocity-Verlet algorithm. This numerical integration scheme is chosen for its desirable properties in molecular dynamics simulations: it is a symplectic integrator, which ensures good long-term conservation of the total energy, and it is time-reversible. The algorithm advances the positions and momenta over a discrete time step $\\Delta t$ according to the following sequence:\n1. Update momenta by a half-step: $\\mathbf{p}(t + \\Delta t/2) = \\mathbf{p}(t) + \\mathbf{F}(\\mathbf{r}(t)) \\frac{\\Delta t}{2}$.\n2. Update positions by a full step using the half-step momenta: $\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\frac{\\mathbf{p}(t + \\Delta t/2)}{\\mathbf{m}} \\Delta t$.\n3. Compute forces $\\mathbf{F}(\\mathbf{r}(t + \\Delta t))$ at the new positions.\n4. Complete the momenta update: $\\mathbf{p}(t + \\Delta t) = \\mathbf{p}(t + \\Delta t/2) + \\mathbf{F}(\\mathbf{r}(t + \\Delta t)) \\frac{\\Delta t}{2}$.\n\nAn ensemble of $N_\\mathrm{traj}$ trajectories is simulated for each specified total energy $E_\\mathrm{tot}$. The initial conditions for each trajectory are prepared as follows. The system starts deep in the reactant channel at $x(0) = x_\\mathrm{init}$. The initial translational momentum $p_x(0)$ is positive and determined by energy conservation:\n$$\np_x(0) = \\sqrt{2 m_x \\left(E_\\mathrm{tot} - E_v^\\mathrm{init} - V(x_\\mathrm{init}, q(0))\\right)}\n$$\nSince $x_\\mathrm{init}$ is far from the barrier, $V_b(x_\\mathrm{init}) \\approx 0$ and $q_0(x_\\mathrm{init}) \\approx q_r$. The vibrational part of the potential energy at $t=0$ plus the kinetic energy of the $q$ motion constitute the initial vibrational energy, $E_v^\\mathrm{init}$. The problem specifies using the classical equivalent of the quantum zero-point energy (ZPE), $E_v^\\mathrm{init} = \\frac{1}{2}\\hbar\\omega = \\frac{1}{2}\\omega$ in atomic units ($\\hbar=1$), where $\\omega = \\sqrt{k/m_q}$. The ensemble of trajectories is generated by sampling the initial phase $\\phi$ of the vibrational motion from a uniform distribution over $[0, 2\\pi)$. This sets the initial vibrational coordinate and momentum:\n$$\nq(0) = q_r + A \\cos\\phi, \\quad p_q(0) = - m_q \\omega A \\sin\\phi\n$$\nwhere the amplitude $A=\\sqrt{2 E_v^\\mathrm{init}/k}$. Each trajectory is then integrated for a fixed duration of $N_\\mathrm{steps} \\times \\Delta t$.\n\nAfter the integration, the final state of each trajectory is analyzed to determine the product vibrational state. The final vibrational energy in the product channel is calculated as:\n$$\nE_v^\\mathrm{final} = \\frac{p_q^2(t_f)}{2 m_q} + \\frac{1}{2} k \\left(q(t_f) - q_p\\right)^2\n$$\nThis classical energy is converted to a vibrational quantum number $n$ using the quasiclassical binning procedure prescribed by the Einstein-Brillouin-Keller (EBK) quantization rule for a harmonic oscillator. The classical action is $I = E_v^\\mathrm{final}/\\omega$, and the quantum number is assigned as the nearest integer to $I - 1/2$:\n$$\nn = \\max\\left(0, \\mathrm{round}\\left(I - \\frac{1}{2}\\right)\\right)\n$$\nTwo different population distributions are computed. The first (no-ZPE) uses all trajectories. The second (hard-ZPE) includes a physically motivated constraint: trajectories resulting in a final vibrational energy less than the quantum ZPE ($E_v^\\mathrm{final} < \\frac{1}{2}\\omega$) are discarded before binning. For both cases, a histogram of the resulting integer quantum numbers $n$ is constructed and normalized to yield the classical probability distributions $p_\\mathrm{cl}(n)$.\n\nFinally, these classical distributions are compared to the provided reference quantum mechanical distributions $p_\\mathrm{qm}(n)$ using the total variation distance, $\\Delta$:\n$$\n\\Delta = \\frac{1}{2} \\sum_{n=0}^{N_\\mathrm{levels}-1} \\left| p_\\mathrm{cl}(n) - p_\\mathrm{qm}(n) \\right|\n$$\nThis entire procedure is repeated for three different total energies, producing six distinct distance values as the final result. The implementation is encapsulated in a Python script which calculates these values and prints them in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the classical trajectory simulation problem for three test cases.\n    \"\"\"\n    \n    # --- Fixed Parameters (atomic units) ---\n    m_x, m_q, k = 10.0, 5.0, 0.05\n    V0, alpha = 0.08, 0.8\n    qr, qp = 0.0, 1.2\n    beta, xc = 1.0, 0.0\n    x_init = -10.0\n    dt, N_steps = 0.15, 1800\n    N_traj = 800\n    N_levels = 6\n\n    # --- Derived constants ---\n    omega = np.sqrt(k / m_q)\n    E_v_init = 0.5 * omega\n    A = np.sqrt(2.0 * E_v_init / k)\n\n    # --- Test Cases ---\n    p_qm_1 = np.array([0.75, 0.22, 0.03, 0.00, 0.00, 0.00])\n    p_qm_2 = np.array([0.35, 0.40, 0.20, 0.05, 0.00, 0.00])\n    p_qm_3 = np.array([0.20, 0.30, 0.27, 0.15, 0.06, 0.02])\n\n    test_cases = [\n        (V0 + E_v_init + 0.03, p_qm_1),\n        (V0 + E_v_init + 0.10, p_qm_2),\n        (V0 + E_v_init + 0.20, p_qm_3),\n    ]\n\n    # --- Potential Energy Surface and Force Functions ---\n    def Vb(x):\n        return V0 / np.cosh(alpha * x)**2\n\n    def S(x):\n        # Use a check to prevent overflow for large negative arguments of exp\n        arg = -beta * (x - xc)\n        if arg > 35: # np.exp(35) is large enough\n             return 0.0\n        return 1.0 / (1.0 + np.exp(arg))\n\n    def q0_func(x):\n        return qr + S(x) * (qp - qr)\n\n    def dVb_dx(x):\n        ax = alpha * x\n        cosh_ax = np.cosh(ax)\n        tanh_ax = np.tanh(ax)\n        return -2.0 * alpha * V0 * tanh_ax / (cosh_ax**2)\n\n    def dq0_dx(x):\n        s_x = S(x)\n        return (qp - qr) * beta * s_x * (1.0 - s_x)\n\n    def get_forces(pos):\n        x, q = pos[0], pos[1]\n        q0_val = q0_func(x)\n        \n        # Force Fx = -dV/dx\n        fx = -dVb_dx(x) + k * (q - q0_val) * dq0_dx(x)\n        # Force Fq = -dV/dq\n        fq = -k * (q - q0_val)\n        \n        return np.array([fx, fq])\n\n    # --- Trajectory integration ---\n    def run_trajectory(initial_conds):\n        pos = np.array([initial_conds[0], initial_conds[1]])\n        mom = np.array([initial_conds[2], initial_conds[3]])\n        masses = np.array([m_x, m_q])\n        \n        # Initial force calculation for velocity-Verlet\n        forces = get_forces(pos)\n        \n        for _ in range(N_steps):\n            # Velocity-Verlet algorithm\n            mom_half = mom + 0.5 * dt * forces\n            pos += dt * mom_half / masses\n            forces = get_forces(pos)\n            mom = mom_half + 0.5 * dt * forces\n            \n        return pos[0], pos[1], mom[0], mom[1]\n\n    # --- Main simulation loop for a given case ---\n    def simulate_case(Etot, p_qm):\n        try:\n            # Handle potential negative value in sqrt if Etot is too low\n            px0_energy_term = Etot - E_v_init - Vb(x_init)\n            if px0_energy_term < 0:\n                raise ValueError(\"Initial kinetic energy is negative. Cannot start trajectory.\")\n            px0 = np.sqrt(2.0 * m_x * px0_energy_term)\n        except ValueError as e:\n            # This case should not happen with the given parameters\n            print(f\"Error during initialization: {e}\")\n            return 0.0, 0.0\n\n        rng = np.random.default_rng()\n        final_vib_energies = []\n        \n        for _ in range(N_traj):\n            phi = rng.uniform(0, 2.0 * np.pi)\n            \n            q_init = qr + A * np.cos(phi)\n            pq_init = -m_q * omega * A * np.sin(phi)\n            \n            initial_conds = (x_init, q_init, px0, pq_init)\n            \n            xf, qf, pxf, pqf = run_trajectory(initial_conds)\n            \n            E_v_final = pqf**2 / (2.0 * m_q) + 0.5 * k * (qf - qp)**2\n            final_vib_energies.append(E_v_final)\n            \n        final_vib_energies = np.array(final_vib_energies)\n\n        # --- Analysis without ZPE constraint ---\n        actions_no_zpe = final_vib_energies / omega\n        n_values_no_zpe = np.maximum(0, np.round(actions_no_zpe - 0.5)).astype(int)\n        \n        hist_no_zpe, _ = np.histogram(n_values_no_zpe, bins=np.arange(N_levels + 1))\n        \n        if np.sum(hist_no_zpe) > 0:\n            p_cl_no_zpe = hist_no_zpe / np.sum(hist_no_zpe)\n        else:\n            p_cl_no_zpe = np.zeros(N_levels)\n        \n        tvd_no_zpe = 0.5 * np.sum(np.abs(p_cl_no_zpe - p_qm))\n\n        # --- Analysis with hard ZPE constraint ---\n        zpe_threshold = 0.5 * omega\n        valid_energies = final_vib_energies[final_vib_energies >= zpe_threshold]\n        \n        p_cl_hard_zpe = np.zeros(N_levels)\n        \n        if len(valid_energies) > 0:\n            actions_hard_zpe = valid_energies / omega\n            n_values_hard_zpe = np.maximum(0, np.round(actions_hard_zpe - 0.5)).astype(int)\n            hist_hard_zpe, _ = np.histogram(n_values_hard_zpe, bins=np.arange(N_levels + 1))\n            \n            if np.sum(hist_hard_zpe) > 0:\n                 p_cl_hard_zpe = hist_hard_zpe / np.sum(hist_hard_zpe)\n\n        tvd_hard_zpe = 0.5 * np.sum(np.abs(p_cl_hard_zpe - p_qm))\n\n        return tvd_no_zpe, tvd_hard_zpe\n\n    # --- Execute and collect results ---\n    results = []\n    for Etot, p_qm in test_cases:\n        dist_no_zpe, dist_hard_zpe = simulate_case(Etot, p_qm)\n        results.extend([dist_no_zpe, dist_hard_zpe])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2632274"}]}