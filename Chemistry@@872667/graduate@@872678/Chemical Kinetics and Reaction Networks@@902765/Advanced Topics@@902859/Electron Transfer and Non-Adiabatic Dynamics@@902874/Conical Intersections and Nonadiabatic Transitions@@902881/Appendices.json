{"hands_on_practices": [{"introduction": "The local topography of a conical intersection is fundamentally defined by two vectors: the gradient-difference vector $\\mathbf{g}$ and the nonadiabatic coupling vector $\\mathbf{h}$. This exercise bridges the gap between these abstract mathematical descriptors and their tangible physical consequences. By calculating the Duschinsky rotation matrix, you will explore how the vibrational normal modes of the ground and excited electronic states are mixed near the CI, a critical factor influencing the direction of nuclear motion after a nonadiabatic transition [@problem_id:2635977].", "problem": "Consider a two-state conical intersection described in the linear vibronic coupling framework in mass-weighted Cartesian coordinates. The local branching plane at the conical intersection is spanned by the gradient-difference vector $\\mathbf{g}$ and the derivative (nonadiabatic) coupling vector $\\mathbf{h}$, which are taken to be orthonormal: $|\\mathbf{g}| = 1$, $|\\mathbf{h}| = 1$, and $\\mathbf{g}\\cdot\\mathbf{h} = 0$. Within this two-dimensional subspace, each electronic state has a pair of orthonormal normal modes that define its local tuning and coupling axes.\n\nAt the ground-state minimum, the two normalized normal-mode directions within the branching plane are given by\n$$\n\\mathbf{Q}_{g1} = \\frac{\\sqrt{3}}{2}\\,\\mathbf{g} + \\frac{1}{2}\\,\\mathbf{h}, \n\\qquad\n\\mathbf{Q}_{g2} = -\\frac{1}{2}\\,\\mathbf{g} + \\frac{\\sqrt{3}}{2}\\,\\mathbf{h}.\n$$\nAt the excited-state minimum, the two normalized normal-mode directions within the branching plane are\n$$\n\\mathbf{Q}_{e1} = \\frac{1}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{2}{\\sqrt{5}}\\,\\mathbf{h},\n\\qquad\n\\mathbf{Q}_{e2} = -\\frac{2}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{1}{\\sqrt{5}}\\,\\mathbf{h}.\n$$\n\nUsing only fundamental definitions of the branching plane and the Duschinsky effect, do the following:\n- Construct the Duschinsky rotation matrix $\\mathbf{J}$ that maps ground-state normal-mode coordinates $(Q_{g1}, Q_{g2})$ in the branching plane to excited-state normal-mode coordinates $(Q_{e1}, Q_{e2})$ via $\\mathbf{Q}_{e} = \\mathbf{J}\\,\\mathbf{Q}_{g} + \\mathbf{K}$, restricted to the branching plane and ignoring the displacement vector $\\mathbf{K}$ within this plane.\n- From $\\mathbf{J}$, extract the principal Duschinsky rotation angle $\\theta$ (take the principal value with $0 \\le \\theta \\le \\pi$). Use radians.\n- In a linear vibronic coupling description near the conical intersection, the diabatic coupling is linear in the coordinate along $\\mathbf{h}$. Interpreting, within each state’s branching-plane frame, the second normal-mode axis as that state’s coupling axis, quantify the immediate nonadiabatic driving for a wavepacket launched on the ground state with initial nuclear velocity along $\\mathbf{Q}_{g1}$ by the dimensionless propensity factor\n$$\nF \\equiv \\left|\\mathbf{Q}_{e2}\\cdot \\mathbf{Q}_{g1}\\right|^{2}.\n$$\n\nReport the final value of $F$ as a dimensionless number, rounded to four significant figures.", "solution": "The problem requires the calculation of a dimensionless propensity factor, $F$, related to nonadiabatic transitions at a conical intersection. This calculation necessitates constructing the Duschinsky rotation matrix $\\mathbf{J}$, which maps the ground-state normal-mode coordinates to the excited-state normal-mode coordinates within the two-dimensional branching plane.\n\nThe branching plane is defined by two orthonormal vectors, the gradient-difference vector $\\mathbf{g}$ and the nonadiabatic coupling vector $\\mathbf{h}$, such that $|\\mathbf{g}|=1$, $|\\mathbf{h}|=1$, and $\\mathbf{g} \\cdot \\mathbf{h}=0$. They form a basis for this plane.\n\nThe ground-state normal modes in this plane are given as:\n$$\n\\mathbf{Q}_{g1} = \\frac{\\sqrt{3}}{2}\\,\\mathbf{g} + \\frac{1}{2}\\,\\mathbf{h}\n$$\n$$\n\\mathbf{Q}_{g2} = -\\frac{1}{2}\\,\\mathbf{g} + \\frac{\\sqrt{3}}{2}\\,\\mathbf{h}\n$$\nThe provided vectors form an orthonormal basis, as $|\\mathbf{Q}_{g1}|^2 = (\\frac{\\sqrt{3}}{2})^2 + (\\frac{1}{2})^2 = \\frac{3}{4} + \\frac{1}{4} = 1$, $|\\mathbf{Q}_{g2}|^2 = (-\\frac{1}{2})^2 + (\\frac{\\sqrt{3}}{2})^2 = \\frac{1}{4} + \\frac{3}{4} = 1$, and $\\mathbf{Q}_{g1} \\cdot \\mathbf{Q}_{g2} = (\\frac{\\sqrt{3}}{2})(-\\frac{1}{2}) + (\\frac{1}{2})(\\frac{\\sqrt{3}}{2}) = 0$.\n\nThe excited-state normal modes in this plane are:\n$$\n\\mathbf{Q}_{e1} = \\frac{1}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{2}{\\sqrt{5}}\\,\\mathbf{h}\n$$\n$$\n\\mathbf{Q}_{e2} = -\\frac{2}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{1}{\\sqrt{5}}\\,\\mathbf{h}\n$$\nThese also form an orthonormal basis, as $|\\mathbf{Q}_{e1}|^2 = (\\frac{1}{\\sqrt{5}})^2 + (\\frac{2}{\\sqrt{5}})^2 = \\frac{1}{5} + \\frac{4}{5} = 1$, $|\\mathbf{Q}_{e2}|^2 = (-\\frac{2}{\\sqrt{5}})^2 + (\\frac{1}{\\sqrt{5}})^2 = \\frac{4}{5} + \\frac{1}{5} = 1$, and $\\mathbf{Q}_{e1} \\cdot \\mathbf{Q}_{e2} = (\\frac{1}{\\sqrt{5}})(-\\frac{2}{\\sqrt{5}}) + (\\frac{2}{\\sqrt{5}})(\\frac{1}{\\sqrt{5}}) = 0$.\n\nThe Duschinsky transformation, neglecting the displacement vector $\\mathbf{K}$, is $\\mathbf{Q}_{e} = \\mathbf{J}\\,\\mathbf{Q}_{g}$. The elements of the Duschinsky matrix $\\mathbf{J}$ are given by the dot products of the normal mode vectors of the two states: $J_{ij} = \\mathbf{Q}_{ei} \\cdot \\mathbf{Q}_{gj}$. We construct the $2 \\times 2$ matrix $\\mathbf{J}$ for the branching-plane modes.\n\nThe elements of $\\mathbf{J}$ are calculated as follows:\n$J_{11} = \\mathbf{Q}_{e1} \\cdot \\mathbf{Q}_{g1} = \\left(\\frac{1}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{2}{\\sqrt{5}}\\,\\mathbf{h}\\right) \\cdot \\left(\\frac{\\sqrt{3}}{2}\\,\\mathbf{g} + \\frac{1}{2}\\,\\mathbf{h}\\right) = \\frac{\\sqrt{3}}{2\\sqrt{5}} + \\frac{2}{2\\sqrt{5}} = \\frac{2+\\sqrt{3}}{2\\sqrt{5}}$.\n$J_{12} = \\mathbf{Q}_{e1} \\cdot \\mathbf{Q}_{g2} = \\left(\\frac{1}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{2}{\\sqrt{5}}\\,\\mathbf{h}\\right) \\cdot \\left(-\\frac{1}{2}\\,\\mathbf{g} + \\frac{\\sqrt{3}}{2}\\,\\mathbf{h}\\right) = -\\frac{1}{2\\sqrt{5}} + \\frac{2\\sqrt{3}}{2\\sqrt{5}} = \\frac{2\\sqrt{3}-1}{2\\sqrt{5}}$.\n$J_{21} = \\mathbf{Q}_{e2} \\cdot \\mathbf{Q}_{g1} = \\left(-\\frac{2}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{1}{\\sqrt{5}}\\,\\mathbf{h}\\right) \\cdot \\left(\\frac{\\sqrt{3}}{2}\\,\\mathbf{g} + \\frac{1}{2}\\,\\mathbf{h}\\right) = -\\frac{2\\sqrt{3}}{2\\sqrt{5}} + \\frac{1}{2\\sqrt{5}} = \\frac{1-2\\sqrt{3}}{2\\sqrt{5}}$.\n$J_{22} = \\mathbf{Q}_{e2} \\cdot \\mathbf{Q}_{g2} = \\left(-\\frac{2}{\\sqrt{5}}\\,\\mathbf{g} + \\frac{1}{\\sqrt{5}}\\,\\mathbf{h}\\right) \\cdot \\left(-\\frac{1}{2}\\,\\mathbf{g} + \\frac{\\sqrt{3}}{2}\\,\\mathbf{h}\\right) = \\frac{2}{2\\sqrt{5}} + \\frac{\\sqrt{3}}{2\\sqrt{5}} = \\frac{2+\\sqrt{3}}{2\\sqrt{5}}$.\n\nThus, the Duschinsky matrix is:\n$$\n\\mathbf{J} = \\begin{pmatrix} J_{11}  J_{12} \\\\ J_{21}  J_{22} \\end{pmatrix} = \\frac{1}{2\\sqrt{5}} \\begin{pmatrix} 2+\\sqrt{3}  2\\sqrt{3}-1 \\\\ 1-2\\sqrt{3}  2+\\sqrt{3} \\end{pmatrix}\n$$\nThis is an orthogonal matrix with $\\det(\\mathbf{J})=1$, representing a pure rotation. The Duschinsky rotation angle $\\theta$, required by the problem to be in the range $[0, \\pi]$, is found from the diagonal elements, $\\cos(\\theta) = J_{11}$. So, $\\theta = \\arccos\\left(\\frac{2+\\sqrt{3}}{2\\sqrt{5}}\\right)$.\n\nThe primary goal is to compute the propensity factor $F$, which is defined as:\n$$\nF \\equiv \\left|\\mathbf{Q}_{e2}\\cdot \\mathbf{Q}_{g1}\\right|^{2}\n$$\nThis quantity is precisely the square of the magnitude of the matrix element $J_{21}$.\n$$\nF = (J_{21})^2 = \\left(\\frac{1-2\\sqrt{3}}{2\\sqrt{5}}\\right)^2\n$$\nWe perform the calculation:\n$$\nF = \\frac{(1-2\\sqrt{3})^2}{(2\\sqrt{5})^2} = \\frac{1^2 - 2(1)(2\\sqrt{3}) + (2\\sqrt{3})^2}{4 \\cdot 5} = \\frac{1 - 4\\sqrt{3} + 12}{20} = \\frac{13 - 4\\sqrt{3}}{20}\n$$\nThis is the exact analytical expression for $F$. To provide the numerical value, we substitute $\\sqrt{3} \\approx 1.7320508$:\n$$\nF = \\frac{13 - 4(1.7320508)}{20} = \\frac{13 - 6.9282032}{20} = \\frac{6.0717968}{20} \\approx 0.30358984\n$$\nRounding this result to four significant figures, as requested, we obtain:\n$$\nF \\approx 0.3036\n$$\nThis factor $F$ quantifies the projection of motion along the ground-state mode $\\mathbf{Q}_{g1}$ onto the excited-state coupling mode $\\mathbf{Q}_{e2}$, providing a measure of the initial driving force for a nonadiabatic transition.", "answer": "$$\n\\boxed{0.3036}\n$$", "id": "2635977"}, {"introduction": "The theoretical concept of a conical intersection becomes a practical tool when we can locate these points on a molecule's potential energy surface. This exercise guides you through the implementation of a standard computational algorithm to find a Minimum Energy Conical Intersection (MECI), which is often the most accessible point of degeneracy. You will apply the method of Lagrange multipliers to a model quadratic potential, a technique central to modern computational photochemistry, and learn to classify the intersection's topology as \"peaked\" or \"sloped\" based on the gradient at the MECI [@problem_id:2635932].", "problem": "You are given a local linear vibronic coupling model for two adiabatic potential energy surfaces near a conical intersection in nuclear coordinate space of dimension $N$. The two adiabatic energies are modeled as\n$$\nE_{\\pm}(\\mathbf{x}) \\;=\\; E_0 \\;+\\; \\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\mathbf{A}\\,\\mathbf{x} \\;+\\; \\mathbf{s}_0^{\\mathsf{T}}\\mathbf{x} \\;\\pm\\; \\sqrt{(\\mathbf{g}^{\\mathsf{T}}\\mathbf{x})^2 + (\\mathbf{h}^{\\mathsf{T}}\\mathbf{x})^2},\n$$\nwhere $\\mathbf{x}\\in\\mathbb{R}^N$ is the displacement vector from a reference geometry, $\\mathbf{A}\\in\\mathbb{R}^{N\\times N}$ is a symmetric positive-definite matrix capturing the harmonic curvature of the average energy, $\\mathbf{s}_0\\in\\mathbb{R}^N$ is a constant vector, and $\\mathbf{g},\\mathbf{h}\\in\\mathbb{R}^N$ are two linearly independent vectors that define the branching plane. The branching plane is the $2$-dimensional subspace $\\mathcal{B}=\\mathrm{span}\\{\\mathbf{g},\\mathbf{h}\\}$. The average energy is\n$$\nE_{\\mathrm{avg}}(\\mathbf{x}) \\;=\\; \\tfrac{1}{2}\\left(E_{+}(\\mathbf{x})+E_{-}(\\mathbf{x})\\right) \\;=\\; E_0 \\;+\\; \\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\mathbf{A}\\,\\mathbf{x} \\;+\\; \\mathbf{s}_0^{\\mathsf{T}}\\mathbf{x},\n$$\nwith gradient\n$$\n\\mathbf{s}(\\mathbf{x}) \\;=\\; \\nabla E_{\\mathrm{avg}}(\\mathbf{x}) \\;=\\; \\mathbf{A}\\mathbf{x} + \\mathbf{s}_0.\n$$\nIn this local model, the conical intersection seam is the set of points satisfying the degeneracy constraints\n$$\n\\mathbf{g}^{\\mathsf{T}}\\mathbf{x} \\;=\\; 0,\\qquad \\mathbf{h}^{\\mathsf{T}}\\mathbf{x} \\;=\\; 0.\n$$\nA minimum-energy conical intersection (MECI) geometry $\\mathbf{x}^{\\star}$ is defined here as any solution to the constrained optimization problem: minimize $E_{\\mathrm{avg}}(\\mathbf{x})$ subject to $\\mathbf{g}^{\\mathsf{T}}\\mathbf{x}=0$ and $\\mathbf{h}^{\\mathsf{T}}\\mathbf{x}=0$. Denote the orthogonal projection onto the branching plane by $\\mathbf{P}_{\\mathcal{B}}$ and onto its orthogonal complement by $\\mathbf{P}_{\\mathcal{B}}^{\\perp}=\\mathbf{I}-\\mathbf{P}_{\\mathcal{B}}$.\n\nYour task is to implement a branching-plane constrained optimization algorithm that:\n- Computes $\\mathbf{x}^{\\star}$ by minimizing $E_{\\mathrm{avg}}(\\mathbf{x})$ subject to the two linear degeneracy constraints.\n- Evaluates the average-energy gradient at the MECI, $\\mathbf{s}^{\\star}=\\mathbf{A}\\mathbf{x}^{\\star}+\\mathbf{s}_0$.\n- Computes the component of the average-energy gradient orthogonal to the branching plane, $\\mathbf{s}_{\\perp}^{\\star}=\\mathbf{P}_{\\mathcal{B}}^{\\perp}\\mathbf{s}^{\\star}$, as a diagnostics of constraint satisfaction at the MECI.\n- Computes the component of the average-energy gradient within the branching plane, $\\mathbf{s}_{\\parallel}^{\\star}=\\mathbf{P}_{\\mathcal{B}}\\mathbf{s}^{\\star}$, and classifies the MECI topology as “sloped” if $\\lVert \\mathbf{s}_{\\parallel}^{\\star}\\rVert_2$ is larger than a threshold and “peaked” otherwise.\n\nAlgorithmic requirements:\n1. Formulate and solve the constrained quadratic minimization using Lagrange multipliers. Let $\\mathbf{C}\\in\\mathbb{R}^{2\\times N}$ have rows $\\mathbf{g}^{\\mathsf{T}}$ and $\\mathbf{h}^{\\mathsf{T}}$. Solve the Karush–Kuhn–Tucker linear system\n$$\n\\begin{bmatrix}\n\\mathbf{A}  \\mathbf{C}^{\\mathsf{T}}\\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x}^{\\star}\\\\\n\\boldsymbol{\\lambda}^{\\star}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\mathbf{s}_0\\\\\n\\mathbf{0}\n\\end{bmatrix}.\n$$\n2. Construct $\\mathbf{P}_{\\mathcal{B}}$ by orthonormalizing $\\{\\mathbf{g},\\mathbf{h}\\}$ (for example, by the Gram–Schmidt process or a thin QR factorization). If $\\mathbf{Q}\\in\\mathbb{R}^{N\\times 2}$ has orthonormal columns spanning $\\mathcal{B}$, then $\\mathbf{P}_{\\mathcal{B}}=\\mathbf{Q}\\mathbf{Q}^{\\mathsf{T}}$ and $\\mathbf{P}_{\\mathcal{B}}^{\\perp}=\\mathbf{I}-\\mathbf{Q}\\mathbf{Q}^{\\mathsf{T}}$.\n3. Compute $\\mathbf{s}^{\\star}$, $\\mathbf{s}_{\\perp}^{\\star}$, and $\\mathbf{s}_{\\parallel}^{\\star}$.\n4. Use an absolute classification threshold $\\tau=10^{-10}$. Classify as “sloped” if $\\lVert \\mathbf{s}_{\\parallel}^{\\star}\\rVert_2\\tau$, and “peaked” otherwise. For output, encode “sloped” as the integer $1$ and “peaked” as the integer $0$.\n\nTest suite:\nImplement your program for the following cases. Each case specifies $N$, $\\mathbf{A}$, $\\mathbf{g}$, $\\mathbf{h}$, and $\\mathbf{s}_0$.\n\n- Case $1$ (baseline peaked):\n  - $N=3$.\n  - $\\mathbf{A}=\\mathrm{diag}(1,1,1)$.\n  - $\\mathbf{g}=(1,0,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,0)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0,0,0)^{\\mathsf{T}}$.\n\n- Case $2$ (generic sloped with identity curvature):\n  - $N=3$.\n  - $\\mathbf{A}=\\mathrm{diag}(1,1,1)$.\n  - $\\mathbf{g}=(1,1,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,1)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0.5,-0.4,0.1)^{\\mathsf{T}}$.\n\n- Case $3$ (peaked with anisotropic curvature):\n  - $N=4$.\n  - $\\mathbf{A}=\\mathrm{diag}(2,1.5,1,0.5)$.\n  - $\\mathbf{g}=(1,0,1,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,0,1)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0,0,0,0)^{\\mathsf{T}}$.\n\n- Case $4$ (generic sloped with coupled curvature):\n  - $N=4$.\n  - $\\mathbf{A}=\\begin{bmatrix}\n2  0.2  0  0\\\\\n0.2  1.5  0.1  0\\\\\n0  0.1  1.2  0.05\\\\\n0  0  0.05  0.8\n\\end{bmatrix}$.\n  - $\\mathbf{g}=(1,1,0,0)^{\\mathsf{T}}$, $\\mathbf{h}=(0,1,1,0)^{\\mathsf{T}}$.\n  - $\\mathbf{s}_0=(0.1,-0.2,0.3,-0.05)^{\\mathsf{T}}$.\n\nAnswer specification:\n- Your program must compute the classification for each case in the given order, using the algorithm above. No physical units are involved; all quantities are dimensionless real numbers.\n- Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, in the exact order of the cases, where each integer is $1$ for “sloped” and $0$ for “peaked”. For example, an output like $[0,1,0,1]$ is acceptable if that matches your computed results for the cases.", "solution": "The core of the problem is to find a minimum-energy conical intersection (MECI) geometry, denoted $\\mathbf{x}^{\\star} \\in \\mathbb{R}^N$. This is achieved by minimizing the average potential energy, $E_{\\mathrm{avg}}(\\mathbf{x})$, subject to the linear constraints that define the conical intersection seam. The optimization problem is stated as:\n$$\n\\begin{aligned}\n \\underset{\\mathbf{x}}{\\text{minimize}}\n  E_{\\mathrm{avg}}(\\mathbf{x}) = E_0 + \\mathbf{s}_0^{\\mathsf{T}}\\mathbf{x} + \\tfrac{1}{2}\\mathbf{x}^{\\mathsf{T}}\\mathbf{A}\\mathbf{x} \\\\\n \\text{subject to}\n  \\mathbf{g}^{\\mathsf{T}}\\mathbf{x} = 0 \\\\\n   \\mathbf{h}^{\\mathsf{T}}\\mathbf{x} = 0\n\\end{aligned}\n$$\nSince $E_0$ is a constant, it does not affect the location of the minimum and can be ignored during optimization. The problem is a quadratic program with equality constraints. The method of Lagrange multipliers is the standard approach for such problems.\n\nWe define the Lagrangian function $\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda})$ with a vector of Lagrange multipliers $\\boldsymbol{\\lambda} = (\\lambda_1, \\lambda_2)^{\\mathsf{T}}$:\n$$\n\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda}) = E_{\\mathrm{avg}}(\\mathbf{x}) + \\lambda_1 (\\mathbf{g}^{\\mathsf{T}}\\mathbf{x}) + \\lambda_2 (\\mathbf{h}^{\\mathsf{T}}\\mathbf{x})\n$$\nThis can be written more compactly using the constraint matrix $\\mathbf{C} \\in \\mathbb{R}^{2 \\times N}$, whose rows are $\\mathbf{g}^{\\mathsf{T}}$ and $\\mathbf{h}^{\\mathsf{T}}$:\n$$\n\\mathcal{L}(\\mathbf{x}, \\boldsymbol{\\lambda}) = E_{\\mathrm{avg}}(\\mathbf{x}) + \\boldsymbol{\\lambda}^{\\mathsf{T}}\\mathbf{C}\\mathbf{x}\n$$\nThe first-order necessary conditions for a minimum $(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star})$ require the gradient of the Lagrangian with respect to both $\\mathbf{x}$ and $\\boldsymbol{\\lambda}$ to be zero.\nThe gradient with respect to $\\mathbf{x}$ is:\n$$\n\\nabla_{\\mathbf{x}}\\mathcal{L}(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star}) = \\nabla E_{\\mathrm{avg}}(\\mathbf{x}^{\\star}) + \\mathbf{C}^{\\mathsf{T}}\\boldsymbol{\\lambda}^{\\star} = \\mathbf{A}\\mathbf{x}^{\\star} + \\mathbf{s}_0 + \\mathbf{C}^{\\mathsf{T}}\\boldsymbol{\\lambda}^{\\star} = \\mathbf{0}\n$$\nThe gradient with respect to $\\boldsymbol{\\lambda}$ simply recovers the constraints:\n$$\n\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L}(\\mathbf{x}^{\\star}, \\boldsymbol{\\lambda}^{\\star}) = \\mathbf{C}\\mathbf{x}^{\\star} = \\mathbf{0}\n$$\nThese two vector equations can be rearranged into a single block matrix linear system, known as the Karush–Kuhn–Tucker (KKT) system, which is precisely what is provided in the problem statement:\n$$\n\\begin{bmatrix}\n\\mathbf{A}  \\mathbf{C}^{\\mathsf{T}}\\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x}^{\\star}\\\\\n\\boldsymbol{\\lambda}^{\\star}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\mathbf{s}_0\\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\nSince $\\mathbf{A}$ is given as positive-definite and the constraint vectors $\\mathbf{g}$ and $\\mathbf{h}$ are linearly independent (making $\\mathbf{C}$ full rank), the KKT matrix is non-singular, guaranteeing a unique solution for $\\mathbf{x}^{\\star}$ and $\\boldsymbol{\\lambda}^{\\star}$.\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\n\n1.  **Solve the KKT System**: Construct the $(N+2) \\times (N+2)$ KKT matrix and the $(N+2) \\times 1$ right-hand side vector using the provided parameters $\\mathbf{A}$, $\\mathbf{g}$, $\\mathbf{h}$, and $\\mathbf{s}_0$. Solve this linear system to obtain the solution vector, from which the MECI geometry $\\mathbf{x}^{\\star}$ (the first $N$ components) is extracted.\n\n2.  **Compute the MECI Gradient**: Evaluate the gradient of the average energy at the MECI geometry, $\\mathbf{s}^{\\star} = \\mathbf{s}(\\mathbf{x}^{\\star}) = \\mathbf{A}\\mathbf{x}^{\\star} + \\mathbf{s}_0$. From the KKT condition $\\mathbf{A}\\mathbf{x}^{\\star} + \\mathbf{s}_0 = -\\mathbf{C}^{\\mathsf{T}}\\boldsymbol{\\lambda}^{\\star}$, it is clear that $\\mathbf{s}^{\\star}$ must lie in the column space of $\\mathbf{C}^{\\mathsf{T}}$, which is the branching plane $\\mathcal{B} = \\mathrm{span}\\{\\mathbf{g}, \\mathbf{h}\\}$.\n\n3.  **Construct the Branching Plane Projector**: To decompose the gradient, we need the orthogonal projection operator $\\mathbf{P}_{\\mathcal{B}}$ onto the branching plane. This is constructed from an orthonormal basis for $\\mathcal{B}$. We form a matrix $\\mathbf{G} = [\\mathbf{g} | \\mathbf{h}]$ of size $N \\times 2$ and perform a thin QR factorization, $\\mathbf{G} = \\mathbf{Q}\\mathbf{R}$, where $\\mathbf{Q}$ is an $N \\times 2$ matrix with orthonormal columns spanning $\\mathcal{B}$. The projector is then given by $\\mathbf{P}_{\\mathcal{B}} = \\mathbf{Q}\\mathbf{Q}^{\\mathsf{T}}$. The projector onto the orthogonal complement is $\\mathbf{P}_{\\mathcal{B}}^{\\perp} = \\mathbf{I} - \\mathbf{P}_{\\mathcal{B}}$.\n\n4.  **Decompose the Gradient**: Compute the component of the gradient $\\mathbf{s}^{\\star}$ that lies within the branching plane: $\\mathbf{s}_{\\parallel}^{\\star} = \\mathbf{P}_{\\mathcal{B}}\\mathbf{s}^{\\star}$. As established in step $2$, we expect $\\mathbf{s}^{\\star}$ to already be in $\\mathcal{B}$, so theoretically $\\mathbf{s}_{\\parallel}^{\\star} = \\mathbf{s}^{\\star}$. The component orthogonal to the branching plane, $\\mathbf{s}_{\\perp}^{\\star} = \\mathbf{P}_{\\mathcal{B}}^{\\perp}\\mathbf{s}^{\\star}$, serves as a numerical diagnostic; its norm should be close to zero.\n\n5.  **Classify the MECI Topology**: The topology of the MECI is classified based on the magnitude of the gradient within the branching plane. We calculate the Euclidean norm $L = \\lVert \\mathbf{s}_{\\parallel}^{\\star} \\rVert_2$. If $L$ is greater than the specified threshold $\\tau = 10^{-10}$, the MECI is of \"sloped\" topology, encoded as the integer $1$. If $L \\le \\tau$, the gradient is considered to have vanished at the MECI, which corresponds to a \"peaked\" topology, encoded as the integer $0$. This procedure is applied systematically to all provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the MECI geometry and classifies its topology for a series of test cases\n    based on a local linear vibronic coupling model.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"N\": 3,\n            \"A\": np.diag([1.0, 1.0, 1.0]),\n            \"g\": np.array([1.0, 0.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 0.0]),\n            \"s0\": np.array([0.0, 0.0, 0.0]),\n        },\n        {\n            \"N\": 3,\n            \"A\": np.diag([1.0, 1.0, 1.0]),\n            \"g\": np.array([1.0, 1.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 1.0]),\n            \"s0\": np.array([0.5, -0.4, 0.1]),\n        },\n        {\n            \"N\": 4,\n            \"A\": np.diag([2.0, 1.5, 1.0, 0.5]),\n            \"g\": np.array([1.0, 0.0, 1.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 0.0, 1.0]),\n            \"s0\": np.array([0.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            \"N\": 4,\n            \"A\": np.array([\n                [2.0, 0.2, 0.0, 0.0],\n                [0.2, 1.5, 0.1, 0.0],\n                [0.0, 0.1, 1.2, 0.05],\n                [0.0, 0.0, 0.05, 0.8]\n            ]),\n            \"g\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"h\": np.array([0.0, 1.0, 1.0, 0.0]),\n            \"s0\": np.array([0.1, -0.2, 0.3, -0.05]),\n        },\n    ]\n\n    results = []\n    tau = 1e-10\n\n    for case in test_cases:\n        N = case[\"N\"]\n        A = case[\"A\"]\n        # Ensure vectors are column vectors for consistent matrix algebra\n        g = case[\"g\"].reshape(N, 1)\n        h = case[\"h\"].reshape(N, 1)\n        s0 = case[\"s0\"].reshape(N, 1)\n        \n        # 1. Formulate and solve the KKT linear system.\n        # Constraint matrix C\n        C = np.vstack([g.T, h.T])\n\n        # KKT matrix (block matrix)\n        KKT_matrix = np.block([\n            [A, C.T],\n            [C, np.zeros((2, 2))]\n        ])\n        \n        # Right-hand side vector\n        rhs = np.vstack([-s0, np.zeros((2, 1))])\n        \n        # Solve for [x_star^T, lambda_star^T]^T\n        solution = np.linalg.solve(KKT_matrix, rhs)\n        x_star = solution[:N]\n\n        # 2. Evaluate the average-energy gradient at the MECI.\n        s_star = A @ x_star + s0\n\n        # 3. Construct the projection operator P_B.\n        # Form matrix G whose columns [g, h] span the branching plane.\n        G = np.hstack([g, h])\n        # Orthonormalize the columns of G via QR decomposition.\n        Q, _ = np.linalg.qr(G)\n        # Projector onto the branching plane B.\n        P_B = Q @ Q.T\n        \n        # 4. Compute the component of the gradient within the branching plane.\n        s_parallel_star = P_B @ s_star\n\n        # 5. Classify the MECI topology.\n        # As a check, s_star should already be in the branching plane,\n        # so norm(s_parallel_star) should equal norm(s_star).\n        norm_s_parallel = np.linalg.norm(s_parallel_star)\n\n        if norm_s_parallel  tau:\n            classification = 1  # Sloped\n        else:\n            classification = 0  # Peaked\n            \n        results.append(classification)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2635932"}, {"introduction": "Simulating the journey of a molecular wavepacket through a conical intersection is key to predicting photochemical outcomes, but exact quantum dynamics simulations are computationally prohibitive for most systems. Semiclassical methods like trajectory surface hopping offer a practical alternative, but they struggle to correctly describe quantum coherence. This practical simulation challenges you to implement and compare several common \"decoherence correction\" schemes, demonstrating the pragmatic and crucial role these corrections play in obtaining physically realistic population dynamics [@problem_id:2635943].", "problem": "A two-mode linear vibronic coupling model for a conical intersection is defined in dimensionless form by the diabatic Hamiltonian\n$$\n\\hat{H}_{\\text{dia}}(Q_x,Q_y)=\n\\begin{pmatrix}\na\\,Q_x  b\\,Q_y\\\\\nb\\,Q_y  -a\\,Q_x\n\\end{pmatrix},\n$$\nwhere $Q_x$ and $Q_y$ are dimensionless nuclear coordinates, and $a$ and $b$ are dimensionless coupling slopes. The adiabatic energies are\n$$\nE_{\\pm}(Q_x,Q_y)=\\pm \\sqrt{(a\\,Q_x)^2+(b\\,Q_y)^2},\n$$\nand the adiabatic mixing angle is\n$$\n\\theta(Q_x,Q_y)=\\tfrac{1}{2}\\arctan2\\!\\big(b\\,Q_y,\\,a\\,Q_x\\big).\n$$\nConsider a classical straight-line nuclear trajectory parameterized by time $t$,\n$$\nQ_x(t)=v\\,t,\\qquad Q_y(t)=b_0,\n$$\nwith constant dimensionless velocity $v$ along $Q_x$ and an impact parameter $b_0$ along $Q_y$. Along this trajectory, the time-derivative of the adiabatic mixing angle (the scalar nonadiabatic coupling along the trajectory) is\n$$\ng(t)\\equiv \\frac{d\\theta}{dt}=\\frac{1}{2}\\,\\frac{a\\,b\\,\\big(Q_x \\dot{Q}_y-Q_y \\dot{Q}_x\\big)}{(a\\,Q_x)^2+(b\\,Q_y)^2}\n=-\\frac{1}{2}\\,\\frac{a\\,b\\,b_0\\,v}{(a\\,v\\,t)^2+(b\\,b_0)^2},\n$$\nsince $\\dot{Q}_x=v$ and $\\dot{Q}_y=0$. In the adiabatic representation, the time-dependent electronic Hamiltonian along the trajectory is\n$$\nH_{\\text{adi}}(t)=\n\\begin{pmatrix}\n- E(t)  -i\\,g(t)\\\\\ni\\,g(t)  E(t)\n\\end{pmatrix},\\qquad\nE(t)=\\sqrt{(a\\,v\\,t)^2+(b\\,b_0)^2}.\n$$\nLet $\\rho(t)$ be the $2\\times 2$ electronic density matrix. Under unitary dynamics generated by $H_{\\text{adi}}(t)$, it evolves as\n$$\n\\rho(t+\\Delta t)=U(t,\\Delta t)\\,\\rho(t)\\,U(t,\\Delta t)^{\\dagger},\\qquad\nU(t,\\Delta t)=\\exp\\!\\big(-i\\,H_{\\text{adi}}(t)\\,\\Delta t\\big).\n$$\nWe define three decoherence correction models commonly used with fewest switches surface hopping (FSSH), expressed here as phenomenological dephasing modifications to $\\rho(t)$ (applied after each unitary step):\n\n- Instantaneous decoherence (code $0$): set $\\rho_{12}\\leftarrow 0$ whenever $\\lvert g(t)\\rvertg_{\\text{cut}}$ and $t0$, leaving populations unchanged.\n- Augmented FSSH (code $1$): apply exponential dephasing $\\rho_{12}\\leftarrow \\rho_{12}\\,\\exp\\!\\big(-\\gamma_{\\text{AF}}(t)\\,\\Delta t\\big)$ with $\\gamma_{\\text{AF}}(t)=\\lvert g(t)\\rvert$.\n- Decay-of-mixing (code $2$): outside the coupling region, apply $\\rho_{12}\\leftarrow \\rho_{12}\\,\\exp\\!\\big(-\\gamma_{\\text{DM}}(t)\\,\\Delta t\\big)$ with $\\gamma_{\\text{DM}}(t)=\\alpha\\,\\Delta(t)$ when $\\lvert g(t)\\rvertg_{\\text{cut}}$, and $\\gamma_{\\text{DM}}(t)=0$ otherwise; here $\\Delta(t)=2\\,E(t)$.\n\nAssume initial condition $\\rho(-T)=\\begin{pmatrix}10\\\\00\\end{pmatrix}$, i.e., the system starts in the lower adiabatic state. All quantities are dimensionless. For fixed $a$, $b$, $v$, $b_0$, propagation interval $[-T,T_{\\text{end}}]$ with time step $\\Delta t$, and a set of target sampling times $\\{t_k\\}$, define the computed excited-state population samples as\n$$\nP_2^{(m)}(t_k)=\\rho_{22}^{(m)}(t_k),\n$$\nwhere $m\\in\\{0,1,2\\}$ denotes the decoherence model code.\n\nGiven a reference “benchmark” excited-state population profile $\\{P_2^{\\text{ref}}(t_k)\\}$ taken as a proxy for the outcome of the Multiconfiguration Time-Dependent Hartree (MCTDH) method, define the root-mean-square error for model $m$ over the sampling set as\n$$\n\\text{RMSE}_m=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\Big(P_2^{(m)}(t_k)-P_2^{\\text{ref}}(t_k)\\Big)^2}.\n$$\n\nYour task is to implement a program that, for each parameter set in the test suite below, computes $P_2^{(m)}(t_k)$ for $m\\in\\{0,1,2\\}$, evaluates $\\text{RMSE}_m$, and returns, for each case, the integer code $m^{\\star}$ that minimizes $\\text{RMSE}_m$ (in case of a tie, choose the smallest $m$). All computations must be carried out in the stated dimensionless units.\n\nUse the following constants for the dephasing models: $g_{\\text{cut}}=10^{-2}$ and $\\alpha=10^{-1}$.\n\nTest suite (each line is one case; the tuple elements are $(a,b,v,b_0,T,\\Delta t,[t_k\\text{-list}], [P_2^{\\text{ref}}(t_k)\\text{-list}])$):\n\n- Case A (moderate coupling, near-seam transit): $(a,b,v,b_0,T,\\Delta t)=($$1.0$$,$$0.8$$,$$1.0$$,$$0.3$$,$$5.0$$,$$0.002$$), target times $[\\, $$1.0$$, $$2.0$$, $$4.0$$ \\,]$, reference $[\\, $$0.27$$, $$0.33$$, $$0.34$$ \\,]$.\n- Case B (weak coupling): $(a,b,v,b_0,T,\\Delta t)=($$1.0$$,$$0.25$$,$$1.0$$,$$0.5$$,$$5.0$$,$$0.002$$), target times $[\\, $$1.0$$, $$2.0$$ \\,]$, reference $[\\, $$0.03$$, $$0.045$$ \\,]$.\n- Case C (stronger coupling, small impact parameter): $(a,b,v,b_0,T,\\Delta t)=($$1.0$$,$$1.2$$,$$1.0$$,$$0.05$$,$$5.0$$,$$0.002$$), target times $[\\, $$0.5$$, $$1.0$$, $$2.0$$ \\,]$, reference $[\\, $$0.40$$, $$0.48$$, $$0.49$$ \\,]$.\n\nFinal output format: Your program should produce a single line of output containing a list of three integers $[m_A^{\\star},m_B^{\\star},m_C^{\\star}]$ corresponding to the best model codes for cases A, B, and C, respectively, with no spaces, as a comma-separated list enclosed in square brackets (e.g., $[0,1,2]$). No other output is permitted.", "solution": "The core of the task is to simulate the time evolution of a $2 \\times 2$ electronic density matrix $\\rho(t)$ for a quantum system subjected to a time-dependent Hamiltonian, and to compare the outcomes of three different phenomenological decoherence models against a reference result. The objective is to find which model provides the best fit to the reference data for each given parameter set.\n\nThe methodology is based on numerical integration of the Liouville-von Neumann equation in the adiabatic representation. The total simulation interval for each case is from $t_{start} = -T$ to $t_{end} = T$. This interval is discretized into a uniform grid of time points $t_i = t_{start} + i \\cdot \\Delta t$, where $\\Delta t$ is the time step.\n\nLet the density matrix at time $t$ be $\\rho(t)$. The evolution over a small time step $\\Delta t$ is a two-part process: unitary evolution followed by a non-unitary decoherence correction.\n\n1.  **Unitary Evolution**:\n    The system evolves under the time-dependent adiabatic Hamiltonian:\n    $$\n    H_{\\text{adi}}(t)=\n    \\begin{pmatrix}\n    - E(t)  -i\\,g(t)\\\\\n    i\\,g(t)  E(t)\n    \\end{pmatrix}\n    $$\n    where the energy term is $E(t)=\\sqrt{(a\\,v\\,t)^2+(b\\,b_0)^2}$ and the nonadiabatic coupling is $g(t)=-\\frac{1}{2}\\,\\frac{a\\,b\\,b_0\\,v}{(a\\,v\\,t)^2+(b\\,b_0)^2}$.\n    Assuming the Hamiltonian is approximately constant over the small interval $[t, t+\\Delta t]$, the evolution of the density matrix is governed by:\n    $$\n    \\rho'(t+\\Delta t)=U(t, \\Delta t)\\,\\rho(t)\\,U(t, \\Delta t)^{\\dagger}\n    $$\n    The time-evolution operator, or propagator, is given by the matrix exponential:\n    $$\n    U(t, \\Delta t)=\\exp\\!\\big(-i\\,H_{\\text{adi}}(t)\\,\\Delta t\\big)\n    $$\n    This matrix exponential is computed numerically at each time step. For a $2 \\times 2$ matrix, analytical solutions exist, but a robust numerical algorithm, such as the one implemented in `scipy.linalg.expm`, is preferable to ensure stability and accuracy, especially in the context of a computational program. The initial condition for the simulation is $\\rho(-T) = \\begin{pmatrix}1  0 \\\\ 0  0 \\end{pmatrix}$, corresponding to the system being in the lower (ground) adiabatic electronic state.\n\n2.  **Decoherence Correction**:\n    After the unitary step, which yields an intermediate density matrix $\\rho'(t+\\Delta t)$, a non-unitary decoherence correction is applied according to one of three specified models, indexed by $m \\in \\{0, 1, 2\\}$. These corrections only affect the off-diagonal elements (the coherences) $\\rho_{12}$ and $\\rho_{21}$, leaving the diagonal elements (the populations) unchanged.\n\n    -   **Model $m=0$ (Instantaneous decoherence)**: The coherences are abruptly set to zero if the nonadiabatic coupling magnitude $\\lvert g(t) \\rvert$ falls below a threshold $g_{\\text{cut}} = 10^{-2}$ and the time $t$ is positive.\n        $$\n        \\rho_{12}(t+\\Delta t) \\leftarrow 0 \\quad \\text{if} \\quad \\lvert g(t)\\rvert  g_{\\text{cut}} \\text{ and } t  0\n        $$\n        The conjugate element $\\rho_{21}$ is also set to $0$ to maintain Hermiticity.\n\n    -   **Model $m=1$ (Augmented FSSH, AFSSH)**: The coherences are attenuated by an exponential factor at every time step. The decay rate is equal to the magnitude of the nonadiabatic coupling.\n        $$\n        \\rho_{12}(t+\\Delta t) \\leftarrow \\rho'_{12}(t+\\Delta t) \\exp\\!\\big( -\\lvert g(t) \\rvert \\Delta t \\big)\n        $$\n\n    -   **Model $m=2$ (Decay-of-mixing, DM)**: The coherences are attenuated by an exponential factor only when the system is \"outside the coupling region,\" which is defined by the condition $\\lvert g(t) \\rvert  g_{\\text{cut}}$. The decay rate is proportional to the energy gap between the adiabatic states, $\\Delta(t) = 2E(t)$.\n        $$\n        \\rho_{12}(t+\\Delta t) \\leftarrow \\rho'_{12}(t+\\Delta t) \\exp\\!\\big( - \\gamma_{\\text{DM}}(t) \\Delta t \\big)\n        $$\n        where $\\gamma_{\\text{DM}}(t) = \\alpha \\Delta(t)$ if $\\lvert g(t)\\rvert  g_{\\text{cut}}$ and $\\gamma_{\\text{DM}}(t) = 0$ otherwise. The constant $\\alpha$ is given as $10^{-1}$.\n\n3.  **Simulation and Analysis**:\n    For each test case (A, B, C), three separate simulations are performed, one for each decoherence model $m \\in \\{0, 1, 2\\}$.\n    The simulation proceeds from $t=-T$ to $t=T$ with time step $\\Delta t$. At each of the specified target times $\\{t_k\\}$, the excited-state population $P_2^{(m)}(t_k) = \\rho_{22}^{(m)}(t_k)$ is recorded.\n    After the simulation, the Root-Mean-Square Error (RMSE) is calculated for each model:\n    $$\n    \\text{RMSE}_m=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\Big(P_2^{(m)}(t_k)-P_2^{\\text{ref}}(t_k)\\Big)^2}\n    $$\n    where $\\{P_2^{\\text{ref}}(t_k)\\}$ are the provided reference populations and $K$ is the number of target times.\n    Finally, for each test case, the model index $m^{\\star}$ that yields the minimum RMSE is identified. If a tie occurs, the model with the smallest index is chosen. The indices $m^{\\star}$ for cases A, B, and C are collected and presented as the final result.\n\nThe accompanying Python code implements this entire procedure. It iterates through the test cases, runs the described simulation for each of the three models, computes the RMSEs, and determines the best-fitting model for each case.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the best decoherence model for three test cases\n    of nonadiabatic dynamics at a conical intersection.\n    \"\"\"\n\n    # Define constants from the problem statement\n    G_CUT = 1e-2\n    ALPHA = 1e-1\n\n    # Test suite: (a, b, v, b_0, T, dt, target_times, ref_pops)\n    test_cases = [\n        # Case A (moderate coupling, near-seam transit)\n        (1.0, 0.8, 1.0, 0.3, 5.0, 0.002, [1.0, 2.0, 4.0], [0.27, 0.33, 0.34]),\n        # Case B (weak coupling)\n        (1.0, 0.25, 1.0, 0.5, 5.0, 0.002, [1.0, 2.0], [0.03, 0.045]),\n        # Case C (stronger coupling, small impact parameter)\n        (1.0, 1.2, 1.0, 0.05, 5.0, 0.002, [0.5, 1.0, 2.0], [0.40, 0.48, 0.49]),\n    ]\n\n    best_model_indices = []\n\n    for case_params in test_cases:\n        a, b, v, b0, T, dt, target_times, ref_pops = case_params\n        \n        # Set up the time grid for the simulation\n        t_end = T\n        num_steps = int( (t_end - (-T)) / dt ) + 1\n        t_grid = np.linspace(-T, t_end, num_steps)\n\n        # Find the indices corresponding to target times for efficient sampling\n        target_indices = [np.argmin(np.abs(t_grid - t_k)) for t_k in target_times]\n\n        rmses = []\n        for model_code in range(3):\n            # Initial condition: system in the lower adiabatic state\n            rho = np.array([[1.0, 0.0], \n                            [0.0, 0.0]], dtype=np.complex128)\n            \n            sampled_pops = []\n            target_sample_idx = 0\n\n            # Propagate the density matrix in time\n            for i, t in enumerate(t_grid[:-1]):\n                # Calculate time-dependent quantities\n                avt = a * v * t\n                bb0 = b * b0\n                \n                # Energy E(t)\n                E_t = np.sqrt(avt**2 + bb0**2)\n                \n                # Nonadiabatic coupling g(t)\n                denom = avt**2 + bb0**2\n                if denom == 0:\n                    # This case is avoided by problem parameters but good practice\n                    g_t = 0.0\n                else:\n                    g_t = -0.5 * a * b * b0 * v / denom\n\n                # Construct the adiabatic Hamiltonian\n                H_adi = np.array([[-E_t, -1j * g_t],\n                                  [1j * g_t,  E_t]], dtype=np.complex128)\n\n                # 1. Unitary evolution step\n                U = expm(-1j * H_adi * dt)\n                rho = U @ rho @ U.conj().T\n\n                # 2. Decoherence correction step\n                if model_code == 0:  # Instantaneous decoherence\n                    if abs(g_t)  G_CUT and t  0:\n                        rho[0, 1] = 0.0\n                        rho[1, 0] = 0.0\n                elif model_code == 1:  # Augmented FSSH (AFSSH)\n                    gamma_af = abs(g_t)\n                    dephasing_factor = np.exp(-gamma_af * dt)\n                    rho[0, 1] *= dephasing_factor\n                    rho[1, 0] *= dephasing_factor\n                elif model_code == 2:  # Decay-of-mixing (DM)\n                    if abs(g_t)  G_CUT:\n                        Delta_t = 2.0 * E_t\n                        gamma_dm = ALPHA * Delta_t\n                        dephasing_factor = np.exp(-gamma_dm * dt)\n                        rho[0, 1] *= dephasing_factor\n                        rho[1, 0] *= dephasing_factor\n\n                # Sample population at the next time step t+dt (index i+1)\n                if target_sample_idx  len(target_indices) and (i + 1) == target_indices[target_sample_idx]:\n                    sampled_pops.append(rho[1, 1].real)\n                    target_sample_idx += 1\n            \n            # Calculate RMSE for the current model\n            sampled_pops = np.array(sampled_pops)\n            ref_pops_arr = np.array(ref_pops)\n            rmse = np.sqrt(np.mean((sampled_pops - ref_pops_arr)**2))\n            rmses.append(rmse)\n\n        # Find the model with the minimum RMSE\n        best_model_indices.append(np.argmin(rmses))\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, best_model_indices))}]\")\n\nsolve()\n```", "id": "2635943"}]}