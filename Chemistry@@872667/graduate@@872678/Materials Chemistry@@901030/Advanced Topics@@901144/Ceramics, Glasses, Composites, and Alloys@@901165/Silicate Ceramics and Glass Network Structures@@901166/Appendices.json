{"hands_on_practices": [{"introduction": "This first practice introduces a cornerstone of glass science: the random bonding model. By applying simple stoichiometric rules, you will learn to calculate how the addition of a network modifier like $\\mathrm{Na_2O}$ systematically depolymerizes the silica network. This exercise demonstrates how to predict the distribution of fundamental structural units, known as $Q^n$ species, directly from the glass composition, providing a powerful link between chemistry and structure. [@problem_id:2522556]", "problem": "A binary sodium oxide–silica glass of composition $\\mathrm{Na_2O}$–$\\mathrm{SiO_2}$ is specified on the oxide basis by a sodium oxide content of $y$ mol$\\%$ $\\mathrm{Na_2O}$ and $(100 - y)$ mol$\\%$ $\\mathrm{SiO_2}$, with $0y100$. Consider a continuous random network of corner-sharing $\\mathrm{SiO_4}$ tetrahedra in which all oxygens are either bridging oxygens (shared by two tetrahedra) or non-bridging oxygens (terminating one tetrahedron), and all sodium cations ($\\mathrm{Na}^+$) only charge-compensate non-bridging oxygens. Assume there are no edge-sharing tetrahedra, no tricluster oxygens, and no homopolar bonds. Define $Q^n$ species as tetrahedra with $n$ bridging oxygens.\n\nStarting only from stoichiometric oxygen and bond-counting constraints and the definition of $Q^n$, do the following:\n- Convert the composition to mole fractions.\n- Derive the average number of non-bridging oxygens per tetrahedron, $\\mathrm{NBO/T}$, in terms of $y$.\n- From this, obtain the mean number of bridging oxygens per tetrahedron, $\\langle n \\rangle$.\n- Adopt a maximum-entropy random-bonding model in which the four corners of a tetrahedron are independently bridging with probability $p$ that is fixed self-consistently by $\\langle n \\rangle$.\n\nUnder these assumptions, determine a closed-form analytic expression for the predicted equilibrium mole fraction of $Q^3$ species as a function of $y$ (expressed in mol$\\%$). Report the final expression simplified in terms of $y$ and integers only. The fraction is dimensionless; no units are required for the answer.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It describes a standard theoretical model for silicate glass structure, providing all necessary definitions and constraints for a unique solution. There are no contradictions, ambiguities, or violations of physical principles. We may proceed with the solution.\n\nFirst, we must establish the relationship between the composition, given in mol$\\%$ $y$, and the network structure. The composition is given as $y$ mol$\\%$ $\\mathrm{Na_2O}$ and $(100 - y)$ mol$\\%$ $\\mathrm{SiO_2}$. We can express this using mole fractions. Let $x_{\\mathrm{Na_2O}}$ be the mole fraction of $\\mathrm{Na_2O}$ and $x_{\\mathrm{SiO_2}}$ be the mole fraction of $\\mathrm{SiO_2}$.\n$$ x_{\\mathrm{Na_2O}} = \\frac{y}{100} $$\n$$ x_{\\mathrm{SiO_2}} = \\frac{100-y}{100} $$\nThe structural units are $\\mathrm{SiO_4}$ tetrahedra, so the number of tetrahedra, $N_{\\mathrm{T}}$, is proportional to the moles of $\\mathrm{SiO_2}$. The modifier oxide, $\\mathrm{Na_2O}$, alters the network. Each mole of $\\mathrm{Na_2O}$ introduces one mole of oxide ions, $\\mathrm{O}^{2-}$, which break the network according to the reaction:\n$$ \\equiv \\mathrm{Si}-\\mathrm{O}-\\mathrm{Si} \\equiv + \\mathrm{O}^{2-} \\rightarrow 2 (\\equiv \\mathrm{Si}-\\mathrm{O}^{-}) $$\nThis reaction shows that for each mole of $\\mathrm{O}^{2-}$ added (from one mole of $\\mathrm{Na_2O}$), one bridging oxygen ($\\mathrm{BO}$) is consumed and two non-bridging oxygens ($\\mathrm{NBO}$) are created. The two $\\mathrm{Na}^{+}$ cations from $\\mathrm{Na_2O}$ provide charge compensation for the two resulting $\\mathrm{NBOs}$.\n\nThe average number of non-bridging oxygens per tetrahedron, $\\mathrm{NBO/T}$, is the ratio of the total number of $\\mathrm{NBOs}$ to the total number of tetrahedra. Based on the stoichiometry of the reaction, the number of $\\mathrm{NBOs}$ is twice the number of moles of $\\mathrm{Na_2O}$, and the number of tetrahedra is equal to the number of moles of $\\mathrm{SiO_2}$.\n$$ \\mathrm{NBO/T} = \\frac{2 \\times (\\text{moles of } \\mathrm{Na_2O})}{(\\text{moles of } \\mathrm{SiO_2})} = \\frac{2 x_{\\mathrm{Na_2O}}}{x_{\\mathrm{SiO_2}}} $$\nSubstituting the expressions in terms of $y$:\n$$ \\mathrm{NBO/T} = \\frac{2 (y/100)}{(100-y)/100} = \\frac{2y}{100-y} $$\nEach tetrahedron has $4$ oxygen corners. These corners can either be part of a bridging linkage or a non-bridging termination. For a single tetrahedron with $n$ bridging oxygens, it must have $4-n$ non-bridging oxygens. Averaging over all tetrahedra in the network, the sum of the mean number of bridging oxygens per tetrahedron, $\\langle n \\rangle$, and the mean number of non-bridging oxygens per tetrahedron, $\\mathrm{NBO/T}$, must equal $4$.\n$$ \\langle n \\rangle + \\mathrm{NBO/T} = 4 $$\nFrom this, we can derive the mean number of bridging oxygens per tetrahedron, $\\langle n \\rangle$, as a function of $y$:\n$$ \\langle n \\rangle = 4 - \\mathrm{NBO/T} = 4 - \\frac{2y}{100-y} = \\frac{4(100-y) - 2y}{100-y} = \\frac{400 - 4y - 2y}{100-y} = \\frac{400 - 6y}{100-y} $$\nThe problem asks us to adopt a random-bonding model. In this model, the distribution of $Q^n$ species (tetrahedra with $n$ bridging oxygens) is assumed to follow a binomial distribution. The probability that any of the four corners of a tetrahedron is a bridging oxygen is $p$, and this probability is independent for each corner. The mole fraction of $Q^n$ species, which we denote as $f(Q^n)$, is given by:\n$$ f(Q^n) = \\binom{4}{n} p^n (1-p)^{4-n} $$\nThe model is made self-consistent by requiring that the mean of this distribution, $\\langle n \\rangle$, is equal to the stoichiometrically-derived value. The mean of a binomial distribution with parameters $N=4$ and probability $p$ is $4p$.\n$$ \\langle n \\rangle = 4p $$\nThis allows us to determine the probability $p$ in terms of the composition $y$:\n$$ p = \\frac{\\langle n \\rangle}{4} = \\frac{1}{4} \\left( \\frac{400 - 6y}{100-y} \\right) = \\frac{100 - \\frac{3}{2}y}{100-y} = \\frac{200 - 3y}{2(100-y)} = \\frac{200 - 3y}{200 - 2y} $$\nThe probability of a corner being a non-bridging oxygen is then $1-p$:\n$$ 1-p = 1 - \\frac{200 - 3y}{200 - 2y} = \\frac{(200 - 2y) - (200 - 3y)}{200 - 2y} = \\frac{y}{200 - 2y} $$\nWe are asked to find the mole fraction of $Q^3$ species. Using the binomial formula for $n=3$:\n$$ f(Q^3) = \\binom{4}{3} p^3 (1-p)^{4-3} = 4 p^3 (1-p) $$\nSubstituting the expressions for $p$ and $1-p$ in terms of $y$:\n$$ f(Q^3) = 4 \\left( \\frac{200 - 3y}{200 - 2y} \\right)^3 \\left( \\frac{y}{200 - 2y} \\right) $$\nNow we simplify this expression:\n$$ f(Q^3) = \\frac{4y(200 - 3y)^3}{(200 - 2y)^4} = \\frac{4y(200 - 3y)^3}{(2(100 - y))^4} = \\frac{4y(200 - 3y)^3}{16(100 - y)^4} $$\nThe final simplified expression for the mole fraction of $Q^3$ species as a function of mol$\\%$ $\\mathrm{Na_2O}$, $y$, is:\n$$ f(Q^3) = \\frac{y(200 - 3y)^3}{4(100 - y)^4} $$\nThis expression is valid for the domain $0  y  100$, as specified. It is dimensionless and expressed solely in terms of $y$ and integers.", "answer": "$$ \\boxed{\\frac{y(200 - 3y)^3}{4(100 - y)^4}} $$", "id": "2522556"}, {"introduction": "Building on the binary silicate model, this problem explores the more complex and technologically significant realm of aluminosilicate glasses. Here, modifier cations play a dual role: they first act as charge compensators for tetrahedrally-coordinated aluminum before creating non-bridging oxygens. Mastering this charge-balance calculation is essential for accurately predicting the network connectivity ($\\mathrm{NBO/T}$) and related properties of most commercial and natural glasses. [@problem_id:2522549]", "problem": "A multicomponent aluminosilicate glass has the following composition given in molar percent: $\\mathrm{SiO_2}$ $=$ $64$, $\\mathrm{Al_2O_3}$ $=$ $12$, $\\mathrm{Na_2O}$ $=$ $10$, $\\mathrm{CaO}$ $=$ $8$, and $\\mathrm{MgO}$ $=$ $6$. Assume an ideal random network in which all aluminum enters the network as tetrahedrally coordinated $\\mathrm{AlO_4^-}$ units when sufficient modifier charge is available, all modifier cations ($\\mathrm{Na^+}$, $\\mathrm{Ca^{2+}}$, $\\mathrm{Mg^{2+}}$) first charge-balance $\\mathrm{AlO_4^-}$ units, and any remaining modifier positive charge creates non-bridging oxygens. Ignore the possibility of other network formers or higher coordination states of aluminum under these conditions.\n\nStarting only from atom balance and charge neutrality, and using the definition that non-bridging oxygens per tetrahedrally coordinated network former (NBO/T) is the ratio of the number of non-bridging oxygen anions to the total number of tetrahedrally coordinated network-former cations, carry out the following:\n\n- Determine the fraction (on a positive charge equivalent basis) of modifier cation charge used to charge-balance $\\mathrm{AlO_4^-}$ versus the fraction that goes to create non-bridging oxygens.\n- Hence compute $\\mathrm{NBO/T}$ for this composition, where the tetrahedrally coordinated network formers are $\\mathrm{Si}$ and $\\mathrm{Al}$.\n\nReport only the final value of $\\mathrm{NBO/T}$ as your answer. If it can be expressed exactly as a rational number, give the exact value; otherwise round to four significant figures. The quantity $\\mathrm{NBO/T}$ is dimensionless; do not include units.", "solution": "The problem presented is a standard exercise in the structural chemistry of silicate glasses and is valid. It is scientifically grounded in the established models of glass structure, well-posed with sufficient and consistent data, and objectively formulated. I will proceed with the solution.\n\nThe analysis is premised on atom and charge balance within the glass network. We will consider a basis of $100$ moles of the oxide components as given by the molar percentages.\n\nFirst, we determine the molar quantities of the constituent cations from the given composition:\n- Moles of $\\mathrm{SiO_2} = 64$. This provides $64$ moles of $\\mathrm{Si}^{4+}$ cations.\n- Moles of $\\mathrm{Al_2O_3} = 12$. This provides $2 \\times 12 = 24$ moles of $\\mathrm{Al}^{3+}$ cations.\n- Moles of $\\mathrm{Na_2O} = 10$. This provides $2 \\times 10 = 20$ moles of $\\mathrm{Na}^{+}$ cations.\n- Moles of $\\mathrm{CaO} = 8$. This provides $8$ moles of $\\mathrm{Ca}^{2+}$ cations.\n- Moles of $\\mathrm{MgO} = 6$. This provides $6$ moles of $\\mathrm{Mg}^{2+}$ cations.\n\nThe problem defines the tetrahedrally coordinated network-former cations, T, as silicon and aluminum. The total molar quantity of these cations, denoted as $[T]$, is the sum of the moles of silicon and aluminum.\n$$\n[T] = [\\mathrm{Si}] + [\\mathrm{Al}] = 64 + 24 = 88 \\text{ moles}\n$$\n\nNext, we evaluate the charge balance requirements. According to the problem statement, $\\mathrm{Al}^{3+}$ substitutes for $\\mathrm{Si}^{4+}$ in the tetrahedral network. This substitution creates a local charge deficit of $-1$ for each aluminum atom incorporated into an $(\\mathrm{AlO_4})$ tetrahedron. Therefore, each mole of $\\mathrm{Al}^{3+}$ in the network requires one mole of positive charge for compensation.\n- Moles of $\\mathrm{Al}^{3+}$ to be charge-compensated $= 24$.\n- Required positive charge for aluminum compensation $= 24$ moles of charge.\n\nThis charge compensation is provided by the network modifier cations: $\\mathrm{Na}^{+}$, $\\mathrm{Ca}^{2+}$, and $\\mathrm{Mg}^{2+}$. We calculate the total available positive charge from these modifiers. The charge contribution is the molar amount of the ion multiplied by its valency.\n- Charge from $\\mathrm{Na}^{+}$: $1 \\times [\\mathrm{Na}^{+}] = 1 \\times 20 = 20$ moles of charge.\n- Charge from $\\mathrm{Ca}^{2+}$: $2 \\times [\\mathrm{Ca}^{2+}] = 2 \\times 8 = 16$ moles of charge.\n- Charge from $\\mathrm{Mg}^{2+}$: $2 \\times [\\mathrm{Mg}^{2+}] = 2 \\times 6 = 12$ moles of charge.\n\nThe total modifier positive charge available is:\n$$\n[\\text{Modifier Charge}]_{\\text{total}} = 20 + 16 + 12 = 48 \\text{ moles of charge}\n$$\n\nThe problem dictates a hierarchy for charge distribution: modifier cations first balance the $(\\mathrm{AlO_4})^{-}$ units.\n- Available modifier charge ($48$ moles) is greater than the charge required for aluminum compensation ($24$ moles). This confirms the assumption that all aluminum enters the network as $(\\mathrm{AlO_4})^{-}$ is satisfied.\n\nThe fraction of modifier charge used to balance aluminum is therefore $\\frac{24}{48} = \\frac{1}{2}$. The remaining modifier charge is used to create non-bridging oxygens (NBOs).\n- Remaining modifier charge $= [\\text{Modifier Charge}]_{\\text{total}} - (\\text{Charge for Al-compensation})$\n$$\n\\text{Remaining modifier charge} = 48 - 24 = 24 \\text{ moles of charge}\n$$\nThis answers the first part of the problem's internal query; the charge is split equally between Al-compensation and NBO creation.\n\nThe creation of a non-bridging oxygen involves the breaking of a bridging $\\mathrm{T-O-T}$ bond, resulting in a terminal oxygen with a formal charge of $-1$ ($\\mathrm{T-O^-}$), which is balanced by one unit of positive charge from a modifier cation. For example, $\\mathrm{O}^{2-} + \\equiv\\mathrm{T-O-T}\\equiv \\rightarrow 2(\\equiv\\mathrm{T-O^-})$. The two negative charges on the two NBOs formed are balanced by two positive charges from modifiers (e.g., $2\\mathrm{Na}^+$ or $1\\mathrm{Ca}^{2+}$). Thus, the number of moles of NBOs is numerically equal to the moles of positive charge from modifiers that are not used for aluminum compensation.\n$$\n[\\mathrm{NBO}] = \\text{Remaining modifier charge} = 24 \\text{ moles}\n$$\n\nFinally, we compute the quantity $\\mathrm{NBO/T}$, which is the ratio of the number of non-bridging oxygens to the total number of tetrahedrally coordinated network-former cations.\n$$\n\\mathrm{NBO/T} = \\frac{[\\mathrm{NBO}]}{[T]} = \\frac{24}{88}\n$$\nThis fraction simplifies as follows:\n$$\n\\frac{24}{88} = \\frac{12}{44} = \\frac{6}{22} = \\frac{3}{11}\n$$\nThe result is an exact rational number, as requested.", "answer": "$$\\boxed{\\frac{3}{11}}$$", "id": "2522549"}, {"introduction": "This final practice moves from analytical models to the direct analysis of atomic-scale data, a core skill in modern computational materials science. You will process a simulated atomic configuration to extract key structural signatures, including radial and angular distribution functions, and the $Q^n$ speciation. This exercise bridges the gap between theoretical concepts and their concrete measurement, allowing you to verify structural models by analyzing the geometry of the network itself. [@problem_id:2522514]", "problem": "Consider a sodium silicate glassy network modeled at the atomic scale under periodic boundary conditions. You are given two synthetic but scientifically realistic molecular configurations (treated as two separate test cases), each consisting of a single frame with atomic positions for silicon, oxygen, and sodium species inside a cubic simulation cell of edge length $L_{\\mathrm{box}}$ in ångströms (Å). Your task is to compute, from first principles, for each test case: (i) partial radial distribution functions, (ii) angular distributions, and (iii) $Q^n$ speciation, and then compare these to benchmark values motivated by experimental observations and stoichiometric constraints.\n\nFoundational definitions and requirements:\n\n1. Periodic boundary conditions must be applied using the minimum-image convention. For any displacement vector $\\Delta \\mathbf{r}$ between two atoms along one Cartesian coordinate with box length $L_{\\mathrm{box}}$, the minimum-image component is $\\Delta r^\\prime = \\Delta r - L_{\\mathrm{box}} \\,\\mathrm{round}(\\Delta r / L_{\\mathrm{box}})$. The Euclidean distance is then $r = \\lVert \\Delta \\mathbf{r}^\\prime \\rVert$.\n\n2. The partial radial distribution function $g_{\\alpha\\beta}(r)$ for species $\\alpha$ around species $\\beta$ is defined as\n$$\ng_{\\alpha\\beta}(r) = \\frac{1}{N_\\alpha\\,\\rho_\\beta}\\,\\frac{1}{4\\pi r^2 \\Delta r}\\,\\sum_{i \\in \\alpha} \\sum_{j \\in \\beta,\\, j \\neq i} \\mathbf{1}\\{r_{ij} \\in [r, r+\\Delta r)\\},\n$$\nwhere $N_\\alpha$ is the number of atoms of type $\\alpha$, $\\rho_\\beta = N_\\beta/V$ is the number density of species $\\beta$, $V = L_{\\mathrm{box}}^3$ is the volume, $\\Delta r$ is the radial bin width, and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. This definition holds for both $\\alpha \\neq \\beta$ and $\\alpha = \\beta$ (excluding self-pairs when $\\alpha=\\beta$).\n\n3. Angular distributions are required for the intratetrahedral oxygen–silicon–oxygen angle and the intertetrahedral silicon–oxygen–silicon angle:\n   - For oxygen–silicon–oxygen, $P_{\\mathrm{O\\!-\\!Si\\!-\\!O}}(\\theta)$, each angle $\\theta$ at a silicon atom is computed between vectors from a silicon to two distinct oxygen neighbors bonded to it within a cutoff $r_{\\mathrm{c}}^{\\mathrm{SiO}}$.\n   - For silicon–oxygen–silicon, $P_{\\mathrm{Si\\!-\\!O\\!-\\!Si}}(\\theta)$, each angle $\\theta$ at an oxygen is computed between vectors from that oxygen to two distinct silicon neighbors within $r_{\\mathrm{c}}^{\\mathrm{SiO}}$.\n   The angle is given by\n   $$\n   \\theta = \\arccos\\!\\left(\\frac{\\mathbf{u}\\cdot\\mathbf{v}}{\\lVert \\mathbf{u}\\rVert\\,\\lVert \\mathbf{v}\\rVert}\\right),\n   $$\n   converted to degrees. Use $r_{\\mathrm{c}}^{\\mathrm{SiO}} = 2.10\\,\\mathrm{\\AA}$.\n\n4. Bridging oxygen (BO) and non-bridging oxygen (NBO) are defined by silicon coordination: an oxygen bonded to exactly two silicon atoms (within $r_{\\mathrm{c}}^{\\mathrm{SiO}}$) is a BO; bonded to exactly one silicon is an NBO. For each silicon, $Q^n$ is defined as the number $n$ of BO connected to that silicon (i.e., $n \\in \\{0,1,2,3,4\\}$). The $Q^n$ distribution is the histogram of $n$ over all silicon atoms, and the average $Q$-index is $\\bar{n} = \\frac{1}{N_{\\mathrm{Si}}}\\sum_{\\mathrm{Si}} n$.\n\n5. Stoichiometric benchmark for average $Q$-index in alkali silicates: assuming each sodium cation charge-balances one NBO, the average number of bridging oxygens per silicon satisfies\n$$\n\\bar{n}_{\\mathrm{bench}} = 4 - \\frac{N_{\\mathrm{Na}}}{N_{\\mathrm{Si}}}.\n$$\n\n6. Benchmarks to compare your computed structural metrics against:\n   - First peak position of $g_{\\mathrm{SiO}}(r)$ near $1.62\\,\\mathrm{\\AA}$.\n   - First peak position of $g_{\\mathrm{OO}}(r)$ near $2.62\\,\\mathrm{\\AA}$.\n   - First peak position of $g_{\\mathrm{NaO}}(r)$ near $2.35\\,\\mathrm{\\AA}$.\n   - Peak of $P_{\\mathrm{O\\!-\\!Si\\!-\\!O}}(\\theta)$ near $109.5\\,\\mathrm{deg}$.\n   - Peak of $P_{\\mathrm{Si\\!-\\!O\\!-\\!Si}}(\\theta)$ near $140\\,\\mathrm{deg}$.\n   - Average $Q$-index $\\bar{n}$ near $\\bar{n}_{\\mathrm{bench}}$ as above.\n\n7. Numerical parameters to be used:\n   - Distances must be in ångströms, angles in degrees.\n   - Use radial bin width $\\Delta r = 0.005\\,\\mathrm{\\AA}$ and maximum distance $r_{\\max} = 6.0\\,\\mathrm{\\AA}$.\n   - Use angular bin width $\\Delta \\theta = 0.5\\,\\mathrm{deg}$ over $\\theta \\in [0,180]\\,\\mathrm{deg}$.\n\n8. Decision logic per test case: define boolean flags that evaluate to true if the computed metric agrees with the benchmark within the indicated tolerances:\n   - $\\lvert r_{\\mathrm{peak}}^{\\mathrm{SiO}} - 1.62\\rvert  0.05\\,\\mathrm{\\AA}$,\n   - $\\lvert r_{\\mathrm{peak}}^{\\mathrm{OO}} - 2.62\\rvert  0.12\\,\\mathrm{\\AA}$,\n   - $\\lvert r_{\\mathrm{peak}}^{\\mathrm{NaO}} - 2.35\\rvert  0.12\\,\\mathrm{\\AA}$,\n   - $\\lvert \\theta_{\\mathrm{peak}}^{\\mathrm{O\\!-\\!Si\\!-\\!O}} - 109.5\\rvert  3.0\\,\\mathrm{deg}$,\n   - $\\lvert \\theta_{\\mathrm{peak}}^{\\mathrm{Si\\!-\\!O\\!-\\!Si}} - 140.0\\rvert  10.0\\,\\mathrm{deg}$,\n   - $\\lvert \\bar{n} - \\bar{n}_{\\mathrm{bench}}\\rvert  0.01$.\n   The test case result is true only if all six conditions are true.\n\nTest suite specification (two configurations; all coordinates in ångströms; angles in degrees; cubic box with $L_{\\mathrm{box}} = 30.0$):\n\nEach configuration is constructed algorithmically to encode physically meaningful local structures:\n\n- Shared constants used in both cases:\n  - Ideal silicon–oxygen bond length $L_{\\mathrm{SiO}} = 1.62$.\n  - Target silicon–oxygen–silicon angle at a bridging oxygen $\\theta_{\\mathrm{Si\\!-\\!O\\!-\\!Si}} = 140.0$.\n  - Canonical tetrahedral directions $\\{\\mathbf{d}_k\\}_{k=1}^4 = \\{\\frac{(1,1,1)}{\\sqrt{3}}, \\frac{(1,-1,-1)}{\\sqrt{3}}, \\frac{(-1,1,-1)}{\\sqrt{3}}, \\frac{(-1,-1,1)}{\\sqrt{3}}\\}$.\n  - For a silicon at position $\\mathbf{S}$ bonded to an oxygen at $\\mathbf{O}$, let $\\hat{\\mathbf{t}} = \\frac{\\mathbf{O}-\\mathbf{S}}{\\lVert \\mathbf{O}-\\mathbf{S}\\rVert}$ denote the unit bond direction. The other three oxygen neighbors (non-bridging oxygens) are placed at $\\mathbf{S} + L_{\\mathrm{SiO}}\\,\\mathbf{R}\\mathbf{d}_k$ for the three $\\mathbf{d}_k$ not chosen for the bridging direction, where $\\mathbf{R}$ is the rotation that maps a reference direction $\\mathbf{d}_{\\mathrm{ref}}=\\frac{(1,1,1)}{\\sqrt{3}}$ onto $-\\hat{\\mathbf{t}}$ via Rodrigues' formula. This construction ensures local oxygen–silicon–oxygen angles near $109.47\\,\\mathrm{deg}$ for the non-bridging neighbors.\n  - For each non-bridging oxygen at $\\mathbf{O}$ bonded to a silicon at $\\mathbf{S}$, place one sodium at $\\mathbf{O} - L_{\\mathrm{NaO}}\\,\\frac{\\mathbf{S}-\\mathbf{O}}{\\lVert \\mathbf{S}-\\mathbf{O}\\rVert}$ with $L_{\\mathrm{NaO}} = 2.35$.\n\n- Test case $1$ (two corner-sharing tetrahedra with one bridging oxygen):\n  - Place a single bridging oxygen at the origin $\\mathbf{O}_{\\mathrm{b}} = (0,0,0)$.\n  - Place two silicon atoms at distance $L_{\\mathrm{SiO}}$ from the origin such that the angle at the oxygen between vectors to the two silicons is $\\theta_{\\mathrm{Si\\!-\\!O\\!-\\!Si}} = 140.0\\,\\mathrm{deg}$. In the $xy$-plane, place $\\mathbf{S}_1 = L_{\\mathrm{SiO}}(\\cos 70^\\circ, \\sin 70^\\circ, 0)$ and $\\mathbf{S}_2 = L_{\\mathrm{SiO}}(\\cos(-70^\\circ), \\sin(-70^\\circ), 0)$.\n  - Around each silicon, construct three non-bridging oxygens using the tetrahedral rotation rule above, with the reference direction mapped onto the bond toward the bridging oxygen.\n  - Place one sodium per non-bridging oxygen as specified.\n  - This yields $N_{\\mathrm{Si}}=2$, $N_{\\mathrm{O}}=7$, $N_{\\mathrm{Na}}=6$.\n\n- Test case $2$ (a three-tetrahedra chain with two bridging oxygens):\n  - First bridge: place $\\mathbf{O}_{12} = (0,0,0)$. Place $\\mathbf{S}_2 = L_{\\mathrm{SiO}}(\\cos 70^\\circ, \\sin 70^\\circ, 0)$ and $\\mathbf{S}_1 = L_{\\mathrm{SiO}}(\\cos(-70^\\circ), \\sin(-70^\\circ), 0)$.\n  - Around $\\mathbf{S}_2$, compute the tetrahedral rotation that maps the reference direction onto the bond toward $\\mathbf{O}_{12}$. Select one of the remaining three rotated tetrahedral directions $\\hat{\\mathbf{t}}_{23}$ and place the second bridge at $\\mathbf{O}_{23} = \\mathbf{S}_2 + L_{\\mathrm{SiO}}\\,\\hat{\\mathbf{t}}_{23}$.\n  - Second bridge geometry: at $\\mathbf{O}_{23}$, define $\\hat{\\mathbf{u}} = \\frac{\\mathbf{S}_2 - \\mathbf{O}_{23}}{\\lVert \\mathbf{S}_2 - \\mathbf{O}_{23}\\rVert}$. Choose any unit vector $\\hat{\\mathbf{p}}$ orthogonal to $\\hat{\\mathbf{u}}$, and set $\\hat{\\mathbf{w}} = \\cos(140^\\circ)\\,\\hat{\\mathbf{u}} + \\sin(140^\\circ)\\,\\hat{\\mathbf{p}}$. Place $\\mathbf{S}_3 = \\mathbf{O}_{23} + L_{\\mathrm{SiO}}\\,\\hat{\\mathbf{w}}$ to enforce a $140.0\\,\\mathrm{deg}$ silicon–oxygen–silicon angle at $\\mathbf{O}_{23}$.\n  - Around each silicon, place the remaining non-bridging oxygens using the tetrahedral rotation rule, with the reference direction mapped to the bridge direction used for that silicon. Place one sodium per non-bridging oxygen as specified.\n  - This yields $N_{\\mathrm{Si}}=3$, $N_{\\mathrm{O}}=10$, $N_{\\mathrm{Na}}=8$.\n\nComputational tasks for each test case:\n\n- Compute $g_{\\mathrm{SiO}}(r)$, $g_{\\mathrm{OO}}(r)$, and $g_{\\mathrm{NaO}}(r)$ using the definition above with $\\Delta r = 0.005\\,\\mathrm{\\AA}$ and $r_{\\max} = 6.0\\,\\mathrm{\\AA}$. Identify the first-peak position within windows: $[1.4,1.9]\\,\\mathrm{\\AA}$ for silicon–oxygen, $[2.2,3.0]\\,\\mathrm{\\AA}$ for oxygen–oxygen, $[2.1,2.6]\\,\\mathrm{\\AA}$ for sodium–oxygen.\n- Compute $P_{\\mathrm{O\\!-\\!Si\\!-\\!O}}(\\theta)$ and $P_{\\mathrm{Si\\!-\\!O\\!-\\!Si}}(\\theta)$ using $\\Delta \\theta = 0.5\\,\\mathrm{deg}$ over $[0,180]\\,\\mathrm{deg}$. Identify the peak positions within windows: $[90,120]\\,\\mathrm{deg}$ for oxygen–silicon–oxygen and $[120,160]\\,\\mathrm{deg}$ for silicon–oxygen–silicon.\n- Determine $Q^n$ for each silicon, compute the distribution over $n \\in \\{0,1,2,3,4\\}$, and compute $\\bar{n}$. Compute the benchmark $\\bar{n}_{\\mathrm{bench}} = 4 - \\frac{N_{\\mathrm{Na}}}{N_{\\mathrm{Si}}}$.\n- For each test case, evaluate the six toleranced comparisons listed above and produce a boolean result that is true only if all comparisons are satisfied.\n\nFinal output format:\n\nYour program should produce a single line of output containing the two boolean results as a comma-separated list enclosed in square brackets (e.g., \"[True,False]\").", "solution": "The problem statement has been subjected to rigorous validation and is deemed to be valid. It constitutes a well-posed computational problem in materials chemistry, focused on the structural analysis of silicate networks. The problem requires the implementation of algorithms to compute standard structural descriptors—partial radial distribution functions ($g_{\\alpha\\beta}(r)$), angular distribution functions ($P(\\theta)$), and $Q^n$ speciation—for two synthetically generated atomic configurations. The configurations and benchmark values are constructed in a self-consistent manner, such that the primary challenge lies in the correct and precise implementation of the required geometric and statistical calculations, rather than in the simulation of physical phenomena.\n\nThe problem is scientifically grounded, using established concepts and definitions from the study of amorphous materials. While the number of atoms in each test case is too small for the computed properties to be statistically representative of a bulk glass, the problem explicitly defines them as \"synthetic... molecular configurations,\" indicating that they serve as a deterministic testbed for the analysis code. The problem is thus a test of algorithmic correctness and not of physical simulation fidelity.\n\nCertain minor ambiguities in the problem description require clarification to ensure a unique, deterministic solution.\n1.  **Rotation Matrix Construction:** The problem requires a rotation $\\mathbf{R}$ that maps a vector $\\mathbf{a}$ to a vector $\\mathbf{b}$. A minimal rotation is assumed. This can be robustly implemented using vector algebra (Rodrigues' rotation formula) or, more conveniently, using the `scipy.spatial.transform.Rotation` class, which is permitted by the specified environment. This approach correctly handles all geometric cases, including parallel and anti-parallel vectors.\n2.  **Orthogonal Vector Choice:** The construction of the second test case requires choosing a unit vector $\\hat{\\mathbf{p}}$ orthogonal to a given vector $\\hat{\\mathbf{u}}$. To ensure a deterministic procedure, a canonical choice must be made. An arbitrary, non-collinear vector (e.g., $(1,0,0)$ or $(0,1,0)$ if the first is collinear) is chosen, and the cross product with $\\hat{\\mathbf{u}}$ is computed and normalized. This yields a unique orthogonal vector $\\hat{\\mathbf{p}}$.\n3.  **Rounding Convention:** The minimum image convention for periodic boundary conditions utilizes a `round()` function. Standard numerical libraries in Python typically round to the nearest even integer for half-integer cases. We will adopt this convention as implemented by `numpy.round()`.\n\nWith these points clarified, the problem is fully specified. The solution proceeds by first implementing functions to generate the atomic coordinates for both test cases according to the provided deterministic rules. Subsequently, a set of analysis functions is developed to compute the structural metrics. Finally, these metrics are evaluated against the given benchmarks to produce the required boolean outputs.\n\nThe solution is structured as follows:\n\n1.  **Coordinate Generation:**\n    - A function is created to compute the rotation matrix that aligns two vectors, using `scipy.spatial.transform.Rotation.align_vectors`.\n    - Functions `generate_case1_coords` and `generate_case2_coords` are implemented. These meticulously follow the geometric construction rules stated in the problem to generate the positions of all Silicon (Si), Oxygen (O), and Sodium (Na) atoms. All angles must be converted from degrees to radians for trigonometric functions.\n\n2.  **Structural Analysis:**\n    - A function `minimum_image_distance` is implemented to calculate the distance between two atoms under periodic boundary conditions with box length $L_{\\mathrm{box}}$. The displacement vector $\\Delta\\mathbf{r}$ is corrected by $\\Delta\\mathbf{r}' = \\Delta\\mathbf{r} - L_{\\mathrm{box}} \\cdot \\mathrm{round}(\\Delta\\mathbf{r} / L_{\\mathrm{box}})$.\n    - A function `calculate_rdf` computes the partial radial distribution function $g_{\\alpha\\beta}(r)$. It systematically iterates through all relevant atom pairs $(\\alpha, \\beta)$, calculates their minimum-image distances, and builds a histogram. The histogram counts are then normalized according to the provided formula:\n      $$g_{\\alpha\\beta}(r) = \\frac{V}{N_\\alpha N_\\beta} \\frac{\\text{count}(r)}{4\\pi r^2 \\Delta r}$$\n      where $\\text{count}(r)$ is the number of pairs found in the spherical shell at radius $r$ with thickness $\\Delta r$, $V = L_{\\mathrm{box}}^3$ is the volume, and $N_\\alpha$, $N_\\beta$ are the total numbers of atoms of species $\\alpha$ and $\\beta$.\n    - A function `calculate_angle_dist` computes the angular distribution for triplets of atoms (e.g., O-Si-O). It first identifies all valid triplets based on a neighborhood search with cutoff distance $r_{\\mathrm{c}}^{\\mathrm{SiO}} = 2.10\\,\\mathrm{\\AA}$. For each triplet centered on atom B (A-B-C), the angle is computed from the vectors $\\mathbf{r}_{\\mathrm{BA}}$ and $\\mathbf{r}_{\\mathrm{BC}}$ using the dot product formula $\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|})$, and a histogram of these angles is generated.\n    - A function `calculate_Qn_spec` determines the $Q^n$ speciation. First, it identifies bridging oxygens (BO) and non-bridging oxygens (NBO) by finding the coordination number of each oxygen atom with respect to silicon. An oxygen coordinated to two silicons is a BO; one coordinated to one silicon is an NBO. Then, for each silicon atom, it counts how many of its neighboring oxygens are bridging oxygens. This count is the value $n$ for that silicon's $Q^n$ state. The average $Q$-index, $\\bar{n}$, is the mean of these $n$ values over all silicon atoms.\n\n3.  **Evaluation and Output:**\n    - A main processing function iterates through each test case.\n    - It calls the coordinate generation and structural analysis functions.\n    - It finds the peak positions of the computed RDFs and angular distributions within the specified windows by finding the maximum of the corresponding histogram.\n    - It computes the average $Q$-index, $\\bar{n}$, and its benchmark value, $\\bar{n}_{\\mathrm{bench}} = 4 - N_{\\mathrm{Na}}/N_{\\mathrm{Si}}$.\n    - The six specified boolean conditions are evaluated based on the computed metrics and their respective benchmarks and tolerances.\n    - The final result for the test case is `True` if and only if all six conditions are met.\n    - The boolean results for both test cases are collected and printed in the required format.\n\nThis systematic procedure ensures that all aspects of the problem are addressed with scientific and mathematical rigor, leading to a verifiable and correct final answer.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    # Define shared parameters from the problem statement\n    L_BOX = 30.0\n    R_CUT_SIO = 2.10\n    L_SIO = 1.62\n    L_NAO = 2.35\n    THETA_SIOSI_DEG = 140.0\n    \n    TETRA_DIRS = np.array([\n        [1, 1, 1],\n        [1, -1, -1],\n        [-1, 1, -1],\n        [-1, -1, 1]\n    ]) / np.sqrt(3)\n    D_REF = TETRA_DIRS[0]\n\n    def get_rotation_from_vectors(vec_a, vec_b):\n        \"\"\"Computes rotation matrix to align vec_a with vec_b.\"\"\"\n        # scipy's align_vectors expects arrays of vectors\n        vec_a_norm = vec_a / np.linalg.norm(vec_a)\n        vec_b_norm = vec_b / np.linalg.norm(vec_b)\n        rot, _ = Rotation.align_vectors(vec_b_norm.reshape(1, 3), vec_a_norm.reshape(1, 3))\n        return rot.as_matrix()\n\n    def get_orthogonal_vector(v):\n        \"\"\"Generates a deterministic orthogonal vector to v.\"\"\"\n        v_norm = v / np.linalg.norm(v)\n        # Choose a vector that is not aligned with v\n        if abs(np.dot(v_norm, [1, 0, 0]))  0.9:\n            axis = [1, 0, 0]\n        else:\n            axis = [0, 1, 0]\n        p = np.cross(v_norm, axis)\n        return p / np.linalg.norm(p)\n\n    def generate_case1_coords():\n        \"\"\"Generates atomic coordinates for Test Case 1.\"\"\"\n        si_coords, o_coords, na_coords = [], [], []\n\n        # Bridging Oxygen\n        o_b = np.array([0.0, 0.0, 0.0])\n        o_coords.append(o_b)\n\n        # Silicon atoms\n        angle_rad = np.deg2rad(THETA_SIOSI_DEG / 2)\n        s1 = L_SIO * np.array([np.cos(angle_rad), np.sin(angle_rad), 0])\n        s2 = L_SIO * np.array([np.cos(-angle_rad), np.sin(-angle_rad), 0])\n        si_coords.extend([s1, s2])\n\n        # NBOs and Na atoms\n        for si in si_coords:\n            t_hat = (o_b - si) / np.linalg.norm(o_b - si)\n            rot_matrix = get_rotation_from_vectors(D_REF, -t_hat)\n            \n            nbo_count = 0\n            for d in TETRA_DIRS:\n                if not np.allclose(d, D_REF):\n                    rotated_d = rot_matrix @ d\n                    o_nbo = si + L_SIO * rotated_d\n                    o_coords.append(o_nbo)\n                    \n                    na_vec = (si - o_nbo) / np.linalg.norm(si - o_nbo)\n                    na = o_nbo - L_NAO * na_vec\n                    na_coords.append(na)\n                    nbo_count += 1\n            assert nbo_count == 3\n\n        return np.array(si_coords), np.array(o_coords), np.array(na_coords)\n\n    def generate_case2_coords():\n        \"\"\"Generates atomic coordinates for Test Case 2.\"\"\"\n        si_coords, o_coords, na_coords = [], [], []\n\n        # First bridge\n        o12 = np.array([0.0, 0.0, 0.0])\n        \n        angle_rad = np.deg2rad(THETA_SIOSI_DEG / 2)\n        s1 = L_SIO * np.array([np.cos(-angle_rad), np.sin(-angle_rad), 0])\n        s2 = L_SIO * np.array([np.cos(angle_rad), np.sin(angle_rad), 0])\n\n        # Second bridge and S3\n        t12_hat_from_s2 = (o12 - s2) / np.linalg.norm(o12 - s2)\n        rot_s2 = get_rotation_from_vectors(D_REF, -t12_hat_from_s2)\n        \n        # Deterministically select the second tetrahedral direction for the next bridge\n        # We need to distinguish TETRA_DIRS[1] from D_REF after rotation\n        t23_hat = rot_s2 @ TETRA_DIRS[1]\n        o23 = s2 + L_SIO * t23_hat\n        \n        u_hat = (s2 - o23) / np.linalg.norm(s2 - o23)\n        p_hat = get_orthogonal_vector(u_hat)\n        w_hat = np.cos(np.deg2rad(THETA_SIOSI_DEG)) * u_hat + np.sin(np.deg2rad(THETA_SIOSI_DEG)) * p_hat\n        s3 = o23 + L_SIO * w_hat\n\n        si_coords.extend([s1, s2, s3])\n        o_coords.extend([o12, o23])\n        \n        # NBOs and Na placement\n        connected_bos = {0: [o12], 1: [o12, o23], 2: [o23]}\n        si_bo_dirs = {\n            0: [(o12 - s1) / np.linalg.norm(o12 - s1)],\n            1: [(o12 - s2) / np.linalg.norm(o12 - s2), (o23 - s2) / np.linalg.norm(o23 - s2)],\n            2: [(o23 - s3) / np.linalg.norm(o23 - s3)]\n        }\n        \n        for i, si in enumerate(si_coords):\n            bo_dirs = si_bo_dirs[i]\n            \n            # Map NBOs away from BOs\n            # For Q2, map d_ref--bo1, d_ref2--bo2\n            if len(bo_dirs) == 1:\n                rot_si = get_rotation_from_vectors(D_REF, -bo_dirs[0])\n                dirs_to_use = [d for d in TETRA_DIRS if not np.allclose(d, D_REF)]\n                for d in dirs_to_use:\n                    rotated_d = rot_si @ d\n                    o_nbo = si + L_SIO * rotated_d\n                    o_coords.append(o_nbo)\n                    na_vec = (si - o_nbo) / np.linalg.norm(si - o_nbo)\n                    na = o_nbo - L_NAO * na_vec\n                    na_coords.append(na)\n\n            elif len(bo_dirs) == 2:\n                rot_si_1 = get_rotation_from_vectors(D_REF, -bo_dirs[0])\n                temp_d2 = rot_si_1 @ TETRA_DIRS[1]\n                rot_si_2 = get_rotation_from_vectors(temp_d2, -bo_dirs[1])\n                rot_si_final = rot_si_2 @ rot_si_1\n                dirs_to_use = [TETRA_DIRS[2], TETRA_DIRS[3]]\n                for d in dirs_to_use:\n                    rotated_d = rot_si_final @ d\n                    o_nbo = si + L_SIO * rotated_d\n                    o_coords.append(o_nbo)\n                    na_vec = (si - o_nbo) / np.linalg.norm(si - o_nbo)\n                    na = o_nbo - L_NAO * na_vec\n                    na_coords.append(na)\n\n        return np.array(si_coords), np.array(o_coords), np.array(na_coords)\n\n    def get_min_image_dist_vec(p1, p2, box_size):\n        delta = p2 - p1\n        delta -= box_size * np.round(delta / box_size)\n        return delta\n\n    def calculate_rdf(coords1, coords2, box_size, r_max, dr):\n        is_same_species = np.array_equal(coords1, coords2)\n        n1, n2 = len(coords1), len(coords2)\n        if n1 == 0 or n2 == 0:\n            return np.zeros(int(r_max / dr)), np.arange(dr / 2, r_max, dr)\n\n        bins = np.arange(0, r_max + dr, dr)\n        hist = np.zeros(len(bins) - 1)\n        \n        for i, p1 in enumerate(coords1):\n            for j, p2 in enumerate(coords2):\n                if is_same_species and i == j:\n                    continue\n                \n                dist_vec = get_min_image_dist_vec(p1, p2, box_size)\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist  r_max:\n                    bin_idx = int(dist / dr)\n                    hist[bin_idx] += 1\n        \n        r = bins[:-1] + dr / 2\n        vol_shell = 4.0 * np.pi * r**2 * dr\n        \n        # Avoid division by zero for r=0\n        vol_shell[vol_shell == 0] = 1.0\n\n        if is_same_species:\n            norm_factor = n1 * (n1 - 1) / box_size**3\n        else:\n            norm_factor = n1 * n2 / box_size**3\n        \n        g_r = hist / (vol_shell * norm_factor)\n        return g_r, r\n\n    def get_peak_position(dist, r_vals, r_min, r_max):\n        mask = (r_vals = r_min)  (r_vals = r_max)\n        if not np.any(mask): return -1\n        \n        masked_dist = dist[mask]\n        masked_r = r_vals[mask]\n        if len(masked_dist) == 0: return -1\n        \n        peak_idx = np.argmax(masked_dist)\n        return masked_r[peak_idx]\n\n    def calculate_angle_dist(coords_a, coords_b, coords_c, is_abc_triplet, cutoff, d_theta):\n        # Angle a-b-c. Coords for species a, b, c.\n        if len(coords_b) == 0:\n            return np.zeros(int(180 / d_theta)), np.arange(d_theta/2, 180, d_theta)\n\n        bins = np.arange(0, 180 + d_theta, d_theta)\n        hist = np.zeros(len(bins) - 1)\n        \n        for i_b, p_b in enumerate(coords_b):\n            neighbors_a = []\n            for i_a, p_a in enumerate(coords_a):\n                if is_abc_triplet and i_a == i_b: continue\n                if np.linalg.norm(get_min_image_dist_vec(p_b, p_a, L_BOX))  cutoff:\n                    neighbors_a.append(i_a)\n\n            neighbors_c = []\n            for i_c, p_c in enumerate(coords_c):\n                if is_abc_triplet and i_c == i_b: continue\n                if np.linalg.norm(get_min_image_dist_vec(p_b, p_c, L_BOX))  cutoff:\n                    neighbors_c.append(i_c)\n\n            from itertools import combinations\n            a_indices = neighbors_a\n            c_indices = neighbors_c if not is_abc_triplet else neighbors_a\n\n            if is_abc_triplet:\n                indices_pairs = combinations(a_indices, 2)\n            else:\n                indices_pairs = [(na, nc) for na in a_indices for nc in c_indices]\n\n            for idx_a, idx_c in indices_pairs:\n                if idx_a == idx_c: continue\n                \n                vec_ba = get_min_image_dist_vec(p_b, coords_a[idx_a], L_BOX)\n                vec_bc = get_min_image_dist_vec(p_b, coords_c[idx_c], L_BOX)\n                \n                cos_theta = np.dot(vec_ba, vec_bc) / (np.linalg.norm(vec_ba) * np.linalg.norm(vec_bc))\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                theta_deg = np.rad2deg(np.arccos(cos_theta))\n                \n                if theta_deg  180:\n                    bin_idx = int(theta_deg / d_theta)\n                    hist[bin_idx] += 1\n        \n        return hist, bins[:-1] + d_theta/2\n\n    def calculate_qn_spec(si_coords, o_coords, cutoff):\n        if len(si_coords) == 0 or len(o_coords) == 0:\n            return 0.0, {}\n\n        o_si_neighbors = {i: [] for i in range(len(o_coords))}\n        si_o_neighbors = {i: [] for i in range(len(si_coords))}\n\n        for i_si, p_si in enumerate(si_coords):\n            for i_o, p_o in enumerate(o_coords):\n                if np.linalg.norm(get_min_image_dist_vec(p_si, p_o, L_BOX))  cutoff:\n                    o_si_neighbors[i_o].append(i_si)\n                    si_o_neighbors[i_si].append(i_o)\n        \n        bo_indices = set()\n        for i_o, neighbors in o_si_neighbors.items():\n            if len(neighbors) == 2:\n                bo_indices.add(i_o)\n        \n        q_values = []\n        for i_si in range(len(si_coords)):\n            n = 0\n            for i_o in si_o_neighbors[i_si]:\n                if i_o in bo_indices:\n                    n += 1\n            q_values.append(n)\n        \n        avg_n = np.mean(q_values) if q_values else 0.0\n        return avg_n, q_values\n\n    def run_case(coords_generator):\n        si_coords, o_coords, na_coords = coords_generator()\n        n_si, n_o, n_na = len(si_coords), len(o_coords), len(na_coords)\n        dr, d_theta = 0.005, 0.5\n        \n        # 1. RDFs\n        g_sio, r_sio = calculate_rdf(si_coords, o_coords, L_BOX, 6.0, dr)\n        g_oo, r_oo = calculate_rdf(o_coords, o_coords, L_BOX, 6.0, dr)\n        g_nao, r_nao = calculate_rdf(na_coords, o_coords, L_BOX, 6.0, dr)\n\n        r_peak_sio = get_peak_position(g_sio, r_sio, 1.4, 1.9)\n        r_peak_oo = get_peak_position(g_oo, r_oo, 2.2, 3.0)\n        r_peak_nao = get_peak_position(g_nao, r_nao, 2.1, 2.6)\n\n        # 2. Angle distributions\n        p_osio, theta_osio = calculate_angle_dist(o_coords, si_coords, o_coords, True, R_CUT_SIO, d_theta)\n        p_siosi, theta_siosi = calculate_angle_dist(si_coords, o_coords, si_coords, False, R_CUT_SIO, d_theta)\n        \n        theta_peak_osio = get_peak_position(p_osio, theta_osio, 90, 120)\n        theta_peak_siosi = get_peak_position(p_siosi, theta_siosi, 120, 160)\n\n        # 3. Qn speciation\n        n_bar, _ = calculate_qn_spec(si_coords, o_coords, R_CUT_SIO)\n        n_bar_bench = 4.0 - n_na / n_si if n_si  0 else 0.0\n        \n        # 4. Evaluate conditions\n        cond1 = abs(r_peak_sio - 1.62)  0.05\n        cond2 = abs(r_peak_oo - 2.62)  0.12\n        cond3 = abs(r_peak_nao - 2.35)  0.12\n        cond4 = abs(theta_peak_osio - 109.5)  3.0\n        cond5 = abs(theta_peak_siosi - 140.0)  10.0\n        cond6 = abs(n_bar - n_bar_bench)  0.01\n\n        return all([cond1, cond2, cond3, cond4, cond5, cond6])\n\n    results = []\n    test_cases = [generate_case1_coords, generate_case2_coords]\n    for case_func in test_cases:\n        results.append(run_case(case_func))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2522514"}]}