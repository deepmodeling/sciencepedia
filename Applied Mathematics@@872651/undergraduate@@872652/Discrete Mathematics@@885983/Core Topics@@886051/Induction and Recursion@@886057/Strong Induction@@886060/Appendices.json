{"hands_on_practices": [{"introduction": "This first practice explores a common scenario in computer science and combinatorics: counting objects that must avoid a certain pattern. We will see how strong induction is the perfect tool to justify the correctness of a recurrence relation, which provides an elegant way to solve such counting problems. This exercise [@problem_id:1402596] builds a bridge between the inductive hypothesis and a concrete computational method.", "problem": "A certain type of computer memory is designed to store data as binary strings (sequences of 0s and 1s). Due to a physical limitation in the data writing mechanism, it is impossible to write two consecutive '0's. Any binary string that does not contain the substring '00' is considered a 'valid word'. Your task is to determine the total number of distinct valid words of length $n=17$.", "solution": "Let $a_n$ be the number of valid binary strings of length $n$, where a valid string is one that does not contain the substring '00'. We want to find the value of $a_{17}$.\n\nTo solve this problem, we first find a recurrence relation for $a_n$. We begin by establishing the base cases for small values of $n$.\n\nFor $n=1$: The possible strings are \"0\" and \"1\". Neither contains the substring \"00\", so they are both valid. Thus, $a_1 = 2$.\n\nFor $n=2$: The possible binary strings are \"00\", \"01\", \"10\", and \"11\". The string \"00\" is forbidden. The other three strings, \"01\", \"10\", and \"11\", are valid. Thus, $a_2 = 3$.\n\nNow, let's consider a valid string of length $n$, where $n \\geq 3$. We can classify these strings based on their last bit.\n\nCase 1: The string ends with a '1'.\nIf a valid string of length $n$ ends with a '1', the first $n-1$ bits can form any valid string of length $n-1$. Appending a '1' to any valid string will never create the forbidden \"00\" substring. Therefore, the number of valid strings of length $n$ ending in '1' is equal to the total number of valid strings of length $n-1$, which is $a_{n-1}$.\n\nCase 2: The string ends with a '0'.\nIf a valid string of length $n$ ends with a '0', the bit at position $n-1$ cannot be a '0', because that would create the forbidden \"00\" substring. Therefore, the bit at position $n-1$ must be a '1'. This means the string must end with \"10\". The first $n-2$ bits can form any valid string of length $n-2$. Appending \"10\" to any valid string of length $n-2$ will always result in a valid string of length $n$. Therefore, the number of valid strings of length $n$ ending in '0' is equal to the total number of valid strings of length $n-2$, which is $a_{n-2}$.\n\nSince these two cases are mutually exclusive (a string cannot end in both '0' and '1') and exhaustive (a string must end in either '0' or '1'), we can find the total number of valid strings of length $n$ by summing the counts from both cases. This gives us the recurrence relation:\n$$ a_n = a_{n-1} + a_{n-2} $$\nThis relation holds for $n \\geq 3$. The establishment of this recurrence, which depends on two preceding terms, is formally proven using the principle of strong induction, with $a_1$ and $a_2$ serving as the base cases for the induction.\n\nNow we can compute the values of $a_n$ sequentially until we reach $a_{17}$:\n$a_1 = 2$\n$a_2 = 3$\n$a_3 = a_2 + a_1 = 3 + 2 = 5$\n$a_4 = a_3 + a_2 = 5 + 3 = 8$\n$a_5 = a_4 + a_3 = 8 + 5 = 13$\n$a_6 = a_5 + a_4 = 13 + 8 = 21$\n$a_7 = a_6 + a_5 = 21 + 13 = 34$\n$a_8 = a_7 + a_6 = 34 + 21 = 55$\n$a_9 = a_8 + a_7 = 55 + 34 = 89$\n$a_{10} = a_9 + a_8 = 89 + 55 = 144$\n$a_{11} = a_{10} + a_9 = 144 + 89 = 233$\n$a_{12} = a_{11} + a_{10} = 233 + 144 = 377$\n$a_{13} = a_{12} + a_{11} = 377 + 233 = 610$\n$a_{14} = a_{13} + a_{12} = 610 + 377 = 987$\n$a_{15} = a_{14} + a_{13} = 987 + 610 = 1597$\n$a_{16} = a_{15} + a_{14} = 1597 + 987 = 2584$\n$a_{17} = a_{16} + a_{15} = 2584 + 1597 = 4181$\n\nThe total number of distinct valid words of length $n=17$ is 4181.", "answer": "$$\\boxed{4181}$$", "id": "1402596"}, {"introduction": "Strong induction is exceptionally powerful for proving properties of recursively defined structures like graphs. This problem [@problem_id:1402599] puts you in the driver's seat of a constructive proof, a method where the proof itself shows you how to build the object in question. You will apply the inductive step of a classic theorem in graph theory to see how assuming the result for smaller cases allows you to solve the problem for a larger one.", "problem": "In a sports analytics competition, you are tasked with analyzing the results of a round-robin tournament. In this tournament, a set of $n$ players compete, and every player plays against every other player exactly once, with one player winning and one losing (no draws). Such a tournament can be modeled as a \"tournament graph\" where players are vertices and a directed edge from player $u$ to player $v$ means that $u$ beat $v$.\n\nA key task is to find a \"dominance ranking,\" which is a sequence of all $n$ players $(P_1, P_2, \\dots, P_n)$ such that $P_i$ beat $P_{i+1}$ for all $i=1, \\dots, n-1$. In graph theory, this is known as a Hamiltonian path.\n\nA well-known constructive method for finding such a path in a tournament with $n$ players is to start with an existing Hamiltonian path for a subtournament of $n-1$ players and then insert the $n$-th player into the correct position in the sequence.\n\nConsider a tournament with five players: {Anna, Ben, Chloe, David, Emily}. For the four-player subtournament on {Anna, Ben, Chloe, David}, one possible dominance ranking (Hamiltonian path) is (Ben, Anna, David, Chloe). The results of the games involving the fifth player, Emily, are as follows:\n- Emily lost to Anna.\n- Emily lost to Ben.\n- Emily beat Chloe.\n- Emily beat David.\n\nUsing the described constructive method of inserting a new player into an existing path, what is the resulting dominance ranking for the full five-player tournament?\n\nA. (Ben, Anna, Emily, David, Chloe)\n\nB. (Emily, Ben, Anna, David, Chloe)\n\nC. (Ben, Anna, David, Chloe, Emily)\n\nD. (Ben, Emily, Anna, David, Chloe)\n\nE. (Anna, Ben, David, Chloe, Emily)", "solution": "Model the subtournament on {Anna, Ben, Chloe, David} by a Hamiltonian path $B \\to A \\to D \\to C$, meaning Ben beat Anna, Anna beat David, and David beat Chloe.\n\nUse the standard insertion algorithm for tournaments: given a Hamiltonian path $v_{1} \\to v_{2} \\to \\dots \\to v_{k}$ and a new vertex $E$, find the smallest index $j$ such that $E \\to v_{j}$. Insert $E$ immediately before $v_{j}$. If no such $j$ exists, append $E$ at the end. This maintains the Hamiltonian path property because for all $ij$, $E \\nrightarrow v_{i}$ implies $v_{i} \\to E$, so the predecessor $v_{j-1}$ (when $j1$) beats $E$, and by choice $E \\to v_{j}$.\n\nApply this to Emily with the given results: Emily lost to Ben and to Anna, so $E \\nrightarrow B$ and $E \\nrightarrow A$. Emily beat David, so $E \\to D$ is the first win encountered while scanning from left to right along $B \\to A \\to D \\to C$. Therefore, insert Emily immediately before David to obtain the path $B \\to A \\to E \\to D \\to C$.\n\nCheck adjacency: Anna beat Emily and Emily beat David, matching the required consecutive-edge directions, and the original edges $B \\to A$ and $D \\to C$ remain intact. Hence the resulting dominance ranking is (Ben, Anna, Emily, David, Chloe), which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1402599"}, {"introduction": "Our final practice demonstrates how strong induction can prove that certain properties are invariant throughout a multi-step process. The problem [@problem_id:1402593] seems complex because the fragmentation can happen in many different ways. However, by leveraging the principle of strong induction, one can prove that the total computational cost is surprisingly independent of the sequence of operations performed.", "problem": "In a particular data communication protocol, large data packets must be fragmented before transmission. The fragmentation process is recursive. A single operation consists of taking any packet of size $k  1$ bytes and splitting it into two smaller, non-empty packets of sizes $k_1$ and $k_2$, where $k_1 + k_2 = k$. The computational cost associated with a single split operation is defined as the product of the sizes of the two resulting packets, i.e., $k_1 \\times k_2$. The process is repeated until the initial packet is broken down entirely into packets of size 1 byte.\n\nCalculate the total computational cost required to completely fragment an initial data packet of size $N = 50$ bytes into 50 individual 1-byte packets.", "solution": "Let the total computational cost be denoted by $S$. Consider the potential function $P$ defined as the sum of the squares of the current packet sizes at any stage of the process.\n\nInitially, there is one packet of size $N$, so the initial potential is\n$$\nP_{\\text{initial}} = N^{2}.\n$$\nAt the end, there are $N$ packets of size $1$, so the final potential is\n$$\nP_{\\text{final}} = N.\n$$\nNow analyze a single split: a packet of size $k$ is split into $k_{1}$ and $k_{2}$ with $k_{1} + k_{2} = k$. The change in potential due to this split is\n$$\n\\Delta P = k_{1}^{2} + k_{2}^{2} - k^{2} = k_{1}^{2} + k_{2}^{2} - (k_{1} + k_{2})^{2} = -2 k_{1} k_{2}.\n$$\nThe cost of this split is $k_{1} k_{2}$, hence\n$$\n\\text{cost of split} = -\\frac{1}{2} \\Delta P = \\frac{1}{2}\\left(k^{2} - k_{1}^{2} - k_{2}^{2}\\right).\n$$\nSumming this identity over all splits, the intermediate terms telescope via the potential, yielding the total cost\n$$\nS = \\frac{1}{2}\\left(P_{\\text{initial}} - P_{\\text{final}}\\right) = \\frac{1}{2}\\left(N^{2} - N\\right).\n$$\nFor $N = 50$, this gives\n$$\nS = \\frac{1}{2}\\left(50^{2} - 50\\right) = \\frac{1}{2}\\cdot 2450 = 1225.\n$$", "answer": "$$\\boxed{1225}$$", "id": "1402593"}]}