{"hands_on_practices": [{"introduction": "The beauty of mathematics often lies in its ability to provide clear solutions to real-world puzzles. This first exercise grounds the abstract concept of the greatest common divisor (GCD) in a practical design problem involving tiling a rectangular space. By working through this scenario [@problem_id:1406858], you will see how the Euclidean algorithm is not just a sequence of calculations, but a powerful tool for solving optimization challenges that appear in fields like architecture and design.", "problem": "A landscape architect is designing a rectangular patio for a new city park. The designated area for the patio measures 1164 centimeters in length and 876 centimeters in width. The architect plans to pave the entire area using identical, non-overlapping square tiles. To minimize costs and aesthetic disruption from grout lines, the architect wants to use the largest possible square tiles that can cover the area perfectly without any of the tiles being cut.\n\nWhat is the side length, in centimeters, of the largest possible square tiles that can be used for this project?", "solution": "Let the side length of each square tile be $s$. To tile the $1164$ by $876$ rectangle exactly with non-overlapping squares of side $s$, both $1164$ and $876$ must be integer multiples of $s$. Therefore, $s$ must be a common divisor of $1164$ and $876$. The largest such $s$ is the greatest common divisor:\n$$\ns=\\gcd(1164,876).\n$$\nCompute $\\gcd(1164,876)$ using the Euclidean algorithm:\n$$\n1164=1 \\cdot 876+288,\n$$\n$$\n876=3\\cdot 288+12,\n$$\n$$\n288=24\\cdot 12+0.\n$$\nThe last nonzero remainder is $12$, hence\n$$\n\\gcd(1164,876)=12.\n$$\nTherefore, the side length of the largest square tile is $12$ centimeters.", "answer": "$$\\boxed{12}$$", "id": "1406858"}, {"introduction": "Having applied the Euclidean algorithm to a practical problem, we now turn to understanding its inner workings more deeply. This next practice [@problem_id:1406844] challenges you to work the algorithm in reverse, deducing the original numbers from the sequence of remainders they produce. This type of reverse reasoning is a crucial skill in mathematics and cryptography, enhancing your grasp of the rigid structure that governs the algorithm's execution.", "problem": "The Euclidean algorithm is a method for finding the Greatest Common Divisor (GCD) of two integers. When the algorithm is applied to two positive integers $a$ and $b$ with $a > b$, it generates a sequence of divisions with remainders. The first division is of $a$ by $b$ to get a remainder $r_1$. The second is of $b$ by $r_1$ to get a remainder $r_2$. This process continues, where at each subsequent step, the previous divisor is divided by the previous remainder, until the remainder is 0. The GCD is the last non-zero remainder.\n\nSuppose that for a particular pair of positive integers $a$ and $b$ with $a>b$, the execution of the Euclidean algorithm produces the following sequence of successive non-zero remainders: $r_1 = 24$, $r_2 = 18$, and $r_3 = 6$.\n\nFind the smallest possible value for the sum $a+b$.", "solution": "By the Euclidean algorithm, with successive remainders $r_{1}=24$, $r_{2}=18$, $r_{3}=6$, the divisions take the form\n$$\na=q_{1}b+24,\\quad 0<24<b,\\quad q_{1}\\in\\mathbb{Z}_{\\ge 1},\n$$\n$$\nb=q_{2}\\cdot 24+18,\\quad 0<18<24,\\quad q_{2}\\in\\mathbb{Z}_{\\ge 1},\n$$\n$$\n24=q_{3}\\cdot 18+6,\\quad 0<6<18,\n$$\n$$\n18=q_{4}\\cdot 6+0.\n$$\nFrom $24=q_{3}\\cdot 18+6$ it follows that $q_{3}=1$. From $18=q_{4}\\cdot 6$ it follows that $q_{4}=3$. Thus the only free quotients are $q_{1},q_{2}\\in\\mathbb{Z}_{\\ge 1}$, and\n$$\nb=24q_{2}+18,\\qquad a=q_{1}b+24.\n$$\nHence the sum is\n$$\na+b=(q_{1}+1)b+24=(q_{1}+1)(24q_{2}+18)+24.\n$$\nTo minimize $a+b$ over integers $q_{1},q_{2}\\ge 1$, choose $q_{1}=1$ and $q_{2}=1$, yielding\n$$\nb=24\\cdot 1+18=42,\\qquad a=1\\cdot 42+24=66,\n$$\nso\n$$\na+b=66+42=108.\n$$\nThese values are consistent with the given remainders:\n$$\n66=1\\cdot 42+24,\\quad 42=1\\cdot 24+18,\\quad 24=1\\cdot 18+6,\\quad 18=3\\cdot 6+0.\n$$\nTherefore, the smallest possible value of $a+b$ is $108$.", "answer": "$$\\boxed{108}$$", "id": "1406844"}, {"introduction": "Mastering the computation of the GCD for two integers is the foundation; the next step is to generalize this capability. This final exercise [@problem_id:1406812] expands our scope to finding the GCD of an entire set of numbers, a common task in computational number theory. You will compare two fundamental algorithmic strategies—iteration and divide-and-conquer—and analyze their efficiency, providing a bridge from pure mathematics to the principles of algorithm design and analysis.", "problem": "In the field of computational number theory, a common task is to find the greatest common divisor (GCD) of a set of integers. You are given access to a pre-existing, efficient, but opaque function `gcd2(x, y)` that computes the GCD of exactly two positive integers, `x` and `y`. Your goal is to implement a function `gcd_array` that computes the GCD of all integers in a given array $A = [a_1, a_2, \\dots, a_n]$ of $n$ positive integers. The computational cost of your implementation is measured by the total number of times the `gcd2` function is called.\n\nTwo algorithms are proposed to implement `gcd_array`. For both algorithms, assume the input is a 1-indexed array $A$ of size $n \\ge 1$. The GCD of a single number, $\\text{GCD}(a_k)$, is defined to be $a_k$ itself, which requires no calls to `gcd2`.\n\n**Algorithm A (Iterative Method):**\n1. Initialize a variable `current_gcd` with the value of the first element, $a_1$.\n2. For each index `i` from $2$ to $n$, update `current_gcd` by assigning it the result of `gcd2(current_gcd, a_i)`.\n3. After the loop completes, the value of `current_gcd` is the GCD of the entire array.\n\n**Algorithm B (Divide-and-Conquer Method):**\nThis algorithm is a recursive function, `GCD_Recursive(A, i, j)`, which computes the GCD of the subarray from index `i` to `j` (inclusive).\n1. If the start index `i` equals the end index `j`, the subarray has one element. Return $a_i$.\n2. If `i < j`, calculate the middle index $mid = \\lfloor(i+j)/2\\rfloor$.\n3. Recursively call the function to find the GCD of the left part: `g1 = GCD_Recursive(A, i, mid)`.\n4. Recursively call the function to find the GCD of the right part: `g2 = GCD_Recursive(A, mid+1, j)`.\n5. Return the result of `gcd2(g1, g2)`.\n\nTo find the GCD of the entire array $A$, an initial call `GCD_Recursive(A, 1, n)` is made.\n\nLet $C_A(n)$ be the total number of calls to `gcd2` made by Algorithm A for an input array of size $n$. Let $C_B(n)$ be the total number of calls to `gcd2` made by Algorithm B for an input array of size $n$. Determine a closed-form expression for the sum of these costs, $S(n) = C_A(n) + C_B(n)$, as a function of $n$.", "solution": "We define $C_A(n)$ as the number of calls to gcd2 made by Algorithm A on an input of size $n$, and $C_B(n)$ as the number of calls to gcd2 made by Algorithm B on an input of size $n$. We compute each in turn.\n\nFor Algorithm A, initialize with the first element and then for each $i$ from $2$ to $n$ perform exactly one call to gcd2. No call is needed when $n=1$. Therefore, the total number of calls is\n$$\nC_A(1)=0,\\quad C_A(n)=\\sum_{i=2}^{n} 1=n-1 \\text{ for } n\\ge 1.\n$$\n\nFor Algorithm B, consider the recursive function on a subarray of length $n$. The base case $n=1$ returns the element without any gcd2 call, so $C_B(1)=0$. For $n\\ge 2$, the subarray is split into two nonempty parts of sizes $n_{L}$ and $n_{R}$ with $n_{L}+n_{R}=n$, a recursive GCD is computed on each part, and then exactly one gcd2 call combines the two results. Hence the recurrence is\n$$\nC_B(1)=0,\\quad C_B(n)=C_B(n_{L})+C_B(n_{R})+1,\\quad n_{L}\\ge 1,\\; n_{R}\\ge 1,\\; n_{L}+n_{R}=n.\n$$\nWe prove by induction that $C_B(n)=n-1$ for all $n\\ge 1$. The base case $n=1$ gives $C_B(1)=0=1-1$. For the inductive step, assume $C_B(m)=m-1$ holds for all $m<n$. Then for $n\\ge 2$,\n$$\nC_B(n)=C_B(n_{L})+C_B(n_{R})+1=(n_{L}-1)+(n_{R}-1)+1=n-1,\n$$\nwhich establishes the claim.\n\nTherefore, the total number of gcd2 calls across both algorithms is\n$$\nS(n)=C_A(n)+C_B(n)=(n-1)+(n-1)=2n-2.\n$$\nThis holds for all integers $n\\ge 1$.", "answer": "$$\\boxed{2n-2}$$", "id": "1406812"}]}