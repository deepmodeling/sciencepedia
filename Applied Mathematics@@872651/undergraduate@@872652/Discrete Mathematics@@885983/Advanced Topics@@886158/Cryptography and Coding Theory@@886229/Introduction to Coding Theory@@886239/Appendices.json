{"hands_on_practices": [{"introduction": "In the world of digital communication, messages are not always received as they were sent. To begin our journey into error correction, we must first establish a clear mathematical language to describe these transmission mishaps. This practice introduces the fundamental concept of an error vector, which precisely identifies the location of bit flips by comparing the transmitted codeword with the received word [@problem_id:1377089].", "problem": "In digital communication systems, error detection is a fundamental task. Consider a simplified model for signals sent from a Mars rover to Earth. Data is encoded into binary strings called codewords. A codeword $c$ is transmitted, but due to atmospheric interference and signal degradation over the vast distance, some bits may be flipped. The binary string that arrives at Earth is called the received word, $r$.\n\nThe errors are represented by an error vector, $e$, which is a binary string of the same length as the codeword. A '1' in the $i$-th position of $e$ signifies that the $i$-th bit of the codeword was flipped during transmission, while a '0' signifies that it was not. The relationship between the transmitted codeword $c$, the received word $r$, and the error vector $e$ is given by the bitwise exclusive-OR (XOR, denoted by $\\oplus$) operation:\n$$r = c \\oplus e$$\nSuppose the rover transmits the 12-bit codeword $c = 110101100011$. After traveling to Earth, the mission control center receives the word $r = 111101000111$.\n\nWhich of the following represents the error vector $e$ that describes the transmission errors?\n\nA. `001000100100`\n\nB. `110101000011`\n\nC. `111101100111`\n\nD. `001000100110`\n\nE. `000000000000`", "solution": "The problem defines the relationship between the transmitted codeword ($c$), the received word ($r$), and the error vector ($e$) using the bitwise exclusive-OR (XOR, $\\oplus$) operation as:\n$$r = c \\oplus e$$\nOur goal is to find the error vector $e$. To isolate $e$, we can use a property of the XOR operation: for any binary string $x$, $x \\oplus x$ results in an all-zero string, and $x \\oplus 0 = x$.\n\nWe can apply the XOR operation with $c$ to both sides of the given equation:\n$$r \\oplus c = (c \\oplus e) \\oplus c$$\nBy the associative and commutative properties of XOR, we can reorder the terms on the right side:\n$$r \\oplus c = (c \\oplus c) \\oplus e$$\nSince $c \\oplus c$ is a string of all zeros, let's call it $\\mathbf{0}$:\n$$r \\oplus c = \\mathbf{0} \\oplus e$$\nThe XOR of any string with an all-zero string is the string itself:\n$$r \\oplus c = e$$\nSo, the error vector $e$ can be found by performing a bitwise XOR operation between the received word $r$ and the transmitted codeword $c$.\n\nThe given values are:\n$c = 110101100011$\n$r = 111101000111$\n\nNow, we compute $e = r \\oplus c$ bit by bit. The XOR operation yields 1 if the bits are different and 0 if they are the same.\n\n```\n  r:  1 1 1 1 0 1 0 0 0 1 1 1\n  c:  1 1 0 1 0 1 1 0 0 0 1 1\n---------------------------------\ne=r⊕c:  0 0 1 0 0 0 1 0 0 1 0 0\n```\n\nLet's do the calculation explicitly for each position:\n- Position 1: $1 \\oplus 1 = 0$\n- Position 2: $1 \\oplus 1 = 0$\n- Position 3: $1 \\oplus 0 = 1$\n- Position 4: $1 \\oplus 1 = 0$\n- Position 5: $0 \\oplus 0 = 0$\n- Position 6: $1 \\oplus 1 = 0$\n- Position 7: $0 \\oplus 1 = 1$\n- Position 8: $0 \\oplus 0 = 0$\n- Position 9: $0 \\oplus 0 = 0$\n- Position 10: $1 \\oplus 0 = 1$\n- Position 11: $1 \\oplus 1 = 0$\n- Position 12: $1 \\oplus 1 = 0$\n\nCombining these bits, we get the error vector:\n$$e = 001000100100$$\nThis result indicates that bits at positions 3, 7, and 10 (counting from the left, starting at 1) were flipped during transmission.\n\nComparing this result with the given options:\nA. `001000100100`\nB. `110101000011`\nC. `111101100111`\nD. `001000100110`\nE. `000000000000`\n\nThe calculated error vector matches option A.", "answer": "$$\\boxed{A}$$", "id": "1377089"}, {"introduction": "Now that we can represent errors, the next logical step is to detect them. This exercise explores one of the oldest and simplest methods for error detection: the parity check. By working through a scenario with an even parity scheme, you will discover how adding a single, carefully chosen bit can reveal the presence of certain errors, and importantly, you will also see why this simple method has its limitations [@problem_id:1377136].", "problem": "A simple communication system is designed to transmit 4-bit data words. To allow for some error detection, each data word is encoded into a 5-bit codeword by appending a single parity bit. The system employs an **even parity** scheme, meaning the parity bit is set to `0` or `1` to ensure the total number of `1`s in the 5-bit codeword is an even number.\n\nConsider the data word `1010`. This word is encoded and transmitted over a noisy channel. Which of the following received words, if any, represent a state where at least one bit-flip error has occurred, but the error would go undetected by the even parity check?\n\nSelect all valid options. Your answer should be a string concatenating the letters of all correct choices in alphabetical order (e.g., if A, C, and F are correct, the answer is `ACF`).\n\nA. `10101`\n\nB. `01100`\n\nC. `11111`\n\nD. `00000`\n\nE. `10100`\n\nF. `11101`", "solution": "Let the 4-bit data word be $d=1010$. Under even parity, the appended parity bit $p$ must satisfy that the total number of $1$'s in the 5-bit codeword is even. Let $w_{i}\\in\\{0,1\\}$ denote the bits of $d$ and compute the sum of ones:\n$$\ns=\\sum_{i=1}^{4} w_{i}=1+0+1+0=2.\n$$\nEven parity requires\n$$\ns+p\\equiv 0 \\pmod{2}.\n$$\nSince $s\\equiv 0 \\pmod{2}$, it follows that $p\\equiv 0 \\pmod{2}$, hence $p=0$. Therefore the transmitted 5-bit codeword is\n$c=10100$.\n\nAn undetected error occurs if and only if the received word $r$ satisfies two conditions: (i) $r\\neq c$ (at least one bit flip occurred), and (ii) the parity check passes, i.e.,\n$$\n\\sum_{i=1}^{5} r_{i}\\equiv 0 \\pmod{2}.\n$$\nNow test each option by counting ones and comparing to $c$:\n- A: `$10101` has 3 ones, so $\\sum r_{i}\\equiv 1 \\pmod{2}$ (detected). Reject.\n- B: `$01100` has 2 ones, so $\\sum r_{i}\\equiv 0 \\pmod{2}$; also $01100\\neq 10100$. Accept as undetected error (e.g., two bit flips).\n- C: `$11111` has 5 ones, so $\\sum r_{i}\\equiv 1 \\pmod{2}$ (detected). Reject.\n- D: `$00000` has 0 ones, so $\\sum r_{i}\\equiv 0 \\pmod{2}$; also $00000\\neq 10100$. Accept as undetected error (e.g., two bit flips).\n- E: `$10100` equals $c$, so this corresponds to zero errors, not “at least one bit-flip.” Reject.\n- F: `$11101` has 4 ones, so $\\sum r_{i}\\equiv 0 \\pmod{2}$; also $11101\\neq 10100$. Accept as undetected error (e.g., two bit flips).\n\nThus the correct choices are B, D, and F.", "answer": "$$\\boxed{BDF}$$", "id": "1377136"}, {"introduction": "Detecting an error is useful, but for robust systems like deep-space communication, we must also be able to correct it. This practice moves beyond simple detection and into the realm of error correction using linear block codes. You will learn to use a parity-check matrix to calculate a \"syndrome,\" a unique signature that not only signals an error but also reveals its exact location, allowing you to reconstruct the original message [@problem_id:1377111].", "problem": "In a deep-space communication system, a linear block code is used to transmit 4-bit messages as 7-bit codewords to protect against errors. All arithmetic operations in this context are performed modulo 2. The code is defined by its parity-check matrix $H$:\n$$ H = \\begin{pmatrix} 0  1  1  1  1  0  0 \\\\ 1  0  1  1  0  1  0 \\\\ 1  1  0  1  0  0  1 \\end{pmatrix} $$\nA 7-bit word $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ is a valid codeword if and only if its transpose $c^T$ satisfies the equation $Hc^T = \\vec{0}$, where $\\vec{0}$ is the zero vector. The code is systematic, meaning any codeword is of the form $(m_1, m_2, m_3, m_4, p_1, p_2, p_3)$, where $(m_1, m_2, m_3, m_4)$ is the original 4-bit message and $(p_1, p_2, p_3)$ are the parity bits.\n\nA ground station receives the 7-bit word $r = (1, 0, 1, 0, 0, 0, 1)$. It is known from the system's design specifications that at most one bit can be flipped during a single transmission. Your task is to determine the original 4-bit message $(m_1, m_2, m_3, m_4)$ that was sent. Present your answer as a single row matrix containing the four message bits.", "solution": "We work over the finite field with two elements, so all additions and multiplications are modulo 2. Let the received vector be $r=(1,0,1,0,0,0,1)$. The syndrome is defined as\n$$\ns = Hr^{T} \\pmod{2}.\n$$\nCompute $s$ explicitly:\n$$\ns = \\begin{pmatrix}\n0  1  1  1  1  0  0 \\\\\n1  0  1  1  0  1  0 \\\\\n1  1  0  1  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0\\cdot 1+1\\cdot 0+1\\cdot 1+1\\cdot 0+1\\cdot 0+0\\cdot 0+0\\cdot 1 \\\\\n1\\cdot 1+0\\cdot 0+1\\cdot 1+1\\cdot 0+0\\cdot 0+1\\cdot 0+0\\cdot 1 \\\\\n1\\cdot 1+1\\cdot 0+0\\cdot 1+1\\cdot 0+0\\cdot 0+0\\cdot 0+1\\cdot 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ 0\n\\end{pmatrix}\n\\pmod{2}.\n$$\nAssuming at most one bit error, write $r=c+e$ with $c$ a valid codeword and $e$ an error vector having Hamming weight at most $1$. Then\n$$\ns=Hr^{T}=Hc^{T}+He^{T}=0+He^{T}=He^{T}.\n$$\nIf the single error is in position $i$, then $e=e_{i}$ and $He^{T}$ equals the $i$-th column $h_{i}$ of $H$. Therefore the syndrome $s$ must equal one of the columns of $H$. The columns of $H$ are\n$$\nh_{1}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}1\\\\1\\\\1\\end{pmatrix},\\quad\nh_{5}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\quad\nh_{6}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\quad\nh_{7}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}.\n$$\nSince $s=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}=h_{5}$, the error is in position $5$. Correcting gives\n$$\nc=r+e_{5}=(1,0,1,0,0,0,1)+(0,0,0,0,1,0,0)=(1,0,1,0,1,0,1)\\pmod{2}.\n$$\nBecause the code is systematic, the original message is the first four bits of $c$, namely $(1,0,1,0)$.", "answer": "$$\\boxed{\\begin{pmatrix}1  0  1  0\\end{pmatrix}}$$", "id": "1377111"}]}