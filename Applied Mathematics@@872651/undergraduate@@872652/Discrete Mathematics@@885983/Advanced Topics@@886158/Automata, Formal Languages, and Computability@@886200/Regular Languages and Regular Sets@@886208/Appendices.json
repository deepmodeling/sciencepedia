{"hands_on_practices": [{"introduction": "Our journey into regular languages begins with a fundamental design task. This exercise [@problem_id:1396488] challenges you to construct a Nondeterministic Finite Automaton (NFA), a powerful tool for pattern recognition. By designing an NFA that identifies strings containing specific substrings, you will gain hands-on experience with the principles of non-determinism and state management, seeing how they can lead to elegant and efficient solutions.", "problem": "A computer scientist is designing a parser for a simple command language. The alphabet for the language is defined as $\\Sigma = \\{a, b, c\\}$. A command string is considered valid if and only if it contains the substring `ac` or the substring `abc`. To recognize these valid commands, a Non-deterministic Finite Automaton (NFA) is to be constructed.\n\nWhat is the minimum number of states (including the start state and any final states) required for an NFA that accepts this language of valid commands?", "solution": "Let the language be $L$. A string $w$ is in $L$ if it is of the form $x \\cdot s \\cdot y$, where $x, y \\in \\Sigma^*$ (any string of symbols from the alphabet $\\Sigma$) and $s$ is either `ac` or `abc`. We want to find the minimum number of states for a Non-deterministic Finite Automaton (NFA) that accepts $L$.\n\nThe two required substrings, `ac` and `abc`, share a common prefix `a`. We can use this overlap to design an efficient NFA. Let's construct the NFA state by state.\n\n1.  **Start State ($q_0$)**: This is the initial state. Before we have encountered any part of the target substrings, we are in this state. Any characters can be read without moving us closer to a final state, so we need a loop back to this state for any symbol. However, the symbol `a` is special as it's the start of both target substrings. Therefore, upon reading an `a`, the NFA must non-deterministically choose to either remain in $q_0$ (to handle cases where the `a` is not the start of the required substring, e.g., in a string like `baac`) or move to a new state that signifies the start of a potential match.\n    - Let $q_0$ be the start state.\n    - Transitions from $q_0$: $\\delta(q_0, a) = \\{q_0, q_1\\}$, $\\delta(q_0, b) = \\{q_0\\}$, $\\delta(q_0, c) = \\{q_0\\}$.\n\n2.  **State after 'a' ($q_1$)**: This state represents the knowledge that we have just seen an `a` that might be the prefix of `ac` or `abc`.\n    - From $q_1$, if the next symbol is `c`, we have successfully found the substring `ac`. We must transition to a final (accepting) state. Let's call this final state $q_f$. So, we add the transition $\\delta(q_1, c) = \\{q_f\\}$.\n    - From $q_1$, if the next symbol is `b`, we might be forming the substring `abc`. We need to move to a new state to remember that we have seen `ab`. Let's call this state $q_2$. So, we add the transition $\\delta(q_1, b) = \\{q_2\\}$.\n    - If the next symbol is `a`, the sequence for both `ac` and `abc` is broken. This non-deterministic path terminates. The machine relies on the other path (where it stayed in $q_0$ on the first `a`) to find a valid substring later.\n\n3.  **State after 'ab' ($q_2$)**: This state represents having seen the prefix `ab`.\n    - From $q_2$, if the next symbol is `c`, we have found the substring `abc`. We must transition to the final state $q_f$. So, we add the transition $\\delta(q_2, c) = \\{q_f\\}$.\n    - For any other symbol (`a` or `b`), the sequence `abc` is broken, and this path terminates.\n\n4.  **Final State ($q_f$)**: This is an accepting state. Reaching this state means we have found either `ac` or `abc`. Since the language accepts any string that *contains* one of these substrings, any characters that appear after the substring do not change the string's validity. Therefore, once in the final state, the NFA should remain in it, regardless of the subsequent input. This is a common \"trap\" accepting state.\n    - Transitions from $q_f$: $\\delta(q_f, a) = \\{q_f\\}$, $\\delta(q_f, b) = \\{q_f\\}$, $\\delta(q_f, c) = \\{q_f\\}$.\n\nThe constructed NFA has four states: $\\{q_0, q_1, q_2, q_f\\}$, with $q_0$ as the start state and $q_f$ as the sole final state.\n\nNow, we must argue that 4 is the minimum number of states. We can do this by showing that all four states are necessary because they represent distinct, distinguishable information about the string processed so far. Two states are distinguishable if there is some string that, when starting from one state, leads to acceptance, but when starting from the other, does not.\n\n-   **$q_f$ vs. non-final states ($q_0, q_1, q_2$)**: $q_f$ is a final state, while the others are not. They are distinguished by the empty string $\\epsilon$.\n\n-   **$q_0$ vs. $q_1$**: From $q_1$, the input string `c` leads to the final state $q_f$. From $q_0$, the input string `c` leads back to $q_0$, which is not a final state for the path. Thus, $q_0$ and $q_1$ are distinguishable.\n\n-   **$q_0$ vs. $q_2$**: From $q_2$, the input string `c` leads to $q_f$. From $q_0$, `c` leads to $q_0$. Thus, $q_0$ and $q_2$ are distinguishable.\n\n-   **$q_1$ vs. $q_2$**: This is the key comparison. From both $q_1$ and $q_2$, the input string `c` leads to acceptance. However, consider the input string `bc`. From $q_1$, reading `b` takes us to state $q_2$, and then reading `c` takes us to state $q_f$ (acceptance). So, the string `bc` is accepted starting from $q_1$. From $q_2$, there is no transition on `b`, so the path dies and the string `bc` is not accepted. Thus, $q_1$ and $q_2$ are distinguishable.\n\nSince all four states ($q_0, q_1, q_2, q_f$) are pairwise distinguishable, no two states can be merged. Therefore, a minimum of 4 states is required.", "answer": "$$\\boxed{4}$$", "id": "1396488"}, {"introduction": "While NFAs are excellent for design, Deterministic Finite Automata (DFAs) are often preferred for implementation due to their unambiguous nature. This practice [@problem_id:1396478] guides you through the subset construction algorithm, a cornerstone method for converting any NFA into an equivalent DFA. Completing this conversion will solidify your understanding of the formal relationship between these two types of automata and the trade-offs between them.", "problem": "Consider a Nondeterministic Finite Automaton (NFA), denoted as $M$, which is designed to accept the set of all binary strings that have a '1' as the second-to-last character. The alphabet for this automaton is $\\Sigma = \\{0, 1\\}$.\n\nThe NFA $M$ is formally defined by the 5-tuple $(Q, \\Sigma, \\delta, q_0, F)$, where:\n- The set of states is $Q = \\{q_0, q_1, q_2\\}$.\n- The alphabet is $\\Sigma = \\{0, 1\\}$.\n- The start state is $q_0$.\n- The set of final (accepting) states is $F = \\{q_2\\}$.\n- The transition function, $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the power set of $Q$, is given by the following table:\n\n| State   | Input '0' | Input '1'   |\n|---------|-----------|-------------|\n| $q_0$   | $\\{q_0\\}$ | $\\{q_0, q_1\\}$|\n| $q_1$   | $\\{q_2\\}$ | $\\{q_2\\}$   |\n| $q_2$   | $\\emptyset$ | $\\emptyset$   |\n\nYour task is to convert this NFA into an equivalent Deterministic Finite Automaton (DFA) using the standard subset construction algorithm. In your construction, you should only include the states that are reachable from the DFA's start state.\n\nAfter performing the conversion, determine the total number of states in the resulting DFA.", "solution": "We apply the subset construction to convert the given NFA $M=(Q,\\Sigma,\\delta,q_{0},F)$ into a DFA $M'=(Q',\\Sigma,\\delta',S_{0},F')$, where:\n- $Q' \\subseteq \\mathcal{P}(Q)$ consists of all subsets of $Q$ reachable from $S_{0}$,\n- $S_{0}=\\{q_{0}\\}$ (there are no $\\epsilon$-moves, so the $\\epsilon$-closure of $q_{0}$ is $\\{q_{0}\\}$),\n- $\\delta'(S,a)=\\bigcup_{q\\in S}\\delta(q,a)$ for $S\\subseteq Q$ and $a\\in\\Sigma$,\n- $F'=\\{S\\subseteq Q: S\\cap F\\neq\\emptyset\\}$.\n\nCompute reachable subsets starting from $S_{0}=\\{q_{0}\\}$. Using the given NFA transitions $\\delta(q_{0},0)=\\{q_{0}\\}$, $\\delta(q_{0},1)=\\{q_{0},q_{1}\\}$, $\\delta(q_{1},0)=\\{q_{2}\\}$, $\\delta(q_{1},1)=\\{q_{2}\\}$, $\\delta(q_{2},0)=\\emptyset$, $\\delta(q_{2},1)=\\emptyset$:\n\n1. From $\\{q_{0}\\}$:\n$$\n\\delta'(\\{q_{0}\\},0)=\\delta(q_{0},0)=\\{q_{0}\\},\\quad\n\\delta'(\\{q_{0}\\},1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}.\n$$\nReachable so far: $\\{q_{0}\\}$, $\\{q_{0},q_{1}\\}$.\n\n2. From $\\{q_{0},q_{1}\\}$:\n$$\n\\delta'(\\{q_{0},q_{1}\\},0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}=\\{q_{0},q_{2}\\},\n$$\n$$\n\\delta'(\\{q_{0},q_{1}\\},1)=\\delta(q_{0},1)\\cup\\delta(q_{1},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{2}\\}=\\{q_{0},q_{1},q_{2}\\}.\n$$\nNew reachable subsets: $\\{q_{0},q_{2}\\}$, $\\{q_{0},q_{1},q_{2}\\}$.\n\n3. From $\\{q_{0},q_{2}\\}$:\n$$\n\\delta'(\\{q_{0},q_{2}\\},0)=\\delta(q_{0},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\emptyset=\\{q_{0}\\},\n$$\n$$\n\\delta'(\\{q_{0},q_{2}\\},1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\emptyset=\\{q_{0},q_{1}\\}.\n$$\nNo new subsets.\n\n4. From $\\{q_{0},q_{1},q_{2}\\}$:\n$$\n\\delta'(\\{q_{0},q_{1},q_{2}\\},0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\},\n$$\n$$\n\\delta'(\\{q_{0},q_{1},q_{2}\\},1)=\\delta(q_{0},1)\\cup\\delta(q_{1},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{1},q_{2}\\}.\n$$\nNo new subsets.\n\nThus the reachable DFA states are exactly $\\{q_{0}\\}$, $\\{q_{0},q_{1}\\}$, $\\{q_{0},q_{2}\\}$, and $\\{q_{0},q_{1},q_{2}\\}$. The empty set and any subset not containing $q_{0}$ are unreachable because for every $a\\in\\Sigma$, $\\delta(q_{0},a)$ contains $q_{0}$, preventing transitions to subsets without $q_{0}$ or to $\\emptyset$. Therefore, the total number of states in the resulting DFA, counting only reachable states, is $4$.", "answer": "$$\\boxed{4}$$", "id": "1396478"}, {"introduction": "Having learned to build and convert automata, it's equally important to understand their limitations. This problem [@problem_id:1396509] introduces the Pumping Lemma, a classic tool used to prove that certain languages are not regular. By strategically selecting a string and applying the lemma's conditions, you will learn to construct a formal argument demonstrating that languages requiring unbounded counting, like $L = \\{a^k b^{2k} \\mid k \\geq 1\\}$, lie beyond the reach of finite automata.", "problem": "A computer science student is analyzing the properties of the language $L = \\{a^k b^{2k} \\mid k \\geq 1\\}$ over the alphabet $\\Sigma = \\{a, b\\}$. The student hypothesizes that $L$ is not a regular language and wants to use the Pumping Lemma for Regular Languages to test this hypothesis.\n\nThe Pumping Lemma asserts that for any regular language, there exists a \"pumping length\" $p \\geq 1$ such that any string $s$ in the language with length at least $p$ can be divided into three substrings, $s = xyz$, subject to three conditions:\n1. $|y| > 0$\n2. $|xy| \\leq p$\n3. $xy^i z \\in L$ for all integers $i \\geq 0$.\n\nTo demonstrate that $L$ is not regular, the student must select a suitable string $s \\in L$ (with $|s| \\geq p$) and an integer $i \\geq 0$ which, when applied to any valid decomposition $s=xyz$, results in a new string $s' = xy^iz$ that is definitively not in $L$.\n\nWhich of the following combinations of a string $s$ and an integer $i$ can be used to successfully complete the argument that $L$ is not a regular language, assuming $p$ is the pumping length? Select all that apply.\n\nA. $s = a^p b^{2p}$ and $i=1$\n\nB. $s = a^p b^p$ and $i=2$\n\nC. $s = a^{2p} b^{4p}$ and $i=0$\n\nD. $s = a^p b^{2p}$ and $i=2$\n\nE. $s = (ab)^{p}$ and $i=0$", "solution": "We analyze the language $L=\\{a^{k}b^{2k}\\mid k\\geq 1\\}$ using the Pumping Lemma for Regular Languages. The lemma states that if $L$ were regular, then there exists $p\\geq 1$ such that any string $s\\in L$ with $|s|\\geq p$ can be written as $s=xyz$ with $|y|>0$, $|xy|\\leq p$, and $xy^{i}z\\in L$ for all integers $i\\geq 0$.\n\nTo contradict this, we must choose $s\\in L$ with $|s|\\geq p$ so that for every valid decomposition $s=xyz$ with $|y|>0$ and $|xy|\\leq p$, there exists an $i\\geq 0$ (as specified in each option) for which $xy^{i}z\\notin L$. A standard strategy for $L$ is to ensure that $y$ consists only of $a$'s by forcing $|xy|\\leq p$ while the first $p$ symbols of $s$ are all $a$'s. Then pumping changes the count of $a$'s while leaving the count of $b$'s fixed, breaking the required relation that the number of $b$'s equals twice the number of $a$'s.\n\nWe test each option.\n\nA. $s=a^{p}b^{2p}$ and $i=1$. For any valid split $s=xyz$ with $|xy|\\leq p$, $y$ is a nonempty block of $a$'s. However, pumping with $i=1$ yields $xy^{1}z=s$, which is still in $L$. This cannot demonstrate non-regularity, since no contradiction arises. Hence A is invalid.\n\nB. $s=a^{p}b^{p}$ and $i=2$. The string $s$ must belong to $L$, but $a^{p}b^{p}\\notin L$ for $p\\geq 1$ because $L$ requires the number of $b$'s to be twice the number of $a$'s. Thus B is invalid.\n\nC. $s=a^{2p}b^{4p}$ and $i=0$. Here $s\\in L$ with $k=2p$, and $|s|\\geq p$. For any valid decomposition $s=xyz$ with $|y|>0$ and $|xy|\\leq p$, the first $p$ symbols of $s$ are all $a$'s, so $y=a^{t}$ for some integer $t\\geq 1$. Pumping down with $i=0$ yields\n$$\nxy^{0}z = xz = a^{2p-t}b^{4p}.\n$$\nIf $xz\\in L$, then there exists $k'$ such that $a^{2p-t}b^{4p}=a^{k'}b^{2k'}$, hence $k'=2p-t$ and $4p=2k'=2(2p-t)=4p-2t$. This implies $2t=0$ and therefore $t=0$, contradicting $|y|>0$. Hence $xy^{0}z\\notin L$, and C works.\n\nD. $s=a^{p}b^{2p}$ and $i=2$. Again $s\\in L$ with $k=p$, and for any valid split with $|xy|\\leq p$, we have $y=a^{t}$ with $t\\geq 1$. Pumping up with $i=2$ yields\n$$\nxy^{2}z = a^{p+t}b^{2p}.\n$$\nIf $xy^{2}z\\in L$, then there exists $k'$ with $a^{p+t}b^{2p}=a^{k'}b^{2k'}$, giving $k'=p+t$ and $2p=2k'=2(p+t)=2p+2t$, which forces $t=0$, again contradicting $|y|>0$. Hence $xy^{2}z\\notin L$, and D works.\n\nE. $s=(ab)^{p}$ and $i=0$. The string $s$ must belong to $L$, but $(ab)^{p}\\notin L$ since strings in $L$ have all $a$'s before all $b$'s with the count of $b$'s twice the count of $a$'s. Thus E is invalid.\n\nTherefore, the combinations that can successfully be used to complete the pumping-lemma argument are exactly C and D.", "answer": "$$\\boxed{CD}$$", "id": "1396509"}]}