{"hands_on_practices": [{"introduction": "Understanding topological sorting begins with the fundamental skill of verifying whether a given sequence of tasks respects all dependencies. This practice exercise puts you in the role of a quality assurance engineer for a software project. By checking several proposed build sequences against a set of dependency rules, you will gain a hands-on feel for the core definition of a valid topological sort [@problem_id:1549706].", "problem": "A software project is divided into seven distinct modules: Setup (S), Core (C), User Interface (UI), Networking (N), Database (D), Analytics (A), and Logging (L). Due to compilation dependencies, some modules must be compiled before others. The complete set of direct dependencies is given as follows:\n- The `Core` module depends on the `Setup` module.\n- The `UI` module depends on the `Core` module.\n- The `Networking` module depends on the `Core` module.\n- The `Database` module depends on both the `UI` and `Networking` modules.\n- The `Analytics` module depends on the `Networking` module.\n- The `Logging` module depends on both the `Database` and `Analytics` modules.\n\nA build sequence is a linear ordering of all seven modules. A build sequence is considered valid if and only if for every dependency, the required module appears before the module that depends on it.\n\nYour task is to determine which of the following proposed build sequences are valid.\n\nA. `Setup, Core, UI, Networking, Analytics, Database, Logging`\n\nB. `Setup, Core, Database, UI, Networking, Analytics, Logging`\n\nC. `Setup, Core, Networking, UI, Analytics, Database, Logging`\n\nD. `Setup, Core, UI, Networking, Logging, Database, Analytics`\n\nE. `Setup, Networking, Core, UI, Analytics, Database, Logging`", "solution": "Let the modules be denoted by $S$ (Setup), $C$ (Core), $UI$ (User Interface), $N$ (Networking), $D$ (Database), $A$ (Analytics), and $L$ (Logging). The dependency constraints can be written as the strict inequalities:\n$$SC,$$\n$$CUI,\\quad CN,$$\n$$UID,\\quad ND,$$\n$$NA,$$\n$$DL,\\quad AL.$$\nA build sequence is valid if and only if all these inequalities hold with respect to the positions of the modules in the sequence. For a given proposed sequence, define $p(X)$ as the position index of module $X$ in that sequence (smaller $p(X)$ means earlier in the order). The sequence is valid if and only if each listed inequality is satisfied by the corresponding $p(\\cdot)$ values.\n\nSequence A: Setup, Core, UI, Networking, Analytics, Database, Logging.\nThus $p(S)=1$, $p(C)=2$, $p(UI)=3$, $p(N)=4$, $p(A)=5$, $p(D)=6$, $p(L)=7$. Check:\n$$p(S)p(C):\\ 12,$$\n$$p(C)p(UI):\\ 23,\\quad p(C)p(N):\\ 24,$$\n$$p(UI)p(D):\\ 36,\\quad p(N)p(D):\\ 46,$$\n$$p(N)p(A):\\ 45,$$\n$$p(D)p(L):\\ 67,\\quad p(A)p(L):\\ 57.$$\nAll constraints hold, so A is valid.\n\nSequence B: Setup, Core, Database, UI, Networking, Analytics, Logging.\nThus $p(S)=1$, $p(C)=2$, $p(D)=3$, $p(UI)=4$, $p(N)=5$, $p(A)=6$, $p(L)=7$. Check $p(UI)p(D)$ requires $43$, which is false. Therefore B violates $UID$ (and also $ND$), so B is invalid.\n\nSequence C: Setup, Core, Networking, UI, Analytics, Database, Logging.\nThus $p(S)=1$, $p(C)=2$, $p(N)=3$, $p(UI)=4$, $p(A)=5$, $p(D)=6$, $p(L)=7$. Check:\n$$p(S)p(C):\\ 12,$$\n$$p(C)p(UI):\\ 24,\\quad p(C)p(N):\\ 23,$$\n$$p(UI)p(D):\\ 46,\\quad p(N)p(D):\\ 36,$$\n$$p(N)p(A):\\ 35,$$\n$$p(D)p(L):\\ 67,\\quad p(A)p(L):\\ 57.$$\nAll constraints hold, so C is valid.\n\nSequence D: Setup, Core, UI, Networking, Logging, Database, Analytics.\nThus $p(S)=1$, $p(C)=2$, $p(UI)=3$, $p(N)=4$, $p(L)=5$, $p(D)=6$, $p(A)=7$. Check $p(D)p(L)$ requires $65$, which is false, and $p(A)p(L)$ requires $75$, which is false. Therefore D is invalid.\n\nSequence E: Setup, Networking, Core, UI, Analytics, Database, Logging.\nThus $p(S)=1$, $p(N)=2$, $p(C)=3$, $p(UI)=4$, $p(A)=5$, $p(D)=6$, $p(L)=7$. Check $p(C)p(N)$ requires $32$, which is false. Therefore E is invalid.\n\nTherefore, the valid build sequences among the options are A and C.", "answer": "$$\\boxed{AC}$$", "id": "1549706"}, {"introduction": "Once we can verify a topological sort, the next step is to generate one. In many real-world applications, there isn't just one correct order, but many. This exercise introduces a common method for systematically choosing a single, deterministic sequence by applying a rule: always pick the alphabetically first task available. This mimics the logic of Kahn's algorithm and highlights how we can move from a set of possibilities to a single, concrete execution plan [@problem_id:1549700].", "problem": "A project manager is planning the sequence of tasks for setting up a new data analysis environment. To ensure a smooth installation, certain tasks must be completed before others. The team wants to follow an execution plan that is lexicographically smallest, meaning that at any step, if there are multiple tasks that can be performed, they will choose the one that comes first alphabetically.\n\nThe tasks are identified by a single uppercase letter:\n- (A) Install Pandas\n- (G) Install Git\n- (J) Install Jupyter Notebook\n- (M) Install Matplotlib\n- (N) Install NumPy\n- (P) Install Python\n- (S) Install Scikit-learn\n- (V) Set up Virtual Environment\n\nThe precedence constraints are as follows:\n1.  Installing Python (P) must be done before setting up the Virtual Environment (V).\n2.  Installing Python (P) must be done before installing Jupyter Notebook (J).\n3.  Setting up the Virtual Environment (V) must be done before installing NumPy (N).\n4.  Setting up the Virtual Environment (V) must be done before installing Pandas (A).\n5.  Setting up the Virtual Environment (V) must be done before installing Matplotlib (M).\n6.  Installing NumPy (N) must be done before installing Scikit-learn (S).\n7.  Installing Pandas (A) must be done before installing Scikit-learn (S).\n\nThere are no other dependencies. 'Install Git' (G) has no prerequisites and is not a prerequisite for any other task.\n\nWhich of the following sequences represents the correct lexicographically smallest order of tasks?\n\nA. `G, P, J, V, A, M, N, S`\n\nB. `P, G, J, V, N, A, S, M`\n\nC. `G, P, V, J, A, M, N, S`\n\nD. `P, G, V, A, N, S, J, M`\n\nE. `G, P, J, V, M, N, A, S`", "solution": "We model the tasks as a directed acyclic graph and seek the lexicographically smallest topological ordering. At each step, among all tasks with no unmet prerequisites, we select the alphabetically earliest letter.\n\nDependencies:\n- P precedes V and J.\n- V precedes N, A, M.\n- N and A both precede S.\n- G is independent (no prerequisites and not a prerequisite for others).\n\nInitially available tasks (no prerequisites): G and P. The lexicographically smallest is G, so pick G first.\nAfter completing G, available remains P. Pick P next.\nAfter completing P, newly available tasks are J and V (both require P). The lexicographically smallest is J. Pick J next.\nAfter completing J, available includes V. Pick V next.\nAfter completing V, newly available tasks are A, M, N (all require V). The lexicographically smallest is A. Pick A next.\nAfter completing A, available tasks are M and N. The lexicographically smallest is M. Pick M next.\nAfter completing M, available task is N. Pick N next.\nAfter completing N, with both A and N completed, S becomes available. Pick S last.\n\nThis yields the sequence: G, P, J, V, A, M, N, S. Checking constraints:\n- P before V and J: satisfied.\n- V before N, A, M: satisfied.\n- N before S and A before S: satisfied.\n- G is unconstrained: placement at the beginning is valid.\nThe sequence matches option A.", "answer": "$$\\boxed{A}$$", "id": "1549700"}, {"introduction": "While having multiple valid task sequences offers flexibility, some processes require a single, unambiguous order for consistency and reproducibility. This advanced problem challenges you to think like a system designer. You must determine the minimum number of dependencies to add to a project to ensure there is only one possible topological sort, thereby eliminating all ambiguity. This exercise reveals the deep connection between the uniqueness of a topological sort and the existence of a Hamiltonian path in the dependency graph [@problem_id:1549737].", "problem": "In project management and computer science, a set of tasks with dependencies among them can be modeled as a Directed Acyclic Graph (DAG), where vertices represent tasks and a directed edge from task `U` to task `V` means `U` must be completed before `V` can begin. A topological sort of this DAG gives a valid linear sequence in which the tasks can be executed.\n\nA software development project consists of eight distinct modules that need to be compiled. The dependencies between these modules are given as follows:\n- Module `M1` must be compiled before module `M3`.\n- Module `M2` must be compiled before module `M3`.\n- Module `M3` must be compiled before module `M4`.\n- Module `M3` must be compiled before module `M5`.\n- Module `M4` must be compiled before module `M6`.\n- Module `M5` must be compiled before module `M6`.\n- Module `M6` must be compiled before module `M7`.\n- Module `M6` must be compiled before module `M8`.\n\nFor the build process to be fully deterministic and reproducible without ambiguity, there must be exactly one unique topological sort for the dependency graph. Your task is to determine the minimum number of additional dependencies (new directed edges) that must be added to the graph to guarantee that it has a unique topological sort. The new edges must not create any cycles.", "solution": "Let $G=(V,E)$ be the given DAG with $V=\\{M_{1},\\dots,M_{8}\\}$ and edges\n$$\nE=\\{M_{1}\\to M_{3},\\,M_{2}\\to M_{3},\\,M_{3}\\to M_{4},\\,M_{3}\\to M_{5},\\,M_{4}\\to M_{6},\\,M_{5}\\to M_{6},\\,M_{6}\\to M_{7},\\,M_{6}\\to M_{8}\\}.\n$$\nA DAG has a unique topological order if and only if, in that order $(v_{1},\\dots,v_{n})$, every consecutive pair satisfies $v_{i}\\to v_{i+1}\\in E$; equivalently, the graph contains a directed Hamiltonian path through all vertices. Necessity: if the order is unique and $v_{i}$ and $v_{i+1}$ were not joined by a direct edge, then there is no path of length at least $2$ from $v_{i}$ to $v_{i+1}$ (that would require an intermediate vertex between them), so $v_{i}$ and $v_{i+1}$ would be incomparable and could be swapped, contradicting uniqueness. Sufficiency: if the graph contains edges $v_{1}\\to v_{2}\\to\\cdots\\to v_{n}$, then for all $ij$ there is a path $v_{i}\\to v_{j}$, so the reachability relation is a total order and the topological order is unique.\n\nThus we must add edges to create a single directed path through all $M_{i}$ without cycles, using only edges consistent with the partial order. Consider the valid linear extension\n$$\n(M_{1},\\,M_{2},\\,M_{3},\\,M_{4},\\,M_{5},\\,M_{6},\\,M_{7},\\,M_{8}).\n$$\nFor uniqueness, we need edges between each consecutive pair. The existing edges already include $M_{2}\\to M_{3}$, $M_{3}\\to M_{4}$, $M_{5}\\to M_{6}$, and $M_{6}\\to M_{7}$. The missing consecutive edges for this order are\n$$\nM_{1}\\to M_{2},\\quad M_{4}\\to M_{5},\\quad M_{7}\\to M_{8}.\n$$\nAdding these three edges yields the Hamiltonian path\n$$\nM_{1}\\to M_{2}\\to M_{3}\\to M_{4}\\to M_{5}\\to M_{6}\\to M_{7}\\to M_{8},\n$$\nwhich imposes a total order and hence guarantees a unique topological sort. These additions do not create cycles because each added edge connects a previously incomparable pair: initially, $M_{1}$ and $M_{2}$ are both sources (no path between them), $M_{4}$ and $M_{5}$ are incomparable siblings under $M_{3}$, and $M_{7}$ and $M_{8}$ are sinks (no path between them).\n\nMinimality: at least one edge is necessary to compare $M_{1}$ and $M_{2}$; otherwise there are two initial zero in-degree vertices and at least two topological orders differing by their swap. Similarly, at least one edge is necessary to compare $M_{4}$ and $M_{5}$, and at least one to compare $M_{7}$ and $M_{8}$. No single added edge can simultaneously render two of these pairs comparable without creating a cycle, because any path attempting to compare $M_{4}$ and $M_{5}$ would have to go through $M_{6}$ (which would require reversing an existing edge), and any path attempting to compare $M_{1}$ and $M_{2}$ would have to go through $M_{3}$ (which is after both). Hence at least three added edges are required. Since three edges suffice as shown, the minimum number is $3$.", "answer": "$$\\boxed{3}$$", "id": "1549737"}]}