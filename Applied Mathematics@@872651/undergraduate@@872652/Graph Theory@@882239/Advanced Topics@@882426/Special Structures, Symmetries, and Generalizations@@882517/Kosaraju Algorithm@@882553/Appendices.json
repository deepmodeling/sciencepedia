{"hands_on_practices": [{"introduction": "Kosaraju's algorithm elegantly finds strongly connected components through a two-pass approach. The foundation of this method lies in the first pass: a Depth-First Search (DFS) on the original graph $G$ to compute finishing times for each vertex. This exercise [@problem_id:1517012] provides essential practice in executing this critical first step, helping you master the mechanics of DFS and the calculation of finishing times that guide the rest of the algorithm.", "problem": "Consider a directed graph $G = (V, E)$ with a set of vertices $V = \\{v_0, v_1, v_2, v_3, v_4\\}$ and a set of directed edges $E$. The edges are defined as follows:\n- There is a central vertex $v_0$ that has outgoing edges to all other vertices.\n- The other vertices form a cycle, directed in a clockwise manner based on their indices.\nSpecifically, the set of edges is $E = \\{(v_0, v_1), (v_0, v_2), (v_0, v_3), (v_0, v_4), (v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$.\n\nWe will perform a Depth-First Search (DFS) on this graph $G$. The DFS procedure uses a global integer timer, which is initialized to 0.\n- When a vertex `u` is first discovered, its discovery time `d[u]` is recorded as the current value of the timer, and then the timer is incremented by 1.\n- After all neighbors of `u` have been visited, `u` is finished. Its finishing time `f[u]` is recorded as the current value of the timer, and then the timer is incremented by 1.\n\nThe DFS traversal follows these specific rules:\n1. The main DFS loop processes the vertices in the order of their indices: $v_0, v_1, v_2, v_3, v_4$. The first unvisited vertex in this sequence is chosen as the starting point for a new search tree.\n2. When exploring the neighbors of any given vertex, the neighbors are visited in increasing order of their vertex index. For example, from vertex $v_0$, the algorithm will attempt to visit $v_1$, then $v_2$, then $v_3$, and finally $v_4$.\n\nYour task is to determine the finishing times for all vertices $v_0, v_1, v_2, v_3, v_4$ after the DFS traversal is complete. Present your answer as a sequence of five integers, representing the finishing times of $v_0, v_1, v_2, v_3, v_4$ in that order.", "solution": "We perform a standard DFS with a global timer initialized to $t=0$. Upon discovering a vertex $u$, we set $d[u]=t$ and then update $t \\leftarrow t+1$. After finishing all neighbors of $u$, we set $f[u]=t$ and then update $t \\leftarrow t+1$. The main loop visits vertices in the order $v_{0},v_{1},v_{2},v_{3},v_{4}$, and adjacency lists are explored in increasing index order.\n\nStart with $v_{0}$ (unvisited), so we call $\\mathrm{DFS\\mbox{-}Visit}(v_{0})$:\n- Discover $v_{0}$:\n$$d[v_{0}]=0,\\quad t\\leftarrow 1.$$\nExplore neighbors of $v_{0}$ in order $v_{1},v_{2},v_{3},v_{4}$.\n\nFrom $v_{0}$, visit $v_{1}$ (white):\n- Discover $v_{1}$:\n$$d[v_{1}]=1,\\quad t\\leftarrow 2.$$\nNeighbors of $v_{1}$: only $v_{2}$. Visit $v_{2}$ (white):\n- Discover $v_{2}$:\n$$d[v_{2}]=2,\\quad t\\leftarrow 3.$$\nNeighbors of $v_{2}$: only $v_{3}$. Visit $v_{3}$ (white):\n- Discover $v_{3}$:\n$$d[v_{3}]=3,\\quad t\\leftarrow 4.$$\nNeighbors of $v_{3}$: only $v_{4}$. Visit $v_{4}$ (white):\n- Discover $v_{4}$:\n$$d[v_{4}]=4,\\quad t\\leftarrow 5.$$\nNeighbors of $v_{4}$: only $v_{1}$, which is already discovered (gray), so no recursion. Finish $v_{4}$:\n$$f[v_{4}]=5,\\quad t\\leftarrow 6.$$\n\nReturn to $v_{3}$, no more neighbors. Finish $v_{3}$:\n$$f[v_{3}]=6,\\quad t\\leftarrow 7.$$\n\nReturn to $v_{2}$, no more neighbors. Finish $v_{2}$:\n$$f[v_{2}]=7,\\quad t\\leftarrow 8.$$\n\nReturn to $v_{1}$, no more neighbors. Finish $v_{1}$:\n$$f[v_{1}]=8,\\quad t\\leftarrow 9.$$\n\nBack to $v_{0}$, continue its neighbor list: $v_{2},v_{3},v_{4}$ are already finished (black), so no new visits. Finish $v_{0}$:\n$$f[v_{0}]=9,\\quad t\\leftarrow 10.$$\n\nThe main loop examines $v_{1},v_{2},v_{3},v_{4}$, all already visited, so DFS terminates. Therefore, the finishing times in the order $(v_{0},v_{1},v_{2},v_{3},v_{4})$ are\n$$f[v_{0}]=9,\\quad f[v_{1}]=8,\\quad f[v_{2}]=7,\\quad f[v_{3}]=6,\\quad f[v_{4}]=5.$$", "answer": "$$\\boxed{\\begin{pmatrix}9 & 8 & 7 & 6 & 5\\end{pmatrix}}$$", "id": "1517012"}, {"introduction": "The magic of Kosaraju's algorithm lies in its second pass, where a DFS on the transpose graph $G^T$ is guided by the finishing times from the first pass. The rule is to process vertices in strictly *decreasing* order of their finishing times. This exercise [@problem_id:1516997] presents a thought-provoking scenario: what happens if this rule is violated? By analyzing a faulty implementation that uses an *increasing* order of finishing times, you will discover why the correct ordering is not arbitrary but is essential for isolating the strongly connected components correctly.", "problem": "In a legacy software system, a team of developers is analyzing module dependencies to identify clusters of tightly coupled components, known as Strongly Connected Components (SCCs). A directed graph $G = (V, E)$ is used to model the system, where the set of vertices $V$ represents the software modules and a directed edge $(u, v) \\in E$ means that module $u$ has a dependency on module $v$.\n\nThe set of modules is $V = \\{A, B, C, D, E, F, G\\}$. The dependencies are given as follows:\n- Module A depends on B and G.\n- Module B depends on C and D.\n- Module C depends on A and D.\n- Module D depends on E.\n- Module E depends on F.\n- Module F depends on D and G.\n\nAn analyst attempts to find the SCCs using a script that is supposed to implement Kosaraju's algorithm. However, the script contains a bug. The faulty algorithm implemented by the script is as follows:\n\n1.  Perform a Depth-First Search (DFS) on the graph $G$. The main loop of the DFS iterates through vertices in alphabetical order (A, B, C, ...). When exploring from a vertex, its unvisited neighbors are visited in alphabetical order. This pass is used to compute the finishing time for each vertex.\n2.  Compute the transpose graph, $G^T$, by reversing all edges in $G$.\n3.  Perform a DFS on the transpose graph $G^T$. The main loop iterates through all vertices in order of **increasing** finishing times as determined in Step 1. The vertices within each tree of the resulting DFS forest are collected into a set, which the script reports as a \"component\".\n\nWhat are the components that this faulty script will output?\n\nA. $\\{A, B, C\\}$, $\\{D, E, F\\}$, $\\{G\\}$\n\nB. $\\{A, B, C, D, E, F, G\\}$\n\nC. $\\{G\\}$, $\\{A, B, C\\}$, $\\{D, E, F\\}$\n\nD. $\\{G\\}$, $\\{F\\}$, $\\{E\\}$, $\\{D\\}$, $\\{C\\}$, $\\{B\\}$, $\\{A\\}$\n\nE. $\\{A, C, G\\}$, $\\{B, D, E, F\\}$", "solution": "We model the directed graph with vertices $V=\\{A,B,C,D,E,F,G\\}$ and edges given by dependencies:\n$$\nE(G)=\\{(A,B),(A,G),(B,C),(B,D),(C,A),(C,D),(D,E),(E,F),(F,D),(F,G)\\}.\n$$\nStep 1: Perform a DFS on $G$ with the main loop over vertices in alphabetical order and, within each DFS-Visit, explore unvisited neighbors in alphabetical order. Starting at $A$ (then $B$, $C$, $D$, $E$, $F$, $G$ if needed), the DFS proceeds:\n- From $A$: visit $B$ (since $B$ precedes $G$).\n- From $B$: visit $C$ (before $D$).\n- From $C$: $A$ is already discovered, so visit $D$.\n- From $D$: visit $E$.\n- From $E$: visit $F$.\n- From $F$: $D$ already discovered, so visit $G$.\n- $G$ has no outgoing edges, so $G$ finishes first.\nBacktracking completes finishes in the order\n$$\nG \\prec F \\prec E \\prec D \\prec C \\prec B \\prec A,\n$$\nthat is, the order of increasing finishing times is $G, F, E, D, C, B, A$.\n\nStep 2: Form the transpose graph $G^{T}$ by reversing all edges. The edges of $G^{T}$ are\n$$\nE(G^{T})=\\{(B,A),(G,A),(C,B),(D,B),(A,C),(D,C),(E,D),(F,E),(D,F),(G,F)\\}.\n$$\nEquivalently, the adjacency in $G^{T}$ (neighbors listed alphabetically) is:\n- $A:\\{C\\}$,\n- $B:\\{A\\}$,\n- $C:\\{B\\}$,\n- $D:\\{B,C,F\\}$,\n- $E:\\{D\\}$,\n- $F:\\{E\\}$,\n- $G:\\{A,F\\}$.\n\nStep 3: Perform a DFS on $G^{T}$ with the main loop iterating vertices in order of increasing finishing times from Step 1, i.e., in the order $G, F, E, D, C, B, A$. Within each DFS-Visit, visit unvisited neighbors in alphabetical order.\n- Start at $G$: visit $A$ (before $F$), then from $A$ visit $C$, from $C$ visit $B$, and from $B$ the only neighbor $A$ is already discovered. Backtrack to $G$ and then visit its next neighbor $F$, from $F$ visit $E$, and from $E$ visit $D$. From $D$, neighbors $\\{B,C,F\\}$ are already visited. Thus, the DFS tree starting at $G$ visits all vertices $\\{A,B,C,D,E,F,G\\}$.\n- The remaining vertices $F, E, D, C, B, A$ in the main loop are already visited, so no new trees are formed.\n\nTherefore, the faulty script reports a single component containing all vertices:\n$$\n\\{A,B,C,D,E,F,G\\}.\n$$\nThis corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1516997"}, {"introduction": "After mastering the individual steps and seeing the consequences of altering them, we can ask a more fundamental question about the algorithm's design. Is the sequence of operations—first DFS on $G$, then on $G^T$—interchangeable? This advanced problem [@problem_id:1517055] challenges you to evaluate a \"Reversed Kosaraju's Algorithm\" and determine its validity. Successfully tackling this question demonstrates a deep, conceptual understanding of why the algorithm works, moving beyond simple mechanical execution to true theoretical insight.", "problem": "An algorithm designer is working on finding the Strongly Connected Components (SCCs) of a directed graph $G=(V, E)$. They are familiar with Kosaraju's algorithm, which consists of the following steps:\n1.  Run a Depth First Search (DFS) on the graph $G$ to determine the finishing times (or a post-order traversal sequence) for all vertices.\n2.  Compute the transpose graph $G^T$, which is the graph $G$ with all its edges reversed.\n3.  Run a DFS on $G^T$, with the main loop processing vertices in decreasing order of their finishing times as determined in Step 1. Each tree in the resulting DFS forest corresponds to a distinct SCC of the original graph $G$.\n\nThe designer proposes a \"Reversed Kosaraju's Algorithm\" by swapping the roles of $G$ and $G^T$ in the main steps. The proposed algorithm is as follows:\n1.  Compute the transpose graph $G^T$.\n2.  Run a DFS on the transpose graph $G^T$ to determine the finishing times for all vertices.\n3.  Run a DFS on the original graph $G$, with the main loop processing vertices in decreasing order of their finishing times as determined in Step 2. The designer claims that each tree in this second DFS forest will correspond to a distinct SCC.\n\nWhich of the following statements accurately evaluates the correctness of this \"Reversed Kosaraju's Algorithm\"?\n\nA. Yes, this reversed algorithm is also a correct method for finding all Strongly Connected Components of any directed graph.\n\nB. No, this reversed algorithm fails for any directed graph that contains more than one Strongly Connected Component.\n\nC. No, this reversed algorithm is not correct because the processing order derived from $G^T$ does not guarantee that the DFS on $G$ will be confined to a single SCC for components processed after the first one.\n\nD. No, this reversed algorithm is not correct because a DFS on the original graph $G$ in the final step cannot utilize finishing times computed from the transpose graph $G^T$.", "solution": "Let $G=(V,E)$ be a directed graph. Let $C(H)$ denote the condensation graph of a graph $H$, whose vertices are the SCCs of $H$. An edge exists from SCC $S_1$ to SCC $S_2$ in $C(H)$ if there is an edge in $H$ from a vertex in $S_1$ to a vertex in $S_2$. A fundamental property of Depth-First Search is that if there is an edge $S_1 \\to S_2$ in the condensation graph $C(H)$, then the maximum finishing time of any vertex in $S_1$ is greater than the maximum finishing time of any vertex in $S_2$. We can write this as $f_{\\max}(S_1) > f_{\\max}(S_2)$. This implies that the SCC containing the vertex with the overall highest finishing time in a DFS of $H$ must be a **source component** of the condensation graph $C(H)$ (i.e., it has no incoming edges from other SCCs).\n\nLet's analyze the \"Reversed Kosaraju's Algorithm\":\n1.  **First Pass (DFS on $G^T$)**: The algorithm performs a DFS on the transpose graph $G^T$. According to the property above, the vertex with the highest finishing time, let's call it $v^*$, must belong to a source SCC of the condensation graph $C(G^T)$.\n2.  **Transposition and Condensation**: The condensation graph of the transpose, $C(G^T)$, is the transpose of the original condensation graph, $C(G)$. This means that a **source** component in $C(G^T)$ corresponds to a **sink** component in $C(G)$. A sink component is an SCC that has no outgoing edges to any other SCC.\n3.  **Second Pass (DFS on $G$)**: The algorithm proceeds to run a DFS on the original graph $G$, starting with the vertices in decreasing order of their finishing times from the first pass. The first DFS will start at $v^*$. Since $v^*$ belongs to a sink SCC of $G$, the DFS traversal starting from $v^*$ is \"trapped\" within its own SCC. It can reach all other vertices in its component, but it cannot follow any edge to a different component. Therefore, the first tree in this second DFS forest correctly identifies one full SCC.\n4.  **Iteration**: The algorithm then moves to the next unvisited vertex in the ordered list. This vertex will belong to a sink component of the *remaining* graph. The process repeats, correctly \"peeling off\" one SCC at a time.\n\nSince the logic is symmetric to the standard Kosaraju's algorithm (which starts from a source component of $G$ and runs the second DFS on $G^T$, where that component is a sink), the reversed algorithm is also correct. It correctly identifies all SCCs.\n\nTherefore, statement A is the correct evaluation. Statements B, C, and D are incorrect. Statement C is particularly misleading; it incorrectly assumes that the ordering from $G^T$ leads to starting from a source component in $G$, which would indeed be a problem, but the actual logic is the reverse.", "answer": "$$\\boxed{A}$$", "id": "1517055"}]}