{"hands_on_practices": [{"introduction": "The most fundamental property of a Directed Acyclic Graph (DAG) is embedded in its name: it must be acyclic. This absence of cycles is essential for modeling any process with irreversible steps or dependencies, such as task scheduling or software compilation. This exercise [@problem_id:1496996] provides a practical scenario where you must analyze a set of project dependencies to determine if they form a valid workflow or contain a logical contradiction in the form of a cycle.", "problem": "A project manager at a software company is planning the build process for a new microservices-based application. The application consists of six distinct modules: `Auth`, `Billing`, `Catalog`, `Delivery`, `Frontend`, and `Orders`. The build process is governed by a set of dependencies, where one module must be compiled and deployed before another. These dependencies are given as a set of ordered pairs `(U, V)`, which signifies that module `U` must be successfully built before the build for module `V` can begin.\n\nThe complete set of dependencies, `D`, for this project is:\n`D = {(Frontend, Auth), (Auth, Orders), (Orders, Billing), (Catalog, Frontend), (Billing, Auth), (Orders, Delivery)}`\n\nAnalyze this set of dependencies to determine the structural properties of the project's build process. Which of the following statements accurately describes the situation?\n\nA. The dependencies are valid and a possible build order is: `Catalog, Frontend, Auth, Orders, Billing, Delivery`.\n\nB. The dependencies are valid and a possible build order is: `Catalog, Frontend, Auth, Orders, Delivery, Billing`.\n\nC. The dependencies contain a logical contradiction, specifically forming a cycle of length 3.\n\nD. The dependencies contain a logical contradiction, specifically forming a cycle of length 4.\n\nE. The set of dependencies is valid, but multiple distinct build orders are possible.", "solution": "Define the directed graph $G=(V,E)$ where $V=\\{\\text{Auth}, \\text{Billing}, \\text{Catalog}, \\text{Delivery}, \\text{Frontend}, \\text{Orders}\\}$ and $E=D=\\{(\\text{Frontend}, \\text{Auth}), (\\text{Auth}, \\text{Orders}), (\\text{Orders}, \\text{Billing}), (\\text{Catalog}, \\text{Frontend}), (\\text{Billing}, \\text{Auth}), (\\text{Orders}, \\text{Delivery})\\}$. A valid build order exists if and only if $G$ is a directed acyclic graph; equivalently, if and only if there is no directed cycle, in which case a topological ordering exists.\n\nFrom $E$, observe the three edges\n$$(\\text{Auth}, \\text{Orders}),\\quad (\\text{Orders}, \\text{Billing}),\\quad (\\text{Billing}, \\text{Auth}).$$\nThese imply the directed cycle\n$$\\text{Auth} \\to \\text{Orders} \\to \\text{Billing} \\to \\text{Auth},$$\nwhich is a cycle of length $3$. Therefore, $G$ is not acyclic and no topological ordering exists. Consequently:\n- Any proposed concrete build order (such as those in options A and B) cannot satisfy all dependencies; for example, both list $\\text{Auth}$ before $\\text{Billing}$, violating $(\\text{Billing}, \\text{Auth})$.\n- Since there is a cycle, the dependency set is not valid, so it is not the case that the set is valid with multiple distinct build orders.\n\nThus, the correct description is that the dependencies contain a logical contradiction forming a cycle of length $3$, which matches option C.", "answer": "$$\\boxed{C}$$", "id": "1496996"}, {"introduction": "Once we establish that a graph is a valid DAG, we can use it for planning and optimization. A common task is to find the \"best\" path between a start and end point, but the definition of \"best\" can vary. This problem [@problem_id:1497000] challenges you to explore the important difference between the path with the fewest steps (structural simplicity) and the path with the minimum total weight (fastest completion time), a crucial distinction in fields from logistics to network analysis.", "problem": "A project manager is analyzing a project's workflow, which can be modeled as a weighted Directed Acyclic Graph (DAG). In this model, vertices represent milestones, and a directed edge from milestone $U$ to milestone $V$ with a weight $w$ signifies a task that must be completed to get from $U$ to $V$, requiring $w$ hours to finish.\n\nThe project starts at a source milestone $S$ and is completed at a sink milestone $T$. The graph is defined by the set of vertices $V = \\{S, A, B, C, T\\}$ and the following set of directed edges with their corresponding time requirements in hours:\n- An edge from $S$ to $A$ with a weight of 8.\n- An edge from $S$ to $B$ with a weight of 3.\n- An edge from $A$ to $T$ with a weight of 4.\n- An edge from $B$ to $C$ with a weight of 2.\n- An edge from $C$ to $T$ with a weight of 5.\n\nThe manager is interested in comparing two distinct types of paths from the start milestone $S$ to the completion milestone $T$:\n1. The \"structurally simplest path,\" defined as the path that consists of the minimum number of sequential tasks (i.e., the minimum number of edges).\n2. The \"fastest path,\" defined as the path that takes the minimum total time to complete (i.e., the minimum sum of edge weights).\n\nCalculate the absolute difference in total hours between the structurally simplest path and the fastest path. Express your answer in hours.", "solution": "We list all directed paths from $S$ to $T$ and compute both the number of edges (for structural simplicity) and the total time (sum of weights) for each.\n\nPath $P_{1}: S \\rightarrow A \\rightarrow T$.\n- Number of edges: $2$.\n- Total time: $w(S,A)+w(A,T)=8+4=12$.\n\nPath $P_{2}: S \\rightarrow B \\rightarrow C \\rightarrow T$.\n- Number of edges: $3$.\n- Total time: $w(S,B)+w(B,C)+w(C,T)=3+2+5=10$.\n\nBy definition, the structurally simplest path is the one with the minimum number of edges, which is $P_{1}$ with $2$ edges and total time $12$.\n\nThe fastest path is the one with the minimum total time, which is $P_{2}$ with total time $10$.\n\nThe required absolute difference in total hours is\n$$|12-10|=2.$$", "answer": "$$\\boxed{2}$$", "id": "1497000"}, {"introduction": "DAGs serve as the foundation for solving complex optimization problems that might otherwise be computationally intractable. This advanced practice [@problem_id:1496951] introduces the powerful technique of dynamic programming on a tree, a special type of DAG. By solving a problem inspired by bioinformatics, you will learn how to break down a large optimization task into smaller, manageable subproblems to find the globally optimal solution efficiently.", "problem": "A biotechnology research firm is modeling a complex cellular signaling network to optimize a new drug cocktail. The network is represented as a Directed Acyclic Graph (DAG), where the nodes are proteins and a directed edge `(u, v)` indicates that protein `u` directly activates protein `v`. The overall network is known to be a forest, meaning it is a collection of disjoint trees, with edges directed from parent to child.\n\nEach protein `i` in the network has been assigned a \"therapeutic value\" `w(i)`, which is a positive integer representing its effectiveness as a drug target. The goal is to select a subset of proteins to target with the drug cocktail to achieve the maximum possible total therapeutic value.\n\nHowever, there is a key constraint based on the binding mechanism: if two proteins are directly linked (i.e., one is an activator of the other), they cannot both be targeted. In graph theory terms, the chosen set of proteins must form an independent set, where no two chosen proteins are adjacent in the graph.\n\nYou are given the structure of one such signaling tree within the network, containing 8 proteins labeled 0 through 7.\nThe structure is defined by the following parent-child relationships, where an edge `(u, v)` denotes that `u` is the parent of `v`:\n(0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (3, 6), (3, 7).\nProtein 0 is the root of the tree.\n\nThe therapeutic values for the proteins are as follows:\n- `w(0) = 3`\n- `w(1) = 5`\n- `w(2) = 6`\n- `w(3) = 2`\n- `w(4) = 8`\n- `w(5) = 4`\n- `w(6) = 7`\n- `w(7) = 3`\n\nCalculate the maximum possible total therapeutic value that can be achieved by selecting a valid set of protein targets.", "solution": "The problem asks for the maximum weight of an independent set in a given vertex-weighted tree. An independent set is a set of vertices where no two vertices are connected by an edge. Since the graph is a tree (a special type of DAG), this problem can be solved efficiently using dynamic programming. The general strategy is to compute the solution for subtrees and use those results to compute the solution for larger trees. This is typically done via a post-order traversal, starting from the leaves and moving up to the root.\n\nFor each node `u` in the tree, we will compute two values:\n1.  `dp_in(u)`: The maximum weight of an independent set in the subtree rooted at `u`, with the constraint that `u` **is included** in the independent set.\n2.  `dp_out(u)`: The maximum weight of an independent set in the subtree rooted at `u`, with the constraint that `u` **is not included** in the independent set.\n\nThe recurrence relations for these values are as follows:\n-   If we include node `u` in the set (for `dp_in(u)`), its weight `w(u)` is added to the total. By the definition of an independent set, we cannot include any of its neighbors. In a tree, this means we cannot include its parent (which is handled by the upward DP flow) or any of its direct children. Therefore, for each child `v` of `u`, we must choose the option where `v` is not included.\n    $$dp_{\\text{in}}(u) = w(u) + \\sum_{v \\in \\text{children}(u)} dp_{\\text{out}}(v)$$\n-   If we do not include node `u` in the set (for `dp_out(u)`), we are free to make the optimal choice for each of its children's subtrees independently. For each child `v`, we can either include `v` or not include `v`, so we take the maximum of the two options for its subtree.\n    $$dp_{\\text{out}}(u) = \\sum_{v \\in \\text{children}(u)} \\max(dp_{\\text{in}}(v), dp_{\\text{out}}(v))$$\n\nThe base cases for this recursion are the leaves of the tree. For any leaf node `l`:\n-   `dp_in(l) = w(l)` (The set is just `{l}`).\n-   `dp_out(l) = 0` (The set is empty).\n\nWe will apply this process starting from the leaves and moving up to the root. The given tree structure is:\nRoot: 0\nChildren of 0: {1, 2, 3}\nChildren of 1: {4, 5}\nChildren of 3: {6, 7}\nLeaves: {2, 4, 5, 6, 7}\n\nThe weights are: `w = {3, 5, 6, 2, 8, 4, 7, 3}` for nodes `0` through `7`.\n\n**Step 1: Compute DP values for the leaves.**\n-   Node 2: `dp_in(2) = w(2) = 6`, `dp_out(2) = 0`.\n-   Node 4: `dp_in(4) = w(4) = 8`, `dp_out(4) = 0`.\n-   Node 5: `dp_in(5) = w(5) = 4`, `dp_out(5) = 0`.\n-   Node 6: `dp_in(6) = w(6) = 7`, `dp_out(6) = 0`.\n-   Node 7: `dp_in(7) = w(7) = 3`, `dp_out(7) = 0`.\n\n**Step 2: Compute DP values for the internal nodes in post-order.**\n-   Node 1 (children {4, 5}):\n    -   `dp_in(1) = w(1) + dp_out(4) + dp_out(5) = 5 + 0 + 0 = 5`.\n    -   `dp_out(1) = \\max(dp_in(4), dp_out(4)) + \\max(dp_in(5), dp_out(5)) = \\max(8, 0) + \\max(4, 0) = 8 + 4 = 12`.\n-   Node 3 (children {6, 7}):\n    -   `dp_in(3) = w(3) + dp_out(6) + dp_out(7) = 2 + 0 + 0 = 2`.\n    -   `dp_out(3) = \\max(dp_in(6), dp_out(6)) + \\max(dp_in(7), dp_out(7)) = \\max(7, 0) + \\max(3, 0) = 7 + 3 = 10`.\n\n**Step 3: Compute DP values for the root node.**\n-   Node 0 (children {1, 2, 3}):\n    -   `dp_in(0) = w(0) + dp_out(1) + dp_out(2) + dp_out(3) = 3 + 12 + 0 + 10 = 25`.\n    -   `dp_out(0) = \\max(dp_in(1), dp_out(1)) + \\max(dp_in(2), dp_out(2)) + \\max(dp_in(3), dp_out(3)) = \\max(5, 12) + \\max(6, 0) + \\max(2, 10) = 12 + 6 + 10 = 28`.\n\n**Step 4: Determine the final answer.**\nThe maximum therapeutic value for the entire tree is the maximum of including the root or not including the root.\nFinal Answer = `\\max(dp_in(0), dp_out(0)) = \\max(25, 28) = 28`.\n\nTo verify, the set corresponding to `dp_out(0)=28` is constructed by taking the optimal choices downwards:\n- Don't include 0.\n- For subtree 1, take the max, which is `dp_out(1)=12`. This means we don't include 1. For its children, 4 and 5, we take the max, which is `dp_in(4)=8` and `dp_in(5)=4`. So we select {4, 5}.\n- For subtree 2, take the max, which is `dp_in(2)=6`. So we select {2}.\n- For subtree 3, take the max, which is `dp_out(3)=10`. This means we don't include 3. For its children, 6 and 7, we take the max, which is `dp_in(6)=7` and `dp_in(7)=3`. So we select {6, 7}.\nThe resulting independent set is {2, 4, 5, 6, 7}.\nThe total weight is `w(2) + w(4) + w(5) + w(6) + w(7) = 6 + 8 + 4 + 7 + 3 = 28`. This confirms the result.", "answer": "$$\\boxed{28}$$", "id": "1496951"}]}