{"hands_on_practices": [{"introduction": "Kernelization is the art of simplifying a complex problem by applying a set of polynomial-time reduction rules. The goal is to shrink the initial instance into a smaller, equivalent \"kernel\" whose size is bounded by a function of the parameter $k$. This exercise provides direct, hands-on practice with this fundamental process for the Feedback Vertex Set problem, demonstrating how simple rules can methodically chip away at a graph to isolate its core complexity. [@problem_id:1504250]", "problem": "In computational complexity theory, the Feedback Vertex Set (FVS) problem is a classic graph problem. For an undirected graph $G=(V, E)$, a feedback vertex set is a subset of vertices $S \\subseteq V$ such that the graph $G-S$, obtained by removing the vertices in $S$ and all incident edges, is acyclic (i.e., a forest). The decision version of the FVS problem asks, for a given graph $G$ and an integer parameter $k$, whether there exists a feedback vertex set of size at most $k$.\n\nThis problem is computationally hard in general. However, it is fixed-parameter tractable, which means we can design a kernelization algorithm. A kernelization algorithm consists of a set of polynomial-time reduction rules that transform a problem instance $(G, k)$ into an equivalent, smaller instance $(G', k')$. An instance is considered equivalent if a solution for it can be used to construct a solution for the original instance. For FVS, a rule is safe if any minimum FVS for $G'$ can be transformed into a minimum FVS for $G$ (and vice-versa). An instance is irreducible if no more reduction rules can be applied. The final irreducible instance is called the kernel.\n\nConsider the following two simple reduction rules for the FVS problem:\n- **Rule A (Isolated Vertex Removal):** If a vertex $v$ has a degree of 0, an equivalent instance is formed by removing $v$ from the graph. The new instance is $(G-v, k)$.\n- **Rule B (Leaf Vertex Removal):** If a vertex $v$ has a degree of 1, an equivalent instance is formed by removing $v$ from the graph. The new instance is $(G-v, k)$.\n\nYou are given an undirected graph $G$ with the vertex set $V = \\{v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8, v_9, v_{10}, v_{11}, v_{12}\\}$ and the edge set $E$ containing the following edges: $\\{v_2, v_3\\}$, $\\{v_3, v_4\\}$, $\\{v_4, v_2\\}$, $\\{v_5, v_6\\}$, $\\{v_6, v_7\\}$, $\\{v_7, v_5\\}$, $\\{v_4, v_5\\}$, $\\{v_2, v_8\\}$, $\\{v_8, v_9\\}$, $\\{v_6, v_{10}\\}$, and $\\{v_{11}, v_{12}\\}$.\n\nStarting with the graph $G$, apply Rule A and Rule B repeatedly in any order until the graph is irreducible (i.e., no more applications of either rule are possible). What is the total number of vertices in the final, irreducible graph?", "solution": "We begin with the undirected graph $G=(V,E)$ where $V=\\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6},v_{7},v_{8},v_{9},v_{10},v_{11},v_{12}\\}$ and edges $E=\\{\\{v_{2},v_{3}\\},\\{v_{3},v_{4}\\},\\{v_{4},v_{2}\\},\\{v_{5},v_{6}\\},\\{v_{6},v_{7}\\},\\{v_{7},v_{5}\\},\\{v_{4},v_{5}\\},\\{v_{2},v_{8}\\},\\{v_{8},v_{9}\\},\\{v_{6},v_{10}\\},\\{v_{11},v_{12}\\}\\}$. We compute initial degrees by counting incident edges:\n$$\n\\deg(v_{1})=0,\\quad \\deg(v_{2})=3,\\quad \\deg(v_{3})=2,\\quad \\deg(v_{4})=3,\\quad \\deg(v_{5})=3,\\quad \\deg(v_{6})=3,\n$$\n$$\n\\deg(v_{7})=2,\\quad \\deg(v_{8})=2,\\quad \\deg(v_{9})=1,\\quad \\deg(v_{10})=1,\\quad \\deg(v_{11})=1,\\quad \\deg(v_{12})=1.\n$$\nWe repeatedly apply Rule A (remove isolated vertex) and Rule B (remove leaf).\n\n1) Apply Rule A to $v_{1}$ since $\\deg(v_{1})=0$. The new vertex set is $V_{1}=V\\setminus\\{v_{1}\\}$. Degrees of all other vertices are unchanged.\n\n2) Apply Rule B to $v_{9}$ since $\\deg(v_{9})=1$ with neighbor $v_{8}$. Remove $v_{9}$: $V_{2}=V_{1}\\setminus\\{v_{9}\\}$. Update the neighbor’s degree:\n$$\n\\deg_{2}(v_{8})=\\deg(v_{8})-1=1.\n$$\n\n3) Apply Rule B to $v_{8}$ since now $\\deg_{2}(v_{8})=1$ with neighbor $v_{2}$. Remove $v_{8}$: $V_{3}=V_{2}\\setminus\\{v_{8}\\}$. Update the neighbor’s degree:\n$$\n\\deg_{3}(v_{2})=\\deg(v_{2})-1=2.\n$$\n\n4) Apply Rule B to $v_{10}$ since $\\deg(v_{10})=1$ with neighbor $v_{6}$. Remove $v_{10}$: $V_{4}=V_{3}\\setminus\\{v_{10}\\}$. Update the neighbor’s degree:\n$$\n\\deg_{4}(v_{6})=\\deg(v_{6})-1=2.\n$$\n\n5) Apply Rule B to $v_{11}$ since $\\deg(v_{11})=1$ with neighbor $v_{12}$. Remove $v_{11}$: $V_{5}=V_{4}\\setminus\\{v_{11}\\}$. Update the neighbor’s degree:\n$$\n\\deg_{5}(v_{12})=\\deg(v_{12})-1=0.\n$$\n\n6) Apply Rule A to $v_{12}$ since now $\\deg_{5}(v_{12})=0$. Remove $v_{12}$: $V_{6}=V_{5}\\setminus\\{v_{12}\\}$.\n\nThe remaining vertices are $V_{6}=\\{v_{2},v_{3},v_{4},v_{5},v_{6},v_{7}\\}$. The remaining edges are those not incident to removed vertices:\n$$\nE_{6}=\\{\\{v_{2},v_{3}\\},\\{v_{3},v_{4}\\},\\{v_{4},v_{2}\\},\\{v_{5},v_{6}\\},\\{v_{6},v_{7}\\},\\{v_{7},v_{5}\\},\\{v_{4},v_{5}\\}\\}.\n$$\nCompute final degrees:\n$$\n\\deg_{6}(v_{2})=2,\\quad \\deg_{6}(v_{3})=2,\\quad \\deg_{6}(v_{4})=3,\\quad \\deg_{6}(v_{5})=3,\\quad \\deg_{6}(v_{6})=2,\\quad \\deg_{6}(v_{7})=2.\n$$\nThere are no vertices of degree $0$ or $1$, so no further applications of Rule A or Rule B are possible. The instance is irreducible. Therefore, the total number of vertices in the final irreducible graph is $|V_{6}|=6$.", "answer": "$$\\boxed{6}$$", "id": "1504250"}, {"introduction": "Beyond simply applying reduction rules, a critical skill in parameterized complexity is proving that these rules are \"safe\"—meaning they don't change the answer to the problem. This next practice moves from mechanical application to conceptual justification. You will analyze a preprocessing algorithm for the classic Vertex Cover problem and discover how a property of one structure, a matching, provides a powerful lower bound that helps us make decisions about another, a vertex cover. [@problem_id:1504236]", "problem": "A cybersecurity firm is tasked with installing monitoring software on servers in a large corporate network. The network is modeled as a graph $G=(V, E)$, where the set of vertices $V$ represents the servers and the set of edges $E$ represents direct, insecure connections between them. To secure the network, the firm must deploy software agents on a subset of servers. An agent placed on a server can monitor all of its direct connections. A set of servers $S \\subseteq V$ is considered a valid deployment if every connection in the network has at least one of its two endpoint servers in $S$. In graph theory, such a set $S$ is known as a vertex cover.\n\nDue to budget constraints, the firm can deploy agents on at most $k$ servers. The problem is to determine if a vertex cover of size at most $k$ exists for the given network graph $G$. This is a well-known NP-hard problem.\n\nAn analyst at the firm proposes a simple polynomial-time preprocessing algorithm to quickly identify \"impossible\" cases. The algorithm is as follows:\n1. Given the graph $G$ and the integer budget $k$.\n2. Find a matching $M$ in the graph $G$. A matching is a set of edges where no two edges share a common vertex. The algorithm used to find $M$ is not guaranteed to find a matching of maximum possible size, but it runs in polynomial time.\n3. If the number of edges in the matching, $|M|$, is greater than $k$, the algorithm reports that it is \"IMPOSSIBLE\" to secure the network with at most $k$ agents.\n4. Otherwise (if $|M| \\le k$), the algorithm reports \"POSSIBLY FEASIBLE\".\n\nWhich of the following statements provides the most accurate assessment of the analyst's algorithm?\n\nA. If the algorithm reports \"IMPOSSIBLE\", its conclusion is always correct.\n\nB. If the algorithm reports \"POSSIBLY FEASIBLE\" because it found a matching of size exactly $k$, then it is guaranteed that a vertex cover of size exactly $k$ exists.\n\nC. The algorithm is flawed. If it finds a matching of size $|M| > k$, the \"IMPOSSIBLE\" conclusion could be incorrect because the algorithm might not have found a *maximum* matching. A different, smaller matching might exist that would not trigger the \"IMPOSSIBLE\" condition.\n\nD. The algorithm offers no practical advantage because finding a matching is computationally as difficult as finding a minimum vertex cover.\n\nE. If the algorithm reports \"POSSIBLY FEASIBLE\" because it found a matching of size $|M|  k$, then it is guaranteed that a vertex cover of size at most $k$ exists.", "solution": "We formalize the key relationship between matchings and vertex covers. Let $G=(V,E)$ be any graph. A matching $M \\subseteq E$ is a set of pairwise vertex-disjoint edges. A vertex cover is a set $S \\subseteq V$ such that every edge in $E$ has at least one endpoint in $S$. For any matching $M$ and any vertex cover $S$, we have the inequality\n$$\n|S| \\ge |M|.\n$$\nProof: Each edge in $M$ must be incident to at least one vertex in $S$. Because the edges of $M$ are vertex-disjoint, these incidences require distinct vertices of $S$, so at least one distinct vertex per edge in $M$, implying $|S| \\ge |M|$.\n\nConsequently, letting $\\tau(G)$ be the size of a minimum vertex cover, and for any matching $M$, we get\n$$\n\\tau(G) \\ge |M|.\n$$\n\nNow assess the algorithm:\n\n- If it finds a matching $M$ with $|M|k$, then for every vertex cover $S$,\n$$\n|S| \\ge |M|  k,\n$$\nso no vertex cover of size at most $k$ exists. Therefore, the conclusion \"IMPOSSIBLE\" is always correct in this case. This validates statement A.\n\n- Statement B claims: if it finds a matching of size exactly $k$, then a vertex cover of size exactly $k$ exists. This is false. The inequality only gives $\\tau(G) \\ge k$, not $\\tau(G) \\le k$ nor $\\tau(G)=k$. A concrete counterexample is the triangle graph, where a matching of size $1$ exists, but the minimum vertex cover has size $2$.\n\n- Statement C claims the \"IMPOSSIBLE\" conclusion could be incorrect because the matching might not be maximum. This is false. The lower bound $|S| \\ge |M|$ holds for any matching $M$, not just a maximum one. Thus $|M|k$ already certifies impossibility irrespective of maximality.\n\n- Statement D claims no practical advantage because finding a matching is as hard as finding a minimum vertex cover. This is false: maximum matching can be found in polynomial time in general graphs, while minimum vertex cover is NP-hard in general graphs.\n\n- Statement E claims that finding a matching with $|M|k$ guarantees a vertex cover of size at most $k$. This is false. A small matching gives only a weak lower bound; the minimum vertex cover can still exceed $k$. For instance, in the triangle graph, if the algorithm returns a matching of size $0$ or $1$ and $k=1$, there is no vertex cover of size at most $1$.\n\nTherefore, the most accurate assessment is A.", "answer": "$$\\boxed{A}$$", "id": "1504236"}, {"introduction": "Fixed-parameter tractability is not limited to kernelization; another cornerstone technique is the bounded search tree. This approach tames exponential complexity by exploring a limited search space whose size depends on the parameter $k$. This final practice problem challenges you to analyze the efficiency of such an algorithm, estimating the size of its search tree to understand why it is considered efficient for small values of $k$. [@problem_id:1504264]", "problem": "A graph is called an \"even-degree graph\" if every vertex in the graph has an even degree. A computer scientist is working on the **Even-Degree Subgraph by Vertex Deletion** problem: given a graph $G=(V, E)$ and an integer parameter $k$, can we delete at most $k$ vertices to obtain an even-degree subgraph?\n\nThey propose the following bounded search tree algorithm, named `Solve(G, k)`:\n1.  Identify the set $O$ of vertices with odd degree in the current graph $G$.\n2.  If the set $O$ is empty, the condition is met. Return `TRUE`.\n3.  If $k=0$ and the set $O$ is not empty, we have no more vertices to delete. Return `FALSE`.\n4.  Select an odd-degree vertex $v \\in O$.\n5.  Branch on all possible single-vertex deletions within the closed neighborhood of $v$, denoted $N[v] = \\{v\\} \\cup N(v)$, where $N(v)$ is the set of neighbors of $v$. For each vertex $u \\in N[v]$:\n    a. Recursively call the algorithm `Solve(G-u, k-1)`.\n    b. If this recursive call returns `TRUE`, then a solution is found. Immediately return `TRUE`.\n6.  If all branches have been explored and none returned `TRUE`, then no solution is possible via this path. Return `FALSE`.\n\nFor your analysis, you can rely on an established (but unproven here) result from graph theory: in step 4, it is always possible to select an odd-degree vertex $v$ whose degree in the current graph, $\\deg(v)$, is bounded by $2k'+1$, where $k'$ is the current budget for deletions in that recursive call.\n\nYour task is to determine a tight upper bound on the number of leaves in the search tree generated by this algorithm for an initial budget of $k$. Express your answer as a mathematical expression in terms of $k$.", "solution": "Let $L(k)$ denote the maximum number of leaves in the search tree produced by the algorithm when invoked with budget $k$.\n\nBase cases:\n- If $k=0$, the algorithm returns immediately in step 2 or step 3 without branching, hence $L(0) \\leq 1$.\n\nInductive branching bound:\n- Consider a recursive call with current budget $k' \\geq 1$. By the given graph-theoretic guarantee, there exists an odd-degree vertex $v$ with $\\deg(v) \\leq 2k' + 1$.\n- The algorithm branches on all vertices in $N[v]$, so the number of branches at this node is at most\n$$\n|N[v]| \\leq \\deg(v) + 1 \\leq 2k' + 2.\n$$\n- Each branch reduces the budget by one, so the number of leaves satisfies the recurrence\n$$\nL(k') \\leq (2k' + 2)\\,L(k' - 1), \\quad \\text{for } k' \\geq 1,\n$$\nwith $L(0) \\leq 1$.\n\nUnfolding the recurrence from $k$ down to $0$ yields\n$$\nL(k) \\leq \\prod_{i=1}^{k} (2i + 2)\\,L(0) \\leq \\prod_{i=1}^{k} (2i + 2).\n$$\nEvaluate the product:\n$$\n\\prod_{i=1}^{k} (2i + 2) = 2^{k} \\prod_{i=1}^{k} (i + 1) = 2^{k} (k + 1)!.\n$$\n\nTherefore, the number of leaves is upper-bounded by $2^{k} (k+1)!$. This bound is tight for this branching scheme and degree bound, since there exist worst-case instances in which at each level the chosen odd-degree vertex achieves $\\deg(v) = 2k' + 1$ and no branch terminates early before exhausting the budget, realizing the full product of branching factors.", "answer": "$$\\boxed{2^{k}(k+1)!}$$", "id": "1504264"}]}