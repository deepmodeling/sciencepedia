## Introduction
In the vast field of graph theory, the tree stands out for its elegant simplicity and widespread utility. As a connected graph with no cycles, it forms the backbone of many networks. However, its true [expressive power](@entry_id:149863) is unlocked by a single, transformative act: designating one vertex as the root. This simple choice imposes a rich hierarchical order, turning an egalitarian structure into a powerful tool for organizing information, modeling processes, and designing efficient algorithms. This article bridges the gap between the abstract concept of a tree and the concrete applications of its rooted form, demonstrating how this hierarchical framework provides solutions to problems across numerous scientific disciplines.

Over the following chapters, we will embark on a comprehensive exploration of rooted trees. The journey begins in **Principles and Mechanisms**, where we will establish the foundational vocabulary and properties that arise from rooting a tree, from parent-child relationships and node depth to the critical concept of the Lowest Common Ancestor. We will then transition to **Applications and Interdisciplinary Connections**, showcasing how these theoretical constructs are used to model everything from computer [file systems](@entry_id:637851) and evolutionary lineages to game strategies and the structure of polymers. Finally, the **Hands-On Practices** section will provide you with the opportunity to solidify your understanding by tackling practical problems that challenge you to construct, analyze, and apply the concepts of rooted trees.

## Principles and Mechanisms

In the study of graph theory, while the abstract structure of a tree—a connected, [acyclic graph](@entry_id:272495)—is of fundamental importance, many of its most powerful applications emerge when we impose an additional layer of organization. This is achieved by designating a single vertex as a point of reference, thereby transforming an egalitarian network into a well-defined hierarchy. This chapter explores the principles and mechanisms governing these **rooted trees**, from the foundational act of establishing a root to the rich vocabulary and structural properties that follow.

### From Unrooted to Rooted Trees: Establishing Hierarchy

An [unrooted tree](@entry_id:199885) is an [undirected graph](@entry_id:263035) characterized by its connectivity and absence of cycles. In this state, all vertices are structurally equivalent in the sense that no single vertex holds a privileged position. The transformation into a [rooted tree](@entry_id:266860) begins with a simple but profound action: the selection of a single, arbitrary vertex to be the **root**.

This designation immediately imposes a directional and hierarchical order upon the entire structure. For any non-root vertex $v$, there exists a unique simple path connecting it to the root $r$. The **parent** of $v$ is defined as the unique neighbor of $v$ that lies on this path. Correspondingly, $v$ is a **child** of its parent. Crucially, this set of parent-child relationships is uniquely and deterministically established for the entire tree the moment a root is chosen [@problem_id:1531609]. The uniqueness of paths in a tree guarantees that every non-root vertex has exactly one parent, and this relationship is not dependent on any particular algorithm, such as Breadth-First Search or Depth-First Search, used to traverse the tree. The structure is an inherent consequence of the chosen root and the tree's topology.

### The Vocabulary of Kinship: Navigating the Tree Structure

The parent-child relationship is the atomic unit of the hierarchy in a [rooted tree](@entry_id:266860), from which a complete and intuitive vocabulary of kinship emerges. This terminology is essential for describing navigation and relationships within the tree.

-   **Parent and Child:** As defined, a vertex $u$ is the parent of $v$ if there is a directed edge from $u$ to $v$ away from the root. This is equivalent to saying $u$ is the immediate vertex on the path from $v$ to the root.

-   **Path to the Root:** A direct consequence of each non-root vertex having a unique parent is that there is a unique path from any vertex $v$ back to the root. This path is generated by starting at $v$ and repeatedly moving to the parent vertex until the root, which has no parent, is reached [@problem_id:1531594]. This property is fundamental to many tree-based algorithms and [data structures](@entry_id:262134), such as those modeling [file systems](@entry_id:637851), where one can always navigate from any subdirectory back to the main root directory.

-   **Siblings:** Vertices that share the same parent are called **siblings**. The root, having no parent, has no siblings.

-   **Leaf and Internal Nodes:** Vertices in a [rooted tree](@entry_id:266860) can be classified based on their number of children. A vertex with no children is called a **leaf node** (or terminal node). A vertex that has at least one child is an **internal node**. This definition is precise and robust; for instance, it correctly handles the case of a trivial tree consisting of a single vertex, which is both the root and a leaf. Alternative characterizations, such as a leaf being a vertex of degree 1, can be misleading in the context of rooted trees, as a root with a single child also has degree 1 but is an internal node [@problem_id:1397572].

To illustrate these concepts, consider a hierarchical structure modeled as a computer's file system [@problem_id:1531595]. Let directory 1 be the root. If directory 1 contains directories 2, 3, and 4, then 1 is the parent of 2, 3, and 4. These three directories are children of 1 and are siblings to each other. If directory 2 in turn contains directories 5 and 6, then 2 is an internal node, and its children are 5 and 6. If directory 3 has no subdirectories, it is a leaf node.

### Vertical Dimensions: Depth, Level, and Height

The hierarchical structure of a [rooted tree](@entry_id:266860) gives rise to natural concepts of vertical position and overall stature. These are quantified using the notions of depth, level, and height.

The **depth** of a vertex $v$ is the length of the unique simple path (i.e., the number of edges) from the root to $v$. By this definition, the path from the root to itself contains zero edges, so the root is the unique vertex in any non-empty [rooted tree](@entry_id:266860) with a depth of 0 [@problem_id:1531622]. The terms **depth** and **level** are often used interchangeably in literature.

The **height** of a [rooted tree](@entry_id:266860) is defined as the maximum depth found among all its vertices. It represents the "tallest" branch of the tree. For example, consider a tree with root $A$. The children of $A$ are $B$ and $C$. $B$'s only child is $D$. $C$'s children are $E$ and $F$. Finally, $E$'s only child is $G$ [@problem_id:1531626]. We can calculate the depths of all vertices:
-   Depth of $A$ is $0$.
-   Depth of $B$ and $C$ is $1$.
-   Depth of $D$ (path $A \to B \to D$) is $2$.
-   Depth of $E$ and $F$ (path $A \to C \to E/F$) is $2$.
-   Depth of $G$ (path $A \to C \to E \to G$) is $3$.

The set of depths is $\{0, 1, 2, 3\}$. The maximum value in this set is $3$, so the height of the tree is $3$. The depth of vertex $D$ is $2$. The final result for the pair (depth of D, height of tree) is thus $\begin{pmatrix} 2  3 \end{pmatrix}$.

### Ancestors and Descendants: The Lineage of Nodes

The hierarchical paths in a [rooted tree](@entry_id:266860) define lineage relationships. A vertex $u$ is an **ancestor** of a vertex $v$ if $u$ lies on the unique path from the root to $v$ (and $u \ne v$). Conversely, $v$ is a **descendant** of $u$. The set of a vertex's ancestors is simply the set of vertices on the path connecting it to the root.

A key insight connects depth and ancestry: the depth of any node $v$ is precisely equal to the number of its ancestors [@problem_id:1531643]. This is because each edge on the path from the root to $v$ corresponds to moving from a parent to a child, with each parent being an ancestor.

A particularly important ancestral concept is the **Lowest Common Ancestor (LCA)**. For any two vertices $u$ and $v$, their LCA, denoted $\text{lca}(u, v)$, is the common ancestor of both $u$ and $v$ that has the greatest depth. It is the vertex where the paths from $u$ and $v$ back to the root first converge.

The LCA possesses a remarkable and non-obvious property concerning any three distinct vertices. Given any three vertices $u$, $v$, and $w$, at least two of the three pairwise LCAs—$\text{lca}(u,v)$, $\text{lca}(v,w)$, and $\text{lca}(u,w)$—must be the same vertex [@problem_id:1531598]. To see why, consider the LCA of two of the vertices, say $z = \text{lca}(v,w)$. The paths from $v$ and $w$ to the root meet at $z$. The third vertex, $u$, must lie in a subtree rooted at some child of $z$, or perhaps $u=z$. If $u$ is in the same subtree descending from $z$ as $v$, then the LCA of $u$ and $w$ will be $z$. If $u$ is in the same subtree as $w$, the LCA of $u$ and $v$ will be $z$. If $u$ is in a different subtree from both $v$ and $w$, then the LCA of $u$ and $v$ is $z$, and the LCA of $u$ and $w$ is also $z$. In every case, at least one of the other two LCAs is also $z$, proving the statement.

### Special Classes of Rooted Trees

While the general theory of rooted trees is broadly applicable, certain subclasses with more constrained structures are of immense practical and theoretical importance, particularly in computer science.

A **binary tree** is a [rooted tree](@entry_id:266860) where every node has at most two children. This simple constraint is the basis for widely used [data structures](@entry_id:262134) like [binary search](@entry_id:266342) trees.

A more restrictive category is the **full binary tree**, where every node has either zero children (it is a leaf) or exactly two children. In a full [binary tree](@entry_id:263879), no node has only one child.

The structural differences between these classes can be profound. Consider two types of [binary trees](@entry_id:270401) of a given height $h$ [@problem_id:1397617].
-   **Architecture A:** A *perfect binary tree*, which is a full binary tree where all leaf nodes are at the same depth, $h$. At each depth $d \lt h$, there are $2^d$ nodes, and at the final depth $h$, there are $L_A(h) = 2^h$ leaf nodes.
-   **Architecture B:** A "skewed" [binary tree](@entry_id:263879) of height $h \ge 1$, where the root has a right child that is a leaf, and a left child that is the root of an identical structure of height $h-1$. This recursive construction yields a tree with $L_B(h) = L_B(h-1) + 1$ leaves. With $L_B(0)=1$ (a single node), the solution to this recurrence is $L_B(h) = h+1$.

For any height $h \gt 0$, the difference in the number of leaves between these two architectures is $L_A(h) - L_B(h) = 2^h - (h+1)$. This demonstrates how significantly the distribution of internal nodes affects the tree's overall shape and leaf count, even when height is held constant.

### Isomorphism in Rooted Trees: When Are Two Trees the Same?

The concept of [isomorphism](@entry_id:137127) allows us to determine if two graphs are structurally identical. For unrooted graphs, two trees are isomorphic if there is a one-to-one correspondence between their vertices that preserves adjacency. However, for rooted trees, this condition is necessary but not sufficient.

Two rooted trees, $T_1$ with root $r_1$ and $T_2$ with root $r_2$, are **isomorphic as rooted trees** only if there exists a [graph isomorphism](@entry_id:143072) $f$ between them that also preserves the root, meaning $f(r_1) = r_2$. This implies that the entire parent-child hierarchy must be preserved by the mapping.

This stricter definition means that two rooted trees can be isomorphic as unrooted graphs but fail to be isomorphic as rooted trees. The choice of the root is an integral part of the structure's identity. Consider an unrooted path graph on four vertices, $v_1-v_2-v_3-v_4$.
- If we root it at $v_2$, we get a tree of height 2 where the root has two children, $v_1$ and $v_3$.
- If we root it at $v_1$, we get a tree of height 3 where the root has one child, $v_2$.

Although both rooted trees derive from the same underlying graph, their root vertices have different numbers of children (different degrees). Since any [isomorphism](@entry_id:137127) must preserve vertex degrees, there can be no [rooted tree](@entry_id:266860) [isomorphism](@entry_id:137127) between them. An [isomorphism](@entry_id:137127) of rooted trees must map the root to the root, and since their degrees differ, this is impossible [@problem_id:1397598]. This example powerfully illustrates that rooting a tree is not just labeling a vertex; it fundamentally defines the character of the resulting hierarchical structure.