{"hands_on_practices": [{"introduction": "The genesis of the Van der Pol oscillator's self-sustaining behavior lies in the instability of its equilibrium point at the origin. This exercise guides you through the essential technique of linearization to analyze the local dynamics in phase space. By determining the eigenvalues of the system's Jacobian matrix, you will uncover the mathematical reason why small perturbations grow, driving the system away from rest and into its characteristic limit cycle. [@problem_id:1067889]", "problem": "The Van der Pol oscillator is a well-known non-conservative oscillator with non-linear damping. A generalized form of the Van der Pol equation is given by the second-order ordinary differential equation:\n$$ \\frac{d^2x}{dt^2} - \\mu(1-\\alpha x^2)\\frac{dx}{dt} + \\omega_0^2 x = 0 $$\nwhere $x(t)$ is the displacement, $\\mu > 0$ is the damping coefficient, $\\alpha > 0$ is a parameter related to the non-linearity, and $\\omega_0 > 0$ is the natural frequency of the undamped, linear oscillator.\n\nThis system can be analyzed by converting it into a system of two first-order differential equations. The stability of its fixed points is determined by the eigenvalues of the Jacobian matrix of the system evaluated at those points. The system has a fixed point at the origin $(x, \\frac{dx}{dt}) = (0,0)$.\n\nFor the case where the system exhibits stable or unstable spiral behavior around the origin, the eigenvalues of the Jacobian matrix are a complex conjugate pair. This occurs when the parameters satisfy the condition $\\mu^2  4\\omega_0^2$.\n\nYour task is to derive the magnitude (absolute value) of the imaginary part of these complex eigenvalues.", "solution": "We set $x_1=x,\\;x_2=\\dot x$. Then the system becomes\n$$x_1' = x_2,$$\n$$x_2' = \\mu\\bigl(1-\\alpha x_1^2\\bigr)x_2-\\omega_0^2x_1.$$\nThe Jacobian matrix is\n$$J=\\begin{pmatrix}\n\\partial_{x_1}x_1'  \\partial_{x_2}x_1'\\\\\n\\partial_{x_1}x_2'  \\partial_{x_2}x_2'\n\\end{pmatrix}\n=\\begin{pmatrix}\n0  1\\\\\n-2\\mu\\alpha x_1 x_2 - \\omega_0^2  \\mu(1-\\alpha x_1^2)\n\\end{pmatrix}.$$\nAt the fixed point $(0,0)$ this reduces to\n$$J(0,0)=\\begin{pmatrix}01\\\\-\\omega_0^2\\mu\\end{pmatrix}.$$\nThe characteristic equation is\n$$\\det\\bigl(J(0,0)-\\lambda I\\bigr)\n=\\begin{vmatrix}-\\lambda1\\\\-\\omega_0^2\\mu-\\lambda\\end{vmatrix}\n=\\lambda^2-\\mu\\lambda+\\omega_0^2=0.$$\nHence the eigenvalues are\n$$\\lambda=\\frac{\\mu\\pm\\sqrt{\\mu^2-4\\omega_0^2}}{2}.$$\nWhen $\\mu^24\\omega_0^2$ these are complex conjugates,\n$$\\lambda=\\frac\\mu2\\pm i\\,\\frac{\\sqrt{4\\omega_0^2-\\mu^2}}{2},$$\nso the magnitude of the imaginary part is\n$$\\frac{\\sqrt{4\\omega_0^2-\\mu^2}}{2}\\,. $$", "answer": "$$\\boxed{\\frac{\\sqrt{4\\omega_0^2-\\mu^2}}{2}}$$", "id": "1067889"}, {"introduction": "Having explored the local instability at the origin, we now turn to the global behavior in the strongly nonlinear regime where $\\mu \\gg 1$. Here, the oscillator exhibits striking \"relaxation oscillations,\" characterized by long periods of slow energy storage followed by rapid discharges. This practice challenges you to apply asymptotic analysis to the \"slow manifold\" of the trajectory, allowing you to derive a direct relationship between the observable period of oscillation and the hidden nonlinearity parameter $\\mu$. [@problem_id:1943841]", "problem": "The dynamics of a self-sustained oscillation can be modeled by the van der Pol oscillator equation, given by:\n$$ \\frac{d^{2}x}{dt^{2}} - \\mu(1-x^{2})\\frac{dx}{dt} + x = 0 $$\nwhere $x(t)$ is the displacement as a function of time $t$, and $\\mu$ is a positive dimensionless parameter that controls the nonlinearity and damping.\n\nA numerical simulation of this system is performed for an unknown, large value of $\\mu$. The system is observed to settle into a stable limit cycle, also known as a relaxation oscillation. In the phase plane, defined by coordinates $(x, v)$ where $v = dx/dt$, this cycle consists of segments of slow evolution punctuated by extremely rapid jumps.\n\nIt is found that the total period of one full oscillation is $T = 403.4$.\n\nFurther analysis of the simulation data reveals that during the slow segments, which account for almost the entire duration of the period, the trajectory in the phase plane adheres closely to the curve described by the equation:\n$$ v = \\frac{x}{\\mu(1-x^{2})} $$\nOne of these slow segments corresponds to the trajectory moving from an extremum at $x=2$ to a point of instability at $x=1$. A second, symmetric slow segment sees the trajectory move from $x=-2$ to $x=-1$. You may assume the time taken for the rapid jumps connecting these slow segments is negligible.\n\nUsing this information, estimate the value of the parameter $\\mu$ used in the simulation. Round your final answer to three significant figures.", "solution": "The problem asks us to estimate the parameter $\\mu$ of the van der Pol oscillator given the total period of oscillation and a description of the trajectory in the phase plane for large $\\mu$.\n\nThe key information is that the period $T$ is dominated by two \"slow\" segments, and during these segments, the velocity $v = dx/dt$ is well-approximated by $v = \\frac{x}{\\mu(1-x^2)}$. The time spent during the rapid jumps is considered negligible.\n\nLet's calculate the time taken for one of the slow segments. The relationship between time $t$ and position $x$ is given by $v = dx/dt$. We can express an infinitesimal time interval $dt$ as:\n$$ dt = \\frac{dx}{v(x)} $$\nSubstituting the given expression for $v(x)$ during the slow segment:\n$$ dt = \\frac{dx}{\\frac{x}{\\mu(1-x^2)}} = \\frac{\\mu(1-x^2)}{x} dx $$\nThe problem states that one slow segment corresponds to the motion from $x_i = 2$ to $x_f = 1$. The time for this segment, which we'll call $T_{slow,1}$, can be found by integrating $dt$ between these limits:\n$$ T_{slow,1} = \\int_{x_i}^{x_f} \\frac{\\mu(1-x^2)}{x} dx = \\int_{2}^{1} \\mu \\left(\\frac{1}{x} - x\\right) dx $$\nWe can take the constant $\\mu$ out of the integral:\n$$ T_{slow,1} = \\mu \\int_{2}^{1} \\left(\\frac{1}{x} - x\\right) dx $$\nNow, we evaluate the definite integral:\n$$ T_{slow,1} = \\mu \\left[ \\ln|x| - \\frac{x^2}{2} \\right]_{2}^{1} $$\nPlugging in the limits of integration:\n$$ T_{slow,1} = \\mu \\left( \\left(\\ln(1) - \\frac{1^2}{2}\\right) - \\left(\\ln(2) - \\frac{2^2}{2}\\right) \\right) $$\n$$ T_{slow,1} = \\mu \\left( \\left(0 - \\frac{1}{2}\\right) - \\left(\\ln(2) - 2\\right) \\right) $$\n$$ T_{slow,1} = \\mu \\left( -\\frac{1}{2} - \\ln(2) + 2 \\right) = \\mu \\left(\\frac{3}{2} - \\ln(2)\\right) $$\nThe problem states that the full limit cycle consists of two such symmetric slow segments. The second segment runs from $x=-2$ to $x=-1$. Due to the symmetry of the integrand function $f(x) = \\frac{1}{x}-x$ (since $f(-x) = -f(x)$) and the symmetric limits, the time for the second segment $T_{slow,2}$ is equal to $T_{slow,1}$.\n$$ T_{slow,2} = \\int_{-2}^{-1} \\mu \\left(\\frac{1}{x} - x\\right) dx = \\mu \\left[ \\ln|x| - \\frac{x^2}{2} \\right]_{-2}^{-1} = \\mu \\left( (\\ln(1)-\\frac{1}{2}) - (\\ln(2)-\\frac{4}{2}) \\right) = \\mu \\left(\\frac{3}{2} - \\ln(2)\\right) $$\nThe total period $T$ is the sum of the durations of these two slow segments, as the time for the fast jumps is negligible.\n$$ T \\approx T_{slow,1} + T_{slow,2} = 2 \\times \\mu \\left(\\frac{3}{2} - \\ln(2)\\right) = \\mu (3 - 2\\ln(2)) $$\nWe are given that the measured period is $T = 403.4$. We can now solve for $\\mu$:\n$$ 403.4 = \\mu (3 - 2\\ln(2)) $$\n$$ \\mu = \\frac{403.4}{3 - 2\\ln(2)} $$\nNow we compute the numerical value. Using the value $\\ln(2) \\approx 0.693147$:\n$$ 3 - 2\\ln(2) \\approx 3 - 2(0.693147) = 3 - 1.386294 = 1.613706 $$\n$$ \\mu = \\frac{403.4}{1.613706} \\approx 249.989... $$\nThe problem asks to round the final answer to three significant figures.\n$$ \\mu \\approx 250. $$\nTo express this unambiguously with three significant figures, we write it in scientific notation.\n$$ \\mu \\approx 2.50 \\times 10^2 $$", "answer": "$$\\boxed{2.50 \\times 10^{2}}$$", "id": "1943841"}, {"introduction": "Analytical approximations provide invaluable insight but are often limited to specific parameter regimes. This computational exercise serves as a virtual laboratory to explore the Van der Pol oscillator's dynamics without such constraints. By implementing the fourth-order Runge-Kutta method, you will not only visualize the limit cycle but also numerically verify its most crucial property: its stability and role as an attractor for trajectories starting both inside and outside its boundary. [@problem_id:2395985]", "problem": "You are to write a complete, runnable program that uses the classical fourth-order Runge–Kutta method to study the van der Pol oscillator. The van der Pol oscillator is the second-order ordinary differential equation (ODE) $$\\frac{d^2 x}{dt^2} - \\mu \\left(1 - x^2\\right)\\frac{dx}{dt} + x = 0,$$ which you must convert to a first-order system by defining $y = \\frac{dx}{dt}$, so that $$\\frac{dx}{dt} = y,\\quad \\frac{dy}{dt} = \\mu \\left(1 - x^2\\right) y - x.$$ All variables are dimensionless.\n\nYour task is to implement the classical fourth-order Runge–Kutta time-stepping method with a fixed step size to integrate the system above for several parameter sets and initial conditions. You must then quantify the emergence of a limit cycle by extracting an asymptotic amplitude from the long-time behavior, and demonstrate that trajectories starting inside or outside the cycle converge to it for positive $\\mu$.\n\nFundamental base you may assume: the definition of an ordinary differential equation, the notion of an initial value problem, and Newtonian kinematics linking $\\frac{dx}{dt}$, $\\frac{dy}{dt}$, and state evolution. You must not use any prebuilt ODE solvers.\n\nImplement the following steps:\n- Use the classical fourth-order Runge–Kutta method with a fixed time step $h$ to advance the state $(x,y)$ in time, for the right-hand side defined above. Do not use any adaptive time-stepping.\n- For each simulation, define a total time $T$ and discard an initial transient of duration $T_{\\mathrm{trans}}$ from the analysis. Over the remaining data, compute an amplitude estimate $$A = \\frac{1}{2}\\left(\\max x - \\min x\\right),$$ where the extrema are taken over the time interval $[T - T_{\\mathrm{trans}}, T]$.\n- For a given $\\mu$, simulate two trajectories with distinct initial conditions, one “inside” and one “outside” the eventual limit cycle, and compute the two amplitudes $A_{\\mathrm{in}}$ and $A_{\\mathrm{out}}$. Then compute a boolean convergence indicator defined by $$\\left|A_{\\mathrm{in}} - A_{\\mathrm{out}}\\right|  \\varepsilon,$$ with a prescribed tolerance $\\varepsilon$.\n\nUse the following test suite of parameter values, time grids, and tolerances:\n- Test $1$ (nonstiff, visible convergence to a unique limit cycle): $\\mu = 1$, $T = 120$, $T_{\\mathrm{trans}} = 60$, $h = 0.01$, initial conditions $(x_0,y_0) = (0.1,0.1)$ and $(x_0,y_0) = (3.0,0.0)$, tolerance $\\varepsilon = 2\\times 10^{-2}$.\n- Test $2$ (more nonlinear, relaxation oscillations; small fixed step to control error): $\\mu = 5$, $T = 200$, $T_{\\mathrm{trans}} = 100$, $h = 0.002$, initial conditions $(x_0,y_0) = (0.1,0.1)$ and $(x_0,y_0) = (3.0,0.0)$, tolerance $\\varepsilon = 5\\times 10^{-2}$.\n- Test $3$ (boundary case with no nonlinearity and no attracting limit cycle): $\\mu = 0$, $T = 60$, $T_{\\mathrm{trans}} = 30$, $h = 0.01$, initial conditions $(x_0,y_0) = (0.1,0.1)$ and $(x_0,y_0) = (3.0,0.0)$, tolerance $\\varepsilon = 5\\times 10^{-2}$.\n\nFor each test, compute the pair of amplitudes $A_{\\mathrm{in}}$ and $A_{\\mathrm{out}}$, and also compute the boolean convergence indicator defined above. Your program must aggregate all results into a single line of output containing the $9$ values in the following order:\n$$[A_{1,\\mathrm{in}}, A_{1,\\mathrm{out}}, C_1, A_{2,\\mathrm{in}}, A_{2,\\mathrm{out}}, C_2, A_{3,\\mathrm{in}}, A_{3,\\mathrm{out}}, C_3],$$\nwhere $C_k$ is the boolean convergence indicator for test $k$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\dots\\right]$. No extra text should be printed.\n\nAngle units are not applicable. There are no physical units since the system is nondimensional. All numeric values must be represented as floating-point numbers or booleans as appropriate in the final output. The program must be self-contained and must not read any input. Ensure that your implementation adheres strictly to the classical fourth-order Runge–Kutta method and the specified time-stepping parameters, without using any external ODE solvers.", "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\nThe problem asks for the numerical solution of the van der Pol oscillator equation, which is a second-order ordinary differential equation (ODE):\n$$\n\\frac{d^2 x}{dt^2} - \\mu \\left(1 - x^2\\right)\\frac{dx}{dt} + x = 0\n$$\nThis is to be converted into a system of two first-order ODEs by defining a new variable $y = \\frac{dx}{dt}$. The resulting system is:\n$$\n\\frac{dx}{dt} = y\n$$\n$$\n\\frac{dy}{dt} = \\mu \\left(1 - x^2\\right) y - x\n$$\nThe numerical method to be used is the classical fourth-order Runge-Kutta (RK4) method with a fixed time step $h$.\n\nFor each simulation run over a total time $T$, an amplitude $A$ is to be computed from the trajectory data. An initial portion of the data, corresponding to a transient time $T_{\\mathrm{trans}}$, is to be discarded. The amplitude is defined as:\n$$\nA = \\frac{1}{2}\\left(\\max x - \\min x\\right)\n$$\nwhere the maximum and minimum are evaluated over the time interval $[T - T_{\\mathrm{trans}}, T]$.\n\nFor each set of parameters, two trajectories are simulated, one starting \"inside\" the limit cycle ($A_{\\mathrm{in}}$) and one \"outside\" ($A_{\\mathrm{out}}$). A boolean convergence indicator, $C$, is then computed as:\n$$\nC = \\left(\\left|A_{\\mathrm{in}} - A_{\\mathrm{out}}\\right|  \\varepsilon\\right)\n$$\nwhere $\\varepsilon$ is a given tolerance.\n\nThe specific test cases are:\n1.  **Test 1**: $\\mu = 1$, $T = 120$, $T_{\\mathrm{trans}} = 60$, $h = 0.01$.\n    Initial conditions: $(x_0, y_0) = (0.1, 0.1)$ (\"in\") and $(x_0, y_0) = (3.0, 0.0)$ (\"out\").\n    Tolerance: $\\varepsilon = 2 \\times 10^{-2}$.\n2.  **Test 2**: $\\mu = 5$, $T = 200$, $T_{\\mathrm{trans}} = 100$, $h = 0.002$.\n    Initial conditions: $(x_0, y_0) = (0.1, 0.1)$ (\"in\") and $(x_0, y_0) = (3.0, 0.0)$ (\"out\").\n    Tolerance: $\\varepsilon = 5 \\times 10^{-2}$.\n3.  **Test 3**: $\\mu = 0$, $T = 60$, $T_{\\mathrm{trans}} = 30$, $h = 0.01$.\n    Initial conditions: $(x_0, y_0) = (0.1, 0.1)$ (\"in\") and $(x_0, y_0) = (3.0, 0.0)$ (\"out\").\n    Tolerance: $\\varepsilon = 5 \\times 10^{-2}$.\n\nThe final output must be a single line containing nine values in the order: $[A_{1,\\mathrm{in}}, A_{1,\\mathrm{out}}, C_1, A_{2,\\mathrm{in}}, A_{2,\\mathrm{out}}, C_2, A_{3,\\mathrm{in}}, A_{3,\\mathrm{out}}, C_3]$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n-   **Scientifically Grounded**: The problem is based on the van der Pol oscillator, a canonical model in the field of nonlinear dynamics and chaos theory. The fourth-order Runge-Kutta method is a standard, well-established numerical technique for solving ODEs. The concept of a limit cycle and its attracting properties are fundamental to the study of such systems. The problem is scientifically sound.\n-   **Well-Posed**: The problem is an initial value problem for a system of ODEs. All necessary parameters ($\\mu$), initial conditions ($(x_0, y_0)$), integration parameters ($h, T$), and post-processing steps (analysis window, amplitude formula, convergence criterion) are explicitly and unambiguously defined. A unique numerical solution is expected for the given setup.\n-   **Objective**: The problem is specified using precise mathematical language and objective, quantitative criteria. There is no subjective or opinion-based content.\n-   **No other flaws**: The problem is self-contained, with no missing information. The parameters are consistent and physically reasonable for a numerical study. The problem is not trivial, metaphorical, or unverifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\nThe core of the solution is the implementation of the classical fourth-order Runge-Kutta method for the given system of ODEs. Let the state of the system at time $t$ be represented by the vector $\\mathbf{z}(t) = [x(t), y(t)]^T$. The system of ODEs can be written in vector form as $\\frac{d\\mathbf{z}}{dt} = \\mathbf{f}(\\mathbf{z}, \\mu)$, where the function $\\mathbf{f}$ is:\n$$\n\\mathbf{f}(\\mathbf{z}, \\mu) = \\begin{pmatrix} y \\\\ \\mu(1-x^2)y - x \\end{pmatrix}\n$$\nThe RK4 method advances the solution from time $t_n$ to $t_{n+1} = t_n + h$ using the following steps:\n1.  Compute the first slope estimate: $\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{z}_n, \\mu)$.\n2.  Compute the second slope estimate at the midpoint, using $\\mathbf{k}_1$: $\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{z}_n + \\frac{h}{2}\\mathbf{k}_1, \\mu)$.\n3.  Compute the third slope estimate at the midpoint, using $\\mathbf{k}_2$: $\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{z}_n + \\frac{h}{2}\\mathbf{k}_2, \\mu)$.\n4.  Compute the fourth slope estimate at the end of the interval, using $\\mathbf{k}_3$: $\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{z}_n + h\\mathbf{k}_3, \\mu)$.\n5.  Combine the slopes to get the state at the next time step: $\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$.\n\nThis process is repeated for a total number of steps $N = T/h$, starting from a given initial condition $\\mathbf{z}_0 = [x_0, y_0]^T$. During the integration, the history of the $x$ component of the state vector is stored.\n\nAfter the simulation is complete, the analysis is performed. The problem specifies that the extrema are taken over the time interval $[T - T_{\\mathrm{trans}}, T]$. For all test cases, it happens that $T - T_{\\mathrm{trans}} = T_{\\mathrm{trans}}$. This means the analysis window corresponds to the second half of the simulation data. The starting index for this analysis window in the history array, which has $N+1$ points, is $i_{\\mathrm{start}} = T_{\\mathrm{trans}} / h$. The algorithm then finds the maximum and minimum values of $x$ in the slice of the history array from this index to the end. These are used to compute the amplitude $A$.\n\nFor each test case, this entire procedure (simulation and analysis) is performed twice: once for the \"in\" initial condition to find $A_{\\mathrm{in}}$, and once for the \"out\" initial condition to find $A_{\\mathrm{out}}$. The convergence condition $|A_{\\mathrm{in}} - A_{\\mathrm{out}}|  \\varepsilon$ is then evaluated to produce a boolean result, $C$.\n\nThe special case $\\mu = 0$ corresponds to the simple harmonic oscillator, $\\frac{d^2x}{dt^2} + x = 0$. This system does not have an attracting limit cycle; its amplitude is conserved and depends entirely on the initial conditions. Therefore, we expect $A_{\\mathrm{in}}$ and $A_{\\mathrm{out}}$ to be significantly different, leading to a a convergence indicator of `False`. For $\\mu  0$, the system has a unique, stable limit cycle, so trajectories starting inside and outside are expected to converge to it, yielding `True` for the convergence indicator, provided the simulation time and numerical accuracy are sufficient. The provided parameters are chosen to demonstrate this behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the van der Pol oscillator problem for a set of test cases.\n    Implements the classical RK4 method and analyzes trajectory convergence.\n    \"\"\"\n\n    def f(z, mu):\n        \"\"\"\n        Calculates the derivative vector for the van der Pol system.\n        z: state vector [x, y]\n        mu: nonlinearity parameter\n        \"\"\"\n        x, y = z\n        dxdt = y\n        dydt = mu * (1.0 - x**2) * y - x\n        return np.array([dxdt, dydt])\n\n    def rk4_step(z, h, mu):\n        \"\"\"\n        Performs a single step of the classical 4th-order Runge-Kutta method.\n        z: current state vector [x, y]\n        h: time step\n        mu: nonlinearity parameter\n        \"\"\"\n        k1 = f(z, mu)\n        k2 = f(z + 0.5 * h * k1, mu)\n        k3 = f(z + 0.5 * h * k2, mu)\n        k4 = f(z + h * k3, mu)\n        return z + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def run_simulation(mu, ic, T, h):\n        \"\"\"\n        Runs a full simulation for the van der Pol oscillator.\n        mu: nonlinearity parameter\n        ic: initial condition (x0, y0)\n        T: total simulation time\n        h: time step\n        Returns: array of x-positions over time.\n        \"\"\"\n        n_steps = int(T / h)\n        x_history = np.zeros(n_steps + 1)\n        \n        z = np.array(ic, dtype=float)\n        x_history[0] = z[0]\n        \n        for i in range(n_steps):\n            z = rk4_step(z, h, mu)\n            x_history[i+1] = z[0]\n            \n        return x_history\n\n    def calculate_amplitude(x_history, T_trans, h):\n        \"\"\"\n        Calculates the asymptotic amplitude from the trajectory.\n        x_history: array of x-positions\n        T_trans: duration of transient to discard\n        h: time step\n        \"\"\"\n        # The analysis is over the interval [T_trans, T].\n        # The start index corresponds to time t = T_trans.\n        analysis_start_index = int(T_trans / h)\n        \n        # Slice the history to get the analysis window\n        analysis_window = x_history[analysis_start_index:]\n        \n        max_x = np.max(analysis_window)\n        min_x = np.min(analysis_window)\n        \n        return 0.5 * (max_x - min_x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (mu, T, T_trans, h, ic_in, ic_out, epsilon)\n        (1.0, 120.0, 60.0, 0.01, (0.1, 0.1), (3.0, 0.0), 2e-2),\n        (5.0, 200.0, 100.0, 0.002, (0.1, 0.1), (3.0, 0.0), 5e-2),\n        (0.0, 60.0, 30.0, 0.01, (0.1, 0.1), (3.0, 0.0), 5e-2)\n    ]\n\n    all_results = []\n    \n    for mu, T, T_trans, h, ic_in, ic_out, epsilon in test_cases:\n        # Run simulation for the \"inside\" trajectory\n        x_history_in = run_simulation(mu, ic_in, T, h)\n        A_in = calculate_amplitude(x_history_in, T_trans, h)\n        \n        # Run simulation for the \"outside\" trajectory\n        x_history_out = run_simulation(mu, ic_out, T, h)\n        A_out = calculate_amplitude(x_history_out, T_trans, h)\n        \n        # Calculate the boolean convergence indicator\n        C = abs(A_in - A_out)  epsilon\n        \n        all_results.extend([A_in, A_out, C])\n\n    # Final print statement in the exact required format.\n    # map(str, ...) converts floats and booleans to their string representations.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2395985"}]}