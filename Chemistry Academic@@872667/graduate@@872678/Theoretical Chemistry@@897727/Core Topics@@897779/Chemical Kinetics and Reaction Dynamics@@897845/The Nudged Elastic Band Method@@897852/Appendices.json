{"hands_on_practices": [{"introduction": "The first step in any Nudged Elastic Band calculation is creating an initial guess for the reaction path. While linear interpolation in Cartesian coordinates is the simplest approach, it can introduce unphysical geometric distortions, such as strained bond lengths. This exercise [@problem_id:2818647] challenges you to analytically quantify the error associated with linear interpolation for a molecular bending motion, developing a criterion for when more sophisticated internal coordinate interpolation is required.", "problem": "In the Nudged Elastic Band (NEB) method for identifying minimum energy paths in chemical reactions, the initial path between reactant and product configurations is often generated by linear interpolation in Cartesian coordinates. Consider a triatomic molecule with atoms labeled $A$–$B$–$C$, where the central atom $B$ is fixed at the origin, atom $A$ is fixed at $\\left(-r,\\,0,\\,0\\right)$, and atom $C$ moves in the $x$–$y$ plane at a fixed bond length $|BC|=r$ between the initial and final configurations. Without loss of generality, let the initial position of $C$ be $\\mathbf{R}_{C}^{(0)}=\\left(r,\\,0,\\,0\\right)$ and the final position be $\\mathbf{R}_{C}^{(1)}=\\left(r\\cos\\Delta\\theta,\\,r\\sin\\Delta\\theta,\\,0\\right)$, where $\\Delta\\theta$ is the change in the bending angle at $B$.\n\nA Cartesian linear interpolation for $C$ is defined for $t\\in[0,\\,1]$ by\n$$\n\\mathbf{R}_{C}(t)\\;=\\;(1-t)\\,\\mathbf{R}_{C}^{(0)}\\;+\\;t\\,\\mathbf{R}_{C}^{(1)}.\n$$\nThis interpolation traces the straight chord between the two endpoints on the circle of radius $r$ centered at $B$, and generally distorts the instantaneous bond distance $|BC(t)|=|\\mathbf{R}_{C}(t)|$. In contrast, an internal-coordinate interpolation that varies only the bending angle at fixed $|BC|=r$ would keep the $BC$ bond length constant along the path (following the arc).\n\nStarting from vector norms and basic trigonometric identities only, derive the maximum fractional deviation of the $BC$ bond length along the Cartesian linear interpolation as a function of $\\Delta\\theta$, and from this obtain a criterion for when internal coordinate interpolation is preferable if one imposes a hard tolerance $\\varepsilon$ on the allowed maximum fractional bond-length deviation during the interpolation.\n\nFinally, for a tolerance $\\varepsilon=0.02$ (expressed as a decimal fraction), compute the critical angular change $\\Delta\\theta_{c}$ such that for $\\Delta\\theta>\\Delta\\theta_{c}$ the internal coordinate interpolation is preferable under this criterion. Express $\\Delta\\theta_{c}$ in radians, and round your answer to four significant figures.", "solution": "The problem as stated is scientifically sound, well-posed, and contains all necessary information for a unique solution. We shall proceed with the derivation.\n\nThe initial and final positions of atom $C$ are given as $\\mathbf{R}_{C}^{(0)} = (r, 0, 0)$ and $\\mathbf{R}_{C}^{(1)} = (r\\cos\\Delta\\theta, r\\sin\\Delta\\theta, 0)$. Atom $B$ is located at the origin. The bond vector $\\mathbf{R}_{BC}$ is therefore identical to the position vector of atom $C$, $\\mathbf{R}_{C}$. The bond length at the endpoints is $|\\mathbf{R}_{C}^{(0)}| = r$ and $|\\mathbf{R}_{C}^{(1)}| = r$.\n\nThe position vector of atom $C$ along the linearly interpolated path is given by $\\mathbf{R}_{C}(t)$ for $t \\in [0, 1]$:\n$$\n\\mathbf{R}_{C}(t) = (1-t)\\mathbf{R}_{C}^{(0)} + t\\mathbf{R}_{C}^{(1)}\n$$\nSubstituting the coordinate vectors:\n$$\n\\mathbf{R}_{C}(t) = (1-t)(r, 0, 0) + t(r\\cos\\Delta\\theta, r\\sin\\Delta\\theta, 0)\n$$\n$$\n\\mathbf{R}_{C}(t) = ((1-t)r + tr\\cos\\Delta\\theta, tr\\sin\\Delta\\theta, 0)\n$$\n$$\n\\mathbf{R}_{C}(t) = (r(1-t+t\\cos\\Delta\\theta), tr\\sin\\Delta\\theta, 0)\n$$\nThe instantaneous bond length of $BC$ is the magnitude of this vector, which we denote as $|BC(t)|_L$, where the subscript $L$ indicates linear interpolation. We calculate its square:\n$$\n|BC(t)|_L^2 = |\\mathbf{R}_{C}(t)|^2 = [r(1-t+t\\cos\\Delta\\theta)]^2 + [tr\\sin\\Delta\\theta]^2\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t+t\\cos\\Delta\\theta)^2 + t^2\\sin^2\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t)^2 + 2t(1-t)\\cos\\Delta\\theta + t^2\\cos^2\\Delta\\theta + t^2\\sin^2\\Delta\\theta \\right)\n$$\nUsing the fundamental trigonometric identity $\\cos^2\\Delta\\theta + \\sin^2\\Delta\\theta = 1$:\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t)^2 + 2t(1-t)\\cos\\Delta\\theta + t^2 \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t + t^2 + 2t\\cos\\Delta\\theta - 2t^2\\cos\\Delta\\theta + t^2 \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t + 2t^2 + (2t - 2t^2)\\cos\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t(1-t) + 2t(1-t)\\cos\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t(1-t)(1-\\cos\\Delta\\theta) \\right)\n$$\nWe apply the half-angle identity $1-\\cos\\Delta\\theta = 2\\sin^2(\\frac{\\Delta\\theta}{2})$:\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right)\n$$\nThe instantaneous bond length is therefore:\n$$\n|BC(t)|_L = r \\sqrt{1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right)}\n$$\nThe fractional deviation of the bond length from its nominal value $r$ is:\n$$\nD(t) = \\frac{r - |BC(t)|_L}{r} = 1 - \\frac{|BC(t)|_L}{r} = 1 - \\sqrt{1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right)}\n$$\nTo find the maximum fractional deviation, $D_{max}$, we must find the maximum of $D(t)$ for $t \\in [0, 1]$. This is equivalent to finding the minimum of $|BC(t)|_L$, which in turn is equivalent to maximizing the positive term being subtracted under the square root, $4t(1-t)\\sin^2(\\frac{\\Delta\\theta}{2})$. As $\\Delta\\theta$ is constant for a given path, we only need to maximize the function $f(t) = t(1-t) = t - t^2$ on the interval $t \\in [0, 1]$.\nThe maximum of $f(t)$ is found by setting its derivative to zero:\n$$\n\\frac{df}{dt} = 1 - 2t = 0 \\implies t = \\frac{1}{2}\n$$\nThis point represents a maximum, as the second derivative $\\frac{d^2f}{dt^2} = -2 < 0$. The maximum value is $f(\\frac{1}{2}) = \\frac{1}{2}(1-\\frac{1}{2}) = \\frac{1}{4}$. This occurs at the midpoint of the chord.\n\nThe minimum bond length, $|BC|_{min}$, occurs at $t=\\frac{1}{2}$:\n$$\n|BC|_{min}^2 = r^2 \\left( 1 - 4\\left(\\frac{1}{4}\\right)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right) = r^2 \\left( 1 - \\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right) = r^2 \\cos^2\\left(\\frac{\\Delta\\theta}{2}\\right)\n$$\nAssuming $\\Delta\\theta \\in [0, \\pi]$, $\\cos(\\frac{\\Delta\\theta}{2}) \\ge 0$, so $|BC|_{min} = r\\cos(\\frac{\\Delta\\theta}{2})$.\n\nThe maximum fractional deviation, $D_{max}$, is then:\n$$\nD_{max} = 1 - \\frac{|BC|_{min}}{r} = 1 - \\frac{r\\cos(\\frac{\\Delta\\theta}{2})}{r} = 1 - \\cos\\left(\\frac{\\Delta\\theta}{2}\\right)\n$$\nThis is the required expression for the maximum fractional deviation as a function of $\\Delta\\theta$.\n\nThe criterion for preferring internal coordinate interpolation is that this maximum deviation exceeds a given tolerance $\\varepsilon$. Internal coordinate interpolation maintains the bond length perfectly, so its deviation is $0$. Thus, Cartesian interpolation is unacceptable when:\n$$\nD_{max} > \\varepsilon\n$$\n$$\n1 - \\cos\\left(\\frac{\\Delta\\theta}{2}\\right) > \\varepsilon\n$$\nThis is the criterion.\n\nFinally, we compute the critical angular change, $\\Delta\\theta_c$, for which the maximum deviation equals the tolerance $\\varepsilon=0.02$.\n$$\n1 - \\cos\\left(\\frac{\\Delta\\theta_c}{2}\\right) = \\varepsilon\n$$\n$$\n\\cos\\left(\\frac{\\Delta\\theta_c}{2}\\right) = 1 - \\varepsilon\n$$\n$$\n\\frac{\\Delta\\theta_c}{2} = \\arccos(1 - \\varepsilon)\n$$\n$$\n\\Delta\\theta_c = 2 \\arccos(1 - \\varepsilon)\n$$\nSubstituting the specified tolerance $\\varepsilon = 0.02$:\n$$\n\\Delta\\theta_c = 2 \\arccos(1 - 0.02) = 2 \\arccos(0.98)\n$$\nUsing a calculator in radians mode:\n$$\n\\arccos(0.98) \\approx 0.20033400 \\, \\text{rad}\n$$\n$$\n\\Delta\\theta_c \\approx 2 \\times 0.20033400 = 0.40066800 \\, \\text{rad}\n$$\nRounding to four significant figures, the critical angle is $0.4007$ radians. For any angular change $\\Delta\\theta > \\Delta\\theta_c$, the bond length distortion of the simple linear path exceeds the $2\\%$ tolerance, making an internal coordinate-based path preferable.", "answer": "$$\\boxed{0.4007}$$", "id": "2818647"}, {"introduction": "The ingenuity of the NEB method lies in its unique force decomposition, which allows a path to relax towards a Minimum Energy Path (MEP) without the images collapsing into the endpoints. The force on each image is a sum of a tangential spring force, which ensures even spacing, and a perpendicular potential force, which minimizes energy off the path. In this practice [@problem_id:2818674], you will implement this core NEB algorithm, deriving the projected forces from first principles and performing an optimization step to observe their effect.", "problem": "A discretized path connecting two local minima on a scalar potential energy surface is represented by a finite sequence of $M+1$ configuration vectors $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ in $\\mathbb{R}^d$, where $\\mathbf{R}_0$ and $\\mathbf{R}_M$ are fixed endpoints. Consider the Nudged Elastic Band (NEB) method used to approximate a minimum energy path. The NEB framework treats adjacent images as connected by harmonic springs and advances internal images under a combination of a spring force constrained to the local tangent direction and a potential force with its tangential component removed. All quantities in this problem are dimensionless. All angles, where applicable, are in radians.\n\nStarting from the following fundamental base:\n- The potential energy is a scalar field $V(\\mathbf{R})$ and the physical force due to the potential is $-\\nabla V(\\mathbf{R})$.\n- The spring interaction between neighboring images is harmonic with a constant spring coefficient $k>0$.\n- The local path tangent at an internal image is the direction of the discrete central difference of positions.\n- The NEB prescription combines only the spring force component parallel to the local tangent and only the potential force component perpendicular to that tangent.\n\nDerive, from these base statements, explicit expressions for:\n- The unit tangent $\\hat{\\boldsymbol{\\tau}}_i$ at each internal image $i\\in\\{1,\\dots,M-1\\}$ using only $\\mathbf{R}_{i-1},\\mathbf{R}_{i},\\mathbf{R}_{i+1}$.\n- The spring force acting on each internal image $i$ restricted to the tangent direction.\n- The potential force acting on each internal image $i$ restricted to the subspace perpendicular to the tangent.\n\nThen, design an algorithm that, given an initial path, performs one explicit steepest-descent step for the internal images:\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\alpha\\, \\mathbf{F}_i,\n$$\nwhere $\\alpha>0$ is a step size and $\\mathbf{F}_i$ is the NEB force composed according to the principles above. Endpoints $i=0$ and $i=M$ are not updated. Let the inter-image distances be $d_i=\\left\\|\\mathbf{R}_{i+1}-\\mathbf{R}_i\\right\\|$ for $i\\in\\{0,\\dots,M-1\\}$. For each step, quantify the evenness of spacing by the coefficient of variation $c_v = \\sigma_d/\\mu_d$, where $\\sigma_d$ and $\\mu_d$ are respectively the standard deviation and mean of $\\{d_i\\}_{i=0}^{M-1}$. Let $r$ be the ratio $r=c_v^{\\text{after}}/c_v^{\\text{before}}$. Additionally, compute $\\bar{s}$, the mean magnitude of the tangential spring force over internal images.\n\nImplement a program that, for each test case specified below, computes one NEB update step and returns the pair $[r,\\bar{s}]$ as floating-point numbers rounded to six decimal places.\n\nUse the following test suite (with all quantities dimensionless):\n\n- Test case A (happy path; uneven initial spacing on a symmetric double well):\n  - Potential $V_1(x,y) = (x^2-1)^2 + 0.1\\,y^2$.\n  - Gradient $\\nabla V_1(x,y)$ must be derived by you.\n  - Dimension $d=2$.\n  - Number of images $M+1=7$ with endpoints fixed at $\\mathbf{R}_0 = (-1,0)$ and $\\mathbf{R}_6=(1,0)$.\n  - Initial internal images: $\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.7,0)$, $\\mathbf{R}_3 = (-0.2,0)$, $\\mathbf{R}_4 = (0.3,0)$, $\\mathbf{R}_5 = (0.8,0)$.\n  - Spring constant $k=1.0$.\n  - Step size $\\alpha=0.05$.\n\n- Test case B (boundary condition; already equal spacing on the same potential):\n  - Potential $V_1(x,y)$ as above.\n  - Dimension $d=2$.\n  - Number of images $M+1=7$ with endpoints fixed at $\\mathbf{R}_0 = (-1,0)$ and $\\mathbf{R}_6=(1,0)$.\n  - Initial internal images equally spaced along the straight line segment: $\\mathbf{R}_i = (-1 + i\\cdot \\Delta,0)$ for $i\\in\\{1,\\dots,5\\}$, where $\\Delta = \\frac{2}{6}$.\n  - Spring constant $k=1.0$.\n  - Step size $\\alpha=0.05$.\n\n- Test case C (curved valley; uneven spacing and nontrivial perpendicular forces):\n  - Potential $V_2(x,y) = \\big(y-\\sin(\\pi x)\\big)^2 + 0.01\\,x^2$. Use angles in radians.\n  - Gradient $\\nabla V_2(x,y)$ must be derived by you.\n  - Dimension $d=2$.\n  - Number of images $M+1=7$ with endpoints fixed at $\\mathbf{R}_0 = (-1,0)$ and $\\mathbf{R}_6=(1,0)$.\n  - Initial internal images: $\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.6,0)$, $\\mathbf{R}_3 = (-0.1,0)$, $\\mathbf{R}_4 = (0.4,0)$, $\\mathbf{R}_5 = (0.9,0)$.\n  - Spring constant $k=1.0$.\n  - Step size $\\alpha=0.05$.\n\nYour program should compute, for each test case, the pair $[r,\\bar{s}]$ as defined above. If $c_v^{\\text{before}}=0$, define $r=1$ by convention. Your program should produce a single line of output containing the results as a comma-separated list of these pairs, enclosed in square brackets, for example:\n$[\\,[r_A,\\bar{s}_A],[r_B,\\bar{s}_B],[r_C,\\bar{s}_C]\\,]$,\nwith each floating-point number rounded to six decimal places. No other output should be produced.", "solution": "The problem statement is valid. It presents a well-posed, scientifically grounded problem in the field of computational chemistry, specifically concerning the Nudged Elastic Band (NEB) method. The given definitions and constraints are sufficient and consistent for deriving the necessary formulas and implementing the algorithm.\n\nThe task requires the derivation of the forces used in the NEB method based on first principles provided in the problem, followed by the design and implementation of an algorithm to perform a single optimization step. The problem is a standard exercise in understanding and applying the NEB method.\n\nThe derivation proceeds as follows. The system consists of a path discretized by $M+1$ images, represented by position vectors $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ in a $d$-dimensional space $\\mathbb{R}^d$. The endpoints $\\mathbf{R}_0$ and $\\mathbf{R}_M$ are fixed. The internal images $i \\in \\{1, \\dots, M-1\\}$ are to be updated.\n\nFirst, we derive the expression for the unit tangent vector at an internal image $i$. The problem states this is \"the direction of the discrete central difference of positions.\" This is the vector connecting the neighboring images, $\\mathbf{R}_{i-1}$ and $\\mathbf{R}_{i+1}$.\nThe tangent vector $\\boldsymbol{\\tau}_i$ is thus:\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\n$$\nThe corresponding unit tangent vector $\\hat{\\boldsymbol{\\tau}}_i$ is obtained by normalizing this vector:\n$$\n\\hat{\\boldsymbol{\\tau}}_i = \\frac{\\boldsymbol{\\tau}_i}{\\|\\boldsymbol{\\tau}_i\\|} = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n$$\nThis definition is valid provided that $\\mathbf{R}_{i+1} \\neq \\mathbf{R}_{i-1}$, which would make the norm zero. For the given test cases, this condition holds.\n\nSecond, we derive the spring force. The problem states that \"adjacent images as connected by harmonic springs with a constant spring coefficient $k>0$.\" The total elastic potential energy $S$ of the band is the sum of harmonic potentials for each segment:\n$$\nS(\\{\\mathbf{R}_i\\}) = \\sum_{j=0}^{M-1} \\frac{1}{2} k \\left\\| \\mathbf{R}_{j+1} - \\mathbf{R}_j \\right\\|^2\n$$\nThe force on a specific image $i$ is the negative gradient of this total potential with respect to its position $\\mathbf{R}_i$. Only two terms in the sum depend on $\\mathbf{R}_i$: the terms for $j=i-1$ and $j=i$.\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\nabla_{\\mathbf{R}_i} S = - \\frac{\\partial}{\\partial \\mathbf{R}_i} \\left[ \\frac{1}{2} k \\left\\| \\mathbf{R}_i - \\mathbf{R}_{i-1} \\right\\|^2 + \\frac{1}{2} k \\left\\| \\mathbf{R}_{i+1} - \\mathbf{R}_i \\right\\|^2 \\right]\n$$\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\left[ k (\\mathbf{R}_i - \\mathbf{R}_{i-1}) + k (\\mathbf{R}_i - \\mathbf{R}_{i+1}) \\right] = k(\\mathbf{R}_{i-1} - \\mathbf{R}_i) + k(\\mathbf{R}_{i+1} - \\mathbf{R}_i) = k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right)\n$$\nThe problem specifies that for the NEB force, we must use \"only the spring force component parallel to the local tangent\". This is the projection of $\\mathbf{F}_{i, \\text{spring}}^{\\text{total}}$ onto the unit tangent $\\hat{\\boldsymbol{\\tau}}_i$.\n$$\n\\mathbf{F}_{i, s}^{\\parallel} = \\left( \\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = \\left[ k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right] \\hat{\\boldsymbol{\\tau}}_i\n$$\nThis is the required expression for the tangential spring force.\n\nThird, we derive the component of the potential force perpendicular to the tangent. The force on image $i$ from the potential energy surface $V(\\mathbf{R})$ is $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$. The problem states that we use \"only the potential force component perpendicular to that tangent\". The component of $\\mathbf{F}_{i, \\text{pot}}$ perpendicular to $\\hat{\\boldsymbol{\\tau}}_i$ is found by subtracting its parallel component:\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = \\mathbf{F}_{i, \\text{pot}} - \\left( \\mathbf{F}_{i, \\text{pot}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\nSubstituting $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$:\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = -\\nabla V(\\mathbf{R}_i) - \\left( (-\\nabla V(\\mathbf{R}_i)) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = -\\nabla V(\\mathbf{R}_i) + \\left( \\nabla V(\\mathbf{R}_i) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\nThis force component drives the path towards the minimum energy path without causing the images to slide along the path.\n\nThe total NEB force $\\mathbf{F}_i$ on an internal image $i$ is the sum of these two components:\n$$\n\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}\n$$\n\nThe gradients for the specified potentials $V_1(x,y) = (x^2-1)^2 + 0.1 y^2$ and $V_2(x,y) = (y-\\sin(\\pi x))^2 + 0.01 x^2$ must be computed. For $\\mathbf{R}=(x,y)$:\n- For $V_1$: $\\nabla V_1(x,y) = \\left( \\frac{\\partial V_1}{\\partial x}, \\frac{\\partial V_1}{\\partial y} \\right) = (4x(x^2-1), 0.2y)$.\n- For $V_2$: $\\nabla V_2(x,y) = \\left( \\frac{\\partial V_2}{\\partial x}, \\frac{\\partial V_2}{\\partial y} \\right) = (0.02x - 2\\pi(y-\\sin(\\pi x))\\cos(\\pi x), 2(y-\\sin(\\pi x)))$.\n\nThe algorithm for a single update step is as follows:\n1.  Given an initial path $\\{\\mathbf{R}_i\\}_{i=0}^{M}$, parameter $k$, and step size $\\alpha$.\n2.  Calculate the set of initial inter-image distances $\\{d_i\\}_{i=0}^{M-1}$ where $d_i = \\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\|$. Compute their mean $\\mu_d^{\\text{before}}$ and standard deviation $\\sigma_d^{\\text{before}}$. Calculate $c_v^{\\text{before}} = \\sigma_d^{\\text{before}} / \\mu_d^{\\text{before}}$, handling the case $\\mu_d^{\\text{before}}=0$ by setting $c_v^{\\text{before}}=0$.\n3.  Initialize a new path array $\\{\\mathbf{R}'_i\\}$ and copy the fixed endpoints: $\\mathbf{R}'_0 = \\mathbf{R}_0$ and $\\mathbf{R}'_M = \\mathbf{R}_M$. Initialize a list to store spring force magnitudes.\n4.  For each internal image $i$ from $1$ to $M-1$:\n    a. Compute the unit tangent $\\hat{\\boldsymbol{\\tau}}_i$ using the original path positions $\\mathbf{R}_{i-1}$ and $\\mathbf{R}_{i+1}$.\n    b. Compute the tangential spring force $\\mathbf{F}_{i, s}^{\\parallel}$ and store its magnitude, $\\|\\mathbf{F}_{i, s}^{\\parallel}\\| = |\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i|$.\n    c. Compute the potential gradient $\\nabla V(\\mathbf{R}_i)$ and the perpendicular potential force $\\mathbf{F}_{i, \\text{pot}}^{\\perp}$.\n    d. Sum the forces to get the total NEB force $\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}$.\n    e. Calculate the updated position: $\\mathbf{R}'_i = \\mathbf{R}_i + \\alpha \\mathbf{F}_i$.\n5.  After updating all internal images, calculate the new set of distances $\\{d'_i\\}_{i=0}^{M-1}$ from the new path $\\{\\mathbf{R}'_i\\}$. Compute their mean $\\mu_d^{\\text{after}}$ and standard deviation $\\sigma_d^{\\text{after}}$, and find $c_v^{\\text{after}} = \\sigma_d^{\\text{after}} / \\mu_d^{\\text{after}}$.\n6.  Calculate the ratio $r = c_v^{\\text{after}} / c_v^{\\text{before}}$. If $c_v^{\\text{before}}=0$, set $r=1$ as per the problem specification.\n7.  Calculate the mean magnitude of the tangential spring force, $\\bar{s}$, by averaging the values stored in step 4b.\n8.  Return the pair $[r, \\bar{s}]$.\n\nThis procedure is implemented for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases for the NEB problem.\n    \"\"\"\n\n    def grad_V1(R):\n        \"\"\"Gradient of V1(x,y) = (x^2-1)^2 + 0.1*y^2\"\"\"\n        x, y = R\n        dx = 4 * x * (x**2 - 1)\n        dy = 0.2 * y\n        return np.array([dx, dy])\n\n    def grad_V2(R):\n        \"\"\"Gradient of V2(x,y) = (y-sin(pi*x))^2 + 0.01*x^2\"\"\"\n        x, y = R\n        sin_pix = np.sin(np.pi * x)\n        cos_pix = np.cos(np.pi * x)\n        term1 = y - sin_pix\n        dx = 0.02 * x - 2 * np.pi * term1 * cos_pix\n        dy = 2 * term1\n        return np.array([dx, dy])\n\n    def get_cv(path):\n        \"\"\"Calculate the coefficient of variation of inter-image distances.\"\"\"\n        distances = [np.linalg.norm(path[i+1] - path[i]) for i in range(len(path) - 1)]\n        mean_dist = np.mean(distances)\n        if mean_dist == 0:\n            return 0.0\n        std_dist = np.std(distances)\n        return std_dist / mean_dist\n\n    def process_case(initial_path_internal, R0, RM, grad_V, k, alpha):\n        \"\"\"\n        Processes one test case of the NEB calculation.\n        Performs one update step and computes the required metrics [r, s_bar].\n        \"\"\"\n        # Construct full initial path\n        path = [R0] + initial_path_internal + [RM]\n        path = [np.array(p) for p in path]\n        M = len(path) - 1\n        num_internal_images = M - 1\n\n        # --- Before the update step ---\n        cv_before = get_cv(path)\n\n        # --- Perform one NEB update step ---\n        new_path = [p.copy() for p in path]\n        tangential_spring_force_mags = []\n\n        for i in range(1, M):\n            # Current, previous, and next image positions\n            R_i = path[i]\n            R_prev = path[i-1]\n            R_next = path[i+1]\n\n            # 1. Calculate tangent\n            tau_vec = R_next - R_prev\n            norm_tau = np.linalg.norm(tau_vec)\n            if norm_tau == 0:\n                tau_hat = np.zeros_like(tau_vec)\n            else:\n                tau_hat = tau_vec / norm_tau\n\n            # 2. Calculate tangential spring force F_s_parallel\n            F_spring_total = k * (R_prev + R_next - 2 * R_i)\n            F_s_parallel_scalar = np.dot(F_spring_total, tau_hat)\n            F_s_parallel = F_s_parallel_scalar * tau_hat\n            tangential_spring_force_mags.append(np.abs(F_s_parallel_scalar))\n\n            # 3. Calculate perpendicular potential force F_pot_perp\n            grad_Vi = grad_V(R_i)\n            F_pot_total = -grad_Vi\n            F_pot_perp = F_pot_total - np.dot(F_pot_total, tau_hat) * tau_hat\n\n            # 4. Total NEB force and update position\n            F_i = F_s_parallel + F_pot_perp\n            new_path[i] = R_i + alpha * F_i\n        \n        # --- After the update step ---\n        cv_after = get_cv(new_path)\n\n        # --- Calculate final metrics ---\n        if cv_before == 0.0:\n            r = 1.0\n        else:\n            r = cv_after / cv_before\n\n        s_bar = np.mean(tangential_spring_force_mags) if tangential_spring_force_mags else 0.0\n\n        return [round(r, 6), round(s_bar, 6)]\n\n    # Test Case A\n    R0_A = [-1.0, 0.0]\n    RM_A = [1.0, 0.0]\n    path_internal_A = [\n        [-0.9, 0.0], [-0.7, 0.0], [-0.2, 0.0], [0.3, 0.0], [0.8, 0.0]\n    ]\n    k_A = 1.0\n    alpha_A = 0.05\n    \n    # Test Case B\n    R0_B = [-1.0, 0.0]\n    RM_B = [1.0, 0.0]\n    delta_B = 2.0 / 6.0\n    path_internal_B = [\n        [-1 + i * delta_B, 0.0] for i in range(1, 6)\n    ]\n    k_B = 1.0\n    alpha_B = 0.05\n    \n    # Test Case C\n    R0_C = [-1.0, 0.0]\n    RM_C = [1.0, 0.0]\n    path_internal_C = [\n        [-0.9, 0.0], [-0.6, 0.0], [-0.1, 0.0], [0.4, 0.0], [0.9, 0.0]\n    ]\n    k_C = 1.0\n    alpha_C = 0.05\n\n    test_cases = [\n        (path_internal_A, R0_A, RM_A, grad_V1, k_A, alpha_A),\n        (path_internal_B, R0_B, RM_B, grad_V1, k_B, alpha_B),\n        (path_internal_C, R0_C, RM_C, grad_V2, k_C, alpha_C)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = process_case(*params)\n        results.append(result)\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{r},{s}]\" for r, s in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2818674"}, {"introduction": "In an NEB calculation, the highest-energy image serves as an approximation of the transition state. However, the accuracy of this approximation can be compromised by the discrete nature of the path, where uneven image spacing can bias the estimated saddle point location and energy. This exercise [@problem_id:2818689] allows you to quantitatively analyze this discretization bias and implement a common refinement strategy—targeted image insertion—to systematically improve the accuracy of your saddle point estimate.", "problem": "Design and implement a program that quantitatively analyzes discretization bias in the Nudged Elastic Band (NEB) method, arising from uneven image spacing along a one-dimensional minimum-energy path. The analysis must start from a well-defined potential energy surface and proceed from first principles of calculus.\n\nConsider the one-dimensional potential energy function given by\n$$\nV(x) = \\frac{1}{4}\\left(x^2 - 1\\right)^2,\n$$\nwhich has minima at $x=-1$ and $x=1$ and a single transition-state (saddle) at the origin. The minimum-energy path connecting the minima is the line in configuration space parameterized by $x$ itself. The true barrier location and energy for this path are at $x^\\ddagger = 0$ with $V^\\ddagger = V(0)$.\n\nIn the NEB picture, a path is discretized into a sequence of images (points) $x_0, x_1, \\dots, x_{N-1}$ connecting the endpoints $x_0=-1$ and $x_{N-1}=1$. The highest-energy image $x_k$ is used as an estimator of the saddle location and barrier energy. When images are unevenly spaced, $x_k$ can be biased away from $x^\\ddagger$, yielding a biased barrier energy. Near the saddle, a smooth potential admits a Taylor expansion\n$$\nV(x) \\approx V^\\ddagger - \\frac{|\\kappa|}{2}\\,\\delta^2 + \\mathcal{O}(\\delta^4),\n$$\nwhere $\\delta = x - x^\\ddagger$ and $|\\kappa|$ is the magnitude of the negative curvature at the saddle. Thus, the absolute energy bias at the discrete maximum scales quadratically with the distance of the nearest image to the saddle. By inserting additional images near the current maximum, one can reduce $\\delta$ and thereby reduce the energy bias.\n\nYour tasks are:\n- Generate initial image sets of size $N$ (including endpoints) on the path using a monotone mapping $s \\mapsto x$ defined by\n$$\nx_i = -1 + 2\\, s_i^p,\\quad s_i = \\frac{i}{N-1},\\quad i\\in\\{0,1,\\dots,N-1\\},\n$$\nwith exponent $p \\geq 1$ controlling the degree of uneven spacing. The choice $p=1$ yields uniform spacing, and $p>1$ clusters images toward the left minimum. This parameterization is a purely mathematical device to emulate the effect of uneven tangential spring distributions in NEB without invoking spring forces explicitly.\n- For each image set, compute the index $k$ of the highest-energy image, the corresponding coordinate $x_k$, and its energy $V(x_k)$. Using $x^\\ddagger=0$ and $V^\\ddagger=V(0)$ as the exact saddle location and barrier energy, compute the absolute energy error\n$$\n\\Delta E_{\\text{before}} = \\left|V(x_k) - V^\\ddagger\\right|\n$$\nand the location error\n$$\n\\Delta x_{\\text{before}} = \\left|x_k - x^\\ddagger\\right|.\n$$\n- Emulate targeted NEB image insertion near the discrete maximum by inserting $m$ new images in the immediate neighborhood of $x_k$ as follows: divide each of the two adjacent intervals $\\left[x_{k-1},x_k\\right]$ and $\\left[x_k,x_{k+1}\\right]$ into equal subintervals and insert equally spaced interior points so that a total of $m$ new images are added, with $\\lceil m/2 \\rceil$ on the left interval and $m - \\lceil m/2 \\rceil$ on the right interval. Keep the endpoints at $x=-1$ and $x=1$ fixed. Recompute the highest-energy image after insertion to obtain $\\Delta E_{\\text{after}}$ and $\\Delta x_{\\text{after}}$ defined analogously.\n- Report the quantitative effect of insertion by outputting, for each test case, the quadruple of floats $[\\Delta E_{\\text{before}}, \\Delta E_{\\text{after}}, \\Delta x_{\\text{before}}, \\Delta x_{\\text{after}}]$, rounded to $10$ decimal places.\n\nTest suite:\n- Case A (uneven spacing, moderate resolution): $N=9$, $p=3$, $m=2$.\n- Case B (uniform spacing, high resolution): $N=33$, $p=1$, $m=2$.\n- Case C (highly uneven spacing, very coarse): $N=5$, $p=5$, $m=2$.\n- Case D (uniform spacing with an image exactly at the saddle): $N=11$, $p=1$, $m=2$.\n\nScientific realism requirements:\n- All computations are to be performed on the exact analytic $V(x)$ provided. Treat energy as dimensionless and positions as dimensionless.\n- Angles are not used in this problem.\n- The algorithmic insertion rule must respect adjacency: images may only be inserted within $\\left[x_{k-1},x_k\\right]$ and $\\left[x_k,x_{k+1}\\right]$.\n\nFinal output format:\n- Your program should produce a single line of output containing all test results as a comma-separated list enclosed in square brackets. Concatenate the four rounded numbers for Case A, then Case B, then Case C, then Case D, in that order. That is, the output is a flat list with $16$ floats: \n$[\\Delta E_{\\text{before}}^{(A)},\\Delta E_{\\text{after}}^{(A)},\\Delta x_{\\text{before}}^{(A)},\\Delta x_{\\text{after}}^{(A)},\\dots,\\Delta E_{\\text{before}}^{(D)},\\Delta E_{\\text{after}}^{(D)},\\Delta x_{\\text{before}}^{(D)},\\Delta x_{\\text{after}}^{(D)}]$.", "solution": "We proceed from first principles of calculus applied to the discretized minimum-energy path. The Nudged Elastic Band (NEB) method represents a continuous path in configuration space by a finite set of images $x_0,\\dots,x_{N-1}$, with $x_0$ and $x_{N-1}$ fixed at the reactant and product minima. The highest-energy image is used as a discrete proxy for the saddle point. When the images are unevenly distributed, the nearest image to the true saddle $x^\\ddagger$ may lie at a finite offset $\\delta = x_k - x^\\ddagger$, producing biased estimates of both the saddle location and barrier energy.\n\nFundamental base: For a smooth potential energy surface $V(x)$ with a nondegenerate saddle at $x^\\ddagger$, a Taylor expansion in the neighborhood of $x^\\ddagger$ yields\n$$\nV(x^\\ddagger + \\delta) = V^\\ddagger + \\frac{1}{2} V''(x^\\ddagger)\\,\\delta^2 + \\mathcal{O}(\\delta^3),\n$$\nwith $V'(x^\\ddagger)=0$ by stationarity and $V''(x^\\ddagger)<0$ by the definition of a first-order saddle. For the specific potential\n$$\nV(x) = \\frac{1}{4}(x^2-1)^2 = \\frac{1}{4} - \\frac{1}{2}x^2 + \\frac{1}{4}x^4,\n$$\nwe have $x^\\ddagger=0$ by symmetry, $V^\\ddagger = V(0) = \\frac{1}{4}$, and $V''(0) = -1$. Therefore,\n$$\nV(\\delta) = \\frac{1}{4} - \\frac{1}{2}\\delta^2 + \\frac{1}{4}\\delta^4,\n$$\nand the absolute energy bias at the discrete maximum located a distance $\\delta$ from the saddle is\n$$\n\\Delta E = \\left|V(\\delta) - V^\\ddagger\\right| = \\frac{1}{2}\\delta^2 - \\frac{1}{4}\\delta^4.\n$$\nFor sufficiently small $\\delta$, the leading behavior is quadratic,\n$$\n\\Delta E \\approx \\frac{1}{2}\\delta^2,\n$$\nwhich formalizes the intuition that discretization bias in the barrier energy decays with the square of the proximity of an image to the saddle.\n\nAlgorithmic design: To emulate uneven NEB spacing without introducing tangential spring forces explicitly, we parameterize initial images by $x_i = -1 + 2\\,(\\frac{i}{N-1})^p$. This concentrates images near the left minimum for $p>1$. We compute the index $k$ of the highest-energy image by maximizing $V(x_i)$. The corresponding absolute errors are\n$$\n\\Delta x_{\\text{before}} = |x_k - x^\\ddagger|, \\quad \\Delta E_{\\text{before}} = |V(x_k) - V^\\ddagger|.\n$$\nTo reduce the bias, we carry out targeted insertion of $m$ images in the immediate vicinity of $x_k$ by subdividing the adjacent intervals $[x_{k-1},x_k]$ and $[x_k,x_{k+1}]$. Specifically, we place $\\lceil m/2 \\rceil$ equally spaced interior points in $[x_{k-1},x_k]$ and $m - \\lceil m/2 \\rceil$ in $[x_k,x_{k+1}]$. This halves or better the local mesh size near the discrete maximum and reduces $\\Delta x$ accordingly. Because $\\Delta E$ is asymptotically quadratic in $\\Delta x$, one expects an approximate reduction factor near $4$ in the energy bias under ideal symmetric refinement near the saddle.\n\nWe apply this to the test suite:\n- Case A: $N=9$, $p=3$, $m=2$. The initial images cluster near $x=-1$, leaving a large gap spanning the saddle. The discrete maximum lies at some $x_k<0$ with $\\Delta x_{\\text{before}}>0$. Inserting $m=2$ images places one on each neighboring interval, moving the nearest image closer to $x^\\ddagger=0$ and reducing both $\\Delta x$ and $\\Delta E$ markedly, consistent with the quadratic scaling.\n- Case B: $N=33$, $p=1$, $m=2$. Uniform spacing with odd $N$ places an image exactly at $x=0$, so $\\Delta x_{\\text{before}}=0$ and $\\Delta E_{\\text{before}}=0$. Insertion leaves the maximum at $x^\\ddagger$, so the errors remain zero.\n- Case C: $N=5$, $p=5$, $m=2$. Extremely uneven coarse spacing leaves the nearest image at a large $|\\delta|$, producing a large $\\Delta E_{\\text{before}}$. Inserting two images substantially reduces $\\Delta x$ and therefore $\\Delta E$ by more than a factor of order $4$, though the exact factor depends on the asymmetry of the adjacent intervals.\n- Case D: $N=11$, $p=1$, $m=2$. As in Case B, an image lies exactly at $x^\\ddagger$, giving zero errors before and after.\n\nImplementation details:\n- Compute $V^\\ddagger = V(0)$ and $x^\\ddagger=0$ directly from the analytic $V(x)$ and its symmetry.\n- Identify the highest-energy image by direct evaluation of $V(x_i)$.\n- Perform insertion by placing equally spaced interior points on each adjacent interval, preserving endpoints $x=-1$ and $x=1$.\n- Recompute the maximum and errors after insertion.\n- Output, for each test case in order A, B, C, D, the quadruple $[\\Delta E_{\\text{before}}, \\Delta E_{\\text{after}}, \\Delta x_{\\text{before}}, \\Delta x_{\\text{after}}]$, rounded to $10$ decimal places, concatenated into a flat list.\n\nThis design directly connects the mathematical expansion of $V(x)$ near the saddle with a concrete algorithmic remedy (local insertion) and demonstrates, through the provided test cases, how reducing the local discretization length near the maximum corrects the bias in both location and barrier energy estimates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef potential(x):\n    # V(x) = 1/4 (x^2 - 1)^2\n    return 0.25 * (x**2 - 1.0)**2\n\ndef generate_images(N, p):\n    # Generate N images including endpoints using x = -1 + 2*(s^p), s in [0,1]\n    s = np.linspace(0.0, 1.0, N, dtype=float)\n    x = -1.0 + 2.0 * (s ** p)\n    # Ensure sorted uniqueness (should already be sorted)\n    x = np.array(sorted(set(np.round(x, 16))))  # guard against fp duplicates\n    return x\n\ndef analyze_images(x, x_saddle=0.0):\n    E = potential(x)\n    k = int(np.argmax(E))\n    x_max = float(x[k])\n    E_max = float(E[k])\n    E_saddle = float(potential(x_saddle))\n    dE = abs(E_max - E_saddle)\n    dx = abs(x_max - x_saddle)\n    return dE, dx, k\n\ndef insert_near_max(x, k, m):\n    # Insert m new images near index k: distribute ceil(m/2) on left interval [x[k-1], x[k]]\n    # and the rest on right interval [x[k], x[k+1]]. Endpoints remain fixed.\n    if m <= 0:\n        return np.array(x, dtype=float)\n    n = len(x)\n    # Safety: k should not be at endpoints for this potential; if it is, return unchanged\n    if k <= 0 or k >= n - 1:\n        return np.array(x, dtype=float)\n    left_count = int(np.ceil(m / 2.0))\n    right_count = int(m - left_count)\n    new_points = []\n\n    # Left interval subdivision: generate equally spaced interior points\n    xL, xK = x[k - 1], x[k]\n    if left_count > 0:\n        for j in range(1, left_count + 1):\n            frac = j / (left_count + 1)\n            new_points.append(xL + frac * (xK - xL))\n\n    # Right interval subdivision\n    xK, xR = x[k], x[k + 1]\n    if right_count > 0:\n        for j in range(1, right_count + 1):\n            frac = j / (right_count + 1)\n            new_points.append(xK + frac * (xR - xK))\n\n    x_aug = np.concatenate([x, np.array(new_points, dtype=float)])\n    x_aug.sort()\n    # Deduplicate with tolerance\n    x_unique = []\n    for xi in x_aug:\n        if len(x_unique) == 0 or abs(xi - x_unique[-1]) > 1e-15:\n            x_unique.append(float(xi))\n    return np.array(x_unique, dtype=float)\n\ndef run_case(N, p, m):\n    x0 = generate_images(N, p)\n    dE_before, dx_before, k = analyze_images(x0, 0.0)\n    x1 = insert_near_max(x0, k, m)\n    dE_after, dx_after, _ = analyze_images(x1, 0.0)\n    return dE_before, dE_after, dx_before, dx_after\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, p, m)\n    test_cases = [\n        (9, 3.0, 2),   # Case A\n        (33, 1.0, 2),  # Case B\n        (5, 5.0, 2),   # Case C\n        (11, 1.0, 2),  # Case D\n    ]\n\n    results = []\n    for N, p, m in test_cases:\n        dE_before, dE_after, dx_before, dx_after = run_case(N, p, m)\n        # Round to 10 decimal places as specified\n        results.extend([\n            round(dE_before, 10),\n            round(dE_after, 10),\n            round(dx_before, 10),\n            round(dx_after, 10),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2818689"}]}