{"hands_on_practices": [{"introduction": "The electrostatic interaction is often the most significant and longest-ranged component of the forces between polar molecules. While we frequently use the final textbook formulas for these interactions, a deeper understanding comes from deriving them from first principles. This practice [@problem_id:2942380] challenges you to build the expression for the interaction energy between two point dipoles directly from the laws of classical electrostatics, reinforcing the fundamental connection between field theory and molecular chemistry.", "problem": "Two rigid linear rotors, molecule A and molecule B, possess permanent electric dipole moments $\\boldsymbol{\\mu}_1$ and $\\boldsymbol{\\mu}_2$ of magnitudes $\\mu_1$ and $\\mu_2$, respectively. Their centers are fixed and separated by a distance $R$ in vacuum. Treat each molecule as a point dipole located at its center (point-dipole approximation), neglecting induction and dispersion. Using only classical electrostatics, start from the definition of the electrostatic potential of a point dipole and the definition of interaction energy between a dipole and an external electric field, and derive the general expression for the interaction energy between two permanent dipoles at fixed separation and arbitrary orientations.\n\nThen evaluate the interaction energy for the following two static arrangements:\n\n1. Collinear and parallel: both dipoles are aligned along the intermolecular axis (the line of centers) and point in the same direction.\n2. Orthogonal: the dipole $\\boldsymbol{\\mu}_1$ of molecule A is aligned along the intermolecular axis, while the dipole $\\boldsymbol{\\mu}_2$ of molecule B is perpendicular to the intermolecular axis and perpendicular to $\\boldsymbol{\\mu}_1$.\n\nFinally, report the difference $\\Delta U = U_{\\text{parallel}} - U_{\\text{orthogonal}}$ as a single closed-form analytic expression in terms of $\\mu_1$, $\\mu_2$, $R$, and the vacuum permittivity $\\varepsilon_0$. Express the final energy difference in Joules. Do not approximate or round.", "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It requires the derivation of a standard result in classical electrostatics. We will proceed with the solution.\n\nThe problem requires a derivation of the interaction energy between two point dipoles, $\\boldsymbol{\\mu}_1$ and $\\boldsymbol{\\mu}_2$, separated by a fixed distance $R$. Let the position vector from the center of dipole $\\boldsymbol{\\mu}_1$ to the center of dipole $\\boldsymbol{\\mu}_2$ be $\\mathbf{R}$, such that $|\\mathbf{R}| = R$. We begin by placing dipole $\\boldsymbol{\\mu}_1$ at the origin of a coordinate system.\n\nAccording to classical electrostatics, the electrostatic potential $\\phi_1(\\mathbf{r})$ generated by a point dipole $\\boldsymbol{\\mu}_1$ at a position $\\mathbf{r}$ is given by:\n$$ \\phi_1(\\mathbf{r}) = \\frac{1}{4\\pi\\varepsilon_0} \\frac{\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r}}{r^3} $$\nwhere $r = |\\mathbf{r}|$ is the magnitude of the position vector and $\\varepsilon_0$ is the vacuum permittivity.\n\nThe electric field $\\mathbf{E}_1(\\mathbf{r})$ is the negative gradient of the electrostatic potential, $\\mathbf{E}_1 = -\\nabla \\phi_1$. We compute the gradient using the product rule for vector calculus, $\\nabla(fg) = f\\nabla g + g\\nabla f$:\n$$ \\mathbf{E}_1(\\mathbf{r}) = -\\nabla \\left( \\frac{1}{4\\pi\\varepsilon_0} \\frac{\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r}}{r^3} \\right) = -\\frac{1}{4\\pi\\varepsilon_0} \\left[ (\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r}) \\nabla\\left(\\frac{1}{r^3}\\right) + \\frac{1}{r^3} \\nabla(\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r}) \\right] $$\nThe necessary gradient terms are $\\nabla(r^{-n}) = -nr^{-n-1}\\nabla(r) = -nr^{-n-2}\\mathbf{r}$, which for $n=3$ gives $\\nabla(r^{-3}) = -3r^{-5}\\mathbf{r}$, and $\\nabla(\\mathbf{A} \\cdot \\mathbf{r}) = \\mathbf{A}$ for a constant vector $\\mathbf{A}$, so $\\nabla(\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r}) = \\boldsymbol{\\mu}_1$. Substituting these results into the expression for the field:\n$$ \\mathbf{E}_1(\\mathbf{r}) = -\\frac{1}{4\\pi\\varepsilon_0} \\left[ (\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r}) \\left( -\\frac{3\\mathbf{r}}{r^5} \\right) + \\frac{\\boldsymbol{\\mu}_1}{r^3} \\right] = \\frac{1}{4\\pi\\varepsilon_0} \\left[ \\frac{3(\\boldsymbol{\\mu}_1 \\cdot \\mathbf{r})\\mathbf{r}}{r^5} - \\frac{\\boldsymbol{\\mu}_1}{r^3} \\right] $$\nThe interaction energy $U$ of a second dipole $\\boldsymbol{\\mu}_2$ located in the field $\\mathbf{E}_1$ is given by $U = -\\boldsymbol{\\mu}_2 \\cdot \\mathbf{E}_1$. To find the interaction energy between our two dipoles, we evaluate the field $\\mathbf{E}_1$ at the position of the second dipole, $\\mathbf{r} = \\mathbf{R}$:\n$$ U = -\\boldsymbol{\\mu}_2 \\cdot \\mathbf{E}_1(\\mathbf{R}) = -\\boldsymbol{\\mu}_2 \\cdot \\left( \\frac{1}{4\\pi\\varepsilon_0} \\left[ \\frac{3(\\boldsymbol{\\mu}_1 \\cdot \\mathbf{R})\\mathbf{R}}{R^5} - \\frac{\\boldsymbol{\\mu}_1}{R^3} \\right] \\right) $$\nDistributing the dot product, we obtain:\n$$ U = -\\frac{1}{4\\pi\\varepsilon_0} \\left[ \\frac{3(\\boldsymbol{\\mu}_1 \\cdot \\mathbf{R})(\\boldsymbol{\\mu}_2 \\cdot \\mathbf{R})}{R^5} - \\frac{\\boldsymbol{\\mu}_1 \\cdot \\boldsymbol{\\mu}_2}{R^3} \\right] $$\nThis can be rewritten by factoring out $R^{-3}$ and introducing the unit vector $\\hat{\\mathbf{R}} = \\mathbf{R}/R$ along the line of centers:\n$$ U = \\frac{1}{4\\pi\\varepsilon_0 R^3} \\left[ (\\boldsymbol{\\mu}_1 \\cdot \\boldsymbol{\\mu}_2) - 3(\\boldsymbol{\\mu}_1 \\cdot \\hat{\\mathbf{R}})(\\boldsymbol{\\mu}_2 \\cdot \\hat{\\mathbf{R}}) \\right] $$\nThis is the general expression for the interaction energy between two fixed point dipoles.\n\nNow, we evaluate the energy for the $2$ specified static arrangements. We set up a coordinate system where the intermolecular axis is aligned with the z-axis, so $\\hat{\\mathbf{R}} = \\hat{\\mathbf{z}}$.\n\nCase $1$: Collinear and parallel arrangement.\nIn this configuration, both dipoles are aligned with the intermolecular axis and point in the same direction. Thus, $\\boldsymbol{\\mu}_1 = \\mu_1 \\hat{\\mathbf{z}}$ and $\\boldsymbol{\\mu}_2 = \\mu_2 \\hat{\\mathbf{z}}$. The required scalar products are:\n$\\boldsymbol{\\mu}_1 \\cdot \\boldsymbol{\\mu}_2 = (\\mu_1 \\hat{\\mathbf{z}}) \\cdot (\\mu_2 \\hat{\\mathbf{z}}) = \\mu_1 \\mu_2$\n$\\boldsymbol{\\mu}_1 \\cdot \\hat{\\mathbf{R}} = (\\mu_1 \\hat{\\mathbf{z}}) \\cdot \\hat{\\mathbf{z}} = \\mu_1$\n$\\boldsymbol{\\mu}_2 \\cdot \\hat{\\mathbf{R}} = (\\mu_2 \\hat{\\mathbf{z}}) \\cdot \\hat{\\mathbf{z}} = \\mu_2$\nSubstituting these into the general energy formula gives the energy for the parallel case, $U_{\\text{parallel}}$:\n$$ U_{\\text{parallel}} = \\frac{1}{4\\pi\\varepsilon_0 R^3} \\left[ \\mu_1 \\mu_2 - 3(\\mu_1)(\\mu_2) \\right] = \\frac{-2\\mu_1 \\mu_2}{4\\pi\\varepsilon_0 R^3} = -\\frac{\\mu_1 \\mu_2}{2\\pi\\varepsilon_0 R^3} $$\n\nCase $2$: Orthogonal arrangement.\nIn this configuration, $\\boldsymbol{\\mu}_1$ is aligned with the intermolecular axis, so $\\boldsymbol{\\mu}_1 = \\mu_1 \\hat{\\mathbf{z}}$. The dipole $\\boldsymbol{\\mu}_2$ is perpendicular to the intermolecular axis. Without loss of generality, we can align it with the x-axis, so $\\boldsymbol{\\mu}_2 = \\mu_2 \\hat{\\mathbf{x}}$. The scalar products are:\n$\\boldsymbol{\\mu}_1 \\cdot \\boldsymbol{\\mu}_2 = (\\mu_1 \\hat{\\mathbf{z}}) \\cdot (\\mu_2 \\hat{\\mathbf{x}}) = 0$\n$\\boldsymbol{\\mu}_1 \\cdot \\hat{\\mathbf{R}} = (\\mu_1 \\hat{\\mathbf{z}}) \\cdot \\hat{\\mathbf{z}} = \\mu_1$\n$\\boldsymbol{\\mu}_2 \\cdot \\hat{\\mathbf{R}} = (\\mu_2 \\hat{\\mathbf{x}}) \\cdot \\hat{\\mathbf{z}} = 0$\nThe energy for the orthogonal case, $U_{\\text{orthogonal}}$, is therefore:\n$$ U_{\\text{orthogonal}} = \\frac{1}{4\\pi\\varepsilon_0 R^3} \\left[ 0 - 3(\\mu_1)(0) \\right] = 0 $$\n\nFinally, we compute the difference $\\Delta U = U_{\\text{parallel}} - U_{\\text{orthogonal}}$:\n$$ \\Delta U = \\left( -\\frac{\\mu_1 \\mu_2}{2\\pi\\varepsilon_0 R^3} \\right) - 0 = -\\frac{\\mu_1 \\mu_2}{2\\pi\\varepsilon_0 R^3} $$\nThis expression represents the energy difference in Joules if the dipole moments $\\mu_1$ and $\\mu_2$ are in Coulomb-meters, the separation $R$ is in meters, and $\\varepsilon_0$ is the vacuum permittivity in Farads per meter.", "answer": "$$\n\\boxed{-\\frac{\\mu_1 \\mu_2}{2\\pi\\varepsilon_0 R^3}}\n$$", "id": "2942380"}, {"introduction": "How do the forces between individual molecules give rise to the observable properties of a bulk material? This exercise [@problem_id:2942370] provides a direct, computational bridge between the microscopic and macroscopic worlds through the lens of statistical mechanics. By numerically evaluating the second virial coefficient, $B_2(T)$, for a fluid governed by the Lennard-Jones potential, you will see how a simple model of atomic repulsion and dispersion can predict a key feature of real gas behavior: the Boyle temperature.", "problem": "A monatomic gas with pairwise additive interactions may be described in the low-density regime by the virial expansion of the equation of state, where the second virial coefficient $B_2(T)$ characterizes the leading correction to ideal-gas behavior. For spherically symmetric interactions, a fundamental and well-tested starting point is the Mayer $f$-function representation of the second virial coefficient,\n$$\nB_2(T) \\;=\\; -2\\pi \\int_{0}^{\\infty} \\left[ \\exp\\!\\left( -\\beta\\,U(r) \\right) - 1 \\right] r^2 \\, dr \\,,\n$$\nwhere $\\beta = 1/(k_{\\mathrm{B}} T)$, $k_{\\mathrm{B}}$ is the Boltzmann constant, $T$ is the absolute temperature, and $U(r)$ is the pair potential as a function of separation $r$. Consider a Lennard–Jones (LJ) fluid, defined by the potential\n$$\nU(r) \\;=\\; 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} \\;-\\; \\left( \\frac{\\sigma}{r} \\right)^6 \\right],\n$$\nwith energy scale $\\epsilon$ and length scale $\\sigma$. The Boyle temperature $T_{\\mathrm{B}}$ is defined by the condition $B_2(T_{\\mathrm{B}})=0$.\n\nYour task is to write a complete, runnable program that, starting only from the definitions above, does all of the following in a numerically robust way:\n\n- Computes $B_2(T)$ via numerical quadrature of the defining integral for arbitrary $(\\epsilon,\\sigma,T)$.\n- Performs a mathematically justified non-dimensionalization to reduce the integral to a single-parameter function of the reduced temperature $T^\\star = k_{\\mathrm{B}}T/\\epsilon$, and uses this reduction to locate $T^\\star_{\\mathrm{B}}$ such that $B_2(T^\\star_{\\mathrm{B}})=0$.\n- Converts $T^\\star_{\\mathrm{B}}$ to the Boyle temperature in Kelvin, using a convention in which $\\epsilon/k_{\\mathrm{B}}$ is specified in Kelvin. That is, if $\\epsilon/k_{\\mathrm{B}}$ is given as a value in Kelvin, then $T_{\\mathrm{B}} = T^\\star_{\\mathrm{B}} \\, (\\epsilon/k_{\\mathrm{B}})$ in Kelvin.\n- Uses a numerically stable root-finding method with explicit bracketing and tolerance control to find $T^\\star_{\\mathrm{B}}$, and a numerical quadrature method with explicit absolute and relative error tolerances to evaluate the integral.\n\nScientific and algorithmic requirements:\n\n- Derive a dimensionless integral representation of $B_2(T)$ by the change of variables $r = \\sigma \\rho$, and identify how $\\sigma$ and $\\epsilon$ enter the result, starting from the definitions. Do not use any pre-tabulated reduced virial coefficient data.\n- Implement the numerical quadrature over the semi-infinite interval $\\rho \\in [0,\\infty)$ in a way that is accurate and convergent. Control the absolute error to be at most $\\leq 10^{-8}$ and the relative error to be at most $\\leq 10^{-8}$ for each integral evaluation.\n- Implement a robust sign-bracketing strategy for the root $T^\\star_{\\mathrm{B}}$ over a search domain $T^\\star \\in [10^{-2}, 10^{2}]$, followed by a bracketing root-finder to within a tolerance of $\\leq 10^{-6}$ in $T^\\star$.\n- The function $B_2(T)$ should be computed from the fundamental integral definition above; you may use either $B_2(T) = -2\\pi \\int [\\exp(-\\beta U)-1] r^2 dr$ or the equivalent $B_2(T) = 2\\pi \\int [1-\\exp(-\\beta U)] r^2 dr$ identity, but you must be consistent.\n\nPhysical units and output specification:\n\n- Treat $\\epsilon/k_{\\mathrm{B}}$ as given in Kelvin and $\\sigma$ as given in meters. You must report the Boyle temperature $T_{\\mathrm{B}}$ in Kelvin, rounded to exactly three decimal places.\n- No other unit-converted quantities are required in the output. Any intermediate use of $B_2$ for numerical work may be performed in reduced, dimensionless form. If you compute any dimensional $B_2$, its natural unit is $\\sigma^3$; however, you are not required to output $B_2$.\n- Angles are not involved; no angle unit is required.\n\nTest suite and coverage:\n\nImplement your program to process the following parameter sets, each specified as $(\\epsilon/k_{\\mathrm{B}} \\text{ in Kelvin}, \\sigma \\text{ in meters})$:\n\n- Case $1$: $(120.0,\\; 3.40\\times 10^{-10})$\n- Case $2$: $(200.0,\\; 3.40\\times 10^{-10})$\n- Case $3$: $(120.0,\\; 4.00\\times 10^{-10})$\n- Case $4$: $(60.0,\\; 3.00\\times 10^{-10})$\n- Case $5$: $(500.0,\\; 3.40\\times 10^{-10})$\n\nFor each case, compute the Boyle temperature $T_{\\mathrm{B}}$ in Kelvin. Your program should produce a single line of output containing the five results as a comma-separated list enclosed in square brackets, in the order above, with each value rounded to exactly three decimal places, for example, $[\\dots]$.\n\nDesign for reasoning:\n\n- Your implementation must directly reflect the first-principles definitions stated above. The numerical algorithm should explicitly encode the non-dimensionalization from the definitions, the numerical quadrature over $\\rho \\in [0,\\infty)$, and the bracketing root-finding for $T^\\star_{\\mathrm{B}}$.\n- Your code should be self-contained and require no input at runtime. All constants and parameters must be defined within the program.", "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in the principles of statistical mechanics, well-posed, objective, and contains all necessary information for a unique solution. The task is to compute the Boyle temperature $T_{\\mathrm{B}}$ for a Lennard-Jones fluid, which is a standard and solvable problem in physical chemistry.\n\nThe solution proceeds in two main stages: first, a theoretical derivation to simplify the problem, and second, a numerical implementation to compute the required values.\n\n**1. Non-dimensionalization of the Second Virial Coefficient**\n\nThe analysis begins with the provided definitions for the second virial coefficient $B_2(T)$ and the Lennard-Jones (LJ) potential $U(r)$.\n\nThe second virial coefficient is given by:\n$$\nB_2(T) = -2\\pi \\int_{0}^{\\infty} \\left[ \\exp\\left( -\\beta U(r) \\right) - 1 \\right] r^2 \\, dr\n$$\nwhere $\\beta = 1/(k_{\\mathrm{B}} T)$. The LJ potential is:\n$$\nU(r) = 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]\n$$\nThe argument of the exponential function, $-\\beta U(r)$, can be rewritten using the reduced temperature $T^\\star = k_{\\mathrm{B}}T/\\epsilon$:\n$$\n-\\beta U(r) = -\\frac{U(r)}{k_{\\mathrm{B}}T} = -\\frac{4\\epsilon}{k_{\\mathrm{B}}T} \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right] = -\\frac{4}{T^\\star} \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]\n$$\nTo create a dimensionless integral, we introduce the reduced distance $\\rho = r/\\sigma$, which implies $r = \\sigma\\rho$ and $dr = \\sigma d\\rho$. The integration limits for $\\rho$ are unchanged from $0$ to $\\infty$. Substituting these into the expression for $B_2(T)$:\n$$\nB_2(T) = -2\\pi \\int_{0}^{\\infty} \\left[ \\exp\\left( -\\frac{4}{T^\\star} \\left[ \\left( \\frac{\\sigma}{\\sigma\\rho} \\right)^{12} - \\left( \\frac{\\sigma}{\\sigma\\rho} \\right)^6 \\right] \\right) - 1 \\right] (\\sigma\\rho)^2 (\\sigma d\\rho)\n$$\nSimplifying the terms inside the integral:\n$$\nB_2(T) = -2\\pi \\int_{0}^{\\infty} \\left[ \\exp\\left( -\\frac{4}{T^\\star} \\left( \\rho^{-12} - \\rho^{-6} \\right) \\right) - 1 \\right] \\sigma^2 \\rho^2 \\sigma d\\rho\n$$\nThe dimensional constant $\\sigma^3$ can be factored out of the integral:\n$$\nB_2(T) = -2\\pi \\sigma^3 \\int_{0}^{\\infty} \\left[ \\exp\\left( -\\frac{4}{T^\\star} \\left( \\rho^{-12} - \\rho^{-6} \\right) \\right) - 1 \\right] \\rho^2 d\\rho\n$$\nThis equation reveals that $B_2(T)$ is proportional to $\\sigma^3$ and a dimensionless integral that depends only on the reduced temperature $T^\\star$. Let us define the reduced second virial coefficient as $B_2^\\star(T^\\star) = B_2(T)/\\sigma^3$.\n\nThe Boyle temperature $T_{\\mathrm{B}}$ is defined by the condition $B_2(T_{\\mathrm{B}}) = 0$. In terms of our reduced quantities, this becomes:\n$$\n-2\\pi \\sigma^3 \\int_{0}^{\\infty} \\left[ \\exp\\left( -\\frac{4}{T^\\star_{\\mathrm{B}}} \\left( \\rho^{-12} - \\rho^{-6} \\right) \\right) - 1 \\right] \\rho^2 d\\rho = 0\n$$\nwhere $T^\\star_{\\mathrm{B}} = k_{\\mathrm{B}}T_{\\mathrm{B}}/\\epsilon$. Since $\\sigma \\neq 0$ and $-2\\pi \\neq 0$, the condition simplifies to finding the root of the integral itself:\n$$\nI(T^\\star) = \\int_{0}^{\\infty} \\left[ \\exp\\left( -\\frac{4}{T^\\star} \\left( \\rho^{-12} - \\rho^{-6} \\right) \\right) - 1 \\right] \\rho^2 d\\rho = 0\n$$\nThe value of $T^\\star_{\\mathrm{B}}$ that satisfies this equation is a universal constant for any substance described by the LJ potential. The parameters $\\epsilon$ and $\\sigma$ for a specific substance only scale the result to the physical temperature $T_{\\mathrm{B}}$ via the relation $T_{\\mathrm{B}} = (\\epsilon/k_{\\mathrm{B}}) T^\\star_{\\mathrm{B}}$. Note that the value of $\\sigma$ is entirely irrelevant for determining $T_{\\mathrm{B}}$.\n\n**2. Numerical Strategy**\n\nThe core of the numerical task is to find the root of the function $I(T^\\star)$.\n\n**Numerical Quadrature:** The integral $I(T^\\star)$ over the semi-infinite interval $[0, \\infty)$ is evaluated using numerical quadrature. The `scipy.integrate.quad` function is well-suited for this purpose, as it is an adaptive routine that can handle infinite limits and user-specified error tolerances. As per the requirements, the absolute and relative error tolerances for the integration will be set to $10^{-8}$.\n\n**Root Finding:** The problem requires a bracketing root-finder. The `scipy.optimize.brentq` algorithm will be used, which requires an interval $[a, b]$ where $I(a)$ and $I(b)$ have opposite signs. The physical behavior of $B_2(T)$ guides the selection of this bracket.\n- At low temperatures (small $T^\\star$), the attractive part of the potential ($U  0$) dominates intermolecular interactions. This makes $\\exp(-\\beta U) \\gg 1$, causing the integrand to be positive for $\\rho  1$. The overall integral $I(T^\\star)$ is positive, and thus $B_2(T)$ is negative.\n- At high temperatures (large $T^\\star$), the repulsive core of the potential ($U  0$) dominates, as particles have enough kinetic energy to probe short distances. This leads to an effective excluded volume, similar to hard spheres, resulting in a positive $B_2(T)$. For $B_2(T)$ to be positive, the integral $I(T^\\star)$ must be negative.\n\nTherefore, the function $I(T^\\star)$ transitions from positive to negative as $T^\\star$ increases, guaranteeing that a root $T^\\star_{\\mathrm{B}}$ exists. A search within the specified range $[10^{-2}, 10^{2}]$ confirms that an interval such as $[1, 5]$ provides a valid bracket ($I(1)  0$ and $I(5)  0$). The `brentq` algorithm is then used to find $T^\\star_{\\mathrm{B}}$ to a tolerance of $10^{-6}$.\n\n**Final Calculation:** Once the universal constant $T^\\star_{\\mathrm{B}}$ is computed numerically, the Boyle temperature $T_{\\mathrm{B}}$ for each test case is calculated using its specific value of $\\epsilon/k_{\\mathrm{B}}$:\n$$\nT_{\\mathrm{B}} = T^\\star_{\\mathrm{B}} \\times \\left( \\frac{\\epsilon}{k_{\\mathrm{B}}} \\right)\n$$\nThe final results are rounded to three decimal places as specified.\n\nThe provided Python code implements this strategy from first principles. It defines a function for the dimensionless integral $I(T^\\star)$, finds its root numerically to obtain $T^\\star_{\\mathrm{B}}$, and then computes and formats the $T_{\\mathrm{B}}$ values for the given test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Computes the Boyle temperature for a Lennard-Jones fluid for several parameter sets.\n\n    The solution is based on the first-principles definition of the second virial coefficient B2(T).\n    1. The integral for B2(T) is non-dimensionalized, showing that the Boyle condition B2(T_B) = 0\n       is equivalent to finding a universal reduced Boyle temperature T_star_B where a dimensionless\n       integral is zero.\n    2. The dimensionless integral is defined as a function of the reduced temperature T_star.\n    3. The root of this integral function, T_star_B, is found using a robust numerical root-finder\n       (Brent's method) after establishing a valid bracket.\n    4. The numerical quadrature for the integral is performed using SciPy's `quad` function with\n       specified high precision.\n    5. The universal T_star_B is then used to calculate the Boyle temperature T_B for each\n       test case using its specific energy parameter epsilon.\n    \"\"\"\n\n    def get_reduced_b2_integral(t_star):\n        \"\"\"\n        Calculates the dimensionless integral part of the second virial coefficient B2.\n        The Boyle temperature occurs when this integral is zero.\n        \n        The integral is: integral_{0 to inf} [exp(-U*(rho)/T_star) - 1] * rho^2 drho\n        where U*(rho) = 4 * (rho^-12 - rho^-6).\n\n        Args:\n            t_star (float): The reduced temperature, T* = k_B*T / epsilon.\n\n        Returns:\n            float: The value of the dimensionless integral.\n        \"\"\"\n        # The Lennard-Jones potential in reduced units U*(rho) = U(r/sigma)/epsilon\n        # is U* = 4 * (rho**-12 - rho**-6).\n        # The argument of the exponential is -U*/T_star.\n        integrand = lambda rho: (np.exp(-4.0 / t_star * (rho**-12 - rho**-6)) - 1.0) * rho**2\n\n        # Perform numerical quadrature over the semi-infinite interval [0, inf).\n        # The tolerances are set as specified in the problem statement.\n        integral_val, _ = integrate.quad(\n            integrand,\n            0,\n            np.inf,\n            epsabs=1e-8,\n            epsrel=1e-8\n        )\n        return integral_val\n\n    # Find the universal reduced Boyle temperature, T_star_B.\n    # This is done by finding the root of the get_reduced_b2_integral function.\n    \n    # First, establish a bracketing interval [a, b] where the function values have opposite signs.\n    # Based on physical principles, at low T*, attractions dominate, B2  0, so integral  0.\n    # At high T*, repulsions dominate, B2  0, so integral  0.\n    # We will search for a root in the specified domain T* in [0.01, 100].\n    # Let's test a reasonable bracket, e.g., [1.0, 5.0].\n    bracket_a, bracket_b = 1.0, 5.0\n    \n    val_a = get_reduced_b2_integral(bracket_a)\n    val_b = get_reduced_b2_integral(bracket_b)\n\n    # Sanity check for the bracket\n    if np.sign(val_a) == np.sign(val_b):\n        raise ValueError(\n            f\"The chosen interval [{bracket_a}, {bracket_b}] does not bracket the root. \"\n            f\"Function values are {val_a} and {val_b}.\"\n        )\n\n    # Use a robust bracketing root-finder (Brent's method) to find T_star_B with the required tolerance.\n    reduced_boyle_temp = optimize.brentq(\n        get_reduced_b2_integral,\n        bracket_a,\n        bracket_b,\n        xtol=1e-6\n    )\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (epsilon/k_B in Kelvin, sigma in meters).\n    test_cases = [\n        (120.0, 3.40e-10),  # Case 1\n        (200.0, 3.40e-10),  # Case 2\n        (120.0, 4.00e-10),  # Case 3\n        (60.0, 3.00e-10),   # Case 4\n        (500.0, 3.40e-10),  # Case 5\n    ]\n\n    results = []\n    for eps_k_val, sigma_val in test_cases:\n        # The Boyle temperature T_B = T_star_B * (epsilon / k_B).\n        # The length scale sigma is not needed for this calculation, as shown by non-dimensionalization.\n        boyle_temp_kelvin = reduced_boyle_temp * eps_k_val\n        results.append(boyle_temp_kelvin)\n\n    # Format the results into a single string as required.\n    # Each value must be rounded to exactly three decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2942370"}, {"introduction": "In modern research, quantum chemical calculations are the gold standard for describing intermolecular interactions, but different methods offer varying balances of accuracy and computational cost. To develop an intuition for the performance of common methods like MP2, CCSD(T), and DFT-D, it is instructive to analyze their behavior using simplified models that capture their essential physics. This computational exercise [@problem_id:2942360] guides you to build and assess such \"surrogate\" models for the water dimer, introducing the crucial practice of benchmarking and error analysis in computational chemistry.", "problem": "You are to write a complete, runnable program that models the interaction energy curve of a hydrogen-bonded water dimer along the intermolecular separation coordinate using analytically defined, physically motivated surrogate models that emulate three widely used electronic structure methods. Your goals are to construct a high-level benchmark reference energy model from fundamental physical contributions and then assess the performance of the method surrogates relative to this benchmark across a specified test suite of intermolecular separations.\n\nFundamental base and modeling assumptions:\n- Represent each water monomer by its permanent dipole moment of magnitude $\\mu$, aligned colinearly (head-to-tail) along the intermolecular axis, which approximates the hydrogen bond donor-acceptor alignment. The dipole-dipole interaction energy for two colinear dipoles in this arrangement is taken as $U_{\\mathrm{dd}}(R) = -\\dfrac{2}{4 \\pi \\varepsilon_0} \\dfrac{\\mu^2}{R^3}$. In the unit system used below, this is implemented as $U_{\\mathrm{dd}}(R) = -2 k_e \\dfrac{\\mu^2}{R^3}$ where $k_e$ is Coulomb’s constant in convenient chemistry units and $\\mu$ is expressed in elementary charge–angstrom ($e \\cdot \\text{\\AA}$).\n- Long-range attractive contributions are modeled using well-tested asymptotic forms:\n  - London dispersion energy $E_{\\mathrm{disp}}(R) = - \\dfrac{C_6}{R^6}$, where $C_6$ is the dispersion coefficient.\n  - Induction (polarization) energy $E_{\\mathrm{ind}}(R) = - \\dfrac{C_8}{R^8}$, as a compact surrogate for the leading-order induction contribution between a polar molecule and an induced dipole.\n- Short-range Pauli (exchange) repulsion is modeled by a steep inverse-power law $E_{\\mathrm{rep}}(R) = \\dfrac{A}{R^{12}}$.\n\nDefine the benchmark reference energy model as the sum\n$$\nE_{\\mathrm{bench}}(R) \\;=\\; U_{\\mathrm{dd}}(R) \\;+\\; E_{\\mathrm{disp}}(R) \\;+\\; E_{\\mathrm{ind}}(R) \\;+\\; E_{\\mathrm{rep}}(R).\n$$\n\nDefine three method-surrogate models that emulate characteristic behaviors of common electronic structure methods:\n- Møller–Plesset second-order perturbation theory (MP2): model overbinding of dispersion by a fixed scale factor $\\delta$,\n$$\nE_{\\mathrm{MP2}}(R) \\;=\\; U_{\\mathrm{dd}}(R) \\;+\\; E_{\\mathrm{rep}}(R) \\;+\\; E_{\\mathrm{ind}}(R) \\;+\\; (1+\\delta)\\,E_{\\mathrm{disp}}(R).\n$$\n- Coupled Cluster with Singles, Doubles, and perturbative Triples [CCSD(T)]: model near-benchmark quality with a small basis-incompleteness offset $\\Delta$,\n$$\nE_{\\mathrm{CCSD(T)}}(R) \\;=\\; E_{\\mathrm{bench}}(R) \\;+\\; \\Delta.\n$$\n- Dispersion-corrected Density Functional Theory (DFT-D): model as a semilocal baseline for permanent electrostatics and induction with a damped empirical dispersion term, where $s_6$ and $s_{\\mathrm{ind}}$ are scale factors and $R_d$ is a damping length,\n$$\nE_{\\mathrm{DFT\\!-\\!D}}(R) \\;=\\; U_{\\mathrm{dd}}(R) \\;+\\; E_{\\mathrm{rep}}(R) \\;+\\; s_{\\mathrm{ind}}\\,E_{\\mathrm{ind}}(R) \\;-\\; \\frac{s_6 \\, C_6}{R^6 + R_d^6}.\n$$\n\nAll energies must be reported in kilojoules per mole (kJ/mol). All separations must be reported and interpreted in angstrom ($\\text{\\AA}$). All constants and parameters are provided below and must be used exactly as stated:\n\n- Coulomb constant in chemistry units: $k_e = 1389.35458 \\,\\text{kJ mol}^{-1}\\,\\text{\\AA}\\,e^{-2}$.\n- Water gas-phase dipole moment: $\\mu = 1.85 \\,\\text{D}$.\n- Debye conversion: $1 \\,\\text{D} = 0.20819434 \\, e \\cdot \\text{\\AA}$.\n- Dispersion coefficient: $C_6 = 2588 \\,\\text{kJ}\\,\\text{\\AA}^6 \\,\\text{mol}^{-1}$.\n- Induction coefficient: $C_8 = 20000 \\,\\text{kJ}\\,\\text{\\AA}^8 \\,\\text{mol}^{-1}$.\n- Repulsion coefficient: $A = 2.0 \\times 10^6 \\,\\text{kJ}\\,\\text{\\AA}^{12}\\,\\text{mol}^{-1}$.\n- MP2 dispersion scaling: $\\delta = 0.25$.\n- CCSD(T) offset: $\\Delta = +0.5 \\,\\text{kJ/mol}$.\n- DFT-D dispersion scale: $s_6 = 0.75$.\n- DFT-D induction scale: $s_{\\mathrm{ind}} = 0.90$.\n- DFT-D damping length: $R_d = 2.0 \\,\\text{\\AA}$.\n\nRequired computations:\n1. Convert the dipole to $e \\cdot \\text{\\AA}$ via $\\mu_{e\\text{\\AA}} = \\mu \\times 0.20819434$ and use it in $U_{\\mathrm{dd}}(R) = -2 k_e \\mu_{e\\text{\\AA}}^2 / R^3$.\n2. For each separation $R$ in the test suite (see below), compute $E_{\\mathrm{bench}}(R)$, $E_{\\mathrm{MP2}}(R)$, $E_{\\mathrm{CCSD(T)}}(R)$, and $E_{\\mathrm{DFT\\!-\\!D}}(R)$.\n3. For each method surrogate relative to the benchmark, compute the error at each $R$ as $E_{\\mathrm{method}}(R) - E_{\\mathrm{bench}}(R)$, and then compute three aggregate statistics over the full test suite:\n   - Root-mean-square error (RMSE): $\\sqrt{\\dfrac{1}{N}\\sum_{i=1}^N \\left( \\Delta E_i \\right)^2}$.\n   - Mean signed error (MSE): $\\dfrac{1}{N}\\sum_{i=1}^N \\Delta E_i$.\n   - Maximum absolute error (MaxAE): $\\max_i \\left| \\Delta E_i \\right|$.\n   Here $\\Delta E_i$ denotes the error at the $i$-th separation, and $N$ is the number of separations.\n\nTest suite:\n- Use the following separations (in angstrom): $R \\in \\{\\, 2.5,\\, 2.8,\\, 3.0,\\, 3.5,\\, 4.5,\\, 8.0 \\,\\}$.\n\nAnswer specification:\n- Your program must produce a single line of output containing a comma-separated list of $9$ floating-point numbers, rounded to three decimal places, enclosed in square brackets, in the following order:\n  - $[\\mathrm{RMSE}_{\\mathrm{MP2}}, \\mathrm{MSE}_{\\mathrm{MP2}}, \\mathrm{MaxAE}_{\\mathrm{MP2}}, \\mathrm{RMSE}_{\\mathrm{CCSD(T)}}, \\mathrm{MSE}_{\\mathrm{CCSD(T)}}, \\mathrm{MaxAE}_{\\mathrm{CCSD(T)}}, \\mathrm{RMSE}_{\\mathrm{DFT\\!-\\!D}}, \\mathrm{MSE}_{\\mathrm{DFT\\!-\\!D}}, \\mathrm{MaxAE}_{\\mathrm{DFT\\!-\\!D}}]$.\n- Units: All energies implicit in the output are in $\\text{kJ/mol}$. No units should be printed.\n- Rounding: Each reported number must be rounded to three decimal places.\n\nYour program must be entirely self-contained, require no input, and may use only the Python standard library and the specified numerical libraries. The result must be reproducible exactly from the constants and definitions above.", "solution": "The problem statement has been analyzed and is deemed valid. It constitutes a well-defined computational exercise in physical chemistry, requiring the implementation of analytical potential energy models and the statistical assessment of their performance against a benchmark. The models, while simplified, are grounded in established physical principles of intermolecular forces. All constants, parameters, and functional forms are provided without ambiguity, rendering the problem self-contained and tractable.\n\nThe solution proceeds as follows. First, we define all physical constants and model parameters as specified. Second, we establish the functions for the individual energy contributions to the total interaction energy. Third, we construct the total energy functions for the benchmark and the three surrogate methods. Fourth, we calculate the modeling error for each surrogate method relative to the benchmark across a given set of intermolecular separations. Finally, we compute the required aggregate error statistics: Root-Mean-Square Error (RMSE), Mean Signed Error (MSE), and Maximum Absolute Error (MaxAE).\n\nAll energies are in units of $\\text{kJ/mol}$ and distances in $\\text{\\AA}$.\n\nThe required physical constants and model parameters are:\n- Coulomb constant: $k_e = 1389.35458 \\,\\text{kJ mol}^{-1}\\,\\text{\\AA}\\,e^{-2}$\n- Water dipole moment: $\\mu = 1.85 \\,\\text{D}$\n- Debye conversion factor: $1 \\,\\text{D} = 0.20819434 \\, e \\cdot \\text{\\AA}$\n- Repulsion coefficient: $A = 2.0 \\times 10^6 \\,\\text{kJ}\\,\\text{\\AA}^{12}\\,\\text{mol}^{-1}$\n- Dispersion coefficient: $C_6 = 2588 \\,\\text{kJ}\\,\\text{\\AA}^6 \\,\\text{mol}^{-1}$\n- Induction coefficient: $C_8 = 20000 \\,\\text{kJ}\\,\\text{\\AA}^8 \\,\\text{mol}^{-1}$\n- MP2 dispersion scaling: $\\delta = 0.25$\n- CCSD(T) offset: $\\Delta = +0.5 \\,\\text{kJ/mol}$\n- DFT-D dispersion scale: $s_6 = 0.75$\n- DFT-D induction scale: $s_{\\mathrm{ind}} = 0.90$\n- DFT-D damping length: $R_d = 2.0 \\,\\text{\\AA}$\n\nThe dipole moment must first be converted to the required units of $e \\cdot \\text{\\AA}$:\n$$ \\mu_{e\\text{\\AA}} = \\mu \\times 0.20819434 = 1.85 \\times 0.20819434 \\approx 0.3851595 \\, e \\cdot \\text{\\AA} $$\n\nThe four fundamental energy components are defined as functions of the intermolecular separation $R$:\n1.  Dipole-dipole interaction: $U_{\\mathrm{dd}}(R) = -2 k_e \\dfrac{\\mu_{e\\text{\\AA}}^2}{R^3}$\n2.  Exchange-repulsion: $E_{\\mathrm{rep}}(R) = \\dfrac{A}{R^{12}}$\n3.  London dispersion: $E_{\\mathrm{disp}}(R) = - \\dfrac{C_6}{R^6}$\n4.  Induction: $E_{\\mathrm{ind}}(R) = - \\dfrac{C_8}{R^8}$\n\nThe benchmark model is the sum of these components:\n$$ E_{\\mathrm{bench}}(R) = U_{\\mathrm{dd}}(R) + E_{\\mathrm{rep}}(R) + E_{\\mathrm{disp}}(R) + E_{\\mathrm{ind}}(R) $$\n\nThe three surrogate models are defined as:\n$$ E_{\\mathrm{MP2}}(R) = U_{\\mathrm{dd}}(R) + E_{\\mathrm{rep}}(R) + E_{\\mathrm{ind}}(R) + (1+\\delta) E_{\\mathrm{disp}}(R) $$\n$$ E_{\\mathrm{CCSD(T)}}(R) = E_{\\mathrm{bench}}(R) + \\Delta $$\n$$ E_{\\mathrm{DFT-D}}(R) = U_{\\mathrm{dd}}(R) + E_{\\mathrm{rep}}(R) + s_{\\mathrm{ind}} E_{\\mathrm{ind}}(R) - \\frac{s_6 C_6}{R^6 + R_d^6} $$\n\nThe error for each method, $\\Delta E_{\\mathrm{method}}(R) = E_{\\mathrm{method}}(R) - E_{\\mathrm{bench}}(R)$, can be simplified by substituting the expressions above:\n- For MP2:\n$$ \\Delta E_{\\mathrm{MP2}}(R) = \\left(U_{\\mathrm{dd}} + E_{\\mathrm{rep}} + E_{\\mathrm{ind}} + (1+\\delta)E_{\\mathrm{disp}}\\right) - \\left(U_{\\mathrm{dd}} + E_{\\mathrm{rep}} + E_{\\mathrm{disp}} + E_{\\mathrm{ind}}\\right) = \\delta E_{\\mathrm{disp}}(R) = -\\frac{\\delta C_6}{R^6} $$\n- For CCSD(T):\n$$ \\Delta E_{\\mathrm{CCSD(T)}}(R) = (E_{\\mathrm{bench}}(R) + \\Delta) - E_{\\mathrm{bench}}(R) = \\Delta $$\n- For DFT-D:\n$$ \\Delta E_{\\mathrm{DFT-D}}(R) = \\left(U_{\\mathrm{dd}} + E_{\\mathrm{rep}} + s_{\\mathrm{ind}}E_{\\mathrm{ind}} - \\frac{s_6 C_6}{R^6+R_d^6}\\right) - \\left(U_{\\mathrm{dd}} + E_{\\mathrm{rep}} + E_{\\mathrm{disp}} + E_{\\mathrm{ind}}\\right) $$\n$$ \\Delta E_{\\mathrm{DFT-D}}(R) = (s_{\\mathrm{ind}}-1)E_{\\mathrm{ind}}(R) - E_{\\mathrm{disp}}(R) - \\frac{s_6 C_6}{R^6+R_d^6} $$\n$$ \\Delta E_{\\mathrm{DFT-D}}(R) = -(s_{\\mathrm{ind}}-1)\\frac{C_8}{R^8} + \\frac{C_6}{R^6} - \\frac{s_6 C_6}{R^6+R_d^6} $$\n\nThese error functions are evaluated for each separation $R_i$ in the test suite $R \\in \\{2.5, 2.8, 3.0, 3.5, 4.5, 8.0\\}$, yielding a set of $N=6$ error values $\\{\\Delta E_i\\}$ for each method. The aggregate statistics are then computed as:\n- Root-mean-square error (RMSE): $\\sqrt{\\dfrac{1}{N}\\sum_{i=1}^N (\\Delta E_i)^2}$\n- Mean signed error (MSE): $\\dfrac{1}{N}\\sum_{i=1}^N \\Delta E_i$\n- Maximum absolute error (MaxAE): $\\max_i |\\Delta E_i|$\n\nFor the CCSD(T) model, the error is constant, $\\Delta E_i = \\Delta = 0.5$. Therefore, its statistics are trivial:\n- $\\mathrm{RMSE}_{\\mathrm{CCSD(T)}} = \\sqrt{\\frac{1}{N}\\sum \\Delta^2} = |\\Delta| = 0.5$\n- $\\mathrm{MSE}_{\\mathrm{CCSD(T)}} = \\frac{1}{N}\\sum \\Delta = \\Delta = 0.5$\n- $\\mathrm{MaxAE}_{\\mathrm{CCSD(T)}} = \\max |\\Delta| = |\\Delta| = 0.5$\n\nThe statistics for the MP2 and DFT-D models require numerical computation over the specified test suite of separations. The program in the final answer implements these calculations precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and assesses surrogate models for water dimer interaction energy.\n    \"\"\"\n    \n    # Define constants and parameters\n    KE = 1389.35458  # Coulomb constant (kJ/mol * A * e^-2)\n    MU_D = 1.85  # Water dipole moment (Debye)\n    D_TO_EA = 0.20819434  # Debye to e*A conversion\n    C6 = 2588.0  # Dispersion coefficient (kJ*A^6/mol)\n    C8 = 20000.0  # Induction coefficient (kJ*A^8/mol)\n    A = 2.0e6  # Repulsion coefficient (kJ*A^12/mol)\n    \n    # Model parameters\n    DELTA_MP2 = 0.25      # MP2 dispersion scaling\n    DELTA_CCSDT = 0.5     # CCSD(T) offset (kJ/mol)\n    S6_DFTD = 0.75        # DFT-D dispersion scale factor\n    S_IND_DFTD = 0.90     # DFT-D induction scale factor\n    RD_DFTD = 2.0         # DFT-D damping length (A)\n    \n    # Test suite of separations (in Angstrom)\n    R_values = np.array([2.5, 2.8, 3.0, 3.5, 4.5, 8.0])\n    \n    # Convert dipole moment to e*A\n    mu_eA = MU_D * D_TO_EA\n    \n    # --- Define energy component functions ---\n    def u_dd(R):\n        return -2 * KE * mu_eA**2 / R**3\n    \n    def e_rep(R):\n        return A / R**12\n    \n    def e_disp(R):\n        return -C6 / R**6\n        \n    def e_ind(R):\n        return -C8 / R**8\n        \n    # --- Define total energy models ---\n    def e_bench(R):\n        return u_dd(R) + e_rep(R) + e_disp(R) + e_ind(R)\n        \n    def e_mp2(R):\n        return u_dd(R) + e_rep(R) + e_ind(R) + (1 + DELTA_MP2) * e_disp(R)\n        \n    def e_ccsdt(R):\n        return e_bench(R) + DELTA_CCSDT\n        \n    def e_dftd(R):\n        damped_disp = - (S6_DFTD * C6) / (R**6 + RD_DFTD**6)\n        return u_dd(R) + e_rep(R) + S_IND_DFTD * e_ind(R) + damped_disp\n\n    # --- Calculate errors for each model relative to the benchmark ---\n    bench_energies = e_bench(R_values)\n    \n    mp2_errors = e_mp2(R_values) - bench_energies\n    ccsdt_errors = e_ccsdt(R_values) - bench_energies\n    dftd_errors = e_dftd(R_values) - bench_energies\n    \n    # --- Helper function to compute error statistics ---\n    def calculate_stats(errors):\n        \"\"\"Calculates RMSE, MSE, and MaxAE for a given array of errors.\"\"\"\n        rmse = np.sqrt(np.mean(np.square(errors)))\n        mse = np.mean(errors)\n        max_ae = np.max(np.abs(errors))\n        return rmse, mse, max_ae\n\n    # --- Compute and collect all statistics ---\n    stats_mp2 = calculate_stats(mp2_errors)\n    stats_ccsdt = calculate_stats(ccsdt_errors)\n    stats_dftd = calculate_stats(dftd_errors)\n    \n    all_stats = list(stats_mp2) + list(stats_ccsdt) + list(stats_dftd)\n    \n    # Format the results for printing\n    # Each number is rounded to three decimal places.\n    formatted_results = [f\"{s:.3f}\" for s in all_stats]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2942360"}]}