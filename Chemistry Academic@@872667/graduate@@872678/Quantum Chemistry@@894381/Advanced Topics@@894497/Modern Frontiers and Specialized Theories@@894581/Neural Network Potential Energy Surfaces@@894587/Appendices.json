{"hands_on_practices": [{"introduction": "A cornerstone of quantum mechanics is the indistinguishability of identical particles, which dictates that the potential energy surface must be invariant under the permutation of their labels. This practice problem directly confronts the consequences of violating this fundamental symmetry. By analyzing a simple, non-invariant model, you will derive the unphysical energy splitting that arises for two physically degenerate configurations, providing a clear motivation for the sophisticated, permutation-invariant architectures used in modern neural network potentials. [@problem_id:2908410]", "problem": "In the Born–Oppenheimer (BO) approximation for the hydrogen molecular cation $\\mathrm{H}_3^+$, the exact potential energy surface (PES) $E_{\\mathrm{BO}}(\\{\\mathbf{R}_i\\})$ is invariant under any permutation of the positions $\\{\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3\\}$ of the three identical hydrogen nuclei. Consider instead a learned neural network potential (NNP) that violates permutation invariance by using atom-indexed linear contributions on translation-invariant but index-ordered descriptors. Specifically, for nuclear positions $\\{\\mathbf{R}_i\\}_{i=1}^3 \\subset \\mathbb{R}^3$, define centered coordinates $\\mathbf{s}_i = \\mathbf{R}_i - \\frac{1}{3}\\sum_{j=1}^3 \\mathbf{R}_j$, and let the predicted energy be\n$$\nE_{\\boldsymbol{\\theta}}(\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3) = b + \\sum_{i=1}^{3} \\mathbf{u}_i \\cdot \\mathbf{s}_i,\n$$\nwhere $b \\in \\mathbb{R}$ is a scalar bias and $\\mathbf{u}_i \\in \\mathbb{R}^3$ are independent, atom-indexed weight vectors, $\\mathbf{u}_i = (u_{ix},u_{iy},u_{iz})$. This model is translation-invariant by construction but not permutation-invariant unless $\\mathbf{u}_1=\\mathbf{u}_2=\\mathbf{u}_3$.\n\nConsider the equilateral geometry of side length $R>0$ in the plane $z=0$ with the following lab-frame coordinates:\n$$\n\\mathbf{R}_1 = (0,0,0),\\quad \\mathbf{R}_2 = (R,0,0),\\quad \\mathbf{R}_3 = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right).\n$$\nDefine the two physically identical but differently labeled inputs: geometry $\\mathcal{G}_A$ uses the labeling $(1,2,3)$ as given, while geometry $\\mathcal{G}_B$ is obtained by permuting labels $1 \\leftrightarrow 2$, i.e., $(2,1,3)$. Because $\\mathrm{H}_3^+$ has three identical nuclei, $E_{\\mathrm{BO}}$ must satisfy $E_{\\mathrm{BO}}(\\mathcal{G}_A)=E_{\\mathrm{BO}}(\\mathcal{G}_B)$. However, the model $E_{\\boldsymbol{\\theta}}$ need not.\n\nStarting from the permutation symmetry of the BO Hamiltonian and the definition of $E_{\\boldsymbol{\\theta}}$ above, derive the closed-form analytic expression for the predicted degeneracy splitting\n$$\n\\Delta E \\equiv E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B)\n$$\nin terms of $R$ and the weight components $u_{ix},u_{iy},u_{iz}$. Express your final answer as a single simplified analytic expression. Do not numerically evaluate or round your result. No units are required for the final expression.", "solution": "The problem is subjected to validation before proceeding.\n\nStep 1: Extracted Givens.\n- The system is the hydrogen molecular cation $\\mathrm{H}_3^+$.\n- The Born-Oppenheimer (BO) potential energy surface (PES) is $E_{\\mathrm{BO}}(\\{\\mathbf{R}_i\\})$.\n- $E_{\\mathrm{BO}}$ is invariant under any permutation of the positions $\\{\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3\\}$.\n- A learned neural network potential (NNP) is defined as $E_{\\boldsymbol{\\theta}}(\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3) = b + \\sum_{i=1}^{3} \\mathbf{u}_i \\cdot \\mathbf{s}_i$.\n- $b \\in \\mathbb{R}$ is a scalar bias.\n- $\\mathbf{u}_i \\in \\mathbb{R}^3$ are independent, atom-indexed weight vectors, $\\mathbf{u}_i = (u_{ix},u_{iy},u_{iz})$.\n- The centered coordinates are $\\mathbf{s}_i = \\mathbf{R}_i - \\frac{1}{3}\\sum_{j=1}^3 \\mathbf{R}_j$.\n- The model is translation-invariant but not necessarily permutation-invariant.\n- An equilateral geometry of side length $R>0$ is given in the plane $z=0$ with coordinates: $\\mathbf{R}_1 = (0,0,0)$, $\\mathbf{R}_2 = (R,0,0)$, $\\mathbf{R}_3 = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right)$.\n- Geometry $\\mathcal{G}_A$ corresponds to the labeling $(1,2,3)$ as given.\n- Geometry $\\mathcal{G}_B$ corresponds to the labeling $(2,1,3)$, obtained by permuting labels $1 \\leftrightarrow 2$.\n- The objective is to derive the expression for the degeneracy splitting $\\Delta E \\equiv E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B)$.\n\nStep 2: Validation.\nThe problem is scientifically grounded, well-posed, and objective. It utilizes standard concepts from quantum chemistry (Born-Oppenheimer approximation, potential energy surfaces, permutation symmetry) and machine learning (neural network potentials, input features). The model presented, while simple, is a valid mathematical construct used to demonstrate the consequences of broken symmetry, a critical topic in the field. All terms are defined without ambiguity, the required information is complete, and the premises are consistent. The problem is a formalizable and verifiable mathematical exercise, not a trivial or ill-posed question.\n\nStep 3: Verdict.\nThe problem is valid. A solution will be provided.\n\nThe objective is to compute the degeneracy splitting $\\Delta E$, defined as:\n$$\n\\Delta E \\equiv E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B)\n$$\nThe energy predicted by the model for a given set of atomic positions $\\{\\mathbf{R}_1, \\mathbf{R}_2, \\mathbf{R}_3\\}$ is:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3) = b + \\sum_{i=1}^{3} \\mathbf{u}_i \\cdot \\mathbf{s}_i\n$$\nwhere $\\mathbf{s}_i = \\mathbf{R}_i - \\mathbf{R}_{\\text{COM}}$ are the centered coordinates, and $\\mathbf{R}_{\\text{COM}} = \\frac{1}{3}\\sum_{j=1}^3 \\mathbf{R}_j$ is the center of the nuclei. The weight vectors $\\mathbf{u}_i$ are indexed by the atom label.\n\nFirst, we calculate the energy for geometry $\\mathcal{G}_A$. The coordinates are $\\mathbf{R}_1^{(A)} = (0,0,0)$, $\\mathbf{R}_2^{(A)} = (R,0,0)$, and $\\mathbf{R}_3^{(A)} = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right)$.\nThe center of positions is:\n$$\n\\mathbf{R}_{\\text{COM}} = \\frac{1}{3}\\left[ (0,0,0) + (R,0,0) + \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right) \\right] = \\frac{1}{3}\\left(\\frac{3R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right) = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right)\n$$\nThe centered coordinates for $\\mathcal{G}_A$ are:\n$$\n\\mathbf{s}_1^{(A)} = \\mathbf{R}_1^{(A)} - \\mathbf{R}_{\\text{COM}} = (0,0,0) - \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(-\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right)\n$$\n$$\n\\mathbf{s}_2^{(A)} = \\mathbf{R}_2^{(A)} - \\mathbf{R}_{\\text{COM}} = (R,0,0) - \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right)\n$$\n$$\n\\mathbf{s}_3^{(A)} = \\mathbf{R}_3^{(A)} - \\mathbf{R}_{\\text{COM}} = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right) - \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(0, \\frac{\\sqrt{3}R}{2} - \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(0, \\frac{\\sqrt{3}R}{3}, 0\\right)\n$$\nThe energy for $\\mathcal{G}_A$ is therefore:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) = b + \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\n$$\nNext, we consider geometry $\\mathcal{G}_B$, which is obtained by permuting the labels $1 \\leftrightarrow 2$ of $\\mathcal{G}_A$. The coordinates for $\\mathcal{G}_B$ are $\\mathbf{R}_1^{(B)} = \\mathbf{R}_2^{(A)}$, $\\mathbf{R}_2^{(B)} = \\mathbf{R}_1^{(A)}$, and $\\mathbf{R}_3^{(B)} = \\mathbf{R}_3^{(A)}$. The set of position vectors is identical, so the center $\\mathbf{R}_{\\text{COM}}$ is unchanged. The centered coordinates are calculated as $\\mathbf{s}_i^{(B)} = \\mathbf{R}_i^{(B)} - \\mathbf{R}_{\\text{COM}}$.\n$$\n\\mathbf{s}_1^{(B)} = \\mathbf{R}_1^{(B)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{R}_2^{(A)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{s}_2^{(A)}\n$$\n$$\n\\mathbf{s}_2^{(B)} = \\mathbf{R}_2^{(B)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{R}_1^{(A)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{s}_1^{(A)}\n$$\n$$\n\\mathbf{s}_3^{(B)} = \\mathbf{R}_3^{(B)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{R}_3^{(A)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{s}_3^{(A)}\n$$\nThe model's weights $\\mathbf{u}_i$ are fixed to the atom indices, not their positions. Thus, the energy for $\\mathcal{G}_B$ is:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathcal{G}_B) = b + \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(B)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(B)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(B)}\n$$\nSubstituting the relations found above:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathcal{G}_B) = b + \\mathbf{u}_1 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\n$$\nNow we compute the splitting $\\Delta E$:\n$$\n\\Delta E = E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B) = \\left(b + \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\\right) - \\left(b + \\mathbf{u}_1 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\\right)\n$$\nThe bias $b$ and the term for atom $3$ cancel, leaving:\n$$\n\\Delta E = \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(A)} - \\mathbf{u}_1 \\cdot \\mathbf{s}_2^{(A)} - \\mathbf{u}_2 \\cdot \\mathbf{s}_1^{(A)}\n$$\nThis expression can be rearranged by grouping the weight vectors:\n$$\n\\Delta E = (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot \\mathbf{s}_1^{(A)} - (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot \\mathbf{s}_2^{(A)}\n$$\n$$\n\\Delta E = (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot (\\mathbf{s}_1^{(A)} - \\mathbf{s}_2^{(A)})\n$$\nWe now compute the vector difference $(\\mathbf{s}_1^{(A)} - \\mathbf{s}_2^{(A)})$:\n$$\n\\mathbf{s}_1^{(A)} - \\mathbf{s}_2^{(A)} = \\left(-\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right) - \\left(\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(-\\frac{R}{2} - \\frac{R}{2}, -\\frac{\\sqrt{3}R}{6} + \\frac{\\sqrt{3}R}{6}, 0 - 0\\right) = (-R, 0, 0)\n$$\nFinally, we compute the dot product:\n$$\n\\Delta E = (u_{1x}-u_{2x}, u_{1y}-u_{2y}, u_{1z}-u_{2z}) \\cdot (-R, 0, 0)\n$$\n$$\n\\Delta E = (u_{1x}-u_{2x})(-R) + (u_{1y}-u_{2y})(0) + (u_{1z}-u_{2z})(0)\n$$\n$$\n\\Delta E = -R(u_{1x}-u_{2x}) = R(u_{2x}-u_{1x})\n$$\nThis is the final closed-form expression for the predicted degeneracy splitting. It shows that the violation of permutation invariance for this specific permutation and geometry depends only on the side length $R$ and the difference in the $x$-components of the weight vectors associated with the permuted atoms. For a permutation-invariant potential, $\\mathbf{u}_1 = \\mathbf{u}_2$, which correctly implies $\\Delta E = 0$.", "answer": "$$\n\\boxed{R(u_{2x} - u_{1x})}\n$$", "id": "2908410"}, {"introduction": "In classical mechanics, the force $\\mathbf{F}$ is the negative gradient of a scalar potential energy $E$, a relationship expressed as $\\mathbf{F} = -\\nabla E$. A direct consequence is that the force field must be *conservative*, meaning the work done along any closed path is zero. This exercise explores a crucial pitfall in designing neural network potentials: directly training on forces without enforcing this constraint can yield an unphysical, non-conservative force field. You will quantify this unphysical behavior by calculating the non-zero work done by a sample force field around a closed loop, making the abstract concept of path-dependence tangible. [@problem_id:2908468]", "problem": "In force-matching approaches to building a Neural Network Potential Energy Surface (NN-PES), it is common to regress forces directly without explicitly integrating a scalar energy. However, physical forces derived from a scalar potential must be conservative. Consider a toy two-dimensional internal coordinate space with coordinates $\\mathbf{q} = (q_{1}, q_{2})$ in atomic units (bohr for length), representing a local patch of the configuration space near a reference geometry. Suppose a force-only regression yields a linear model\n$$\n\\mathbf{F}(\\mathbf{q}) = \\mathbf{W}\\,\\mathbf{q}, \\quad \\text{with} \\quad \\mathbf{W} = \\alpha \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix},\n$$\nwhere $\\alpha$ is a constant. This form can arise from an unconstrained least-squares fit to local force residuals, and it is not guaranteed to be integrable.\n\nUsing only the fundamental definitions of conservative fields and work as a line integral, do the following:\n\n1. Argue from first principles whether $\\mathbf{F}(\\mathbf{q})$ can be the negative gradient of any scalar energy $E(\\mathbf{q})$ on this domain.\n\n2. Consider the closed curve $C$ defined by the circle $q_{1}^{2} + q_{2}^{2} = R^{2}$, centered at the origin and traversed counterclockwise once. Compute the work\n$$\n\\oint_{C} \\mathbf{F}(\\mathbf{q}) \\cdot d\\mathbf{q}\n$$\nin terms of $\\alpha$ and $R$.\n\n3. Evaluate your result for $\\alpha = 1$ $\\text{Hartree/bohr}^2$ and $R = 1$ bohr. Express the final work in Hartree. No rounding is required.", "solution": "The problem requires an analysis of a given two-dimensional force field $\\mathbf{F}(\\mathbf{q})$ to determine if it is conservative, and to compute the work done along a specific closed path.\n\nFirst, we must express the force vector $\\mathbf{F}(\\mathbf{q})$ components explicitly. The force field is defined as $\\mathbf{F}(\\mathbf{q}) = \\mathbf{W}\\mathbf{q}$, where $\\mathbf{q} = \\begin{pmatrix} q_{1} \\\\ q_{2} \\end{pmatrix}$ and the matrix $\\mathbf{W}$ is given by $\\alpha \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$.\nPerforming the matrix-vector multiplication:\n$$\n\\mathbf{F}(\\mathbf{q}) = \\alpha \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\begin{pmatrix} q_{1} \\\\ q_{2} \\end{pmatrix} = \\alpha \\begin{pmatrix} q_{2} \\\\ -q_{1} \\end{pmatrix} = \\begin{pmatrix} \\alpha q_{2} \\\\ -\\alpha q_{1} \\end{pmatrix}\n$$\nSo, the components of the force field are $F_{1}(q_{1}, q_{2}) = \\alpha q_{2}$ and $F_{2}(q_{1}, q_{2}) = -\\alpha q_{1}$.\n\nThe first task is to determine if this force field can be expressed as the negative gradient of a scalar potential energy function $E(q_{1}, q_{2})$, such that $\\mathbf{F} = -\\nabla E$. A necessary condition for a vector field to be a gradient field (i.e., to be conservative) on a simply connected domain like the entire plane $\\mathbb{R}^{2}$ is that its curl must be zero. For a two-dimensional vector field $\\mathbf{F} = (F_{1}, F_{2})$, this condition simplifies to the equality of mixed partial derivatives derived from the potential:\n$$\n\\frac{\\partial F_{1}}{\\partial q_{2}} = \\frac{\\partial F_{2}}{\\partial q_{1}}\n$$\nThis is a direct consequence of Clairaut's theorem, assuming the potential $E$ is twice continuously differentiable, as $\\frac{\\partial}{\\partial q_{2}}(-\\frac{\\partial E}{\\partial q_{1}}) = \\frac{\\partial}{\\partial q_{1}}(-\\frac{\\partial E}{\\partial q_{2}})$.\nLet us test this condition for the given force field.\nWe compute the partial derivatives:\n$$\n\\frac{\\partial F_{1}}{\\partial q_{2}} = \\frac{\\partial}{\\partial q_{2}}(\\alpha q_{2}) = \\alpha\n$$\n$$\n\\frac{\\partial F_{2}}{\\partial q_{1}} = \\frac{\\partial}{\\partial q_{1}}(-\\alpha q_{1}) = -\\alpha\n$$\nFor the condition to hold, we must have $\\alpha = -\\alpha$, which implies $2\\alpha = 0$, or $\\alpha = 0$. If $\\alpha \\neq 0$, the condition is violated. The problem context, particularly the non-zero structure of $\\mathbf{W}$, implies $\\alpha$ is a non-zero parameter. Therefore, the force field $\\mathbf{F}(\\mathbf{q})$ is non-conservative and cannot be the negative gradient of any scalar energy $E(\\mathbf{q})$.\n\nThe second task is to compute the work done by the force field along the closed circular path $C$ defined by $q_{1}^{2} + q_{2}^{2} = R^{2}$, traversed counterclockwise. The work $W$ is given by the line integral:\n$$\nW = \\oint_{C} \\mathbf{F}(\\mathbf{q}) \\cdot d\\mathbf{q}\n$$\nTo evaluate this integral, we first parameterize the path $C$. A standard counterclockwise parameterization for a circle of radius $R$ is:\n$$\n\\mathbf{q}(t) = (q_{1}(t), q_{2}(t)) = (R \\cos(t), R \\sin(t)) \\quad \\text{for } t \\in [0, 2\\pi]\n$$\nThe differential displacement vector $d\\mathbf{q}$ is found by differentiating $\\mathbf{q}(t)$ with respect to the parameter $t$:\n$$\nd\\mathbf{q} = \\frac{d\\mathbf{q}}{dt} dt = \\left( \\frac{d}{dt}(R \\cos(t)), \\frac{d}{dt}(R \\sin(t)) \\right) dt = (-R \\sin(t), R \\cos(t)) dt\n$$\nNext, we evaluate the force field $\\mathbf{F}$ on the path $C$:\n$$\n\\mathbf{F}(\\mathbf{q}(t)) = (\\alpha q_{2}(t), -\\alpha q_{1}(t)) = (\\alpha R \\sin(t), -\\alpha R \\cos(t))\n$$\nNow we compute the dot product $\\mathbf{F}(\\mathbf{q}(t)) \\cdot \\frac{d\\mathbf{q}}{dt}$:\n$$\n\\mathbf{F} \\cdot \\frac{d\\mathbf{q}}{dt} = (\\alpha R \\sin(t), -\\alpha R \\cos(t)) \\cdot (-R \\sin(t), R \\cos(t))\n$$\n$$\n= (\\alpha R \\sin(t))(-R \\sin(t)) + (-\\alpha R \\cos(t))(R \\cos(t))\n$$\n$$\n= -\\alpha R^{2} \\sin^{2}(t) - \\alpha R^{2} \\cos^{2}(t) = -\\alpha R^{2} (\\sin^{2}(t) + \\cos^{2}(t)) = -\\alpha R^{2}\n$$\nThe work integral then becomes:\n$$\nW = \\int_{0}^{2\\pi} (-\\alpha R^{2}) dt = -\\alpha R^{2} \\int_{0}^{2\\pi} dt = -\\alpha R^{2} [t]_{0}^{2\\pi} = -\\alpha R^{2} (2\\pi - 0)\n$$\n$$\nW = -2\\pi \\alpha R^{2}\n$$\nThis result demonstrates that for any $\\alpha \\neq 0$ and $R > 0$, the work done over a closed loop is non-zero. This provides an independent and definitive proof, from the fundamental definition of work, that the force field is non-conservative, corroborating the conclusion from the first part.\n\nThe third task is to evaluate this work for the specific values $\\alpha = 1$ Hartree/bohr$^{2}$ and $R = 1$ bohr. Substituting these values into our expression for $W$:\n$$\nW = -2\\pi (1 \\text{ Hartree/bohr}^{2}) (1 \\text{ bohr})^{2}\n$$\nThe units correctly combine to yield energy:\n$$\n\\text{Hartree} \\cdot \\text{bohr}^{-2} \\cdot \\text{bohr}^{2} = \\text{Hartree}\n$$\nThe numerical value of the work is:\n$$\nW = -2\\pi\n$$\nThe result is in Hartree, as requested.", "answer": "$$\\boxed{-2\\pi}$$", "id": "2908468"}, {"introduction": "Having established the critical physical constraints of permutation symmetry and conservative forces, we now turn to a powerful architectural paradigm that satisfies them: the message-passing neural network (MPNN). These models build a total energy by summing atomic contributions, where each atom's features are refined by exchanging \"messages\" with its neighbors, naturally ensuring symmetry and deriving forces from a scalar potential. This hands-on coding exercise will demystify the inner workings of an MPNN by requiring you to implement a complete forward pass, from atomic embeddings to the final pooled energy, for a toy molecular system. [@problem_id:2908437]", "problem": "You are asked to implement one deterministic forward pass of a single-layer message-passing network to approximate an atomistic potential energy surface under the Born–Oppenheimer approximation. The model should be a simple translationally and rotationally invariant architecture that maps nuclear geometry to a scalar total energy by pooling per-atom contributions. The mathematical design is constrained by the following foundations: (1) under the Born–Oppenheimer approximation, the potential energy surface depends only on nuclear coordinates and charges; (2) invariance to global translations and rotations is enforced by using only pairwise interatomic distances; (3) the total energy is the sum of per-atom contributions. You must implement the complete computation using the prescribed scalar and tensor operations with the provided numerical parameters, and return a single-line output with all intermediate messages, updated features, and the pooled energy for each test case.\n\nModel and computation to implement:\n- Atom types are represented by an embedding map from atomic number to an initial hidden feature vector of dimension $d_h = 2$.\n- Messages are computed for every ordered pair of distinct atoms using a distance-based filter and an elementwise nonlinearity.\n- The aggregate of incoming messages updates each atom’s hidden state by a gated transformation of the concatenated current hidden features and the summed messages.\n- Atomwise energy contributions are read out linearly from the updated features, and the total energy is the sum across atoms.\n\nAll mathematical entities used below are defined in LaTeX and must be followed exactly.\n\nDefinitions and parameters:\n- Hidden feature dimension: $d_h = 2$.\n- Initial embeddings (dimensionless):\n  - Hydrogen $\\left(Z = 1\\right)$: $\\mathbf{h}_{\\mathrm{H}} = \\begin{bmatrix} 0.40 \\\\ -0.10 \\end{bmatrix}$.\n  - Carbon $\\left(Z = 6\\right)$: $\\mathbf{h}_{\\mathrm{C}} = \\begin{bmatrix} 0.00 \\\\ 0.50 \\end{bmatrix}$.\n  - Oxygen $\\left(Z = 8\\right)$: $\\mathbf{h}_{\\mathrm{O}} = \\begin{bmatrix} 0.80 \\\\ 0.20 \\end{bmatrix}$.\n- Directed message from atom $j$ to atom $i$:\n  - Let $\\mathbf{h}_j \\in \\mathbb{R}^{2}$ be the current hidden feature of atom $j$.\n  - Linear message pre-activation: $\\mathbf{z}_{j} = \\mathbf{W}_m \\mathbf{h}_j + \\mathbf{b}_m$, where\n    $$\\mathbf{W}_m = \\begin{bmatrix} 0.60 & -0.20 \\\\ 0.15 & 0.30 \\end{bmatrix}, \\quad \\mathbf{b}_m = \\begin{bmatrix} 0.05 \\\\ -0.05 \\end{bmatrix}.$$\n  - Nonlinearity: $\\phi(\\cdot) = \\tanh(\\cdot)$ applied elementwise, so $\\tilde{\\mathbf{m}}_{j} = \\phi(\\mathbf{z}_{j})$.\n  - Distance between atoms $i$ and $j$ with positions $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^{3}$ in ångström is $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$.\n  - Radial filter (Gaussian): $f(r) = \\exp\\!\\left(-\\dfrac{(r - \\mu)^2}{2 \\sigma^2}\\right)$ with $\\mu = 1.00$ ångström and $\\sigma = 0.50$ ångström.\n  - Directed message: $\\mathbf{m}_{i \\leftarrow j} = f(r_{ij}) \\cdot \\tilde{\\mathbf{m}}_{j}$.\n- Message aggregation for atom $i$: $\\mathbf{m}_i = \\sum_{j \\neq i} \\mathbf{m}_{i \\leftarrow j}$.\n- Update rule for atom $i$:\n  - Concatenate $\\mathbf{h}_i$ and $\\mathbf{m}_i$ to form $\\mathbf{u}_i = \\begin{bmatrix} \\mathbf{h}_i \\\\ \\mathbf{m}_i \\end{bmatrix} \\in \\mathbb{R}^{4}$.\n  - Linear update: $\\mathbf{q}_i = \\mathbf{W}_u \\mathbf{u}_i + \\mathbf{b}_u$, where\n    $$\\mathbf{W}_u = \\begin{bmatrix} 0.50 & 0.10 & 0.20 & -0.30 \\\\ -0.40 & 0.25 & 0.10 & 0.15 \\end{bmatrix}, \\quad \\mathbf{b}_u = \\begin{bmatrix} 0.00 \\\\ 0.10 \\end{bmatrix}.$$\n  - Nonlinear updated features: $\\mathbf{h}_i' = \\phi(\\mathbf{q}_i)$ with $\\phi = \\tanh$ elementwise.\n- Atomwise energy readout and pooling:\n  - Readout weights and bias: $\\mathbf{v} = \\begin{bmatrix} 1.50 \\\\ -0.50 \\end{bmatrix}$ and $c = -0.20$.\n  - Atomwise energy: $e_i = \\mathbf{v}^\\top \\mathbf{h}_i' + c$ in electronvolts.\n  - Total energy: $E = \\sum_i e_i$ in electronvolts.\n\nConstraints:\n- Include all directed messages for $i \\neq j$ (no self-messages).\n- Use the provided parameters exactly.\n- Use hyperbolic tangent for all $\\tanh$ operations.\n- All distances must be computed in ångström and the total energy must be reported in electronvolts.\n\nRequired outputs for each test case:\n- A flattened list of all directed message components in the fixed order: iterate atoms $i$ by ascending index, and for each $i$ iterate senders $j$ by ascending index with $j \\neq i$; within each directed message vector, list components by ascending component index.\n- A flattened list of the updated features $\\mathbf{h}_i'$ by ascending atom index and ascending component index.\n- The scalar total energy $E$.\n- Round all floating-point outputs to $6$ decimal places.\n\nFinal output format:\n- Your program must produce a single line containing a JSON-like representation (without spaces) of a list of per-case results.\n- Each per-case result is a list of three elements: the flattened directed messages list, the flattened updated features list, and the scalar energy.\n- For example, a valid output line has the form: $[\\;[[m\\_1,\\dots],[h\\_1,\\dots],E\\_1],\\;[[m\\_2,\\dots],[h\\_2,\\dots],E\\_2]\\;]$ with all numbers rounded as specified.\n\nTest suite:\n- Case $1$ (linear triatomic): atoms $\\left[ Z_1, Z_2, Z_3 \\right] = \\left[ 1, 6, 8 \\right]$, positions in ångström\n  $$\\mathbf{r}_1 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}, \\quad \\mathbf{r}_2 = \\begin{bmatrix} 1.10 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}, \\quad \\mathbf{r}_3 = \\begin{bmatrix} 2.30 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}.$$\n- Case $2$ (diatomic hydrogen): atoms $\\left[ Z_1, Z_2 \\right] = \\left[ 1, 1 \\right]$, positions\n  $$\\mathbf{r}_1 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}, \\quad \\mathbf{r}_2 = \\begin{bmatrix} 0.74 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}.$$\n- Case $3$ (single oxygen): atoms $\\left[ Z_1 \\right] = \\left[ 8 \\right]$, position\n  $$\\mathbf{r}_1 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}.$$\n\nAngle units are not involved. Energies must be expressed in electronvolts. Your program should produce a single line of output containing the results as a JSON-like list with no spaces, where each element corresponds to one test case in the order listed above, and each test case is represented by a list containing: the flattened directed messages, the flattened updated features, and the scalar total energy, all rounded to $6$ decimal places.", "solution": "The problem statement is valid. It presents a well-defined, self-contained computational task based on established principles in computational chemistry, specifically the construction of a neural network potential energy surface. All necessary parameters, initial conditions, and mathematical operations are specified unambiguously. The task is to implement a single forward pass of a simple message-passing neural network for three given molecular systems.\n\nThe solution is developed by methodically implementing the prescribed sequence of operations for each test case. The overall process for a given system of $N$ atoms is as follows:\n1.  Initialize the hidden feature vector $\\mathbf{h}_i \\in \\mathbb{R}^{d_h}$ for each atom $i$ based on its atomic number $Z_i$.\n2.  Compute all directed messages $\\mathbf{m}_{i \\leftarrow j}$ for $i, j \\in \\{1,\\dots,N\\}$, $i \\neq j$.\n3.  Aggregate incoming messages for each atom $i$ to obtain $\\mathbf{m}_i$.\n4.  Update the hidden feature vector of each atom from $\\mathbf{h}_i$ to $\\mathbf{h}_i'$.\n5.  Read out the atomic energy contribution $e_i$ from each updated feature vector $\\mathbf{h}_i'$.\n6.  Sum the atomic energies to obtain the total potential energy $E = \\sum_i e_i$.\n\nThe provided parameters are:\n- Hidden feature dimension: $d_h = 2$.\n- Initial embeddings: $\\mathbf{h}_{\\mathrm{H}} = \\begin{bmatrix} 0.40 \\\\ -0.10 \\end{bmatrix}$, $\\mathbf{h}_{\\mathrm{C}} = \\begin{bmatrix} 0.00 \\\\ 0.50 \\end{bmatrix}$, $\\mathbf{h}_{\\mathrm{O}} = \\begin{bmatrix} 0.80 \\\\ 0.20 \\end{bmatrix}$.\n- Message linear layer: $\\mathbf{W}_m = \\begin{bmatrix} 0.60 & -0.20 \\\\ 0.15 & 0.30 \\end{bmatrix}$, $\\mathbf{b}_m = \\begin{bmatrix} 0.05 \\\\ -0.05 \\end{bmatrix}$.\n- Update linear layer: $\\mathbf{W}_u = \\begin{bmatrix} 0.50 & 0.10 & 0.20 & -0.30 \\\\ -0.40 & 0.25 & 0.10 & 0.15 \\end{bmatrix}$, $\\mathbf{b}_u = \\begin{bmatrix} 0.00 \\\\ 0.10 \\end{bmatrix}$.\n- Energy readout: $\\mathbf{v} = \\begin{bmatrix} 1.50 \\\\ -0.50 \\end{bmatrix}$, $c = -0.20$.\n- Radial filter: $\\mu = 1.00$ Å, $\\sigma = 0.50$ Å.\n- Nonlinearity: $\\phi(x) = \\tanh(x)$.\n\nThe computation proceeds with the following detailed steps.\n\n**Step 1: Message Generation**\nFor each ordered pair of distinct atoms $(i, j)$, a directed message $\\mathbf{m}_{i \\leftarrow j}$ is computed. This message depends on the sending atom's feature vector $\\mathbf{h}_j$ and the distance between the atoms $r_{ij}$.\n\nFirst, a \"base\" message $\\tilde{\\mathbf{m}}_j$ is created from the sender's current features $\\mathbf{h}_j$. This involves a linear transformation followed by an elementwise hyperbolic tangent nonlinearity, $\\phi(\\cdot) = \\tanh(\\cdot)$.\n$$\n\\mathbf{z}_{j} = \\mathbf{W}_m \\mathbf{h}_j + \\mathbf{b}_m\n$$\n$$\n\\tilde{\\mathbf{m}}_{j} = \\phi(\\mathbf{z}_{j})\n$$\nThis base message is then modulated by a radial filter function $f(r_{ij})$ which depends on the interatomic distance $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$. The filter is a Gaussian function centered at $\\mu$ with standard deviation $\\sigma$.\n$$\nf(r_{ij}) = \\exp\\!\\left(-\\frac{(r_{ij} - \\mu)^2}{2 \\sigma^2}\\right)\n$$\nThe final directed message from atom $j$ to atom $i$ is the product of the filter value and the base message.\n$$\n\\mathbf{m}_{i \\leftarrow j} = f(r_{ij}) \\cdot \\tilde{\\mathbf{m}}_{j}\n$$\nAll computed directed messages $\\mathbf{m}_{i \\leftarrow j}$ are collected and flattened into a list as specified by the output format.\n\n**Step 2: Message Aggregation**\nFor each atom $i$, the incoming messages from all other atoms $j$ are summed to form a single aggregated message vector $\\mathbf{m}_i \\in \\mathbb{R}^{d_h}$.\n$$\n\\mathbf{m}_i = \\sum_{j \\neq i} \\mathbf{m}_{i \\leftarrow j}\n$$\nIf an atom has no neighbors (e.g., a single-atom system), this sum is empty and evaluates to the zero vector, $\\mathbf{m}_i = \\mathbf{0}$.\n\n**Step 3: Feature Update**\nThe hidden feature vector $\\mathbf{h}_i$ of each atom is updated to $\\mathbf{h}_i'$ using its current features and the aggregated message $\\mathbf{m}_i$. First, $\\mathbf{h}_i$ and $\\mathbf{m}_i$ are concatenated to form a vector $\\mathbf{u}_i \\in \\mathbb{R}^{2 d_h}$.\n$$\n\\mathbf{u}_i = \\begin{bmatrix} \\mathbf{h}_i \\\\ \\mathbf{m}_i \\end{bmatrix}\n$$\nThis concatenated vector is then passed through another linear transformation and elementwise nonlinearity to produce the updated feature vector $\\mathbf{h}_i'$.\n$$\n\\mathbf{q}_i = \\mathbf{W}_u \\mathbf{u}_i + \\mathbf{b}_u\n$$\n$$\n\\mathbf{h}_i' = \\phi(\\mathbf{q}_i)\n$$\nThe components of all updated feature vectors $\\mathbf{h}_i'$ are collected and flattened into a second list.\n\n**Step 4: Energy Readout and Pooling**\nThe final step is to compute the total potential energy $E$. This is done by first assigning a scalar energy contribution $e_i$ to each atom based on its updated feature vector $\\mathbf{h}_i'$. A linear readout maps $\\mathbf{h}_i'$ to $e_i$.\n$$\ne_i = \\mathbf{v}^\\top \\mathbf{h}_i' + c\n$$\nThe total potential energy of the system is the sum of all atomic energy contributions.\n$$\nE = \\sum_i e_i\n$$\nThe total energy $E$ is the final output value for the given atomic configuration.\n\nThese steps are executed for each of the three test cases provided. For the single-atom case (Case 3), the message generation and aggregation steps result in zero messages, and the update is based solely on the initial atomic features, which is a correct and consistent outcome of the defined model. All numerical results are rounded to $6$ decimal places before being formatted into the final output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single forward pass of a message-passing neural network for potential energy.\n    \"\"\"\n    # Define model parameters\n    params = {\n        'h_dim': 2,\n        'embeddings': {\n            1: np.array([0.40, -0.10]),  # Hydrogen (Z=1)\n            6: np.array([0.00, 0.50]),  # Carbon (Z=6)\n            8: np.array([0.80, 0.20]),  # Oxygen (Z=8)\n        },\n        'W_m': np.array([[0.60, -0.20], [0.15, 0.30]]),\n        'b_m': np.array([0.05, -0.05]),\n        'mu': 1.00,\n        'sigma': 0.50,\n        'W_u': np.array([[0.50, 0.10, 0.20, -0.30], [-0.40, 0.25, 0.10, 0.15]]),\n        'b_u': np.array([0.00, 0.10]),\n        'v': np.array([1.50, -0.50]),\n        'c': -0.20,\n    }\n\n    # Define test cases\n    test_cases = [\n        {\n            'Z': [1, 6, 8],\n            'R': np.array([\n                [0.00, 0.00, 0.00],\n                [1.10, 0.00, 0.00],\n                [2.30, 0.00, 0.00]\n            ])\n        },\n        {\n            'Z': [1, 1],\n            'R': np.array([\n                [0.00, 0.00, 0.00],\n                [0.74, 0.00, 0.00]\n            ])\n        },\n        {\n            'Z': [8],\n            'R': np.array([\n                [0.00, 0.00, 0.00]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Zs = case['Z']\n        Rs = case['R']\n        num_atoms = len(Zs)\n\n        # 1. Initialize features\n        h_initial = np.array([params['embeddings'][Z] for Z in Zs])\n\n        # 2. Message Generation and Aggregation\n        all_messages_flat = []\n        aggregated_messages = np.zeros_like(h_initial)\n        \n        # Pre-compute base messages for all atoms\n        base_messages = {}\n        for j in range(num_atoms):\n            z_j = params['W_m'] @ h_initial[j] + params['b_m']\n            m_tilde_j = np.tanh(z_j)\n            base_messages[j] = m_tilde_j\n\n        for i in range(num_atoms):\n            for j in range(num_atoms):\n                if i == j:\n                    continue\n                \n                # Distance\n                r_ij = np.linalg.norm(Rs[i] - Rs[j])\n                \n                # Radial filter\n                f_r = np.exp(-((r_ij - params['mu'])**2) / (2 * params['sigma']**2))\n\n                # Directed message\n                m_i_j = f_r * base_messages[j]\n                \n                # Collect for output\n                all_messages_flat.extend(m_i_j.tolist())\n\n                # Aggregate\n                aggregated_messages[i] += m_i_j\n\n        # 3. Feature Update\n        h_updated = np.zeros_like(h_initial)\n        all_updated_features_flat = []\n        \n        for i in range(num_atoms):\n            u_i = np.concatenate([h_initial[i], aggregated_messages[i]])\n            q_i = params['W_u'] @ u_i + params['b_u']\n            h_prime_i = np.tanh(q_i)\n            h_updated[i] = h_prime_i\n            all_updated_features_flat.extend(h_prime_i.tolist())\n\n        # 4. Energy Readout\n        total_energy = 0.0\n        if num_atoms > 0:\n            atomic_energies = h_updated @ params['v'] + params['c']\n            total_energy = np.sum(atomic_energies)\n\n        results.append([all_messages_flat, all_updated_features_flat, total_energy])\n\n    # Format output as specified\n    def format_case(case_result):\n        msg_list_str = f\"[{','.join([f'{m:.6f}' for m in case_result[0]])}]\"\n        feat_list_str = f\"[{','.join([f'{h:.6f}' for h in case_result[1]])}]\"\n        energy_str = f'{case_result[2]:.6f}'\n        return f\"[{msg_list_str},{feat_list_str},{energy_str}]\"\n    \n    all_cases_str = [format_case(case) for case in results]\n    final_output = f\"[{','.join(all_cases_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2908437"}]}