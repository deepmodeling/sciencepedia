{"hands_on_practices": [{"introduction": "Accurate modeling of electrostatic interactions, particularly polarization, is essential for describing condensed-phase environments. However, simple linear-response models lead to an unphysical divergence known as the polarization catastrophe at short intermolecular distances. This practice ([@problem_id:2881216]) introduces a physically-motivated solution using Thole-type damping to regularize the induction energy, providing a crucial tool for building robust polarizable force fields.", "problem": "You are asked to reason from first principles about the classical polarization catastrophe in induced-dipole models near strongly charged ions and to implement a physically motivated damping to prevent divergence. Work in atomic units, where the unit of energy is the Hartree, the unit of length is the Bohr, and the elementary charge is unity. Consider a single, isotropic, polarizable site with polarizability $\\alpha$ at a fixed distance $r$ from a fixed point charge $q$. The local electric field magnitude due to the ion at the polarizable site in atomic units is $|\\mathcal{E}| = |q|/r^2$. The induced dipole moment satisfies the linear response relation $\\boldsymbol{\\mu} = \\alpha \\,\\boldsymbol{\\mathcal{E}}$, and the induction energy is the classical work of polarizing in a linear medium, $U_{\\mathrm{ind}} = -\\tfrac{1}{2}\\,\\boldsymbol{\\mu}\\cdot \\boldsymbol{\\mathcal{E}}$. For a point ion, this diverges as $r \\to 0$, a phenomenon known as the polarization catastrophe.\n\nTo regularize the field near the ion and represent charge penetration at short range, impose a damping function $f_{\\mathrm{damp}}(r; a, \\rho)$ that satisfies $f_{\\mathrm{damp}}(0)=0$, $f_{\\mathrm{damp}}(\\infty)=1$, and is monotonically increasing. Adopt the Thole-type functional form\n$f_{\\mathrm{damp}}(r; a, \\rho) = 1 - \\exp\\!\\left(-a \\left(\\dfrac{r}{\\rho}\\right)^3\\right)$\nwith a shape parameter $a>0$ and a polarizability-dependent length scale $\\rho = \\gamma\\,\\alpha^{1/3}$, where $\\gamma>0$ is a dimensionless parameter. The damped local field magnitude is then $|\\mathcal{E}_{\\mathrm{d}}| = f_{\\mathrm{damp}}(r; a, \\rho)\\,|\\mathcal{E}|$, and the corresponding induction energy is $U_{\\mathrm{ind}}^{\\mathrm{(d)}} = -\\tfrac{1}{2}\\,\\alpha\\,|\\mathcal{E}_{\\mathrm{d}}|^2$.\n\nYour task is to implement a program that, for a set of specified test cases, computes for each case both the undamped induction energy $U_{\\mathrm{ind}}$ and the damped induction energy $U_{\\mathrm{ind}}^{\\mathrm{(d)}}$ using the fundamental relations above. All quantities are to be expressed in atomic units. The program must not accept any input and must produce a single line of output containing a comma-separated flat list with the undamped energy followed by the damped energy for each test in the order provided below. Each value must be rounded to exactly eight decimal places. The final output must therefore be a single line in the exact format\n$[u_1^{\\mathrm{(und)}},u_1^{\\mathrm{(d)}},u_2^{\\mathrm{(und)}},u_2^{\\mathrm{(d)}},\\dots]$.\n\nUse the following test suite, which covers a near-catastrophic short-range case, moderate distances and charges, sign inversion of $q$ (which should not affect the magnitude of the energies), and a far-field limit where damping should be negligible:\n\n- Test $1$: $(q,\\alpha,r,a,\\gamma) = (\\,{+2},\\,{10},\\,{0.5},\\,{0.39},\\,{1.0}\\,)$.\n- Test $2$: $(q,\\alpha,r,a,\\gamma) = (\\,{+1},\\,{10},\\,{2.0},\\,{0.39},\\,{1.0}\\,)$.\n- Test $3$: $(q,\\alpha,r,a,\\gamma) = (\\,{+3},\\,{20},\\,{1.0},\\,{0.39},\\,{1.2}\\,)$.\n- Test $4$: $(q,\\alpha,r,a,\\gamma) = (\\,{-1},\\,{5},\\,{4.0},\\,{0.39},\\,{1.0}\\,)$.\n- Test $5$: $(q,\\alpha,r,a,\\gamma) = (\\,{+1},\\,{10},\\,{10.0},\\,{0.39},\\,{1.0}\\,)$.\n\nImplementation requirements:\n\n- Start from the fundamental definitions $\\boldsymbol{\\mu} = \\alpha \\boldsymbol{\\mathcal{E}}$ and $U_{\\mathrm{ind}} = -\\tfrac{1}{2}\\,\\boldsymbol{\\mu}\\cdot \\boldsymbol{\\mathcal{E}}$, with $|\\mathcal{E}| = |q|/r^2$.\n- Apply the damping via $f_{\\mathrm{damp}}(r; a, \\rho) = 1 - \\exp\\!\\left(-a \\left(\\dfrac{r}{\\rho}\\right)^3\\right)$ with $\\rho = \\gamma\\,\\alpha^{1/3}$ to obtain the damped field magnitude $|\\mathcal{E}_{\\mathrm{d}}|$ and damped energy $U_{\\mathrm{ind}}^{\\mathrm{(d)}}$.\n- For each test, compute two floats: the undamped $U_{\\mathrm{ind}}$ and the damped $U_{\\mathrm{ind}}^{\\mathrm{(d)}}$, both in Hartree, and round to exactly eight decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,\\dots]$) with no additional text.\n\nNote: Angles do not appear in this problem. All answers must be expressed in Hartree (atomic units of energy), rounded to eight decimal places as specified.", "solution": "The problem statement is first subjected to a rigorous validation procedure.\n\n**Step 1: Extract Givens**\nThe following information is provided verbatim or as direct mathematical definitions:\n-   A system consists of a point charge $q$ and an isotropic polarizable site with polarizability $\\alpha$, separated by a fixed distance $r$. All quantities are in atomic units.\n-   The magnitude of the electric field created by the charge at the polarizable site is $|\\mathcal{E}| = |q|/r^2$.\n-   The induced dipole moment follows the linear response relation $\\boldsymbol{\\mu} = \\alpha \\,\\boldsymbol{\\mathcal{E}}$.\n-   The undamped induction energy is defined as $U_{\\mathrm{ind}} = -\\tfrac{1}{2}\\,\\boldsymbol{\\mu}\\cdot \\boldsymbol{\\mathcal{E}}$.\n-   A Thole-type damping function is introduced: $f_{\\mathrm{damp}}(r; a, \\rho) = 1 - \\exp\\!\\left(-a \\left(\\dfrac{r}{\\rho}\\right)^3\\right)$, with a shape parameter $a>0$.\n-   The damping function depends on a polarizability-dependent length scale $\\rho = \\gamma\\,\\alpha^{1/3}$, where $\\gamma>0$ is a dimensionless parameter.\n-   The damped local electric field magnitude is given by $|\\mathcal{E}_{\\mathrm{d}}| = f_{\\mathrm{damp}}(r; a, \\rho)\\,|\\mathcal{E}|$.\n-   The damped induction energy is $U_{\\mathrm{ind}}^{\\mathrm{(d)}} = -\\tfrac{1}{2}\\,\\alpha\\,|\\mathcal{E}_{\\mathrm{d}}|^2$.\n-   The following five test cases are specified for the tuple $(q, \\alpha, r, a, \\gamma)$:\n    1.  $(\\,{+2},\\,{10},\\,{0.5},\\,{0.39},\\,{1.0}\\,)$\n    2.  $(\\,{+1},\\,{10},\\,{2.0},\\,{0.39},\\,{1.0}\\,)$\n    3.  $(\\,{+3},\\,{20},\\,{1.0},\\,{0.39},\\,{1.2}\\,)$\n    4.  $(\\,{-1},\\,{5},\\,{4.0},\\,{0.39},\\,{1.0}\\,)$\n    5.  $(\\,{+1},\\,{10},\\,{10.0},\\,{0.39},\\,{1.0}\\,)$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the required criteria:\n-   **Scientifically Grounded**: The problem addresses the classical polarization catastrophe, a well-known artifact in molecular mechanics force fields, and its resolution via Thole-style damping. This is a standard and physically motivated concept in the field of condensed-phase modeling. The physical and mathematical principles are entirely sound.\n-   **Well-Posed**: All necessary formulae, variables, and constants are explicitly provided. The functional forms are defined for the given parameter domains. For each set of input parameters, a unique numerical solution exists.\n-   **Objective**: The problem is stated using precise, unambiguous mathematical language. It is free from subjective or non-scientific content.\n-   **Completeness and Consistency**: The problem is self-contained. It presents no internal contradictions and provides all data required for the solution.\n-   **Feasibility**: The requested calculations are computationally straightforward and the parameters are within a reasonable range for a theoretical model.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It represents a standard, well-defined computational exercise in theoretical chemistry. A solution based on the provided first principles will be constructed.\n\nThe solution proceeds by first principles. The system under consideration involves a point charge $q$ generating an electric field $\\boldsymbol{\\mathcal{E}}$ at a distance $r$. The magnitude of this field is given by Coulomb's law in atomic units:\n$$\n|\\boldsymbol{\\mathcal{E}}| = \\frac{|q|}{r^2}\n$$\nIn this field, a particle with isotropic polarizability $\\alpha$ acquires an induced dipole moment $\\boldsymbol{\\mu} = \\alpha\\boldsymbol{\\mathcal{E}}$. The energy of induction, $U_{\\mathrm{ind}}$, is the work done in polarizing the particle, given by:\n$$\nU_{\\mathrm{ind}} = -\\frac{1}{2} \\boldsymbol{\\mu} \\cdot \\boldsymbol{\\mathcal{E}} = -\\frac{1}{2} (\\alpha\\boldsymbol{\\mathcal{E}}) \\cdot \\boldsymbol{\\mathcal{E}} = -\\frac{1}{2} \\alpha |\\boldsymbol{\\mathcal{E}}|^2\n$$\nSubstituting the expression for the field magnitude yields the formula for the undamped induction energy:\n$$\nU_{\\mathrm{ind}} = -\\frac{1}{2} \\alpha \\left( \\frac{|q|}{r^2} \\right)^2 = -\\frac{\\alpha q^2}{2r^4}\n$$\nThis expression exhibits a non-physical divergence as $r \\to 0$, known as the polarization catastrophe.\n\nTo rectify this, the electric field is regularized at short range using a damping function, which models the finite size of the interacting charge distributions. The damped field magnitude, $|\\mathcal{E}_{\\mathrm{d}}|$, is defined as:\n$$\n|\\mathcal{E}_{\\mathrm{d}}| = f_{\\mathrm{damp}}(r; a, \\rho) |\\boldsymbol{\\mathcal{E}}|\n$$\nThe specified Thole-type damping function is:\n$$\nf_{\\mathrm{damp}}(r; a, \\rho) = 1 - \\exp\\left(-a \\left(\\frac{r}{\\rho}\\right)^3\\right)\n$$\nThis function depends on a shape parameter $a$ and a characteristic length scale $\\rho$, which is linked to the volume of the polarizable particle via $\\rho = \\gamma\\alpha^{1/3}$ for some dimensionless constant $\\gamma$. The function correctly satisfies the physical limits: $f_{\\mathrm{damp}} \\to 0$ as $r \\to 0$ (full screening), and $f_{\\mathrm{damp}} \\to 1$ as $r \\to \\infty$ (no screening).\n\nThe damped induction energy, $U_{\\mathrm{ind}}^{\\mathrm{(d)}}$, is computed using the same fundamental relation but with the damped field:\n$$\nU_{\\mathrm{ind}}^{\\mathrm{(d)}} = -\\frac{1}{2} \\alpha |\\mathcal{E}_{\\mathrm{d}}|^2 = -\\frac{1}{2} \\alpha \\left( f_{\\mathrm{damp}}(r; a, \\rho) |\\boldsymbol{\\mathcal{E}}| \\right)^2\n$$\nBy inspection, the relationship between the damped and undamped energies is:\n$$\nU_{\\mathrm{ind}}^{\\mathrm{(d)}} = \\left( f_{\\mathrm{damp}}(r; a, \\rho) \\right)^2 U_{\\mathrm{ind}}\n$$\nThis formulation is computationally efficient. The procedure for each test case is to first calculate $U_{\\mathrm{ind}}$, then calculate the damping factor $f_{\\mathrm{damp}}$, and finally obtain $U_{\\mathrm{ind}}^{\\mathrm{(d)}}$.\n\nThe computational steps for a given set of parameters $(q, \\alpha, r, a, \\gamma)$ are:\n1.  Compute the squared magnitude of the undamped electric field: $|\\boldsymbol{\\mathcal{E}}|^2 = (q/r^2)^2$.\n2.  Compute the undamped energy: $U_{\\mathrm{ind}} = -0.5 \\times \\alpha \\times |\\boldsymbol{\\mathcal{E}}|^2$.\n3.  Compute the length scale: $\\rho = \\gamma \\times \\alpha^{1/3}$.\n4.  Compute the damping factor: $f_{\\mathrm{damp}} = 1 - \\exp(-a \\times (r/\\rho)^3)$.\n5.  Compute the damped energy: $U_{\\mathrm{ind}}^{\\mathrm{(d)}} = U_{\\mathrm{ind}} \\times (f_{\\mathrm{damp}})^2$.\n6.  Format both energy values to eight decimal places.\nThis procedure is applied to all specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes undamped and damped induction energies for several test cases\n    based on a classical model with Thole-type damping.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (q, alpha, r, a, gamma) in atomic units.\n    test_cases = [\n        (2.0, 10.0, 0.5, 0.39, 1.0),\n        (1.0, 10.0, 2.0, 0.39, 1.0),\n        (3.0, 20.0, 1.0, 0.39, 1.2),\n        (-1.0, 5.0, 4.0, 0.39, 1.0),\n        (1.0, 10.0, 10.0, 0.39, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        q, alpha, r, a, gamma = case\n\n        # 1. Undamped calculation\n        # Electric field magnitude: |E| = |q|/r^2\n        # Undamped induction energy: U_ind = -1/2 * alpha * |E|^2\n        E_mag_sq = (abs(q) / r**2)**2\n        U_ind_undamped = -0.5 * alpha * E_mag_sq\n\n        # 2. Damped calculation\n        # Length scale: rho = gamma * alpha^(1/3)\n        rho = gamma * np.power(alpha, 1.0/3.0)\n\n        # Damping function: f_damp = 1 - exp(-a * (r/rho)^3)\n        # We must handle the case where rho can be zero to avoid division by zero,\n        # although with the given constraints (alpha > 0), rho will not be zero.\n        if rho == 0:\n            # If rho is 0 and r > 0, r/rho is infinite, exp -> 0, f_damp -> 1.\n            # If rho is 0 and r = 0, the expression is indeterminate but physically\n            # the fields should be zero, so we can define f_damp as 0.\n            # For non-polarizable site (alpha=0), rho=0, U=0.\n            f_damp = 1.0 if r > 0 else 0.0\n        else:\n            u = r / rho\n            f_damp = 1.0 - np.exp(-a * np.power(u, 3.0))\n\n        # Damped induction energy: U_ind_d = -1/2 * alpha * (f_damp * |E|)^2\n        # This can be simplified to U_ind_d = (f_damp)^2 * U_ind\n        U_ind_damped = U_ind_undamped * (f_damp**2)\n\n        # 3. Append formatted results to the list\n        # The problem requires rounding to exactly eight decimal places,\n        # which is best achieved with string formatting.\n        results.append(f\"{U_ind_undamped:.8f}\")\n        results.append(f\"{U_ind_damped:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2881216"}, {"introduction": "Beyond electrostatics, London dispersion forces are critical for the structure and energetics of condensed matter, yet their long-range nature presents a challenge for finite simulations. This practice explores the calculation of the total dispersion contribution to the enthalpy of a liquid, starting from a physically-grounded damped potential. By implementing and testing the effect of spherical cutoffs and analytical long-range corrections, you will gain direct insight into the numerical methods required for accurate energy calculations in large-scale simulations ([@problem_id:2881241]).", "problem": "You will write a complete program to compute the dispersion contribution to the molar enthalpy of liquid water under ambient conditions by modeling the liquid as a homogeneous, isotropic fluid with pairwise-additive dispersion interactions. You will use a selected dispersion correction model and analyze the sensitivity of the result to spherical cutoff schemes and to the inclusion of a long-range tail correction. The final numerical answers for each test case must be expressed in kilojoules per mole, rounded to three decimal places.\n\nThe physical model is defined as follows. Consider an isotropic fluid of number density $\\rho_{\\mathrm{N}}$ and a pairwise-additive, spherically symmetric dispersion potential $u(r)$. The configurational (dispersion) contribution to the potential energy per particle is\n$$\n\\bar{u} \\;=\\; 2\\pi\\,\\rho_{\\mathrm{N}} \\int_{0}^{\\infty} g(r)\\,u(r)\\,r^2\\,dr,\n$$\nwhere $g(r)$ is the radial distribution function. To isolate and model the dispersion contribution, approximate $g(r)$ by a hard-core step function\n$$\ng(r) \\;=\\; \\Theta\\!\\big(r - r_{\\mathrm{hc}}\\big),\n$$\nwith a hard-core distance $r_{\\mathrm{hc}}$. The dispersion potential is taken to be a damped $C_6$ term using the Tang–Toennies damping function of order $6$:\n$$\nu(r) \\;=\\; -\\,s_6\\,\\frac{C_6}{r^6}\\,F_6\\!\\big(b\\,r\\big),\n\\quad\\text{with}\\quad\nF_6(x) \\;=\\; 1 - e^{-x}\\sum_{k=0}^{6}\\frac{x^k}{k!}.\n$$\nIn practical simulations, a spherical cutoff at $r_c$ is often used. Under a spherical cutoff without shifting, the finite-range estimate is\n$$\n\\bar{u}(r_c;\\,\\text{no-tail}) \\;=\\; 2\\pi\\,\\rho_{\\mathrm{N}} \\int_{r_{\\min}}^{r_c} g(r)\\,u(r)\\,r^2\\,dr,\n\\quad r_{\\min} \\equiv r_{\\mathrm{hc}}.\n$$\nA common long-range tail correction assumes $g(r)\\approx 1$ and $F_6(br)\\approx 1$ for $r\\ge r_c$, yielding the analytical tail\n$$\n\\Delta\\bar{u}_{\\mathrm{tail}}(r_c) \\;=\\; 2\\pi\\,\\rho_{\\mathrm{N}} \\int_{r_c}^{\\infty} \\left(-\\,s_6\\,\\frac{C_6}{r^6}\\right)\\,r^2\\,dr\n\\;=\\; -\\,\\frac{2\\pi}{3}\\,\\rho_{\\mathrm{N}}\\,s_6\\,\\frac{C_6}{r_c^3}.\n$$\nWhen the tail correction is included, the corrected estimate is\n$$\n\\bar{u}(r_c;\\,\\text{with-tail}) \\;=\\; \\bar{u}(r_c;\\,\\text{no-tail}) \\;+\\; \\Delta\\bar{u}_{\\mathrm{tail}}(r_c).\n$$\nAdopt the standard approximation that, for condensed liquids under ambient conditions, the dispersion contribution to the molar enthalpy is well approximated by the configurational (dispersion) contribution to the molar internal energy. Therefore report\n$$\nH_{\\mathrm{disp}} \\;\\approx\\; U_{\\mathrm{disp,\\,molar}} \\;=\\; N_{\\mathrm{A}}\\,\\bar{u},\n$$\nwhere $N_{\\mathrm{A}}$ is Avogadro’s number. Express $U_{\\mathrm{disp,\\,molar}}$ in $\\mathrm{kJ\\,mol^{-1}}$.\n\nUse the following physically reasonable parameters:\n- Liquid water mass density at ambient conditions: $\\rho_{\\mathrm{m}} = 997\\ \\mathrm{kg\\,m^{-3}}$.\n- Molar mass of water: $M = 18.01528\\times 10^{-3}\\ \\mathrm{kg\\,mol^{-1}}$.\n- Avogadro’s number: $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\ \\mathrm{mol^{-1}}$.\n- Number density: $\\rho_{\\mathrm{N}} = \\rho_{\\mathrm{m}}\\,N_{\\mathrm{A}}/M$ in $\\mathrm{m^{-3}}$.\n- Dispersion coefficient in atomic units: $C_6^{\\mathrm{(au)}} = 45.0$, where $1\\ \\text{atomic unit of}\\ C_6 = E_{\\mathrm{h}}\\,a_0^6$, with Hartree energy $E_{\\mathrm{h}} = 4.3597447222071\\times 10^{-18}\\ \\mathrm{J}$ and Bohr radius $a_0 = 0.529177210903\\times 10^{-10}\\ \\mathrm{m}$. Convert $C_6$ to $\\mathrm{J\\,m^6}$.\n- Damping parameter: $b = 3.0\\ \\mathrm{\\AA^{-1}}$ converted to $\\mathrm{m^{-1}}$.\n- Hard-core distance: $r_{\\mathrm{hc}} = 2.7\\ \\mathrm{\\AA}$ converted to $\\mathrm{m}$.\n- Scaling factor: $s_6 = 1.0$.\n\nAngle units are not applicable. All final energies must be expressed in $\\mathrm{kJ\\,mol^{-1}}$, rounded to three decimal places.\n\nTest suite. For each test case, compute $H_{\\mathrm{disp}}$ using the above model, with the specified spherical cutoff $r_c$ and whether to include the long-range tail correction. Use numerical quadrature for the finite-range integral and the analytical expression for the tail when requested. The six test cases are:\n1. $r_c = 0.27\\ \\mathrm{nm}$, no tail correction.\n2. $r_c = 0.27\\ \\mathrm{nm}$, with tail correction.\n3. $r_c = 0.80\\ \\mathrm{nm}$, no tail correction.\n4. $r_c = 0.80\\ \\mathrm{nm}$, with tail correction.\n5. $r_c = 1.50\\ \\mathrm{nm}$, no tail correction.\n6. $r_c = 1.50\\ \\mathrm{nm}$, with tail correction.\n\nAlgorithmic requirements:\n- Use the integral definition for $\\bar{u}$ with $g(r)=\\Theta(r-r_{\\mathrm{hc}})$ and the specified $u(r)$.\n- For each test case, evaluate the finite-range integral from $r_{\\min}=\\max(0, r_{\\mathrm{hc}})$ to $r_c$. If $r_c \\le r_{\\mathrm{hc}}$, the finite-range integral is zero by construction.\n- If a tail correction is requested, add $\\Delta\\bar{u}_{\\mathrm{tail}}(r_c)$ as given above.\n- Convert to $\\mathrm{kJ\\,mol^{-1}}$ by multiplying by $N_{\\mathrm{A}}$ and dividing by $1000$.\n\nYour program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, for example, \"[x1,x2,x3,x4,x5,x6]\". Each entry must be rounded to three decimal places in $\\mathrm{kJ\\,mol^{-1}}$ and include the sign as appropriate. No other text should be printed.", "solution": "We model the dispersion contribution to the molar enthalpy via the configurational energy of a homogeneous, isotropic liquid with pairwise-additive interactions. The foundational statistical mechanical relation for the potential energy per particle in a uniform fluid is\n$$\n\\bar{u} \\;=\\; 2\\pi\\,\\rho_{\\mathrm{N}} \\int_{0}^{\\infty} g(r)\\,u(r)\\,r^2\\,dr,\n$$\nwhere $\\rho_{\\mathrm{N}}$ is the number density, $g(r)$ is the radial distribution function, and $u(r)$ is the pair potential. To isolate the dispersion physics while maintaining computational tractability, we adopt the step-function approximation\n$$\ng(r)=\\Theta(r-r_{\\mathrm{hc}}),\n$$\nwhich enforces an excluded volume of radius $r_{\\mathrm{hc}}$ and $g(r)\\approx 1$ beyond that. This is a standard approximation for long-range contributions in liquids.\n\nFor the dispersion model, we use a damped $C_6$ potential with Tang–Toennies damping of order $6$,\n$$\nu(r)=-s_6\\,\\frac{C_6}{r^6}\\,F_6(b r),\n\\quad\nF_6(x)=1-e^{-x}\\sum_{k=0}^{6}\\frac{x^k}{k!},\n$$\nwhich regularizes the short-range divergence of the $r^{-6}$ term by enforcing the correct short-range limiting behavior from overlap of electronic densities. The parameters are: the scaling factor $s_6$, the dispersion coefficient $C_6$ in $\\mathrm{J\\,m^6}$, and the damping parameter $b$ in $\\mathrm{m^{-1}}$.\n\nIn practical simulations a spherical cutoff $r_c$ is applied. The finite-range estimator without tail is\n$$\n\\bar{u}(r_c;\\,\\text{no-tail})=2\\pi\\,\\rho_{\\mathrm{N}}\\int_{r_{\\min}}^{r_c} g(r)\\,u(r)\\,r^2\\,dr,\n\\quad\nr_{\\min}=r_{\\mathrm{hc}}.\n$$\nIf $r_c\\le r_{\\mathrm{hc}}$, then $\\int_{r_{\\mathrm{hc}}}^{r_c}=0$ by the step-function $g(r)$. A standard long-range correction assumes that beyond the cutoff $g(r)\\approx 1$ and the damping is negligible, $F_6(br)\\approx 1$ for $r\\ge r_c$. Under these assumptions, the tail integral becomes analytically tractable:\n$$\n\\Delta\\bar{u}_{\\mathrm{tail}}(r_c)\n=2\\pi\\,\\rho_{\\mathrm{N}}\\int_{r_c}^{\\infty}\\left(-s_6\\frac{C_6}{r^6}\\right)r^2\\,dr\n=-\\frac{2\\pi}{3}\\,\\rho_{\\mathrm{N}}\\,s_6\\,\\frac{C_6}{r_c^3}.\n$$\nThe corrected estimate is\n$$\n\\bar{u}(r_c;\\,\\text{with-tail})=\\bar{u}(r_c;\\,\\text{no-tail})+\\Delta\\bar{u}_{\\mathrm{tail}}(r_c).\n$$\n\nThe dispersion contribution to the molar enthalpy at ambient conditions is approximated by the corresponding molar configurational energy contribution,\n$$\nH_{\\mathrm{disp}}\\approx U_{\\mathrm{disp,\\,molar}}=N_{\\mathrm{A}}\\bar{u}.\n$$\nThis neglects the comparatively small $pV$ contribution and any temperature derivatives specific to dispersion, which is a standard approximation for condensed-phase liquids under ambient conditions.\n\nUnits and constants:\n- The number density is computed from the mass density and molar mass,\n$$\n\\rho_{\\mathrm{N}}=\\frac{\\rho_{\\mathrm{m}}\\,N_{\\mathrm{A}}}{M},\n$$\nwith $\\rho_{\\mathrm{m}}=997\\ \\mathrm{kg\\,m^{-3}}$, $M=18.01528\\times 10^{-3}\\ \\mathrm{kg\\,mol^{-1}}$, and $N_{\\mathrm{A}}=6.02214076\\times 10^{23}\\ \\mathrm{mol^{-1}}$.\n- The dispersion coefficient is converted from atomic units,\n$$\nC_6 = C_6^{(\\mathrm{au})}\\times E_{\\mathrm{h}}\\,a_0^6,\n$$\nwith $C_6^{(\\mathrm{au})}=45.0$, $E_{\\mathrm{h}}=4.3597447222071\\times 10^{-18}\\ \\mathrm{J}$, and $a_0=0.529177210903\\times 10^{-10}\\ \\mathrm{m}$.\n- The damping parameter is $b=3.0\\ \\mathrm{\\AA^{-1}}=3.0\\times 10^{10}\\ \\mathrm{m^{-1}}$.\n- The hard-core distance is $r_{\\mathrm{hc}}=2.7\\ \\mathrm{\\AA}=2.7\\times 10^{-10}\\ \\mathrm{m}$.\n- The scaling factor is $s_6=1.0$.\n\nNumerical plan:\n- Define $F_6(x)$ via its series to evaluate the damping.\n- Define $u(r)$ from the above formula.\n- Define the integrand for $\\bar{u}$ as $2\\pi\\,\\rho_{\\mathrm{N}}\\,g(r)\\,u(r)\\,r^2$, with $g(r)=\\Theta(r-r_{\\mathrm{hc}})$.\n- For each cutoff $r_c$, compute the finite integral from $r_{\\min}=r_{\\mathrm{hc}}$ to $r_c$ using numerical quadrature. If $r_c\\le r_{\\mathrm{hc}}$, the finite integral is zero.\n- If the tail is requested, add $\\Delta\\bar{u}_{\\mathrm{tail}}(r_c)$ using the analytical expression above.\n- Convert $\\bar{u}$ to $\\mathrm{kJ\\,mol^{-1}}$ by multiplying by $N_{\\mathrm{A}}$ and dividing by $1000$.\n- Round each result to three decimal places and print as a list.\n\nSensitivity analysis is encoded by the test suite:\n- Very short cutoff $r_c=0.27\\ \\mathrm{nm}$ tests the boundary where the finite integral vanishes due to $g(r)$ but the tail can contribute.\n- Moderate cutoff $r_c=0.80\\ \\mathrm{nm}$ examines the impact of truncation error and the effect of tail correction.\n- Large cutoff $r_c=1.50\\ \\mathrm{nm}$ reduces the truncation error and tests whether the tail correction becomes small.\nIn all cases, the tail correction assumes $g(r)\\approx 1$ and negligible damping beyond $r_c$, which increasingly holds at larger $r_c$. The results are reported as $[H_1,H_2,H_3,H_4,H_5,H_6]$ in $\\mathrm{kJ\\,mol^{-1}}$, rounded to three decimals.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    # Physical constants and parameters\n    NA = 6.02214076e23  # mol^-1\n    rho_mass = 997.0  # kg m^-3\n    M = 18.01528e-3  # kg mol^-1\n    rho_N = rho_mass * NA / M  # number density, m^-3\n\n    # Atomic unit conversion for C6: 1 a.u. = Eh * a0^6\n    Eh = 4.3597447222071e-18  # J\n    a0 = 0.529177210903e-10  # m\n    C6_au = 45.0  # atomic units\n    C6_SI = C6_au * Eh * (a0 ** 6)  # J m^6\n\n    # Damping and structural parameters\n    b = 3.0e10  # m^-1  (3.0 Å^-1)\n    r_hc = 2.7e-10  # m (2.7 Å)\n    s6 = 1.0\n\n    # Tang-Toennies damping function of order 6\n    def F6(x):\n        # F6(x) = 1 - exp(-x) * sum_{k=0}^6 x^k/k!\n        # Evaluate the finite series explicitly\n        poly = 0.0\n        term = 1.0\n        # Compute sum_{k=0}^6 x^k/k! iteratively\n        for k in range(0, 7):\n            if k > 0:\n                term *= x / k\n            poly += term\n        return 1.0 - np.exp(-x) * poly\n\n    # Pair potential u(r) with damping\n    def u_disp(r):\n        # - s6 * C6 / r^6 * F6(b r)\n        return -s6 * C6_SI * F6(b * r) / (r ** 6)\n\n    # Integrand for per-particle energy: 2π ρ_N g(r) u(r) r^2 with g(r)=Theta(r-r_hc)\n    def integrand(r):\n        if r < r_hc:\n            return 0.0\n        return 2.0 * np.pi * rho_N * u_disp(r) * (r ** 2)\n\n    # Tail correction assuming g(r)=1 and F6(br)=1 beyond rc\n    def tail_correction(rc):\n        # Δu = - (2π/3) ρ_N s6 C6 / rc^3\n        return -(2.0 * np.pi / 3.0) * rho_N * s6 * C6_SI / (rc ** 3)\n\n    # Test cases: (rc in meters, include_tail boolean)\n    test_cases = [\n        (0.27e-9, False),\n        (0.27e-9, True),\n        (0.80e-9, False),\n        (0.80e-9, True),\n        (1.50e-9, False),\n        (1.50e-9, True),\n    ]\n\n    results = []\n    # Numerical integration settings\n    # Tight tolerances to ensure stable kJ/mol precision\n    epsabs = 1e-13\n    epsrel = 1e-9\n\n    for rc, include_tail in test_cases:\n        # Finite integral from r_hc to rc (if rc > r_hc)\n        if rc > r_hc:\n            finite_val, _ = quad(integrand, r_hc, rc, epsabs=epsabs, epsrel=epsrel, limit=400)\n        else:\n            finite_val = 0.0\n\n        ubar = finite_val\n        if include_tail and rc > 0.0:\n            ubar += tail_correction(rc)\n\n        # Convert per-particle energy to kJ/mol\n        H_disp_kJmol = ubar * NA / 1000.0\n        # Round to three decimals in output representation\n        results.append(H_disp_kJmol)\n\n    # Final print statement in the exact required format, rounded to three decimals\n    formatted = \"[\" + \",\".join(f\"{x:.3f}\" for x in results) + \"]\"\n    print(formatted)\n\nsolve()\n```", "id": "2881241"}, {"introduction": "A primary goal of condensed-phase modeling is to map the free energy landscape of chemical processes, but rare events like barrier crossings are inaccessible to standard simulations. This exercise tackles this challenge by having you derive and implement the self-consistent multi-histogram method, often known as WHAM, from first principles ([@problem_id:2881243]). By combining biased data from umbrella sampling simulations, you will reconstruct an unbiased potential of mean force and learn to assess the quality of the underlying data, a crucial skill for any advanced simulation study.", "problem": "You are tasked with deriving and implementing a numerical method to compute a potential of mean force along a one-dimensional reaction coordinate using umbrella sampling and a self-consistent multi-histogram approach grounded in statistical mechanics. The target is to reconstruct an unbiased free-energy profile from biased histograms without using any pre-stated shortcut formulas. You must start from first principles and core definitions only.\n\nAssume a system at constant temperature in the canonical ensemble. Let the reaction coordinate be denoted by $z$. The unbiased equilibrium marginal probability density along $z$ is $p(z)$, and the potential of mean force $W(z)$ is defined by $W(z) = -\\beta^{-1} \\ln p(z) + \\text{constant}$, where $\\beta = (R T)^{-1}$, $T$ is the absolute temperature in Kelvin, and $R$ is the molar gas constant in $\\mathrm{kJ}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$. The system is sampled under a set of harmonic umbrella biases indexed by $i$, each of the form $U_i(z) = \\tfrac{1}{2} k_i \\left(z - z_{0,i}\\right)^2$, where $k_i$ is the force constant and $z_{0,i}$ is the umbrella center. For each bias, you have an independent histogram of counts over a uniform grid of bins along $z$. You must derive, from the canonical ensemble and definitions, a self-consistent method to estimate $W(z)$ from these histograms, ensuring you explicitly isolate the unknown bias-dependent free-energy offsets that arise as Lagrange multipliers of normalization constraints. You may assume that within each umbrella, the sampling is equilibrated and sufficiently representative of its biased stationary distribution, and that bins are narrow enough for Riemann-sum approximations to hold.\n\nYour program must implement:\n- A solver based on the self-consistent multi-histogram approach to recover $p(z)$ and hence $W(z)$ from the biased histograms and the known umbrella potentials, using only the canonical ensemble definition and the relation between biased and unbiased distributions as your starting point. Do not use any pre-provided closed-form \"shortcut\" equations; instead, derive them within your solution and translate them into a stable numerical algorithm.\n- A normalization convention for $W(z)$ such that $\\min_z W(z) = 0$.\n- An assessment of neighboring-window overlap quality based on a quantitative measure computed from the histograms. Specifically, for each adjacent pair of umbrellas $(i,i+1)$, compute a similarity coefficient between their normalized histograms over the common binning, and report the minimum across all adjacent pairs for the test case. Use this as an indicator of whether the window overlap is adequate for reliable reconstruction.\n- A simple adequacy decision rule: return an indicator equal to $1$ if the minimum adjacent-window overlap coefficient exceeds a threshold, and $0$ otherwise.\n\nUnits and numerical constants:\n- Positions $z$ are in $\\mathrm{nm}$.\n- Force constants $k_i$ are in $\\mathrm{kJ}\\, \\mathrm{mol}^{-1}\\, \\mathrm{nm}^{-2}$.\n- Temperature $T$ is in $\\mathrm{K}$.\n- Return free-energy values $W(z)$ in $\\mathrm{kJ}\\, \\mathrm{mol}^{-1}$.\n- Use the molar gas constant $R = 0.00831446261815324\\ \\mathrm{kJ}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$ so that $\\beta = 1/(R T)$ has units $\\mathrm{mol}\\, \\mathrm{kJ}^{-1}$.\n- All angles, if any were to arise, must be in radians. No angles are used here.\n- Express the final requested numerical outputs with floats rounded to three decimals where required, and integers where required.\n\nAssessment of window overlap:\n- For each window $i$, define a normalized discrete distribution over bins $p_i(z_j) = \\left(n_i(z_j) + \\varepsilon\\right) / \\sum_{j} \\left(n_i(z_j) + \\varepsilon\\right)$ using a small pseudo-count $\\varepsilon = 10^{-12}$ to avoid division by zero. For each adjacent pair $(i,i+1)$, compute the Bhattacharyya coefficient $C_{i,i+1} = \\sum_j \\sqrt{p_i(z_j)\\, p_{i+1}(z_j)}$. The minimum coefficient across adjacent pairs is your overlap quality metric. Use the threshold $C_\\mathrm{min}^\\star = 0.05$ for the adequacy decision: if $\\min C_{i,i+1} > C_\\mathrm{min}^\\star$, return $1$, else $0$.\n\nTest suite:\nImplement your solver and apply it to the following three test cases. For each case, you must construct the histograms deterministically from the specified umbrella parameters to ensure reproducibility, by assuming that the underlying unbiased potential of mean force is flat on the provided grid and that the observed biased histogram in umbrella $i$ is proportional to the corresponding biased stationary distribution restricted to the grid. Specifically, for each umbrella $i$, define the unnormalized bin weights $w_i(z_j) = \\exp\\!\\left(-\\beta\\, U_i(z_j)\\right)$ at bin centers $z_j$, normalize to probabilities $\\pi_i(z_j) = w_i(z_j) / \\sum_j w_i(z_j)$, and then convert to integer counts $n_i(z_j)$ whose total exactly equals the specified $N_i$ by rounding with a largest-remainder rule that preserves $\\sum_j n_i(z_j) = N_i$. This construction produces the input histograms for the solver. Note: this histogram construction rule is part of the test-data generation and must not be used to short-circuit the derivation of the solver.\n\nFor each test case, report a triple consisting of:\n- The endpoint free-energy difference $\\Delta W = W(z_{\\text{last}}) - W(z_{\\text{first}})$ in $\\mathrm{kJ}\\, \\mathrm{mol}^{-1}$, rounded to three decimals.\n- The minimum adjacent-window Bhattacharyya coefficient, rounded to three decimals.\n- The adequacy indicator as an integer ($1$ or $0$).\n\nYour program should produce a single line of output containing the nine results from the three test cases in order, as a comma-separated list enclosed in square brackets, i.e., $[\\Delta W_1, C_1, \\mathrm{Adeq}_1, \\Delta W_2, C_2, \\mathrm{Adeq}_2, \\Delta W_3, C_3, \\mathrm{Adeq}_3]$.\n\nUse the following test cases. In each case: construct a uniform bin grid by $z_{\\min}$, $z_{\\max}$, and $\\Delta z$, with edges $z_{\\min}, z_{\\min} + \\Delta z, \\ldots, z_{\\max}$ inclusive, and use bin centers at the midpoints of consecutive edges. All three cases use $T = 300$.\n\n- Case A (happy path, broad coverage and good overlap):\n  - $z_{\\min} = -0.60$, $z_{\\max} = +0.60$, $\\Delta z = 0.06$.\n  - Umbrella centers $\\{z_{0,i}\\}$: $(-0.40,\\ -0.20,\\ 0.00,\\ +0.20,\\ +0.40)$.\n  - Force constants $\\{k_i\\}$: $(100,\\ 100,\\ 100,\\ 100,\\ 100)$.\n  - Total counts $\\{N_i\\}$: $(8000,\\ 8000,\\ 8000,\\ 8000,\\ 8000)$.\n\n- Case B (heterogeneous stiffness and counts, still adequate overlap):\n  - $z_{\\min} = -0.50$, $z_{\\max} = +0.50$, $\\Delta z = 0.05$.\n  - Umbrella centers $\\{z_{0,i}\\}$: $(-0.40,\\ -0.10,\\ 0.00,\\ +0.10,\\ +0.40)$.\n  - Force constants $\\{k_i\\}$: $(80,\\ 120,\\ 200,\\ 120,\\ 80)$.\n  - Total counts $\\{N_i\\}$: $(2000,\\ 7000,\\ 15000,\\ 7000,\\ 2000)$.\n\n- Case C (edge case with poor overlap):\n  - $z_{\\min} = -0.60$, $z_{\\max} = +0.60$, $\\Delta z = 0.06$.\n  - Umbrella centers $\\{z_{0,i}\\}$: $(-0.50,\\ 0.00,\\ +0.50)$.\n  - Force constants $\\{k_i\\}$: $(500,\\ 500,\\ 500)$.\n  - Total counts $\\{N_i\\}$: $(6000,\\ 6000,\\ 6000)$.\n\nAssumptions to state clearly in your solution:\n- Each umbrella histogram is generated from an equilibrated segment representative of the biased canonical distribution with the stated $U_i(z)$ at temperature $T$.\n- Autocorrelations and time correlations are neglected in the construction of the histograms (you do not have time series here).\n- The Riemann-sum discretization over the provided bins is sufficiently fine to approximate integrals needed for normalization.\n- Overlap adequacy is assessed by the minimum Bhattacharyya coefficient as specified.\n\nFinal output format:\n- Your program should produce one single line: a list with nine comma-separated numbers enclosed in square brackets, corresponding to the three triples from Cases A, B, and C in that order, i.e., $[\\Delta W_A, C_A, \\mathrm{Adeq}_A, \\Delta W_B, C_B, \\mathrm{Adeq}_B, \\Delta W_C, C_C, \\mathrm{Adeq}_C]$, with the two floating-point values in each triple rounded to three decimals and the adequacy indicator as an integer. Units for $\\Delta W$ must be in $\\mathrm{kJ}\\, \\mathrm{mol}^{-1}$.", "solution": "The problem is valid. It concerns the derivation and implementation of the self-consistent multi-histogram method, a cornerstone of statistical mechanics for free energy calculations, commonly known as the Weighted Histogram Analysis Method (WHAM). The problem is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. We proceed with the derivation and solution.\n\nAssumptions stated for clarity:\n1.  The system is in the canonical ensemble at a constant temperature $T$.\n2.  Each histogram of counts, $n_i(z_j)$, is derived from a simulation that has reached equilibrium under the biased potential $V(z,q') + U_i(z)$ and is a representative sample of that biased ensemble.\n3.  The binning along the reaction coordinate $z$ is sufficiently fine for discrete sums to approximate integrals accurately (Riemann-sum approximation).\n4.  The adequacy of overlap between adjacent simulation windows is quantitatively assessed by the minimum Bhattacharyya coefficient, as defined in the problem statement.\n\nDerivation of the Self-Consistent Equations\n\nOur goal is to determine the unbiased potential of mean force (PMF), $W(z)$, which is related to the unbiased probability density, $p(z)$, along a reaction coordinate $z$. At constant temperature $T$, this relationship is given by:\n$$\nW(z) = -\\beta^{-1} \\ln p(z) + C\n$$\nwhere $\\beta = (R T)^{-1}$ and $C$ is an arbitrary constant. The probability density $p(z)$ is the marginal probability of finding the system at coordinate $z$.\n\nIn umbrella sampling, a set of $K$ simulations are performed, each biased by a potential $U_i(z)$ for $i=1, \\dots, K$. The biased probability density in simulation $i$, $p_i^{\\text{bias}}(z)$, is related to the unbiased density $p(z)$ as follows:\n$$\np_i^{\\text{bias}}(z) = \\frac{p(z) e^{-\\beta U_i(z)}}{\\int p(z') e^{-\\beta U_i(z')} dz'}\n$$\nThe denominator is a normalization constant that ensures $\\int p_i^{\\text{bias}}(z) dz = 1$.\n\nLet us define a set of free energy offsets, $f_i$, corresponding to the free energy cost of applying the bias $U_i(z)$ to the unbiased system:\n$$\ne^{-\\beta f_i} = \\int p(z) e^{-\\beta U_i(z)} dz\n$$\nThese $f_i$ are the unknown bias-dependent free-energy offsets mentioned in the problem description, which arise formally as Lagrange multipliers associated with the normalization constraint of each biased distribution. With this definition, the biased probability density becomes:\n$$\np_i^{\\text{bias}}(z) = p(z) e^{-\\beta U_i(z)} e^{\\beta f_i}\n$$\nThis fundamental equation relates the (known) biased density to the (unknown) unbiased density and the (unknown) free energy offsets.\n\nThe experimental data consist of histograms, which are discrete counts. We consider a grid of $M$ bins along $z$, with bin centers denoted by $z_j$ for $j=1, \\dots, M$. Let $p_j$ be the discrete, unbiased probability of the system being in bin $j$. Let $n_{ij}$ be the number of samples from simulation $i$ that fall into bin $j$, and let $N_i = \\sum_j n_{ij}$ be the total number of samples in simulation $i$.\n\nThe number of counts $n_{ij}$ is a statistical estimator of the expected number of counts, which is $N_i$ times the probability of being in bin $j$ in simulation $i$. In the discrete representation, this probability is $p_{ij}^{\\text{bias}}$. Thus, we have the statistical relationship:\n$$\nn_{ij} \\approx N_i p_{ij}^{\\text{bias}}\n$$\nUsing our previously derived relationship, we discretize it for bin $j$:\n$$\np_{ij}^{\\text{bias}} = p_j e^{-\\beta U_{ij}} e^{\\beta f_i}\n$$\nwhere $U_{ij} = U_i(z_j)$. The discrete version of the equation for $f_i$ is:\n$$\ne^{-\\beta f_i} = \\sum_{j=1}^{M} p_j e^{-\\beta U_{ij}} \\quad \\quad (1)\n$$\nCombining these, we get an expression for the observed counts:\n$$\nn_{ij} \\approx N_i p_j e^{-\\beta U_{ij}} e^{\\beta f_i}\n$$\nThis equation is not useful for solving for $p_j$ directly, as it holds for each simulation $i$ separately. The key insight of the multi-histogram method is to combine information from all simulations. The total number of counts observed in bin $j$ across all simulations is $n_j = \\sum_{i=1}^{K} n_{ij}$. Summing the previous expression over all simulations $i$:\n$$\nn_j = \\sum_{i=1}^{K} n_{ij} \\approx \\sum_{i=1}^{K} N_i p_j e^{-\\beta U_{ij}} e^{\\beta f_i} = p_j \\left( \\sum_{i=1}^{K} N_i e^{\\beta (f_i - U_{ij})} \\right)\n$$\nThis allows us to express the unknown unbiased probability $p_j$ in terms of the total histogram counts $n_j$ and the unknown free energies $f_i$:\n$$\np_j \\propto \\frac{\\sum_{i=1}^{K} n_{ij}}{\\sum_{i=1}^{K} N_i e^{\\beta (f_i - U_{ij})}}\n$$\nAfter enforcing the normalization condition $\\sum_{j=1}^{M} p_j = 1$, we arrive at the final expression for $p_j$:\n$$\np_j = \\frac{\\sum_{i=1}^{K} n_{ij}}{\\sum_{i=1}^{K} N_i e^{\\beta (f_i - U_{ij})}} \\bigg/ \\left( \\sum_{k=1}^{M} \\frac{\\sum_{i=1}^{K} n_{ik}}{\\sum_{i=1}^{K} N_i e^{\\beta (f_i - U_{ik})}} \\right) \\quad \\quad (2)\n$$\nEquations (1) and (2) form a coupled, self-consistent set. They must be solved iteratively for the unknowns $\\{p_j\\}$ and $\\{f_i\\}$.\n\nAlgorithmic Implementation\n\nThe self-consistent field (SCF) algorithm proceeds as follows:\n1.  **Initialization**: Provide an initial guess for the free energies $\\{f_i\\}$, for example, $f_i = 0$ for all $i=1, \\dots, K$.\n2.  **Iteration**: Repeat the following steps until convergence is achieved.\n    a.  **Compute Probabilities**: Calculate the unnormalized probabilities $p_j^{\\text{unnorm}}$ for all bins $j=1, \\dots, M$ using the current estimates of $\\{f_i\\}$:\n        $$\n        p_j^{\\text{unnorm}} = \\frac{\\sum_{i=1}^{K} n_{ij}}{\\sum_{i=1}^{K} N_i e^{\\beta (f_i - U_{ij})}}\n        $$\n        Handle cases where the numerator is zero by setting $p_j^{\\text{unnorm}} = 0$.\n    b.  **Normalize Probabilities**: Normalize the probability distribution: $p_j = p_j^{\\text{unnorm}} / \\sum_{k=1}^{M} p_k^{\\text{unnorm}}$.\n    c.  **Update Free Energies**: Compute new estimates for $\\{f_i\\}$ using the updated probabilities $\\{p_j\\}$ via Equation (1):\n        $$\n        f_i^{\\text{new}} = -\\beta^{-1} \\ln \\left( \\sum_{j=1}^{M} p_j e^{-\\beta U_{ij}} \\right)\n        $$\n    d.  **Check Convergence**: The iteration has converged if the maximum change in any $f_i$ is below a small tolerance $\\delta$, i.e., $\\max_i |f_i^{\\text{new}} - f_i| < \\delta$. If not converged, set $f_i \\leftarrow f_i^{\\text{new}}$ and continue to the next iteration.\n\nOnce the SCF procedure has converged, the final probabilities $\\{p_j\\}$ are used to compute the PMF, $W_j = W(z_j)$:\n$$\nW_j = -\\beta^{-1} \\ln p_j\n$$\nFor bins where $p_j = 0$, $W_j$ is formally infinite. The PMF is then normalized by shifting it so its minimum value is zero:\n$$\nW_j^{\\text{norm}} = W_j - \\min_{k: p_k>0} (W_k)\n$$\nFinally, we compute the required outputs: the endpoint free energy difference $\\Delta W = W_{M}^{\\text{norm}} - W_{1}^{\\text{norm}}$, the minimum adjacent-window Bhattacharyya coefficient $C_{\\min}$, and the adequacy indicator. For the test cases, the input histograms are generated deterministically as specified, mimicking a scenario where the true underlying PMF is flat, which should result in a reconstructed PMF that is approximately zero everywhere after normalization, leading to $\\Delta W \\approx 0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    R = 0.00831446261815324  # kJ mol^-1 K^-1\n    T = 300.0  # K\n    BETA = 1.0 / (R * T)\n    OVERLAP_THRESHOLD = 0.05\n    PSEUDO_COUNT = 1e-12\n\n    # Test case definitions\n    test_cases = [\n        {\n            \"z_min\": -0.60, \"z_max\": 0.60, \"dz\": 0.06,\n            \"z0_i\": [-0.40, -0.20, 0.00, 0.20, 0.40],\n            \"k_i\": [100.0, 100.0, 100.0, 100.0, 100.0],\n            \"N_i\": [8000, 8000, 8000, 8000, 8000],\n        },\n        {\n            \"z_min\": -0.50, \"z_max\": 0.50, \"dz\": 0.05,\n            \"z0_i\": [-0.40, -0.10, 0.00, 0.10, 0.40],\n            \"k_i\": [80.0, 120.0, 200.0, 120.0, 80.0],\n            \"N_i\": [2000, 7000, 15000, 7000, 2000],\n        },\n        {\n            \"z_min\": -0.60, \"z_max\": 0.60, \"dz\": 0.06,\n            \"z0_i\": [-0.50, 0.00, 0.50],\n            \"k_i\": [500.0, 500.0, 500.0],\n            \"N_i\": [6000, 6000, 6000],\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_case(params, BETA, OVERLAP_THRESHOLD, PSEUDO_COUNT)\n        all_results.extend(result)\n\n    print(f\"[{','.join(f'{x:.3f}' if isinstance(x, float) else str(x) for x in all_results)}]\")\n\ndef largest_remainder_rounding(values, total_sum):\n    \"\"\"\n    Distributes a total integer sum across a list of floats using the largest remainder method.\n    \"\"\"\n    int_parts = np.floor(values).astype(int)\n    remainders = values - int_parts\n    n_remainder = total_sum - np.sum(int_parts)\n    \n    if n_remainder < 0:\n        # This case is unlikely if 'values' are from a normalized distribution\n        return int_parts\n    \n    indices_to_increment = np.argsort(remainders)[-n_remainder:]\n    int_parts[indices_to_increment] += 1\n    \n    return int_parts\n\ndef generate_histograms(bin_centers, params, beta):\n    \"\"\"Generates deterministic histograms for a test case.\"\"\"\n    num_windows = len(params[\"k_i\"])\n    num_bins = len(bin_centers)\n    histograms = np.zeros((num_windows, num_bins), dtype=int)\n    bias_potentials = np.zeros((num_windows, num_bins))\n\n    for i in range(num_windows):\n        k = params[\"k_i\"][i]\n        z0 = params[\"z0_i\"][i]\n        N = params[\"N_i\"][i]\n        \n        # Calculate bias potentials U_i(z_j)\n        U_ij = 0.5 * k * (bin_centers - z0)**2\n        bias_potentials[i, :] = U_ij\n        \n        # Calculate biased probabilities assuming a flat underlying PMF\n        weights = np.exp(-beta * U_ij)\n        probs = weights / np.sum(weights)\n        \n        # Convert probabilities to ideal counts\n        ideal_counts = N * probs\n        \n        # Get integer counts using largest remainder method\n        histograms[i, :] = largest_remainder_rounding(ideal_counts, N)\n        \n    return histograms, bias_potentials\n\ndef wham_solver(histograms, bias_potentials, N_i, beta, tol=1e-10, max_iter=10000):\n    \"\"\"\n    Solves the self-consistent multi-histogram equations.\n    \"\"\"\n    num_windows, num_bins = histograms.shape\n    \n    # Initial guess for free energy offsets\n    f_i = np.zeros(num_windows)\n    \n    # Total counts per bin\n    n_j = np.sum(histograms, axis=0)\n    \n    for iteration in range(max_iter):\n        f_i_old = np.copy(f_i)\n        \n        # Equation 2: Calculate probabilities p_j\n        exp_term = np.exp(beta * (f_i[:, np.newaxis] - bias_potentials))\n        denominator = np.sum(N_i[:, np.newaxis] * exp_term, axis=0)\n        \n        # Handle bins with no samples and where denominator could be zero\n        p_j_unnorm = np.zeros(num_bins)\n        non_zero_denom = denominator > 0\n        p_j_unnorm[non_zero_denom] = n_j[non_zero_denom] / denominator[non_zero_denom]\n        \n        # Normalize probabilities\n        p_j_sum = np.sum(p_j_unnorm)\n        p_j = p_j_unnorm / p_j_sum if p_j_sum > 0 else np.zeros(num_bins)\n        \n        # Equation 1: Update free energies f_i\n        exp_U = np.exp(-beta * bias_potentials)\n        sum_term = np.sum(p_j[np.newaxis, :] * exp_U, axis=1)\n        \n        # Handle cases where sum_term can be zero for a window\n        non_zero_sum = sum_term > 0\n        f_i[non_zero_sum] = -1.0/beta * np.log(sum_term[non_zero_sum])\n        f_i[~non_zero_sum] = np.inf # Should not happen with real data\n\n        # Check for convergence\n        if np.max(np.abs(f_i - f_i_old)) < tol:\n            break\n            \n    return p_j\n\ndef run_case(params, beta, overlap_threshold, pseudo_count):\n    \"\"\"\n    Runs a single test case: generates data, solves, computes metrics.\n    \"\"\"\n    # 1. Setup grid\n    # Bins are defined by edges, we need bin centers\n    num_bins = int(round((params[\"z_max\"] - params[\"z_min\"]) / params[\"dz\"]))\n    bin_edges = np.linspace(params[\"z_min\"], params[\"z_max\"], num_bins + 1)\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n    \n    # 2. Generate histograms deterministically\n    histograms, bias_potentials = generate_histograms(bin_centers, params, beta)\n    N_i = np.array(params[\"N_i\"])\n    \n    # 3. Solve for unbiased probabilities using the self-consistent method\n    p_j = wham_solver(histograms, bias_potentials, N_i, beta)\n\n    # 4. Calculate PMF W(z)\n    W = np.full_like(p_j, np.inf)\n    has_prob = p_j > 0\n    W[has_prob] = -1.0/beta * np.log(p_j[has_prob])\n    \n    # 5. Normalize PMF\n    min_W = np.min(W[np.isfinite(W)]) if np.any(np.isfinite(W)) else 0.0\n    W -= min_W\n    \n    # 6. Calculate endpoint free energy difference\n    delta_W = W[-1] - W[0] if len(W) > 0 else 0.0\n\n    # 7. Calculate overlap quality\n    num_windows = len(params[\"k_i\"])\n    adj_coeffs = []\n    if num_windows > 1:\n        for i in range(num_windows - 1):\n            h1 = histograms[i, :] + pseudo_count\n            h2 = histograms[i+1, :] + pseudo_count\n            \n            p1 = h1 / np.sum(h1)\n            p2 = h2 / np.sum(h2)\n            \n            b_coeff = np.sum(np.sqrt(p1 * p2))\n            adj_coeffs.append(b_coeff)\n            \n    min_overlap_coeff = min(adj_coeffs) if adj_coeffs else 0.0\n    \n    # 8. Adequacy decision\n    adequacy = 1 if min_overlap_coeff > overlap_threshold else 0\n    \n    return delta_W, min_overlap_coeff, adequacy\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2881243"}]}