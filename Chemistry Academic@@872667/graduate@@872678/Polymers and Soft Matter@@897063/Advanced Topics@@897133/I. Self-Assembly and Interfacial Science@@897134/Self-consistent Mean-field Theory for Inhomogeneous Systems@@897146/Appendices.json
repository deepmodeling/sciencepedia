{"hands_on_practices": [{"introduction": "The heart of any self-consistent field theory (SCFT) simulation is the numerical solution of the modified diffusion equation, which governs the statistical weight of polymer chains in the presence of mean fields. This exercise [@problem_id:2927261] provides hands-on practice in developing an efficient and accurate solver for this equation using a pseudo-spectral method combined with Strang splitting. Mastering this fundamental algorithm is the first critical step toward building a complete SCFT code and understanding its numerical properties.", "problem": "You are asked to design and implement a numerical solver for the modified diffusion equation that appears in self-consistent mean-field theory of polymer chains, and to quantify its accuracy as a function of the contour step. Consider the three-dimensional modified diffusion equation for the single-chain propagator $q(\\mathbf{r},s)$,\n$$\n\\partial_s q(\\mathbf{r},s) \\;=\\; D \\nabla^2 q(\\mathbf{r},s) \\;-\\; w(\\mathbf{r})\\, q(\\mathbf{r},s),\n$$\nwhere $D$ is a positive constant, $s$ is the contour variable, and $w(\\mathbf{r})$ is a prescribed, time-independent external field with periodic boundary conditions. The spatial domain is the cube $\\Omega = [0,L)^3$ with period $L$ in each coordinate. All quantities are nondimensional.\n\nFundamental starting points and core definitions:\n- The generator of diffusion is $D\\nabla^2$, with the Laplacian represented in Fourier space by $-D k^2$, where $k^2 = k_x^2 + k_y^2 + k_z^2$.\n- For periodic boundary conditions on a uniform grid, the Fast Fourier Transform (FFT) can be used to evaluate the action of the diffusion semigroup $\\exp(s D \\nabla^2)$ exactly in Fourier space as a diagonal multiplication by $\\exp(-s D k^2)$.\n- The potential term $-w(\\mathbf{r}) q$ acts as pointwise multiplication in real space.\n- A second-order symmetric operator splitting (Strang splitting) of the semigroup $\\exp\\{ \\Delta s\\,[D\\nabla^2 - w(\\mathbf{r})]\\}$ alternates half-steps of the potential in real space with full steps of diffusion in Fourier space.\n\nYour task is to:\n1) Discretize the contour variable $s$ on a uniform grid with step $\\Delta s$, apply second-order symmetric operator splitting to advance $q$ from $s$ to $s+\\Delta s$ on a three-dimensional periodic grid using FFTs for the diffusion operator, and implement this scheme in a program.\n2) For the test cases specified below, compute the numerical solution at total contour length $S$ and quantify the accuracy as a function of $\\Delta s$ using the $L^2$-norm over space.\n3) For the nontrivial inhomogeneous potential, estimate the observed order of accuracy by fitting a straight line to $\\log(\\text{error})$ as a function of $\\log(\\Delta s)$.\n\nSpatial discretization and Fourier representation:\n- Use a uniform grid with $N \\times N \\times N$ points, where $N$ is specified in the test suite. The spatial coordinates are $x_i = i\\, L/N$, $y_j = j\\, L/N$, $z_k = k\\, L/N$ for integers $i,j,k \\in \\{0,1,\\dots,N-1\\}$.\n- The Fourier wavenumbers are defined using the discrete frequencies under periodic boundary conditions. If $\\nu_\\alpha$ are the discrete frequencies returned by the discrete Fourier transform convention, then the angular wavenumbers are $k_\\alpha = 2\\pi \\nu_\\alpha$, and $k^2 = k_x^2 + k_y^2 + k_z^2$.\n\nError metric:\n- Given a reference field $q_{\\text{ref}}(\\mathbf{r})$ and an approximation $q_{\\Delta s}(\\mathbf{r})$, define the relative $L^2$ error as\n$$\nE(\\Delta s) \\;=\\; \\frac{\\left( \\int_\\Omega |q_{\\Delta s}(\\mathbf{r}) - q_{\\text{ref}}(\\mathbf{r})|^2 \\, d\\mathbf{r} \\right)^{1/2}}{\\left( \\int_\\Omega |q_{\\text{ref}}(\\mathbf{r})|^2 \\, d\\mathbf{r} \\right)^{1/2}},\n$$\nwhich on a uniform grid reduces to the square root of the average of squared differences divided by the square root of the average of squared reference values.\n\nTest suite:\nAdopt the fixed parameters $L = 2\\pi$, $N = 16$, $D = 1$, and total contour length $S = 1$. Consider the four contour steps $\\Delta s \\in \\{1/8,\\, 1/16,\\, 1/32,\\, 1/64\\}$ so that the number of steps is $S/\\Delta s \\in \\{8,\\,16,\\,32,\\,64\\}$. Use the following three tests:\n\n- Test $1$ (homogeneous, diffusion-only): $w(\\mathbf{r}) = 0$, initial condition $q(\\mathbf{r},0) = \\cos(x)\\cos(y)\\cos(z)$. The exact solution at $s=S$ equals the action of the diffusion semigroup on the initial condition. Use the spectral representation to compute the exact solution, and for each $\\Delta s$ compute the relative $L^2$ error $E(\\Delta s)$. Report the maximum over the four values of $\\Delta s$ as a single float.\n\n- Test $2$ (homogeneous potential that commutes with diffusion): $w(\\mathbf{r}) = w_0$ with $w_0 = 0.3$, initial condition $q(\\mathbf{r},0) = \\cos(x)\\cos(y)\\cos(z)$. The exact solution at $s=S$ equals $\\exp(-w_0 S)$ times the action of the diffusion semigroup on the initial condition. Compute the relative $L^2$ error $E(\\Delta s)$ for each $\\Delta s$ and report the maximum over the four values as a single float.\n\n- Test $3$ (inhomogeneous potential, reference-based accuracy study): $w(\\mathbf{r}) = A \\cos(x)\\cos(y)\\cos(z)$ with $A = 0.5$, and initial condition $q(\\mathbf{r},0) = 1$. For the reference, compute $q_{\\text{ref}}(\\mathbf{r})$ at $s=S$ using the same splitting method with a much smaller step $\\Delta s_{\\text{ref}} = 1/512$. For each $\\Delta s \\in \\{1/8,\\, 1/16,\\, 1/32,\\, 1/64\\}$, compute $E(\\Delta s)$ relative to $q_{\\text{ref}}$. Fit a straight line to the pairs $(\\log(\\Delta s), \\log(E(\\Delta s)))$ using least squares, and report the fitted slope as a single float. This slope estimates the observed order of accuracy.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{max\\_error\\_test1},\\, \\text{max\\_error\\_test2},\\, \\text{observed\\_order\\_test3}]$. For example, a valid output could look like $[a,b,c]$ where $a$, $b$, and $c$ are floats. No physical units are required because all quantities are nondimensional. Angles are in radians by construction of the domain $[0,2\\pi)^3$.", "solution": "The posed problem is a standard exercise in the numerical solution of partial differential equations common in statistical field theory, specifically the application of pseudo-spectral methods and operator splitting to the modified diffusion equation. The problem statement is scientifically sound, well-posed, and contains all necessary information for its resolution. I will proceed with a full solution.\n\nThe governing equation for the single-chain propagator $q(\\mathbf{r},s)$ is a linear partial differential equation of parabolic type:\n$$\n\\partial_s q(\\mathbf{r},s) \\;=\\; D \\nabla^2 q(\\mathbf{r},s) \\;-\\; w(\\mathbf{r})\\, q(\\mathbf{r},s)\n$$\nThis can be written in abstract operator form as $\\partial_s q = (\\mathcal{A} + \\mathcal{B})q$, where $\\mathcal{A} = D \\nabla^2$ is the diffusion operator and $\\mathcal{B} = -w(\\mathbf{r})$ is the potential operator. The formal solution over a contour step of length $\\Delta s$ is given by the action of the propagator, or semigroup, $q(s+\\Delta s) = \\exp\\{\\Delta s (\\mathcal{A} + \\mathcal{B})\\} q(s)$.\n\nThe operators $\\mathcal{A}$ and $\\mathcal{B}$ do not, in general, commute ($[\\mathcal{A}, \\mathcal{B}] \\neq 0$). Consequently, the exponential of their sum cannot be simply factorized. The problem requires the use of a second-order symmetric operator splitting, known as Strang splitting, to approximate the propagator:\n$$\n\\exp\\{\\Delta s (\\mathcal{A} + \\mathcal{B})\\} \\approx e^{\\frac{\\Delta s}{2}\\mathcal{B}} e^{\\Delta s\\mathcal{A}} e^{\\frac{\\Delta s}{2}\\mathcal{B}} + O(\\Delta s^3)\n$$\nThis splitting scheme provides a robust method to advance the solution in time by discretizing the contour variable $s$ into steps of size $\\Delta s$. The total solution at contour length $S$ is obtained by applying this split-step operator $M = S/\\Delta s$ times to the initial condition $q(\\mathbf{r},0)$.\n\nThe implementation of the split-step operators leverages their distinct properties in real and Fourier space. The spatial domain $\\Omega = [0,L)^3$ is discretized on a uniform grid of $N \\times N \\times N$ points.\n1.  **Potential Operator**: The operator $e^{\\frac{\\Delta s}{2}\\mathcal{B}} = \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r}))$ is a local operator in real space. Its action on the field $q(\\mathbf{r},s)$ is a simple pointwise multiplication.\n2.  **Diffusion Operator**: The operator $e^{\\Delta s\\mathcal{A}} = \\exp(\\Delta s D \\nabla^2)$ is non-local in real space but becomes diagonal in Fourier space. On a periodic domain, the Laplacian $\\nabla^2$ has eigenfunctions $e^{i\\mathbf{k}\\cdot\\mathbf{r}}$ with eigenvalues $-k^2$. The action of the diffusion operator is therefore computed efficiently using the Fast Fourier Transform (FFT). The procedure is as follows:\n    a. Transform the field $q(\\mathbf{r})$ to its Fourier representation $\\hat{q}(\\mathbf{k}) = \\mathcal{F}\\{q(\\mathbf{r})\\}$.\n    b. Multiply the Fourier coefficients by the diagonal diffusion kernel, $\\hat{q}_{\\text{diffused}}(\\mathbf{k}) = \\exp(-\\Delta s D k^2) \\hat{q}(\\mathbf{k})$. The squared wavevector magnitude is $k^2 = k_x^2 + k_y^2 + k_z^2$. The components $k_\\alpha$ are the discrete angular wavenumbers corresponding to the grid, given by $k_\\alpha = 2\\pi\\nu_\\alpha$, where $\\nu_\\alpha$ are the frequencies provided by the standard FFT algorithm for a domain of size $L$.\n    c. Transform the result back to real space: $q_{\\text{diffused}}(\\mathbf{r}) = \\mathcal{F}^{-1}\\{\\hat{q}_{\\text{diffused}}(\\mathbf{k})\\}$.\n\nThe complete algorithm for advancing the solution from $s=0$ to $s=S$ is:\nInitialize $q(\\mathbf{r}) = q(\\mathbf{r},0)$.\nFor $m=1, \\dots, M=S/\\Delta s$:\n1.  $q(\\mathbf{r}) \\leftarrow \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r})) q(\\mathbf{r})$\n2.  $\\hat{q}(\\mathbf{k}) \\leftarrow \\mathcal{F}\\{q(\\mathbf{r})\\}$\n3.  $\\hat{q}(\\mathbf{k}) \\leftarrow \\exp(-\\Delta s D k^2) \\hat{q}(\\mathbf{k})$\n4.  $q(\\mathbf{r}) \\leftarrow \\mathcal{F}^{-1}\\{\\hat{q}(\\mathbf{k})\\}$\n5.  $q(\\mathbf{r}) \\leftarrow \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r})) q(\\mathbf{r})$\nThe resulting field $q(\\mathbf{r})$ is the numerical approximation $q_{\\Delta s}(\\mathbf{r}, S)$.\n\nWe now analyze the specified test cases.\n\n**Test 1 (Homogeneous, $w(\\mathbf{r}) = 0$) and Test 2 (Homogeneous, $w(\\mathbf{r}) = w_0$)**:\nIn these two cases, the operator $\\mathcal{B}$ is a scalar multiplication ($-0$ and $-w_0$, respectively). A scalar operator commutes with any other operator, including the Laplacian $\\nabla^2$. Thus, $[\\mathcal{A}, \\mathcal{B}] = 0$. For commuting operators, the Strang splitting is not an approximation but an exact identity: $e^{\\frac{\\Delta s}{2}\\mathcal{B}} e^{\\Delta s\\mathcal{A}} e^{\\frac{\\Delta s}{2}\\mathcal{B}} = e^{\\Delta s\\mathcal{A}}e^{\\Delta s\\mathcal{B}} = e^{\\Delta s(\\mathcal{A}+\\mathcal{B})}$.\nThe numerical evolution over one step is therefore identical to the exact evolution. By induction, the numerical solution after $M$ steps, $(e^{\\Delta s(\\mathcal{A}+\\mathcal{B})})^M q_0 = e^{S(\\mathcal{A}+\\mathcal{B})}q_0$, is identical to the exact solution at $s=S$. The requested reference solutions are computed by applying the total propagator directly. Any deviation between the iterated numerical solution and the reference solution must arise solely from the accumulation of floating-point arithmetic errors. We expect this error to be on the order of machine precision. The maximum of these small errors over the four values of $\\Delta s$ is reported.\n\n**Test 3 (Inhomogeneous Potential)**:\nHere, the potential $w(\\mathbf{r}) = A \\cos(x)\\cos(y)\\cos(z)$ is spatially dependent, and the operators $\\mathcal{A}$ and $\\mathcal{B}$ do not commute. The Strang splitting method introduces a local truncation error of order $O(\\Delta s^3)$. Over the total interval $S$, the $M = S/\\Delta s$ steps accumulate to a global error of order $O(\\Delta s^2)$. The error is expected to scale as $E(\\Delta s) \\propto (\\Delta s)^p$, where $p=2$ is the theoretical order of accuracy.\nTo verify this, we take the logarithm: $\\log E(\\Delta s) = p \\log(\\Delta s) + \\text{const}$. The order $p$ can thus be estimated as the slope of a linear fit to the data points $(\\log(\\Delta s), \\log E(\\Delta s))$. The reference solution, against which the error is measured, is computed using the same numerical method but with a much smaller step, $\\Delta s_{\\text{ref}} = 1/512$, to ensure it is a sufficiently accurate proxy for the true solution. The slope is computed via a standard linear least-squares regression formula:\n$$\np = \\frac{n \\sum_{i=1}^n (x_i y_i) - (\\sum_{i=1}^n x_i)(\\sum_{i=1}^n y_i)}{n \\sum_{i=1}^n (x_i^2) - (\\sum_{i=1}^n x_i)^2}\n$$\nwhere $n=4$, $x_i = \\log(\\Delta s_i)$, and $y_i = \\log(E(\\Delta s_i))$. This slope is the reported result.\n\nThe code implements these procedures using the `numpy` library for array manipulations and FFTs. The error metric is computed as the relative $L^2$ norm, which for a uniform grid simplifies to $\\text{norm}(q_{\\Delta s} - q_{\\text{ref}}) / \\text{norm}(q_{\\text{ref}})$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef setup_grid(N, L):\n    \"\"\"\n    Sets up the spatial grid and the corresponding k-space grid.\n    \n    Args:\n        N (int): Number of grid points in each dimension.\n        L (float): Length of the periodic box.\n\n    Returns:\n        tuple: A tuple containing ((x, y, z), k_squared), where (x,y,z) are the \n               coordinate meshes and k_squared is the mesh of squared wavevector magnitudes.\n    \"\"\"\n    grid_1d = np.arange(N) * L / N\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # Wavevectors (k) corresponding to the grid (N points, L length)\n    # The sample spacing is d = L/N.\n    # np.fft.fftfreq(N, d=L/N) gives frequencies in cycles per unit of length.\n    # Angular wavenumbers are 2*pi times these frequencies.\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n\n    return (x, y, z), k_squared\n\ndef solve_diffusion_equation(q0, w, D, S, ds, k_squared):\n    \"\"\"\n    Solves the modified diffusion equation using Strang splitting.\n\n    Args:\n        q0 (np.ndarray): Initial condition for the field q.\n        w (np.ndarray): External potential field.\n        D (float): Diffusion constant.\n        S (float): Total contour length.\n        ds (float): Contour step size.\n        k_squared (np.ndarray): Squared wavevector magnitudes on the Fourier grid.\n\n    Returns:\n        np.ndarray: The field q at contour length S.\n    \"\"\"\n    num_steps = round(S / ds)\n    if not np.isclose(S / ds, num_steps):\n        raise ValueError(\"S must be an integer multiple of ds for this solver.\")\n    \n    q = q0.copy().astype(np.complex128)\n\n    # Pre-calculate operators for efficiency\n    exp_w_half_step = np.exp(-0.5 * ds * w)\n    diffusion_kernel = np.exp(-ds * D * k_squared)\n\n    for _ in range(num_steps):\n        # Strang splitting step\n        # 1. Half potential step\n        q *= exp_w_half_step\n        \n        # 2. Full diffusion step in Fourier space\n        q_hat = np.fft.fftn(q)\n        q_hat *= diffusion_kernel\n        q = np.fft.ifftn(q_hat)\n\n        # 3. Second half potential step\n        q *= exp_w_half_step\n        \n    return q.real\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    L = 2 * np.pi\n    N = 16\n    D = 1.0\n    S = 1.0\n    \n    (x, y, z), k_squared = setup_grid(N, L)\n    \n    ds_values = [1/8, 1/16, 1/32, 1/64]\n    \n    results = []\n\n    # --- Test 1: Homogeneous, diffusion-only ---\n    w_test1 = np.zeros((N, N, N))\n    q0_test1 = np.cos(x) * np.cos(y) * np.cos(z)\n    \n    # Reference solution for Test 1 (exact in spectral space)\n    q0_hat_test1 = np.fft.fftn(q0_test1)\n    exact_diffusion_kernel = np.exp(-S * D * k_squared)\n    q_ref_hat_test1 = q0_hat_test1 * exact_diffusion_kernel\n    q_ref_test1 = np.fft.ifftn(q_ref_hat_test1).real\n    \n    errors_test1 = []\n    norm_ref1 = np.linalg.norm(q_ref_test1)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test1, w_test1, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test1) / norm_ref1\n        errors_test1.append(error)\n\n    results.append(np.max(errors_test1))\n    \n    # --- Test 2: Homogeneous potential ---\n    w0 = 0.3\n    w_test2 = np.full((N, N, N), w0)\n    q0_test2 = np.cos(x) * np.cos(y) * np.cos(z)\n    \n    # Reference solution for Test 2 (exact since operators commute)\n    q0_hat_test2 = np.fft.fftn(q0_test2)\n    q_ref_hat_test2 = q0_hat_test2 * exact_diffusion_kernel\n    q_ref_test2_diffusion = np.fft.ifftn(q_ref_hat_test2).real\n    q_ref_test2 = np.exp(-w0 * S) * q_ref_test2_diffusion\n    \n    errors_test2 = []\n    norm_ref2 = np.linalg.norm(q_ref_test2)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test2, w_test2, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test2) / norm_ref2\n        errors_test2.append(error)\n\n    results.append(np.max(errors_test2))\n    \n    # --- Test 3: Inhomogeneous potential, accuracy study ---\n    A = 0.5\n    w_test3 = A * np.cos(x) * np.cos(y) * np.cos(z)\n    q0_test3 = np.ones((N, N, N))\n    \n    # Reference solution computed with a much smaller step size\n    ds_ref = 1/512\n    q_ref_test3 = solve_diffusion_equation(q0_test3, w_test3, D, S, ds_ref, k_squared)\n    \n    errors_test3 = []\n    norm_ref3 = np.linalg.norm(q_ref_test3)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test3, w_test3, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test3) / norm_ref3\n        errors_test3.append(error)\n        \n    log_ds_vals = np.log(ds_values)\n    log_errors = np.log(errors_test3)\n    \n    # OLS linear regression to find the slope (order of accuracy)\n    x_fit = log_ds_vals\n    y_fit = log_errors\n    n_fit = len(x_fit)\n    \n    sum_x = np.sum(x_fit)\n    sum_y = np.sum(y_fit)\n    sum_xy = np.sum(x_fit * y_fit)\n    sum_x2 = np.sum(x_fit**2)\n    \n    # Formula for the slope of the regression line\n    slope = (n_fit * sum_xy - sum_x * sum_y) / (n_fit * sum_x2 - sum_x**2)\n    \n    results.append(slope)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2927261"}, {"introduction": "Building upon the propagator solver, this practice [@problem_id:2927297] guides you through assembling a full SCFT calculation for a one-dimensional diblock copolymer system. You will implement the complete self-consistent loop: evolving propagators, calculating monomer densities, and updating the mean fields until convergence is achieved. Furthermore, by performing a grid refinement study, you will learn how to quantify the numerical accuracy of your simulation and ensure that the obtained free energies and density profiles are physically reliable.", "problem": "Consider a one-dimensional self-consistent field theory (SCFT) for a symmetric diblock copolymer melt forming a lamellar morphology in a periodic domain. The aim is to quantify convergence of the saddle-point free energy per chain and the monomer density profile with respect to spatial resolution by performing a grid refinement study. Use the following fundamental base and definitions.\n\nA Gaussian-chain diblock copolymer of total contour length scaled to unity has an A-block of fraction $f$ and a B-block of fraction $1 - f$. In the mean-field approximation, the single-chain propagator $q(s,z)$ in an external field satisfies the modified diffusion equation\n$$\n\\frac{\\partial q}{\\partial s} = \\nabla^2 q - w_\\alpha(z)\\, q,\n$$\nwhere $s \\in [0,1]$ is the contour variable, $z \\in [0,L)$ is the spatial coordinate, and $w_\\alpha(z)$ is the self-consistent field acting on segment type $\\alpha \\in \\{\\mathrm{A}, \\mathrm{B}\\}$. The system is incompressible, so the total monomer density is constrained by\n$$\n\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1.\n$$\nIntroduce the exchange and pressure-like fields $w_-(z)$ and $w_+(z)$ via $w_\\mathrm{A} = w_+(z) - w_-(z)$ and $w_\\mathrm{B} = w_+(z) + w_-(z)$. The Floryâ€“Huggins incompatibility parameter is $\\chi N$, and the saddle-point conditions enforce\n$$\nw_-(z) = \\chi N \\left[\\phi_\\mathrm{B}(z) - \\phi_\\mathrm{A}(z)\\right],\n\\quad\n\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1.\n$$\nThe forward propagator satisfies $q(0,z) = 1$, and the corresponding backward propagator $q^\\dagger(s,z)$ satisfies $q^\\dagger(1,z) = 1$, with the same modified diffusion operator applied along the appropriate block types. The single-chain partition function is\n$$\nQ = \\frac{1}{L} \\int_0^L q(1,z)\\, dz,\n$$\nand the block densities are obtained from the propagators as\n$$\n\\phi_\\mathrm{A}(z) = \\frac{1}{Q} \\int_0^f q(s,z)\\, q^\\dagger(s,z)\\, ds,\\qquad\n\\phi_\\mathrm{B}(z) = \\frac{1}{Q} \\int_f^1 q(s,z)\\, q^\\dagger(s,z)\\, ds.\n$$\nAll equations are written in dimensionless units obtained by scaling length with the radius of gyration such that the Laplacian prefactor is unity and free energies are in units of the Boltzmann constant times temperature, $k_\\mathrm{B} T$.\n\nTask. Starting from these definitions, do the following.\n\n1) Discretize the spatial domain $[0,L)$ with periodic boundary conditions using a uniform grid of $N_x$ points. Discretize the contour variable $s \\in [0,1]$ with $M$ uniform steps. Use a pseudo-spectral method in space with Strang splitting in $s$ for the propagator evolution. The Strang splitting should alternate half-steps in the real-space field multiplication and full steps in the Fourier-space diffusion operator. Derive this algorithm from the modified diffusion equation and explain why it is second-order accurate in the contour step size.\n\n2) Implement a fixed-point iterative scheme to solve the self-consistent equations for $w_-(z)$ and $w_+(z)$ subject to the incompressibility constraint. Use under-relaxed updates for both fields. Impose the gauge condition that the spatial average of $w_+(z)$ is zero at every iteration. Derive a gauge-invariant expression for the saddle-point free energy per chain, $F$, expressed purely in terms of $Q$, $w_-(z)$, and known constants, under the gauge $\\langle w_+ \\rangle = 0$. Express the final value of $F$ in units of $k_\\mathrm{B} T$ per chain.\n\n3) Set up a lamellar state by initializing the exchange field $w_-(z)$ with a small-amplitude sinusoid of fundamental wave number consistent with a single lamella in the box and $w_+(z)$ initially zero. Iterate to convergence.\n\n4) Grid-refinement study. Use the same physical and numerical parameters for all resolutions except $N_x$. Compute the converged $F$ and the converged $\\phi_\\mathrm{A}(z)$ for each $N_x$. Use the finest grid as the reference, and quantify the errors on coarser grids as follows:\n- Free-energy error: $\\Delta F(N_x) = F(N_x) - F(N_{\\mathrm{ref}})$.\n- Density error: For grids where $N_x$ divides $N_{\\mathrm{ref}}$, compare $\\phi_\\mathrm{A}(z)$ at the common grid points (i.e., subsample the reference profile onto the coarse grid) and compute the relative discrete $L^2$ error\n$$\n\\mathcal{E}(N_x) = \\left( \\frac{\\sum_j \\left[\\phi_\\mathrm{A}^{(N_x)}(z_j) - \\phi_\\mathrm{A}^{(N_{\\mathrm{ref}})}(z_j)\\right]^2}{\\sum_j \\left[\\phi_\\mathrm{A}^{(N_{\\mathrm{ref}})}(z_j)\\right]^2} \\right)^{1/2}.\n$$\n\nUse the following test suite of parameters:\n- Physical: $f = 0.5$, $\\chi N = 20.0$, domain length $L = 4.0$ (dimensionless), one lamellar period in the domain.\n- Numerical: $M = 100$ (even), maximum iterations $200$, under-relaxation parameters $\\alpha_+ = 0.10$ and $\\alpha_- = 0.10$, convergence tolerance $10^{-6}$ on the root-mean-square residuals of the two self-consistency conditions.\n- Spatial resolutions: $N_x \\in \\{32, 48, 64, 96, 192\\}$ with $N_{\\mathrm{ref}} = 192$ used as the reference.\n\nFinal output. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, in this order, report the free-energy error $\\Delta F$ and the relative $L^2$ density error $\\mathcal{E}$ for each coarse grid in increasing $N_x$, omitting the reference grid. The format is:\n$$\n[\\Delta F(32),\\, \\mathcal{E}(32),\\, \\Delta F(48),\\, \\mathcal{E}(48),\\, \\Delta F(64),\\, \\mathcal{E}(64),\\, \\Delta F(96),\\, \\mathcal{E}(96)].\n$$\nAll free energies must be expressed in units of $k_\\mathrm{B} T$ per chain, and the density errors are dimensionless. Values should be printed as decimal floating-point numbers on a single line in the exact list format described.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n-   **System**: A symmetric diblock copolymer melt with A-block fraction $f$ and B-block fraction $1-f$, forming a one-dimensional lamellar structure in a periodic domain of length $L$.\n-   **Governing Equation**: The single-chain propagator $q(s,z)$ for contour $s \\in [0,1]$ and position $z \\in [0,L)$ evolves according to the modified diffusion equation: $\\frac{\\partial q}{\\partial s} = \\nabla^2 q - w_\\alpha(z)\\, q$, where $w_\\alpha(z)$ is the mean field for block type $\\alpha \\in \\{\\mathrm{A}, \\mathrm{B}\\}$.\n-   **Initial/Boundary Conditions**: $q(0,z) = 1$ for the forward propagator, $q^\\dagger(1,z) = 1$ for the backward propagator. Periodic boundary conditions in $z$.\n-   **Self-Consistency**: The system is incompressible, $\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1$. The fields are related via $w_\\mathrm{A}(z) = w_+(z) - w_-(z)$ and $w_\\mathrm{B}(z) = w_+(z) + w_-(z)$. The saddle-point conditions are $w_-(z) = \\chi N \\left[\\phi_\\mathrm{B}(z) - \\phi_\\mathrm{A}(z)\\right]$ and the incompressibility constraint.\n-   **Observables**: Single-chain partition function $Q = \\frac{1}{L} \\int_0^L q(1,z)\\, dz$. Block densities are $\\phi_\\mathrm{A}(z) = \\frac{1}{Q} \\int_0^f q(s,z)\\, q^\\dagger(s,z)\\, ds$ and $\\phi_\\mathrm{B}(z) = \\frac{1}{Q} \\int_f^1 q(s,z)\\, q^\\dagger(s,z)\\, ds$.\n-   **Units**: Dimensionless, with lengths scaled by the radius of gyration and energies by $k_\\mathrm{B} T$.\n-   **Task 1 (Algorithm)**: Discretize the domain using $N_x$ spatial grid points and $M$ contour steps. Derive and explain a pseudo-spectral algorithm with second-order Strang splitting for the propagator evolution.\n-   **Task 2 (Theory)**: Implement a fixed-point iteration. Derive a gauge-invariant expression for the saddle-point free energy per chain, $F$, under the gauge $\\langle w_+ \\rangle = 0$.\n-   **Task 3 (Initialization)**: Initialize $w_-(z)$ with a small-amplitude sinusoid of period $L$, and $w_+(z) = 0$.\n-   **Task 4 (Grid Study)**:\n    -   Physical parameters: $f = 0.5$, $\\chi N = 20.0$, $L = 4.0$.\n    -   Numerical parameters: $M = 100$, max iterations $= 200$, under-relaxation $\\alpha_+ = \\alpha_- = 0.10$, tolerance $= 10^{-6}$.\n    -   Spatial resolutions: $N_x \\in \\{32, 48, 64, 96, 192\\}$, with $N_{\\mathrm{ref}} = 192$.\n    -   Error metrics: Free-energy error $\\Delta F(N_x) = F(N_x) - F(N_{\\mathrm{ref}})$ and relative $L^2$ density error $\\mathcal{E}(N_x)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is analyzed against the specified criteria.\n-   **Scientific Grounding**: The problem is a standard application of self-consistent field theory (SCFT) to diblock copolymers, a foundational model in polymer physics. The equations and concepts are textbook material (e.g., Matsen & Schick, 1994). The framework is scientifically sound.\n-   **Well-Posedness**: The task is to find a saddle point of a free energy functional, which is a well-defined mathematical objective. The specified iterative numerical scheme is a standard and robust method for solving this class of problems. The parameter set is known to lead to a stable lamellar phase, ensuring a meaningful solution exists.\n-   **Objectivity**: The problem is stated in precise, quantitative, and unbiased mathematical language. All terms are defined.\n-   **Completeness**: All required physical and numerical parameters, initial conditions, and convergence criteria are provided. The error metrics for the grid-refinement study are explicitly defined.\n-   **Consistency**: The definitions and constraints are self-consistent. The definitions of the fields $w_-$ and $w_+$ and their relation to the block densities are clearly stated and form a closed set of equations. The grid resolutions $N_x$ are chosen such that the coarser grids are divisors of the reference grid, which is consistent with the definition of the density error metric.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed, scientifically grounded, and complete problem in computational polymer physics. A solution will be provided.\n\n### Solution and Derivations\n\nThe problem requires the derivation of the numerical algorithm and the free energy expression, followed by a computational implementation.\n\n**1. Pseudo-spectral Algorithm with Strang Splitting**\n\nThe evolution of the propagator $q(s,z)$ is governed by the modified diffusion equation:\n$$\n\\frac{\\partial q}{\\partial s} = \\left(\\nabla^2 - w(z)\\right) q \\equiv (\\hat{A} + \\hat{B}) q\n$$\nHere, the operator is split into a diffusion part, $\\hat{A} = \\nabla^2$, and a reaction part, $\\hat{B} = -w(z)$. The operators $\\hat{A}$ and $\\hat{B}$ do not commute, as $[\\hat{A}, \\hat{B}]q = \\nabla^2(-wq) - (-w)\\nabla^2q \\neq 0$. This non-commutativity prohibits a simple exponential solution $e^{\\Delta s \\hat{A}}e^{\\Delta s \\hat{B}}$.\n\nThe pseudo-spectral method is ideal for this structure. The diffusion operator $\\hat{A}$ is a simple multiplication in Fourier space ($\\hat{A} \\rightarrow -k^2$), while the reaction operator $\\hat{B}$ is a local multiplication in real space.\n\nA symmetric operator splitting, known as Strang splitting, provides second-order accuracy in the contour step size $\\Delta s$. The formal solution over one step, $q(s+\\Delta s) = e^{\\Delta s(\\hat{A}+\\hat{B})} q(s)$, is approximated as:\n$$\nq(s+\\Delta s) \\approx e^{\\frac{\\Delta s}{2}\\hat{B}} e^{\\Delta s\\hat{A}} e^{\\frac{\\Delta s}{2}\\hat{B}} q(s)\n$$\nTo demonstrate its second-order accuracy, we expand the exponential operators. The exact evolution operator is $e^{\\Delta s (\\hat{A}+\\hat{B})} = 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}+\\hat{B})^2 + O(\\Delta s^3)$. The Strang splitting approximation expands to:\n$$\n\\left(1 + \\frac{\\Delta s}{2}\\hat{B} + \\frac{\\Delta s^2}{8}\\hat{B}^2\\right) \\left(1 + \\Delta s\\hat{A} + \\frac{\\Delta s^2}{2}\\hat{A}^2\\right) \\left(1 + \\frac{\\Delta s}{2}\\hat{B} + \\frac{\\Delta s^2}{8}\\hat{B}^2\\right) + O(\\Delta s^3)\n$$\n$$\n= 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}^2 + \\hat{B}^2 + \\hat{A}\\hat{B} + \\hat{B}\\hat{A}) + O(\\Delta s^3)\n$$\n$$\n= 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}+\\hat{B})^2 + O(\\Delta s^3)\n$$\nThe approximation matches the exact expansion up to terms of order $\\Delta s^2$, meaning the local truncation error is $O(\\Delta s^3)$. For an integration over a total contour length of $1$ using $M = 1/\\Delta s$ steps, the global error is $M \\times O(\\Delta s^3) = O(\\Delta s^2)$, hence the method is second-order accurate.\n\nThe algorithmic implementation for a single step is:\n1.  Half-step in real space: $q' = e^{-\\frac{\\Delta s}{2}w(z)} q(z)$.\n2.  Transform to Fourier space: $\\tilde{q}' = \\mathcal{F}[q']$.\n3.  Full step in Fourier space: $\\tilde{q}'' = e^{-k^2 \\Delta s} \\tilde{q}'$.\n4.  Transform back to real space: $q'' = \\mathcal{F}^{-1}[\\tilde{q}'']$.\n5.  Second half-step in real space: $q_{new} = e^{-\\frac{\\Delta s}{2}w(z)} q''$.\n\nThe backward propagator $q^\\dagger(s,z)$ must be formulated to ensure numerical stability. The standard governing equation is $-\\frac{\\partial q^\\dagger}{\\partial s} = (\\nabla^2 - w)q^\\dagger$. Let $s' = 1-s$. The equation transforms into $\\frac{\\partial q^\\dagger}{\\partial s'} = (\\nabla^2 - w(1-s'))q^\\dagger$, which is identical in form to the forward propagator equation. Thus, the same stable numerical scheme is used to evolve $q^\\dagger$ from $s'=0$ (physical $s=1$) to $s'=1$ (physical $s=0$), but with the block fields $w_B$ and $w_A$ applied in reverse sequence.\n\n**2. Saddle-Point Free Energy**\n\nThe self-consistent field equations arise from finding the saddle point of a free energy functional $F[w_-, w_+]$. We construct a functional such that its extremization with respect to the fields yields the given self-consistency conditions. The functional derivative of the single-chain partition function part, $-\\ln Q$, with respect to the fields is $\\frac{\\delta(-\\ln Q)}{\\delta w_\\alpha} = \\phi_\\alpha$. In terms of the transformed fields:\n$$\n\\frac{\\delta(-\\ln Q)}{\\delta w_+} = \\phi_A + \\phi_B \\quad , \\quad \\frac{\\delta(-\\ln Q)}{\\delta w_-} = \\phi_B - \\phi_A\n$$\nConsider the following functional form for the free energy per chain:\n$$\nF[w_-, w_+] = -\\ln Q + \\frac{1}{L} \\int_0^L \\left( \\frac{w_-^2(z)}{2\\chi N} - w_+(z) \\right) dz\n$$\nExtremizing with respect to $w_+$ and $w_-$ provides the saddle-point equations:\n$$\n\\frac{\\delta F}{\\delta w_+(z)} = -1 + (\\phi_A(z) + \\phi_B(z)) = 0 \\implies \\phi_A(z) + \\phi_B(z) = 1\n$$\n$$\n\\frac{\\delta F}{\\delta w_-(z)} = \\frac{w_-(z)}{\\chi N} - (\\phi_B(z) - \\phi_A(z)) = 0 \\implies w_-(z) = \\chi N (\\phi_B(z) - \\phi_A(z))\n$$\nThese precisely match the self-consistency and incompressibility conditions specified in the problem. The value of this functional at the saddle point is the desired Helmholtz free energy per chain. This expression is gauge-invariant. A shift $w_+(z) \\to w_+(z) + C_0$ results in $q(s,z) \\to q(s,z)e^{-s C_0}$, $Q \\to Q e^{-C_0}$, and $-\\ln Q \\to -\\ln Q + C_0$. The term $-\\frac{1}{L}\\int w_+(z) dz$ shifts by $-C_0$, which exactly cancels the shift from $-\\ln Q$.\nThe problem specifies the gauge condition that the spatial average of $w_+(z)$ is zero, $\\langle w_+ \\rangle = \\frac{1}{L}\\int_0^L w_+(z) dz = 0$. Under this gauge, the integral of $w_+$ vanishes, and the free energy expression simplifies to:\n$$\nF = -\\ln Q + \\frac{1}{2\\chi N L} \\int_0^L w_-^2(z) dz = -\\ln Q + \\frac{1}{2\\chi N} \\langle w_-^2 \\rangle\n$$\nThis expression, in units of $k_\\mathrm{B} T$ per chain, will be used for calculation. The fixed-point iteration updates $w_-$ and $w_+$ to drive the system toward this saddle point. Simple Picard iteration with under-relaxation is used:\n$w_-^{(k+1)} = (1-\\alpha_-)w_-^{(k)} + \\alpha_- \\left[\\chi N(\\phi_B^{(k)}-\\phi_A^{(k)})\\right]$\n$w_+^{(k+1)} = w_+^{(k)} - \\alpha_+(\\phi_A^{(k)}+\\phi_B^{(k)}-1) - \\langle w_+^{(k)} - \\alpha_+(\\phi_A^{(k)}+\\phi_B^{(k)}-1) \\rangle$\nThe update for $w_+$ is a simple feedback on the incompressibility error, followed by re-imposition of the gauge condition.\n\n**3. Implementation and Grid Refinement**\n\nThe described algorithms are implemented in Python. The propagators are evolved along the discretized contour, storing their values at each step. Densities are computed via numerical integration (trapezoidal rule) of the product $q(s,z)q^\\dagger(s,z)$ over the respective block domains. The SCFT loop is iterated until the root-mean-square residuals of the two self-consistency conditions fall below the tolerance of $10^{-6}$. This procedure is executed for each specified spatial resolution $N_x$. Finally, the free energy and density profile errors are calculated relative to the finest grid ($N_{\\mathrm{ref}}=192$).", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SCFT problem for a symmetric diblock copolymer and\n    performs a grid refinement study.\n    \"\"\"\n\n    # --- Physical and Numerical Parameters ---\n    f_A = 0.5\n    chi_N = 20.0\n    L = 4.0\n    \n    M = 100  # Number of contour steps\n    max_iter = 200\n    alpha_plus = 0.10\n    alpha_minus = 0.10\n    tolerance = 1e-6\n\n    Nx_list = [32, 48, 64, 96, 192]\n    N_ref = 192\n\n    # --- Container for results ---\n    converged_data = {}\n\n    # --- Main loop over grid resolutions ---\n    for Nx in Nx_list:\n        F_conv, phi_A_conv = run_scft(\n            Nx, M, L, f_A, chi_N, max_iter, tolerance, alpha_minus, alpha_plus\n        )\n        converged_data[Nx] = {'F': F_conv, 'phi_A': phi_A_conv}\n\n    # --- Post-processing: Error Analysis ---\n    ref_data = converged_data[N_ref]\n    F_ref = ref_data['F']\n    phi_A_ref = ref_data['phi_A']\n\n    results_list = []\n    for Nx in sorted(converged_data.keys()):\n        if Nx == N_ref:\n            continue\n\n        coarse_data = converged_data[Nx]\n        F_coarse = coarse_data['F']\n        phi_A_coarse = coarse_data['phi_A']\n\n        # 1. Free energy error\n        delta_F = F_coarse - F_ref\n        results_list.append(delta_F)\n\n        # 2. Density profile error\n        stride = N_ref // Nx\n        phi_A_ref_subsampled = phi_A_ref[::stride]\n        \n        numerator = np.sum((phi_A_coarse - phi_A_ref_subsampled)**2)\n        denominator = np.sum(phi_A_ref_subsampled**2)\n        \n        if denominator == 0:\n            error_phi = 0.0\n        else:\n            error_phi = np.sqrt(numerator / denominator)\n        results_list.append(error_phi)\n\n    # --- Final Output ---\n    output_str = \",\".join([f\"{val:.12f}\" for val in results_list])\n    print(f\"[{output_str}]\")\n\n\ndef run_scft(Nx, M, L, f_A, chi_N, max_iter, tolerance, alpha_minus, alpha_plus):\n    \"\"\"\n    Performs the self-consistent field iteration for a given set of parameters.\n    \"\"\"\n    # --- Grid setup ---\n    z = np.linspace(0, L, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=L / Nx)\n    ds = 1.0 / M\n    f_A_steps = int(f_A * M)\n\n    # --- Field initialization ---\n    w_minus = 0.1 * np.cos(2 * np.pi * z / L)\n    w_plus = np.zeros(Nx)\n\n    for iteration in range(max_iter):\n        # --- Update fields ---\n        w_A = w_plus - w_minus\n        w_B = w_plus + w_minus\n\n        # --- Solve propagator equations ---\n        # Forward propagator q(s,z)\n        q_traj = np.zeros((M + 1, Nx), dtype=np.complex128)\n        q_traj[0, :] = 1.0\n        q_current = q_traj[0, :]\n        \n        # Evolve through A-block\n        for i in range(f_A_steps):\n            q_current = strang_split_step(q_current, w_A, k, ds)\n            q_traj[i + 1, :] = q_current\n            \n        # Evolve through B-block\n        for i in range(f_A_steps, M):\n            q_current = strang_split_step(q_current, w_B, k, ds)\n            q_traj[i + 1, :] = q_current\n            \n        # Single-chain partition function\n        Q = np.mean(q_traj[M, :]).real\n\n        # Backward propagator q_dagger(s,z)\n        q_dagger_traj = np.zeros((M + 1, Nx), dtype=np.complex128)\n        q_dagger_traj[M, :] = 1.0\n        q_dagger_current = q_dagger_traj[M, :]\n\n        # Evolve backwards through B-block (forward in s')\n        for i in range(M - 1, f_A_steps - 1, -1):\n            q_dagger_current = strang_split_step(q_dagger_current, w_B, k, ds)\n            q_dagger_traj[i, :] = q_dagger_current\n        \n        # Evolve backwards through A-block\n        for i in range(f_A_steps - 1, -1, -1):\n            q_dagger_current = strang_split_step(q_dagger_current, w_A, k, ds)\n            q_dagger_traj[i, :] = q_dagger_current\n        \n        # --- Calculate densities ---\n        # Trapezoidal rule for integration over s\n        integrand_A = q_traj[0:f_A_steps + 1, :] * q_dagger_traj[0:f_A_steps + 1, :]\n        phi_A = np.trapz(integrand_A.real, dx=ds, axis=0) / Q\n        \n        integrand_B = q_traj[f_A_steps:M + 1, :] * q_dagger_traj[f_A_steps:M + 1, :]\n        phi_B = np.trapz(integrand_B.real, dx=ds, axis=0) / Q\n\n        # --- Calculate residuals for convergence check ---\n        res_minus_field = w_minus - chi_N * (phi_B - phi_A)\n        res_plus_field = phi_A + phi_B - 1\n        \n        res_minus = np.sqrt(np.mean(res_minus_field**2))\n        res_plus = np.sqrt(np.mean(res_plus_field**2))\n\n        if res_minus  tolerance and res_plus  tolerance:\n            break\n\n        # --- Update fields using simple mixing ---\n        w_minus_target = chi_N * (phi_B - phi_A)\n        w_minus = (1 - alpha_minus) * w_minus + alpha_minus * w_minus_target\n\n        w_plus_updated = w_plus - alpha_plus * (phi_A + phi_B - 1)\n        w_plus = w_plus_updated - np.mean(w_plus_updated)\n\n    # --- Calculate final free energy ---\n    F = -np.log(Q) + np.mean(w_minus**2) / (2 * chi_N)\n    \n    return F, phi_A\n\n\ndef strang_split_step(q_in, w, k, ds):\n    \"\"\"\n    Performs one step of the propagator evolution using a pseudo-spectral\n    method with Strang splitting.\n    \"\"\"\n    # Half-step in real space (reaction)\n    q_half_reac = q_in * np.exp(-0.5 * ds * w)\n    \n    # Full step in Fourier space (diffusion)\n    q_half_reac_f = np.fft.fft(q_half_reac)\n    q_full_diff_f = q_half_reac_f * np.exp(-ds * k**2)\n    q_full_diff = np.fft.ifft(q_full_diff_f)\n    \n    # Second half-step in real space (reaction)\n    q_out = q_full_diff * np.exp(-0.5 * ds * w)\n    \n    return q_out\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2927297"}, {"introduction": "A key challenge in interpreting simulation results is to distinguish true physical behavior from artifacts introduced by the simulation methodology, such as the use of a finite-sized periodic cell. This exercise [@problem_id:2927292] utilizes a simplified Landau-Brazovskii model to explore the nature of these finite-size effects. By analyzing how the system's free energy changes with the size of the simulation box, you will learn a standard extrapolation technique to estimate the properties of the system in the thermodynamic limit, a crucial skill for comparing computational predictions with real-world experiments.", "problem": "Consider a reduced, one-dimensional, single-mode surrogate of self-consistent field theory (SCFT) for an inhomogeneous polymer system in a periodic unit cell of length $L$ with periodic boundary conditions. The order parameter field is represented by a single harmonic mode $\\phi(x) = A \\cos(q x)$, where $A$ is the amplitude and $q$ is the wavenumber constrained by periodicity to the discrete set $q = 2\\pi n / L$ with $n \\in \\mathbb{N}$. The effective mean-field free-energy density per unit volume is modeled by the Landau-Brazovskii-type expansion\n$$\nf(A,q) = \\alpha A^2 + \\beta A^4 + \\gamma (q - q_0)^2 A^2,\n$$\nwhere $\\alpha  0$ encodes the distance below the mean-field ordering threshold, $\\beta  0$ stabilizes the amplitude, $\\gamma  0$ penalizes deviations of the modulation from its preferred wavenumber $q_0  0$, and all quantities are dimensionless.\n\nYour tasks are:\n1. For a given set of parameters $(\\alpha,\\beta,\\gamma,q_0)$ and a list of unit-cell sizes $\\{L_i\\}$, compute the finite-size free-energy density $F(L)$ defined as the minimum of $f(A,q)$ with respect to both the amplitude $A$ and the allowed discrete wavenumbers $q = 2\\pi n/L$, $n \\in \\mathbb{N}$. That is, for each $L$, minimize over $A$ for each allowed $q$, then take the smallest value over $n \\ge 1$. If the minimum over $A$ is nonnegative for all allowed $q$ at a given $L$, then set $F(L) = 0$ for that $L$ (disordered state).\n2. Using the asymptotic expectation that discretization-induced finite-size effects enter as a leading correction that scales as $L^{-2}$ when $L$ is large and $F(L)  0$, estimate the infinite-system free-energy density $F_{\\infty}$ by a least-squares fit of the form\n$$\nF(L) \\approx F_{\\infty} + C \\, L^{-2},\n$$\nusing only those $L$ values for which $F(L)  0$. If there are at least two such points, perform an ordinary least squares fit of $F(L)$ versus $x = L^{-2}$ and report the intercept as $F_{\\infty}$. If there is only one such point, use that single value as the estimate of $F_{\\infty}$. If there are none, report $F_{\\infty} = 0$.\n\nAll quantities are dimensionless. Angles are not used explicitly, and no physical units are required.\n\nImplement a program that carries out the above procedure for each parameter set in the test suite below and outputs the resulting estimates of $F_{\\infty}$.\n\nTest suite (each line is one test case with $(\\alpha,\\beta,\\gamma,q_0;\\, \\{L\\})$):\n- Case 1 (generic incommensurate sampling of $q_0$): $(\\alpha,\\beta,\\gamma,q_0) = (-1.0, 1.0, 1.0, 1.0)$; $\\{L\\} = \\{20.0, 30.0, 40.0, 50.0, 80.0, 120.0\\}$.\n- Case 2 (exact commensurability for all $L$ listed): $(\\alpha,\\beta,\\gamma,q_0) = (-0.5, 2.0, 0.8, \\pi)$; $\\{L\\} = \\{20.0, 40.0, 60.0, 80.0\\}$.\n- Case 3 (edge case where small $L$ are disordered but larger $L$ order): $(\\alpha,\\beta,\\gamma,q_0) = (-0.01, 1.0, 3.0, 0.9)$; $\\{L\\} = \\{6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 30.0, 40.0\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three estimated values of $F_{\\infty}$, corresponding to the three cases above, as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (e.g., \"[x1,x2,x3]\").", "solution": "The problem presented requires the analysis of a simplified one-dimensional Landau-Brazovskii model for a microphase-separated polymer system. The task involves two main parts: first, for a finite system of size $L$, to determine the equilibrium free-energy density $F(L)$ by minimizing a given free-energy functional with respect to both its amplitude and discrete wavelength; second, to extrapolate these finite-size results to the infinite system limit ($L \\to \\infty$) to find the bulk free-energy density $F_{\\infty}$. The procedure is grounded in standard methods of statistical mechanics and computational physics.\n\nThe provided model for the free-energy density per unit volume is\n$$\nf(A,q) = \\alpha A^2 + \\beta A^4 + \\gamma (q - q_0)^2 A^2\n$$\nwhere $A$ is the amplitude of the order parameter modulation, $q$ is its wavenumber, and $\\alpha, \\beta, \\gamma, q_0$ are phenomenological parameters with constraints $\\alpha  0$, $\\beta  0$, $\\gamma  0$, and $q_0  0$.\n\nFirst, we address the minimization of $f(A,q)$ for a given set of parameters and a fixed wavenumber $q$. The expression can be regrouped as:\n$$\nf(A,q) = \\left[ \\alpha + \\gamma(q-q_0)^2 \\right] A^2 + \\beta A^4\n$$\nLet us define an effective quadratic coefficient $r(q) = \\alpha + \\gamma(q-q_0)^2$. The free energy becomes $f(A,q) = r(q)A^2 + \\beta A^4$. To find the minimum with respect to the amplitude $A$ (which must be real, and by convention non-negative), we compute the derivative with respect to $A$ and set it to zero:\n$$\n\\frac{\\partial f}{\\partial A} = 2A \\cdot r(q) + 4\\beta A^3 = 2A \\left( r(q) + 2\\beta A^2 \\right) = 0\n$$\nThis equation yields two possible solutions for the optimal amplitude:\n1. $A_{opt} = 0$: This corresponds to the disordered, homogeneous state, with a free-energy density of $f(0,q) = 0$.\n2. $A_{opt}^2 = -\\frac{r(q)}{2\\beta}$: This corresponds to an ordered, periodically structured state. For a real amplitude $A_{opt}$ to exist, we must have $A_{opt}^2 \\ge 0$. As $\\beta  0$, this requires $r(q) \\le 0$.\n\nTo determine which solution corresponds to the stable equilibrium state, we inspect the second derivative or simply evaluate the free energy at the non-trivial solution. If $r(q)  0$, the only real solution is $A=0$, which is the minimum. The minimum free energy for this $q$ is thus $f_{min}(q) = 0$. If $r(q) \\le 0$, the non-trivial solution exists and corresponds to the global minimum. Substituting $A_{opt}^2 = -r(q)/(2\\beta)$ back into the expression for $f(A,q)$:\n$$\nf_{min}(q) = r(q) \\left(-\\frac{r(q)}{2\\beta}\\right) + \\beta \\left(-\\frac{r(q)}{2\\beta}\\right)^2 = -\\frac{r(q)^2}{2\\beta} + \\frac{r(q)^2}{4\\beta} = -\\frac{r(q)^2}{4\\beta}\n$$\nIn summary, for a fixed wavenumber $q$, the minimized free-energy density is:\n$$\nf_{min}(q) = \\begin{cases}\n    -\\frac{(\\alpha + \\gamma(q-q_0)^2)^2}{4\\beta}  \\text{if } \\alpha + \\gamma(q-q_0)^2 \\le 0 \\\\\n    0  \\text{if } \\alpha + \\gamma(q-q_0)^2  0\n\\end{cases}\n$$\nThe condition for ordering, $r(q) \\le 0$, defines a finite band of wavenumbers favorable to structure formation: $|q - q_0| \\le \\sqrt{-\\alpha/\\gamma}$.\n\nNext, we consider the finite-size system of length $L$ with periodic boundary conditions. This imposes a constraint on the allowed wavenumbers: they must be discrete, given by $q_n = \\frac{2\\pi n}{L}$ for integers $n \\in \\mathbb{N}$ (i.e., $n \\ge 1$). The finite-size free-energy density $F(L)$ is the minimum of $f_{min}(q_n)$ over all allowed modes $n$:\n$$\nF(L) = \\min_{n \\ge 1} f_{min}\\left(q_n = \\frac{2\\pi n}{L}\\right)\n$$\nTo find this minimum, we must find the integer $n \\ge 1$ for which the corresponding $q_n$ yields the most negative free energy. The minimum of $f_{min}(q)$ occurs when $q$ is as close as possible to the preferred wavenumber $q_0$, as this minimizes the penalty term $(q-q_0)^2$ and makes $r(q)$ most negative. Therefore, the computational task is to find the integer $n_{best} \\ge 1$ that minimizes $|q_n - q_0| = |\\frac{2\\pi n}{L} - q_0|$. Once $n_{best}$ is found, we compute $q_{best} = 2\\pi n_{best}/L$ and evaluate $f_{min}(q_{best})$ to obtain $F(L)$. If the resulting $f_{min}(q_{best})$ is non-negative, then $F(L)=0$.\n\nFinally, we estimate the infinite-system free energy $F_{\\infty}$ by extrapolating from the calculated finite-size values $\\{F(L_i)\\}$. The problem specifies the asymptotic relationship $F(L) \\approx F_{\\infty} + C L^{-2}$. This is a linear model if we plot $F(L)$ against $x = L^{-2}$. We are to perform an ordinary least squares regression on the data points $(x_i, y_i) = (L_i^{-2}, F(L_i))$ for which $F(L_i)  0$. Let there be $N$ such points. The linear model is $y = a + bx$, where the intercept $a$ is our estimate for $F_{\\infty}$.\n- If $N \\ge 2$, we construct the design matrix $A$ with a column of ones and a column of the $x_i$ values, and solve the linear system $A \\mathbf{v} = \\mathbf{y}$ for the vector of coefficients $\\mathbf{v} = [a, b]^T$ in the least-squares sense. The estimate is $F_{\\infty} = a$.\n- If $N=1$, with data $(L^*, F(L^*))$, the estimate is simply $F_{\\infty} = F(L^*)$.\n- If $N=0$ (all calculated $F(L_i)$ are zero), the estimate is $F_{\\infty} = 0$.\n\nThis completes the logical procedure required to solve the problem. The implementation follows this design.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def calculate_F_L(L, alpha, beta, gamma, q0):\n        \"\"\"\n        Computes the finite-size free-energy density F(L).\n\n        This is done by finding the discrete wavenumber q_n = 2*pi*n/L (n=1)\n        that is closest to the preferred wavenumber q0. This mode is the most\n        likely to produce the lowest free energy. If even this optimal mode\n        is disordered (f=0), the system is considered disordered (F(L)=0).\n        \"\"\"\n        \n        # Find the integer n = 1 that minimizes |2*pi*n/L - q0|.\n        # This is equivalent to finding the integer n closest to L*q0/(2*pi).\n        n_ideal = L * q0 / (2 * np.pi)\n\n        if n_ideal  1.0:\n            # If n_ideal is less than 1, the closest positive integer is 1.\n            n_best = 1\n        else:\n            n_low = int(np.floor(n_ideal))\n            n_high = int(np.ceil(n_ideal))\n\n            # n must be at least 1.\n            if n_low == 0:\n                n_low = 1\n            \n            q_low = 2 * np.pi * n_low / L\n            q_high = 2 * np.pi * n_high / L\n\n            if abs(q_low - q0)  abs(q_high - q0):\n                n_best = n_low\n            else:\n                n_best = n_high\n        \n        # Calculate the free energy for this best available mode.\n        q_best = 2 * np.pi * n_best / L\n        r_best = alpha + gamma * (q_best - q0)**2\n\n        if r_best = 0:\n            # Ordered state is possible for this mode.\n            F_L = -r_best**2 / (4 * beta)\n        else:\n            # Disordered state; free energy is 0.\n            F_L = 0.0\n            \n        return F_L\n\n    def estimate_F_infinity(params, L_values):\n        \"\"\"\n        Calculates F(L) for each L and then estimates F_infinity via a fit.\n        \"\"\"\n        alpha, beta, gamma, q0 = params\n        \n        fit_points = []\n        for L in L_values:\n            F_L = calculate_F_L(L, alpha, beta, gamma, q0)\n            if F_L  0:\n                fit_points.append((L, F_L))\n                \n        num_points = len(fit_points)\n        \n        if num_points == 0:\n            return 0.0\n        elif num_points == 1:\n            # Use the single F(L) value if only one point is available.\n            return fit_points[0][1]\n        else:\n            # At least two points, perform ordinary least squares fit.\n            # Model: y = F_inf + C * x, where y=F(L), x=L^(-2).\n            x_data = np.array([1 / p[0]**2 for p in fit_points])\n            y_data = np.array([p[1] for p in fit_points])\n            \n            # Construct the design matrix A for y = intercept + slope * x.\n            A = np.vstack([np.ones(num_points), x_data]).T\n            \n            # Use numpy's least-squares solver.\n            # The result is a vector [intercept, slope]. We need the intercept.\n            F_inf, C = np.linalg.lstsq(A, y_data, rcond=None)[0]\n            \n            return F_inf\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1\n        {'params': (-1.0, 1.0, 1.0, 1.0), 'L': [20.0, 30.0, 40.0, 50.0, 80.0, 120.0]},\n        # Case 2\n        {'params': (-0.5, 2.0, 0.8, np.pi), 'L': [20.0, 40.0, 60.0, 80.0]},\n        # Case 3\n        {'params': (-0.01, 1.0, 3.0, 0.9), 'L': [6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 30.0, 40.0]}\n    ]\n    \n    results = []\n    for case in test_cases:\n        f_inf_estimate = estimate_F_infinity(case['params'], case['L'])\n        results.append(f_inf_estimate)\n\n    # Format output as specified: list of comma-separated values, rounded to 6 decimal places.\n    formatted_results = [f'{res:.6f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2927292"}]}