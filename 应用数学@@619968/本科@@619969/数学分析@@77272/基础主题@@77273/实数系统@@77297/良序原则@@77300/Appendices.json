{"hands_on_practices": [{"introduction": "良序原则是揭示整数集基本结构的利器。这个练习将带你探索一种特殊的“可减集”(subtractive set)，并要求你找出其中的最小正整数。通过这个过程，你将亲身体会到，由良序原则保证存在的这个最小元素，其性质如何决定了整个集合的结构，并最终与我们熟悉的欧几里得算法和最大公约数 ($GCD$) 概念联系起来。", "problem": "考虑一种特殊类型的整数集合，我们称之为“差集”（subtractive set）。如果一个集合 $S$ 满足以下两个条件，则它被定义为差集：\n1. $S$ 是一个非空集合，且仅包含正整数。\n2. 对于 $S$ 中的任意两个整数 $x$ 和 $y$，如果 $x > y$，那么它们的差 $x-y$ 也是 $S$ 的成员。\n\n已知某个差集 $S$ 包含整数 119 和 204。仅根据这些信息和差集的性质，求出保证存在于 $S$ 中的最小正整数。", "solution": "一个差集 $S$ 满足：如果 $x,y \\in S$ 且 $x>y$，那么 $x-y \\in S$。因为 $204,119 \\in S$ 且 $204>119$，重复应用该定义性质，可以得到欧几里得算法的步骤：\n$$204-119=85 \\in S,$$\n$$119-85=34 \\in S,$$\n$$85-34=51 \\in S,$$\n$$51-34=17 \\in S,$$\n$$34-17=17 \\in S.$$\n因此 $17 \\in S$。这些步骤恰好是欧几里得算法，所以 $\\gcd(204,119)=17$，我们仅利用差运算的封闭性就证明了该元素存在于 $S$ 中。\n\n为了证明没有更小的正整数能被保证存在，我们考虑集合\n$$T=\\{k \\in \\mathbb{Z}_{>0} : k \\equiv 0 \\pmod{17},\\ k \\leq 204\\}.$$\n那么 $T$ 只包含正整数且非空。如果 $x,y \\in T$ 且 $x>y$，那么 $x-y$ 是 $17$ 的一个正倍数，并且满足 $x-y \\leq 204-17=187$，因此 $x-y \\in T$。所以 $T$ 是一个差集。此外，$119=7\\cdot 17 \\in T$ 且 $204=12\\cdot 17 \\in T$，并且 $T$ 中最小的元素是 $17$。因此，对于任何包含 119 和 204 的差集，没有任何小于 17 的整数是必须存在的。\n\n综合这两个事实，17 存在于每一个这样的集合 $S$ 中，且没有更小的正整数能被保证存在。因此，保证在 $S$ 中的最小正整数是 $17$。", "answer": "$$\\boxed{17}$$", "id": "1841590"}, {"introduction": "在理解了前一个抽象练习的核心思想后，我们将把相同的原理应用到一个更具体、更形象的场景中。这次我们不再讨论抽象的集合，而是考虑一个机器人在网格上所有可能到达的位置。这个练习将帮助你巩固“整数线性组合 $ax+by$ 所能构成的最小正数即是其系数的最大公约数 $\\gcd(a, b)$”这一重要结论，而这个结论的证明正是良序原则的经典应用之一 [@problem_id:1841590]。", "problem": "一个机器人智能体在一个无限的一维网格上运行。该智能体从原点（位置 0）开始。其编程中有两个基本移动指令：`move_A`，将其位置移动 +14 个单位；`move_B`，将其位置移动 +35 个单位。该智能体也可以反向执行这些指令（即移动 -14 或 -35 个单位）。在任意一系列移动之后，智能体的最终位置 $P$ 可以用线性组合 $P = 14x + 35y$ 来描述，其中 $x$ 和 $y$ 是整数，分别代表 `move_A` 和 `move_B` (及其反向移动) 的净执行次数。\n\n我们关心的是该智能体可以访问的所有可能位置的集合。令 $S$ 为该智能体可到达的所有*正*整数位置的集合。根据良序原则，任何非空的正整数集合必有最小元。可以证明 $S$ 是非空的。令 $d$ 为 $S$ 的最小元。\n\n这个最小正位置 $d$ 的数值是多少？", "solution": "问题要求 $d$ 的值，其中 $d$ 是可以表示为 $14x + 35y$ 形式的最小正整数，对于某些整数 $x$ 和 $y$。所有这些正整数的集合用 $S$ 表示。\n\n首先，我们确认集合 $S$ 是非空的。例如，如果我们选择 $x=1$ 和 $y=0$，位置为 $14(1) + 35(0) = 14$。由于 14 是一个正整数，所以 $14 \\in S$，因此 S 是非空的。根据良序原则，$S$ 必须有一个最小元，我们称之为 $d$。\n\n由于 $d \\in S$，根据 $S$ 的定义，必然存在某个整数 $x_0$ 和 $y_0$ 使得：\n$$d = 14x_0 + 35y_0$$\n\n现在，我们将证明 $d$ 必须同时是 14 和 35 的约数。我们从 14 开始。根据除法算法，我们可以找到唯一的整数 $q$ 和 $r$ 使得：\n$$14 = qd + r, \\quad \\text{其中 } 0 \\le r < d$$\n\n我们想要确定 $r$ 的值。我们可以将 $r$ 表示为线性组合的形式：\n$$r = 14 - qd$$\n代入 $d$ 的表达式：\n$$r = 14 - q(14x_0 + 35y_0)$$\n$$r = 14 - 14qx_0 - 35qy_0$$\n$$r = 14(1 - qx_0) + 35(-qy_0)$$\n令 $x' = 1 - qx_0$ 且 $y' = -qy_0$。由于 $q$、$x_0$ 和 $y_0$ 都是整数，所以 $x'$ 和 $y'$ 也是整数。因此，$r$ 是 14 和 35 的一个整系数线性组合。\n\n如果 $r > 0$，那么 $r$ 将是集合 $S$ 的一个元素。然而，我们从除法算法中知道 $r < d$。这意味着 $r$ 是 $S$ 中一个比 $d$ 更小的元素，这与 $d$ 是 $S$ 的*最小*元的事实相矛盾。所以，$r > 0$ 的假设必定是错误的。\n\n由于 $r$ 必须是非负的（$0 \\le r < d$），唯一剩下的可能性是 $r=0$。\n如果 $r=0$，那么 $14 = qd$。这意味着 $d$ 是 14 的一个约数。\n\n我们可以应用完全相同的论证来证明 $d$ 也必须是 35 的一个约数。我们写出 $35 = q'd + r'$，其中 $0 \\le r' < d$。余数 $r'$ 可以表示为 $r' = 35 - q'd = 35(1-q'y_0) + 14(-q'x_0)$，这表明它也是一个线性组合。与之前相同的原因，$r'$ 必须为 0，这意味着 $35 = q'd$。因此，$d$ 也是 35 的一个约数。\n\n所以，$d$ 是 14 和 35 的一个公约数。\n\n现在，我们来考虑 14 和 35 的最大公约数，我们记为 $g = \\gcd(14, 35)$。因为 $d$ 是 14 和 35 的一个公约数，所以它必须小于或等于*最大*公约数。即 $d \\le g$。\n\n接下来，我们知道 $g$ 整除 14 且 $g$ 整除 35。这意味着我们可以写成 $14 = ga$和 $35 = gb$ 的形式，其中 $a$ 和 $b$ 是某个整数。\n我们再来看一下 $d$ 的表达式：\n$$d = 14x_0 + 35y_0$$\n将 14 和 35 用 $g$ 的表达式代入：\n$$d = (ga)x_0 + (gb)y_0$$\n$$d = g(ax_0 + by_0)$$\n由于 $a, x_0, b, y_0$ 都是整数，所以 $(ax_0 + by_0)$ 这一项也是一个整数。这个方程表明 $g$ 是 $d$ 的一个约数。由于 $d$ 是一个正整数，这意味着 $g \\le d$。\n\n我们已经建立了两个不等式：$d \\le g$ 和 $g \\le d$。两者同时成立的唯一方式是 $d = g$。\n因此，最小正位置 $d$ 等于 14 和 35 的最大公约数。\n\n我们来计算最大公约数：\n14 的质因数分解是 $2 \\times 7$。\n35 的质因数分解是 $5 \\times 7$。\n最大公约数是公共质因数的乘积，即 7。\n所以，$\\gcd(14, 35) = 7$。\n\n因此，$d$ 的值为 7。", "answer": "$$\\boxed{7}$$", "id": "1411715"}, {"introduction": "良序原则的应用远不止于数论，它在证明其他领域（如图论）中“最优”对象的存在性时同样威力巨大。这个问题将让你把网络中的一条含有重复节点的“步道”(walk)简化为一条不含重复节点的“简单路径”(simple path)。你的任务是亲手执行这个简化过程，而这个过程之所以总是能够成功，其背后的理论保障正是基于良序原则的论证——最短的步道必然是一条简单路径。", "problem": "在通信网络中，一个数据包的行程被建模为其访问的路由器序列。我们可以将此网络表示为一个图 $G=(V, E)$，其中 $V$ 是路由器（顶点）的集合，$E$ 是直接连接（边）的集合。\n\n从起始路由器 $u$ 到结束路由器 $v$ 的长度为 $k$ 的*漫步*（walk）是一个路由器序列 $(v_0, v_1, \\dots, v_k)$，满足 $v_0 = u$，$v_k = v$，并且对于每个 $i \\in \\{1, \\dots, k\\}$，在 $v_{i-1}$ 和 $v_i$ 之间都存在一条边。漫步中的路由器可以被重复访问。\n\n*简单路径*（simple path）是一种没有路由器被访问超过一次的漫步。\n\n如果一个漫步不是简单路径，这意味着它至少包含一个*环*（cycle）。一个环可以被看作是漫步序列中从同一个路由器开始并结束于该路由器的部分，例如子序列 $(R_i, \\dots, R_j)$，其中 $R_i = R_j$ 且 $i < j$。任何包含环的漫步都可以通过系统地移除这些冗余的环路遍历，从而转换为一条更短的简单路径。例如，漫步 $(A, B, C, D, B, E)$ 包含环 $(B, C, D, B)$，可以被简化为简单路径 $(A, B, E)$。\n\n考虑一个数据包遵循从路由器 `V1` 到路由器 `V10` 的特定漫步。其访问的路由器序列如下：\n(`V1`, `V2`, `V3`, `V4`, `V5`, `V3`, `V6`, `V7`, `V2`, `V8`, `V6`, `V9`, `V10`)\n\n确定从给定的漫步中消除所有环后得到的简单路径的长度。", "solution": "漫步（walk）是连续顶点相邻的顶点序列；简单路径是没有重复顶点的漫步。漫步中任何重复的顶点都标识出一个环；移除该顶点的首次出现与重复出现之间的子漫步，会产生一条具有相同端点的更短漫步。重复此过程会产生一条从相同起点到相同终点的简单路径。\n\n从左到右处理给定的漫步，维护一条不含重复项的当前路径 $P$。每当一个顶点重复出现时，就将 $P$ 截断回该顶点的首次出现位置：\n\n从 $P=(V1)$ 开始。按顺序读取顶点：\n- 读取 V2：不在 $P$ 中，因此 $P=(V1, V2)$。\n- 读取 V3：不在 $P$ 中，因此 $P=(V1, V2, V3)$。\n- 读取 V4：不在 $P$ 中，因此 $P=(V1, V2, V3, V4)$。\n- 读取 V5：不在 $P$ 中，因此 $P=(V1, V2, V3, V4, V5)$。\n- 读取 V3：V3 重复；通过截断至第一个 V3 来移除先前的 V3 与此 V3 之间的环：$P=(V1, V2, V3)$。\n- 读取 V6：不在 $P$ 中，因此 $P=(V1, V2, V3, V6)$。\n- 读取 V7：不在 $P$ 中，因此 $P=(V1V1, V2, V3, V6, V7)$。\n- 读取 V2：V2 重复；截断至第一个 V2：$P=(V1, V2)$。\n- 读取 V8：不在 $P$ 中，因此 $P=(V1, V2, V8)$。\n- 读取 V6：不在 $P$ 中，因此 $P=(V1, V2, V8, V6)$。\n- 读取 V9：不在 $P$ 中，因此 $P=(V1, V2, V8, V6, V9)$。\n- 读取 V10：不在 $P$ 中，因此 $P=(V1, V2, V8, V6, V9, V10)$。\n\n这个 $P$ 没有重复的顶点，因此它是最终的简单路径。如果 $|P|$ 表示 $P$ 中的顶点数，则简单路径的长度 $L$（边的数量）为\n$$\nL = |P| - 1 = 6 - 1 = 5.\n$$", "answer": "$$\\boxed{5}$$", "id": "1411727"}]}