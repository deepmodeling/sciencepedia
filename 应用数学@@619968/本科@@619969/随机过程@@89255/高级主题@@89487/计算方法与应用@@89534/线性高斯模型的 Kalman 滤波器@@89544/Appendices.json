{"hands_on_practices": [{"introduction": "掌握卡尔曼滤波器的第一步是理解其核心的更新机制。这个练习将我们置于一个具体的情境中：利用一个带有噪声的传感器读数来修正对系统状态的预测。通过这个简单的标量计算，你将亲手实践卡尔曼增益如何基于预测和测量的不确定性来智能地融合信息，从而得到一个更精确的后验估计 [@problem_id:1339626]。", "problem": "一名技术人员正在使用数字控制系统监测一个小型实验性生物反应器的内部温度。该系统采用卡尔曼滤波器来估计会发生波动的真实温度。设离散时间步 $k$ 的真实温度表示为 $x_k$。\n\n在特定的时间步 $k$，系统的动态模型根据先前的数据，给出了一个预测温度（*先验*状态估计）为 $\\hat{x}_{k|k-1} = 85.2^\\circ C$。与此预测相关的方差（*先验*误差协方差）为 $P_{k|k-1} = 1.5$，表示模型的不确定性。\n\n一个温度传感器提供了一个测量值 $z_k$。测量模型由 $z_k = H x_k + v_k$ 给出，其中 $H=1$（传感器直接测量温度），$v_k$ 是一个代表传感器不准确性的零均值高斯噪声项。该测量噪声的方差指定为 $R = 0.6$。\n\n在此时间步 $k$，传感器返回的测量值为 $z_k = 84.1^\\circ C$。\n\n使用线性卡尔曼滤波器的单个更新步骤，计算在结合这个新测量值后的更新温度估计（*后验*状态估计）$\\hat{x}_{k|k}$。将最终答案以摄氏度表示，并四舍五入到四位有效数字。", "solution": "我们对一个标量系统使用标准的线性卡尔曼滤波器测量更新。测量模型为 $z_{k} = H x_{k} + v_{k}$，其中 $H=1$ 且测量噪声方差为 $R$。给定先验估计 $\\hat{x}_{k|k-1}$ 和协方差 $P_{k|k-1}$，卡尔曼增益为\n$$\nK_{k} = \\frac{P_{k|k-1} H^{\\top}}{H P_{k|k-1} H^{\\top} + R}.\n$$\n当 $H=1$ 时，上式简化为\n$$\nK_{k} = \\frac{P_{k|k-1}}{P_{k|k-1} + R}.\n$$\n代入给定值 $P_{k|k-1} = 1.5$ 和 $R = 0.6$，\n$$\nK_{k} = \\frac{1.5}{1.5 + 0.6} = \\frac{1.5}{2.1} = \\frac{5}{7}.\n$$\n新息（测量残差）为\n$$\ny_{k} = z_{k} - H \\hat{x}_{k|k-1} = 84.1 - 85.2 = -1.1.\n$$\n*后验*状态估计为\n$$\n\\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_{k} y_{k} = 85.2 + \\frac{5}{7}(-1.1) = 85.2 - \\frac{11}{14}.\n$$\n数值计算得，\n$$\n85.2 - \\frac{11}{14} \\approx 84.414285714\n$$\n四舍五入到四位有效数字，结果是 $84.41$。", "answer": "$$\\boxed{84.41}$$", "id": "1339626"}, {"introduction": "在掌握了基本的更新步骤之后，是时候将预测和更新两个阶段结合起来，并处理更实际的多维系统了。本练习要求你为一个二维状态（位置和速度）执行一个完整的卡尔曼滤波周期。这个过程将清晰地展示误差协方差矩阵 $P$ 如何在“预测”步骤中因模型不确定性而增大，又如何在“更新”步骤中因新测量值的到来而减小 [@problem_id:2888322]。", "problem": "一个离散时间线性时不变（LTI）状态空间模型，用于描述一维空间中的匀速运动，由以下随机差分方程给出：\n$$\nx_{k+1} = A x_{k} + w_{k}, \\quad y_{k} = C x_{k} + v_{k},\n$$\n其中 $x_{k} \\in \\mathbb{R}^{2}$ 是状态，其分量为位置和速度，$y_{k} \\in \\mathbb{R}$ 是位置测量值，$w_{k}$ 是零均值过程噪声，其协方差为 $Q$，$v_{k}$ 是零均值测量噪声，其协方差为 $R$。假设采样间隔为 $1$ 个时间单位，因此\n$$\nA = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix}, \\quad C = \\begin{bmatrix} 1 & 0 \\end{bmatrix}, \\quad Q = \\operatorname{diag}(0.01,\\,0.01), \\quad R = \\begin{bmatrix} 0.04 \\end{bmatrix}.\n$$\n假设在时间 $k=0$ 时的初始后验误差协方差为\n$$\nP_{0|0} = I_{2}.\n$$\n从这个先验开始，执行一个完整的 Kalman 滤波器（KF）预测-更新周期，以获得在时间 $k=1$ 时的后验误差协方差。您的推导应从估计误差协方差和线性高斯系统的最小方差线性估计器的定义开始，然后推导出用于预测和更新的协方差递归。计算协方差更新所需的所有中间量，但最终答案只报告在时间 $k=1$ 时的后验误差协方差矩阵。将报告的每个矩阵元素四舍五入到 $4$ 位有效数字。不需要物理单位。", "solution": "协方差传播方程如下。\n预测：\n$$\nP_{k|k-1} = A P_{k-1|k-1} A^T + Q\n$$\n更新：\n$$\nK_k = P_{k|k-1} C^T (C P_{k|k-1} C^T + R)^{-1}\n$$\n$$\nP_{k|k} = (I - K_k C) P_{k|k-1}\n$$\n这里，$P_{k|k-1}$ 是在时间 $k$ 时的先验误差协方差，$P_{k|k}$ 是在时间 $k$ 时的后验误差协方差。$K_k$ 是 Kalman 增益。\n\n给定的参数是：\n状态转移矩阵：$A = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix}$\n测量矩阵：$C = \\begin{bmatrix} 1 & 0 \\end{bmatrix}$\n过程噪声协方差：$Q = \\begin{bmatrix} 0.01 & 0 \\\\ 0 & 0.01 \\end{bmatrix}$\n测量噪声协方差：$R = [0.04]$\n在 $k=0$ 时的初始后验误差协方差：$P_{0|0} = I_2 = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$\n\n我们现在对 $k=1$ 执行一个完整的周期。\n\n**步骤1：预测（时间更新）**\n\n我们使用在 $k=0$ 时的协方差状态来计算在 $k=1$ 时的先验误差协方差 $P_{1|0}$。\n$$\nP_{1|0} = A P_{0|0} A^T + Q\n$$\n代入给定值：\n$$\nA P_{0|0} A^T = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\end{bmatrix} = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\cdot 1 + 1 \\cdot 1 & 1 \\cdot 0 + 1 \\cdot 1 \\\\ 0 \\cdot 1 + 1 \\cdot 1 & 0 \\cdot 0 + 1 \\cdot 1 \\end{bmatrix} = \\begin{bmatrix} 2 & 1 \\\\ 1 & 1 \\end{bmatrix}\n$$\n现在，我们加上过程噪声协方差 $Q$：\n$$\nP_{1|0} = \\begin{bmatrix} 2 & 1 \\\\ 1 & 1 \\end{bmatrix} + \\begin{bmatrix} 0.01 & 0 \\\\ 0 & 0.01 \\end{bmatrix} = \\begin{bmatrix} 2.01 & 1 \\\\ 1 & 1.01 \\end{bmatrix}\n$$\n这是在并入 $k=1$ 时的测量值之前的预测误差协方差。\n\n**步骤2：更新（测量更新）**\n\n首先，我们计算新息协方差，我们将其记为 $S_1$：\n$$\nS_1 = C P_{1|0} C^T + R\n$$\n$$\nC P_{1|0} C^T = \\begin{bmatrix} 1 & 0 \\end{bmatrix} \\begin{bmatrix} 2.01 & 1 \\\\ 1 & 1.01 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 2.01 & 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = [2.01]\n$$\n$$\nS_1 = [2.01] + [0.04] = [2.05]\n$$\n接下来，我们计算 Kalman 增益 $K_1$：\n$$\nK_1 = P_{1|0} C^T S_1^{-1}\n$$\n$$\nP_{1|0} C^T = \\begin{bmatrix} 2.01 & 1 \\\\ 1 & 1.01 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 2.01 \\\\ 1 \\end{bmatrix}\n$$\n$$\nK_1 = \\begin{bmatrix} 2.01 \\\\ 1 \\end{bmatrix} [2.05]^{-1} = \\begin{bmatrix} \\frac{2.01}{2.05} \\\\ \\frac{1}{2.05} \\end{bmatrix}\n$$\n最后，我们计算后验误差协方差 $P_{1|1}$：\n$$\nP_{1|1} = (I - K_1 C) P_{1|0}\n$$\n我们来计算 $(I - K_1 C)$ 项：\n$$\nK_1 C = \\begin{bmatrix} \\frac{2.01}{2.05} \\\\ \\frac{1}{2.05} \\end{bmatrix} \\begin{bmatrix} 1 & 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{2.01}{2.05} & 0 \\\\ \\frac{1}{2.05} & 0 \\end{bmatrix}\n$$\n$$\nI - K_1 C = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} \\frac{2.01}{2.05} & 0 \\\\ \\frac{1}{2.05} & 0 \\end{bmatrix} = \\begin{bmatrix} 1 - \\frac{2.01}{2.05} & 0 \\\\ -\\frac{1}{2.05} & 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{0.04}{2.05} & 0 \\\\ -\\frac{1}{2.05} & 1 \\end{bmatrix}\n$$\n现在我们执行最后的矩阵乘法：\n$$\nP_{1|1} = \\begin{bmatrix} \\frac{0.04}{2.05} & 0 \\\\ -\\frac{1}{2.05} & 1 \\end{bmatrix} \\begin{bmatrix} 2.01 & 1 \\\\ 1 & 1.01 \\end{bmatrix}\n$$\n$$\nP_{1|1} = \\begin{bmatrix} (\\frac{0.04}{2.05})(2.01) + (0)(1) & (\\frac{0.04}{2.05})(1) + (0)(1.01) \\\\ (-\\frac{1}{2.05})(2.01) + (1)(1) & (-\\frac{1}{2.05})(1) + (1)(1.01) \\end{bmatrix}\n$$\n$$\nP_{1|1} = \\begin{bmatrix} \\frac{0.0804}{2.05} & \\frac{0.04}{2.05} \\\\ \\frac{-2.01 + 2.05}{2.05} & \\frac{-1 + 1.01 \\cdot 2.05}{2.05} \\end{bmatrix} = \\begin{bmatrix} \\frac{0.0804}{2.05} & \\frac{0.04}{2.05} \\\\ \\frac{0.04}{2.05} & \\frac{1.0705}{2.05} \\end{bmatrix}\n$$\n问题要求将矩阵元素四舍五入到 $4$ 位有效数字。\n$$\nP_{1|1}(1,1) = \\frac{0.0804}{2.05} \\approx 0.0392195 \\dots \\approx 0.03922\n$$\n$$\nP_{1|1}(1,2) = P_{1|1}(2,1) = \\frac{0.04}{2.05} \\approx 0.0195121 \\dots \\approx 0.01951\n$$\n$$\nP_{1|1}(2,2) = \\frac{1.0705}{2.05} \\approx 0.5221951 \\dots \\approx 0.5222\n$$\n因此，在 $k=1$ 时的后验误差协方差矩阵为：\n$$\nP_{1|1} \\approx \\begin{bmatrix} 0.03922 & 0.01951 \\\\ 0.01951 & 0.5222 \\end{bmatrix}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.03922 & 0.01951 \\\\ 0.01951 & 0.5222 \\end{pmatrix}}\n$$", "id": "2888322"}, {"introduction": "从理论计算走向实际应用，最后一个练习探讨了卡尔曼滤波的一个关键挑战：模型参数的设定和调整。这个基于代码的仿真任务旨在研究当测量噪声协方差 $R$ 被错误设定时滤波器的行为。通过亲手实现并分析结果，你将直观地理解为何高估噪声会导致滤波器输出变得过于平滑且滞后于真实状态，这对于在现实世界中有效应用卡尔曼滤波器至关重要 [@problem_id:2441505]。", "problem": "要求您研究在线性高斯状态空间模型中，错误设定测量噪声协方差所产生的影响。该模型常用于计算经济学和金融学领域。考虑一个潜在的宏观经济状态，其遵循一阶自回归 (AR(1)) 运动定律，并且其观测值带有噪声。该潜在状态可以被解释为潜在产出缺口或动态因子模型中的一个潜在因子。数据生成过程由以下线性高斯状态空间模型定义：\n- 状态转移：$x_{t} = \\phi x_{t-1} + w_{t}$，其中 $w_{t} \\sim \\mathcal{N}(0, Q)$。\n- 测量：$y_{t} = x_{t} + v_{t}$，其中 $v_{t} \\sim \\mathcal{N}(0, R_{\\text{true}})$。\n\n您将实现卡尔曼滤波器 (KF)，以在两种设定下根据 $y_{t}$ 生成 $x_{t}$ 的滤波估计 $x_{t|t}$：一种设定使用正确的测量噪声方差 $R_{\\text{true}}$，另一种设定使用一个被错误夸大的方差 $R_{\\text{hat}} = \\lambda R_{\\text{true}}$（其中 $\\lambda \\ge 1$），后者代表了一位认为测量值比实际情况含有更多噪声的分析师。滤波器的起始先验必须是高斯分布，其均值为 $0$，方差为 $P_{0} = Q/(1-\\phi^{2})$（即当 $\\lvert \\phi \\rvert < 1$ 时 AR(1) 过程的无条件方差）。假设 $x_{0} = 0$。模拟中的噪声必须在时间上是独立的，并且在状态方程和测量方程之间也是独立的。\n\n您的任务：\n1. 针对提供的测试套件中的每一组参数，使用指定的随机种子从模型中模拟 $t = 1, \\dots, T$ 的 $(x_{t}, y_{t})$，以确保可复现性。使用具有指定方差的独立抽样来生成 $w_{t}$ 和 $v_{t}$。\n2. 从第一性原理出发，实现适用于线性高斯系统的时间递归线性最小均方误差估计器（即卡尔曼滤波器），并对每一组参数运行两次：一次使用 $R_{\\text{true}}$，另一次使用 $R_{\\text{hat}} = \\lambda R_{\\text{true}}$（其中 $\\lambda \\ge 1$）。\n3. 对于每一组参数，通过计算以下三个指标来量化夸大 $R$ 对滤波器的影响：\n   - 均方误差差值：$\\Delta \\text{MSE} = \\frac{1}{T}\\sum_{t=1}^{T} (x_{t} - \\hat{x}^{(\\text{mis})}_{t|t})^{2} - \\frac{1}{T}\\sum_{t=1}^{T} (x_{t} - \\hat{x}^{(\\text{true})}_{t|t})^{2}$，其中 $\\hat{x}^{(\\text{mis})}_{t|t}$ 是使用 $R_{\\text{hat}}$ 得到的滤波估计，而 $\\hat{x}^{(\\text{true})}_{t|t}$ 是使用 $R_{\\text{true}}$ 得到的滤波估计。\n   - 错误设定的滤波器的估计滞后周期：$\\ell^{\\ast} = \\arg\\max_{\\ell \\in \\{0,1,\\dots,L_{\\max}\\}} \\mathrm{corr}(x_{t}, \\hat{x}^{(\\text{mis})}_{t-\\ell|t-\\ell})$，其通过经验计算得出，即在所有两者均有定义的 $t$ 上，$x_{t}$ 与移动了 $\\ell$ 个周期的滤波序列之间的样本相关性。使用 $L_{\\max} = 10$。\n   - 通过方差比反映的平滑度差异：$\\Delta \\text{VR} = \\frac{\\mathrm{Var}(\\hat{x}^{(\\text{mis})}_{t|t})}{\\mathrm{Var}(x_{t})} - \\frac{\\mathrm{Var}(\\hat{x}^{(\\text{true})}_{t|t})}{\\mathrm{Var}(x_{t})}$，其中方差是 $t=1,\\dots,T$ 上的经验样本方差。\n4. 在您的解决方案中，从第一性原理出发，解释为什么夸大 $R$ 会减小卡尔曼增益，并因此产生更平滑、更滞后的估计值。\n\n测试套件：\n对于每个元组 $(\\phi, Q, R_{\\text{true}}, \\lambda, T, \\text{seed})$，模拟并计算上述三个指标。\n- 案例 A (一般情况): $(\\phi, Q, R_{\\text{true}}, \\lambda, T, \\text{seed}) = (0.9, 0.05, 0.2, 5.0, 200, 123)$。\n- 案例 B (高信噪比，重度夸大): $(0.9, 0.05, 0.05, 10.0, 200, 456)$。\n- 案例 C (近单位根状态): $(0.99, 0.02, 0.1, 8.0, 300, 789)$。\n- 案例 D (高过程波动性): $(0.6, 0.2, 0.2, 5.0, 200, 321)$。\n- 案例 E (边界，正确设定): $(0.9, 0.05, 0.2, 1.0, 200, 999)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果。每个内部列表按上述顺序对应一个案例，并包含三个值：$[\\Delta \\text{MSE}, \\ell^{\\ast}, \\Delta \\text{VR}]$。第一个和第三个条目是四舍五入到六位小数的浮点数；中间的条目是整数。例如：$[[0.012345,2,-0.123456],[\\dots],\\dots]$。\n- 不应打印任何额外文本。", "solution": "该问题要求对卡尔曼滤波器进行原则性推导，并分析其在测量噪声协方差错误设定下的行为。\n\n首先，我们将此标量系统的状态空间模型形式化。状态方程为：\n$$ x_{t} = \\phi x_{t-1} + w_{t}, \\quad w_{t} \\sim \\mathcal{N}(0, Q) $$\n测量方程为：\n$$ y_{t} = x_{t} + v_{t}, \\quad v_{t} \\sim \\mathcal{N}(0, R) $$\n在这里，测量矩阵 $H$ 是单位矩阵，我们表示为 $1$。状态转移矩阵 $F$ 是标量 $\\phi$。\n\n卡尔曼滤波器提供了一个递归算法，用于在给定截至时间 $t$ 的观测值的情况下，计算状态 $x_t$ 的最优线性估计，记为 $\\hat{x}_{t|t} = \\mathbb{E}[x_t | y_1, \\dots, y_t]$。该算法在每个时间增量中分两步进行：预测和更新。\n\n递归在 $t=0$ 时用先验估计 $\\hat{x}_{0|0}$ 及其误差协方差 $P_{0|0} = \\mathbb{E}[(x_0 - \\hat{x}_{0|0})^2]$ 进行初始化。问题指定使用平稳先验，因此我们设置 $\\hat{x}_{0|0} = 0$ 和 $P_{0|0} = Q / (1 - \\phi^2)$。\n\n对于 $t = 1, 2, \\dots, T$：\n\n1.  **预测（时间更新）：**此步骤将状态和协方差估计从时间 $t-1$ 投影到时间 $t$。\n    - 预测的状态估计为：\n      $$ \\hat{x}_{t|t-1} = \\phi \\hat{x}_{t-1|t-1} $$\n    - 预测的误差协方差为：\n      $$ P_{t|t-1} = \\phi^{2} P_{t-1|t-1} + Q $$\n\n2.  **更新（测量更新）：**此步骤结合新的测量值 $y_t$ 来修正预测的估计。\n    - 新息（innovation）或测量残差，是实际测量值与其预测值之间的差值：\n      $$ \\nu_t = y_t - \\hat{x}_{t|t-1} $$\n    - 新息协方差为：\n      $$ S_t = P_{t|t-1} + R $$\n    - 最优卡尔曼增益 $K_t$ 决定了赋予新息多大的权重。它的计算旨在最小化后验误差协方差 $P_{t|t}$：\n      $$ K_t = \\frac{P_{t|t-1}}{S_t} = \\frac{P_{t|t-1}}{P_{t|t-1} + R} $$\n    - 更新后（滤波后）的状态估计是预测估计和测量信息的加权平均值：\n      $$ \\hat{x}_{t|t} = \\hat{x}_{t|t-1} + K_t \\nu_t $$\n    - 更新后的误差协方差为：\n      $$ P_{t|t} = (1 - K_t) P_{t|t-1} $$\n\n现在，考虑错误设定 $R$ 的影响。分析师使用 $R_{\\text{hat}} = \\lambda R_{\\text{true}}$（其中 $\\lambda > 1$），认为测量值比实际情况含有更多的噪声。这解决了任务 4。\n\n在这种错误设定下的卡尔曼增益变为：\n$$ \\hat{K}_t = \\frac{\\hat{P}_{t|t-1}}{\\hat{P}_{t|t-1} + R_{\\text{hat}}} = \\frac{\\hat{P}_{t|t-1}}{\\hat{P}_{t|t-1} + \\lambda R_{\\text{true}}} $$\n注意，由于递归，$\\hat{P}_{t|t-1}$ 也会与真实模型的 $P_{t|t-1}$ 不同。然而，对于任何给定的预测协方差值 $\\hat{P}_{t|t-1} > 0$，增加分母中 $R$ 的值会严格减小增益 $K_t$。由于 $\\lambda > 1$，因此 $R_{\\text{hat}} > R_{\\text{true}}$，这通常会导致 $\\hat{K}_t  K_t$。\n\n状态更新方程可以重写为：\n$$ \\hat{x}_{t|t} = (1 - K_t) \\hat{x}_{t|t-1} + K_t y_t $$\n一个较小的增益 $\\hat{K}_t$ 会减少对新传入的测量值 $y_t$ 的权重，反之，会增加对先验估计 $\\hat{x}_{t|t-1}$ 的权重 $(1 - \\hat{K}_t)$，而后者完全基于过去的信息。\n\n这会带来两个主要后果：\n1.  **更平滑的估计：**通过在每一步中降低噪声测量值 $y_t$ 的权重，滤波序列 $\\hat{x}^{(\\text{mis})}_{t|t}$ 对数据的短期波动的响应会减弱。由于估计值通过预测步骤更牢固地锚定于其自身的过去值，因此其演化会更缓慢、更平滑。这导致滤波序列的方差降低，该效应由指标 $\\Delta \\text{VR}$ 衡量。\n2.  **更滞后的估计：**由于滤波器吸收新信息的速度变慢，它需要更长的时间来对潜在真实状态 $x_t$ 的真实变化做出反应。如果 $x_t$ 经历持续性变化，滤波估计 $\\hat{x}^{(\\text{mis})}_{t|t}$ 将比正确设定的滤波器“追赶”得更慢。这表现为真实状态序列与滤波序列之间的时间滞后，该效应由指标 $\\ell^{\\ast}$ 捕获。", "answer": "```python\nimport numpy as np\n\ndef kalman_filter(y_obs, phi, Q, R, x0_hat, P0_hat):\n    \"\"\"\n    Implements a scalar Kalman filter for a linear Gaussian state-space model.\n\n    Args:\n        y_obs (np.ndarray): Array of observations.\n        phi (float): Autoregressive parameter in the state equation.\n        Q (float): Variance of the state noise.\n        R (float): Variance of the measurement noise.\n        x0_hat (float): Initial state estimate.\n        P0_hat (float): Initial estimate variance.\n\n    Returns:\n        np.ndarray: Filtered state estimates x_t|t.\n    \"\"\"\n    T = len(y_obs)\n    x_filtered = np.zeros(T)\n    \n    # Initialize with the posterior at t=0\n    x_curr_post = x0_hat\n    P_curr_post = P0_hat\n\n    for t in range(T):\n        # Prediction step\n        x_pred = phi * x_curr_post\n        P_pred = phi**2 * P_curr_post + Q\n\n        # Update step\n        innovation = y_obs[t] - x_pred\n        innovation_cov = P_pred + R\n        kalman_gain = P_pred / innovation_cov\n\n        x_filtered[t] = x_pred + kalman_gain * innovation\n        P_curr_post = (1 - kalman_gain) * P_pred\n        x_curr_post = x_filtered[t]\n\n    return x_filtered\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating data, running Kalman filters, and computing metrics.\n    \"\"\"\n    test_cases = [\n        # (phi, Q, R_true, lambda, T, seed)\n        (0.9, 0.05, 0.2, 5.0, 200, 123),\n        (0.9, 0.05, 0.05, 10.0, 200, 456),\n        (0.99, 0.02, 0.1, 8.0, 300, 789),\n        (0.6, 0.2, 0.2, 5.0, 200, 321),\n        (0.9, 0.05, 0.2, 1.0, 200, 999),\n    ]\n\n    results = []\n    L_max = 10\n\n    for case in test_cases:\n        phi, Q, R_true, lambda_val, T, seed = case\n        \n        # 1. Simulate data from the true model\n        rng = np.random.default_rng(seed)\n        w = rng.normal(0, np.sqrt(Q), size=T)\n        v = rng.normal(0, np.sqrt(R_true), size=T)\n        \n        x_true = np.zeros(T + 1) # x_0, ..., x_T\n        y_obs = np.zeros(T)      # y_1, ..., y_T\n        \n        # x_0 = 0 is given\n        for t in range(1, T + 1):\n            x_true[t] = phi * x_true[t-1] + w[t-1]\n            y_obs[t-1] = x_true[t] + v[t-1]\n        \n        x_true_series = x_true[1:] # We care about x_1, ..., x_T\n\n        # 2. Run Kalman filter with correct and misspecified R\n        R_hat = lambda_val * R_true\n        \n        # Initial prior for the filter at t=0\n        x0_hat = 0.0\n        P0_hat = Q / (1 - phi**2)\n        \n        x_hat_true = kalman_filter(y_obs, phi, Q, R_true, x0_hat, P0_hat)\n        x_hat_mis = kalman_filter(y_obs, phi, Q, R_hat, x0_hat, P0_hat)\n        \n        # 3. Compute metrics\n        \n        # Delta MSE\n        mse_true = np.mean((x_true_series - x_hat_true)**2)\n        mse_mis = np.mean((x_true_series - x_hat_mis)**2)\n        delta_mse = mse_mis - mse_true\n        \n        # Estimated Lag\n        correlations = []\n        for l in range(L_max + 1):\n            if l == 0:\n                series1 = x_true_series\n                series2 = x_hat_mis\n            else:\n                series1 = x_true_series[l:]\n                series2 = x_hat_mis[:-l]\n            \n            # np.corrcoef returns a 2x2 matrix, we need the off-diagonal element\n            corr = np.corrcoef(series1, series2)[0, 1]\n            correlations.append(corr)\n            \n        lag_star = int(np.argmax(correlations))\n        \n        # Delta Variance Ratio\n        var_x_true = np.var(x_true_series)\n        var_x_hat_true = np.var(x_hat_true)\n        var_x_hat_mis = np.var(x_hat_mis)\n        \n        if var_x_true > 1e-9: # Avoid division by zero for flat series\n            vr_true = var_x_hat_true / var_x_true\n            vr_mis = var_x_hat_mis / var_x_true\n            delta_vr = vr_mis - vr_true\n        else:\n            delta_vr = 0.0\n\n        results.append([round(delta_mse, 6), lag_star, round(delta_vr, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(str(r) for r in results)}]]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2441505"}]}