{"hands_on_practices": [{"introduction": "面对一个目标，是采取小而稳健的“耐心策略”，还是孤注一掷的“大胆策略”？这个问题不仅是赌徒的困境，也出现在投资和项目决策中。这个练习将使用赌徒破产模型来量化比较这两种策略，并揭示一个深刻的结论：最优选择取决于你是否在游戏中占有优势 ($p > 0.5$)。通过这个练习，你将学会如何应用概率模型来指导现实世界中的策略选择。[@problem_id:1326619]", "problem": "一名玩家带着 $i=5$ 单位的初始资本进入一个序贯投注游戏。玩家的目标是达到 $N=10$ 单位的总财富。如果玩家的资本达到10单位的目标（获胜）或0单位（破产），游戏结束。在每一轮独立的游戏中，玩家赢得赌注的概率为 $p$，其中 $p \\in (0, 1)$。玩家正在考虑两种不同的投注策略：\n\n1.  **耐心策略 (Patient Strategy)**：在每一轮中，玩家投注一个单位。他们以概率 $p$ 赢得1个单位，以概率 $1-p$ 输掉1个单位。如此持续直到游戏结束。\n2.  **大胆策略 (Bold Strategy)**：玩家在单单一轮“全有或全无”的博弈中，押上他们全部的5单位初始资本。如果他们赢了，他们的资本变为10单位，实现目标。如果他们输了，他们的资本变为0，宣告破产。\n\n假设玩家的目标是最大化达到目标资本的概率，以下哪个陈述根据获胜概率 $p$ 正确地描述了最优策略选择？\n\nA. 对于所有 $p \\in (0, 1)$，大胆策略都严格优于耐心策略。\n\nB. 对于所有 $p \\in (0, 1)$，耐心策略都严格优于大胆策略。\n\nC. 如果 $p \\le 0.5$，大胆策略是更好或等效的选择；如果 $p > 0.5$，耐心策略是更好的选择。\n\nD. 如果 $p \\le 0.5$，耐心策略是更好或等效的选择；如果 $p > 0.5$，大胆策略是更好的选择。\n\nE. 无论 $p$ 的值是多少，两种策略产生的成功概率总是完全相同。", "solution": "令 $q=1-p$。在耐心策略下，玩家的财富在 $\\{0,1,\\dots,10\\}$ 上进行一个有偏的随机游走，其吸收态为 $0$ 和 $10$。令 $u_{i}$ 表示从状态 $i$ 开始，在到达 0 之前先到达 10 的概率。标准的赌徒破产问题差分方程和边界条件是\n$$\nu_{i}=p\\,u_{i+1}+q\\,u_{i-1},\\quad u_{0}=0,\\quad u_{10}=1.\n$$\n对于 $p\\neq \\frac{1}{2}$，解为\n$$\nu_{i}=\\frac{1-\\left(\\frac{q}{p}\\right)^{i}}{1-\\left(\\frac{q}{p}\\right)^{10}},\\quad\\text{而对于 }p=\\frac{1}{2},\\;u_{i}=\\frac{i}{10}.\n$$\n当 $i=5$ 时，我们得到对于 $p\\neq \\frac{1}{2}$ 的情况：\n$$\nP_{\\text{pat}}=\\frac{1-\\left(\\frac{q}{p}\\right)^{5}}{1-\\left(\\frac{q}{p}\\right)^{10}}=\\frac{1}{1+\\left(\\frac{q}{p}\\right)^{5}}=\\frac{p^{5}}{p^{5}+q^{5}},\n$$\n而对于 $p=\\frac{1}{2}$，$P_{\\text{pat}}=\\frac{1}{2}$，这通过连续性与上述表达式一致。\n\n在大胆策略下，玩家一次性下注 $5$，并以概率 $p$ 获胜，立即达到 $10$，所以\n$$\nP_{\\text{bold}}=p.\n$$\n\n为了比较，考虑不等式 $P_{\\text{bold}}\\ge P_{\\text{pat}}$：\n$$\np\\ge \\frac{p^{5}}{p^{5}+q^{5}}\n\\;\\Longleftrightarrow\\;\np\\left(p^{5}+q^{5}\\right)\\ge p^{5}\n\\;\\Longleftrightarrow\\;\np q^{5}\\ge p^{5}(1-p)=p^{5}q.\n$$\n对于 $p\\in(0,1)$，两边同除以 $pq>0$ 得到\n$$\nq^{4}\\ge p^{4}\\;\\Longleftrightarrow\\;q\\ge p\\;\\Longleftrightarrow\\;p\\le \\frac{1}{2}.\n$$\n因此：\n- 如果 $p<\\frac{1}{2}$，那么 $P_{\\text{bold}}>P_{\\text{pat}}$。\n- 如果 $p=\\frac{1}{2}$，那么 $P_{\\text{bold}}=P_{\\text{pat}}=\\frac{1}{2}$。\n- 如果 $p>\\frac{1}{2}$，那么 $P_{\\text{bold}}<P_{\\text{pat}}$。\n\n所以，如果 $p\\le \\frac{1}{2}$，大胆策略更好或等效；如果 $p>\\frac{1}{2}$，耐心策略更好。", "answer": "$$\\boxed{C}$$", "id": "1326619"}, {"introduction": "我们已经看到了策略选择如何影响成功概率，但问题的“规模”本身又扮演着什么角色呢？本练习设计了一个思想实验，比较两位初始资本和目标都成比例缩放的赌徒。直觉上，他们的成功概率可能看起来有简单的关系，但通过运用破产概率公式，你将发现一个更微妙的结论。这个练习旨在加深你对破产公式中各参数非线性关系的理解。[@problem_id:1326643]", "problem": "两位赌徒，A 和 B，在一个赌场里玩一种机会游戏。在每一轮中，赌徒下注一个固定的金额。赌徒以概率 $p$ 赢得该轮，并以概率 $q = 1-p$ 输掉该轮，其中 $p \\neq 1/2$。\n\n赌徒 A 的初始资本为 $i$ 个单位，其中 $i$ 是一个正偶数。他们的目标是达到 $2i$ 个单位的总资本。如果他们达到这个目标或他们的资本变为零，他们就停止游戏。\n\n赌徒 B 的初始资本为 $i/2$ 个单位。他们的目标是达到 $i$ 个单位的总资本。如果他们达到目标或资本变为零，他们也停止游戏。\n\n设 $P_A$ 为赌徒 A 成功的概率，$P_B$ 为赌徒 B 成功的概率。求比率 $\\frac{P_A}{P_B}$。请用 $p$、$q$ 和 $i$ 将你的答案表示为一个单一的闭式解析表达式。", "solution": "将每个赌徒的资本建模为一个有偏的简单随机游走，步长为+1的概率是 $p$，步长为-1的概率是 $q=1-p$，在 $0$ 和目标处被吸收。对于一个在 $0$ 和 $N$ 处有吸收壁、从 $k$ 开始且 $p \\neq q$ 的游走，经典的赌徒破产问题中的成功概率是\n$$\nP_{\\text{hit }N\\text{ before }0}(k)=\\frac{1-\\left(\\frac{q}{p}\\right)^{k}}{1-\\left(\\frac{q}{p}\\right)^{N}}.\n$$\n为简洁起见，引入 $r=\\frac{q}{p}$。\n\n赌徒 A 从 $k=i$ 开始，目标为 $N=2i$，因此\n$$\nP_{A}=\\frac{1-r^{i}}{1-r^{2i}}.\n$$\n赌徒 B 从 $k=\\frac{i}{2}$ 开始，目标为 $N=i$，因此\n$$\nP_{B}=\\frac{1-r^{i/2}}{1-r^{i}}.\n$$\n因此，\n$$\n\\frac{P_{A}}{P_{B}}=\\frac{\\frac{1-r^{i}}{1-r^{2i}}}{\\frac{1-r^{i/2}}{1-r^{i}}}\n=\\frac{(1-r^{i})^{2}}{(1-r^{2i})(1-r^{i/2})}.\n$$\n使用代数恒等式 $1-r^{2i}=(1-r^{i})(1+r^{i})$ 以及，因为 $i$ 是偶数，$1-r^{i}=(1-r^{i/2})(1+r^{i/2})$ 来简化：\n$$\n\\frac{P_{A}}{P_{B}}=\\frac{1-r^{i}}{(1+r^{i})(1-r^{i/2})}\n=\\frac{(1-r^{i/2})(1+r^{i/2})}{(1+r^{i})(1-r^{i/2})}\n=\\frac{1+r^{i/2}}{1+r^{i}}.\n$$\n恢复 $r=\\frac{q}{p}$ 得到闭式形式\n$$\n\\frac{P_{A}}{P_{B}}=\\frac{1+\\left(\\frac{q}{p}\\right)^{i/2}}{1+\\left(\\frac{q}{p}\\right)^{i}}.\n$$", "answer": "$$\\boxed{\\frac{1+\\left(\\frac{q}{p}\\right)^{i/2}}{1+\\left(\\frac{q}{p}\\right)^{i}}}$$", "id": "1326643"}, {"introduction": "理论公式为我们提供了精确的概率预测，但我们如何确信这些抽象的数学结果能够准确描述随机过程的真实行为？最后的这个动手实践将带你从纸笔分析走向计算机模拟。通过编写程序来模拟成千上万次赌徒的随机游走过程，你将能够计算出经验破产概率，并将其与理论预测进行直接比较。这不仅是验证数学模型的强大方法，也是连接理论与实践的桥梁。[@problem_id:2445753]", "problem": "考虑赌徒破产问题中的一维随机游走资本模型。赌徒在第 $t$ 步后的资本是一个离散时间随机过程 $\\{X_t\\}_{t \\ge 0}$，其状态空间为有限集合 $\\{0,1,2,\\dots,N\\}$，在 $0$ 和 $N$ 处有吸收边界。在每个时间步，只要资本未达到边界，其资本便以概率 $p$ 增加 $+1$，以概率 $q=1-p$ 减少 $-1$，且此变化与过去无关。初始资本为 $X_0=i$。如果过程触及 $0$，赌徒破产；如果触及 $N$，赌徒达到目标。本问题中所有概率均为无量纲。\n\n你的任务是编写一个完整、可运行的程序，完成以下操作：\n\n1) 仅使用模型的基本定义和全概率定律，从第一性原理出发，推导并实现破产的解析概率，记为 $r_i=\\mathbb{P}(\\text{ruin}\\mid X_0=i)$。推导必须从边界条件 $r_0=1$ 和 $r_N=0$以及针对 $0<i<N$ 的第一步关系式开始。不要使用任何预先记好的最终公式；相反，应求解所得的带边界条件的线性差分方程，以获得一个封闭形式的表达式，然后将其在代码中实现。\n\n2) 通过模拟 $M$ 条独立的样本路径直至被吸收，并计算破产的经验频率，来实现破产概率的蒙特卡洛估计器。使用带有固定种子 $s$ 的伪随机数生成器以确保可复现性。\n\n3) 对于下方的每个测试用例，计算解析破产概率和蒙特卡洛估计值，并返回一个布尔值，该值表示两者之间的绝对误差是否在容差 $\\varepsilon$之内。\n\n你必须使用的基础理论：\n- 应用于随机游走第一步的全概率定律。\n- 吸收态的边界条件。\n- 求解带有边界值的常系数线性差分方程的标准代数方法。\n\n蒙特卡洛估计器规范：\n- 对于每次独立试验，从 $X_0=i$ 开始，并以概率 $p$ 步进 $+1$、以概率 $q=1-p$ 步进 $-1$ 来演化 $X_t$，直到 $X_t \\in \\{0,N\\}$。记录 $X_t$ 是在到达 $N$ 之前到达 $0$。估计器是最终破产的试验所占的比例。\n\n可复现性：\n- 对所有模拟，伪随机数生成器均使用单一的固定种子 $s=123456$。\n\n验收标准：\n- 设 $\\hat{r}_i$ 为蒙特卡洛估计值，$r_i$ 为解析值。如果 $|\\hat{r}_i - r_i| \\le \\varepsilon$（其中 $\\varepsilon=0.02$），则测试用例通过。\n\n测试套件：\n为以下参数集 $(N,i,p,M)$ 提供结果：\n- 情况 A (一般情况，公平博弈): $(N,i,p,M)=(10,3,0.5,20000)$。\n- 情况 B (边界：立即破产): $(N,i,p,M)=(10,0,0.5,1000)$。\n- 情况 C (边界：立即成功): $(N,i,p,M)=(10,10,0.5,1000)$。\n- 情况 D (偏向成功): $(N,i,p,M)=(50,10,0.7,20000)$。\n- 情况 E (偏向破产): $(N,i,p,M)=(50,10,0.3,20000)$。\n- 情况 F (更大状态空间，公平博弈): $(N,i,p,M)=(100,50,0.5,5000)$。\n\n输出格式：\n- 你的程序应生成单行输出，其中包含六个情况的结果，形式为方括号内由逗号分隔的布尔值列表，且无空格。例如：“[True,False,True,True,True,False]”。\n\n注意：以上出现的所有数值参数，如 $0$、$1$、$0.5$、$10$、$50$、$100$、$20000$、$1000$、$5000$、$0.02$ 和 $123456$，都是测试规范的一部分，必须严格按给定的值使用。除了无量纲的概率外，不涉及任何角度或物理单位。", "solution": "该问题陈述是计算物理学和概率论中的一个有效练习。它描述了经典的一维赌徒破产问题，这是一个具有唯一解析解的适定模型。该问题是自洽的，提供了所有必要的参数和定义，其组成部分——推导解析解并与蒙特卡洛模拟进行比较——是标准且科学上合理的步骤。该问题没有歧义、事实错误和主观断言。因此，我们将着手解决它。\n\n解决方案分为三个部分：第一，解析破产概率的推导；第二，蒙特卡洛估计器的规范；第三，针对给定测试套件比较两者的实现逻辑。\n\n_1. 解析破产概率的推导_\n\n设 $r_i$ 为初始资本为 $X_0 = i$ 时的破产概率，其中资本的状态空间为 $\\{0, 1, 2, \\dots, N\\}$。状态 $0$ 和 $N$ 是吸收态。\n\n边界条件由这些吸收态的性质定义：\n- 如果初始资本为 $i=0$，赌徒已经破产。因此，破产概率为 $1$。\n  $$r_0 = 1$$\n- 如果初始资本为 $i=N$，赌徒已经达到目标，不会再破产。因此，破产概率为 $0$。\n  $$r_N = 0$$\n\n对于任何非边界状态 $i \\in \\{1, 2, \\dots, N-1\\}$，我们可以通过应用全概率定律，对第一步的结果进行条件化，从而为 $r_i$ 建立一个递推关系。从状态 $i$ 出发，一步之后，资本或以概率 $p$ 变为 $i+1$，或以概率 $q=1-p$ 变为 $i-1$。由于过程的无记忆性，从这些新状态出发的破产概率分别为 $r_{i+1}$ 和 $r_{i-1}$。这导出了以下关系：\n$$r_i = p \\cdot r_{i+1} + q \\cdot r_{i-1}$$\n这可以重写为一个二阶线性常系数齐次差分方程：\n$$p r_{i+1} - r_i + q r_{i-1} = 0$$\n为了解此方程，我们寻求 $r_i = \\lambda^i$ 形式的解。将此代入方程得到特征方程：\n$$p \\lambda^2 - \\lambda + q = 0$$\n该二次方程的根由 $\\lambda = \\frac{1 \\pm \\sqrt{1 - 4pq}}{2p}$ 给出。由于 $q=1-p$，判别式简化为 $1 - 4p(1-p) = 1 - 4p + 4p^2 = (1-2p)^2$。\n因此，根为：\n$$\\lambda_1 = \\frac{1 + (1-2p)}{2p} = \\frac{2 - 2p}{2p} = \\frac{1-p}{p} = \\frac{q}{p}$$\n$$\\lambda_2 = \\frac{1 - (1-2p)}{2p} = \\frac{2p}{2p} = 1$$\n\n我们必须根据这两个根是否相异来考虑两种情况。\n\n_情况1：非公平博弈 ($p \\neq 0.5$)_\n如果 $p \\neq 0.5$，则 $p \\neq q$，根 $\\lambda_1 = q/p$ 和 $\\lambda_2 = 1$ 是相异的。该差分方程的通解是基本解的线性组合：\n$$r_i = A (\\frac{q}{p})^i + B (1)^i = A (\\frac{q}{p})^i + B$$\n常数 $A$ 和 $B$ 由边界条件 $r_0=1$ 和 $r_N=0$ 决定。\n对于 $i=0$：$r_0 = A(\\frac{q}{p})^0 + B = A+B = 1$。\n对于 $i=N$：$r_N = A(\\frac{q}{p})^N + B = 0$。\n解这个线性方程组，我们得到 $B = 1-A$，代入得 $A(\\frac{q}{p})^N + (1-A) = 0$，所以 $A( (\\frac{q}{p})^N - 1 ) = -1$。\n这得出 $A = \\frac{1}{1-(q/p)^N}$ 且 $B = 1 - A = \\frac{-(q/p)^N}{1-(q/p)^N}$。\n将 $A$ 和 $B$ 代回通解，我们得到 $p \\neq 0.5$ 时的破产概率：\n$$r_i = \\frac{(q/p)^i - (q/p)^N}{1 - (q/p)^N}$$\n\n_情况2：公平博弈 ($p = 0.5$)_\n如果 $p = 0.5$，则 $q=0.5$ 且 $\\lambda_1 = \\lambda_2 = 1$。特征方程有一个重根。在这种情况下，通解的形式为：\n$$r_i = A(1)^i + B \\cdot i \\cdot (1)^i = A + Bi$$\n我们再次使用边界条件 $r_0=1$ 和 $r_N=0$ 来求解常数 $A$ 和 $B$。\n对于 $i=0$：$r_0 = A + B(0) = A = 1$。\n对于 $i=N$：$r_N = A + BN = 1 + BN = 0$，这意味着 $B = -1/N$。\n将 $A$ 和 $B$ 代回，我们得到 $p = 0.5$ 时的破产概率：\n$$r_i = 1 - \\frac{i}{N} = \\frac{N-i}{N}$$\n\n这些推导出的公式为破产概率 $r_i$ 提供了完整的解析解。\n\n_2. 蒙特卡洛估计器设计_\n\n蒙特卡洛方法通过模拟大量的随机游走，为破产概率 $\\hat{r}_i$ 提供一个数值估计。对于 $M$ 次独立试验中的每一次：\n1.  将赌徒的资本初始化为起始值 $X_0 = i$。\n2.  如果 $i=0$ 或 $i=N$，则结果已预先确定为破产或成功。\n3.  对于 $0 < i < N$，逐步模拟游走过程。在每个时间步 $t$，从均匀分布 $U(0,1)$ 中生成一个伪随机数 $u$。\n    - 如果 $u < p$，资本更新为：$X_{t+1} = X_t + 1$。\n    - 如果 $u \\ge p$，资本更新为：$X_{t+1} = X_t - 1$。\n4.  这个过程持续进行，直到资本 $X_t$ 到达任一吸收边界 $0$ 或 $N$。\n5.  如果游走在状态 $0$ 终止，则该次试验被记录为“破产”。如果在状态 $N$ 终止，则为“成功”。\n\n完成 $M$ 次试验后，估计器 $\\hat{r}_i$ 是破产的经验频率：\n$$\\hat{r}_i = \\frac{\\text{以破产告终的试验次数}}{\\text{总试验次数, } M}$$\n为确保结果的可复现性，在为每个测试用例运行模拟之前，使用固定的种子 $s=123456$ 初始化伪随机数生成器。\n\n_3. 实现与比较_\n\n最终的程序将实现两个函数，分别对应于解析解和蒙特卡洛估计器。一个主程序将遍历所提供的测试套件。对于每个参数集 $(N, i, p, M)$：\n- 边界情况 $i=0$ 和 $i=N$ 被直接处理。根据定义，解析解为 $r_0=1, r_N=0$。蒙特卡洛估计器也将在不进行模拟的情况下返回这些值。\n- 对于 $0 < i < N$，计算 $r_i$ 的解析公式（取决于 $p$ 是否等于 $0.5$）。\n- 通过使用指定的参数和固定的种子 $s=123456$ 运行 $M$ 次模拟，计算蒙特卡洛估计器 $\\hat{r}_i$。\n- 计算绝对误差 $|\\hat{r}_i - r_i|$ 并与容差 $\\varepsilon=0.02$ 进行比较。\n- 为每种情况确定一个布尔值，如果误差在容差范围内则为 `True`，否则为 `False`。\n- 程序的最终输出是按指定格式化的、由这些布尔值组成的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gambler's Ruin problem for a suite of test cases.\n    It calculates the analytical ruin probability and a Monte Carlo estimate,\n    then checks if the estimate is within a specified tolerance of the analytical value.\n    \"\"\"\n\n    def analytical_ruin_prob(N: int, i: int, p: float) -> float:\n        \"\"\"\n        Calculates the analytical ruin probability r_i.\n\n        Args:\n            N: The goal capital.\n            i: The initial capital.\n            p: The probability of winning a single bet.\n\n        Returns:\n            The analytical probability of ruin.\n        \"\"\"\n        if i <= 0:\n            return 1.0\n        if i >= N:\n            return 0.0\n\n        # Using a small tolerance for floating point comparison of p with 0.5\n        if abs(p - 0.5) < 1e-9:\n            # Case for a fair game (p = 0.5)\n            return (N - i) / N\n        else:\n            # Case for a biased game (p != 0.5)\n            q = 1.0 - p\n            rho = q / p\n            # The formula is robust and does not require special handling\n            # for rho > 1 or rho < 1, as long as rho != 1.\n            return (rho**i - rho**N) / (1 - rho**N)\n\n    def monte_carlo_estimator(N: int, i: int, p: float, M: int, seed: int) -> float:\n        \"\"\"\n        Estimates the ruin probability using a Monte Carlo simulation.\n\n        Args:\n            N: The goal capital.\n            i: The initial capital.\n            p: The probability of winning a single bet.\n            M: The number of simulation trials.\n            seed: The seed for the random number generator.\n\n        Returns:\n            The estimated probability of ruin.\n        \"\"\"\n        if i <= 0:\n            return 1.0\n        if i >= N:\n            return 0.0\n\n        rng = np.random.default_rng(seed)\n        ruin_count = 0\n\n        for _ in range(M):\n            capital = i\n            while 0 < capital < N:\n                if rng.random() < p:\n                    capital += 1\n                else:\n                    capital -= 1\n            if capital == 0:\n                ruin_count += 1\n        \n        return ruin_count / M\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, i, p, M)\n        (10, 3, 0.5, 20000),  # Case A\n        (10, 0, 0.5, 1000),   # Case B\n        (10, 10, 0.5, 1000),  # Case C\n        (50, 10, 0.7, 20000),  # Case D\n        (50, 10, 0.3, 20000),  # Case E\n        (100, 50, 0.5, 5000), # Case F\n    ]\n\n    # Parameters for the simulation and comparison\n    seed = 123456\n    tolerance = 0.02\n    \n    results = []\n    for case in test_cases:\n        N, i, p, M = case\n        \n        # Calculate analytical and estimated probabilities\n        analytical_val = analytical_ruin_prob(N, i, p)\n        mc_estimate = monte_carlo_estimator(N, i, p, M, seed)\n        \n        # Check if the estimate is within the tolerance\n        absolute_error = abs(analytical_val - mc_estimate)\n        is_within_tolerance = absolute_error <= tolerance\n        results.append(is_within_tolerance)\n\n    # Final print statement in the exact required format.\n    # The str() of a boolean is 'True' or 'False' (capitalized).\n    # The requirement \"[True,False,...]\" matches Python's string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2445753"}]}