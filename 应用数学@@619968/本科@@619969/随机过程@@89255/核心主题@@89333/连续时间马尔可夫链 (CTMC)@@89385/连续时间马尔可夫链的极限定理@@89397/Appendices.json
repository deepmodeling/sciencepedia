{"hands_on_practices": [{"introduction": "让我们从一个基础场景开始：一个在两个状态之间切换的系统。这个练习模拟了一个简化的交通信号灯，将帮助你掌握稳态平衡的核心概念。通过为这个双态连续时间马尔可夫链建立并求解平衡方程，你将计算其极限概率，并理解一个系统的长期行为是如何由其转移速率决定的。[@problem_id:1314961]", "problem": "一个偏远十字路口的简化交通控制系统使用单个交通信号灯运行，该信号灯可以处于两种状态之一：状态 $M$，主干道为绿灯；或状态 $S$，次干道为绿灯。该交通信号灯的行为被建模为连续时间马尔可夫链。\n\n系统从状态 $M$ 切换到状态 $S$ 的恒定速率为 $\\lambda_{MS} = 0.025$ 次切换/秒。它从状态 $S$ 切换回状态 $M$ 的恒定速率为 $\\lambda_{SM} = 0.060$ 次切换/秒。这些速率意味着系统在转换前在每个状态停留的时间是一个服从指数分布的随机变量。\n\n假设系统已经运行了很长时间，那么主干道为绿灯的时间在长期来看占总时间的比例是多少？计算这个比例，并以四舍五入到四位有效数字的小数形式给出你的答案。", "solution": "将该十字路口建模为一个两状态连续时间马尔可夫链，其状态为 $M$ 和 $S$，从 $M$到 $S$ 的转移速率为 $\\lambda_{MS}$，从 $S$ 到 $M$ 的转移速率为 $\\lambda_{SM}$。在稳态下，稳态概率 $\\pi_{M}$ 和 $\\pi_{S}$ 满足全局平衡方程和归一化方程：\n$$\n\\pi_{M}\\lambda_{MS}=\\pi_{S}\\lambda_{SM}, \\quad \\pi_{M}+\\pi_{S}=1.\n$$\n根据平衡方程，\n$$\n\\pi_{S}=\\pi_{M}\\frac{\\lambda_{MS}}{\\lambda_{SM}}.\n$$\n代入归一化方程：\n$$\n\\pi_{M}+\\pi_{M}\\frac{\\lambda_{MS}}{\\lambda_{SM}}=1 \\;\\;\\Rightarrow\\;\\; \\pi_{M}\\left(1+\\frac{\\lambda_{MS}}{\\lambda_{SM}}\\right)=1 \\;\\;\\Rightarrow\\;\\; \\pi_{M}=\\frac{1}{1+\\frac{\\lambda_{MS}}{\\lambda_{SM}}}=\\frac{\\lambda_{SM}}{\\lambda_{SM}+\\lambda_{MS}}.\n$$\n代入给定的速率 $\\lambda_{MS}=0.025$ 和 $\\lambda_{SM}=0.060$：\n$$\n\\pi_{M}=\\frac{0.060}{0.060+0.025}=\\frac{0.060}{0.085}=\\frac{60}{85}=\\frac{12}{17}\\approx 0.705882\\ldots\n$$\n四舍五入到四位有效数字，结果为 $0.7059$。", "answer": "$$\\boxed{0.7059}$$", "id": "1314961"}, {"introduction": "在双态模型的基础上，我们现在来探索一个具有循环结构的系统。这个实践模拟了一辆在“车库-出发送货-返回车库”循环中移动的送货卡车，这代表了物流和其他网络流中的一种常见模式。解决这个问题将加深你对平衡方程如何应用于多于两个状态的系统的理解，并引入稳态流在循环中流动的概念。[@problem_id:1314964]", "problem": "一家物流公司将一辆送货卡车的活动建模为一个具有三个状态的连续时间随机过程：‘在仓库’、‘在出库途中’（派送包裹）和‘在返库途中’（返回仓库）。\n\n根据大量的运营数据，该公司确定了以下几点：\n- 当卡车在仓库时，其被派出进行新一轮派送前的等待时间服从速率为 $\\lambda_D$ 的指数分布。\n- 一旦踏上出库途中，完成所有派送并开始返程所需的时间服从速率为 $\\lambda_O$ 的指数分布。\n- 最后，返回仓库的返库途中的持续时间是一个速率为 $\\lambda_I$ 的指数随机变量。\n\n经过很长一段时间的运行，系统达到稳态。请确定卡车‘在仓库’状态的长期时间比例。请用速率 $\\lambda_D$、$\\lambda_O$ 和 $\\lambda_I$ 表示您的答案，给出一个闭式解析表达式。", "solution": "将卡车建模为具有状态 $D$（仓库）、$O$（出库）和 $I$（返库）的连续时间马尔可夫链。在每个状态的停留时间分别服从速率为 $\\lambda_{D}$、$\\lambda_{O}$ 和 $\\lambda_{I}$ 的指数分布，且唯一的转移是 $D \\to O$（速率为 $\\lambda_D$），$O \\to I$（速率为 $\\lambda_O$），以及 $I \\to D$（速率为 $\\lambda_I$）。生成元 $Q$ 的非对角线元素为 $q_{DO}=\\lambda_{D}$，$q_{OI}=\\lambda_{O}$，$q_{ID}=\\lambda_{I}$，且对于 $i \\in \\{D,O,I\\}$ 有 $q_{ii}=-\\lambda_{i}$。\n\n在稳态下，平稳分布 $\\pi=(\\pi_{D},\\pi_{O},\\pi_{I})$ 满足全局平衡（流量）方程。由于转移形成一个带单向边的循环，因此通过每次转移的稳态吞吐量 $r$ 必须相等：\n$$\n\\pi_{D}\\lambda_{D}=\\pi_{O}\\lambda_{O}=\\pi_{I}\\lambda_{I}=r.\n$$\n因此，\n$$\n\\pi_{D}=\\frac{r}{\\lambda_{D}},\\quad \\pi_{O}=\\frac{r}{\\lambda_{O}},\\quad \\pi_{I}=\\frac{r}{\\lambda_{I}}.\n$$\n施加归一化条件 $\\pi_{D}+\\pi_{O}+\\pi_{I}=1$：\n$$\n\\frac{r}{\\lambda_{D}}+\\frac{r}{\\lambda_{O}}+\\frac{r}{\\lambda_{I}}=1\n\\;\\;\\Longrightarrow\\;\\;\nr\\left(\\frac{1}{\\lambda_{D}}+\\frac{1}{\\lambda_{O}}+\\frac{1}{\\lambda_{I}}\\right)=1\n\\;\\;\\Longrightarrow\\;\\;\nr=\\frac{1}{\\frac{1}{\\lambda_{D}}+\\frac{1}{\\lambda_{O}}+\\frac{1}{\\lambda_{I}}}.\n$$\n所以，\n$$\n\\pi_{D}=\\frac{r}{\\lambda_{D}}=\\frac{\\frac{1}{\\lambda_{D}}}{\\frac{1}{\\lambda_{D}}+\\frac{1}{\\lambda_{O}}+\\frac{1}{\\lambda_{I}}}.\n$$\n等价地，将分子和分母同乘以 $\\lambda_{D}\\lambda_{O}\\lambda_{I}$，\n$$\n\\pi_{D}=\\frac{\\lambda_{O}\\lambda_{I}}{\\lambda_{O}\\lambda_{I}+\\lambda_{D}\\lambda_{I}+\\lambda_{D}\\lambda_{O}}.\n$$\n这个 $\\pi_{D}$ 就是卡车在仓库的长期时间比例。", "answer": "$$\\boxed{\\frac{\\lambda_{O}\\lambda_{I}}{\\lambda_{O}\\lambda_{I}+\\lambda_{D}\\lambda_{I}+\\lambda_{D}\\lambda_{O}}}$$", "id": "1314964"}, {"introduction": "虽然通过解析方法求解小型系统能提供深刻见解，但许多现实世界的问题过于复杂，无法手动计算。这项实践要求你通过实现一个数值算法来为任何有限状态连续时间马尔可夫链找到平稳分布，从而架起理论与计算之间的桥梁。你将推导并应用“均匀化”（uniformization）方法，该方法将问题转化为一个不动点迭代问题，为你分析复杂马尔可夫链提供一个强大而通用的工具。[@problem_id:2393783]", "problem": "您的任务是通过求解从生成元矩阵导出的不动点问题来计算若干个连续时间马尔可夫链 (CTMC) 的平稳概率分布。一个生成元矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 满足连续时间马尔可夫链的标准性质：对于所有 $i \\neq j$，有 $q_{ij} \\ge 0$，并且每行的和为 $0$。平稳分布是一个行向量 $\\pi \\in \\mathbb{R}^n$，满足 $\\pi \\ge 0$，$\\sum_{i=1}^n \\pi_i = 1$ 以及 $\\pi Q = 0$。您的任务是从第一性原理出发，在概率单纯形上构造一个编码此平稳条件的不动点映射，并实现一个不动点迭代，使其对下述每个测试用例都能收敛到平稳分布。\n\n设计要求：\n- 从连续时间马尔可夫链的 Kolmogorov 前向方程以及生成元矩阵和平稳分布的定义属性出发。由此推导出在概率单纯形 $\\Delta^{n-1} = \\{ x \\in \\mathbb{R}^n: x_i \\ge 0, \\sum_i x_i = 1 \\}$ 上的一个不动点映射 $g$，使得平稳分布 $\\pi^\\star$ 满足 $\\pi^\\star = g(\\pi^\\star)$。您的映射必须对于任何满足 CTMC 条件的生成元矩阵 $Q$ 都是良定义的，并且对于下述测试用例应构成一个压缩映射，以便简单的不动点迭代能够收敛。\n- 从状态上的均匀分布开始，实现不动点迭代 $\\pi^{(k+1)} = g(\\pi^{(k)})$。使用 $\\ell_1$-范数停止准则 $\\lVert \\pi^{(k+1)} - \\pi^{(k)} \\rVert_1 \\le \\varepsilon$，容差为 $\\varepsilon = 10^{-12}$；如果未达到容差，则在最多 $N_{\\max} = 2{,}000{,}000$ 次迭代后停止。在终止时，重新归一化以强制 $\\sum_i \\pi_i = 1$，并在必要时将任何负的舍入误差修正为 $0$。\n- 对于每个测试用例，按状态索引顺序输出平稳分布，形式为一个包含 $n$ 个浮点数的列表，四舍五入到 $6$ 位小数。\n\n测试套件：\n1) 一个具有生成元矩阵的 $3$ 状态生灭过程 CTMC $$\nQ_1 =\n\\begin{bmatrix}\n-2 & 2 & 0\\\\\n1 & -4 & 3\\\\\n0 & 1 & -1\n\\end{bmatrix}\n$$.\n\n2) 一个在索引 $4$ 处有唯一吸收态的 $4$ 状态 CTMC：\n$$\nQ_2 =\n\\begin{bmatrix}\n-4 & 1 & 1 & 2\\\\\n1 & -3 & 0.5 & 1.5\\\\\n0 & 1 & -2 & 1\\\\\n0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n\n3) 一个 $5$ 状态的几乎可分解 CTMC（两个弱连接的簇），但仍是不可约的：\n$$\nQ_3 =\n\\begin{bmatrix}\n-5 & 5 & 0 & 0 & 0\\\\\n2.5 & -5.05 & 2.5 & 0.05 & 0\\\\\n0 & 5 & -5 & 0 & 0\\\\\n0 & 0.04 & 0 & -4.04 & 4\\\\\n0 & 0 & 0 & 4 & -4\n\\end{bmatrix}\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。此顶层列表的每个元素对应一个测试用例，顺序与上文相同，并且本身必须是包含平稳分布条目（四舍五入到 $6$ 位小数）的列表。例如，一个包含两个用例的有效输出格式看起来像 `[[0.500000,0.500000],[0.250000,0.750000]]`。", "solution": "该问题要求计算若干个连续时间马尔可夫链 (CTMC) 的平稳概率分布，记为行向量 $\\pi$。这些 CTMC 由其生成元矩阵 $Q$ 定义。一个平稳分布 $\\pi$ 必须满足三个条件：\n$1$. 平衡方程：$\\pi Q = 0$。\n$2$. 非负性：对于所有状态 $i \\in \\{1, \\dots, n\\}$，$\\pi_i \\ge 0$。\n$3$. 归一化：$\\sum_{i=1}^n \\pi_i = 1$。\n\n任务是推导在概率单纯形 $\\Delta^{n-1} = \\{ x \\in \\mathbb{R}^n: x_i \\ge 0, \\sum_i x_i = 1 \\}$ 上的一个不动点映射 $g$，使得平稳分布 $\\pi^\\star$ 是一个不动点，即 $\\pi^\\star = g(\\pi^\\star)$。这允许通过迭代方案 $\\pi^{(k+1)} = g(\\pi^{(k)})$ 来计算 $\\pi^\\star$。\n\n此推导从第一性原理出发，具体使用均匀化方法。\n\n一个 CTMC 的生成元矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 具有非负的非对角元素（对于 $i \\neq j$，$q_{ij} \\ge 0$），并且其行和为零（$\\sum_{j=1}^n q_{ij} = 0$）。这意味着对角元素是非正的：$q_{ii} = -\\sum_{j \\neq i} q_{ij} \\le 0$。\n\n让我们定义均匀化率 $\\lambda$ 为一个实数，使得 $\\lambda \\ge \\max_i |q_{ii}|$。一个标准且充分的选择是 $\\lambda = \\max_i |q_{ii}|$。由于 $|q_{ii}| = \\sum_{j \\neq i} q_{ij}$，这等价于 $\\lambda = \\max_i \\sum_{j \\neq i} q_{ij}$。我们必须处理 $Q$ 是零矩阵的平凡情况，此时 $\\lambda = 0$。在这种情况下，任何概率向量都是平稳分布，初始的均匀分布是一个有效的解。对于任何非平凡的 CTMC，$\\lambda > 0$。\n\n我们可以将生成元矩阵 $Q$ 重写为：\n$$ Q = \\lambda \\left(I + \\frac{1}{\\lambda} Q\\right) - \\lambda I $$\n此处 $I$ 是 $n \\times n$ 的单位矩阵。让我们定义一个新矩阵 $P$ 为：\n$$ P = I + \\frac{1}{\\lambda} Q $$\n平稳条件 $\\pi Q = 0$ 可以使用 $Q$ 的这个表达式重写为：\n$$ \\pi \\left( \\lambda(P - I) \\right) = 0 $$\n因为我们假设 $\\lambda > 0$，这等价于：\n$$ \\pi(P - I) = 0 $$\n$$ \\pi P = \\pi $$\n这个方程是具有转移矩阵 $P$ 的离散时间马尔可夫链 (DTMC) 的平稳分布的定义条件。我们必须验证 $P$ 是一个有效的随机矩阵。\n\n$1$. **元素非负性**：\n$P$ 的非对角元素是 $p_{ij} = \\frac{q_{ij}}{\\lambda}$（对于 $i \\neq j$）。由于 $q_{ij} \\ge 0$ 且 $\\lambda > 0$，我们有 $p_{ij} \\ge 0$。\n$P$ 的对角元素是 $p_{ii} = 1 + \\frac{q_{ii}}{\\lambda} = 1 - \\frac{|q_{ii}|}{\\lambda}$。根据我们对 $\\lambda$ 的选择，我们有 $|q_{ii}| \\le \\lambda$，这意味着 $0 \\le \\frac{|q_{ii}|}{\\lambda} \\le 1$。因此，$0 \\le p_{ii} \\le 1$。\n$P$ 的所有元素都是非负的。\n\n$2$. **行和**：\n$P$ 的第 $i$ 行元素之和为：\n$$ \\sum_{j=1}^n p_{ij} = p_{ii} + \\sum_{j \\neq i} p_{ij} = \\left(1 + \\frac{q_{ii}}{\\lambda}\\right) + \\sum_{j \\neq i} \\frac{q_{ij}}{\\lambda} = 1 + \\frac{1}{\\lambda} \\left( q_{ii} + \\sum_{j \\neq i} q_{ij} \\right) = 1 + \\frac{1}{\\lambda} \\sum_{j=1}^n q_{ij} $$\n根据生成元矩阵的定义，$\\sum_{j=1}^n q_{ij} = 0$。因此：\n$$ \\sum_{j=1}^n p_{ij} = 1 + \\frac{1}{\\lambda} (0) = 1 $$\n$P$ 的行和为 $1$。\n\n由于 $P$ 是一个有效的随机矩阵，寻找具有生成元 $Q$ 的 CTMC 的平稳分布问题等价于寻找具有转移矩阵 $P$ 的 DTMC 的平稳分布。\n\n方程 $\\pi = \\pi P$ 提供了所需的不动点公式。我们定义映射 $g: \\Delta^{n-1} \\to \\Delta^{n-1}$ 为：\n$$ g(\\pi) = \\pi P $$\n这个映射在概率单纯形上是良定义的。如果 $\\pi$ 是一个概率向量，那么 $\\pi P$ 的所有分量都是非负的，并且其分量之和为 $\\sum_j (\\pi P)_j = \\sum_j \\sum_i \\pi_i p_{ij} = \\sum_i \\pi_i (\\sum_j p_{ij}) = \\sum_i \\pi_i (1) = 1$。\n\n不动点迭代由下式给出：\n$$ \\pi^{(k+1)} = g(\\pi^{(k)}) = \\pi^{(k)} P $$\n这个迭代被称为幂法。对于一个不可约且非周期的 DTMC，此迭代保证从任何初始概率向量收敛到唯一的平稳分布。所提供的测试用例对应于不可约或具有吸收态的 CTMC。均匀化过程在得到的 DTMC 中保留了这些性质，从而确保了迭代的收敛性。\n\n算法如下：\n$1$. 给定生成元矩阵 $Q$，计算均匀化率 $\\lambda = \\max_i |q_{ii}|$。如果 $\\lambda=0$，则平稳分布是初始的均匀分布。\n$2$. 构建随机矩阵 $P = I + \\frac{1}{\\lambda} Q$。\n$3$. 将概率向量 $\\pi^{(0)}$ 初始化为均匀分布：对所有 $i$，$\\pi_i^{(0)} = \\frac{1}{n}$。\n$4$. 对于 $k = 0, 1, 2, \\dots$ 进行迭代，最多 $N_{\\max} - 1 = 1,999,999$ 次：\n   a. 计算下一次迭代值：$\\pi^{(k+1)} = \\pi^{(k)} P$。\n   b. 使用 $\\ell_1$-范数检查收敛性：如果 $\\lVert \\pi^{(k+1)} - \\pi^{(k)} \\rVert_1 = \\sum_{i=1}^n |\\pi_i^{(k+1)} - \\pi_i^{(k)}| \\le \\varepsilon = 10^{-12}$，则终止迭代。\n   c. 更新以进行下一步：$\\pi^{(k)} \\leftarrow \\pi^{(k+1)}$。\n$5$. 终止后，对结果向量进行后处理，以校正任何微小的浮点误差。任何小于 $0$ 的分量都被修正为 $0$，并且向量被重新归一化以确保其分量之和恰好为 $1$。这个最终向量就是计算出的平稳分布。\n\n将此过程应用于所提供的三个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the stationary distribution of CTMCs using fixed-point iteration.\n    \"\"\"\n\n    def compute_stationary_distribution(Q: np.ndarray, tol: float, max_iter: int) -> np.ndarray:\n        \"\"\"\n        Computes the stationary distribution for a given generator matrix Q.\n        \n        Args:\n            Q (np.ndarray): The generator matrix of the CTMC.\n            tol (float): The tolerance for the stopping criterion.\n            max_iter (int): The maximum number of iterations.\n\n        Returns:\n            np.ndarray: The stationary probability distribution vector.\n        \"\"\"\n        n = Q.shape[0]\n        \n        # Initialize pi to the uniform distribution\n        pi = np.ones(n) / n\n\n        # Uniformization rate lambda\n        diag_abs = np.abs(np.diag(Q))\n        lambda_rate = np.max(diag_abs)\n\n        # Handle the trivial case of a zero matrix\n        if lambda_rate == 0:\n            return pi\n\n        # Construct the stochastic matrix P for the corresponding DTMC\n        # P = I + (1/lambda_rate) * Q\n        P = np.eye(n) + Q / lambda_rate\n\n        # Fixed-point iteration\n        for _ in range(max_iter):\n            pi_next = pi @ P\n            \n            # Check for convergence using the L1 norm\n            if np.sum(np.abs(pi_next - pi)) < tol:\n                pi = pi_next\n                break\n            \n            pi = pi_next\n\n        # Post-processing: clip small negative values due to floating point error\n        pi[pi < 0] = 0\n        \n        # Re-normalize to ensure the sum is exactly 1\n        pi_sum = np.sum(pi)\n        if pi_sum > 0:\n            pi = pi / pi_sum\n        \n        return pi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [-2, 2, 0],\n            [1, -4, 3],\n            [0, 1, -1]\n        ]),\n        np.array([\n            [-4, 1, 1, 2],\n            [1, -3, 0.5, 1.5],\n            [0, 1, -2, 1],\n            [0, 0, 0, 0]\n        ]),\n        np.array([\n            [-5, 5, 0, 0, 0],\n            [2.5, -5.05, 2.5, 0.05, 0],\n            [0, 5, -5, 0, 0],\n            [0, 0.04, 0, -4.04, 4],\n            [0, 0, 0, 4, -4]\n        ])\n    ]\n\n    tolerance = 1e-12\n    max_iterations = 2000000\n    \n    formatted_results = []\n    for Q_matrix in test_cases:\n        stationary_dist = compute_stationary_distribution(Q_matrix, tolerance, max_iterations)\n        # Format each element to 6 decimal places as a string\n        formatted_dist = [f\"{x:.6f}\" for x in stationary_dist]\n        # Create the string representation of the list\n        formatted_results.append(f\"[{','.join(formatted_dist)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393783"}]}