{"hands_on_practices": [{"introduction": "在处理任何概率分布时，首要任务是确保其是“归一化”的，即其在整个定义域上的总概率为1。本练习将引导你完成伽马分布概率密度函数的核心积分，通过一个简单的变量替换，将其与欧拉伽马函数 $\\Gamma(k)$ 的标准定义联系起来。掌握这项基本演算是在随机微分方程研究中验证候选平稳分布等高级工作的关键第一步。[@problem_id:3056353]", "problem": "在一维伊藤扩散（如 Cox–Ingersoll–Ross 平方根过程）的研究中，候选的平稳密度通常在 $(0,\\infty)$ 上具有与 $x^{k-1}\\exp(-x/\\theta)$ 成比例的核函数形式，其中 $k0$ 且 $\\theta0$。为了从第一性原理检验其可归一性，考虑积分\n$$\nI(k,\\theta)=\\int_{0}^{\\infty} x^{k-1}\\exp\\!\\left(-\\frac{x}{\\theta}\\right)\\,dx,\n$$\n其中参数 $k0$ 且 $\\theta0$。\n\n仅使用 Gamma 函数的定义 $\\Gamma(k)=\\int_{0}^{\\infty} u^{\\,k-1}\\exp(-u)\\,du$（对于 $k0$）和积分的换元法则，以 $k$ 和 $\\theta$ 的函数形式，求出 $I(k,\\theta)$ 的闭合解。你的最终答案必须是一个单一的解析表达式。无需进行数值舍入。", "solution": "问题要求计算积分\n$$\nI(k,\\theta)=\\int_{0}^{\\infty} x^{k-1}\\exp\\left(-\\frac{x}{\\theta}\\right)\\,dx\n$$\n其中参数 $k0$ 且 $\\theta0$。计算必须使用 Gamma 函数 $\\Gamma(k)$ 的定义和积分的换元法则。\n\n首先，我们陈述所提供的对于 $k0$ 的 Gamma 函数定义：\n$$\n\\Gamma(k)=\\int_{0}^{\\infty} u^{k-1}\\exp(-u)\\,du\n$$\n\n任务是将积分 $I(k,\\theta)$ 转换成一种可以直接应用该定义的形式。我们将 $I(k,\\theta)$ 的被积函数 $x^{k-1}\\exp(-x/\\theta)$ 与 $\\Gamma(k)$ 的被积函数 $u^{k-1}\\exp(-u)$ 进行比较。关键区别在于指数函数的参数。在 $I(k,\\theta)$ 中是 $-x/\\theta$，而在 $\\Gamma(k)$ 中是 $-u$。这一观察启发我们进行变量替换。\n\n让我们定义一个新的积分变量 $u$，以使指数项相匹配。我们设：\n$$\nu = \\frac{x}{\\theta}\n$$\n由此代换，我们解出以 $u$ 表示的 $x$：\n$$\nx = \\theta u\n$$\n为完成变量替换，我们需要找到以 $du$ 表示的微分 $dx$。将 $x$ 的表达式对 $u$ 求导，我们得到：\n$$\n\\frac{dx}{du} = \\theta\n$$\n这意味着微分元的变换如下：\n$$\ndx = \\theta \\, du\n$$\n接下来，我们必须变换积分的上下限。原积分的区间是 $x \\in (0, \\infty)$。\n对于下限，当 $x=0$ 时，新变量为 $u = \\frac{0}{\\theta} = 0$。\n对于上限，当 $x \\to \\infty$ 时，由于给定 $\\theta  0$，新变量 $u = \\frac{x}{\\theta}$ 也趋于 $\\infty$。\n因此，变量 $u$ 的积分上下限仍然是从 $0$ 到 $\\infty$。\n\n现在，我们将 $x = \\theta u$ 和 $dx = \\theta \\, du$ 代入 $I(k,\\theta)$ 的积分中：\n$$\nI(k,\\theta) = \\int_{0}^{\\infty} (\\theta u)^{k-1} \\exp\\left(-\\frac{\\theta u}{\\theta}\\right) (\\theta \\, du)\n$$\n我们简化积分内的表达式。项 $(\\theta u)^{k-1}$ 变为 $\\theta^{k-1} u^{k-1}$，指数的参数简化为 $-u$。\n$$\nI(k,\\theta) = \\int_{0}^{\\infty} \\theta^{k-1} u^{k-1} \\exp(-u) \\, \\theta \\, du\n$$\n我们利用指数的性质合并 $\\theta$ 的因子：\n$$\nI(k,\\theta) = \\int_{0}^{\\infty} \\theta^{k-1+1} u^{k-1} \\exp(-u) \\, du = \\int_{0}^{\\infty} \\theta^k u^{k-1} \\exp(-u) \\, du\n$$\n项 $\\theta^k$ 不依赖于积分变量 $u$，所以可以从积分中提出来：\n$$\nI(k,\\theta) = \\theta^k \\int_{0}^{\\infty} u^{k-1} \\exp(-u) \\, du\n$$\n剩下的积分现在与问题陈述中提供的 Gamma 函数的定义完全相同：\n$$\n\\int_{0}^{\\infty} u^{k-1} \\exp(-u) \\, du = \\Gamma(k)\n$$\n将此定义代入我们关于 $I(k, \\theta)$ 的表达式中，我们得到最终的闭合形式结果：\n$$\nI(k,\\theta) = \\theta^k \\Gamma(k)\n$$\n此结果对所有 $k0$ 和 $\\theta0$ 均有效，这是原积分和 Gamma 函数所指定的定义域。问题因此按要求得到解决。", "answer": "$$\\boxed{\\theta^k \\Gamma(k)}$$", "id": "3056353"}, {"introduction": "本练习将带你更深入地探索伽马分布的内在结构，特别是当形状参数为整数时。在这种情况下，伽马分布描述了泊松过程中事件发生的等待时间。通过重复使用分部积分法，你将推导出伽马累积分布函数 (CDF) 的一个精确的级数形式，从而揭示连续的伽马分布与离散的泊松分布之间的深刻联系，这是随机建模中的一个基石。[@problem_id:3056417]", "problem": "令 $X$ 表示速率为 $\\lambda$ 的齐次泊松过程的第 $k$ 次跳跃的等待时间，因此 $X$ 服从伽马分布，其整数形状参数为 $k \\in \\mathbb{N}$，尺度参数为 $\\theta = \\lambda^{-1}  0$。对于整数 $k$，伽马概率密度函数由下式给出\n$$\nf_{k,\\theta}(x) = \\frac{1}{\\Gamma(k)\\,\\theta^{k}}\\,x^{k-1}\\,\\exp\\!\\left(-\\frac{x}{\\theta}\\right), \\quad x \\ge 0,\n$$\n且当 $x  0$ 时 $f_{k,\\theta}(x)=0$，其中 Euler 伽马函数对于整数 $k \\in \\mathbb{N}$ 满足 $\\Gamma(k) = (k-1)!$。从累积分布函数的定义\n$$\nF_{k,\\theta}(x) = \\int_{0}^{x} f_{k,\\theta}(t)\\,\\mathrm{d}t,\n$$\n出发，并且仅使用微积分中的基本分部积分恒等式以及 $\\Gamma(k)=(k-1)!$，为在 $x \\ge 0$ 时有效的 $F_{k,\\theta}(x)$ 推导出一个闭式表达式，该表达式包含指数函数和有限的幂次和。您的推导必须通过重复分部积分进行，并且除了 Euler 伽马函数外，不得假定任何其他特殊函数。\n\n将您的最终答案以关于 $x$、$k$ 和 $\\theta$ 的单个闭式解析表达式的形式给出（最终答案中不需要分段形式）。不需要进行数值计算。", "solution": "问题是为具有整数形状参数 $k$ 的伽马分布的累积分布函数(CDF)推导一个闭式表达式。\n\n对于 $x \\ge 0$，累积分布函数 $F_{k,\\theta}(x)$ 由以下积分定义：\n$$\nF_{k,\\theta}(x) = \\int_{0}^{x} f_{k,\\theta}(t)\\,\\mathrm{d}t\n$$\n代入给定的概率密度函数(PDF)并使用对于 $k \\in \\mathbb{N}$ 的 $\\Gamma(k) = (k-1)!$：\n$$\nF_{k,\\theta}(x) = \\int_{0}^{x} \\frac{1}{(k-1)! \\theta^k} t^{k-1} \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t = \\frac{1}{(k-1)! \\theta^k} \\int_{0}^{x} t^{k-1} \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t\n$$\n让我们将此积分表示为 $I_k(x) = \\int_{0}^{x} t^{k-1} \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t$。我们将使用分部积分法计算此积分，其中 $\\int u \\, \\mathrm{d}v = uv - \\int v \\, \\mathrm{d}u$。\n\n令 $u = t^{k-1}$ 且 $\\mathrm{d}v = \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t$。\n则 $\\mathrm{d}u = (k-1)t^{k-2} \\mathrm{d}t$ 且 $v = -\\theta \\exp\\left(-\\frac{t}{\\theta}\\right)$。\n\n对 $k  1$ 应用分部积分法：\n$$\nI_k(x) = \\left[ t^{k-1} \\left(-\\theta \\exp\\left(-\\frac{t}{\\theta}\\right)\\right) \\right]_{0}^{x} - \\int_{0}^{x} \\left(-\\theta \\exp\\left(-\\frac{t}{\\theta}\\right)\\right) (k-1)t^{k-2} \\mathrm{d}t\n$$\n$$\nI_k(x) = -x^{k-1}\\theta \\exp\\left(-\\frac{x}{\\theta}\\right) - 0 + (k-1)\\theta \\int_{0}^{x} t^{k-2} \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t\n$$\n剩下的积分是 $I_{k-1}(x)$。这建立了一个递推关系：\n$$\nI_k(x) = -x^{k-1}\\theta \\exp\\left(-\\frac{x}{\\theta}\\right) + (k-1)\\theta I_{k-1}(x)\n$$\n现在，让我们将其与累积分布函数联系起来。我们有 $F_{k,\\theta}(x) = \\frac{1}{(k-1)!\\theta^k} I_k(x)$。\n代入 $I_k(x)$ 的递推式：\n$$\nF_{k,\\theta}(x) = \\frac{1}{(k-1)!\\theta^k} \\left( -x^{k-1}\\theta \\exp\\left(-\\frac{x}{\\theta}\\right) + (k-1)\\theta I_{k-1}(x) \\right)\n$$\n$$\nF_{k,\\theta}(x) = -\\frac{x^{k-1}\\theta \\exp\\left(-\\frac{x}{\\theta}\\right)}{(k-1)!\\theta^k} + \\frac{(k-1)\\theta I_{k-1}(x)}{(k-1)!\\theta^k}\n$$\n$$\nF_{k,\\theta}(x) = -\\frac{1}{(k-1)!} \\left(\\frac{x}{\\theta}\\right)^{k-1} \\exp\\left(-\\frac{x}{\\theta}\\right) + \\frac{1}{(k-2)!\\theta^{k-1}} I_{k-1}(x)\n$$\n认识到 $F_{k-1,\\theta}(x) = \\frac{1}{(k-2)!\\theta^{k-1}} I_{k-1}(x)$，我们得到一个关于CDF的递推关系：\n$$\nF_{k,\\theta}(x) = F_{k-1,\\theta}(x) - \\frac{1}{(k-1)!} \\left(\\frac{x}{\\theta}\\right)^{k-1} \\exp\\left(-\\frac{x}{\\theta}\\right)\n$$\n这个关系是单次分部积分步骤的直接结果。根据问题要求，我们可以重复应用此过程。这等价于将递推关系展开至基例 $k=1$。\n$$\nF_{k,\\theta}(x) = F_{k-1,\\theta}(x) - \\frac{\\exp(-x/\\theta)}{(k-1)!} \\left(\\frac{x}{\\theta}\\right)^{k-1}\n$$\n$$\nF_{k-1,\\theta}(x) = F_{k-2,\\theta}(x) - \\frac{\\exp(-x/\\theta)}{(k-2)!} \\left(\\frac{x}{\\theta}\\right)^{k-2}\n$$\n$$\n\\vdots\n$$\n$$\nF_{2,\\theta}(x) = F_{1,\\theta}(x) - \\frac{\\exp(-x/\\theta)}{1!} \\left(\\frac{x}{\\theta}\\right)^{1}\n$$\n将这些方程进行伸缩求和，我们得到：\n$$\nF_{k,\\theta}(x) = F_{1,\\theta}(x) - \\sum_{j=2}^{k} \\frac{\\exp(-x/\\theta)}{(j-1)!} \\left(\\frac{x}{\\theta}\\right)^{j-1}\n$$\n让我们通过令 $i = j-1$ 来改变求和索引。求和变为 $\\sum_{i=1}^{k-1} \\frac{\\exp(-x/\\theta)}{i!} \\left(\\frac{x}{\\theta}\\right)^{i}$。\n$$\nF_{k,\\theta}(x) = F_{1,\\theta}(x) - \\exp\\left(-\\frac{x}{\\theta}\\right)\\sum_{i=1}^{k-1} \\frac{1}{i!} \\left(\\frac{x}{\\theta}\\right)^{i}\n$$\n现在，我们必须找到基例 $F_{1,\\theta}(x)$。这对应于指数分布。我们直接从积分定义计算它：\n$$\nF_{1,\\theta}(x) = \\int_{0}^{x} \\frac{1}{(1-1)!\\theta^1} t^{1-1} \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t = \\int_{0}^{x} \\frac{1}{\\theta} \\exp\\left(-\\frac{t}{\\theta}\\right) \\mathrm{d}t\n$$\n$$\nF_{1,\\theta}(x) = \\left[ -\\exp\\left(-\\frac{t}{\\theta}\\right) \\right]_{0}^{x} = -\\exp\\left(-\\frac{x}{\\theta}\\right) - (-\\exp(0)) = 1 - \\exp\\left(-\\frac{x}{\\theta}\\right)\n$$\n将这个基例代回我们关于 $F_{k,\\theta}(x)$ 的表达式中：\n$$\nF_{k,\\theta}(x) = \\left(1 - \\exp\\left(-\\frac{x}{\\theta}\\right)\\right) - \\exp\\left(-\\frac{x}{\\theta}\\right)\\sum_{i=1}^{k-1} \\frac{1}{i!} \\left(\\frac{x}{\\theta}\\right)^{i}\n$$\n$$\nF_{k,\\theta}(x) = 1 - \\exp\\left(-\\frac{x}{\\theta}\\right) - \\exp\\left(-\\frac{x}{\\theta}\\right)\\sum_{i=1}^{k-1} \\frac{1}{i!} \\left(\\frac{x}{\\theta}\\right)^{i}\n$$\n我们可以提出因子 $\\exp\\left(-\\frac{x}{\\theta}\\right)$：\n$$\nF_{k,\\theta}(x) = 1 - \\exp\\left(-\\frac{x}{\\theta}\\right) \\left( 1 + \\sum_{i=1}^{k-1} \\frac{1}{i!} \\left(\\frac{x}{\\theta}\\right)^{i} \\right)\n$$\n认识到 $1 = \\frac{1}{0!} \\left(\\frac{x}{\\theta}\\right)^{0}$，我们可以将独立项合并到求和中：\n$$\nF_{k,\\theta}(x) = 1 - \\exp\\left(-\\frac{x}{\\theta}\\right) \\sum_{i=0}^{k-1} \\frac{1}{i!} \\left(\\frac{x}{\\theta}\\right)^{i}\n$$\n这就是按要求使用重复分部积分法推导出的、具有整数形状参数 $k$ 的伽马分布的累积分布函数(CDF)的最终闭式表达式。该求和是一个有限和，其项涉及 $x$ 的幂和指数函数。在最终答案中，我们可以使用索引 $j$ 代替 $i$。", "answer": "$$\n\\boxed{1 - \\exp\\left(-\\frac{x}{\\theta}\\right) \\sum_{j=0}^{k-1} \\frac{1}{j!} \\left(\\frac{x}{\\theta}\\right)^j}\n$$", "id": "3056417"}, {"introduction": "现在，我们将从纯数学的推导过渡到计算科学的实践。作为伽马分布的一个特例，卡方分布天然地产生于对独立标准正态变量的平方求和。鉴于标准正态增量是布朗运动的基本构成单元，模拟卡方分布对于研究随机微分方程至关重要。本练习不仅要求你通过编程实现其定义，还将引导你探讨在处理大规模数据时必须面对的数值稳定性这一关键的现实问题。[@problem_id:3056438]", "problem": "本题要求您将随机微分方程中的一个核心构造与经典连续分布联系起来，然后实现一个数值稳健的模拟器。在由标准布朗运动驱动的伊藤随机微分方程的欧拉-丸山离散化中，会自然出现独立的标准化高斯增量。考虑独立的标准化增量 $\\{Z_k\\}_{k=1}^{\\nu}$，其中 $Z_k \\sim \\mathcal{N}(0,1)$，并注意平方和 $\\sum_{k=1}^{\\nu} Z_k^2$ 会出现在二次变差及相关似然的估计量中。请从独立性和标准正态分布的第一性原理出发，确定 $\\sum_{k=1}^{\\nu} Z_k^2$ 的分布，并根据关于伽马分布及其加法稳定性的已验证事实，推导出其均值和方差。然后，实现一个仅使用独立标准正态定义的模拟（主模拟中不直接调用卡方或伽马采样器），并量化不同求和策略在自由度参数较大时的数值稳定性。\n\n对于每个含参数 $(\\nu, M, s)$ 的测试用例，您的程序必须执行以下操作：\n- 使用以种子 $s$ 初始化的伪随机数生成器，通过为每次抽样显式生成 $\\nu$ 个独立的 $\\mathcal{N}(0,1)$ 变量并对其平方求和，来模拟 $M$ 次平方和 $\\sum_{k=1}^{\\nu} Z_k^2$ 的独立抽样。\n- 计算这 $M$ 次抽样的样本均值 $\\widehat{\\mu}$ 和无偏样本方差 $\\widehat{\\sigma}^2$，然后计算绝对均值误差 $|\\widehat{\\mu} - \\nu|$ 和绝对方差误差 $|\\widehat{\\sigma}^2 - 2\\nu|$。这些值应以浮点数形式报告。\n- 为评估大 $\\nu$ 值下求和的数值稳定性，使用以种子 $s + 1337$ 初始化的一个新的伪随机数生成器，抽取单个向量 $(Z_1,\\dots,Z_{\\nu})$，其中 $Z_k \\sim \\mathcal{N}(0,1)$，并使用三种方法计算相同的平方和：\n  1. 通过简单循环实现的朴素 Python 累加 $S_{\\text{naive}} = \\sum_{k=1}^{\\nu} Z_k^2$，\n  2. 应用于序列 $\\{Z_k^2\\}_{k=1}^{\\nu}$ 的 Kahan 补偿求和 $S_{\\text{kahan}}$，\n  3. 使用高级向量化点积的向量化成对求和 $S_{\\text{np}}$。\n  基于这些结果，计算两个相对差异（无量纲浮点数）：$r_1 = |S_{\\text{naive}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$ 和 $r_2 = |S_{\\text{np}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$。如果 $S_{\\text{kahan}} = 0$，则将两个相对差异都定义为 $0$。\n- 对于每个测试用例，按固定顺序输出四个浮点数：绝对均值误差、绝对方差误差、$r_1$、$r_2$。\n\n您在推导中可以使用的基本依据是：\n- 标准正态分布 $\\mathcal{N}(0,1)$ 的定义、独立性以及布朗运动中独立增量的可加性。\n- 已验证的事实：如果 $X \\sim \\operatorname{Gamma}(k,\\theta)$ 和 $Y \\sim \\operatorname{Gamma}(k',\\theta)$ 独立且具有共同的尺度参数 $\\theta$，则 $X+Y \\sim \\operatorname{Gamma}(k+k',\\theta)$，并且 $\\operatorname{Gamma}(k,\\theta)$ 的均值为 $k\\theta$，方差为 $k\\theta^2$。\n- 数值浮点求和的基本性质以及 Kahan 补偿求和算法。\n\n必须处理边界情况和数值稳定性问题。特别地，对于大的 $\\nu$，对许多小数求和会累积舍入误差；对于 $\\nu = 0$，分布在 $0$ 处退化。\n\n本题不涉及物理单位。所有角度（若有）默认为弧度（本题未使用）。表示比例时，请始终使用小数。\n\n测试套件：\n- 用例 A（边界情况）：$(\\nu, M, s) = (0, 1000, 1234)$。\n- 用例 B（正常路径）：$(\\nu, M, s) = (10, 100000, 202311)$。\n- 用例 C（大 $\\nu$ 稳定性）：$(\\nu, M, s) = (200000, 200, 7)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按顺序连接用例 A 的四个浮点数，然后是用例 B 的四个浮点数，再然后是用例 C 的四个浮点数。例如，输出必须类似于\n$[\\text{A\\_mean\\_err},\\text{A\\_var\\_err},\\text{A\\_r1},\\text{A\\_r2},\\text{B\\_mean\\_err},\\dots,\\text{C\\_r2}]$。", "solution": "**理论基础**\n\n本题要求我们确定 $\\nu$ 个独立标准正态随机变量的平方和 $S_{\\nu} = \\sum_{k=1}^{\\nu} Z_k^2$ 的分布，其中每个 $Z_k \\sim \\mathcal{N}(0,1)$ 且相互独立。我们将从第一性原理和已知的伽马分布性质出发，推导该分布及其均值和方差。\n\n**第 1 步：单个标准正态变量平方的分布**\n\n设 $Z \\sim \\mathcal{N}(0,1)$。$Z$ 的概率密度函数 (PDF) 为 $f_Z(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$，其中 $z \\in (-\\infty, \\infty)$。我们寻求 $Y = Z^2$ 的分布。由于 $Y$ 必须为非负数，我们考虑 $y \\geq 0$ 的情况。\n\n$Y$ 的累积分布函数 (CDF) 是 $F_Y(y) = P(Y \\leq y) = P(Z^2 \\leq y) = P(-\\sqrt{y} \\leq Z \\leq \\sqrt{y})$。\n$$F_Y(y) = \\int_{-\\sqrt{y}}^{\\sqrt{y}} \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz$$\n我们可以通过对 $Y$ 的 CDF 关于 $y$ 求导来找到其 PDF，使用莱布尼茨积分法则：\n$$f_Y(y) = \\frac{d}{dy} F_Y(y) = \\frac{1}{\\sqrt{2\\pi}} e^{-(\\sqrt{y})^2/2} \\cdot \\frac{d}{dy}(\\sqrt{y}) - \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-(-\\sqrt{y})^2/2} \\cdot \\frac{d}{dy}(-\\sqrt{y})\\right)$$\n$$f_Y(y) = \\frac{1}{\\sqrt{2\\pi}} e^{-y/2} \\left(\\frac{1}{2\\sqrt{y}}\\right) - \\frac{1}{\\sqrt{2\\pi}} e^{-y/2} \\left(-\\frac{1}{2\\sqrt{y}}\\right) = 2 \\cdot \\frac{1}{\\sqrt{2\\pi}} e^{-y/2} \\left(\\frac{1}{2\\sqrt{y}}\\right) = \\frac{1}{\\sqrt{2\\pi y}} e^{-y/2}$$\n这是当 $y  0$ 时的 PDF。\n\n现在，我们将其与 $\\operatorname{Gamma}(k, \\theta)$ 分布的 PDF 进行比较，其形式为 $f(x; k, \\theta) = \\frac{1}{\\Gamma(k)\\theta^k} x^{k-1} e^{-x/\\theta}$。\n题目指出，自由度为 $\\nu$ 的卡方分布 $\\chi^2(\\nu)$ 是伽马分布的一个特例，具体为 $\\operatorname{Gamma}(k=\\nu/2, \\theta=2)$。对于一个自由度（$\\nu=1$），这对应于 $\\operatorname{Gamma}(k=1/2, \\theta=2)$。\n让我们将 $k=1/2$ 和 $\\theta=2$ 代入伽马 PDF 公式。已知 $\\Gamma(1/2) = \\sqrt{\\pi}$：\n$$f(y; 1/2, 2) = \\frac{1}{\\Gamma(1/2) 2^{1/2}} y^{1/2-1} e^{-y/2} = \\frac{1}{\\sqrt{\\pi} \\sqrt{2}} y^{-1/2} e^{-y/2} = \\frac{1}{\\sqrt{2\\pi y}} e^{-y/2}$$\n这证实了 $Y=Z^2$ 的 PDF 确实是 $\\operatorname{Gamma}(1/2, 2)$ 分布的 PDF。这也被称为自由度为 1 的卡方分布，即 $\\chi^2(1)$。\n\n**第 2 步：平方和的分布**\n\n我们感兴趣的是和 $S_{\\nu} = \\sum_{k=1}^{\\nu} Z_k^2$。随机变量 $Z_k$ 是独立的，这意味着变量 $Y_k = Z_k^2$ 也是独立的。每个 $Y_k \\sim \\operatorname{Gamma}(1/2, 2)$。\n\n题目提供了伽马分布的一个关键性质：如果 $X_1 \\sim \\operatorname{Gamma}(k_1, \\theta)$ 和 $X_2 \\sim \\operatorname{Gamma}(k_2, \\theta)$ 是独立的，那么它们的和 $X_1+X_2 \\sim \\operatorname{Gamma}(k_1+k_2, \\theta)$。这种可加性可以推广到任意数量具有相同尺度参数 $\\theta$ 的独立伽马变量之和。\n\n将此性质应用于我们的和 $S_{\\nu}$：\n$$S_{\\nu} = \\sum_{k=1}^{\\nu} Y_k \\sim \\operatorname{Gamma}\\left(\\sum_{k=1}^{\\nu} \\frac{1}{2}, 2\\right) = \\operatorname{Gamma}\\left(\\frac{\\nu}{2}, 2\\right)$$\n因此，$\\nu$ 个独立标准正态变量的平方和服从形状参数为 $k=\\nu/2$、尺度参数为 $\\theta=2$ 的伽马分布。根据定义，这就是自由度为 $\\nu$ 的卡方分布，记为 $\\chi^2(\\nu)$。\n\n**第 3 步：均值和方差**\n\n题目指出，对于一个随机变量 $X \\sim \\operatorname{Gamma}(k, \\theta)$，其均值为 $\\mathbb{E}[X] = k\\theta$，方差为 $\\operatorname{Var}(X) = k\\theta^2$。\n对于我们的变量 $S_{\\nu} \\sim \\operatorname{Gamma}(\\nu/2, 2)$，我们有 $k = \\nu/2$ 和 $\\theta=2$。因此：\n- 均值：$\\mathbb{E}[S_{\\nu}] = \\left(\\frac{\\nu}{2}\\right) \\cdot 2 = \\nu$。\n- 方差：$\\operatorname{Var}(S_{\\nu}) = \\left(\\frac{\\nu}{2}\\right) \\cdot 2^2 = \\frac{\\nu}{2} \\cdot 4 = 2\\nu$。\n\n这些理论结果 $\\mathbb{E}[S_{\\nu}]=\\nu$ 和 $\\operatorname{Var}(S_{\\nu})=2\\nu$ 提供了基准真相，模拟中的样本统计量将与之比较以计算绝对误差。对于边界情况 $\\nu=0$，和是空和，定义为 $0$。分布在 $0$ 处退化，我们的公式也正确地给出了 $0$ 的均值和 $0$ 的方差。\n\n**实现策略**\n\n对于每个测试用例 $(\\nu, M, s)$，实现将分为两个主要部分。\n\n**A 部分：统计估计**\n使用给定的种子 $s$ 初始化一个伪随机数生成器 (PRNG)。我们将生成 $M$ 次对和 $S_{\\nu}$ 的独立抽样。为提高计算效率，当 $\\nu  0$ 时，最好的方法是生成一个 $M \\times \\nu$ 的 $\\mathcal{N}(0,1)$ 样本矩阵，将每个元素平方，然后按行求和，从而得到 $M$ 个 $S_{\\nu}$ 的值。根据这 $M$ 个值的样本，我们计算样本均值 $\\widehat{\\mu}$ 和无偏样本方差 $\\widehat{\\sigma}^2$（使用 $M-1$ 作为分母）。然后计算绝对误差 $|\\widehat{\\mu} - \\nu|$ 和 $|\\widehat{\\sigma}^2 - 2\\nu|$。对于 $\\nu=0$ 的情况，所有和都为 $0$，因此样本均值和方差都为 $0$，误差也为 $0$。\n\n**B 部分：数值稳定性评估**\n使用种子 $s+1337$ 初始化第二个独立的 PRNG。生成一个包含 $\\nu$ 个标准正态样本的向量。使用三种不同的算法计算这些样本的平方和，以突显浮点误差累积的影响，这在 $\\nu$ 很大时尤其重要。\n1.  **朴素求和 ($S_{\\text{naive}}$):** 在 Python 中使用标准的 `for` 循环累加求和。当将一个小数字加到一个已经很大的累加和上时，此方法容易丢失精度。\n2.  **Kahan 求和 ($S_{\\text{kahan}}$):** Kahan 补偿求和算法维护一个动态补偿项，用于跟踪和纠正每次加法中丢失的低位比特。这为求和提供了一个高度精确的“基准真相”。\n3.  **向量化求和 ($S_{\\text{np}}$):** 在样本向量 $v$ 上使用 `numpy.dot(v, v)` 来计算平方和。NumPy 底层的 BLAS/LAPACK 库通常采用数值稳定的技术，如成对求和或使用扩展精度累加器，使得这种方法比朴素求和要精确得多。\n\n然后计算相对差异 $r_1 = |S_{\\text{naive}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$ 和 $r_2 = |S_{\\text{np}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$。为了防止除以零，特殊处理 $S_{\\text{kahan}}=0$ 的情况，此时将两个差异都设为 $0$。这种情况仅当 $\\nu=0$ 时才会发生。\n\n最终代码将封装此逻辑，遍历所提供的测试用例并按规定格式化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (nu, M, s)\n        (0, 1000, 1234),          # Case A (boundary)\n        (10, 100000, 202311),      # Case B (happy path)\n        (200000, 200, 7),         # Case C (large-nu stability)\n    ]\n\n    all_results = []\n    for nu, M, s in test_cases:\n        results_for_case = process_case(nu, M, s)\n        all_results.extend(results_for_case)\n\n    # Format output as a single line: [res1,res2,res3,...]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef process_case(nu, M, s):\n    \"\"\"\n    Process a single test case (nu, M, s) and return a list of the four\n    required float values: [mean_err, var_err, r1, r2].\n    \"\"\"\n\n    # --- Part A: Statistical Estimation ---\n    \n    true_mean = float(nu)\n    true_variance = 2.0 * nu\n    \n    if nu == 0:\n        # Trivial case: sum is always 0.\n        mean_err = 0.0\n        var_err = 0.0\n    else:\n        rng_A = np.random.default_rng(seed=s)\n        # Generate M x nu standard normal variates\n        z_matrix = rng_A.standard_normal(size=(M, nu), dtype=np.float64)\n        # Square them and sum along rows to get M draws of the sum-of-squares\n        sums_of_squares = np.sum(z_matrix**2, axis=1)\n        \n        # Calculate sample mean and unbiased sample variance\n        mu_hat = np.mean(sums_of_squares)\n        sigma2_hat = np.var(sums_of_squares, ddof=1)\n        \n        # Calculate absolute errors\n        mean_err = abs(mu_hat - true_mean)\n        var_err = abs(sigma2_hat - true_variance)\n\n    # --- Part B: Numerical Stability Assessment ---\n\n    if nu == 0:\n        # Trivial case: all sums are 0, so discrepancies are 0.\n        r1 = 0.0\n        r2 = 0.0\n    else:\n        # Initialize a new RNG with a different seed for independence\n        rng_B = np.random.default_rng(seed=s + 1337)\n        z_vector = rng_B.standard_normal(size=nu, dtype=np.float64)\n        z_vector_sq = z_vector**2\n        \n        # 1. Naïve summation in a plain Python loop\n        s_naive = 0.0\n        for x in z_vector_sq:\n            s_naive += x\n            \n        # 2. Kahan compensated summation\n        s_kahan = 0.0\n        c = 0.0  # A running compensation for lost low-order bits.\n        for x in z_vector_sq:\n            y = x - c\n            t = s_kahan + y\n            c = (t - s_kahan) - y\n            s_kahan = t\n            \n        # 3. Vectorized numpy.dot summation\n        s_np = np.dot(z_vector, z_vector)\n        \n        # Calculate relative discrepancies using Kahan sum as the baseline\n        if s_kahan == 0.0:\n            # This case is extremely unlikely for nu > 0 but is handled for correctness.\n            r1 = 0.0\n            r2 = 0.0\n        else:\n            r1 = abs(s_naive - s_kahan) / s_kahan\n            r2 = abs(s_np - s_kahan) / s_kahan\n\n    return [mean_err, var_err, r1, r2]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3056438"}]}