{"hands_on_practices": [{"introduction": "本练习是模拟随机过程的第一步。我们将把一个随机微分方程的模拟分解为其最基本的组成部分：使用欧拉-丸山（Euler-Maruyama）方法的单个时间步。通过这个练习 [@problem_id:3067105]，你将具体理解确定性的漂移项和随机的扩散项是如何结合起来，共同推动过程在时间上向前演进的。", "problem": "考虑几何布朗运动，一个由 $dX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t$ 给出的随机微分方程 (SDE)，其中 $W_t$ 是一个标准布朗运动。在蒙特卡洛 (MC) 模拟中，时间在步长为 $\\Delta t = t_{n+1} - t_n$ 的均匀网格 $t_n$ 上被离散化。在每一步中，布朗增量 $\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 从均值为 $0$、方差为 $\\Delta t$ 的正态分布中采样，即 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$。\n\n给定参数值为 $\\mu = 0.05$，$\\sigma = 0.2$，当前状态为 $X_n = 50$，以及时间步长为 $\\Delta t = 0.01$。假设一次 MC 抽样产生了一个标准正态变量 $Z_n = 0.32$，我们设定 $\\Delta W_n = \\sqrt{\\Delta t}\\,Z_n$。使用从 $t_n$ 到 $t_{n+1}$ 的一个时间步长上 SDE 的第一性原理离散化，计算从 $X_n$ 开始，经过一个欧拉-丸山步后产生的更新值 $X_{n+1}$。\n\n将您的最终结果四舍五入到四位有效数字。", "solution": "几何布朗运动 SDE 由 $dX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t$ 给出。在一个小的时间区间 $[t_n, t_{n+1}]$ 上，步长为 $\\Delta t = t_{n+1} - t_n$，其积分形式为\n$$\nX_{t_{n+1}} - X_{t_n} = \\int_{t_n}^{t_{n+1}} \\mu X_s\\,ds + \\int_{t_n}^{t_{n+1}} \\sigma X_s\\,dW_s.\n$$\n一种一阶显式时间离散化方法，称为欧拉-丸山方法，通过在左端点评估被积函数并乘以步长来近似漂移积分，以及通过在左端点评估被积函数并乘以布朗增量来近似伊藤积分。因此，\n$$\nX_{n+1} \\approx X_n + \\mu X_n \\Delta t + \\sigma X_n \\Delta W_n.\n$$\n在蒙特卡洛实现中，布朗增量 $\\Delta W_n$ 根据 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$ 进行采样。一个方便的构造是使用一个标准正态变量 $Z_n \\sim \\mathcal{N}(0,1)$ 并设定\n$$\n\\Delta W_n = \\sqrt{\\Delta t}\\, Z_n.\n$$\n使用给定的值 $\\Delta t = 0.01$ 和 $Z_n = 0.32$，我们计算\n$$\n\\sqrt{\\Delta t} = \\sqrt{0.01} = 0.1,\n$$\n所以\n$$\n\\Delta W_n = 0.1 \\times 0.32 = 0.032.\n$$\n现在将 $\\mu = 0.05$，$\\sigma = 0.2$， $X_n = 50$ 以及 $\\Delta t = 0.01$，$\\Delta W_n = 0.032$ 代入欧拉-丸山更新公式：\n$$\nX_{n+1} = 50 + (0.05)(50)(0.01) + (0.2)(50)(0.032).\n$$\n逐项计算贡献：\n- 漂移项：$(0.05)(50)(0.01) = 0.05 \\times 0.5 = 0.025$。\n- 扩散项：$(0.2)(50)(0.032) = 0.2 \\times 1.6 = 0.32$。\n因此，\n$$\nX_{n+1} = 50 + 0.025 + 0.32 = 50.345.\n$$\n四舍五入到四位有效数字得到 $50.35$。", "answer": "$$\\boxed{50.35}$$", "id": "3067105"}, {"introduction": "虽然欧拉-丸山方法是基础，但存在更精确的数值格式。本练习将介绍米尔斯坦（Milstein）方法，这是一种通过引入一个源自伊藤-泰勒展开（Itô-Taylor expansion）的额外校正项来提高强收敛阶的更高阶格式。通过完成这个练习 [@problem_id:3067093]，你不仅能学会一种更复杂的技巧，还能更深入地洞察支撑这些数值方法的伊藤微积分（Itô calculus）原理。", "problem": "一个由布朗运动（维纳过程）驱动的标量随机微分方程 (SDE) 将几何布朗运动建模为 $dX_{t}=\\mu X_{t}\\,dt+\\sigma X_{t}\\,dW_{t}$，其中 $\\mu$ 和 $\\sigma$ 是实常数， $W_{t}$ 是标准布朗运动。在随机微分方程的蒙特卡洛 (MC) 模拟中，通过使用布朗增量 $\\Delta W_{n}$ 将状态 $X_{t}$ 在一个微小的时间步长 $\\Delta t$ 上推进，从而构建样本路径的离散时间强近似。该增量由标准正态变量 $Z_{n}\\sim\\mathcal{N}(0,1)$ 生成为 $\\Delta W_{n}=\\sqrt{\\Delta t}\\,Z_{n}$。\n\n使用 Itô 积分和 Itô–Taylor 展开（截断到能产生一阶强收敛格式的项），推导上述 SDE 在步长为 $\\Delta t$ 上的单步 Milstein 更新格式，该格式用 $X_{n}$、$\\Delta W_{n}$ 以及系数 $\\mu$ 和 $\\sigma$ 表示。然后，使用具体输入值 $\\mu=0.12$、$\\sigma=0.5$、$X_{n}=0.8$、$\\Delta t=0.01$ 和 $\\Delta W_{n}=0.09$（这与当 $Z_{n}=0.9$ 时，蒙特卡洛构造 $\\Delta W_{n}=\\sqrt{\\Delta t}\\,Z_{n}$ 一致）来计算此更新的值。将你的数值答案四舍五入到 $5$ 位有效数字。以无单位的单个数字形式提供最终答案。", "solution": "### Milstein 格式的推导\n\n一个一般的标量SDE具有以下形式：\n$$ dX_t = a(X_t) \\, dt + b(X_t) \\, dW_t $$\n其中 $a(X_t)$ 是漂移系数，$b(X_t)$ 是扩散系数。对于给定的几何布朗运动问题，我们有：\n$$ a(X_t) = \\mu X_t $$\n$$ b(X_t) = \\sigma X_t $$\n\nMilstein 格式是从 Itô-Taylor 展开式推导出的一个 $1.0$ 阶强近似。为了推导它，我们从SDE在时间区间 $[t, t+\\Delta t]$ 上的积分形式开始：\n$$ X_{t+\\Delta t} = X_t + \\int_{t}^{t+\\Delta t} a(X_s) \\, ds + \\int_{t}^{t+\\Delta t} b(X_s) \\, dW_s $$\n\n我们对被积函数进行近似。漂移项近似为：\n$$ \\int_{t}^{t+\\Delta t} a(X_s) \\, ds \\approx a(X_t) \\int_{t}^{t+\\Delta t} ds = a(X_t) \\Delta t $$\n\n对于随机积分，需要比 Euler-Maruyama 格式中使用的更精确的近似。我们使用 Itô 公式将积分项 $b(X_s)$ 在 $X_t$ 附近展开，保留到增量的一阶项：\n$$ b(X_s) \\approx b(X_t) + (X_s - X_t) b'(X_t) $$\n对于小区间内的项 $(X_s - X_t)$，我们可以使用最低阶的近似，即扩散部分：\n$$ X_s - X_t \\approx \\int_t^s b(X_u) \\, dW_u \\approx b(X_t) (W_s - W_t) $$\n将此代入 $b(X_s)$ 的展开式中：\n$$ b(X_s) \\approx b(X_t) + b(X_t) b'(X_t) (W_s - W_t) $$\n现在，我们将其代回到随机积分中：\n$$ \\int_{t}^{t+\\Delta t} b(X_s) \\, dW_s \\approx \\int_{t}^{t+\\Delta t} \\left[ b(X_t) + b(X_t) b'(X_t) (W_s - W_t) \\right] \\, dW_s $$\n$$ = b(X_t) \\int_{t}^{t+\\Delta t} dW_s + b(X_t) b'(X_t) \\int_{t}^{t+\\Delta t} (W_s - W_t) \\, dW_s $$\n令 $\\Delta W_t = W_{t+\\Delta t} - W_t$。第一个积分就是 $b(X_t) \\Delta W_t$。第二个积分是一个著名的迭代 Itô 积分：\n$$ \\int_{t}^{t+\\Delta t} (W_s - W_t) \\, dW_s = \\frac{1}{2} \\left[ (W_{t+\\Delta t} - W_t)^2 - \\Delta t \\right] = \\frac{1}{2} ((\\Delta W_t)^2 - \\Delta t) $$\n结合所有项，我们得到增量 $X_{t+\\Delta t} - X_t$ 的近似值：\n$$ X_{t+\\Delta t} - X_t \\approx a(X_t) \\Delta t + b(X_t) \\Delta W_t + \\frac{1}{2} b(X_t) b'(X_t) ((\\Delta W_t)^2 - \\Delta t) $$\n将其写成从时间步 $n$ 到 $n+1$ 的离散形式，我们得到通用的单步 Milstein 更新法则：\n$$ X_{n+1} = X_n + a(X_n) \\Delta t + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) ((\\Delta W_n)^2 - \\Delta t) $$\n其中 $b'(X_n) = \\frac{\\partial b}{\\partial x}|_{X=X_n}$。\n\n现在，我们将这个通用格式应用于几何布朗运动的特定SDE：\n$dX_{t}=\\mu X_{t}\\,dt+\\sigma X_{t}\\,dW_{t}$。\n系数为：\n- 漂移项：$a(X_n) = \\mu X_n$\n- 扩散项：$b(X_n) = \\sigma X_n$\n我们需要扩散系数相对于 $X$ 的导数：\n$$ b'(X_n) = \\frac{\\partial}{\\partial X_n}(\\sigma X_n) = \\sigma $$\n将这些代入通用的 Milstein 公式中，得到：\n$$ X_{n+1} = X_n + (\\mu X_n) \\Delta t + (\\sigma X_n) \\Delta W_n + \\frac{1}{2} (\\sigma X_n) (\\sigma) ((\\Delta W_n)^2 - \\Delta t) $$\n化简后，我们得到几何布朗运动的 Milstein 更新格式：\n$$ X_{n+1} = X_n + \\mu X_n \\Delta t + \\sigma X_n \\Delta W_n + \\frac{1}{2} \\sigma^2 X_n ((\\Delta W_n)^2 - \\Delta t) $$\n这也可以通过提出因子 $X_n$ 来写成：\n$$ X_{n+1} = X_n \\left( 1 + \\mu \\Delta t + \\sigma \\Delta W_n + \\frac{1}{2} \\sigma^2 ((\\Delta W_n)^2 - \\Delta t) \\right) $$\n\n### 数值计算\n\n给定以下数值：\n- $\\mu = 0.12$\n- $\\sigma = 0.5$\n- $X_{n} = 0.8$\n- $\\Delta t = 0.01$\n- $\\Delta W_{n} = 0.09$\n\n我们将这些值代入推导出的 Milstein 更新方程中：\n$$ X_{n+1} = 0.8 + (0.12)(0.8)(0.01) + (0.5)(0.8)(0.09) + \\frac{1}{2}(0.5)^2(0.8)( (0.09)^2 - 0.01 ) $$\n\n我们来计算每一项：\n1. 初始值：$X_n = 0.8$\n2. 漂移项：$\\mu X_n \\Delta t = (0.12)(0.8)(0.01) = 0.00096$\n3. 扩散项：$\\sigma X_n \\Delta W_n = (0.5)(0.8)(0.09) = 0.036$\n4. Milstein 修正项：$\\frac{1}{2} \\sigma^2 X_n ((\\Delta W_n)^2 - \\Delta t)$\n   - $(\\Delta W_n)^2 = (0.09)^2 = 0.0081$\n   - $(\\Delta W_n)^2 - \\Delta t = 0.0081 - 0.01 = -0.0019$\n   - $\\frac{1}{2} \\sigma^2 X_n = \\frac{1}{2} (0.5)^2 (0.8) = \\frac{1}{2} (0.25) (0.8) = (0.125)(0.8) = 0.1$\n   - 修正项 = $(0.1)(-0.0019) = -0.00019$\n\n将所有部分相加：\n$$ X_{n+1} = 0.8 + 0.00096 + 0.036 - 0.00019 $$\n$$ X_{n+1} = 0.83696 - 0.00019 $$\n$$ X_{n+1} = 0.83677 $$", "answer": "$$\n\\boxed{0.83677}\n$$", "id": "3067093"}, {"introduction": "我们如何判断一个模拟方法是否“好”？这最后一个练习将从单个时间步的计算，转向一个全面的数值实验，来衡量模拟格式的质量。你将实现欧拉-丸山方法，通过经验数据来验证其理论上的强收敛和弱收敛速度 [@problem_id:3067097]，并学习路径耦合（path coupling）和对数-对数误差分析（log-log error analysis）等专业技巧，这些技巧在验证量化金融和计算科学中的数值方法时至关重要。", "problem": "设计并实现一个独立的数值实验，通过细化时间步长并比较路径误差和期望误差，以经验方式估计应用于随机微分方程 (SDE) 的时间离散化方法的强收敛和弱收敛速率。\n\n您的工作必须基于以下基本设置和定义。\n\n1. 随机微分方程模型。考虑几何布朗运动 (GBM) SDE\n$$\ndX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t,\\quad X_0>0,\n$$\n其中 $W_t$ 是标准布朗运动，$\\mu,\\sigma \\in \\mathbb{R}$ 是常数。对于时间离散化，使用欧拉-丸山 (EM) 方法，这是从伊藤积分定义和增量近似 $dW_t \\approx \\Delta W$（其中 $\\Delta W \\sim \\mathcal{N}(0,\\Delta t)$）推导出的最基本格式。\n\n2. 误差概念。对于固定的最终时间 $T>0$，令 $X_T^{\\Delta t}$ 表示时间步长为 $\\Delta t$ 时在时间 $T$ 的 EM 近似值。定义：\n- 时间 $T$ 的强误差为\n$$\ne_{\\text{strong}}(\\Delta t) = \\left(\\mathbb{E}\\left[\\,|X_T^{\\Delta t}-X_T|^2\\,\\right]\\right)^{1/2}.\n$$\n- 对于测试函数 $\\varphi$，时间 $T$ 的弱误差为\n$$\ne_{\\text{weak}}(\\Delta t) = \\left|\\,\\mathbb{E}\\left[\\varphi\\left(X_T^{\\Delta t}\\right)\\right] - \\mathbb{E}\\left[\\varphi\\left(X_T\\right)\\right]\\right|.\n$$\n\n3. 蒙特卡洛 (MC) 实验设计。使用蒙特卡洛方法对一系列细化的时间步长 $\\Delta t$ 估计这些误差。对于强误差，通过重用一个单一的精细布朗网格来耦合不同细化程度下的布朗路径，其增量被求和以形成较粗网格的增量。对于弱误差，在 EM 的终端值上评估 $\\varphi$，并与从第一性原理得到的 $\\mathbb{E}[\\varphi(X_T)]$ 的精确值进行比较。使用以下测试函数以确保目标具有封闭形式解：\n- 情况 $\\varphi(x)=x^k$，其中 $k \\in \\{1,2\\}$。\n\n4. 收敛速率。对于每个递减的时间步长序列 $\\{\\Delta t_\\ell\\}$ 和相应的误差估计 $\\{e(\\Delta t_\\ell)\\}$，通过对 $\\log e(\\Delta t_\\ell)$ 与 $\\log \\Delta t_\\ell$ 进行线性最小二乘拟合来估计经验收敛速率 $p$，即拟合\n$$\n\\log e(\\Delta t_\\ell) \\approx a + p \\,\\log \\Delta t_\\ell,\n$$\n并将斜率 $p$ 作为估计的速率。\n\n程序要求和测试套件。\n\nA. 实现一个程序，该程序：\n- 针对由 $M \\in \\{4,8,16,32,64\\}$ 个均匀子区间形成的一系列时间步长（即 $\\Delta t = T/M$），模拟 GBM 到时间 $T$ 的 EM 近似。\n- 使用具有 $M_{\\max}=64$ 的单一最精细网格生成布朗增量 $\\Delta W$；通过对不相交的连续精细增量块求和来获得较粗级别的增量，以强制实现跨细化级别的路径耦合。\n- 通过在耦合路径上进行蒙特卡洛均方根 (RMS) 计算来估计强误差，其中使用在相同布朗终端值上评估的精确解 $X_T$ 来逐路径定义 $X_T$。\n- 使用 $\\varphi(X_T^{\\Delta t})$ 的蒙特卡洛平均值和从 GBM 分布律推导出的 $\\mathbb{E}[\\varphi(X_T)]$ 的精确值来估计弱误差。\n- 使用 $N$ 条蒙特卡洛路径和固定的随机种子以保证可复现性。\n\nB. 使用以下参数集测试套件，涵盖典型、边界和类边缘情况。对于每个测试用例，按顺序报告两个浮点数：估计的强收敛速率和估计的弱收敛速率。\n\n- 测试用例 1 (理想情况): $X_0=1.0$, $\\mu=0.3$, $\\sigma=0.5$, $T=1.0$, $\\varphi(x)=x$ (即 $k=1$), $N=20000$, seed $=12345$。\n- 测试用例 2 (边界情况: 零漂移，非线性矩): $X_0=2.0$, $\\mu=0.0$, $\\sigma=0.8$, $T=2.0$, $\\varphi(x)=x^2$ (即 $k=2$), $N=20000$, seed $=12346$。\n- 测试用例 3 (类边缘情况: 负漂移，大波动率，短时间范围): $X_0=1.5$, $\\mu=-0.2$, $\\sigma=1.2$, $T=0.5$, $\\varphi(x)=x$ (即 $k=1$), $N=20000$, seed $=12347$。\n\nC. 最终输出格式。您的程序应生成单行输出，其中包含结果，格式为浮点数列表的列表，每个内部列表对应于上述顺序的一个测试用例：\n- 格式必须为\n$$\n\\big[ [p_{\\text{strong},1},\\, p_{\\text{weak},1}],\\; [p_{\\text{strong},2},\\, p_{\\text{weak},2}],\\; [p_{\\text{strong},3},\\, p_{\\text{weak},3}] \\big],\n$$\n每个浮点数四舍五入到三位小数。\n\n不允许使用外部输入或文件。程序必须能直接运行，并遵循指定的随机种子。不涉及物理单位或角度单位。输出必须是严格符合指定格式的单行文本。", "solution": "目标是凭经验确定欧拉-丸山 (EM) 方法应用于几何布朗运动 (GBM) 随机微分方程 (SDE) 的强收敛和弱收敛速率。这将通过一个蒙特卡洛模拟实验来完成，其中时间步长被细化，并对产生的误差进行分析。\n\n### 1. 理论框架\n\n#### 1.1. 几何布朗运动 SDE 及其解\n问题基于几何布朗运动 SDE：\n$$\ndX_t = \\mu X_t \\,dt + \\sigma X_t \\,dW_t, \\quad X(0) = X_0 > 0\n$$\n其中 $\\mu$ 是漂移率，$\\sigma$ 是波动率，$W_t$ 是一个标准维纳过程 (布朗运动)。该 SDE 拥有已知的强解，可以通过对 $f(x) = \\log(x)$ 使用 Itô 引理找到。在时间 $T$ 的过程解为：\n$$\nX_T = X_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T \\right)\n$$\n在此，$W_T$ 是一个正态分布的随机变量，$W_T \\sim \\mathcal{N}(0, T)$。这个精确解对于计算强收敛分析所需的路径误差至关重要。\n\n#### 1.2. 欧拉-丸山离散化\n欧拉-丸山方法是一种用于近似 SDE 解的数值格式。对于一个离散为 $M$ 个步长为 $\\Delta t = T/M$ 的时间区间 $[0, T]$，GBM SDE 的格式由以下迭代公式给出：\n$$\nX_{n+1} = X_n + \\mu X_n \\Delta t + \\sigma X_n \\Delta W_{n+1}\n$$\n其中 $X_n$ 是在时间 $t_n = n\\Delta t$ 时 $X_{t_n}$ 的近似值。项 $\\Delta W_{n+1} = W_{t_{n+1}} - W_{t_n}$ 是维纳过程的一个增量，它被模拟为一个从正态分布 $\\mathcal{N}(0, \\Delta t)$ 中抽取的独立随机变量。在时间 $T$ 该近似的终端值记为 $X_T^{\\Delta t}$。\n\n#### 1.3. 误差定义和收敛速率\n分析依赖于两种类型的误差度量。\n-   **强误差** 衡量数值近似与精确解之间的路径平均偏差。它被定义为均方根误差：\n    $$\n    e_{\\text{strong}}(\\Delta t) = \\left( \\mathbb{E}\\left[ |X_T^{\\Delta t} - X_T|^2 \\right] \\right)^{1/2}\n    $$\n    强收敛速率 $p_{\\text{strong}}$ 满足 $e_{\\text{strong}}(\\Delta t) = \\mathcal{O}((\\Delta t)^{p_{\\text{strong}}})$。对于欧拉-丸山方法，理论强收敛速率为 $p_{\\text{strong}} = 0.5$。\n\n-   **弱误差** 衡量解的函数期望值的误差。对于给定的测试函数 $\\varphi$，它被定义为：\n    $$\n    e_{\\text{weak}}(\\Delta t) = \\left| \\mathbb{E}\\left[\\varphi\\left(X_T^{\\Delta t}\\right)\\right] - \\mathbb{E}\\left[\\varphi\\left(X_T\\right)\\right] \\right|\n    $$\n    弱收敛速率 $p_{\\text{weak}}$ 满足 $e_{\\text{weak}}(\\Delta t) = \\mathcal{O}((\\Delta t)^{p_{\\text{weak}}})$。对于欧拉-丸山方法，理论弱收敛速率为 $p_{\\text{weak}} = 1.0$。\n\n对于此问题，测试函数是单项式 $\\varphi(x) = x^k$。精确期望 $\\mathbb{E}[\\varphi(X_T)] = \\mathbb{E}[X_T^k]$ 可以从 $X_T$ 的对数正态分布计算得出。由于 $\\ln(X_T) \\sim \\mathcal{N}\\left(\\ln(X_0) + (\\mu - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T\\right)$，第 $k$ 阶矩为：\n$$\n\\mathbb{E}[X_T^k] = X_0^k \\exp\\left( k\\mu T + \\frac{1}{2}k(k-1)\\sigma^2 T \\right)\n$$\n该公式提供了精确值，用于与数值平均值 $\\mathbb{E}[\\varphi(X_T^{\\Delta t})]$ 进行比较。\n\n### 2. 数值实验设计\n\n收敛速率从数值实验中凭经验估计。\n\n#### 2.1. 蒙特卡洛模拟和路径耦合\n我们生成 $N$ 条独立的样本路径来估计期望值。强误差估计的一个关键要素是**路径耦合**。为确保差值 $|X_T^{\\Delta t} - X_T|$ 有意义，近似解和精确解都必须由底层布朗路径 $W_t$ 的相同实现驱动。我们通过在最精细的网格上生成一组布朗增量来实现这一点，该网格有 $M_{\\max}$ 个步长。设这些精细增量为 $\\{\\Delta W_i^{\\text{fine}}\\}_{i=1}^{M_{\\max}}$。一个具有 $M  M_{\\max}$ 步长的较粗网格（其中 $M$ 可整除 $M_{\\max}$）使用通过对精细增量块求和形成的增量 $\\Delta W_j^{\\text{coarse}}$：\n$$\n\\Delta W_j^{\\text{coarse}} = \\sum_{i=(j-1)S+1}^{jS} \\Delta W_i^{\\text{fine}}, \\quad \\text{其中 } S = M_{\\max} / M\n$$\n因此，最终时刻的总布朗运动 $W_T = \\sum_i \\Delta W_i$ 对于所有离散化级别都是相同的，从而实现了有效的逐路径比较。\n\n#### 2.2. 误差估计\n误差定义中的期望通过对 $N$ 条样本路径的蒙特卡洛平均来近似。\n-   强误差通过以下方式估计：\n    $$\n    \\hat{e}_{\\text{strong}}(\\Delta t) = \\left( \\frac{1}{N} \\sum_{j=1}^{N} \\left| X_{T, j}^{\\Delta t} - X_{T, j} \\right|^2 \\right)^{1/2}\n    $$\n    其中 $j$ 是蒙特卡洛路径的索引。\n-   弱误差通过以下方式估计：\n    $$\n    \\hat{e}_{\\text{weak}}(\\Delta t) = \\left| \\left( \\frac{1}{N} \\sum_{j=1}^{N} \\varphi(X_{T, j}^{\\Delta t}) \\right) - \\mathbb{E}[\\varphi(X_T)] \\right|\n    $$\n\n#### 2.3. 收敛速率计算\n我们为 $M_\\ell \\in \\{4, 8, 16, 32, 64\\}$ 生成一系列时间步长 $\\{\\Delta t_\\ell = T/M_\\ell\\}$，并计算相应的误差估计 $\\{\\hat{e}(\\Delta t_\\ell)\\}$。收敛速率 $p$ 通过拟合模型 $\\log \\hat{e}(\\Delta t_\\ell) \\approx a + p \\log \\Delta t_\\ell$ 来确定。这是一个关于 $(\\log \\Delta t_\\ell, \\log \\hat{e}(\\Delta t_\\ell))$ 的线性回归问题。最佳拟合线的斜率 $p$ 就是估计的收敛速率。这可以使用标准方法计算，例如 1 次多项式拟合。\n\n### 3. 实现\n对于每个测试用例，实现将遵循以下步骤：\n1.  设置参数 $X_0, \\mu, \\sigma, T, k, N$ 及随机种子。\n2.  生成 $N \\times M_{\\max}$ 个标准正态随机变量，并进行缩放以表示精细网格的布朗增量 $\\Delta W_i^{\\text{fine}}$。\n3.  对于 $N$ 条路径中的每一条，使用所有精细增量之和作为 $W_T$ 来计算精确的终端值 $X_T$。\n4.  计算精确矩 $\\mathbb{E}[\\varphi(X_T)]$。\n5.  遍历指定的细化级别 $M \\in \\{4, 8, 16, 32, 64\\}$：\n    a. 通过对精细增量块求和来构建较粗的布朗增量。\n    b. 模拟 EM 路径到时间 $T$ 以获得 $X_T^{\\Delta t}$。\n    c. 计算并存储该 $\\Delta t$ 的强弱误差估计。\n6.  对误差与时间步长的对数-对数图执行线性回归，以找到斜率，即估计的强弱收敛速率。\n7.  收集所有测试用例的结果，并将其格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to estimate strong and weak\n    convergence rates for the Euler-Maruyama method applied to the Geometric\n    Brownian Motion SDE.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (X0, mu, sigma, T, k, N, seed)\n        (1.0, 0.3, 0.5, 1.0, 1, 20000, 12345),\n        (2.0, 0.0, 0.8, 2.0, 2, 20000, 12346),\n        (1.5, -0.2, 1.2, 0.5, 1, 20000, 12347)\n    ]\n\n    # Levels of discretization (number of steps)\n    M_levels = [4, 8, 16, 32, 64]\n    M_max = 64\n\n    results = []\n    for case in test_cases:\n        X0, mu, sigma, T, k, N, seed = case\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # --- Monte Carlo Simulation Setup ---\n        \n        # Generate all Brownian increments for the finest grid (M_max)\n        # These are used to build increments for all coarser grids\n        dt_fine = T / M_max\n        fine_shocks = rng.normal(loc=0.0, scale=np.sqrt(dt_fine), size=(N, M_max))\n\n        # Calculate the exact solution X_T for each path\n        # W_T is the sum of all fine increments\n        W_T = fine_shocks.sum(axis=1)\n        X_T_exact = X0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * W_T)\n\n        # Calculate the exact expectation for the weak error component\n        # E[X_T^k] = X0^k * exp(k*mu*T + 0.5*k*(k-1)*sigma^2*T)\n        exact_moment = (X0**k) * np.exp(k * mu * T + 0.5 * k * (k - 1) * (sigma**2) * T)\n\n        # Store errors and step sizes for regression\n        dts = []\n        strong_errors = []\n        weak_errors = []\n\n        # --- Loop over refinement levels ---\n        for M in M_levels:\n            dt = T / M\n            dts.append(dt)\n\n            # --- Path Generation (Euler-Maruyama) ---\n            \n            # Construct coarse Brownian increments from fine ones (path coupling)\n            # Sum blocks of fine_shocks to get shocks for the current grid size M\n            step_size = M_max // M\n            coarse_shocks = fine_shocks.reshape(N, M, step_size).sum(axis=2)\n\n            # Simulate paths using Euler-Maruyama\n            X_em = np.full(N, X0)\n            for i in range(M):\n                # The formula is X_{n+1} = X_n * (1 + mu*dt + sigma*dW)\n                X_em += mu * X_em * dt + sigma * X_em * coarse_shocks[:, i]\n            \n            X_T_em = X_em\n\n            # --- Error Calculation ---\n\n            # Strong error: (E[|X_T^EM - X_T_exact|^2])^0.5\n            strong_error = np.sqrt(np.mean((X_T_em - X_T_exact)**2))\n            strong_errors.append(strong_error)\n\n            # Weak error: |E[phi(X_T^EM)] - E[phi(X_T_exact)]|\n            # where phi(x) = x^k\n            em_moment = np.mean(X_T_em**k)\n            weak_error = np.abs(em_moment - exact_moment)\n            weak_errors.append(weak_error)\n\n        # --- Convergence Rate Estimation ---\n        \n        # Use linear regression on log-log data to find the slope (rate)\n        # log(error) = a + p * log(dt)\n        # np.polyfit(x, y, 1) returns [p, a]\n        \n        log_dts = np.log(dts)\n        \n        # Strong rate\n        log_strong_errors = np.log(strong_errors)\n        p_strong = np.polyfit(log_dts, log_strong_errors, 1)[0]\n        \n        # Weak rate\n        log_weak_errors = np.log(weak_errors)\n        p_weak = np.polyfit(log_dts, log_weak_errors, 1)[0]\n        \n        results.append([p_strong, p_weak])\n\n    # --- Final Output Formatting ---\n    # The format must be [[p_strong,1, p_weak,1], [p_strong,2, p_weak,2], [p_strong,3, p_weak,3]]\n    # Each float is rounded to three decimal places.\n    output_str = f\"[[{', '.join([f'[{s:.3f}, {w:.3f}]' for s, w in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3067097"}]}