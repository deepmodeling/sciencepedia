{"hands_on_practices": [{"introduction": "布朗运动最引人注目的特性之一是其路径虽然处处连续但处处不可微，这与其非零的二次变分紧密相关。这个实践练习将让你通过数值模拟来亲手验证广义布朗运动 $X_t = \\mu t + \\sigma W_t$ 的二次变分理论值 $[X]_T = \\sigma^2 T$。通过编写代码，你将观察到二次变分是如何从大量微小、独立的随机增量的平方和中涌现出来的，并理解为何在极限情况下，过程的漂移项对二次变分没有贡献 [@problem_id:3074681]。", "problem": "考虑一个实值标准布朗运动 $W_t$，满足 $W_0=0$，定义在一个满足通常条件的带滤概率空间上。标准布朗运动的特征是其具有独立增量和平稳高斯增量，即对于任意 $0 \\leq s \\leq t$，增量 $W_t - W_s$ 是均值为 $0$、方差为 $t - s$ 的高斯分布，并且对于不相交的时间区间，其增量是独立的。对于区间 $[0,T]$ 的一个分割 $\\mathcal{P} = \\{0 = t_0  t_1  \\cdots  t_n = T\\}$，过程 $X_t$ 在 $[0,T]$ 上沿 $\\mathcal{P}$ 的二次变差定义为\n$$\n[X]_T(\\mathcal{P}) = \\sum_{i=1}^n \\left(X_{t_i} - X_{t_{i-1}}\\right)^2\n$$\n而二次变差 $[X]_T$ 是当分割的网格趋于零时 $[X]_T(\\mathcal{P})$ 的极限（如果该极限存在）。一个基本且经过充分验证的事实是，标准布朗运动的二次变差为 $[W]_T = T$。更一般地，对于过程 $X_t = \\mu t + \\sigma W_t$，其中常数 $\\mu \\in \\mathbb{R}$ 且 $\\sigma > 0$，我们有 $[X]_T = \\sigma^2 T$。\n\n您的任务是设计一个程序，使用将 $[0,T]$ 划分为 $n$ 个相等子区间的均匀分割，来数值估计过程 $X_t = \\mu t + \\sigma W_t$ 路径的二次变差。数值估计量是离散和\n$$\n\\widehat{[X]}_T^{(n)} = \\sum_{i=1}^n \\left(\\Delta X_i\\right)^2, \\quad \\text{其中} \\quad \\Delta X_i = X_{t_i} - X_{t_{i-1}}\n$$\n模拟必须使用布朗增量的特征：对于每个长度为 $\\Delta t = T/n$ 的子区间，增量 $\\Delta W_i$ 服从 $\\mathcal{N}(0, \\Delta t)$ 分布，并且在不同的 $i$ 之间是独立的。因此对于 $X_t = \\mu t + \\sigma W_t$，我们有 $\\Delta X_i = \\mu \\Delta t + \\sigma \\Delta W_i$。\n\n请使用以下测试套件，其中每个测试用例由元组 $(T, n, M, \\mu, \\sigma, \\text{seed})$ 指定：\n- 测试用例 1 (精细分割，标准布朗运动): $(1.0, 2048, 2000, 0.0, 1.0, 12345)$。\n- 测试用例 2 (粗糙分割边界，标准布朗运动): $(1.0, 1, 100000, 0.0, 1.0, 23456)$。\n- 测试用例 3 (带漂移和缩放的布朗运动): $(2.0, 4096, 1000, 1.0, 0.5, 34567)$。\n- 测试用例 4 (零时间边界): $(0.0, 50, 1000, 3.0, 7.0, 45678)$。\n- 测试用例 5 (波动率缩放检查): $(0.5, 1024, 1500, 0.0, 2.0, 56789)$。\n\n对于每个测试用例：\n1. 使用 $n$ 个相等的时间步长，通过在每个子区间上生成 $W_t$ 的独立高斯增量，来模拟 $X_t$ 在 $[0,T]$ 上的 $M$ 条独立路径。\n2. 为每条路径计算二次变差估计量 $\\widehat{[X]}_T^{(n)}$，并返回这 $M$ 条路径的样本均值，作为该测试用例的数值估计结果。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个条目是其对应测试用例的 $\\widehat{[X]}_T^{(n)}$ 样本均值，四舍五入到六位小数。例如，输出格式必须严格遵循以下形式\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]\n$$\n其中每个 $\\text{result}$ 是一个四舍五入到六位小数的浮点数。本问题不涉及任何物理单位或角度单位。", "solution": "此问题是有效的。它在科学上基于随机过程理论，问题陈述适定，提供了所有必要的参数和条件，并且在计算上是可行的。\n\n目标是数值估计一个广义布朗运动过程的二次变差，并计算其在大量模拟路径上的样本均值。该过程定义为 $X_t = \\mu t + \\sigma W_t$，其中 $W_t$ 是标准布朗运动，$\\mu \\in \\mathbb{R}$ 是漂移参数，$\\sigma > 0$ 是波动率参数。理论上已知，该过程在区间 $[0, T]$ 上的二次变差为 $[X]_T = \\sigma^2 T$。\n\n我们的任务是为这个量实现一个数值估计量。问题指定使用将时间区间 $[0,T]$ 分成 $n$ 个等长子区间的均匀分割，子区间长度为 $\\Delta t = T/n$。分割点为 $t_i = i \\Delta t$，其中 $i = 0, 1, \\dots, n$。\n\n二次变差的数值估计量，记为 $\\widehat{[X]}_T^{(n)}$，定义为过程在该分割上的增量平方和：\n$$\n\\widehat{[X]}_T^{(n)} = \\sum_{i=1}^n (X_{t_i} - X_{t_{i-1}})^2 = \\sum_{i=1}^n (\\Delta X_i)^2\n$$\n\n为了模拟该过程，我们必须首先确定增量 $\\Delta X_i$ 的特征。根据 $X_t$ 的定义：\n$$\n\\Delta X_i = X_{t_i} - X_{t_{i-1}} = (\\mu t_i + \\sigma W_{t_i}) - (\\mu t_{i-1} + \\sigma W_{t_{i-1}})\n$$\n整理各项，我们得到：\n$$\n\\Delta X_i = \\mu(t_i - t_{i-1}) + \\sigma(W_{t_i} - W_{t_{i-1}}) = \\mu \\Delta t + \\sigma \\Delta W_i\n$$\n此处，$\\Delta W_i = W_{t_i} - W_{t_{i-1}}$ 是标准布朗运动的增量。布朗运动的一个基本性质是，其在不相交时间区间上的增量是独立的，并且服从正态分布。具体来说，对于长度为 $\\Delta t$ 的区间，增量 $\\Delta W_i$ 服从均值为 $0$、方差为 $\\Delta t$ 的正态分布，即 $\\Delta W_i \\sim \\mathcal{N}(0, \\Delta t)$。\n\n为了从 $\\mathcal{N}(0, \\Delta t)$ 生成一个随机变量，我们可以生成一个标准正态随机变量 $Z_i \\sim \\mathcal{N}(0, 1)$，然后用标准差 $\\sqrt{\\Delta t}$ 对其进行缩放。因此，我们可以写成：\n$$\n\\Delta W_i = \\sqrt{\\Delta t} \\cdot Z_i, \\quad \\text{其中 } Z_i \\sim \\mathcal{N}(0, 1) \\text{ 且是独立同分布的}\n$$\n将此代入 $\\Delta X_i$ 的表达式，我们得到单个增量的核心模拟公式：\n$$\n\\Delta X_i = \\mu \\Delta t + \\sigma \\sqrt{\\Delta t} \\cdot Z_i\n$$\n\n对于由参数 $(T, n, M, \\mu, \\sigma, \\text{seed})$ 指定的单个测试用例，算法如下：\n1. 使用提供的 `seed` 初始化随机数生成器，以确保可复现性。\n2. 处理 $T=0$ 的边界情况。在这种情况下，$\\Delta t = 0$，所有增量 $\\Delta X_i$ 均为 $0$，因此二次变差估计量 $\\widehat{[X]}_0^{(n)}$ 确定性地为 $0$。\n3. 对于 $T>0$，计算时间步长 $\\Delta t = T/n$。\n4. 模拟需要生成 $M$ 条独立路径。一种高效的方法是使用向量化。我们不是逐条路径模拟，而是一次性为所有路径和所有时间步生成所有随机数。我们创建一个 $M \\times n$ 的独立标准正态变量矩阵 $Z$，其中每个元素 $Z_{m,i}$ 对应于第 $m$ 条路径的第 $i$ 个时间步。\n5. 使用这个矩阵 $Z$，我们通过一次向量化操作计算出 $M \\times n$ 的增量矩阵 $\\Delta X$：\n   $$\n   \\Delta X = \\mu \\Delta t + \\sigma \\sqrt{\\Delta t} \\cdot Z\n   $$\n   在这里，算术运算是按元素执行的。\n6. 接下来，我们通过对矩阵 $\\Delta X$ 进行按元素平方来计算增量的平方。\n7. 对于每条路径（即，对于增量平方矩阵的每一行），我们将所有 $n$ 个时间步的元素相加。这将产生一个包含 $M$ 个值的向量，其中每个值是对应一条路径的二次变差估计值 $\\widehat{[X]}_{T,m}^{(n)}$，其中 $m=1, \\dots, M$。\n   $$\n   \\widehat{[X]}_{T,m}^{(n)} = \\sum_{i=1}^n (\\Delta X_{m,i})^2\n   $$\n8. 最后，我们计算这 $M$ 个估计值的样本均值。根据大数定律，这个样本均值将是估计量期望值 $E[\\widehat{[X]}_T^{(n)}]$ 的一个良好近似。\n   $$\n   \\text{结果} = \\frac{1}{M} \\sum_{m=1}^M \\widehat{[X]}_{T,m}^{(n)}\n   $$\n   该估计量的期望值为 $E[\\widehat{[X]}_T^{(n)}] = \\sigma^2 T + \\mu^2 T^2/n$。对于 $\\mu=0$ 或较大的 $n$，这个值接近于理论二次变差 $\\sigma^2 T$。\n\n这种向量化方法在实现中避免了对 $M$ 和 $n$ 的显式循环，从而使程序简洁且计算效率高。每个测试用例的最终结果按照要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef estimate_quadratic_variation(T, n, M, mu, sigma, seed):\n    \"\"\"\n    Numerically estimates the quadratic variation for a generalized Brownian motion.\n\n    Args:\n        T (float): The time horizon.\n        n (int): The number of time steps.\n        M (int): The number of independent paths to simulate.\n        mu (float): The drift coefficient.\n        sigma (float): The volatility coefficient.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The sample mean of the quadratic variation estimator.\n    \"\"\"\n    # Handle the degenerate case T=0. The quadratic variation is 0.\n    if T == 0.0:\n        return 0.0\n    \n    # Handle the case n=0, which is ill-defined for T>0.\n    # The problem constraints ensure n>0, but this is a defensive check.\n    if n == 0:\n        return np.nan\n\n    # Initialize the random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Calculate the time step size.\n    delta_t = T / n\n\n    # Generate all standard normal random variables in a single M x n array.\n    # Z_mi corresponds to the i-th increment of the m-th path.\n    z_matrix = rng.normal(loc=0.0, scale=1.0, size=(M, n))\n\n    # Calculate the Brownian increments delta_W = sqrt(delta_t) * Z.\n    delta_w_matrix = np.sqrt(delta_t) * z_matrix\n\n    # Calculate the process increments delta_X = mu*delta_t + sigma*delta_W.\n    delta_x_matrix = mu * delta_t + sigma * delta_w_matrix\n\n    # Square the increments element-wise.\n    squared_delta_x_matrix = np.square(delta_x_matrix)\n\n    # Sum the squared increments for each path (row-wise) to get the QV for each path.\n    path_quadratic_variations = np.sum(squared_delta_x_matrix, axis=1)\n\n    # Compute the sample mean of the quadratic variations across all M paths.\n    mean_quadratic_variation = np.mean(path_quadratic_variations)\n\n    return mean_quadratic_variation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, n, M, mu, sigma, seed)\n        (1.0, 2048, 2000, 0.0, 1.0, 12345),\n        (1.0, 1, 100000, 0.0, 1.0, 23456),\n        (2.0, 4096, 1000, 1.0, 0.5, 34567),\n        (0.0, 50, 1000, 3.0, 7.0, 45678),\n        (0.5, 1024, 1500, 0.0, 2.0, 56789),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, n, M, mu, sigma, seed = case\n        result = estimate_quadratic_variation(T, n, M, mu, sigma, seed)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3074681"}, {"introduction": "在掌握了基本路径模拟后，我们常常需要模拟满足特定约束条件的路径，这在金融和科学建模中至关重要。本练习聚焦于布朗桥——一种被约束在未来某个时刻到达指定值的特殊布朗运动。你将首先从第一性原理出发，推导布朗桥的统计特性，然后通过蒙特卡洛模拟来验证你的分析结果，从而将理论推导与计算实践紧密结合 [@problem_id:3074672]。", "problem": "给定标准布朗运动（也称为Wiener过程）$\\{W_t\\}_{t \\ge 0}$的定义，它是一个高斯过程，满足$W_0 = 0$几乎必然、独立增量以及对于$0 \\le s  t$有$W_t - W_s \\sim \\mathcal{N}(0, t - s)$。现在考虑对一个布朗运动在未来时刻取固定终值的条件。给定$T > 0$和一个终值$a \\in \\mathbb{R}$。在中间时刻$t \\in [0, T]$，将条件化过程（布朗桥）定义为$B_t := W_t \\mid \\{W_T = a\\}$。从高斯过程和布朗运动的基本性质出发，推导$B_t$的条件分布（用其均值和方差表示），并推导一个仅使用布朗运动定义性质、不借助任何快捷公式的$B_t$模拟方法。\n\n你的程序必须完全基于这些原则实现以下内容：\n- 对于给定的$t$和$T$，使用基于布朗运动基本增量结构的蒙特卡洛模拟，生成数对$(W_t, W_T)$的独立样本。\n- 从这些样本中，构建对应于以$W_T = a$为条件的布朗桥$B_t$的样本。\n- 从生成的样本中经验性地估计$B_t$的均值和方差。\n- 将这些经验值与你推导出的解析均值和方差进行比较，并报告每个估计值是否在指定的容差范围内。\n\n必须严格遵循的实现细节：\n- 每个测试用例使用$N = 400000$个蒙特卡洛样本。\n- 为了可复现性，使用固定的伪随机数生成器种子，其值等于$314159265$。\n- 对均值使用容差$\\varepsilon_{\\mu} = 5 \\times 10^{-3}$，对方差使用容差$\\varepsilon_{\\sigma^2} = 5 \\times 10^{-3}$。\n- 为模拟$(W_t, W_T)$，你必须使用布朗运动的增量结构：模拟$W_t \\sim \\mathcal{N}(0, t)$和一个独立的增量$I_{t \\to T} \\sim \\mathcal{N}(0, T - t)$（理解为方差等于0意味着相应变量是确定性为0的），然后设置$W_T := W_t + I_{t \\to T}$。\n- 仅使用你推导出的关系，从模拟的$(W_t, W_T)$中构建$B_t$的样本，然后计算其经验均值和方差。\n\n测试套件：\n你的程序必须运行以下测试用例，每个用例指定为一个元组$(T, a, t)$：\n- $(1.0, 0.0, 0.5)$\n- $(2.0, 1.0, 1.0)$\n- $(3.0, -1.5, 0.0)$\n- $(1.25, 0.7, 1.25)$\n\n对于每个测试用例，计算两个布尔值：\n- $b_{\\mu}$：如果经验均值与解析均值之间的绝对误差至多为$\\varepsilon_{\\mu}$，则为true。\n- $b_{\\sigma^2}$：如果经验方差与解析方差之间的绝对误差至多为$\\varepsilon_{\\sigma^2}$，则为true。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。按顺序连接每个测试用例的两个布尔值，得到一个长度为8的列表，即\n$[b_{\\mu}^{(1)}, b_{\\sigma^2}^{(1)}, b_{\\mu}^{(2)}, b_{\\sigma^2}^{(2)}, b_{\\mu}^{(3)}, b_{\\sigma^2}^{(3)}, b_{\\mu}^{(4)}, b_{\\sigma^2}^{(4)}]$。\n不应打印额外的文本或换行。\n\n本问题中所有量均为无量纲量；不涉及物理单位。不出现角度，也不需要百分比。在所有计算中，确保$T > 0$和$t \\in [0, T]$。[@problem_id:481]", "solution": "问题要求推导标准布朗运动$\\{W_t\\}_{t \\ge 0}$在中间时刻$t \\in [0, T]$，给定其终值$W_T = a$时的条件分布。这个条件化过程$B_t := W_t \\mid \\{W_T = a\\}$被称为布朗桥。我们必须从基本原理出发推导其均值和方差，然后同样从基本原理出发推导一个模拟方法。最后，我们将实现这个方法来经验性地验证我们的解析结果。\n\n**1. 布朗桥条件分布的推导**\n\n一个标准布朗运动$\\{W_t\\}_{t \\ge 0}$是一个高斯过程，其特征如下：\n1. $W_0 = 0$ 几乎必然。\n2. 对于任意一组时间$0 \\le t_1  t_2  \\dots  t_n$，增量$W_{t_1}, W_{t_2}-W_{t_1}, \\dots, W_{t_n}-W_{t_{n-1}}$是独立的。\n3. 对于$0 \\le s  t$，增量$W_t - W_s$是一个正态分布的随机变量，$W_t - W_s \\sim \\mathcal{N}(0, t-s)$。\n\n从这些性质可以得出，对于任意$t>0$，$W_t \\sim \\mathcal{N}(0, t)$，且$\\mathbb{E}[W_t] = 0$。\n\n为了找到$B_t = W_t \\mid \\{W_T = a\\}$的分布，我们考虑对于一个固定的$t$（满足$0 \\le t \\le T$），随机变量$W_t$和$W_T$的联合分布。由于$\\{W_t\\}$是一个高斯过程，向量$(W_t, W_T)^T$服从一个二元正态分布。我们必须确定其均值向量和协方差矩阵。\n\n均值向量是 $\\boldsymbol{\\mu} = (\\mathbb{E}[W_t], \\mathbb{E}[W_T])^T = (0, 0)^T$。\n\n协方差矩阵$\\Sigma$由下式给出：\n$$\n\\Sigma = \\begin{pmatrix} \\text{Var}(W_t)  \\text{Cov}(W_t, W_T) \\\\ \\text{Cov}(W_t, W_T)  \\text{Var}(W_T) \\end{pmatrix}\n$$\n方差由定义直接给出：$\\text{Var}(W_t) = t$ 和 $\\text{Var}(W_T) = T$。\n为了求协方差$\\text{Cov}(W_t, W_T)$，我们使用独立增量的性质。我们将$W_T$写成$W_t + (W_T - W_t)$。对于$t  T$，随机变量$W_t$和$(W_T - W_t)$是独立的。\n$$\n\\text{Cov}(W_t, W_T) = \\mathbb{E}[W_t W_T] - \\mathbb{E}[W_t]\\mathbb{E}[W_T] = \\mathbb{E}[W_t W_T]\n$$\n$$\n\\mathbb{E}[W_t W_T] = \\mathbb{E}[W_t (W_t + W_T - W_t)] = \\mathbb{E}[W_t^2] + \\mathbb{E}[W_t(W_T - W_t)]\n$$\n由于独立性以及对于任意$s$有$\\mathbb{E}[W_s] = 0$这一事实，我们得到：\n$$\n\\mathbb{E}[W_t(W_T - W_t)] = \\mathbb{E}[W_t]\\mathbb{E}[W_T - W_t] = 0 \\cdot 0 = 0\n$$\n因此，协方差是：\n$$\n\\text{Cov}(W_t, W_T) = \\mathbb{E}[W_t^2] = \\text{Var}(W_t) + (\\mathbb{E}[W_t])^2 = t + 0^2 = t\n$$\n这个公式对于边界情况$t=T$也成立，此时$\\text{Cov}(W_T, W_T) = \\text{Var}(W_T) = T$。\n因此，$(W_t, W_T)^T$的协方差矩阵是：\n$$\n\\Sigma = \\begin{pmatrix} t  t \\\\ t  T \\end{pmatrix}\n$$\n对于一个均值为$(\\mu_1, \\mu_2)^T$，协方差矩阵为$\\begin{pmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{pmatrix}$的一般二元正态向量$(X_1, X_2)^T$，给定$X_2 = x_2$时$X_1$的条件分布是正态的，其条件均值和方差由以下公式给出：\n$$\n\\mathbb{E}[X_1 \\mid X_2=x_2] = \\mu_1 + \\Sigma_{12} \\Sigma_{22}^{-1} (x_2 - \\mu_2)\n$$\n$$\n\\text{Var}(X_1 \\mid X_2=x_2) = \\Sigma_{11} - \\Sigma_{12} \\Sigma_{22}^{-1} \\Sigma_{21}\n$$\n将这些公式应用于我们的情况（其中$X_1 = W_t, X_2 = W_T, x_2 = a, \\mu_1 = \\mu_2 = 0$），我们得到布朗桥$B_t$的解析均值和方差：\n解析均值为：\n$$\n\\mathbb{E}[B_t] = \\mathbb{E}[W_t \\mid W_T=a] = 0 + t \\cdot T^{-1} \\cdot (a - 0) = \\frac{at}{T}\n$$\n解析方差为：\n$$\n\\text{Var}(B_t) = \\text{Var}(W_t \\mid W_T=a) = t - t \\cdot T^{-1} \\cdot t = t - \\frac{t^2}{T} = \\frac{tT - t^2}{T} = \\frac{t(T-t)}{T}\n$$\n所以，条件分布是$B_t \\sim \\mathcal{N}\\left(\\frac{at}{T}, \\frac{t(T-t)}{T}\\right)$。\n\n**2. 模拟方法的推导**\n\n问题要求从基本原理出发推导一个模拟方法。我们可以通过构建一个与布朗桥相关且独立于条件变量$W_T$的过程来实现这一点。我们为$t \\in [0, T]$定义一个新过程$X_t$：\n$$\nX_t = W_t - \\frac{t}{T}W_T\n$$\n由于$X_t$是联合高斯随机变量的线性组合，它也是一个高斯过程。我们来计算它与$W_T$的协方差：\n$$\n\\text{Cov}(X_t, W_T) = \\text{Cov}\\left(W_t - \\frac{t}{T}W_T, W_T\\right) = \\text{Cov}(W_t, W_T) - \\frac{t}{T}\\text{Var}(W_T)\n$$\n使用我们之前推导的结果$\\text{Cov}(W_t, W_T) = t$和$\\text{Var}(W_T) = T$：\n$$\n\\text{Cov}(X_t, W_T) = t - \\frac{t}{T} \\cdot T = 0\n$$\n由于$X_t$和$W_T$是联合高斯的且它们的协方差为零，所以它们是独立的。\n我们可以用$X_t$和$W_T$来表示$W_t$：\n$$\nW_t = X_t + \\frac{t}{T}W_T\n$$\n当我们对事件$\\{W_T = a\\}$进行条件化时，随机变量$W_T$变成了常数$a$。因为$X_t$独立于$W_T$，其分布不受此条件化影响。因此，条件化过程$B_t = W_t \\mid \\{W_T = a\\}$与随机变量$X_t + \\frac{at}{T}$具有相同的分布。\n过程$X_t$是一个标准布朗桥（从0到0），其分布为正态分布，均值为$\\mathbb{E}[X_t] = \\mathbb{E}[W_t] - \\frac{t}{T}\\mathbb{E}[W_T] = 0$，方差为$\\text{Var}(X_t) = \\frac{t(T-t)}{T}$（如前一节所计算）。\n\n这种分解提供了模拟方法：\n1.  生成无条件数对$(W_t, W_T)$的一个样本。问题要求使用独立增量结构来完成此操作：\n    a. 从$\\mathcal{N}(0, t)$生成一个样本$w_t$。\n    b. 从$\\mathcal{N}(0, T-t)$生成一个独立样本$i_{t \\to T}$。\n    c. 构成样本$w_T = w_t + i_{t \\to T}$。\n2.  从样本对$(w_t, w_T)$，构建标准布朗桥过程$X_t$的一个样本：\n    $$\n    x_t = w_t - \\frac{t}{T}w_T\n    $$\n    这个$x_t$是从$\\mathcal{N}(0, \\frac{t(T-t)}{T})$中的一个随机抽样。\n3.  通过加上确定性漂移，构建所需的条件化布朗桥$B_t$的样本：\n    $$\n    b_t = x_t + \\frac{at}{T} = \\left(w_t - \\frac{t}{T}w_T\\right) + \\frac{at}{T}\n    $$\n此方法严格遵循了先生成$(W_t, W_T)$的样本，然后完全基于布朗运动的基本性质，使用推导出的关系来构建$B_t$的样本。我们现在将实现该算法，为每个测试用例生成$N=400000$个样本，并将经验均值和方差与上面推导的解析结果进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# SciPy is specified as available but is not required for this problem.\n# from scipy import stats\n\ndef solve():\n    \"\"\"\n    Derives and simulates a Brownian bridge to verify its mean and variance.\n    \"\"\"\n    # Define the simulation parameters from the problem statement.\n    N = 400000\n    SEED = 314159265\n    TOL_MEAN = 5e-3\n    TOL_VAR = 5e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, a, t)\n        (1.0, 0.0, 0.5),\n        (2.0, 1.0, 1.0),\n        (3.0, -1.5, 0.0),\n        (1.25, 0.7, 1.25),\n    ]\n\n    # Set the seed for the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(SEED)\n\n    results = []\n    for T, a, t in test_cases:\n        # Step 1: Calculate the analytical mean and variance of the Brownian bridge B_t.\n        # Handle the case T=0 to avoid division by zero, although problem constraints ensure T > 0.\n        if T == 0:\n            # If T=0, then t must be 0. W_0 = 0.\n            # If a is not 0, the conditioning is on an impossible event.\n            # However, problem states T > 0.\n            mean_analytical = 0.0 if a == 0 else np.nan\n            var_analytical = 0.0\n        else:\n            mean_analytical = a * t / T\n            var_analytical = t * (T - t) / T\n\n        # Step 2: Perform Monte Carlo simulation based on the derived procedure.\n        \n        # Variances for the normal distributions. Variances can be zero.\n        # std_dev = sqrt(variance)\n        std_dev_W_t = np.sqrt(t)\n        std_dev_inc = np.sqrt(T - t)\n\n        # Generate N samples of W_t from N(0, t).\n        # If t=0, std_dev_W_t=0, and this correctly generates an array of zeros.\n        W_t_samples = rng.normal(loc=0.0, scale=std_dev_W_t, size=N)\n\n        # Generate N samples of the independent increment I_{t->T} from N(0, T-t).\n        # If t=T, std_dev_inc=0, and this correctly generates an array of zeros.\n        inc_samples = rng.normal(loc=0.0, scale=std_dev_inc, size=N)\n\n        # Construct N samples of W_T = W_t + I_{t->T}.\n        W_T_samples = W_t_samples + inc_samples\n\n        # Construct N samples of the Brownian bridge B_t using the derived relation:\n        # b_t = (w_t - (t/T)*w_T) + (a*t)/T\n        # This is numerically stable since T > 0 for all test cases.\n        bridge_samples = (W_t_samples - (t / T) * W_T_samples) + (a * t / T)\n\n        # Step 3: Calculate empirical mean and variance from the samples.\n        # We use population variance (ddof=0) for comparison against theoretical value.\n        mean_empirical = np.mean(bridge_samples)\n        var_empirical = np.var(bridge_samples, ddof=0)\n\n        # Step 4: Compare empirical results to analytical values within tolerance.\n        b_mu = abs(mean_empirical - mean_analytical) = TOL_MEAN\n        b_sigma2 = abs(var_empirical - var_analytical) = TOL_VAR\n\n        results.extend([b_mu, b_sigma2])\n\n    # Final print statement in the exact required format.\n    # The default str() for bool is 'True'/'False' with capitalization.\n    # The problem format example like [b_mu, b_sigma2] suggests this is OK.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3074672"}, {"introduction": "高效的蒙特卡洛模拟是随机过程应用的基石。本练习将带你超越基础的路径生成，探索两种强大的方差缩减技术：对偶变量法（Antithetic Variates）和控制变量法（Control Variates）。通过实现并比较这些高级方法与标准蒙特卡洛模拟的效率，你将学会如何用更少的计算资源获得更精确的估计，这是计算科学中的一项核心技能 [@problem_id:3074678]。", "problem": "您需要设计并实现一个模拟，以量化在使用三种蒙特卡洛估计量估计标准布朗运动的路径依赖泛函的期望时，所实现的方差缩减。请从标准布朗运动的基本原理出发，其中标准布朗运动 $\\{B_t\\}_{t \\ge 0}$ 是一个连续时间随机过程，满足 $B_0 = 0$，具有独立增量，并且对于 $0 \\le s  t$，有 $B_t - B_s \\sim \\mathcal{N}(0, t - s)$。使用带有均匀网格的离散时间近似，通过独立高斯增量构建样本路径。\n\n对于给定的参数 $\\alpha$ 和时间范围 $T$，将路径泛函定义为\n$$\nI = \\int_0^T \\exp\\!\\big(\\alpha\\, B_t - \\tfrac{1}{2}\\alpha^2 t\\big)\\, dt.\n$$\n在一个包含 $M$ 个步长的均匀网格上，使用左黎曼和来近似该积分，其中步长 $\\Delta t = T/M$，并使用值 $\\{B_{k\\Delta t}\\}_{k=0}^{M-1}$。对每条路径，计算其样本路径近似值\n$$\n\\widehat{I} = \\sum_{k=0}^{M-1} \\exp\\!\\big(\\alpha\\, B_{k\\Delta t} - \\tfrac{1}{2}\\alpha^2 (k\\Delta t)\\big)\\, \\Delta t.\n$$\n\n您的目标是使用三种估计量来估计 $\\mu = \\mathbb{E}[\\widehat{I}]$，并量化每种方法下蒙特卡洛估计量（即样本均值）的方差。该方差应表示为该方法所使用的逐路径贡献的样本方差除以对均值有贡献的有效独立项数。\n\n请实现以下估计量：\n- 普通蒙特卡洛（MC）：模拟 $N$ 条独立路径，并计算 $\\widehat{I}$ 的样本均值。将此样本均值的估计方差报告为 $\\widehat{\\mathrm{Var}}_{\\text{plain}} = s^2(\\widehat{I}_1,\\dots,\\widehat{I}_N)/N$，其中 $s^2$ 表示从 $N$ 个逐路径值计算出的无偏样本方差。\n- 对偶变量：对于 $N/2$ 组独立模拟的高斯增量 $\\{\\Delta B_k\\}_{k=1}^M$，使用 $\\Delta B_k$ 和 $-\\Delta B_k$ 形成一对路径，以计算 $\\widehat{I}^{(+)}$ 和 $\\widehat{I}^{(-)}$。使用成对平均值 $Y_i = \\tfrac{1}{2}(\\widehat{I}^{(+)}_i + \\widehat{I}^{(-)}_i)$ 作为估计量的贡献项，并将样本均值的方差计算为 $\\widehat{\\mathrm{Var}}_{\\text{anti}} = s^2(Y_1,\\dots,Y_{N/2})/(N/2)$。\n- 控制变量：对于与普通蒙特卡洛方法中相同的 $N$ 条独立路径，使用终值 $C = B_T$（其已知期望为 $\\mathbb{E}[C] = 0$）构建一个线性控制变量。构造调整后的贡献项 $Z_i = \\widehat{I}_i - \\beta C_i$，其中系数 $\\beta$ 是基于相同的模拟数据选择的，以在所有实系数中最小化 $Z_i$ 的样本方差。将样本均值的估计方差报告为 $\\widehat{\\mathrm{Var}}_{\\text{ctrl}} = s^2(Z_1,\\dots,Z_N)/N$。\n\n遵循标准布朗运动模拟的原理：将增量生成为方差等于时间步长的独立高斯随机变量，并通过累积求和获得离散路径值。按照规定，使用左端点构建黎曼和。\n\n测试套件：\n为了可复现性，使用一个固定的随机数生成器种子 $12345$，并使用以下三个测试用例：\n1. 用例 A（正常路径）：$N = 20000$，$T = 1.0$，$M = 200$，$\\alpha = 1.0$。\n2. 用例 B（小时间边界）：$N = 20000$，$T = 0.05$，$M = 5$，$\\alpha = 1.0$。\n3. 用例 C（粗糙网格边缘）：$N = 20000$，$T = 1.0$，$M = 1$，$\\alpha = 1.0$。\n\n对于每个用例，按此顺序计算并返回浮点数三元组 $\\big(\\widehat{\\mathrm{Var}}_{\\text{plain}}, \\widehat{\\mathrm{Var}}_{\\text{anti}}, \\widehat{\\mathrm{Var}}_{\\text{ctrl}}\\big)$。按用例 A、用例 B、用例 C 的顺序，将所有用例的结果串联成一个包含九个浮点数的单个扁平列表。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含九个十进制数，分别对应三个用例的三个方差，并四舍五入到六位小数。例如，一个有效的输出行应如下所示：\n$[0.001234,0.000987,0.000543,0.000111,0.000098,0.000076,0.0,0.0,0.0]$。\n不应打印任何其他文本。", "solution": "首先评估用户问题的有效性。\n\n### 步骤 1：提取已知条件\n- **过程**：标准布朗运动 $\\{B_t\\}_{t \\ge 0}$，满足 $B_0 = 0$，具有独立增量，且对于 $0 \\le s  t$，$B_t - B_s \\sim \\mathcal{N}(0, t - s)$。\n- **路径泛函**：$I = \\int_0^T \\exp\\big(\\alpha\\, B_t - \\tfrac{1}{2}\\alpha^2 t\\big)\\, dt$。\n- **离散化**：均匀时间网格，含 $M$ 个步长，$\\Delta t = T/M$。使用路径值 $\\{B_{k\\Delta t}\\}_{k=0}^{M-1}$。\n- **近似泛函**：左黎曼和 $\\widehat{I} = \\sum_{k=0}^{M-1} \\exp\\big(\\alpha\\, B_{k\\Delta t} - \\tfrac{1}{2}\\alpha^2 (k\\Delta t)\\big)\\, \\Delta t$。\n- **目标**：估计 $\\mu = \\mathbb{E}[\\widehat{I}]$ 并计算三种估计量的样本均值方差。\n- **估计量**：\n    1.  **普通蒙特卡洛 (MC)**：$N$ 条独立路径。估计量方差：$\\widehat{\\mathrm{Var}}_{\\text{plain}} = s^2(\\widehat{I}_1,\\dots,\\widehat{I}_N)/N$。\n    2.  **对偶变量**：$N/2$ 组独立增量，形成路径对 $(B, -B)$。贡献项 $Y_i = \\tfrac{1}{2}(\\widehat{I}^{(+)}_i + \\widehat{I}^{(-)}_i)$。估计量方差：$\\widehat{\\mathrm{Var}}_{\\text{anti}} = s^2(Y_1,\\dots,Y_{N/2})/(N/2)$。\n    3.  **控制变量**：来自普通 MC 的 $N$ 条路径。控制变量 $C = B_T$。调整后的贡献项 $Z_i = \\widehat{I}_i - \\beta C_i$，其中 $\\beta$ 通过估计以最小化样本方差。估计量方差：$\\widehat{\\mathrm{Var}}_{\\text{ctrl}} = s^2(Z_1,\\dots,Z_N)/N$。\n- **模拟参数**：\n    - 随机种子：$12345$。\n    - 用例 A：$N = 20000$，$T = 1.0$，$M = 200$，$\\alpha = 1.0$。\n    - 用例 B：$N = 20000$，$T = 0.05$，$M = 5$，$\\alpha = 1.0$。\n    - 用例 C：$N = 20000$，$T = 1.0$，$M = 1$，$\\alpha = 1.0$。\n- **输出**：一个包含九个浮点数的单个扁平列表，按顺序为每个用例的 $(\\widehat{\\mathrm{Var}}_{\\text{plain}}, \\widehat{\\mathrm{Var}}_{\\text{anti}}, \\widehat{\\mathrm{Var}}_{\\text{ctrl}})$，四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **科学依据**：该问题基于随机过程（布朗运动）和统计模拟（蒙特卡洛方法）的成熟数学理论。所有定义和概念都是量化金融和计算数学中的标准内容。量 $X_t = \\exp(\\alpha B_t - \\frac{1}{2}\\alpha^2 t)$ 是一个几何布朗运动，是金融建模中的一个基本对象。\n- **良态的**：问题提供了一个清晰、明确的计算任务。所有参数都已指定，输出格式也很精确。对于给定的种子，存在唯一的数值解。\n- **客观的**：问题陈述是形式化和客观的，没有主观或推测性元素。\n- **无缺陷**：问题没有违反任何无效性标准。它在科学上是合理的、可形式化的、完整的、可行的和良态的。特殊情况 $M=1$ 是一个有效的边缘情况，而不是一个缺陷。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个合理的解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是估计一个随机过程泛函的期望 $\\mu = \\mathbb{E}[\\widehat{I}]$，并量化不同蒙特卡洛估计量的效率。\n\n**理论基础**\n过程 $X_t = \\exp(\\alpha B_t - \\frac{1}{2}\\alpha^2 t)$ 是一个关于由标准布朗运动 $B_t$ 生成的滤的鞅。这是 Girsanov 定理的直接结果，也可以通过 Itô 引理来验证，该引理显示 $dX_t = \\alpha X_t dB_t$，这是一个没有漂移项的随机微分方程。作为一个鞅，其期望随时间保持不变：对于所有 $t \\ge 0$，$\\mathbb{E}[X_t] = X_0 = \\exp(0-0) = 1$。\n因此，离散化泛函 $\\widehat{I}$ 的期望可以解析计算：\n$$\n\\mu = \\mathbb{E}[\\widehat{I}] = \\mathbb{E}\\left[\\sum_{k=0}^{M-1} X_{k\\Delta t} \\Delta t\\right] = \\sum_{k=0}^{M-1} \\mathbb{E}[X_{k\\Delta t}] \\Delta t = \\sum_{k=0}^{M-1} (1) \\Delta t = M \\Delta t = T.\n$$\n期望的精确值是时间范围 $T$。这为模拟结果提供了一个有价值的合理性检查，因为所有估计量的样本均值都应收敛到 $T$。\n\n**布朗路径模拟**\n在离散时间网格 $t_k = k \\Delta t$（其中 $k = 0, 1, \\dots, M$ 且 $\\Delta t = T/M$）上模拟一条标准布朗运动的路径。该路径由其基本属性构建：\n1.  $B_{t_0} = B_0 = 0$。\n2.  增量 $\\Delta B_k = B_{t_k} - B_{t_{k-1}}$（其中 $k=1, \\dots, M$）是独立同分布（i.i.d.）的正态随机变量，$\\Delta B_k \\sim \\mathcal{N}(0, \\Delta t)$。\n这些增量通过缩放标准正态变量 $Z_k \\sim \\mathcal{N}(0, 1)$ 生成，即 $\\Delta B_k = \\sqrt{\\Delta t} Z_k$。然后通过累积和构建路径：$B_{t_k} = \\sum_{j=1}^k \\Delta B_j$。\n\n**估计量实现**\n\n对于每个测试用例，根据问题规范实现三种估计量。一个为每个用例重新初始化并使用指定种子的随机数生成器提供随机性来源。\n\n1.  **普通蒙特卡洛 (MC)**：这是基线方法。我们生成 $N$ 条独立的布朗运动路径。对于每条路径 $i \\in \\{1, \\dots, N\\}$，我们计算泛函值 $\\widehat{I}_i$。$\\mu$ 的估计是样本均值 $\\bar{I} = \\frac{1}{N} \\sum_{i=1}^N \\widehat{I}_i$。此样本均值的方差（衡量估计量精度）由 $\\widehat{\\mathrm{Var}}_{\\text{plain}} = s^2(\\{\\widehat{I}_i\\}) / N$ 估计，其中 $s^2$ 是收集到的 $\\widehat{I}_i$ 值的无偏样本方差。\n\n2.  **对偶变量**：该技术利用了布朗运动增量的对称性。由于驱动噪声 $\\{Z_k\\}$ 的分布关于 0 对称，由增量 $-\\Delta B_k$ 生成的路径 $-B_t$ 与路径 $B_t$ 同样可能。对于像 $\\widehat{I}$ 这样的凸泛函（指数函数是凸的），$\\widehat{I}(B_t)$ 和 $\\widehat{I}(-B_t)$ 的平均值预计比单独的 $\\widehat{I}(B_t)$ 具有更低的方差。我们生成 $N/2$ 条独立路径，记为 $B^{(+)}_i$，以及它们的对偶对应路径 $B^{(-)}_i = -B^{(+)}_i$。然后我们形成 $N/2$ 个新的观测值 $Y_i = \\frac{1}{2}(\\widehat{I}(B^{(+)}_i) + \\widehat{I}(B^{(-)}_i))$。所得样本均值的方差由 $\\widehat{\\mathrm{Var}}_{\\text{anti}} = s^2(\\{Y_i\\}) / (N/2)$ 估计。\n\n3.  **控制变量**：该方法通过减去一个具有已知均值的相关变量来减少方差。我们使用布朗路径的终值 $C = B_T$ 作为控制变量。我们知道 $\\mathbb{E}[C] = \\mathbb{E}[B_T] = 0$。我们形成一组新的观测值 $Z_i = \\widehat{I}_i - \\beta(C_i - \\mathbb{E}[C_i]) = \\widehat{I}_i - \\beta C_i$。最小化 $\\mathrm{Var}(Z_i)$ 的最优系数 $\\beta$ 是 $\\beta^* = \\mathrm{Cov}(\\widehat{I}, C) / \\mathrm{Var}(C)$。我们从 $N$ 个 $\\widehat{I}_i$ 和 $C_i$ 的模拟样本中估计 $\\beta^*$：\n    $$\n    \\hat{\\beta} = \\frac{\\widehat{\\mathrm{Cov}}(\\{\\widehat{I}_i\\}, \\{C_i\\})}{\\widehat{\\mathrm{Var}}(\\{C_i\\})}.\n    $$\n    使用这个估计的 $\\hat{\\beta}$，我们计算调整后的值 $Z_i = \\widehat{I}_i - \\hat{\\beta} C_i$。然后，控制估计量均值的方差由 $\\widehat{\\mathrm{Var}}_{\\text{ctrl}} = s^2(\\{Z_i\\}) / N$ 给出。如果 $\\widehat{I}$ 和 $B_T$ 显著相关，此方法是有效的。由于积分项在后期时间点的值依赖于方差较大的 $B_t$ 值，而这些值与 $B_T$ 高度相关，因此预期存在强相关性。\n\n对于 M=1 的边缘情况 C，黎曼和简化为 k=0 的单项。由于 $B_0=0$ 且 $t_0=0$，$\\widehat{I} = \\exp(0)\\Delta t = \\Delta t = T/M = 1.0/1.0 = 1.0$。由于 $\\widehat{I}$ 是一个常数，所有估计量的方差均为 0。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates Brownian motion paths to quantify variance reduction in estimating the\n    expectation of a path-dependent functional using three Monte Carlo techniques:\n    Plain Monte Carlo, Antithetic Variates, and Control Variates.\n    \"\"\"\n\n    def calculate_variances_for_case(N, T, M, alpha, rng):\n        \"\"\"\n        Calculates the variances of the sample mean for the three estimators\n        for a single set of parameters.\n\n        Args:\n            N (int): Number of paths for Plain MC and Control Variates.\n            T (float): Time horizon.\n            M (int): Number of time steps in the discretization.\n            alpha (float): Parameter in the path functional.\n            rng (np.random.Generator): The random number generator instance.\n\n        Returns:\n            tuple: A triple of floats (var_plain, var_anti, var_ctrl).\n        \"\"\"\n        delta_t = T / M\n\n        # Handle the trivial edge case where the functional is constant.\n        if M == 1:\n            # For M=1, the sum has one term at k=0.\n            # I_hat = exp(alpha*B_0 - 0.5*alpha^2*t_0) * delta_t\n            # Since B_0=0 and t_0=0, I_hat = exp(0) * T = T.\n            # The value is constant, so variance is 0 for all methods.\n            return 0.0, 0.0, 0.0\n\n        # --- Plain MC and Control Variate Calculations ---\n        # Generate N paths, each with M steps.\n        # Z_mc are the standard normal innovations.\n        Z_mc = rng.standard_normal(size=(N, M))\n        delta_B_mc = Z_mc * np.sqrt(delta_t)\n        \n        # B_mc are the Brownian paths. Shape: (N, M+1) since B_0=0 is prepended.\n        B_mc = np.cumsum(delta_B_mc, axis=1)\n        B_mc = np.hstack((np.zeros((N, 1)), B_mc))\n        \n        # Time grid for the Riemann sum (k=0 to M-1).\n        t_grid = np.arange(M) * delta_t\n        \n        # Calculate the approximate functional I_hat for each of the N paths.\n        # B_for_I uses path values from t_0 to t_{M-1}.\n        B_for_I = B_mc[:, :M]\n        exponent = alpha * B_for_I - 0.5 * alpha**2 * t_grid\n        integrand = np.exp(exponent)\n        I_hats_mc = np.sum(integrand, axis=1) * delta_t\n        \n        # 1. Plain MC variance of the sample mean\n        var_plain_samples = np.var(I_hats_mc, ddof=1)\n        var_plain_mean = var_plain_samples / N\n        \n        # 3. Control Variate variance of the sample mean\n        C = B_mc[:, -1] # Control variate C = B_T\n        cov_matrix = np.cov(I_hats_mc, C, ddof=1)\n        \n        # Estimate the optimal coefficient beta.\n        # Check for Var(C)=0 to avoid division by zero, though unlikely here.\n        if cov_matrix[1, 1] == 0:\n            beta_hat = 0.0\n        else:\n            beta_hat = cov_matrix[0, 1] / cov_matrix[1, 1]\n\n        Z = I_hats_mc - beta_hat * C\n        var_Z_samples = np.var(Z, ddof=1)\n        var_ctrl_mean = var_Z_samples / N\n\n        # --- Antithetic Variate Calculation ---\n        N_half = N // 2\n        \n        # Generate N/2 new sets of increments.\n        Z_anti = rng.standard_normal(size=(N_half, M))\n        \n        # Construct positive and negative paths from the same increments.\n        delta_B_pos = Z_anti * np.sqrt(delta_t)\n        B_pos = np.cumsum(delta_B_pos, axis=1)\n        B_pos = np.hstack((np.zeros((N_half, 1)), B_pos))\n        B_neg = -B_pos\n        \n        # Calculate I_hat for positive paths.\n        B_for_I_pos = B_pos[:, :M]\n        exponent_pos = alpha * B_for_I_pos - 0.5 * alpha**2 * t_grid\n        integrand_pos = np.exp(exponent_pos)\n        I_hats_pos = np.sum(integrand_pos, axis=1) * delta_t\n        \n        # Calculate I_hat for negative paths.\n        B_for_I_neg = B_neg[:, :M]\n        exponent_neg = alpha * B_for_I_neg - 0.5 * alpha**2 * t_grid\n        integrand_neg = np.exp(exponent_neg)\n        I_hats_neg = np.sum(integrand_neg, axis=1) * delta_t\n        \n        # 2. Antithetic Variate variance of the sample mean.\n        # Y are the pairwise averages.\n        Y = 0.5 * (I_hats_pos + I_hats_neg)\n        var_Y_samples = np.var(Y, ddof=1)\n        var_anti_mean = var_Y_samples / N_half\n\n        return var_plain_mean, var_anti_mean, var_ctrl_mean\n\n    seed = 12345\n    \n    test_cases = [\n        # (N, T, M, alpha)\n        (20000, 1.0, 200, 1.0),  # Case A\n        (20000, 0.05, 5, 1.0),   # Case B\n        (20000, 1.0, 1, 1.0)     # Case C\n    ]\n\n    results = []\n    for case_params in test_cases:\n        N, T, M, alpha = case_params\n        # A new RNG is created for each test case, seeded with the same value\n        # to ensure each case is independently reproducible.\n        rng = np.random.default_rng(seed)\n        case_variances = calculate_variances_for_case(N, T, M, alpha, rng)\n        results.extend(case_variances)\n\n    # Format the final output list as a comma-separated string of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3074678"}]}