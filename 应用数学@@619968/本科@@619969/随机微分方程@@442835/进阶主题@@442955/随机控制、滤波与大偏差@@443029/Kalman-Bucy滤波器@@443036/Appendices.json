{"hands_on_practices": [{"introduction": "理解一个复杂系统的最佳方式，是从其最简单的形式入手。这项实践将引导你从第一性原理出发，为一个标量系统推导里卡蒂微分方程（Riccati differential equation）。通过这个过程，你将深刻理解滤波器如何最小化误差方差，并接触到稳态误差（steady-state error）的关键概念 [@problem_id:3080944]。", "problem": "考虑一个由独立标准布朗运动驱动的标量、线性、时不变连续时间模型，\n$$\n\\mathrm{d}x_t = a\\,x_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t,\\qquad\n\\mathrm{d}y_t = c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t,\n$$\n其中 $a\\in\\mathbb{R}$、$c\\in\\mathbb{R}$、$q\\ge 0$、$r>0$ 是给定常数，$W_t$ 和 $V_t$ 是独立的标准维纳过程。令 $\\hat{x}_t$ 表示由卡尔曼-布西滤波器（KBF）产生的估计值，并定义估计误差为 $e_t = x_t - \\hat{x}_t$，其误差方差为 $P_t = \\mathbb{E}[e_t^2]$。假设初始方差 $P_0 \\ge 0$。\n\n从随机微分方程（SDE）模型和 $e_t$ 的定义出发，根据第一性原理（不引用现成的滤波器公式）推导控制卡尔曼-布西滤波器中 $P_t$ 的常微分方程（ODE）。然后，在初始条件为 $P_0$ 的情况下，显式地求解此标量 ODE 得到 $P_t$。接下来，确定 $P_t$ 收敛到有限稳态值 $P_{\\infty} = \\lim_{t\\to\\infty} P_t$ 时，$a$、$c$、$q$、$r$ 和 $P_0$ 需要满足的精确条件，并给出 $P_{\\infty}$ 的闭式表达式。\n\n最后，对于数值 $a=0.4$，$c=1.5$，$q=0.2$，$r=0.5$ 和 $P_0=1.0$，数值计算稳态值 $P_{\\infty}$。将您的答案四舍五入到四位有效数字。最终答案无需单位。", "solution": "该问题要求推导标量卡尔曼-布西滤波器的方差动态过程，求解所得的微分方程，确定稳态收敛的条件，并对稳态方差进行数值评估。\n\n该过程从给定的线性时不变系统开始：\n状态方程：\n$$\n\\mathrm{d}x_t = a\\,x_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t\n$$\n测量方程：\n$$\n\\mathrm{d}y_t = c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t\n$$\n其中 $a, c, q, r$ 是常数，满足 $q \\ge 0$ 和 $r>0$，$W_t, V_t$ 是独立的标准维纳过程。\n\n卡尔曼-布西滤波器提供状态 $x_t$ 的最优估计 $\\hat{x}_t$。该系统的滤波器形式如下：\n$$\n\\mathrm{d}\\hat{x}_t = a\\,\\hat{x}_t\\,\\mathrm{d}t + K_t(\\mathrm{d}y_t - c\\,\\hat{x}_t\\,\\mathrm{d}t)\n$$\n其中 $K_t$ 是我们将要确定的卡尔曼增益。项 $\\mathrm{d}y_t - c\\,\\hat{x}_t\\,\\mathrm{d}t$ 是新息过程。\n\n**1. 误差方差 $P_t$ 的常微分方程（ODE）推导**\n\n估计误差定义为 $e_t = x_t - \\hat{x}_t$。我们通过取其微分来推导其 SDE：$\\mathrm{d}e_t = \\mathrm{d}x_t - \\mathrm{d}\\hat{x}_t$。\n代入 $\\mathrm{d}x_t$ 和 $\\mathrm{d}\\hat{x}_t$ 的表达式：\n$$\n\\mathrm{d}e_t = (a\\,x_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t) - \\left( a\\,\\hat{x}_t\\,\\mathrm{d}t + K_t(\\mathrm{d}y_t - c\\,\\hat{x}_t\\,\\mathrm{d}t) \\right)\n$$\n现在，将 $\\mathrm{d}y_t = c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t$ 代入方程中：\n$$\n\\mathrm{d}e_t = a\\,(x_t - \\hat{x}_t)\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t(c\\,x_t\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t - c\\,\\hat{x}_t\\,\\mathrm{d}t)\n$$\n按 $e_t = x_t - \\hat{x}_t$ 对各项进行分组：\n$$\n\\mathrm{d}e_t = a\\,e_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t(c\\,(x_t - \\hat{x}_t)\\,\\mathrm{d}t + \\sqrt{r}\\,\\mathrm{d}V_t)\n$$\n$$\n\\mathrm{d}e_t = (a - K_t c)\\,e_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t\\sqrt{r}\\,\\mathrm{d}V_t\n$$\n误差方差为 $P_t = \\mathbb{E}[e_t^2]$。为了找到其动态方程，我们对函数 $f(e_t) = e_t^2$ 应用伊藤引理。\n$$\n\\mathrm{d}(e_t^2) = 2\\,e_t\\,\\mathrm{d}e_t + (\\mathrm{d}e_t)^2\n$$\n二次变分项 $(\\mathrm{d}e_t)^2$ 是从 $\\mathrm{d}e_t$ 的随机部分计算得出的：\n$$\n(\\mathrm{d}e_t)^2 = (\\sqrt{q}\\,\\mathrm{d}W_t - K_t\\sqrt{r}\\,\\mathrm{d}V_t)^2 = q(\\mathrm{d}W_t)^2 + (K_t\\sqrt{r})^2(\\mathrm{d}V_t)^2 - 2\\sqrt{q}K_t\\sqrt{r}\\,\\mathrm{d}W_t\\mathrm{d}V_t\n$$\n由于 $W_t$ 和 $V_t$ 是独立的，我们有 $(\\mathrm{d}W_t)^2 = \\mathrm{d}t$，$(\\mathrm{d}V_t)^2 = \\mathrm{d}t$，以及 $\\mathrm{d}W_t\\mathrm{d}V_t = 0$。\n$$\n(\\mathrm{d}e_t)^2 = (q + K_t^2 r)\\,\\mathrm{d}t\n$$\n将 $\\mathrm{d}e_t$ 和 $(\\mathrm{d}e_t)^2$ 代入 $\\mathrm{d}(e_t^2)$ 的表达式中：\n$$\n\\mathrm{d}(e_t^2) = 2\\,e_t \\left( (a - K_t c)\\,e_t\\,\\mathrm{d}t + \\sqrt{q}\\,\\mathrm{d}W_t - K_t\\sqrt{r}\\,\\mathrm{d}V_t \\right) + (q + K_t^2 r)\\,\\mathrm{d}t\n$$\n$$\n\\mathrm{d}(e_t^2) = 2(a - K_t c)\\,e_t^2\\,\\mathrm{d}t + (q + K_t^2 r)\\,\\mathrm{d}t + 2\\sqrt{q}\\,e_t\\,\\mathrm{d}W_t - 2K_t\\sqrt{r}\\,e_t\\,\\mathrm{d}V_t\n$$\n为了得到 $P_t = \\mathbb{E}[e_t^2]$ 的 ODE，我们对两边取期望。随机积分项（鞅）的期望为零。\n$$\n\\mathrm{d}P_t = \\mathrm{d}\\mathbb{E}[e_t^2] = \\mathbb{E}[\\mathrm{d}(e_t^2)] = \\mathbb{E}[2(a - K_t c)\\,e_t^2\\,\\mathrm{d}t + (q + K_t^2 r)\\,\\mathrm{d}t]\n$$\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2(a - K_t c)\\,\\mathbb{E}[e_t^2] + q + K_t^2 r = 2(a - K_t c)\\,P_t + q + K_t^2 r\n$$\n选择卡尔曼-布西滤波器增益 $K_t$ 以最小化误差方差 $P_t$。这是通过在每个瞬间最小化变化率 $\\frac{\\mathrm{d}P_t}{\\mathrm{d}t}$ 来实现的。我们将右侧视为 $K_t$ 的函数，并通过将其导数设为零来找到最小值：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}K_t} \\left( 2(a - K_t c)\\,P_t + q + K_t^2 r \\right) = -2c\\,P_t + 2r\\,K_t = 0\n$$\n这给出了最优卡尔曼增益：\n$$\nK_t = \\frac{c\\,P_t}{r}\n$$\n将此最优增益代回 $P_t$ 的 ODE 中：\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2\\left(a - \\frac{c\\,P_t}{r} c\\right)P_t + q + \\left(\\frac{c\\,P_t}{r}\\right)^2 r\n$$\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2a\\,P_t - \\frac{2c^2}{r}P_t^2 + q + \\frac{c^2 P_t^2}{r}\n$$\n这简化为连续时间标量里卡蒂微分方程：\n$$\n\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = -\\frac{c^2}{r}P_t^2 + 2a\\,P_t + q\n$$\n\n**2. 里卡蒂 ODE 的求解**\n\n这是一个一阶非线性 ODE。对于 $c \\ne 0$，我们可以通过找到其稳态解并使用变量分离法来求解。令 $P_{\\infty}$ 为一个稳态解，此时 $\\frac{\\mathrm{d}P}{\\mathrm{d}t}=0$：\n$$\n-\\frac{c^2}{r}P_{\\infty}^2 + 2a\\,P_{\\infty} + q = 0 \\implies \\frac{c^2}{r}P_{\\infty}^2 - 2a\\,P_{\\infty} - q = 0\n$$\n这个二次方程的根是：\n$$\nP_{\\infty} = \\frac{2a \\pm \\sqrt{4a^2 - 4(\\frac{c^2}{r})(-q)}}{2(\\frac{c^2}{r})} = \\frac{r}{c^2}\\left(a \\pm \\sqrt{a^2 + \\frac{c^2 q}{r}}\\right)\n$$\n令 $\\gamma = \\sqrt{a^2 + \\frac{c^2 q}{r}}$。两个根是 $\\lambda_1 = \\frac{r}{c^2}(a+\\gamma)$ 和 $\\lambda_2 = \\frac{r}{c^2}(a-\\gamma)$。由于 $\\gamma \\ge |a|$，因此 $\\lambda_1 \\ge 0$ 且 $\\lambda_2 \\le 0$。方差 $P_t$ 必须是非负的。$\\lambda_1$ 是 $P_t \\ge 0$ 的稳定平衡点。\n该 ODE 可以写成 $\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = -\\frac{c^2}{r}(P_t - \\lambda_1)(P_t - \\lambda_2)$。使用变量分离法：\n$$\n\\int_{P_0}^{P_t} \\frac{\\mathrm{d}P}{(P - \\lambda_1)(P - \\lambda_2)} = -\\frac{c^2}{r} \\int_0^t \\mathrm{d}s = -\\frac{c^2}{r}t\n$$\n使用部分分式，$\\frac{1}{(P - \\lambda_1)(P - \\lambda_2)} = \\frac{1}{\\lambda_1 - \\lambda_2}\\left(\\frac{1}{P - \\lambda_1} - \\frac{1}{P - \\lambda_2}\\right)$。积分变为：\n$$\n\\frac{1}{\\lambda_1 - \\lambda_2} \\left[ \\ln\\left|\\frac{P-\\lambda_1}{P-\\lambda_2}\\right| \\right]_{P_0}^{P_t} = -\\frac{c^2}{r} t\n$$\n由于 $P_t$ 从 $P_0$ 收敛到 $\\lambda_1$ 而不穿过 $\\lambda_2$（因为 $\\lambda_2 \\le 0$ 且 $P_t \\ge 0$），$(P_t-\\lambda_1)$ 和 $(P_0-\\lambda_1)$ 的符号相同，且 $(P_t-\\lambda_2)>0, (P_0-\\lambda_2)>0$。我们可以去掉绝对值。\n$$\n\\ln\\left(\\frac{P_t-\\lambda_1}{P_t-\\lambda_2}\\right) - \\ln\\left(\\frac{P_0-\\lambda_1}{P_0-\\lambda_2}\\right) = -(\\lambda_1 - \\lambda_2)\\frac{c^2}{r} t\n$$\n注意到 $\\lambda_1 - \\lambda_2 = \\frac{2r\\gamma}{c^2}$，指数变为 $-(\\frac{2r\\gamma}{c^2})\\frac{c^2}{r} t = -2\\gamma t$。\n$$\n\\frac{P_t-\\lambda_1}{P_t-\\lambda_2} = \\frac{P_0-\\lambda_1}{P_0-\\lambda_2} \\exp(-2\\gamma t)\n$$\n求解 $P_t$：\n$$\nP_t = \\frac{\\lambda_1(P_0-\\lambda_2) - \\lambda_2(P_0-\\lambda_1)\\exp(-2\\gamma t)}{(P_0-\\lambda_2) - (P_0-\\lambda_1)\\exp(-2\\gamma t)}\n$$\n其中 $\\lambda_1 = \\frac{r}{c^2}(a+\\gamma)$，$\\lambda_2 = \\frac{r}{c^2}(a-\\gamma)$，以及 $\\gamma = \\sqrt{a^2 + \\frac{c^2 q}{r}}$。\n\n**3. 收敛条件和稳态值 $P_{\\infty}$**\n\n为了使 $P_t$ 收敛到一个有限的稳态值 $P_{\\infty} = \\lim_{t\\to\\infty} P_t$，解必须趋于一个有限极限。从显式解来看，这发生在系统是“可检测的”情况下。对于这个标量系统，可检测性意味着任何不稳定或中性稳定模式（$a \\ge 0$）必须是可观测的（$c \\ne 0$）。这等价于以下条件：\n$$\na  0 \\quad \\text{或} \\quad c \\ne 0\n$$\n如果此条件成立，我们可以通过取 $t \\to \\infty$ 时 $P_t$ 的极限来找到 $P_{\\infty}$。假设 $\\gamma > 0$（如果 $a \\neq 0$ 或 $c^2q \\neq 0$，则该假设成立），项 $\\exp(-2\\gamma t)$ 趋于 $0$。\n$$\nP_{\\infty} = \\lim_{t\\to\\infty} P_t = \\frac{\\lambda_1(P_0-\\lambda_2) - 0}{(P_0-\\lambda_2) - 0} = \\lambda_1\n$$\n这对应于里卡蒂方程的稳定、非负平衡点。稳态方差的闭式表达式为：\n$$\nP_{\\infty} = \\frac{r}{c^2}\\left(a + \\sqrt{a^2 + \\frac{c^2 q}{r}}\\right)\n$$\n此表达式在 $c \\ne 0$ 时有效。如果 $c=0$，收敛条件要求 $a  0$。在这种情况下，里卡蒂 ODE 变为线性的：$\\frac{\\mathrm{d}P_t}{\\mathrm{d}t} = 2aP_t + q$，其稳态解为 $P_{\\infty} = -q/(2a)$。对于 $a  0$ 的情况，当 $c \\to 0$ 时，为 $c \\ne 0$ 推导的公式能正确地趋于这个极限。\n\n**4. 数值计算**\n\n给定数值：$a=0.4$，$c=1.5$，$q=0.2$，$r=0.5$ 和 $P_0=1.0$。\n首先，我们检查收敛条件。我们有 $a=0.4 > 0$，但 $c=1.5 \\ne 0$。条件（$a  0$ 或 $c \\ne 0$）得到满足，因此存在一个有限的稳态方差。我们使用 $P_{\\infty}$ 的公式：\n$$\nP_{\\infty} = \\frac{r}{c^2}\\left(a + \\sqrt{a^2 + \\frac{c^2 q}{r}}\\right)\n$$\n代入给定值：\n$$\nP_{\\infty} = \\frac{0.5}{(1.5)^2}\\left(0.4 + \\sqrt{(0.4)^2 + \\frac{(1.5)^2 (0.2)}{0.5}}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{0.16 + \\frac{2.25 \\times 0.2}{0.5}}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{0.16 + \\frac{0.45}{0.5}}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{0.16 + 0.9}\\right)\n$$\n$$\nP_{\\infty} = \\frac{0.5}{2.25}\\left(0.4 + \\sqrt{1.06}\\right)\n$$\n计算数值：\n$$\nP_{\\infty} \\approx \\frac{0.5}{2.25}\\left(0.4 + 1.029563\\right) \\approx 0.222222 \\times (1.429563) \\approx 0.3176806\n$$\n四舍五入到四位有效数字，我们得到：\n$$\nP_{\\infty} \\approx 0.3177\n$$", "answer": "$$\n\\boxed{0.3177}\n$$", "id": "3080944"}, {"introduction": "在掌握了理论推导后，我们转向数值模拟。这项实践将探讨“能检测性”（detectability）这一关键概念，它是滤波器稳定性的一个核心条件。通过编写代码并观察不同情景下误差协方差的行为，你将对为何某些系统能被有效滤波而另一些则不能，获得直观且具体的理解 [@problem_id:3080976]。", "problem": "考虑一个带有高斯白噪声的连续时间线性随机系统和测量模型，\n$$\n\\mathrm{d}x_t = A x_t \\,\\mathrm{d}t + G \\,\\mathrm{d}W_t,\\quad \\mathrm{d}y_t = C x_t \\,\\mathrm{d}t + D \\,\\mathrm{d}V_t,\n$$\n其中 $x_t \\in \\mathbb{R}^n$，$y_t \\in \\mathbb{R}^m$，$A \\in \\mathbb{R}^{n \\times n}$，$C \\in \\mathbb{R}^{m \\times n}$，$G \\in \\mathbb{R}^{n \\times r}$，$D \\in \\mathbb{R}^{m \\times s}$，并且 $W_t, V_t$ 是标准维纳过程。设过程噪声协方差为 $Q = G G^\\top \\in \\mathbb{R}^{n \\times n}$，测量噪声协方差为 $R = D D^\\top \\in \\mathbb{R}^{m \\times m}$，其中 $R$ 是正定的。卡尔曼-布西滤波器 (KBF) 用估计量 $\\hat{x}_t$ 和一个对称半正定估计误差协方差 $P_t = \\mathbb{E}[(x_t - \\hat{x}_t)(x_t - \\hat{x}_t)^\\top]$ 来估计 $x_t$，该协方差由连续时间里卡蒂微分方程控制\n$$\n\\dot{P}_t = A P_t + P_t A^\\top + Q - P_t C^\\top R^{-1} C P_t,\\quad P_0 \\simeq P(0).\n$$\n如果 $A$ 的每个具有非负实部的特征值都对应一个在 $C$ 下可观测的状态，则称对 $(A,C)$ 是可检测的；等价地，所有不可观测的模态都是指数稳定的。在本问题中，您将构建一个 $(A,C)$ 不可检测的例子，并数值地证明误差协方差 $P_t$ 发散，且采样新息方差无界增长。为了从第一性原理出发以一种有意义的方式量化后者，将固定采样间隔 $\\Delta t$ 上的采样新息残差定义为\n$$\nr_k = y_{t_k+\\Delta t} - y_{t_k} - C \\hat{x}_{t_k}\\,\\Delta t,\n$$\n在线性高斯模型和小 $\\Delta t$ 的条件下，其方差可以很好地近似为\n$$\n\\mathrm{Var}(r_k) \\approx C P_{t_k} C^\\top\\,\\Delta t^2 + R\\,\\Delta t.\n$$\n您的程序必须为每个测试用例对里卡蒂微分方程进行积分，计算最终时间 $T$ 时的 $P_T$，并报告：\n- 最大特征值 $\\lambda_{\\max}(P_T)$，以及\n- 最终时间的采样新息方差 $S_T = C P_T C^\\top\\,\\Delta t^2 + R\\,\\Delta t$。\n\n对所有测试用例使用以下固定的数值设置：\n- 维度 $n=2$，测量维度 $m=1$，\n- 初始协方差 $P_0 = I_2$（$2 \\times 2$ 单位矩阵），\n- 过程噪声矩阵 $G = I_2$，因此 $Q = I_2$，\n- 测量噪声矩阵 $D = 1$（标量），因此 $R = [1]$，\n- 时间步长 $\\Delta t = 0.01$，最终时间 $T = 20$，\n- 使用稳定的四阶显式龙格-库塔方法对 $\\dot{P}_t$ 进行积分，确保 $P_t$ 在每一步都保持对称。\n\n测试套件：\n- 情况 1（不可检测；不稳定的不可观测模态）：$A = \\mathrm{diag}(0.5,-1.0)$，$C = \\begin{bmatrix}0  1\\end{bmatrix}$。\n- 情况 2（可检测；不稳定的模态可观测）：$A = \\mathrm{diag}(0.5,-1.0)$，$C = \\begin{bmatrix}1  0\\end{bmatrix}$。\n- 情况 3（可检测但不可观测；所有不可观测模态都稳定）：$A = \\mathrm{diag}(-0.2,-0.3)$，$C = \\begin{bmatrix}0  1\\end{bmatrix}$。\n- 情况 4（不可检测边界；临界稳定的不可观测模态）：$A = \\mathrm{diag}(0.0,-1.0)$，$C = \\begin{bmatrix}0  1\\end{bmatrix}$。\n\n对于每种情况，从 $t=0$ 到 $t=T$ 数值积分里卡蒂方程。然后计算如上定义的 $\\lambda_{\\max}(P_T)$ 和 $S_T$。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，该列表包含四项（每个测试用例一项），每项本身是一个双元素列表 $[\\lambda_{\\max}(P_T), S_T]$。例如，输出格式必须是\n$$\n[[\\lambda_{\\max}^{(1)},S^{(1)}],[\\lambda_{\\max}^{(2)},S^{(2)}],[\\lambda_{\\max}^{(3)},S^{(3)}],[\\lambda_{\\max}^{(4)},S^{(4)}]],\n$$\n其中每个量都表示为浮点数，不打印任何额外文本。", "solution": "用户的问题要求对与卡尔曼-布西滤波器相关的连续时间矩阵里卡蒂微分方程 (RDE) 进行数值积分。分析将集中于可检测性概念及其对估计误差协方差稳定性的影响。\n\n首先，我们将问题形式化。该系统由状态方程和测量方程控制：\n$$\n\\mathrm{d}x_t = A x_t \\,\\mathrm{d}t + G \\,\\mathrm{d}W_t\n$$\n$$\n\\mathrm{d}y_t = C x_t \\,\\mathrm{d}t + D \\,\\mathrm{d}V_t\n$$\n估计误差协方差 $P_t = \\mathbb{E}[(x_t - \\hat{x}_t)(x_t - \\hat{x}_t)^\\top]$ 根据 RDE 演化：\n$$\n\\dot{P}_t = F(P_t) = A P_t + P_t A^\\top + Q - P_t C^\\top R^{-1} C P_t\n$$\n其中 $Q = G G^\\top$ 且 $R = D D^\\top$。问题提供了固定的参数：状态维度 $n=2$，测量维度 $m=1$，初始协方差 $P_0 = I_2$（$2 \\times 2$ 单位矩阵），过程噪声矩阵 $G=I_2$（因此 $Q=I_2$），以及测量噪声矩阵 $D=1$（一个标量，因此 $R=[1]$ 且 $R^{-1}=[1]$）。积分将从 $t=0$ 执行到最终时间 $T=20$，使用的时间步长为 $\\Delta t = 0.01$。\n\nRDE 是一个矩阵值的常微分方程，我们使用四阶龙格-库塔 (RK4) 方法来求解它。对于一个常微分方程 $\\dot{P}_t = F(P_t)$，从时间 $t_k$ 到 $t_{k+1}=t_k+\\Delta t$ 的更新由以下公式给出：\n$$\nK_1 = F(P_{t_k})\n$$\n$$\nK_2 = F(P_{t_k} + \\frac{\\Delta t}{2} K_1)\n$$\n$$\nK_3 = F(P_{t_k} + \\frac{\\Delta t}{2} K_2)\n$$\n$$\nK_4 = F(P_{t_k} + \\Delta t K_3)\n$$\n$$\nP_{t_{k+1}} = P_{t_k} + \\frac{\\Delta t}{6} (K_1 + 2K_2 + 2K_3 + K_4)\n$$\n协方差矩阵 $P_t$ 必须是对称的。RDE 函数 $F(P_t)$ 保持对称性：如果 $P_t$ 是对称的，那么 $F(P_t)$ 也是对称的。因此，RK4 算法作为 $F$ 的求值的线性组合，也保持对称性。为了抵消由浮点数不精确性引起的任何潜在数值漂移，在每个积分步骤中通过设置 $P_{t_{k+1}} \\leftarrow \\frac{1}{2}(P_{t_{k+1}} + P_{t_{k+1}}^\\top)$ 来显式地强制对称性。\n\n此问题的核心概念是矩阵对 $(A,C)$ 的可检测性。如果 $A$ 的每个具有非负实部的特征值都可以通过测量矩阵 $C$ 观测到，那么矩阵对 $(A,C)$ 是可检测的。如果 $(A,C)$ 是可检测的，并且对 $(A,G)$ 是可镇定的（此处因 $Q=I_20$ 而满足），则 RDE 的解 $P_t$ 将在 $t \\to \\infty$ 时收敛到一个唯一的、有限的、半正定的稳态矩阵 $P_{ss}$。如果 $(A,C)$ 不可检测，误差协方差 $P_t$ 将会发散。我们分析每个测试用例：\n- **情况 1**：$A = \\mathrm{diag}(0.5, -1.0)$，$C = \\begin{bmatrix}0  1\\end{bmatrix}$。特征值 $\\lambda=0.5$ 是不稳定的（非负实部）。其对应的特征向量是 $e_1 = [1, 0]^\\top$。通过乘积 $C e_1 = \\begin{bmatrix}0  1\\end{bmatrix} [1, 0]^\\top = 0$ 来检查此模态的可观测性。该不稳定模态是不可观测的。因此，矩阵对 $(A,C)$ 是不可检测的，我们预期误差协方差 $P_t$ 会发散。\n- **情况 2**：$A = \\mathrm{diag}(0.5, -1.0)$，$C = \\begin{bmatrix}1  0\\end{bmatrix}$。现在用新的 $C$ 测试 $\\lambda=0.5$ 的不稳定模态：$C e_1 = \\begin{bmatrix}1  0\\end{bmatrix} [1, 0]^\\top = 1 \\neq 0$。该不稳定模态是可观测的。矩阵对 $(A,C)$ 是可检测的，我们预期 $P_t$ 会收敛到一个有限的稳态解。\n- **情况 3**：$A = \\mathrm{diag}(-0.2, -0.3)$，$C = \\begin{bmatrix}0  1\\end{bmatrix}$。两个特征值 $-0.2$ 和 $-0.3$ 都具有负实部。所有模态都是稳定的。因此，可检测性的条件（关于不稳定或临界稳定模态）自然满足。矩阵对 $(A,C)$ 是可检测的，我们预期 $P_t$ 会收敛。\n- **情况 4**：$A = \\mathrm{diag}(0.0, -1.0)$，$C = \\begin{bmatrix}0  1\\end{bmatrix}$。特征值 $\\lambda=0.0$ 是临界稳定的（非负实部）。其特征向量是 $e_1 = [1, 0]^\\top$。可观测性测试得出 $C e_1 = \\begin{bmatrix}0  1\\end{bmatrix} [1, 0]^\\top = 0$。该临界稳定模态是不可观测的。矩阵对 $(A,C)$ 是不可检测的，我们预期 $P_t$ 会发散。\n\n在积分 RDE 得到 $P_T$ 后，我们为每种情况计算两个量：\n1. 最终协方差矩阵的最大特征值 $\\lambda_{\\max}(P_T)$。该值量化了估计不确定性最大分量的大小。\n2. 在时间 $T$ 的采样新息方差，由 $S_T = C P_T C^\\top\\,\\Delta t^2 + R\\,\\Delta t$ 给出。该度量反映了基于当前状态估计，下一次测量的可预测性。在 $C$“可见”的方向上发散的 $P_T$ 将导致一个大的 $S_T$。\n\n以下程序实现了这整个过程。它遍历四种情况，执行数值积分，计算所需的度量，并按规定格式化输出。", "answer": "```python\nimport numpy as np\nfrom scipy import __version__ as scipy_version  # For environment spec adherence only\n\ndef solve():\n    \"\"\"\n    求解四个测试用例的连续时间里卡蒂微分方程，并报告最终时刻的最大特征值和采样新息方差。\n    \"\"\"\n    # Define fixed numerical settings from the problem statement.\n    n = 2\n    P0 = np.identity(n)\n    G = np.identity(n)\n    Q = G @ G.T  # Results in the 2x2 identity matrix\n    D = np.array([[1.0]])\n    R = D @ D.T  # Results in the 1x1 matrix [1]\n    try:\n        R_inv = np.linalg.inv(R)\n    except np.linalg.LinAlgError:\n        # Fallback for scalar-like R\n        R_inv = np.array([[1.0 / R[0, 0]]])\n\n    DT = 0.01\n    T_FINAL = 20.0\n\n    # Define the test cases.\n    test_cases = [\n        # Case 1: Not detectable (unstable unobservable mode)\n        {\"A\": np.diag([0.5, -1.0]), \"C\": np.array([[0.0, 1.0]])},\n        # Case 2: Detectable (unstable mode observed)\n        {\"A\": np.diag([0.5, -1.0]), \"C\": np.array([[1.0, 0.0]])},\n        # Case 3: Detectable (all modes stable)\n        {\"A\": np.diag([-0.2, -0.3]), \"C\": np.array([[0.0, 1.0]])},\n        # Case 4: Not detectable (marginally stable unobservable mode)\n        {\"A\": np.diag([0.0, -1.0]), \"C\": np.array([[0.0, 1.0]])},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A = case[\"A\"]\n        C = case[\"C\"]\n        \n        # Initialize the covariance matrix for the current case.\n        P = P0.copy()\n        \n        # Define the right-hand side of the Riccati differential equation.\n        def riccati_rhs(p_matrix):\n            return A @ p_matrix + p_matrix @ A.T + Q - p_matrix @ C.T @ R_inv @ C @ p_matrix\n\n        num_steps = int(T_FINAL / DT)\n        for _ in range(num_steps):\n            # Fourth-order Runge-Kutta (RK4) integration step.\n            k1 = riccati_rhs(P)\n            k2 = riccati_rhs(P + 0.5 * DT * k1)\n            k3 = riccati_rhs(P + 0.5 * DT * k2)\n            k4 = riccati_rhs(P + DT * k3)\n            \n            P_next = P + (DT / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n            # Enforce symmetry to prevent numerical drift.\n            P = 0.5 * (P_next + P_next.T)\n\n        P_T = P\n\n        # 1. Compute the largest eigenvalue of P_T.\n        # np.linalg.eigvalsh is used as it is efficient for symmetric matrices.\n        lambda_max_PT = np.max(np.linalg.eigvalsh(P_T))\n\n        # 2. Compute the sampled innovation variance S_T.\n        # C @ P_T @ C.T results in a (1, 1) matrix for m=1.\n        innovation_var_term = C @ P_T @ C.T\n        S_T_matrix = innovation_var_term * (DT**2) + R * DT\n        S_T = S_T_matrix[0, 0]  # Extract the scalar value.\n\n        results.append([lambda_max_PT, S_T])\n\n    # Format the final output string precisely as required: [[v1,v2],[v3,v4],...].\n    # This manual formatting avoids spaces that str(list) would insert.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3080976"}, {"introduction": "最后的这项实践将解决一个在实际应用中的关键问题：“我的滤波器工作正常吗？”。我们在此引入一个重要的理论特性：一个最优滤波器的“新息序列”（innovation sequence）必须是“白噪声”（white noise）。你将通过编程实现对此特性的检验，学会如何诊断滤波器性能并识别参数失配等问题 [@problem_id:3080965]。", "problem": "考虑一个由连续时间线性卡尔曼-布西滤波器进行滤波并被连续观测的线性随机系统。状态过程由随机微分方程 $dx_t = A x_t \\, dt + G \\, dW_t$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稳定的漂移矩阵，$G \\in \\mathbb{R}^{n \\times r}$ 是扩散输入矩阵，$W_t$ 是一个标准的 $r$ 维维纳过程。观测过程由 $dy_t = H x_t \\, dt + d\\eta_t$ 给出，其中 $H \\in \\mathbb{R}^{m \\times n}$ 是观测矩阵，$\\eta_t$ 是一个 $m$ 维维纳过程，其瞬时协方差强度为 $R_{\\text{eff}} = H R H^{\\top}$，其中 $R \\in \\mathbb{R}^{n \\times n}$ 是某个正定矩阵。卡尔曼-布西滤波器的新息过程是观测增量与其模型预测增量之间的差异。\n\n从线性随机微分方程和卡尔曼-布西滤波器中新息过程的定义出发，设计一个程序，从第一性原理执行以下步骤：\n\n- 使用一种对于伊藤过程而言相容的科学方法，在步长为 $dt$（单位：秒）的均匀采样网格上对上述连续时间模型进行离散化。根据上述定义生成 $x_t$ 和 $y_t$ 的样本路径，确保观测噪声增量的协方差为 $R_{\\text{eff}} \\, dt$。\n- 以符合基本定义的方式实现卡尔曼-布西滤波方程，不使用任何超出连续时间线性高斯设定范围的预先推导的简化公式。使用显式欧拉方法来近似连续时间滤波器的更新。\n- 在每个时间步，根据模型预测的观测增量和实际实现的观测增量，计算新息序列增量 $\\Delta \\nu_k$。\n- 估计新息序列在滞后 $0$、$1$ 和 $2$ 时的样本自协方差矩阵。使用从随机向量间协方差定义推导出的无偏或相容的有限样本估计量。\n- 将估计的滞后-$0$ 新息协方差与由分布极限 $H R H^{\\top} \\, \\delta$ 表征的理论行为进行比较，这意味着在离散步长上，滞后-$0$ 协方差等于 $H R H^{\\top} \\, dt$，而当 $\\ell \\ge 1$ 时，滞后-$\\ell$ 协方差为 $0$。使用差值的弗罗贝尼乌斯范数（由 $H R H^{\\top} \\, dt$ 的弗罗贝尼乌斯范数归一化）来量化滞后 $0$ 时的失配，并使用滞后-$1$ 协方差的弗罗贝尼乌斯范数（由滞后-$0$ 协方差的弗罗贝尼乌斯范数归一化）来量化非白性。\n\n您的程序必须在以下参数集测试套件下模拟和测试新息的白性。在每个测试用例中，$dt$ 以秒为单位指定，$N$ 是一个正整数。所有矩阵必须在科学上是合理的，其中 $A$ 是稳定的，噪声协方差是正定的：\n\n- 测试用例 1（基准二维系统，良好调优的滤波器）：\n  - $n = 2$, $m = 2$, $r = 2$.\n  - $A = \\begin{bmatrix} -0.5  0.0 \\\\ 0.0  -1.0 \\end{bmatrix}$, $G = I_2$, $H = \\begin{bmatrix} 1.0  0.5 \\\\ 0.0  1.0 \\end{bmatrix}$.\n  - $Q = I_2$（过程噪声协方差强度），$R = \\operatorname{diag}(0.4, 0.6)$（用于构造 $R_{\\text{eff}} = H R H^{\\top}$）。\n  - $dt = 0.01$ 秒，$N = 5000$，初始均值 $x_0 = 0$，初始滤波器协方差 $P_0 = I_2$。\n  - 滤波器必须使用真实的 $R_{\\text{eff}}$。\n\n- 测试用例 2（边界一维系统，小步长）：\n  - $n = 1$, $m = 1$, $r = 1$.\n  - $A = [-2.0]$, $G = [1.0]$, $H = [1.0]$.\n  - $Q = [1.0]$，$R = [0.2]$，因此 $R_{\\text{eff}} = H R H^{\\top} = [0.2]$。\n  - $dt = 0.002$ 秒，$N = 15000$，初始均值 $x_0 = 0$，初始滤波器协方差 $P_0 = [1.0]$。\n  - 滤波器必须使用真实的 $R_{\\text{eff}}$。\n\n- 测试用例 3（滤波器中使用失配的测量噪声以诱发非白性）：\n  - 与测试用例 1 相同，但滤波器必须使用失配的测量噪声协方差强度 $\\widehat{R}_{\\text{eff}} = 0.25 \\times R_{\\text{eff}}$，而模拟的观测噪声仍使用真实的 $R_{\\text{eff}}$。\n\n对于每个测试用例，计算两个标量指标：\n- 归一化滞后-$0$ 失配 $\\rho_0 = \\dfrac{\\| \\widehat{\\Gamma}_0 - R_{\\text{eff}} \\, dt \\|_F}{\\| R_{\\text{eff}} \\, dt \\|_F}$，其中 $\\widehat{\\Gamma}_\\ell$ 表示滞后 $\\ell$ 时的样本自协方差，$\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n- 归一化滞后-$1$ 幅值 $\\rho_1 = \\dfrac{\\| \\widehat{\\Gamma}_1 \\|_F}{\\| \\widehat{\\Gamma}_0 \\|_F}$。\n\n为每个测试用例声明一个布尔类型的通过/失败结果，定义为：如果 $\\rho_0 \\le 0.3$ 和 $\\rho_1 \\le 0.25$ 同时满足，则为真（true），否则为假（false）。这些阈值是无量纲的，必须对所有测试用例一致地应用。\n\n您的程序应生成单行输出，其中包含三个测试用例的通过/失败结果，格式为方括号内以逗号分隔的列表，例如 $[ \\text{true}, \\text{false}, \\text{true} ]$。输出值为布尔型且无量纲。不得打印任何其他输出。", "solution": "本问题的目标是数值验证连续时间线性卡尔曼-布西滤波器的一个基本属性：其新息过程的白性。该任务包括模拟一个线性随机系统，应用离散化版本的卡尔曼-布西滤波器，并分析所得新息序列的统计特性。分析将针对三个不同的测试用例进行，包括一个良好调优的滤波器和一个参数失配的滤波器，以观察理论性质及其失效情况。\n\n该系统由一对伊藤随机微分方程（SDE）描述。状态过程 $x_t \\in \\mathbb{R}^n$ 的演化遵循：\n$$dx_t = A x_t \\, dt + G \\, dW_t$$\n而观测过程 $y_t \\in \\mathbb{R}^m$ 由下式给出：\n$$dy_t = H x_t \\, dt + d\\eta_t$$\n此处，$A$ 是状态动态矩阵，$G$ 是过程噪声输入矩阵，$H$ 是观测矩阵。$W_t$ 和 $\\eta_t$ 是维纳过程。过程噪声项 $G \\, dW_t$ 的协方差强度矩阵为 $Q_c = G Q G^T$，其中基础维纳过程 $W_t$ 增量的协方差为 $Q \\, dt$。观测噪声 $d\\eta_t$ 具有指定的协方差强度矩阵 $R_{\\text{eff}} = H R H^T$，其中 $R$ 是一个给定的正定矩阵。\n\n**1. 系统与滤波器离散化**\n\n为了在数字计算机上模拟系统和滤波器，我们必须在步长为 $dt$ 的均匀时间网格上对连续时间方程进行离散化。\n\n**系统离散化**：我们使用 Euler-Maruyama 方法，这是一种用于随机微分方程（SDEs）的标准一阶数值方案。对于一个小的 时间步长 $dt$，在时间 $t_{k+1} = t_k + dt$ 的状态可近似为：\n$$x_{k+1} \\approx x_k + A x_k \\, dt + \\Delta\\xi_k$$\n其中 $\\Delta\\xi_k$ 是一个均值为零、协方差矩阵为 $E[\\Delta\\xi_k \\Delta\\xi_k^T] = Q_c \\, dt = (G Q G^T) \\, dt$ 的高斯随机向量。\n\n观测方程通过在区间 $[t_k, t_{k+1}]$ 上积分进行离散化，得到观测增量 $\\Delta y_k = y_{k+1} - y_k$：\n$$\\Delta y_k \\approx H x_k \\, dt + \\Delta\\eta_k$$\n其中 $\\Delta\\eta_k$ 是一个均值为零、协方差矩阵为 $E[\\Delta\\eta_k \\Delta\\eta_k^T] = R_{\\text{eff}} \\, dt$ 的高斯随机向量。\n\n**滤波器离散化**：Kalman-Bucy 滤波器提供状态 $x_t$ 的最优估计 $\\hat{x}_t$。该估计及其误差协方差矩阵 $P_t = E[(x_t - \\hat{x}_t)(x_t - \\hat{x}_t)^T]$ 遵循连续时间微分方程演化。我们使用显式欧拉方法来近似其解。\n\n状态估计更新由以下随机微分方程给出：\n$$d\\hat{x}_t = A \\hat{x}_t \\, dt + K_t (dy_t - H \\hat{x}_t \\, dt)$$\n其欧拉离散化为：\n$$\\hat{x}_{k+1} \\approx \\hat{x}_k + (A \\hat{x}_k) \\, dt + K_k (\\Delta y_k - H \\hat{x}_k \\, dt)$$\n误差协方差 $P_t$ 遵循连续时间里卡蒂微分方程演化：\n$$\\frac{dP_t}{dt} = A P_t + P_t A^T - P_t H^T \\widehat{R}_{\\text{eff}}^{-1} H P_t + Q_c$$\n其中 $\\widehat{R}_{\\text{eff}}$ 是滤波器所假设的测量噪声协方差强度，它可能与真实的 $R_{\\text{eff}}$ 不匹配。卡尔曼增益 $K_t$ 由 $K_t = P_t H^T \\widehat{R}_{\\text{eff}}^{-1}$ 给出。代入增益表达式，Riccati 方程变为 $\\frac{dP_t}{dt} = A P_t + P_t A^T - K_t H P_t + Q_c$。协方差的显式欧拉更新为：\n$$P_{k+1} \\approx P_k + (A P_k + P_k A^T - K_k H P_k + Q_c) \\, dt$$\n在每一步中，增益 $K_k = P_k H^T \\widehat{R}_{\\text{eff}}^{-1}$ 使用当前的协方差 $P_k$ 计算。\n\n**2. 新息序列与自协方差分析**\n\n卡尔曼滤波器的一个关键组成部分是新息过程，它代表了最新测量所提供的新信息。连续时间新息为 $d\\nu_t = dy_t - H \\hat{x}_t \\, dt$。对于最优滤波器，新息过程是一个与测量噪声具有相同统计特性的维纳过程，即 $E[d\\nu_t d\\nu_s^T] = R_{\\text{eff}} \\delta(t-s) \\, dt ds$。\n\n在步骤 $k$ 的离散化新息增量为：\n$$\\Delta \\nu_k = \\Delta y_k - H \\hat{x}_k \\, dt$$\n理论性质表明，对于一个最优滤波器，序列 $\\{\\Delta\\nu_k\\}$ 应该是一个零均值、不相关（白噪声）的向量序列，其滞后为零的协方差矩阵为 $\\Gamma_0 = E[\\Delta\\nu_k \\Delta\\nu_k^T] = R_{\\text{eff}} \\, dt$，而对于所有非零滞后，协方差为零，即当 $\\ell \\ge 1$ 时，$\\Gamma_\\ell = E[\\Delta\\nu_{k+\\ell} \\Delta\\nu_k^T] = 0$。\n\n为验证此性质，我们从模拟的新息序列 $\\{\\Delta\\nu_0, \\Delta\\nu_1, \\dots, \\Delta\\nu_{N-1}\\}$ 中估计样本自协方差矩阵：\n$$\\widehat{\\Gamma}_\\ell = \\frac{1}{N-\\ell} \\sum_{k=0}^{N-1-\\ell} \\Delta\\nu_{k+\\ell} \\Delta\\nu_k^T$$\n我们计算滞后 $\\ell=0$ 和 $\\ell=1$ 时的该值。\n\n**3. 性能指标与评估**\n\n问题指定了两个指标来量化所估计新息序列的白性：\n1.  **归一化滞后-0失配（$\\rho_0$）**：该指标衡量估计的滞后-$0$ 协方差与其理论值的偏差。\n    $$\\rho_0 = \\frac{\\| \\widehat{\\Gamma}_0 - R_{\\text{eff}} \\, dt \\|_F}{\\| R_{\\text{eff}} \\, dt \\|_F}$$\n    其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。一个小的 $\\rho_0$ 值表示滤波器正确地捕捉了新息的方差。\n\n2.  **归一化滞后-1幅值（$\\rho_1$）**：该指标衡量滞后 $1$ 时的相关程度，并由滞后-$0$ 的功率进行归一化。\n    $$\\rho_1 = \\frac{\\| \\widehat{\\Gamma}_1 \\|_F}{\\| \\widehat{\\Gamma}_0 \\|_F}$$\n    一个小的 $\\rho_1$ 值表示新息接近不相关（白噪声），这与理论预期相符。\n\n如果一个测试用例同时满足 $\\rho_0 \\le 0.3$ 和 $\\rho_1 \\le 0.25$，则认为其通过测试。该标准检查滤波器性能是否接近最优。测试用例 3 使用了失配的噪声协方差 $\\widehat{R}_{\\text{eff}}$，预计会产生一个次优滤波器，导致有色新息，并很可能无法通过此测试。\n\n程序实现了这整个过程：它为每个参数集模拟系统和滤波器，计算新息序列，估计其自协方差，计算指标 $\\rho_0$ 和 $\\rho_1$，并确定通过/失败的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Simulates a linear stochastic system, applies a Kalman-Bucy filter,\n    and analyzes the whiteness of the innovation sequence.\n    \"\"\"\n    n, m, A, G, H, Q, R, dt, N, P0, R_eff_mismatch_factor = params\n    \n    # --- 1. Initialization ---\n    \n    # Ensure all matrices are 2D arrays for consistent matrix multiplication\n    A, G, H, Q, R, P0 = map(np.atleast_2d, (A, G, H, Q, R, P0))\n\n    # True continuous-time noise covariance matrices\n    Qc = G @ Q @ G.T\n    R_eff = H @ R @ H.T\n    \n    # Filter's assumed continuous-time measurement noise covariance\n    R_eff_hat = R_eff * R_eff_mismatch_factor\n    R_eff_hat_inv = np.linalg.inv(R_eff_hat)\n\n    # Initial states as column vectors\n    x = np.zeros((n, 1))\n    x_hat = np.zeros((n, 1))\n    P = np.copy(P0)\n\n    # Storage for innovation increments\n    innovations = np.zeros((N, m))\n    \n    # Discrete-time noise covariance matrices for simulation\n    Q_proc_dt = Qc * dt\n    R_obs_dt = R_eff * dt\n\n    mean_n = np.zeros(n)\n    mean_m = np.zeros(m)\n    \n    # --- 2. Simulation Loop ---\n    for k in range(N):\n        # Generate noise increments as column vectors\n        proc_noise = np.random.multivariate_normal(mean_n, Q_proc_dt).reshape(n, 1)\n        obs_noise = np.random.multivariate_normal(mean_m, R_obs_dt).reshape(m, 1)\n        \n        # S-1: Simulate true system observation increment at step k\n        delta_y = (H @ x) * dt + obs_noise\n        \n        # S-2: Simulate true system state update for step k+1\n        x_next = x + (A @ x) * dt + proc_noise\n        \n        # F-1: Calculate innovation increment at step k\n        delta_nu = delta_y - (H @ x_hat) * dt\n        innovations[k, :] = delta_nu.flatten()\n\n        # F-2: Calculate Kalman gain at step k\n        K = P @ H.T @ R_eff_hat_inv\n        \n        # F-3: Update filter state estimate for step k+1\n        x_hat_next = x_hat + (A @ x_hat) * dt + K @ delta_nu\n        \n        # F-4: Update filter covariance for step k+1 via Euler on Riccati eq.\n        dP_dt = A @ P + P @ A.T - K @ H @ P + Qc\n        P_next = P + dP_dt * dt\n        \n        # Advance time step\n        x, x_hat, P = x_next, x_hat_next, P_next\n        \n    # --- 3. Post-Processing ---\n    \n    # Estimate autocovariances using vectorized operations\n    Gamma_hat_0 = (innovations.T @ innovations) / N\n    Gamma_hat_1 = (innovations[1:].T @ innovations[:-1]) / (N - 1)\n    \n    # Theoretical lag-0 covariance\n    Gamma_0_th = R_eff * dt\n    \n    # Calculate Frobenius norms for metrics\n    norm_gamma_th_0 = np.linalg.norm(Gamma_0_th, 'fro')\n    if norm_gamma_th_0  1e-15: norm_gamma_th_0 = 1.0\n\n    norm_gamma_hat_0 = np.linalg.norm(Gamma_hat_0, 'fro')\n    if norm_gamma_hat_0  1e-15: norm_gamma_hat_0 = 1.0\n\n    # Calculate metrics\n    rho_0 = np.linalg.norm(Gamma_hat_0 - Gamma_0_th, 'fro') / norm_gamma_th_0\n    rho_1 = np.linalg.norm(Gamma_hat_1, 'fro') / norm_gamma_hat_0\n\n    # Apply pass/fail criterion\n    is_pass = rho_0 = 0.3 and rho_1 = 0.25\n    return is_pass\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the simulations.\n    \"\"\"\n    # Test Case 1: Baseline 2D system, well-tuned filter\n    A1 = np.array([[-0.5, 0.0], [0.0, -1.0]])\n    G1 = np.eye(2)\n    H1 = np.array([[1.0, 0.5], [0.0, 1.0]])\n    Q1 = np.eye(2)\n    R1 = np.diag([0.4, 0.6])\n    P0_1 = np.eye(2)\n    case1 = (2, 2, A1, G1, H1, Q1, R1, 0.01, 5000, P0_1, 1.0)\n\n    # Test Case 2: Boundary 1D system, well-tuned filter\n    A2 = np.array([[-2.0]])\n    G2 = np.array([[1.0]])\n    H2 = np.array([[1.0]])\n    Q2 = np.array([[1.0]])\n    R2 = np.array([[0.2]])\n    P0_2 = np.array([[1.0]])\n    case2 = (1, 1, A2, G2, H2, Q2, R2, 0.002, 15000, P0_2, 1.0)\n\n    # Test Case 3: Mismatched filter (underestimates measurement noise)\n    case3 = (2, 2, A1, G1, H1, Q1, R1, 0.01, 5000, P0_1, 0.25)\n    \n    test_cases = [case1, case2, case3]\n    \n    # Using a fixed seed for reproducibility of the stochastic simulation results.\n    np.random.seed(42)\n    \n    results = []\n    for case in test_cases:\n        pass_fail = run_simulation(case)\n        results.append(str(pass_fail).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3080965"}]}