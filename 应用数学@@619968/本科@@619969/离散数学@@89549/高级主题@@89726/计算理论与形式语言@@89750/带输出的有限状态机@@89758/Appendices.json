{"hands_on_practices": [{"introduction": "理解有输出的有限状态机的第一步是学会如何追踪其行为。这个练习将带你逐步演练一个典型的米利机 (Mealy machine)，给定一个输入字符串，你需要根据其状态转移表和输出表计算出最终的输出序列。这有助于你掌握米利机的基本运行机制，即其输出如何同时取决于当前状态和当前输入。[@problem_id:1370727]", "problem": "米利机（Mealy machine）是一种有限状态机，其输出由当前状态和当前输入共同决定。考虑一个由以下组件定义的米利机 $M$：\n- 状态集 $S = \\{s_0, s_1, s_2, s_3\\}$，其中 $s_0$ 是起始状态。\n- 输入字母表 $\\Sigma = \\{0, 1\\}$。\n- 输出字母表 $\\Gamma = \\{a, b, c\\}$。\n\n该机器的行为由其转移函数 $g: S \\times \\Sigma \\to S$ 和其输出函数 $h: S \\times \\Sigma \\to \\Gamma$ 描述。合并的转移和输出表如下所示。每个条目是一个（下一状态，输出）对。\n\n| 当前状态 | 输入 0             | 输入 1             |\n|:--------------|:--------------------|:--------------------|\n| $s_0$         | ($s_2$, $a$)        | ($s_1$, $b$)        |\n| $s_1$         | ($s_0$, $c$)        | ($s_3$, $a$)        |\n| $s_2$         | ($s_2$, $b$)        | ($s_0$, $c$)        |\n| $s_3$         | ($s_1$, $a$)        | ($s_3$, $b$)        |\n\n给定输入字符串 `1011`，确定机器 $M$ 产生的输出字符串。你的答案应该是输出字符的序列，连接在一起，没有任何空格或分隔符。", "solution": "我们从起始状态 $s_{0}$ 开始，逐个符号地处理输入字符串。对于一个米利机，对于每个输入符号 $x$，我们产生一个输出 $h(\\text{state}, x)$ 并转移到下一状态 $g(\\text{state}, x)$。\n\n设输入为 $x_{1}x_{2}x_{3}x_{4} = 1011$。初始化 $q_{0} = s_{0}$。\n\n- 对于 $x_{1} = 1$：根据表中 $(s_{0}, 1)$ 的条目，我们有 $(g(s_{0}, 1), h(s_{0}, 1)) = (s_{1}, b)$。因此 $q_{1} = s_{1}$ 且 $y_{1} = b$。\n- 对于 $x_{2} = 0$：根据表中 $(s_{1}, 0)$ 的条目，我们有 $(g(s_{1}, 0), h(s_{1}, 0)) = (s_{0}, c)$。因此 $q_{2} = s_{0}$ 且 $y_{2} = c$。\n- 对于 $x_{3} = 1$：根据表中 $(s_{0}, 1)$ 的条目，我们有 $(g(s_{0}, 1), h(s_{0}, 1)) = (s_{1}, b)$。因此 $q_{3} = s_{1}$ 且 $y_{3} = b$。\n- 对于 $x_{4} = 1$：根据表中 $(s_{1}, 1)$ 的条目，我们有 $(g(s_{1}, 1), h(s_{1}, 1)) = (s_{3}, a)$。因此 $q_{4} = s_{3}$ 且 $y_{4} = a$。\n\n按顺序连接输出得到 $y_{1}y_{2}y_{3}y_{4} = bcba$。", "answer": "$$\\boxed{bcba}$$", "id": "1370727"}, {"introduction": "在理论学习之后，将知识应用于实践是关键，而找出设计中的瑕疵则是工程师的一项核心技能。本问题提供了一个有设计缺陷的米利机，它本应作为一个 “010” 序列检测器。你的任务是像一个测试工程师一样，通过分析其行为，找出能揭示其错误的、长度最短的输入字符串，这能加深你对状态机设计中逻辑严密性的理解。[@problem_id:1370700]", "problem": "米利机是一种有限状态机，其输出取决于当前状态和当前输入。一位工程师设计了一台米利机，用作重叠序列检测器。该机器应处理一个二进制输入字符串，并且当且仅当最近接收的三个比特位形成序列 `010` 时，输出 `1`。对于所有其他情况，它应输出 `0`。\n\n该机器由状态集 $S = \\{S_0, S_1, S_2\\}$、输入字母表 $\\Sigma = \\{0, 1\\}$、输出字母表 $\\Gamma = \\{0, 1\\}$ 和初始状态 $S_0$ 定义。该机器的行为由以下转移和输出表指定：\n\n| 当前状态 | 输入 | 下一状态 | 输出 |\n| :---: | :---: | :---: | :---: |\n| $S_0$ | 0 | $S_1$ | 0 |\n| $S_0$ | 1 | $S_0$ | 0 |\n| $S_1$ | 0 | $S_1$ | 0 |\n| $S_1$ | 1 | $S_2$ | 0 |\n| $S_2$ | 0 | $S_0$ | 1 |\n| $S_2$ | 1 | $S_0$ | 0 |\n\n然而，这个设计存在一个缺陷。该机器并不总是根据其规范产生正确的输出。找出可能的最短长度的二进制输入字符串，使得该机器的输出字符串与正确指定的输出字符串不同。对于输入字符串 $w = w_1w_2...w_k$，正确的输出是一个输出字符串 $z = z_1z_2...z_k$，其中当 $w_{i-2}w_{i-1}w_i = 010$ 时 $z_i=1$，否则 $z_i=0$。对于 $i  3$，输出 $z_i$ 总是 $0$。", "solution": "设输入为 $w = b_{1}b_{2}\\dots b_{k}$，机器输出为 $y_{1}y_{2}\\dots y_{k}$，而根据规范的正确输出为 $z_{1}z_{2}\\dots z_{k}$，其中当且仅当 $i\\geq 3$ 且 $b_{i-2}b_{i-1}b_{i}=010$ 时 $z_{i}=1$，否则 $z_{i}=0$（特别是 $z_{1}=z_{2}=0$）。\n\n我们从初始状态 $S_{0}$ 开始模拟这台米利机。用 $s_{i}$ 表示读取 $b_{i}$ 之前的状态；因此 $s_{1}=S_{0}$，在状态 $s_{i}$ 读取 $b_{i}$ 时，会产生输出 $y_{i}$，并且机器会按照表中的规定转移到 $s_{i+1}$。\n\n第 1 步：对于 $i=1$ 和 $i=2$，从表可知，从 $S_{0}$ 和 $S_{1}$ 出发的所有输出都是 $0$，并且不可能在两步内从 $S_{0}$ 到达 $S_{2}$。因此，对于所有输入，$y_{1}=y_{2}=0=z_{1}=z_{2}$；在 $i=1,2$ 时不可能出现不匹配。\n\n第 2 步：对于 $i=3$，机器仅在转移 $(S_{2},0)\\to S_{0}$ 时输出 $1$。从 $S_{0}$ 出发，经过两次输入后要使 $s_{3}=S_{2}$ 的唯一方法是读取 $b_{1}b_{2}=01$（因为 $S_{0}\\xrightarrow{0}S_{1}\\xrightarrow{1}S_{2}$）。因此，$y_{3}=1$ 当且仅当 $b_{1}b_{2}b_{3}=010$，这与规范中 $z_{3}=1$ 的情况完全匹配，否则为 $0$。因此，在 $i=3$ 时不可能出现不匹配。\n\n第 3 步：对于 $i=4$，规范要求 $z_{4}=1$ 当且仅当 $b_{2}b_{3}b_{4}=010$，即输入形式为 $x010$，其中 $x\\in\\{0,1\\}$。机器输出 $y_{4}=1$ 的条件是 $s_{4}=S_{2}$ 且 $b_{4}=0$。计算所有长度为 3 的前缀的 $s_{4}$：\n- 如果 $b_{1}b_{2}b_{3}\\in\\{001,101\\}$，则 $s_{4}=S_{2}$；否则 $s_{4}\\in\\{S_{0},S_{1}\\}$。\n因此，只有在输入为 $0010$ 和 $1010$ 时才会出现 $y_{4}=1$，这恰好是 $b_{2}b_{3}b_{4}=010$ 的输入。对于所有其他输入，$y_{4}=0$，而在这些情况下 $z_{4}$ 也为 $0$。因此，在 $i=4$ 时不可能出现不匹配。\n\n第 4 步：考虑 $i=5$。取 $w=01010$。通过滑动长度为 3 的窗口来计算正确的输出：\n- $z_{1}=0$，$z_{2}=0$，\n- $z_{3}=1$ 因为 $b_{1}b_{2}b_{3}=010$，\n- $z_{4}=0$ 因为 $b_{2}b_{3}b_{4}=101$，\n- $z_{5}=1$ 因为 $b_{3}b_{4}b_{5}=010$。\n因此 $z=00101$。\n\n在 $w=01010$ 上模拟该机器：\n- $i=1$: $s_{1}=S_{0}$，输入 $0$ 得到 $y_{1}=0$，$s_{2}=S_{1}$。\n- $i=2$: $s_{2}=S_{1}$，输入 $1$ 得到 $y_{2}=0$，$s_{3}=S_{2}$。\n- $i=3$: $s_{3}=S_{2}$，输入 $0$ 得到 $y_{3}=1$，$s_{4}=S_{0}$（注意重置到 $S_{0}$）。\n- $i=4$: $s_{4}=S_{0}$，输入 $1$ 得到 $y_{4}=0$，$s_{5}=S_{0}$。\n- $i=5$: $s_{5}=S_{0}$，输入 $0$ 得到 $y_{5}=0$，$s_{6}=S_{1}$。\n因此 $y=00100$。\n\n比较可知，$y_{5}=0$ 而 $z_{5}=1$，所以在第 5 个位置出现了不匹配。根据上面对 $i\\leq 4$ 的论证，对于任何更短的输入都不可能出现不匹配。因此，揭示缺陷的最小长度输入字符串是 $01010$。", "answer": "$$\\boxed{01010}$$", "id": "1370700"}, {"introduction": "与米利机不同，摩尔机 (Moore machine) 的输出仅由当前状态决定。为了巩固这一核心区别，本练习将挑战你进行一次“逆向工程”。给定一个摩尔机和一个特定的输出序列，你需要反向推导出所有可能产生该输出的输入字符串。这个过程将迫使你深入思考状态与输出之间的固定映射关系，这是摩尔机设计的基石。[@problem_id:1370719]", "problem": "考虑一个为简单数字信号处理任务设计的Moore机。Moore机由一个状态集、一个输入字母表、一个输出字母表、一个转移函数、一个输出函数和一个指定的起始状态定义。Moore机的输出仅由其当前状态决定。\n\n该机器正式定义为 $M = (S, s_{start}, \\Sigma, \\Lambda, T, G)$，其组成部分如下：\n-   状态集为 $S = \\{q_0, q_1, q_2\\}$。\n-   起始状态为 $s_{start} = q_0$。\n-   输入字母表为 $\\Sigma = \\{0, 1\\}$。\n-   输出字母表为 $\\Lambda = \\{0, 1\\}$。\n\n该机器的行为由其转移函数 $T: S \\times \\Sigma \\to S$ 和输出函数 $G: S \\to \\Lambda$ 控制，具体规定如下：\n\n**输出函数 G：**\n-   $G(q_0) = 1$\n-   $G(q_1) = 0$\n-   $G(q_2) = 1$\n\n**转移函数 T：**\n-   $T(q_0, 0) = q_1$\n-   $T(q_0, 1) = q_2$\n-   $T(q_1, 0) = q_0$\n-   $T(q_1, 1) = q_2$\n-   $T(q_2, 0) = q_0$\n-   $T(q_2, 1) = q_1$\n\n当处理一个输入字符串时，机器从状态 $q_0$ 开始。输出字符串的第一个字符是 $G(q_0)$。接着，对于输入字符串中的每个字符，机器都会转移到一个新状态，并产生与该新状态对应的输出。对于长度为 $k$ 的输入字符串，输出字符串的长度将为 $k+1$。\n\n确定所有可能的长度为2的输入字符串的集合，这些字符串使得机器产生输出字符串 `101`。\n\nA. $\\{00, 11\\}$\n\nB. $\\{01, 10\\}$\n\nC. $\\{00, 01\\}$\n\nD. $\\{10, 11\\}$\n\nE. $\\{01, 11\\}$\n\nF. 空集 $\\emptyset$", "solution": "设长度为2的输入字符串表示为 $x_1x_2$，其中 $x_1, x_2 \\in \\{0, 1\\}$。对于Moore机，输出字符串是根据所访问的状态序列生成的。机器从初始状态 $s_{start} = q_0$ 开始。初始输出为 $G(q_0)$。处理完第一个输入字符 $x_1$ 后，机器转移到一个新状态，记为 $q'$，其中 $q' = T(q_0, x_1)$。第二个输出字符是 $G(q')$。处理完第二个输入字符 $x_2$ 后，机器转移到一个最终状态，记为 $q''$，其中 $q'' = T(q', x_2)$。第三个输出字符是 $G(q'')$。\n\n所以，对于输入字符串 $x_1x_2$，状态序列为 $q_0 \\xrightarrow{x_1} q' \\xrightarrow{x_2} q''$。对应的输出字符串是 $G(q_0)G(q')G(q'')$。根据题意，这个输出字符串必须是 `101`。\n\n我们通过将所需输出与机器的输出函数 $G$ 进行比较来分解这个问题：\n\n1.  **第一个输出字符（来自起始状态）：**\n    要求的第一个输出是 `1`。机器从起始状态 $q_0$ 的输出是 $G(q_0)$。根据问题定义，$G(q_0) = 1$。这与要求相符，因此该条件满足，对输入没有任何限制。\n\n2.  **第二个输出字符（在第一个输入 $x_1$ 之后）：**\n    要求的第二个输出是 `0`。这个输出由状态 $q' = T(q_0, x_1)$ 生成。我们需要找到输出为 `0` 的状态。查看输出函数 $G$：\n    $G(q_0) = 1$\n    $G(q_1) = 0$\n    $G(q_2) = 1$\n    唯一产生输出 `0` 的状态是 $q_1$。因此，第一次转移后的状态 $q'$ 必须是 $q_1$。\n    所以，我们必须有 $T(q_0, x_1) = q_1$。\n    现在我们查看从 $q_0$ 开始的转移函数 $T$：\n    $T(q_0, 0) = q_1$\n    $T(q_0, 1) = q_2$\n    要从 $q_0$ 到达状态 $q_1$，输入 $x_1$ 必须是 `0`。所以，我们的输入字符串的第一个字符是固定的：$x_1 = 0$。\n\n3.  **第三个输出字符（在第二个输入 $x_2$ 之后）：**\n    要求的第三个输出是 `1`。这个输出由状态 $q'' = T(q', x_2)$ 生成。我们已经确定 $q'$ 必须是 $q_1$。所以，我们需要找到 $x_2$，使得机器从 $q_1$ 转移到一个状态 $q''$，并且 $G(q'') = 1$。\n    从输出函数 $G$ 可知，产生输出 `1` 的状态是 $q_0$ 和 $q_2$。\n    因此，目标状态 $q''$ 可以是 $q_0$ 或 $q_2$。我们需要检查哪些输入 $x_2$ 会导致从 $q_1$ 到 $q_0$ 或 $q_2$ 的转移。\n    我们来看从状态 $q_1$ 的转移：\n    $T(q_1, 0) = q_0$\n    $T(q_1, 1) = q_2$\n\n    *   **情况1：** 机器转移到 $q_0$。这在输入为 $x_2 = 0$ 时发生。由于 $G(q_0) = 1$，这是一条有效的路径。结合 $x_1 = 0$，得到输入字符串 $x_1x_2 = 00$。\n    *   **情况2：** 机器转移到 $q_2$。这在输入为 $x_2 = 1$ 时发生。由于 $G(q_2) = 1$，这也是一条有效的路径。结合 $x_1 = 0$，得到输入字符串 $x_1x_2 = 01$。\n\n4.  **结论：**\n    我们找到了两个可能的长度为2的输入字符串可以产生输出 `101`：`00` 和 `01`。\n    我们来验证一下：\n    -   输入 `00`：$q_0 \\xrightarrow{0} q_1 \\xrightarrow{0} q_0$。输出序列：$G(q_0)G(q_1)G(q_0) = 101$。正确。\n    -   输入 `01`：$q_0 \\xrightarrow{0} q_1 \\xrightarrow{1} q_2$。输出序列：$G(q_0)G(q_1)G(q_2) = 101$。正确。\n\n    所有可能的输入字符串集合是 $\\{00, 01\\}$。这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1370719"}]}