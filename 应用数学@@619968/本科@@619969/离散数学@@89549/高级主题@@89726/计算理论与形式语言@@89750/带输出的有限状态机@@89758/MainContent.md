## 引言
从智能手机到交通信号灯，我们的世界充满了做出决策和记忆信息的自动化系统。这些系统的核心往往是一种强大的[计算模型](@article_id:313052)：有输出的[有限状态机](@article_id:323352)（Finite-State Machine, FSM）。它们是数字世界的无形齿轮，以简洁的逻辑规则驱动着复杂的行为。然而，并非所有状态机都以相同的方式与世界互动。

其中，最主要的两类是[米利机](@article_id:323448)（Mealy machine）和[摩尔机](@article_id:323235)（Moore machine）。尽管它们都能完成相似的任务，但其工作哲学上的细微差别——输出是在转换的“旅程”中产生，还是在状态的“目的地”上显现——决定了它们各自的优势和应用场景。理解这一根本区别，并掌握它们之间的联系与转换，是深入现代计算和系统设计的关键一步。

本文将带领读者深入探索这两种机器的内在机制。我们将在第一章“核心概念”中，通过生动的例子剖析它们的定义、关键区别，并揭示它们之间如何相互转换以及如何通过[状态最小化](@article_id:336923)来达到最高效率。随后的章节将进一步展示这些抽象模型如何在数字逻辑、[编译器设计](@article_id:335686)乃至合成生物学等广泛领域中发挥着不可或缺的作用，揭示它们作为我们数字世界构建基石的真正威力。

## 原理与机制

想象一下，你正在与两台奇特的自动售货机互动。第一台，我们称之为机器 M，有一系列按钮。你处于一个特定的“状态”——也许你已经投了一枚硬币。当你按下一个按钮（输入），一罐苏打水就哐当一声掉了出来（输出）。输出发生在按下按钮的“动作期间”。现在，考虑第二台，机器 R。它的前面有一个小屏幕。屏幕上总是根据机器的当前状态显示一条信息：“准备就绪”、“请投币”或“正在出货”。你看到的信息只取决于机器所处的“状态”，而不是你将要按下的按钮。在你按下按钮后，机器转换到一个新状态，屏幕会更新以显示该新状态的信息。

从本质上讲，这两台机器抓住了我们故事中两个主角——**[米利机](@article_id:323448)（Mealy machine）**和**[摩尔机](@article_id:323235)（Moore machine）**——之间的根本区别。它们都是有输出的[有限状态机](@article_id:323352)（FSMs），是构成数字逻辑、编译器和无数其他系统的抽象计算机基石。然而，它们的运作哲学却有微妙的不同。

### 核心区别：过程 vs. 终点

核心区别在于输出是“如何”以及“何时”产生的。

**[米利机](@article_id:323448)**，就像我们的第一台自动售货机，其输出基于其**当前状态**和**当前输入**。输出与从一个状态到另一个状态的“转换”（过程）相关联。如果我们说机器处于状态 $s$ 并接收到输入 $X$，其输出 $Z$ 是两者的函数：$Z = \lambda(s, X)$。想象一个设计用于检测二进制序列 `101` 的简单电路。该检测器的[米利机](@article_id:323448)版本会在序列的最后一个 `1` 到达的确切时刻输出一个 `1`，但前提是其内部状态记得刚刚看到了 `10`。输出是一个短暂的事件，是由特定位置（状态）和特定事件（输入）的组合产生的火花 [@problem_id:1935261]。

**[摩尔机](@article_id:323235)**，就像我们的第二台自动售货机，则更为“稳重”。其输出“仅”由其**当前状态**决定。输出是“终点”（状态）的一个属性。无论你如何到达一个状态，其输出总是相同的。我们可以将其写为 $Z = \lambda(s)$。在我们的 `101` [序列检测器](@article_id:324798)中，[摩尔机](@article_id:323235)版本会在接收到完整序列“后”进入一个特殊的“检测”状态。只要机器保持在该状态，其输出就是 `1`。输出是稳定的，并与位置本身绑定 [@problem_id:1935261]。

在实际应用中，比如查看工程师的设计表时，你如何区分它们呢？这非常简单。[摩尔机](@article_id:323235)的[状态表](@article_id:323531)会有一个单独的输出列；每个状态都精确地关联一个输出，无论输入是什么 [@problem_id:1962877]。对于[米利机](@article_id:323448)，输出是为每个“转换”指定的，所以你通常会看到输出与每个可能输入的下一状态并列。如果对于同一个当前状态，不同的输入导致不同的输出，那么你看到的就是一台[米利机](@article_id:323448) [@problem_id:1962893]。

这个根本区别导致了一个有趣的附带效应。如果你向两台机器输入一个长度为 $k$ 的输入字符串，输出字符串会有多长？[米利机](@article_id:323448)执行 $k$ 次转换，每次产生一个输出，因此其输出字符串的长度为 $k$。但[摩尔机](@article_id:323235)有点不同。在看到任何输入“之前”，它就已经处于一个初始状态，而这个状态本身就有一个输出！它会产生一个初始输出，然后在其处理的 $k$ 个输入中，每个输入再产生一个输出。因此，对于长度为 $k$ 的输入，[摩尔机](@article_id:323235)产生一个长度为 $k+1$ 的输出字符串 [@problem_id:1386390] [@problem_id:1370720]。这是一个虽小但能说明其不同哲学的标志。

让我们通过一个例子来追踪这个过程。想象一个数字密码锁试图识别密码 `121`。这是[米利机](@article_id:323448)的完美工作。
- 从状态 $S_{locked}$ 开始。输入是 `1`。机器发出一声确认蜂鸣（`output=1`）并转移到状态 $S_{first}$。
- 现在在 $S_{first}$，输入是 `2`。又一声确认蜂鸣（`output=1`），并转移到 $S_{second}$。
- 在 $S_{second}$，输入是 `1`。播放解锁音效（`output=2`），并转移到 $S_{unlocked}$。
- 假设下一个输入是 `0`。锁重新上锁，转换回 $S_{locked}$ 并发出错误蜂鸣（`output=3`）。
输出序列是与输入[同步](@article_id:339180)一步步生成的，是每个（状态，输入）对的直接结果 [@problem_id:1370721]。

### 通用语言：等价性与转换

有着如此不同的工作原理，人们可能会认为[米利机](@article_id:323448)和[摩尔机](@article_id:323235)生活在不同的世界里。但在这里，我们发现了一个美妙的统一之处：它们在计算上是等价的。任何[米利机](@article_id:323448)能做的事，[摩尔机](@article_id:323235)也能做，反之亦然（只是输出有一个时间步的偏移）。我们甚至可以将一种机器翻译成另一种。

你将如何把[米利机](@article_id:323448)转换为[摩尔机](@article_id:323235)呢？这正是“状态”本质被揭示的地方。一个[摩尔机](@article_id:323235)的状态必须包含确定其输出所需的所有信息。[米利机](@article_id:323448)的输出取决于 `(状态, 输入)`。因此，技巧是创建新的[摩尔机](@article_id:323235)状态，这些新状态不仅编码了原始[米利机](@article_id:323448)的位置，还编码了“导致”它进入该状态的转换所产生的输出。

假设一个[米利机](@article_id:323448)有一个状态 $s_1$。如果你可以通过一个输出 `0` 的转换到达 $s_1$（例如，从 $s_0$ 输入 `1`），也可以通过另一个输出 `1` 的转换到达（例如，从 $s_2$ 输入 `0`），那么对于[摩尔机](@article_id:323235)来说这就成了一个问题。状态 $s_1$ 不能同时有两个不同的输出！解决方案很巧妙：我们“分裂”这个状态。我们创建两个新的[摩尔机](@article_id:323235)状态：$(s_1, 0)$ 和 $(s_1, 1)$。状态 $(s_1, 0)$ 的输出为 `0`，状态 $(s_1, 1)$ 的输出为 `1`。这个[摩尔机](@article_id:323235)的状态名副其实地记住了它被创建时的上下文 [@problem_id:1370705]。

这揭示了一个有趣的权衡。虽然两种模型在能力上是等价的，但将一个有 $n$ 个状态的[米利机](@article_id:323448)转换为[摩尔机](@article_id:323235)，可能会导致[摩尔机](@article_id:323235)有更多的状态——可能多达 $n$ 乘以可能输出符号的数量。这是因为每个原始状态可能需要被分裂成几个新状态，每个可能导致它的输出都对应一个 [@problem_id:1370711]。这是在机器语言中优雅表达的经典[时空权衡](@article_id:640938)。

### 简约的艺术：发现本质

如果我们能用100个状态的机器完成一项工作，但存在一个等价的、只有10个状态的机器，哪个更好？当然是更简单的那个。它建造成本更低，更容易理解，也不易出错。这就引出了**[状态最小化](@article_id:336923)**这门至关重要的艺术。我们如何为给定的任务找到可能最小的机器？

秘诀在于提问：哪些状态是真正不同的？答案非常务实：只有当存在某个输入字符串能够使它们产生不同的输出时，两个状态才是不同的。如果没有任何输入字符串，无论多长，能揭示它们未来行为的差异，那么在所有实际目的上，它们都是相同的。我们称它们为**等价的**。

我们可以使用一个称为划分优化的巧妙迭代过程来找到这些等价状态。
1.  **第0步（0-等价）：** 首先，将明显相似的状态分组：那些具有相同输出的状态。这构成了我们的初始划分 $P_0$。任何输出不同的状态都绝对不等价。
2.  **第k步（k-等价）：** 现在，我们进行优化。我们说两个状态是 $(k)$-等价的，如果它们是 $(k-1)$-等价的，并且对于每一个输入符号，它们的转换都指向同样属于 $(k-1)$-等价状态的同一个组。如果一个组中的两个状态在某个输入下指向了不同的组，那么它们必须被分开。我们持续这个过程，直到某个划分不再改变。这个稳定的划分就给出了状态的等价类。

让我们想象两个状态，$s_0$ 和 $s_1$。假设它们是2-等价的，意味着长度为2或更短的输入字符串无法区分它们。但长度为3的字符串，比如 `100` 呢？如果我们从 $s_0$ 开始并处理 `100`，我们可能得到最终输出 `E`（'Error'）。但从 $s_1$ 开始处理相同的字符串 `100` 可能得到最终输出 `G`（'Grante[d'](@article_id:368251)）。啊哈！字符串 `100` 是一个区分字符串。它证明了 $s_0$ 和 $s_1$ 并非真正等价，尽管对于更短的输入它们看起来一样 [@problem_id:1370740]。最终的稳定划分将所有无法区分的状态分在一组，每个组都可以在我们的新的、最小化的机器中合并成一个单一状态。

### 最后的[升华](@article_id:299454)：抽象的力量

这里有一个最后的美丽转折。标准最小化[算法](@article_id:331821)坚持认为，要使两个[状态等价](@article_id:325040)，它们的输出序列对于任何输入都必须是“完全相同”的。但如果我们不需要它们完全相同，只需要“相似”呢？

想象一个输出字母表 $\{a, b, c, d\}$，但出于我们的目的，我们认为输出 $a$ 和 $c$ 是同一“类型”（比如，“警告”），而 $b$ 和 $d$ 是另一类型（“正常”）。我们可以在输出上定义一个等价关系 $\equiv$，其中 $a \equiv c$ 和 $b \equiv d$。现在我们可以问一个更深刻的问题：我们能基于这种“广义”的不可区分性来最小化机器吗？如果两个状态产生的输出序列在我们的新规则下总是逐点等价的，那么它们就被认为是等价的。

惊人的答案是肯定的，而且方法几乎完全相同！划分[优化算法](@article_id:308254)仍然完美适用。唯一改变的是第一步。我们不再是把具有相同输出的状态分组，而是把其输出根据我们的新规则 $\equiv$ 是“等价”的状态分组。其余的优化过程——检查转换和分裂组——与之前完全一样。从一个包含“警告”输出状态和“正常”输出状态的初始划分开始，[算法](@article_id:331821)会继续运行，并交付出尊重我们对行为等价性抽象定义的最小化机器 [@problem_id:1370706]。

这正是数学在科学和工程中的真正魔力。一个清晰、强大的思想——比如划分优化——不仅仅是一招鲜。其底层逻辑是如此基础，以至于可以被推广来解决更广泛、更抽象的一类问题。从两台自动售货机的简单[二分法](@article_id:301259)，我们已经走到了一个抽象原则，它揭示了支配计算世界的深层、统一的结构。