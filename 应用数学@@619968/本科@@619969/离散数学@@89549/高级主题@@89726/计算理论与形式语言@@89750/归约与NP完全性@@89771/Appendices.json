{"hands_on_practices": [{"introduction": "掌握归约思想的最佳方式之一就是亲身实践。许多NP完全问题本质上是同一枚硬币的两面，理解它们之间的对偶关系是掌握归约技巧的关键。本练习将探讨图论中一对最经典的问题：独立集（INDEPENDENT-SET）和团（CLIQUE），通过这个练习，你将学会如何通过一个巧妙的图变换（构造补图），使用一个问题的求解器来解决另一个看似不同的问题，从而深刻体会“将一个问题重构为另一个问题”的归约核心思想。[@problem_id:1395778]", "problem": "在计算复杂性理论中，判定问题通常通过将它们相互关联来进行研究。考虑图论中关于一个简单无向图 $G = (V, E)$ 的以下两个基本问题，其中 $V$ 是顶点集，$E$ 是边集。\n\n1.  **独立集问题 (INDEPENDENT-SET Problem)**：给定一个图 $G$ 和一个正整数 $k$，是否存在一个大小至少为 $k$ 的顶点子集 $S \\subseteq V$，使得对于 $S$ 中任意两个不同的顶点 $u, v \\in S$，边 $(u, v)$ 都不在 $E$ 中？这样的集合 $S$ 称为独立集。\n\n2.  **团问题 (CLIQUE Problem)**：给定一个图 $G$ 和一个正整数 $k$，是否存在一个大小至少为 $k$ 的顶点子集 $C \\subseteq V$，使得对于 $C$ 中任意两个不同的顶点 $u, v \\in C$，边 $(u, v)$ 都在 $E$ 中？这样的集合 $C$ 称为团。\n\n假设你有一个假设的、能用多项式时间解决团问题的超快速“黑箱”算法。你现在的任务是为一个特定的图（我们称之为 $G_{IS}$）解决一个独立集问题的实例。图 $G_{IS}$ 有 75 个顶点。你的目标是确定 $G_{IS}$ 是否包含一个大小至少为 18 的独立集。\n\n为了解决这个问题，你可以构建一个新图（称之为 $G'$），并向你的团问题求解器提出一个关于这个新图的单一问题。这个问题的形式是询问 $G'$ 是否包含一个特定大小的团。\n\n对于这个问题，回想一下，一个图 $G=(V, E)$ 的补图，记作 $\\bar{G}$，是具有相同顶点集 $V$ 的图，其中边 $(u,v)$ 存在当且仅当它在 $G$ 中不存在。\n\n为了解决 $G_{IS}$ 上的原始独立集问题，以下哪个选项描述了正确的图 $G'$ 和要查询的团的正确大小？\n\nA. $G'$ 与 $G_{IS}$ 是同一个图，你应该询问是否存在大小为 18 的团。\n\nB. $G'$ 是 $G_{IS}$ 的补图，你应该询问是否存在大小为 $75 - 18 = 57$ 的团。\n\nC. $G'$ 与 $G_{IS}$ 是同一个图，你应该询问是否存在大小为 $75 - 18 = 57$ 的团。\n\nD. $G'$ 是 $G_{IS}$ 的补图，你应该询问是否存在大小为 18 的团。\n\nE. 使用团问题的求解器不可能解决独立集问题。", "solution": "目标是使用团问题的求解器，来确定一个图 $G_{IS} = (V, E_{IS})$ 是否拥有一个大小至少为 $k_{IS}$ 的独立集。已知 $|V|=75$ 且 $k_{IS}=18$。\n\n让我们分析一下图 $G$ 中的独立集与其补图 $\\bar{G}$ 中的团之间的关系。\n\n设 $G = (V, E)$ 是一个图。其补图为 $\\bar{G} = (V, \\bar{E})$，其中 $\\bar{E}$ 是所有满足 $\\{u, v\\} \\notin E$ 的不同顶点对 $\\{u, v\\}$ 的集合。\n\n根据定义，$G$ 中的独立集是一个顶点子集 $S \\subseteq V$，使得对于 $S$ 中任意一对不同的顶点 $u, v \\in S$，边 $(u, v)$ 都**不**在 $E$ 中。\n\n根据定义，$\\bar{G}$ 中的团是一个顶点子集 $C \\subseteq V$，使得对于 $C$ 中任意一对不同的顶点 $u, v \\in C$，边 $(u, v)$ **都**在 $\\bar{E}$ 中。\n\n现在，我们将这两个定义联系起来。根据补图 $\\bar{G}$ 的定义，边 $(u, v)$ 在 $\\bar{E}$ 中当且仅当边 $(u, v)$ 不在 $E$ 中。\n\n因此，条件“对于 $C$ 中任意一对不同的顶点 $u, v \\in C$，边 $(u, v)$ 都在 $\\bar{E}$ 中”（$C$ 是 $\\bar{G}$ 中团的定义）完全等价于条件“对于 $C$ 中任意一对不同的顶点 $u, v \\in C$，边 $(u, v)$ 都不在 $E$ 中”（$C$ 是 $G$ 中独立集的定义）。\n\n这就建立了一个直接的等价关系：一个顶点子集 $S$ 是图 $G$ 中的一个独立集，当且仅当 $S$ 是其补图 $\\bar{G}$ 中的一个团。\n\n因此，一个图 $G$ 拥有大小至少为 $k$ 的独立集，当且仅当其补图 $\\bar{G}$ 拥有大小至少为 $k$ 的团。\n\n在我们具体的问题中，我们要确定图 $G_{IS}$ 是否有一个大小至少为 $k_{IS}=18$ 的独立集。基于上述推理，这等价于询问 $G_{IS}$ 的补图（我们称之为 $\\bar{G}_{IS}$）是否有一个大小至少为 18 的团。\n\n所以，要使用我们的团问题求解器，我们必须执行以下步骤：\n1.  构建 $G_{IS}$ 的补图。这将是我们的图 $G'$。因此，$G' = \\bar{G}_{IS}$。顶点数量仍为 75。\n2.  用图 $G'$ 和大小 $k=18$ 来查询团问题求解器。求解器将告诉我们 $G'$ 是否有大小至少为 18 的团。\n\n如果求解器返回 TRUE，则 $\\bar{G}_{IS}$ 有一个大小至少为 18 的团，这意味着 $G_{IS}$ 有一个大小至少为 18 的独立集。如果返回 FALSE，则 $G_{IS}$ 没有。\n\n让我们评估给出的选项：\nA. $G'$ 与 $G_{IS}$ 是同一个图，你应该询问是否存在大小为 18 的团。这是不正确的。这将测试 $G_{IS}$ 本身是否有一个大小为 18 的团，而不是独立集。\nB. $G'$ 是 $G_{IS}$ 的补图，你应该询问是否存在大小为 $75 - 18 = 57$ 的团。这是不正确的。补图中的团的大小与原图中独立集的大小相同。大小 57 与顶点覆盖问题有关，而不是以这种直接的方式与独立集问题相关。\nC. $G'$ 与 $G_{IS}$ 是同一个图，你应该询问是否存在大小为 $75 - 18 = 57$ 的团。这因两个原因而不正确：它使用了错误的图和错误的规模。\nD. $G'$ 是 $G_{IS}$ 的补图，你应该询问是否存在大小为 18 的团。这是正确的步骤。要查询的图是原图的补图，并且大小参数与所期望的独立集大小保持一致。\nE. 使用团问题的求解器不可能解决独立集问题。这是不正确的，因为我们刚刚描述了一个有效的多项式时间归约。\n\n因此，正确的做法如选项 D 所述。", "answer": "$$\\boxed{D}$$", "id": "1395778"}, {"introduction": "布尔可满足性问题（SAT）在NP完全理论中扮演着基石的角色，因为许多其他NP问题都可以被“翻译”或“编码”成SAT的形式。本练习将带你完成一个具体的编码过程：将一个经典的图着色（k-Coloring）问题的所有约束条件，系统地转化为一个等价的布尔逻辑公式。这项技能不仅在理论计算机科学中至关重要，在自动化验证、人工智能等应用领域也极为实用，它让你能够将任何NP问题转化为一个通用的SAT求解器可以处理的格式。[@problem_id:1395817]", "problem": "一个研究团队正在开发一个“图到逻辑编译器”，旨在将图着色问题转换为布尔可满足性 (SAT) 问题的实例。该编译器接受一个具有 $n = |V|$ 个顶点和 $m = |E|$ 条边的简单无向图 $G=(V, E)$，以及一个代表可用颜色数量的整数 $k > 1$。然后它会生成一个合取范式 (CNF) 的布尔公式 $\\phi$，该公式是多个子句的逻辑与，其中每个子句是文字的逻辑或。该公式的构造方式使得其可满足当且仅当图 $G$ 可以用 $k$ 种颜色进行着色。\n\n编译器为每个顶点 $v_i \\in V$（索引从 $i=1$ 到 $n$）和每种颜色 $c \\in \\{1, \\dots, k\\}$ 生成变量 $x_{i,c}$。赋值 $x_{i,c} = \\text{True}$ 被解释为“顶点 $v_i$ 被赋予颜色 $c$”。\n\n公式 $\\phi$ 是由以下三条规则派生出的子句的合取：\n1.  **顶点着色规则**：对于每个顶点 $v_i$，生成一个子句。该子句确保顶点被赋予至少一种颜色，它由该顶点的所有可能颜色赋值变量的析取（或）组成。\n2.  **颜色唯一性规则**：对于每个顶点 $v_i$ 和每一对不同的颜色 $\\{c_1, c_2\\}$，生成一个子句。该子句确保该顶点不能同时被赋予两种颜色。\n3.  **边约束规则**：对于每条边 $(v_i, v_j) \\in E$ 和每种颜色 $c$，生成一个子句。该子句确保两个相邻的顶点 $v_i$ 和 $v_j$ 不被赋予相同的颜色 $c$。\n\n考虑轮图 $W_5$。该图由一个中心毂顶点连接到一个 5-环的所有顶点而形成。它总共有 6 个顶点和 10 条边。编译器被用来转换该图的 4-着色问题，因此我们有 $k=4$。\n\n计算编译器为具有 $k=4$ 种颜色的图 $W_5$ 生成的布尔公式 $\\phi$ 中的子句总数。", "solution": "我们使用组合推理，按规则计算子句数量。\n\n设 $n=|V|$ 为顶点数，$m=|E|$ 为边数，$k$ 为颜色数。编译器为每个 $i \\in \\{1,\\dots,n\\}$ 和 $c \\in \\{1,\\dots,k\\}$ 生成布尔变量 $x_{i,c}$。\n\n- 顶点着色规则：对于每个顶点 $v_{i}$，一个子句强制其至少有一种颜色：\n$$\n(x_{i,1} \\lor x_{i,2} \\lor \\dots \\lor x_{i,k}).\n$$\n这产生 $n$ 个子句。\n\n- 颜色唯一性规则：对于每个顶点 $v_{i}$ 和每一对无序的不同颜色 $\\{c_{1},c_{2}\\}$，一个子句\n$$\n(\\lnot x_{i,c_{1}} \\lor \\lnot x_{i,c_{2}})\n$$\n防止同时分配两种颜色。每个顶点有 $\\binom{k}{2}$ 对这样的颜色对，因此总共有 $n \\binom{k}{2}$ 个子句。\n\n- 边约束规则：对于每条边 $(v_{i},v_{j}) \\in E$ 和每种颜色 $c$，一个子句\n$$\n(\\lnot x_{i,c} \\lor \\lnot x_{j,c})\n$$\n防止相邻顶点共享颜色 $c$。这产生 $m k$ 个子句。\n\n因此，子句的总数是\n$$\nC_{\\text{total}} \\;=\\; n \\;+\\; n \\binom{k}{2} \\;+\\; m k.\n$$\n\n对于问题中定义的轮图 $W_{5}$，有 $n=6$ 个顶点和 $m=10$ 条边，我们使用 $k=4$ 种颜色。代入公式，\n$$\nC_{\\text{total}} \\;=\\; 6 \\;+\\; 6 \\binom{4}{2} \\;+\\; 10 \\cdot 4\n\\;=\\; 6 \\;+\\; 6 \\cdot 6 \\;+\\; 40\n\\;=\\; 6 \\;+\\; 36 \\;+\\; 40\n\\;=\\; 82.\n$$", "answer": "$$\\boxed{82}$$", "id": "1395817"}, {"introduction": "在计算复杂性中，我们通常区分两种问题：判定问题（回答“是/否”，例如：是否存在一个解？）和搜索问题（“找到一个解”）。这个练习是一个引人入胜的思想实验：假设你拥有一个神奇的“神谕机”，它只能判定一个布尔公式是否可满足，却不能告诉你具体的解，你该如何利用这个设备来找到一个实际的满足赋值？这项被称为“自归约”（self-reduction）的技术揭示了“知道解存在”与“找到解”之间的深刻联系，是理解NP完备性理论内涵的绝佳实践。[@problem_id:1395818]", "problem": "假设你是一家尖端科技公司的工程师，该公司刚刚研制出一种革命性设备的原型：“SAT谕示机” (SAT-Oracle)。该设备可以接受任何合取范式 (CNF) 的布尔公式，并在多项式时间内确定其是否可满足。该谕示机的输出是二进制的：如果至少存在一组变量真值赋值能使整个公式为真，则返回 `1`，否则返回 `0`。然而，该谕示机本身并 **不** 提供一个可满足赋值。\n\n你的任务是设计一个作为该谕示机软件包装器的高级算法。该算法必须接受任何具有 $n$ 个不同变量（$x_1, x_2, \\dots, x_n$）的 CNF 布尔公式 $\\phi$ 作为输入。如果 $\\phi$ 是可满足的，你的算法必须输出一个完整的可满足真值赋值。如果 $\\phi$ 是不可满足的，它应报告这一事实。\n\n考虑到与使用成本高昂的SAT谕示机交互的效率，对于一个有 $n$ 个变量的公式，在最坏情况下，找到一个可满足赋值或确定不存在赋值，所需谕示机的确切调用次数是多少？\n\nA. $n$\n\nB. $2n$\n\nC. $n+1$\n\nD. $n^2$\n\nE. $2^n$\n\nF. $1$", "solution": "该问题要求设计一个算法，使用布尔可满足性（SAT）问题的判定谕示机来找到一个可满足赋值（这是一个搜索问题）。这是自规约的一个经典例子。设给定的布尔公式为 $\\phi$，其变量为 $\\{x_1, x_2, \\dots, x_n\\}$。该谕示机（我们称之为 `is_SAT(formula)`）在`formula`可满足时返回 `1`，否则返回 `0`。\n\n我们的算法必须处理两种可能性：输入的公式 $\\phi$ 可能是可满足的，也可能是不可满足的。\n\n**步骤 1：初始可满足性检查**\n首先，我们必须确定解是否存在。我们用原始公式 $\\phi$ 对谕示机进行第一次调用。\n$$ \\text{调用 1: } \\text{is\\_SAT}(\\phi) $$\n如果 `is_SAT}(\\phi)` 返回 `0`，我们知道该公式是不可满足的。算法可以立即终止并报告这一事实。这种情况仅使用一次谕示机调用。\n\n如果 `is_SAT}(\\phi)` 返回 `1`，我们知道该公式是可满足的，并且我们必须继续寻找一个赋值。算法的这一分支将代表调用次数的最坏情况。\n\n**步骤 2：迭代确定变量赋值**\n既然我们知道存在一个可满足赋值，我们就可以从 $x_1$ 到 $x_n$ 逐一确定每个变量的值。\n\n让我们从变量 $x_1$ 开始。我们想知道是否存在一个 $x_1$ 为真的可满足赋值。为了测试这一点，我们通过将 $\\phi$ 与文字 $x_1$ 进行合取，创建一个新公式 $\\phi_1$。在 CNF 中，这相当于向公式 $\\phi$ 添加一个新的子句 `(x_1)`。\n$$ \\phi_1 = \\phi \\land x_1 $$\n然后我们询问谕示机这个新公式是否可满足。\n$$ \\text{调用 2: } \\text{is\\_SAT}(\\phi_1) $$\n\n有两种可能的结果：\n- 如果 `is_SAT}(\\phi_1)` 返回 `1`：这意味着存在一个 $\\phi$ 的可满足赋值，其中 $x_1 = \\text{真 (true)}$。我们可以确定这个赋值。我们将 $x_1$ 固定为真，并将我们的工作公式更新为 $\\phi_1$。现在问题被归约为在 $\\phi_1$ 的上下文中为其余变量寻找一个可满足赋值。\n- 如果 `is_SAT}(\\phi_1)` 返回 `0`：这意味着不存在 $\\phi$ 的可满足赋值，其中 $x_1 = \\text{真 (true)}$。由于我们从步骤 1 中知道 $\\phi$ *是*可满足的，因此逻辑上可以推断，在 $\\phi$ 的*每一个*可满足赋值中，$x_1$ 都必须为 `假 (false)`。因此，我们将 $x_1$ 固定为假，并将我们的工作公式更新为 $\\phi_0 = \\phi \\land \\neg x_1$。我们确切地知道 $\\phi_0$ 是可满足的。\n\n无论哪种情况，一次谕示机调用就足以确定 $x_1$ 的正确真值。\n\n**步骤 3：泛化与重复**\n我们对剩余的变量重复此过程。对于第二个变量 $x_2$，我们采用当前的工作公式（即上一步中的 $\\phi_1$ 或 $\\phi_0$，我们称之为 $\\phi'$）并测试赋值 $x_2 = \\text{真 (true)}$。我们构建公式 $\\phi'' = \\phi' \\land x_2$ 并进行下一次谕示机调用。\n$$ \\text{调用 3: } \\text{is\\_SAT}(\\phi'') $$\n根据结果，我们固定 $x_2$ 的值并再次更新工作公式。\n\n我们对所有 $n$ 个变量（从 $x_1$ 到 $x_n$）继续此过程。对于每个变量 $x_i$，我们都执行一次谕示机调用来决定其值。\n\n**步骤 4：计算调用次数**\n让我们统计一下最坏情况（即公式可满足时）下谕示机调用的总次数：\n- 一次初始调用，检查原始公式 $\\phi$ 的可满足性。\n- 对 $n$ 个变量中的每一个进行一次调用，以确定其真值。\n\n总调用次数 = $1 \\text{ (用于初始检查)} + n \\text{ (每个变量一次)} = n+1$。\n\n经过 $n+1$ 次调用后，我们将确定所有变量 $x_1, \\dots, x_n$ 的真值，这些真值构成一个可满足赋值。这是最坏情况下的调用次数，因为不可满足的公式情况仅需 1 次调用。因此，所需调用次数的最紧上界是 $n+1$。", "answer": "$$\\boxed{C}$$", "id": "1395818"}]}