{"hands_on_practices": [{"introduction": "本练习探讨了一种简单的计算模型——有限状态自动机——与图灵机之间的根本区别。通过分析前者无法识别的一种语言，我们将精确地指出内存是赋予图灵机其卓越计算能力的关键资源。这是理解丘奇-图灵论题的一个基础概念，它帮助我们理解为何需要像图灵机这样拥有无限记忆能力的模型来定义“算法”的边界。[@problem_id:1405449]", "problem": "在丘奇-图灵论题的背景下，该论题假定图灵机（TM）可以计算任何有算法的函数，我们通常将图灵机与更简单的计算模型进行比较，以理解计算能力的层级。\n\n一位初级软件工程师接到了一个数据验证任务。任务是为字母表 $\\Sigma = \\{0, 1\\}$ 上的语言 $L$ 构建一个识别器。该语言定义为 $L = \\{0^k 1^k \\mid k \\ge 1\\}$，由一个或多个'0'后跟等数量的'1'所构成的所有字符串组成。例如，'01'、'0011'和'000111'属于 $L$，而'011'、'001'和'10'不属于。\n\n该工程师首先尝试使用有限状态自动机（FSA），也称为有限自动机，来实现这个识别器。经过数次尝试，他们得出结论：无法为这个任务构建任何FSA。以下哪个陈述为FSA无法识别语言 $L$ 提供了最根本的原因，从而说明了为什么它是一种比图灵机能力更弱的计算模型？\n\nA. FSA由有限个状态定义。为了识别 $L$，机器必须记住它已经处理过的'0'的确切数量，而这个数量可以是任意大的。FSA的有限状态仅提供有限的内存，不足以完成这个无界计数任务。相比之下，TM可以将其无限长的纸带用作无界内存。\n\nB. 语言 $L$ 是内在地非确定性的，因为 $k$ 的值是事先未知的。标准的确定性FSA无法处理这一点，虽然非确定性有限自动机（NFA）更强大，但只有TM才足够强大，能够解决 $L$ 所需的无界非确定性。\n\nC. FSA的主要局限性在于其读写头只能在输入上单向移动。TM能够成功是因为其读写头是双向的，允许它在'0'块和'1'块之间来回移动以确认它们的数量相等。\n\nD. TM可以识别 $L$ 是因为它能解决针对这个特定语言的停机问题，而FSA不能。无法确定在读取'0'之后是否应该停机是FSA的主要失败点。\n\nE. FSA之所以失败，是因为它无法写入或修改其输入。TM可以解决这个问题，因为它具有写入能力，允许它在将每个'0'与对应的'1'匹配时进行标记，从而跟踪计数。", "solution": "我们通过证明语言 $L=\\{0^{k}1^{k}\\mid k\\ge 1\\}$ 不是正则语言，来形式化地说明有限状态自动机（FSA）的局限性，这意味着没有FSA能识别它。设 $M=(Q,\\Sigma,\\delta,q_{0},F)$ 是在 $\\Sigma=\\{0,1\\}$ 上的任意一个FSA，其状态数为 $|Q|=n$。考虑字符串 $w=0^{n}1^{n}\\in L$。当 $M$ 读取前 $n$ 个符号 $0^{n}$ 时，它会经历 $n+1$ 个状态（包括读取任何符号之前的起始状态），因此根据鸽巢原理，存在索引 $0\\le i<j\\le n$，使得读取 $0^{i}$ 后达到的状态与读取 $0^{j}$ 后达到的状态相同。设 $p=j-i>0$。那么，对于任何整数 $t\\ge 0$，在处理形如 $0^{i}(0^{p})^{t}0^{n-j}1^{n}$ 的字符串时，其计算在处理完0字符串块后所达到的状态，将与处理 $w$ 时完全相同，因此在处理结尾的 $1^{n}$ 时也将遵循相同的状态转移。特别地，如果 $w$ 被接受，那么\n$$\nw_{0}=0^{i}(0^{p})^{0}0^{n-j}1^{n}=0^{n-p}1^{n}\n$$\n也应被接受。但是 $0^{n-p}1^{n}\\notin L$，因为它拥有的'0'少于'1'。这个矛盾表明没有FSA能精确地接受 $L$，即 $L$ 不是正则语言。\n\n这个证明所揭示的根本原因是，识别 $L$ 需要记住一个无界的'0'的数量，以便与'1'的数量进行比较，而FSA只有有限个状态，因而只有有限的内存，不足以进行无界计数。相比之下，图灵机（TM）可以利用其无限长的纸带存储任意大的计数，因此可以识别 $L$。\n\n因此，在给定的陈述中，最根本且正确的原因是FSA只有有限的内存，无法执行无界计数，而TM可以；这对应于选项A。其他选项不正确的原因如下：非确定性（选项B）并不增加对正则语言的处理能力，因为确定性有限自动机（DFA）和非确定性有限自动机（NFA）识别同一类语言；读写头方向（选项C）不是根本原因，因为双向有限自动机与单向有限自动机具有相同的计算能力；停机问题（选项D）与识别 $L$ 无关；写能力（选项E）也不是核心问题，因为需要的是无界内存，而不仅仅是写的能力（例如，带有堆栈的下推自动机可以在不写入输入纸带的情况下识别 $L$）。", "answer": "$$\\boxed{A}$$", "id": "1405449"}, {"introduction": "我们能否通过允许一台机器在运行时重写自己的指令来设计出比标准图灵机更强大的机器？本练习将挑战你思考一个标准图灵机（拥有固定程序）如何模拟一台“自我修改”的图灵机。理解这一模拟过程将揭示一个深植于计算核心的深刻原理——程序即数据，这为丘奇-图灵论题所主张的图灵机模型的鲁棒性提供了强有力的证据。[@problem_id:1405429]", "problem": "一家未来计算公司的工程师提出了一种新的理论计算模型，称为自修改图灵机（Self-Modifying Turing Machine, SMTM）。SMTM 类似于标准的图灵机（Turing Machine, TM），但具有一个额外的能力：它可以在执行期间改变自身的转移函数。\n\n具体来说，一台 SMTM $M_{SM}$ 由一个状态集 $Q$、一个输入字母表 $\\Sigma$ 和一个带字母表 $\\Gamma$ 定义。它的单条无限带在概念上被分为两个区域：一个数据区和一个程序区。程序区包含该机器自身转移函数 $\\delta$ 的完整编码。SMTM 的一次转移由其当前状态和从数据区读取的符号决定，并具有以下形式：\n$$ \\delta(q, \\gamma) = (q', \\gamma', D, A) $$\n其中 $q, q' \\in Q$ 是当前状态和下一个状态，$\\gamma, \\gamma' \\in \\Gamma$ 是从数据区读取和写入数据区的符号，$D \\in \\{L, R\\}$ 是读写头在数据区上的移动方向，而 $A$ 是一个特殊的“修改动作”。动作 $A$ 可以是两种类型之一：\n1.  **`NO-OP`**：程序区不发生修改。转移函数保持不变。\n2.  **`MODIFY( (q_s, \\gamma_s), (q_t, \\gamma_t, D_t) )`**：机器在其程序区中找到状态-符号对 $(q_s, \\gamma_s)$ 的规则编码并将其覆盖。新规则变为转移到状态 $q_t$，写入符号 $\\gamma_t$，并向 $D_t$ 方向移动读写头。为简单起见，假定这个新定义的转移具有 `NO-OP` 修改动作。\n\n丘奇-图灵论题（Church-Turing thesis）断言，任何能由算法过程计算的函数都可以由一台标准图灵机计算。要检验 SMTM 模型是否对该论题构成挑战，必须确定它是否能计算标准图灵机无法计算的函数。这通常通过展示一台标准的、具有固定程序的图灵机（我们称之为 $M_{standard}$）如何模拟任何给定 SMTM 的行为来完成。\n\n假设您的任务是描述这样一种模拟。$M_{standard}$ 机器将使用其自身的带来追踪 SMTM 的整个配置，包括 SMTM 的数据区、程序区及其当前状态。\n\n下列哪个陈述最能描述允许一台具有固定转移函数的标准图灵机成功模拟自修改图灵机的核心原理？\n\nA. 每当 SMTM 修改其转移函数时，标准图灵机就停止运行，并由操作员手动重新编程，从而有效地创建一系列不同的图灵机来反映 SMTM 的演变。\n\nB. 标准图灵机对 SMTM 的每个未来转移函数使用非确定性的“猜测”，如果至少有一条猜测的计算路径与 SMTM 的实际演变相匹配，则该计算被认为是成功的。\n\nC. 标准图灵机将 SMTM 的转移函数视为存储在其自身带上的数据。当 SMTM 执行 `MODIFY` 动作时，标准图灵机会执行标准的数据写入操作来更新其带上的此表示，然后再模拟下一步。\n\nD. 只有当 SMTM 被限制在有限的、预定次数的自修改内时，模拟才可能实现。一个能够在执行过程中进行无限次修改的 SMTM 无法由标准图灵机模拟。\n\nE. 模拟要求标准图灵机有一个特殊的“元带”，该带在物理上与其数据带分离，并且普通的读/写操作无法访问，专门用于存储 SMTM 的程序。", "solution": "我们将一台标准图灵机（表示为 $M_{standard}$）对一台具有转移关系 $\\delta$ 的自修改图灵机 $M_{SM}$ 的模拟过程形式化。关键的观察是，通用图灵机将机器的描述解释为数据；因此，$M_{SM}$ 程序的任何变化都可以通过 $M_{standard}$ 在其自身带上维护的数据的相应变化来反映。\n\n首先，我们将 $M_{SM}$ 在步骤 $t$ 的完整配置定义为 $C_{t}=(q_{t},T^{data}_{t},T^{prog}_{t},h^{data}_{t})$，其中 $q_{t}\\in Q$ 是当前状态，$T^{data}_{t}$ 编码了数据区的内容，$T^{prog}_{t}$ 编码了 $M_{SM}$ 的当前转移表，$h^{data}_{t}$ 编码了数据区中的读写头位置。在每个模拟步骤 $t$，$M_{standard}$ 机器在其自身的带上维护 $C_{t}$ 的显式编码。\n\n为了模拟一次转移，$M_{standard}$ 执行以下确定性解释过程：\n1. 它读取编码的数据读写头下的符号 $\\gamma$ 和当前状态 $q_{t}$。\n2. 它在编码的 $T^{prog}_{t}$ 中搜索与 $(q_{t},\\gamma)$ 对应的规则，得到 $(q',\\gamma',D,A)=\\delta(q_{t},\\gamma)$。\n3. 它通过在编码的读写头位置写入 $\\gamma'$ 来更新编码的数据区，根据 $D$ 移动编码的读写头位置，并将编码的状态设置为 $q'$。\n\n关键地，对修改动作 $A$ 的处理是通过在 $M_{standard}$ 的带上进行普通的数据操作来实现的：\n- 如果 $A$ 是 NO-OP，则 $T^{prog}_{t+1}=T^{prog}_{t}$，并且 $M_{standard}$ 使用更新后的配置编码进入下一个模拟步骤。\n- 如果 $A$ 是 $\\operatorname{MODIFY}\\big((q_{s},\\gamma_{s}),(q_{targ},\\gamma_{targ},D_{targ})\\big)$，$M_{standard}$ 会在其带上 $T^{prog}_{t}$ 的编码中搜索键为 $(q_{s},\\gamma_{s})$ 的规则，并用新的右侧 $(q_{targ},\\gamma_{targ},D_{targ})$ 覆盖该编码规则，按照约定在编码中将其动作设置为 NO-OP。这是对编码程序的数据进行的一次标准写入操作。结果是一个新的程序编码 $T^{prog}_{t+1}$。\n\n因为每次修改都是对带上有限部分的局部重写，$M_{standard}$ 可以在其计算过程中随时间执行任何有限或可数无限序列的此类修改。不需要非确定性，不需要对 $M_{standard}$ 进行外部干预或重新编程，也不需要普通工作带之外的特殊元带。这正是通用机原理：程序即数据，解释和更新程序都在具有固定转移函数的标准图灵机的能力范围之内。\n\n因此，实现模拟的核心原理是，$M_{standard}$ 将 SMTM 的转移函数视为其带上的数据，并在 SMTM 执行修改时更新该数据，然后继续确定性地进行逐步模拟。因此，正确的选项是明确阐述了这一原理的陈述。", "answer": "$$\\boxed{C}$$", "id": "1405429"}, {"introduction": "在确立了图灵机的强大功能和鲁棒性之后，我们现在转向它的局限性。本练习介绍了“忙碌的海狸”函数($\\Sigma(n)$)，这是一个定义明确但可被证明是不可计算的问题。通过一个归谬法证明，你将看到这个函数的定义本身如何导向一个逻辑悖论，从而具体地展示出存在算法永远无法解决的问题，这也是丘奇-图灵论题的一个深刻推论。[@problem_id:1405440]", "problem": "丘奇-图灵论题断言，任何可以通过有效过程计算的函数都可以由图灵机计算。该论题的一个关键推论是存在定义良好但不可计算的函数。其中最著名的例子之一是忙碌的海狸函数($\\Sigma(n)$)，它被定义为一个停机的、有 $n$ 个状态、使用 2 个符号（其中一个是空白符）的图灵机在停机前，在初始为空的带子上可以写入的“1”的最大数量。$\\Sigma(n)$ 的不可计算性可以通过反证法来证明。\n\n考虑以下一个图灵机的假设性构造，我们称之为 $M_{paradox}$：\n\n首先，假设存在一个假设的图灵机 $M_{\\Sigma}$，它可以计算忙碌的海狸函数 $\\Sigma(n)$。这个机器 $M_{\\Sigma}$ 从带子上读取一个整数 $n$ 作为输入，在完成计算后，它会停机，并将整数值 $\\Sigma(n)$ 写在带子上。设这个机器 $M_{\\Sigma}$ 的状态数为一个固定常数 $c$。\n\n现在，我们通过将 $M_{\\Sigma}$ 的功能与其他组件相结合来构造机器 $M_{paradox}$。机器 $M_{paradox}$ 被设计为对一个硬编码到其结构中的值 $N$ 进行操作。$M_{paradox}$ 的完整操作序列如下：\n1.  一个子机器 $M_{write}$ 将整数 $N$ 写入带子。该组件需要固定数量的状态 $c_{write}$。\n2.  接着执行机器 $M_{\\Sigma}$（具有 $c$ 个状态），使用带子上的值 $N$ 作为输入来计算 $\\Sigma(N)$。\n3.  最后一个子机器 $M_{increment}$ 从带子上读取值 $\\Sigma(N)$，然后在一个空白的带子区域上总共写入 $\\Sigma(N) + 1$ 个“1”后停机。该组件需要固定数量的状态 $c_{inc}$。\n\n整个机器 $M_{paradox}$ 的总状态数是其各组成部分状态数的总和，所以其状态数为 $N_{total} = c_{write} + c + c_{inc}$。为了制造悖论，操作步骤中使用的硬编码整数 $N$ 被设置为等于 $M_{paradox}$ 自身总状态数。也就是说，我们设置 $N = N_{total}$。给定非预言机组件的额外开销状态总和为 $c_{write} + c_{inc} = 38$。\n\n这种构造——一个具有 $N_{total}$ 个状态、被设计用来写入 $\\Sigma(N_{total}) + 1$ 个“1”的机器——与忙碌的海狸函数的定义本身相比，导致了一个基本矛盾，从而证明了初始假设（$M_{\\Sigma}$ 的存在性）必定是错误的。\n\n以下哪个数学陈述正确地表示了从这个假设性构造中导出的矛盾？\n\nA. $\\Sigma(c+38) + 1 = \\Sigma(c) + \\Sigma(38)$\n\nB. $\\Sigma(c+38) \\le \\Sigma(c) + 38$\n\nC. $c+38 \\le \\Sigma(c+38)$\n\nD. $\\Sigma(c+38) + 1 \\le \\Sigma(c+38)$\n\nE. $\\Sigma(c) + 1 \\le \\Sigma(c)$", "solution": "根据忙碌的海狸函数的定义，对于任何一个从空白带子开始、在停机前写入 $t$ 个“1”的、有 $n$ 个状态、使用 2 个符号的停机图灵机 $M$，都存在基本界限\n$$\nt \\le \\Sigma(n).\n$$\n假设存在一个具有 $c$ 个状态的图灵机 $M_{\\Sigma}$，当给定带子上的输入 $n$ 时，它会停机并在带子上写下 $\\Sigma(n)$。通过组合以下部分来构造 $M_{paradox}$：\n- 一个写入器 $M_{write}$，它使用 $c_{write}$ 个状态将一个硬编码的整数 $N$ 写入带子，\n- 一个具有 $c$ 个状态的预言机 $M_{\\Sigma}$，用于计算 $\\Sigma(N)$，\n- 一个具有 $c_{inc}$ 个状态的增量器 $M_{increment}$，它在一个空白的带子区域上精确地写入 $\\Sigma(N)+1$ 个“1”，然后停机。\n\n$M_{paradox}$ 的总状态数为\n$$\nN_{total} = c_{write} + c + c_{inc}.\n$$\n我们已知 $c_{write} + c_{inc} = 38$，因此\n$$\nN_{total} = c + 38.\n$$\n将硬编码的输入设置为 $N = N_{total}$。那么 $M_{paradox}$ 就是一个有 $N$ 个状态、使用 2 个符号的图灵机，它从空白带子开始，停机，并精确写入 $\\Sigma(N) + 1$ 个“1”。将忙碌的海狸函数的定义界限应用于这个特定的 $N$ 状态停机图灵机，得到\n$$\n\\Sigma(N) + 1 \\le \\Sigma(N),\n$$\n这是一个矛盾。代入 $N = c + 38$ 得到明确的矛盾不等式\n$$\n\\Sigma(c+38) + 1 \\le \\Sigma(c+38).\n$$\n在给定的选项中，这正是陈述 D。", "answer": "$$\\boxed{D}$$", "id": "1405440"}]}