{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能真正内化。本节提供了一系列精心设计的练习，旨在加深你对可判定性和不可判定性核心概念的理解。我们将从一个在编译器设计和静态代码分析中至关重要且可判定的问题开始。这个练习探讨了我们是否能确定一个给定的上下文无关文法（CFG）是否能生成任何字符串，即其语言是否为空 [@problem_id:1361679]。通过解决这个问题，你将亲手构建一个总能停机并给出明确答案的算法，这清晰地展示了即使是处理可能无限的集合（语言），我们也能解决一些根本性的问题。", "problem": "一个计算机科学家团队正在设计一种名为“Aether”的新编程语言。为了帮助开发人员编写更好的代码，他们希望构建一个能够检测“不可达代码”的静态分析工具。在Aether的形式化规约中，该语言的语法由一个上下文无关文法（Context-Free Grammar, CFG）定义。一个CFG被形式化地定义为一个四元组 $G = (V, T, P, S)$，其中：\n- $V$ 是一个非终结符（变量）的有限集合。\n- $T$ 是一个终结符（语言的字母表）的有限集合，与 $V$ 不相交。\n- $P$ 是一个产生式规则的有限集合，其中每条规则的形式为 $A \\to \\alpha$，其中 $A \\in V$ 且 $\\alpha$ 是由来自 $(V \\cup T)^*$ 的符号组成的字符串。\n- $S \\in V$ 是特殊的开始符号。\n\n由该文法生成的语言，记为 $L(G)$，是从开始符号 $S$ 派生出的所有终结符串的集合。\n\n该静态分析工具的一个关键特性是确定由Aether的文法定义的语言是否完全“死”的——也就是说，是否不可能从开始符号生成任何有效的程序（任何终结符串）。用形式化的术语来说，该工具需要对给定的文法 $G$ 判定 $L(G) = \\emptyset$ 是否成立。\n\n该团队需要知道，理论上是否可能创建一个算法，对于任意给定的CFG $G$，该算法总能终止并正确回答 $L(G)$ 是否为空。\n\n下列哪个陈述正确地评估了此问题的可判定性？\n\nA. 是的，它是可判定的。可以构建一个算法，该算法系统地识别所有能够生成终结符串的非终结符，然后检查开始符号是否是其中之一。\n\nB. 不，它是不可判定的。这个问题在计算上等价于停机问题，因为如果文法生成一个无限语言，检查所有从开始符号出发的可能派生过程可能会导致无限循环。\n\nC. 不，它是不可判定的。为了确定语言是否非空，算法将不得不检查无限数量的潜在字符串以查看是否有任何一个可以被生成，这是一项不可能完成的任务。\n\nD. 是的，它是可判定的，但仅当文法不包含任何递归规则（例如，形如 $A \\to \\alpha A \\beta$ 的规则）时。如果存在递归，该问题就变得不可判定。", "solution": "该问题询问是否存在一个算法，可以确定由任意上下文无关文法（CFG）生成的语言 $L(G)$ 是否为空。这被称为上下文无关语言的空性问题。实际上，这个问题是可判定的。让我们描述一个解决该问题的算法。\n\n核心思想是识别出文法中所有“能产的”（productive）非终结符。一个非终结符如果能派生出至少一个完全由终结符组成的字符串，那么它就是能产的。如果开始符号 $S$ 是能产的，则 $L(G)$ 非空。否则，$L(G)$ 为空。\n\n该算法按以下步骤进行：\n\n1.  **初始化**：我们将维护一个已识别为能产的非终结符集合。我们称这个集合为 `ProductiveSymbols`。初始时，`ProductiveSymbols` 为空。\n\n2.  **基本情况**：我们对文法 $G = (V, T, P, S)$ 的所有产生式规则 $P$ 进行一次初始遍历。我们识别所有具有 $A \\to w$ 形式规则的非终结符 $A$，其中 $w$ 是一个完全由来自 $T$ 的终结符组成的字符串（包括空串 $\\epsilon$）。对于每个这样的规则，我们将非终结符 $A$ 添加到我们的 `ProductiveSymbols` 集合中。\n\n3.  **迭代步骤**：我们重复遍历所有产生式规则的集合 $P$。在每次迭代中，对于每个规则 $B \\to \\alpha_1 \\alpha_2 ... \\alpha_k$，我们检查其右侧字符串中的每个符号 $\\alpha_i$ 是否要么是终结符，要么是已经存在于我们 `ProductiveSymbols` 集合中的非终结符。如果这个条件对于左侧为非终结符 $B$ 的规则成立，并且 $B$ 尚不在 `ProductiveSymbols` 中，我们就将 $B$ 添加到 `ProductiveSymbols` 中。\n\n4.  **终止**：我们继续迭代步骤（步骤3），直到对所有产生式规则的完整遍历不再向 `ProductiveSymbols` 中添加任何新的非终结符为止。这个过程保证会终止，因为非终结符集合 $V$ 是有限的，并且在每个修改集合的步骤中，我们至少添加一个非终结符。`ProductiveSymbols` 的大小最多为 $|V|$。\n\n5.  **判定**：一旦算法终止，我们就检查开始符号 $S$ 是否在 `ProductiveSymbols` 集合中。\n    *   如果 $S \\in \\text{ProductiveSymbols}$，这意味着 $S$ 可以派生出一个终结符串，所以 $L(G)$ 非空。\n    *   如果 $S \\notin \\text{ProductiveSymbols}$，这意味着 $S$ 没有任何方法可以派生出一个仅由终结符组成的字符串，所以 $L(G)$ 为空。\n\n既然我们已经描述了一个对于任何CFG都能保证终止并正确回答 $L(G)$ 是否为空问题的算法，那么该问题就是可判定的。\n\n让我们分析一下给出的选项：\n*   **A**：这个选项正确地指出该问题是可判定的，并准确地总结了上述算法的逻辑。\n*   **B**：这个选项是错误的。虽然天真地检查派生过程可能导致无限循环，但这个问题不等价于停机问题。上述算法分析的是文法自身的结构（一个有限对象），而不是模拟无限的派生过程。\n*   **C**：这个选项是错误的。该算法不涉及测试无限数量的字符串，而是直接作用于文法的有限规则集。问题不是“这个字符串是否在该语言中？”，而是“该语言中是否*存在任何*字符串？”。\n*   **D**：这个选项是错误的。递归的存在不会使问题变得不可判定。所描述的算法能正确处理递归规则。对于像 $A \\to aA$ 这样的规则，如果 $A$ 有另一个规则（例如 $A \\to b$）允许它终止，那么 $A$ 就会被标记为能产的。该算法能正确地传播这种“能产性”。\n\n因此，正确的陈述是A。", "answer": "$$\\boxed{A}$$", "id": "1361679"}, {"introduction": "在掌握了如何分析单个问题的可判定性之后，我们来探索当这些问题组合在一起时会发生什么。在计算机科学中，复杂的系统常常由简单的组件组合而成，理解这些组合如何影响系统的基本属性至关重要。这个练习提出了一个深刻的问题：一个可判定语言和一个不可判定语言的交集是可判定的吗 [@problem_id:1361666]？这个问题挑战我们超越简单的“是”或“否”的回答，通过构造具体示例来证明，结果可能是可判定的，也可能是不可判定的，这取决于具体选择的语言。这个过程将极大地锻炼你的逻辑推理和通过构造反例进行证明的能力。", "problem": "在计算理论中，形式语言被定义为在特定字母表 $\\Sigma$ 上的字符串集合。我们关心的是可以被计算模型识别的语言类别。\n\n如果存在一台图灵机，对于任意给定的输入字符串，它总能停机并明确回答该字符串是否属于 $L$，那么语言 $L$ 就被称为 **(图灵)可判定的**。不是可判定的语言则被称为**不可判定的**。\n\n设 $L_D$ 是一个任意的可判定语言，$L_U$ 是一个任意的不可判定语言，两者都定义在同一个字母表 $\\Sigma$ 上。考虑它们的交集，定义为语言 $L_{int} = L_D \\cap L_U$。\n\n关于 $L_{int}$ 的可判定性，以下哪个陈述是正确的？\n\nA. $L_{int}$ 总是可判定的。\n\nB. $L_{int}$ 总是不可判定的。\n\nC. $L_{int}$ 的可判定性取决于 $L_D$ 和 $L_U$ 的具体选择；它既可能是可判定的，也可能是不可判定的。\n\nD. 一个可判定语言和一个不可判定语言的交集不是一个良定义的语言，因此其可判定性无法讨论。\n\nE. $L_{int}$ 是可判定的，当且仅当 $L_D$ 是一个有限语言。", "solution": "该问题要求我们确定一个可判定语言 $L_D$ 和一个不可判定语言 $L_U$ 的交集的可判定性的性质。让我们通过构造实例来分析各种可能性。目标是确定其结果是总是可判定的，总是不可判定的，还是两者皆有可能。\n\n首先，让我们考虑交集 $L_{int} = L_D \\cap L_U$ 是否可以是可判定的。\n为了证明这是可能的，我们需要找到至少一对可判定语言 $L_D$ 和不可判定语言 $L_U$，使得它们的交集是可判定的。\n\n让我们为 $L_D$ 选择一个非常简单的可判定语言。空语言 $L_D = \\emptyset$ 是可判定的。一个用于判定它的图灵机会立即拒绝每个输入字符串，并且它总会停机。所以，$L_D = \\emptyset$ 是可判定的。\n\n现在，设 $L_U$ 为任意一个不可判定语言。一个典型的例子是停机问题语言，通常表示为 $A_{TM}$。$A_{TM}$ 是所有对 $\\langle M, w \\rangle$ 的集合，其中 $M$ 是一台图灵机的编码，$w$ 是一个输入字符串，且 $M$ 在输入 $w$ 上会停机。$A_{TM}$ 是不可判定的，这是可计算性理论中的一个基础性结论。\n\n让我们为这个具体的选择计算交集：\n$$L_{int} = L_D \\cap L_U = \\emptyset \\cap A_{TM} = \\emptyset$$\n得到的语言是空语言 $\\emptyset$。如前所述，空语言是可判定的。因此，我们找到了一个实例，其中可判定语言和不可判定语言的交集是可判定的。这证明了陈述 B“$L_{int}$ 总是不可判定的”是错误的。\n\n接下来，让我们考虑交集 $L_{int} = L_D \\cap L_U$ 是否可以是不可判定的。\n为了证明这是可能的，我们需要找到至少一对可判定语言 $L_D$ 和不可判定语言 $L_U$，使得它们的交集是不可判定的。\n\n让我们为 $L_D$ 选择另一个简单的可判定语言。字母表 $\\Sigma$ 上所有可能字符串的语言，记为 $\\Sigma^*$，是可判定的。一个用于判定它的图灵机会立即接受每个输入字符串，并且它总会停机。所以，$L_D = \\Sigma^*$ 是可判定的。\n\n再次，设 $L_U$ 为不可判定语言 $A_{TM}$。\n\n让我们为这个新的选择计算交集：\n$$L_{int} = L_D \\cap L_U = \\Sigma^* \\cap A_{TM}$$\n由于 $A_{TM}$ 是某个字母表 $\\Sigma$ 上的字符串集合，根据定义，它的所有元素都包含在 $\\Sigma^*$ 内。因此，$A_{TM}$ 与 $\\Sigma^*$ 的交集就是 $A_{TM}$ 本身。\n$$L_{int} = A_{TM}$$\n得到的语言是 $A_{TM}$，我们知道它是不可判定的。因此，我们找到了一个实例，其中可判定语言和不可判定语言的交集是不可判定的。这证明了陈述 A“$L_{int}$ 总是可判定的”是错误的。\n\n既然我们已经证明了一个交集是可判定的案例和另一个交集是不可判定的案例，那么交集的可判定性就不是固定的。它取决于所选择的具体语言 $L_D$ 和 $L_U$。这直接支持了陈述 C。\n\n让我们快速回顾一下其他选项。\n- 陈述 D 是不正确的。两个集合（语言）的交集总是一个良定义的集合（语言）。\n- 陈述 E 是不正确的。在我们的第一个例子中，$L_D = \\emptyset$，它是有限的，其交集是可判定的。在我们的第二个例子中，$L_D = \\Sigma^*$，它是无限的，其交集是不可判定的。这可能暗示了一种模式。然而，考虑 $L_D = \\{ \\langle M, w \\rangle | \\text{编码的符号数量为偶数} \\}$。这是一个无限的可判定语言。它与 $A_{TM}$ 的交集是 $A_{TM}^{\\text{even}} = \\{ \\langle M, w \\rangle \\in A_{TM} | \\text{编码的符号数量为偶数} \\}$。这个语言可以被证明是不可判定的（通过从 $A_{TM}$ 进行归约）。所以一个无限的 $L_D$ 可以导致一个不可判定的交集。但如果我们取同一个无限的 $L_D$ 并将其与 $L_U = \\text{COMPLEMENT}(A_{TM})$ 求交集，该交集也可能是不可判定的。然而，如果我们取 $L_D$ 为所有不以图灵机编码开头的字符串的集合，这是一个无限且可判定的集合，那么 $L_D \\cap A_{TM} = \\emptyset$，而这是可判定的。因此，一个无限的 $L_D$ 并不能保证交集是不可判定的。因此，陈述 E 是错误的。\n\n唯一正确的结论是结果取决于具体的语言。", "answer": "$$\\boxed{C}$$", "id": "1361666"}, {"introduction": "最后，让我们面对一个听起来非常简单直观，但却触及计算理论核心限制的问题。我们能否创建一个通用程序，来判断任何其他程序是否会在其执行过程中打印出特定的短语，比如“Hello, world!” [@problem_id:1361702]？这个问题是停机问题的一个经典变体，它完美地揭示了不可判定性的本质。通过分析这个问题，你将理解“可判定”（decidable）和“图灵可识别”（Turing-recognizable）之间的关键区别——前者要求算法总能停机并给出“是”或“否”的回答，而后者只要求在答案为“是”时能够确认，这为我们理解计算的极限提供了具体而生动的例证。", "problem": "在计算理论中，我们使用图灵机（TM）作为任意计算机程序的形式化模型。语言是一个字符串集合。我们有兴趣通过分析问题对应语言的可计算性属性来对问题的难度进行分类。图灵机 $M$ 的编码表示为字符串 $\\langle M \\rangle$。\n\n考虑以下语言，我们称之为“Hello World”语言 $L_{HW}$：\n$$ L_{HW} = \\{ \\langle M \\rangle \\mid \\text{$M$ is a TM that, when started on a blank input tape, eventually prints \"Hello, world!\"} \\} $$\n这意味着，一个图灵机若要属于语言 $L_{HW}$，它必须在有限步之后，其输出带上包含精确的字符串“Hello, world!”。该图灵机在打印出该字符串后不要求停机。\n\n作为背景，回顾以下标准定义：\n*   如果存在一个图灵机，它在每个输入上都会停机，接受属于该语言的字符串，并拒绝不属于该语言的字符串，那么该语言是**可判定的**。\n*   如果存在一个图灵机，它接受该语言中的所有字符串，那么该语言是**图灵可识别的**。对于不在此语言中的字符串，该机器既可能拒绝，也可能永远循环。\n*   如果一个语言的补集是图灵可识别的，那么该语言是**余-图灵可识别的**。\n\n下列哪个陈述正确地分类了语言 $L_{HW}$？\n\nA. $L_{HW}$ 是可判定的。\n\nB. $L_{HW}$ 是图灵可识别的，但不是可判定的。\n\nC. $L_{HW}$ 是余-图灵可识别的，但不是图灵可识别的。\n\nD. $L_{HW}$ 既不是图灵可识别的，也不是余-图灵可识别的。", "solution": "我们必须确定语言 $L_{HW}=\\{\\langle M\\rangle\\mid \\text{$M$ is a TM that, on blank input, eventually prints \"Hello, world!\"}\\}$ 是可判定的、图灵可识别的、余-图灵可识别的，还是都不是。\n\n首先，我们证明 $L_{HW}$ 是图灵可识别的。根据定义，如果存在一个图灵机，它精确接受该语言中的字符串，而对于不在此语言中的字符串可能永远循环，那么该语言是图灵可识别的。构造一个识别器 $R$，它在输入 $x$ 时按如下方式进行：如果 $x$ 不是一个有效的图灵机编码，$R$ 可以立即拒绝（这不影响可识别性）。如果 $x=\\langle M\\rangle$（对于某个图灵机 $M$），$R$ 在空白输入带上逐步模拟 $M$。在每个模拟步骤之后，$R$ 扫描输出带上已写入的部分，检查是否出现了精确的有限字符串“Hello, world!”作为一个连续块（等价地，检查当时的输出带是否包含该字符串）。如果在某个有限的模拟时间内发生了这样的事件，$R$ 就接受。如果 $M$ 永不产生该字符串，那么 $R$ 将永远模拟下去并且永不接受。这个过程是有效的，因为在任何有限的时间点，带上已写入的部分是有限的，并且检查一个固定的有限模式是可判定的。因此，$L_{HW}$ 是图灵可识别的。\n\n其次，我们通过从标准的不可判定语言 $A_{TM}=\\{\\langle M,w\\rangle\\mid \\text{$M$ accepts }w\\}$ 进行映射归约，来证明 $L_{HW}$ 是不可判定的。定义一个可计算函数 $f$，它在给定 $\\langle M,w\\rangle$ 时，输出一个图灵机 $N$ 的编码 $\\langle N\\rangle$。$N$ 在空白输入上的行为如下：$N$ 模拟 $M$ 在输入 $w$ 上的运行；如果模拟显示 $M$ 在 $w$ 上进入了接受状态，$N$ 就接着在其输出带上精确地写入字符串“Hello, world!”（然后可以任意地循环或停机）。如果 $M$ 拒绝 $w$ 或在 $w$ 上不停机，那么 $N$ 永远不会产生字符串“Hello, world!”。这样的 $N$ 可以通过将 $M$ 和 $w$ 硬编码到 $N$ 的转移函数中来有效地构造，因此 $f$ 是可计算的。根据构造，\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle N\\rangle=f(\\langle M,w\\rangle)\\in L_{HW}.\n$$\n因此 $A_{TM}\\leq_{m} L_{HW}$。因为 $A_{TM}$ 是不可判定的，所以 $L_{HW}$ 也是不可判定的。\n\n第三，我们证明 $L_{HW}$ 不是余-图灵可识别的。假设 $L_{HW}$ 和它的补集 $\\overline{L_{HW}}$ 都是图灵可识别的，以寻求矛盾。那么，对两者都会存在识别器。通过在任意输入上交错运行这两个识别器，其中一个最终会接受，从而为 $L_{HW}$ 构成一个判定器。这与 $L_{HW}$ 的不可判定性相矛盾。因此，$\\overline{L_{HW}}$ 不是图灵可识别的。\n\n综合这些结果，$L_{HW}$ 是图灵可识别的但不是可判定的，并且它的补集不是图灵可识别的。因此，正确的分类是选项B。", "answer": "$$\\boxed{B}$$", "id": "1361702"}]}