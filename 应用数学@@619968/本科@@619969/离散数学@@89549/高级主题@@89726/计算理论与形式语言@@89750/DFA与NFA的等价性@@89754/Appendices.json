{"hands_on_practices": [{"introduction": "非确定性有限自动机（NFA）的威力在于其能够同时探索多条计算路径。在将 NFA 转换为等价的确定性有限自动机（DFA）时，核心思想是将 NFA 的“活动状态集”映射为 DFA 的一个单一状态。本练习通过追踪一个输入字符串在 NFA 上的处理过程，让你亲手体验这种“并行宇宙”的模拟，从而为理解子集构造法奠定直观基础。[@problem_id:1367326]", "problem": "考虑一个非确定性有限自动机 (NFA)，记为 $N$，它由一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 形式化定义。其组成部分定义如下：\n- 状态集合为 $Q = \\{q_0, q_1, q_2\\}$。\n- 输入字母表为 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_0$。\n- 终止（或接受）状态集合为 $F = \\{q_2\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，定义如下：\n  - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n  - $\\delta(q_0, b) = \\{q_0\\}$\n  - $\\delta(q_1, a) = \\emptyset$\n  - $\\delta(q_1, b) = \\{q_2\\}$\n  - $\\delta(q_2, a) = \\emptyset$\n  - $\\delta(q_2, b) = \\emptyset$\n\n当一个 NFA 处理一个输入字符串时，它可以同时处于多个状态。在处理了给定输入的一部分后，NFA 可能处于的所有状态的集合被称为“活动状态集”。自动机理论中的一个基本结论是，对于任何 NFA，都存在一个等价的确定性有限自动机 (DFA)，其中 DFA 的每个状态都对应于 NFA 的一个活动状态集。\n\n给定上面描述的 NFA $N$，请确定从初始状态 $q_0$ 开始，处理输入字符串 `aba` 后的活动状态集。\n\nA. $\\{q_0\\}$\n\nB. $\\{q_0, q_1\\}$\n\nC. $\\{q_0, q_2\\}$\n\nD. $\\{q_1, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "我们使用标准的 NFA 更新规则来模拟活动状态集的演变：如果 $S_{i}$ 是在读取前 $i$ 个符号后的活动状态集，那么对于下一个输入符号 $x \\in \\Sigma$，\n$$\nS_{i+1}=\\bigcup_{q \\in S_{i}} \\delta(q,x).\n$$\n这个 NFA 中没有 $\\varepsilon$-转移，所以不需要计算 $\\varepsilon$-闭包。从初始集合 $S_{0}=\\{q_{0}\\}$ 开始。\n\n处理第一个符号 $a$：\n$$\nS_{1}=\\bigcup_{q \\in \\{q_{0}\\}} \\delta(q,a)=\\delta(q_{0},a)=\\{q_{0},q_{1}\\}.\n$$\n\n处理下一个符号 $b$：\n$$\nS_{2}=\\bigcup_{q \\in \\{q_{0},q_{1}\\}} \\delta(q,b)=\\delta(q_{0},b)\\cup \\delta(q_{1},b)=\\{q_{0}\\}\\cup \\{q_{2}\\}=\\{q_{0},q_{2}\\}.\n$$\n\n处理最后一个符号 $a$：\n$$\nS_{3}=\\bigcup_{q \\in \\{q_{0},q_{2}\\}} \\delta(q,a)=\\delta(q_{0},a)\\cup \\delta(q_{2},a)=\\{q_{0},q_{1}\\}\\cup \\emptyset=\\{q_{0},q_{1}\\}.\n$$\n\n因此，在处理输入字符串 `aba` 后，活动状态集为 $\\{q_{0},q_{1}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1367326"}, {"introduction": "掌握了活动状态集的概念后，我们便可以应用子集构造法，将一个 NFA 系统地转换为一个等价的 DFA。这个过程是计算理论中的一个基石操作。本练习将引导你完整地执行一次子集构造，并确定最终生成的最小 DFA 的接受状态，从而让你熟练掌握这一核心算法的每一个步骤。[@problem_id:1367335]", "problem": "考虑一个非确定性有限自动机（NFA），记作 $N$，它由一个5元组 $(Q, \\Sigma, \\delta, q_{start}, F)$ 形式化定义。其组成部分规定如下：\n- 状态集为 $Q = \\{s_0, s_1\\}$。\n- 输入字母表为 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_{start} = s_0$。\n- 最终（或接受）状态集为 $F = \\{s_1\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，由下表给出：\n\n| 状态 | 输入 'a' | 输入 'b' |\n|:-----:|:---------:|:---------:|\n| $s_0$ | $\\{s_1\\}$   | $\\{s_0, s_1\\}$ |\n| $s_1$ | $\\{s_0\\}$   | $\\{s_1\\}$   |\n\n在自动机理论中，一个已知的定理是：对于任何NFA，都存在一个等价的、识别相同语言的确定性有限自动机（DFA）。使用标准的子集构造算法，可以构造出这样一个DFA。在构造出等价的DFA之后，应将其最小化以获得最少可能的状态。\n\n与上述NFA $N$ 等价的最小DFA中有多少个最终（接受）状态？\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3", "solution": "问题要求计算与给定的非确定性有限自动机（NFA）等价的最小确定性有限自动机（DFA）中最终状态的数量。我们将使用子集构造算法来找出等价的DFA，然后计算其最终状态的数量。由子集构造算法从一个从其起始状态没有不可达状态的NFA生成的DFA本身也将没有不可达状态。然后可以检查其最小性。\n\n给定的NFA是 $N = (Q, \\Sigma, \\delta, s_0, F)$，其中：\n- $Q = \\{s_0, s_1\\}$\n- $\\Sigma = \\{a, b\\}$\n- 起始状态为 $s_0$\n- 最终状态集 $F = \\{s_1\\}$\n- 转移函数 $\\delta$ 如问题陈述中所给出。\n\n等价DFA（我们称之为 $M$）的状态将是NFA状态集 $Q$ 的子集。$M$ 的起始状态是包含 $N$ 的起始状态的集合。\n我们将 $M$ 的状态表示为 $S_i$。\n\n1.  **起始状态：** $M$ 的起始状态是 $S_{start} = \\{s_0\\}$。我们称这个状态为 $S_0$。\n\n2.  **从 $S_0 = \\{s_0\\}$ 开始探索：** 我们计算该状态对于字母表 $\\Sigma=\\{a,b\\}$ 中每个符号的转移。\n    - 对于输入 'a'：$\\delta_M(S_0, a) = \\delta(s_0, a) = \\{s_1\\}$。这是一个新状态。我们称之为 $S_1 = \\{s_1\\}$。\n    - 对于输入 'b'：$\\delta_M(S_0, b) = \\delta(s_0, b) = \\{s_0, s_1\\}$。这是另一个新状态。我们称之为 $S_2 = \\{s_0, s_1\\}$。\n\n3.  **从 $S_1 = \\{s_1\\}$ 开始探索：** 现在我们为新状态 $S_1$ 计算转移。\n    - 对于输入 'a'：$\\delta_M(S_1, a) = \\delta(s_1, a) = \\{s_0\\} = S_0$。这个状态已经存在。\n    - 对于输入 'b'：$\\delta_M(S_1, b) = \\delta(s_1, b) = \\{s_1\\} = S_1$。这个状态已经存在。\n\n4.  **从 $S_2 = \\{s_0, s_1\\}$ 开始探索：** 我们为状态 $S_2$ 计算转移。从一个状态集合出发的转移是该集合中每个状态的转移的并集。\n    - 对于输入 'a'：$\\delta_M(S_2, a) = \\delta(s_0, a) \\cup \\delta(s_1, a) = \\{s_1\\} \\cup \\{s_0\\} = \\{s_0, s_1\\} = S_2$。\n    - 对于输入 'b'：$\\delta_M(S_2, b) = \\delta(s_0, b) \\cup \\delta(s_1, b) = \\{s_0, s_1\\} \\cup \\{s_1\\} = \\{s_0, s_1\\} = S_2$。\n\n我们现在已经探索了所有可达状态。我们的新DFA $M$ 的状态集是 $Q_M = \\{S_0, S_1, S_2\\} = \\{\\{s_0\\}, \\{s_1\\}, \\{s_0, s_1\\}\\}$。该DFA有3个状态。\n\n5.  **确定最终状态：** 如果DFA中的一个状态包含原始NFA中至少一个最终状态，那么它就是最终状态。NFA中的最终状态集是 $F = \\{s_1\\}$。\n    - $S_0 = \\{s_0\\}$ 不包含 $s_1$。因此，$S_0$ 不是最终状态。\n    - $S_1 = \\{s_1\\}$ 包含 $s_1$。因此，$S_1$ 是一个最终状态。\n    - $S_2 = \\{s_0, s_1\\}$ 包含 $s_1$。因此，$S_2$ 是一个最终状态。\n    $M$ 中的最终状态集是 $F_M = \\{S_1, S_2\\}$。\n\n6.  **检查最小性：** 如果子集构造法生成的DFA的所有状态都是可区分的，那么它就是最小的。\n    - $S_0$ 是非最终状态，而 $S_1$ 和 $S_2$ 是最终状态。因此，$S_0$ 与 $S_1$ 和 $S_2$ 都是可区分的。\n    - 为了区分 $S_1$ 和 $S_2$（两者都是最终状态），我们检查它们的转移。\n        - 对于输入 'a'，$\\delta_M(S_1, a) = S_0$（一个非最终状态）。\n        - 对于输入 'a'，$\\delta_M(S_2, a) = S_2$（一个最终状态）。\n    由于输入 'a' 将 $S_1$ 和 $S_2$ 转移到不同最终性的状态（一个非最终状态，一个最终状态），因此 $S_1$ 和 $S_2$ 是可区分的。\n    由于所有三个状态彼此之间都是可区分的，因此构造出的这个有3个状态的DFA是最小的。\n\n7.  **计算最终状态数量：** 最终状态集是 $F_M = \\{S_1, S_2\\}$。最终状态的数量是 $|F_M| = 2$。", "answer": "$$\\boxed{C}$$", "id": "1367335"}, {"introduction": "DFA 和 NFA 的一个关键区别在于它们对语言求补运算的处理方式。虽然为一个 DFA 构造其补集很简单（只需翻转其接受与非接受状态），但这一方法对 NFA 通常不成立。本练习通过一个具体的反例，让你找出为何这种直接“翻转”会失败，从而加深你对 NFA 非确定性本质的理解，并警示在实践中可能遇到的常见陷阱。[@problem_id:1367357]", "problem": "在计算理论中，为语言 $L$ 的补集构造自动机的一个标准方法是，从一个识别 $L$ 的确定性有限自动机 (DFA) 开始，然后将其终态集与非终态集互换。然而，这个过程通常不适用于非确定性有限自动机 (NFA)。\n\n这个问题要求你探究此方法为何会失效。考虑由五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 定义的 NFA $N$，其中：\n- 状态集为 $Q = \\{q_s, q_f\\}$。\n- 字母表为 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_s$。\n- 终态集为 $F = \\{q_f\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，定义如下：\n    - $\\delta(q_s, a) = \\{q_s, q_f\\}$\n    - $\\delta(q_s, b) = \\{q_s\\}$\n    - $\\delta(q_f, a) = \\emptyset$ (空集)\n    - $\\delta(q_f, b) = \\emptyset$\n\n令 $L(N)$ 为 $N$ 所接受的语言。\n现在，通过互换 $N$ 的终态和非终态来构造一个新的 NFA $N'$。新的自动机为 $N' = (Q, \\Sigma, \\delta, q_s, Q \\setminus F)$。令 $L(N')$ 为 $N'$ 所接受的语言。\n\n$L(N')$ 不是 $L(N)$ 的补集的一个关键迹象是，存在一个同时被两个自动机接受的字符串。如果 $L(N')$ 是 $L(N)$ 的真正补集，那么没有任何字符串可以同时属于这两种语言。\n\n你的任务是找到字母表 $\\Sigma$ 上最短的非空字符串 $w$，它既被原始自动机 $N$ 接受，也被修改后的自动机 $N'$ 接受。", "solution": "我们分析 NFA $N=(Q,\\Sigma,\\delta,q_{s},F)$，其中 $Q=\\{q_{s},q_{f}\\}$，$\\Sigma=\\{a,b\\}$，起始状态为 $q_{s}$，终态集为 $F=\\{q_{f}\\}$，转移函数为 $\\delta(q_{s},a)=\\{q_{s},q_{f}\\}$，$\\delta(q_{s},b)=\\{q_{s}\\}$，以及 $\\delta(q_{f},a)=\\delta(q_{f},b)=\\emptyset$。\n\n首先，确定 $L(N)$ 的特征。一个字符串 $w$ 被 $N$ 接受，当且仅当存在一条运行路径，在读完 $w$ 的所有符号后终止于 $q_f$。进入 $q_f$ 的唯一方式是在状态 $q_s$ 下读取一个 $a$ 并进行到 $q_f$ 的转移。由于对所有 $x\\in\\Sigma$ 都有 $\\delta(q_{f},x)=\\emptyset$，一旦到达 $q_f$，就无法再读取任何输入。因此，在任何接受路径中，进入 $q_f$ 的转移必须发生在输入的最后一个符号上，且该符号必须是 $a$。反之，对于任何以 $a$ 结尾的字符串，都存在一条路径，它对之前的所有符号都停留在 $q_s$ 状态（在需要时从 $\\delta(q_{s},a)$ 中选择 $q_s$，并使用 $\\delta(q_{s},b)=\\{q_{s}\\}$），然后在最后一个符号上进行 $q_{s}\\xrightarrow{a}q_{f}$ 的转移。因此\n$$\nL(N)=\\{xa\\mid x\\in\\{a,b\\}^{*}\\},\n$$\n即所有最后一个符号为 $a$ 的非空字符串的集合。\n\n现在构造 $N'=(Q,\\Sigma,\\delta,q_{s},Q\\setminus F)$，因此唯一的接受状态是 $q_s$。一个字符串 $w$ 被 $N'$ 接受，当且仅当存在一条终止于 $q_s$ 的运行路径。从 $q_s$ 开始，在输入 $a$ 时，我们可以选择停留在 $q_s$（因为 $\\delta(q_{s},a)$ 包含 $q_s$），而在输入 $b$ 时，我们必须转移到 $q_s$（因为 $\\delta(q_{s},b)=\\{q_{s}\\}$）。因此，对于每个 $w\\in\\Sigma^{*}$，都存在一条始终停留在 $q_s$ 的路径，因此也终止于 $q_s$。所以\n$$\nL(N')=\\Sigma^{*}.\n$$\n\n因此，$L(N)\\cap L(N')=L(N)=\\{xa\\mid x\\in\\{a,b\\}^{*}\\}$。这个集合中最短的非空字符串是 $w=a$，长度为 1，它被 $N$ 接受（通过路径 $q_{s}\\xrightarrow{a}q_{f}$），也被 $N'$ 接受（通过路径 $q_{s}\\xrightarrow{a}q_{s}$）。", "answer": "$$\\boxed{a}$$", "id": "1367357"}]}