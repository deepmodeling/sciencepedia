{"hands_on_practices": [{"introduction": "在我们开始设计自己的非确定性有限自动机 (NFA) 之前，首先必须理解它们是如何处理输入字符串的。本练习将引导你逐步模拟一个给定的 NFA 的计算过程，这包括处理其同时处于多个状态的能力以及遵循空转移 ($\\epsilon$) 的规则。掌握这一技能是建立“像 NFA 一样思考”的直觉的基础。[@problem_id:1388210]", "problem": "一位计算机科学家正在设计一个基于非确定性有限自动机 (NFA) 的简单词法分析工具，用于检测二进制数据流中的特定模式。该 NFA 的形式化定义包含以下组成部分：\n- 状态集 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 输入字母表 $\\Sigma = \\{0, 1\\}$。\n- 起始状态 $q_{start} = q_0$。\n- 接受状态集 $F = \\{q_3\\}$。\n\n转移函数 $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，$\\epsilon$ 表示空字符串，由以下规则表给出。请注意，如果某个状态-输入对未被列出，则其转移指向空集 $\\emptyset$。\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\epsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\n给定输入字符串 `101`，确定在处理完整个字符串后，该自动机可能处于的所有状态的集合。从以下选项中选择正确的集合。\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "对于一个带有 $\\epsilon$-转移的 NFA，在每一步我们首先计算当前状态集的 $\\epsilon$-闭包，然后根据输入符号进行转移，最后再次计算 $\\epsilon$-闭包。设 $\\text{E}(S)$ 表示集合 $S$ 的 $\\epsilon$-闭包。未指明的转移指向空集。\n\n初始闭包：\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\n读取第一个符号 $1$ 后：\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\n读取第二个符号 $0$ 后：\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\n读取第三个符号 $1$ 后：\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\n因此，在处理完整个字符串 $101$ 后，可能的状态集是 $\\{q_{0},q_{1},q_{2},q_{3}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "当你掌握了 NFA 的运行机制后，就可以开始尝试设计了。这个练习要求你构建一个能够识别一种常见模式的 NFA——即以特定子字符串结尾的字符串。这需要你运用非确定性的核心思想，即“猜测”所需模式可能开始的位置，这是从理解 NFA 到应用 NFA 的关键一步。[@problem_id:1388241]", "problem": "在理论计算机科学领域，非确定性有限自动机（Nondeterministic Finite Automaton, NFA）是一种计算模型，用于识别文本字符串中的模式。一个NFA由一个五元组 $M = (Q, \\Sigma, \\delta, q_0, F)$ 形式化定义，其中：\n- $Q$ 是状态的有限集合。\n- $\\Sigma$ 是输入符号的有限集合，称为字母表。\n- $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ 是转移函数，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集。\n- $q_0 \\in Q$ 是起始状态。\n- $F \\subseteq Q$ 是最终（或接受）状态的集合。\n\n如果存在至少一个从 $q_0$ 开始的转移序列，在处理完整个字符串后能到达 $F$ 中的某个状态，那么该NFA就接受该字符串。\n\n考虑语言 $L$，它包含所有在字母表 $\\Sigma = \\{a, b\\}$ 上以子串 'ab' 结尾的字符串。下列哪个形式化描述正确地表示了一个恰好接受语言 $L$ 的NFA？在所有选项中，状态集合为 $Q=\\{q_0, q_1, q_2\\}$，字母表为 $\\Sigma = \\{a, b\\}$，起始状态为 $q_0$。未明确定义的转移被假定映射到空集 $\\emptyset$。\n\nA. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nB. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nC. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n   - $\\delta(q_2, a) = \\{q_2\\}$\n   - $\\delta(q_2, b) = \\{q_2\\}$\n\nD. $F = \\{q_0, q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$", "solution": "该问题要求我们识别出能接受语言 $L$（所有在 $\\Sigma = \\{a, b\\}$ 上以子串 'ab' 结尾的字符串）的非确定性有限自动机（NFA）。让我们先分析该语言的属性，然后评估每个选项。\n\n语言 $L$ 包括像 \"ab\"、\"aab\"、\"bab\" 和 \"abbab\" 这样的字符串。它不包括空字符串 $\\epsilon$、\"a\"、\"b\"、\"ba\" 或 \"aba\"。用于此语言的NFA必须能够处理任意前缀，然后识别出最后的 'ab' 序列。\n\n让我们逐一分析每个选项：\n\n**选项A的分析：**\n- $Q = \\{q_0, q_1, q_2\\}$，起始状态 $q_0$，$F = \\{q_2\\}$。\n- 转移：$\\delta(q_0, a) = \\{q_0, q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n\n此NFA的逻辑可以解释如下：\n- 状态 $q_0$ 是初始状态，也是一个“搜索”状态。它消耗任意的 'a' 和 'b' 序列。循环 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$ 允许机器在处理任何前缀时保持在此状态。\n- 转移 $\\delta(q_0, a) \\ni q_1$ 是非确定性的。当NFA在状态 $q_0$ 读到一个 'a' 时，它可以“猜测”这个 'a' 可能是所期望的后缀 \"ab\" 的开始。它产生一个新的计算路径，转移到状态 $q_1$。\n- 状态 $q_1$ 代表了这样一个假设：上一个看到的字符是 \"ab\" 中的 'a'。\n- 如果下一个字符是 'b'，转移 $\\delta(q_1, b) = \\{q_2\\}$ 会使该路径到达最终状态 $q_2$。如果字符串在此结束，它就被接受。\n- 如果在状态 $q_1$ 读到任何其他字符（例如 'a'），或在状态 $q_2$ 读到任何字符，由于没有定义转移，该路径终止。\n\n我们用一些字符串来测试这个NFA：\n- 字符串 \"aab\":\n    1. 从 $q_0$ 开始。读入 'a'。$\\delta(q_0, a) = \\{q_0, q_1\\}$。NFA现在处于状态集合 $\\{q_0, q_1\\}$ 中。\n    2. 读入 'a'。从 $q_0$，$\\delta(q_0, a) = \\{q_0, q_1\\}$。从 $q_1$，$\\delta(q_1, a) = \\emptyset$。结果状态的并集是 $\\{q_0, q_1\\} \\cup \\emptyset = \\{q_0, q_1\\}$。NFA处于状态 $\\{q_0, q_1\\}$。\n    3. 读入 'b'。从 $q_0$，$\\delta(q_0, b) = \\{q_0\\}$。从 $q_1$，$\\delta(q_1, b) = \\{q_2\\}$。结果状态的并集是 $\\{q_0\\} \\cup \\{q_2\\} = \\{q_0, q_2\\}$。\n    4. 字符串结束。最终的状态集合是 $\\{q_0, q_2\\}$。由于该集合包含一个最终状态（$q_2 \\in F$），字符串 \"aab\" 被接受。正确。\n- 字符串 \"aba\":\n    1. 从 $q_0$ 开始。读入 'a'。状态集为 $\\{q_0, q_1\\}$。\n    2. 读入 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态集为 $\\{q_0, q_2\\}$。\n    3. 读入 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\emptyset$。状态集为 $\\{q_0, q_1\\}$。\n    4. 字符串结束。最终的状态集合是 $\\{q_0, q_1\\}$。此集合不包含 $F$ 中的任何状态。字符串 \"aba\" 被拒绝。正确。\n这个构造正确地接受了所有以 \"ab\" 结尾的字符串，并拒绝了所有其他字符串。因此，选项A是正确答案。\n\n**选项B的分析：**\n- $F = \\{q_2\\}$，$\\delta(q_0, a) = \\{q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n这个NFA的转移是确定性的（每个都映射到一个单元素集或空集）。问题在于转移 $\\delta(q_0, a) = \\{q_1\\}$。一旦读入一个 'a'，机器必须转移到 $q_1$ 并且永远不能返回 $q_0$。\n- 让我们测试 \"aab\"。从 $q_0$ 开始。读入 'a'。转到 $q_1$。读入 'a'。$\\delta(q_1, a) = \\emptyset$。计算路径在未到达最终状态时就停止了。字符串 \"aab\" 被拒绝，但它应该被接受。因此，选项B不正确。这个NFA只接受形式为 $b^k ab$（$k \\ge 0$）的字符串。\n\n**选项C的分析：**\n- $F = \\{q_2\\}$。这个NFA与A相似，但在最终状态 $q_2$ 上增加了自循环：$\\delta(q_2, a) = \\{q_2\\}$ 和 $\\delta(q_2, b) = \\{q_2\\}$。\n这些循环意味着一旦机器到达最终状态 $q_2$（即，一旦它看到了 \"ab\" 子串），无论后面跟什么字符，它都将保持在该最终状态。\n- 让我们测试 \"aba\"。\n    1. 从 $q_0$ 开始。读入 'a'。状态集为 $\\{q_0, q_1\\}$。\n    2. 读入 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态集为 $\\{q_0, q_2\\}$。\n    3. 读入 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\{q_2\\}$。状态集为 $\\{q_0, q_1, q_2\\}$。\n    4. 字符串结束。最终的状态集合包含 $q_2 \\in F$。字符串 \"aba\" 被接受。这是不正确的，因为 \"aba\" 并不以 \"ab\" 结尾。这个NFA接受任何*包含* \"ab\" 作为子串的字符串。因此，选项C不正确。\n\n**选项D的分析：**\n- $F = \\{q_0, q_2\\}$。这个NFA的转移与选项A中的正确NFA相同，但最终状态集合不同。在这里，起始状态 $q_0$ 也是一个最终状态。\n因为 $q_0$ 是一个最终状态，空字符串 $\\epsilon$ 会被接受，这是不正确的。此外，考虑转移 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$。对于*任何*输入字符串，都存在一条仅停留在状态 $q_0$ 的路径。由于 $q_0$ 是一个接受状态，这条路径将导致该字符串被接受。例如，对于字符串 \"b\"，机器可以遵循路径 $q_0 \\xrightarrow{b} q_0$，结束于一个最终状态。所以，\"b\" 被接受。这是不正确的。这个NFA接受 $\\Sigma^*$ 中的所有字符串。因此，选项D不正确。\n\n基于以上分析，只有选项A正确地描述了指定语言的NFA。", "answer": "$$\\boxed{A}$$", "id": "1388241"}, {"introduction": "最后的这个练习将展示非确定性的真正优雅与强大之处。你将挑战为一个对于确定性自动机而言异常复杂的语言设计一个 NFA。解决这个问题将巩固你对 NFA 如何利用其“猜测并验证”的能力来简化语言识别器设计的理解。[@problem_id:1388199]", "problem": "在理论计算机科学领域，非确定性有限自动机（NFA）是一种用于识别符号串中模式的计算模型。考虑字母表 $\\Sigma = \\{0, 1\\}$。我们定义语言 $L$ 是该字母表上所有倒数第三个符号为 $1$ 的二进制串的集合。例如，字符串 `1010` 在 $L$ 中，因为其倒数第三个符号是 `1`，而字符串 `011` 不在 $L$ 中，因为其倒数第三个符号是 `0`。字符串 `10` 不在 $L$ 中，因为它太短，没有倒数第三个符号。\n\n一个接受语言 $L$ 的非确定性有限自动机（NFA）所需的最少状态数是多少？", "solution": "设语言为 $L = \\{w \\in \\{0, 1\\}^* \\mid w \\text{ 的倒数第三个符号是 } 1\\}$。我们在寻找一个接受 $L$ 的非确定性有限自动机（NFA）的最小状态数。\n\n为该语言设计 NFA 的关键思想是利用非确定性来“猜测”哪个符号是倒数第三个符号。该 NFA 将按以下方式进行：\n1.  读取任意数量的符号（0或1），直到它猜测当前处于输入串的倒数第三个符号位置。\n2.  如果做出此猜测，它必须验证当前符号是 $1$。\n3.  在验证了 `1` 之后，它必须接着验证输入串中还剩下恰好两个符号。\n\n我们可以构建一个有四个状态的 NFA 来完成这个任务。我们将状态标记为 $q_0, q_1, q_2, q_3$。\n\n-   **状态 $q_0$ (起始状态):** 这是初始状态。只要 NFA 尚未确定它已经看到了倒数第三个符号，它就一直处于这个状态。\n    -   当读取一个 $0$ 时，NFA 停留在状态 $q_0$。\n    -   当读取一个 $1$ 时，NFA 有一个非确定性选择：\n        a) 停留在状态 $q_0$（将这个 `1` 解释为不是倒数第三个符号）。\n        b) 转移到状态 $q_1$（猜测这个 `1` 是倒数第三个符号）。\n\n-   **状态 $q_1$:** 在猜测刚刚读取的是倒数第三个符号（该符号为 `1`）后，NFA 进入此状态。现在它需要看到恰好两个符号才能到达字符串的末尾。\n\n-   **状态 $q_2$:** 在处于状态 $q_1$ 并再读取一个符号（0 或 1）后，NFA 进入此状态。这个符号对应于字符串的倒数第二个符号。\n\n-   **状态 $q_3$ (接受状态):** 在处于状态 $q_2$ 并再读取一个符号（0 或 1）后，NFA 进入此状态。这个符号对应于字符串的最后一个符号。由于 NFA 在做出猜测后已经成功读取了整个字符串，所以这必须是一个接受状态。$q_3$ 没有出向转移。如果输入中还有更多符号，该计算路径就会死亡。\n\n让我们正式总结一下转移：\n-   $\\delta(q_0, 0) = \\{q_0\\}$\n-   $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n-   $\\delta(q_1, 0) = \\{q_2\\}$\n-   $\\delta(q_1, 1) = \\{q_2\\}$\n-   $\\delta(q_2, 0) = \\{q_3\\}$\n-   $\\delta(q_2, 1) = \\{q_3\\}$\n\n状态集合为 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n起始状态为 $q_0$。\n最终状态集合为 $F = \\{q_3\\}$。\n\n这个构造使用了 4 个状态。\n\n要论证这是最小状态数，我们可以使用 Myhill-Nerode 定理对 NFA 的扩展，或者一个更直观的论证。针对该语言的 NFA 必须在某种意义上“记住”它已经看到了一个 `1`，然后计算是否经过了另外两个字符。为了区分以 $1xx$（其中 $x$ 是 0 或 1）结尾的字符串与其他字符串，机器需要一条长度至少为 3 的路径来处理序列 `1`, `x`, `x` 然后接受。一条长度为 3 的路径需要 4 个不同的状态。例如，考虑在输入 `100` 上的路径：$q_0 \\xrightarrow{1} q_1 \\xrightarrow{0} q_2 \\xrightarrow{0} q_3$。这条路径包含 3 次转移，涉及 4 个状态。如果我们有少于 4 个状态，比如 3 个状态，那么任何长度为 3 的路径都必须包含一个环。这意味着机器也会接受其他长度的字符串（例如，对于某个 $k>1$ 的 $1(xx)^k$），其中原来的 `1` 将不再处于倒数第三的位置，从而导致接受了错误的语言。因此，至少需要 4 个状态。", "answer": "$$\\boxed{4}$$", "id": "1388199"}]}