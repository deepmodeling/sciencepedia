{"hands_on_practices": [{"introduction": "克林定理的强大之处在于其构造性证明，它提供了一套明确的算法，能将任何正则表达式转换为等价的非确定性有限自动机（NFA）。要真正掌握这个算法，最好的方法就是亲手实践。这个练习将引导你处理一个基础但又十分关键的特例：对空字符串 $\\epsilon$ 应用克林尼星号（Kleene star）构造规则。通过这个练习，你将能牢固掌握星号构造的正式步骤，并理解该算法如何精确地处理特殊情况。", "problem": "在计算理论中，正则表达式是定义文本中搜索模式的字符序列。此模式用于定义一个字符串集合，称为正则语言。非确定性有限自动机（NFA）是一种可用于识别正则语言的有限自动机。一个 NFA 被形式化地定义为一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是一个有限的输入符号集合，称为字母表。\n- $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$ 是转移函数，其中 $\\epsilon$ 代表空字符串，$\\mathcal{P}(Q)$ 是 $Q$ 的幂集。\n- $q_0 \\in Q$ 是起始状态。\n- $F \\subseteq Q$ 是最终状态（或接受状态）的集合。\n\n考虑在字母表 $\\Sigma = \\{a\\}$ 上定义的正则表达式 $r = \\epsilon^*$。存在标准的递归算法可以从任何给定的正则表达式构造一个 NFA。请应用这样一种标准的构造过程。\n\n下列哪个选项正确地描述了接受语言 $L(r)$ 的最终 NFA 以及语言 $L(r)$ 本身？\n\nA.\nNFA: $Q=\\{q_0, q_1, q_2, q_3\\}$，$q_0$ 是起始状态，$F=\\{q_3\\}$。转移函数 $\\delta$ 定义为：$\\delta(q_0, \\epsilon) = \\{q_1, q_3\\}$，$\\delta(q_1, \\epsilon) = \\{q_2\\}$，以及 $\\delta(q_2, \\epsilon) = \\{q_1, q_3\\}$。对于所有其他输入，转移函数映射到空集。\n语言：$L(r) = \\{\\epsilon\\}$，即只包含空字符串的语言。\n\nB.\nNFA: $Q=\\{q_0, q_1, q_2, q_3\\}$，$q_0$ 是起始状态，$F=\\{q_3\\}$。转移函数 $\\delta$ 定义为：$\\delta(q_0, \\epsilon) = \\{q_1, q_3\\}$，$\\delta(q_1, a) = \\{q_2\\}$，以及 $\\delta(q_2, \\epsilon) = \\{q_1, q_3\\}$。对于所有其他输入，转移函数映射到空集。\n语言：$L(r) = \\{a^n \\mid n \\geq 0\\}$。\n\nC.\nNFA: $Q=\\{q_0, q_1\\}$，$q_0$ 是起始状态，$F=\\{q_1\\}$。转移函数 $\\delta$ 定义为：$\\delta(q_0, \\epsilon) = \\{q_1\\}$。对于所有其他输入，转移函数映射到空集。\n语言：$L(r) = \\{\\epsilon\\}$，即只包含空字符串的语言。\n\nD.\nNFA: $Q=\\{q_0\\}$，$q_0$ 是起始状态，$F=\\emptyset$。转移函数 $\\delta$ 为空。\n语言：$L(r) = \\emptyset$，即空语言。\n\nE.\nNFA: $Q=\\{q_0\\}$，$q_0$ 是起始状态，$F=\\{q_0\\}$。转移函数 $\\delta$ 定义为：$\\delta(q_0, a) = \\{q_0\\}$。对于所有其他输入，转移函数映射到空集。\n语言：$L(r) = \\{a^n \\mid n \\geq 0\\}$。", "solution": "本问题要求根据正则表达式 $r = \\epsilon^*$，使用标准递归过程（如 Thompson 构造法）构造出 NFA，并确定该 NFA 接受的语言。\n\n首先，我们来分析正则表达式 $r = \\epsilon^*$ 的语言。该表达式的基础是 $\\epsilon$，代表空字符串。克莱尼星号算子（$^*$）表示前一个元素的“零次或多次串联”。因此，$\\epsilon^*$ 表示空字符串的零次或多次串联。\n- $\\epsilon$ 的零次串联是空字符串 $\\epsilon$。\n- $\\epsilon$ 的一次串联是 $\\epsilon$。\n- $\\epsilon$ 的两次串联是 $\\epsilon\\epsilon$，也就是 $\\epsilon$。\n- 依此类推。\n因此，唯一可以形成的字符串是空字符串。$\\epsilon^*$ 的语言是 $L(\\epsilon^*) = \\{\\epsilon\\}$。\n\n现在，我们遵循标准递归构造（Thompson 构造法）的步骤来构建 NFA。该构造基于正则表达式的结构。表达式为 $R^*$，其中子表达式为 $R = \\epsilon$。\n\n**步骤 1：为基本情况 $R = \\epsilon$ 构造 NFA。**\n正则表达式 $\\epsilon$ 的标准构造会创建一个 NFA，它有一个起始状态和一个最终状态，由一个 $\\epsilon$ 转移连接。我们称起始状态为 $q_1$，最终状态为 $q_2$。\n$$\nq_1 \\xrightarrow{\\epsilon} q_2\n$$\n因此，用于 $\\epsilon$ 的 NFA 是 $N_\\epsilon = (\\{q_1, q_2\\}, \\Sigma, \\delta_\\epsilon, q_1, \\{q_2\\})$，其中 $\\delta_\\epsilon(q_1, \\epsilon) = \\{q_2\\}$。\n\n**步骤 2：将克莱尼星号构造法应用于 $R = \\epsilon$ 的 NFA。**\n要为 $R^*$ 构造一个 NFA，我们取 $R$ 的 NFA（在我们的例子中是 $N_\\epsilon$）并按如下方式修改它：\n1. 创建一个新的起始状态，我们称之为 $q_0$。\n2. 创建一个新的最终状态，我们称之为 $q_3$。新 NFA 的最终状态集合将是 $F=\\{q_3\\}$。\n3. 添加一个从新起始状态 $q_0$ 到旧起始状态 $q_1$ 的 $\\epsilon$-转移。\n4. 添加一个从旧最终状态 $q_2$ 到新最终状态 $q_3$ 的 $\\epsilon$-转移。\n5. 添加一个从旧最终状态 $q_2$ 回到旧起始状态 $q_1$ 的 $\\epsilon$-转移。这就创建了“零次或多次”的循环。\n6. 添加一个从新起始状态 $q_0$ 直接到新最终状态 $q_3$ 的 $\\epsilon$-转移。这处理了“零次”的情况，确保空字符串被接受。\n\n让我们根据 $N_\\epsilon$ 来可视化新的连接：\n- 新状态：$q_0$（起始），$q_3$（最终）。\n- 原始的 $\\epsilon$ 的 NFA：$q_1 \\xrightarrow{\\epsilon} q_2$。\n- 连接 3：$q_0 \\xrightarrow{\\epsilon} q_1$。\n- 连接 4：$q_2 \\xrightarrow{\\epsilon} q_3$。\n- 连接 5（循环）：$q_2 \\xrightarrow{\\epsilon} q_1$。\n- 连接 6（旁路）：$q_0 \\xrightarrow{\\epsilon} q_3$。\n\n**步骤 3：定义最终的 NFA。**\n综合这些，用于 $\\epsilon^*$ 的最终 NFA 的组成部分如下：\n- 状态集合：$Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 字母表：$\\Sigma = \\{a\\}$（虽然没有使用其中的任何符号）。\n- 起始状态：$q_0$。\n- 最终状态：$F = \\{q_3\\}$。\n- 转移函数 $\\delta$：\n    - 从 $q_0$ 出发，在 $\\epsilon$ 上有到 $q_1$ 和 $q_3$ 的转移。所以，$\\delta(q_0, \\epsilon) = \\{q_1, q_3\\}$。\n    - 从 $q_1$ 出发，在 $\\epsilon$ 上有到 $q_2$ 的原始转移。所以，$\\delta(q_1, \\epsilon) = \\{q_2\\}$。\n    - 从 $q_2$ 出发，在 $\\epsilon$ 上有到 $q_3$ 和回到 $q_1$ 的转移。所以，$\\delta(q_2, \\epsilon) = \\{q_1, q_3\\}$。\n    - 没有其他转移。对于任何其他状态-输入对，结果都是空集 $\\emptyset$。\n\n这个 NFA 与选项 A 中的描述完全匹配。\n\n**步骤 4：验证语言并评估选项。**\n我们构造的 NFA 所接受的语言确实是 $\\{\\epsilon\\}$。如果存在一条从起始状态 $q_0$ 到最终状态（$q_3$）的路径，其标记为该字符串，则该字符串被接受。\n- 路径 1：$q_0 \\xrightarrow{\\epsilon} q_3$。这条路径消耗空字符串并结束于一个最终状态。所以，$\\epsilon$ 被接受。\n- 路径 2：$q_0 \\xrightarrow{\\epsilon} q_1 \\xrightarrow{\\epsilon} q_2 \\xrightarrow{\\epsilon} q_3$。这条路径是一系列三个 $\\epsilon$-转移，同样对应于消耗空字符串 $\\epsilon$。\n- 任何涉及循环 $q_2 \\to q_1$ 的路径只会增加更多的 $\\epsilon$-转移，仍然对应于空字符串。\n由于没有关于符号 'a' 的转移，任何包含 'a' 的字符串都不能被接受。\n因此，接受的语言是 $L = \\{\\epsilon\\}$。\n\n选项 A 中的 NFA 和语言都是正确的。\n\n我们来简要分析一下为什么其他选项是错误的：\n- **选项 B：** 所示的 NFA 是正则表达式 $a^*$ 的标准构造结果。它接受语言 $\\{a^n \\mid n \\geq 0\\}$。这错误地将 $\\epsilon$ 当作了符号 $a$。\n- **选项 C：** 这个 NFA 确实接受语言 $\\{\\epsilon\\}$。但是，它是正则表达式 $\\epsilon$ 的标准构造，而不是 $\\epsilon^*$。它缺少星号构造规则所要求的额外状态和反馈/旁路循环。\n- **选项 D：** 这个 NFA 没有最终状态，所以它不接受任何字符串。它的语言是空语言 $\\emptyset$。这是错误的，因为 $L(\\epsilon^*) = \\{\\epsilon\\}$，它不是空的。\n- **选项 E：** 这是一个用于语言 $a^* = \\{a^n \\mid n \\geq 0\\}$ 的最小确定性有限自动机（DFA）。其 NFA 和语言对于给定的正则表达式 $\\epsilon^*$ 都是错误的。\n\n因此，选项 A 是唯一一个正确呈现了标准构造产生的 NFA 及其所识别语言的选项。", "answer": "$$\\boxed{A}$$", "id": "1379664"}, {"introduction": "在掌握了基本的构造规则后，让我们来探索这个算法的递归特性。这个练习要求你为一个嵌套表达式 $(a^*)^*$ 机械地应用克林尼星号构造法。关键在于要抵制住“先简化表达式再构造”的诱惑，因为 $L(a^*) = L((a^*)^*)$。这个实践突显了 Thompson 构造法的一个核心特点：它是一个纯粹的句法算法，忠实地转换表达式的结构，而非其语义。这也解释了为什么算法生成的自动机虽然保证正确，但通常不是最简化的形式。", "problem": "在计算理论中，Kleene 定理确立了正则表达式和有限自动机之间的等价性。该定理证明的一个关键部分是一种构造性算法，称为 Thompson 构造法，该算法可将任意正则表达式转换为等价的带 epsilon 转移的非确定性有限自动机 (NFA-$\\epsilon$)。一个 NFA-$\\epsilon$ 由一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 正式定义，其中 $Q$ 是一个有限的状态集，$\\Sigma$ 是输入字母表，$\\delta$ 是转移函数，$q_0 \\in Q$ 是开始状态，$F \\subseteq Q$ 是最终（或接受）状态集。\n\n考虑字母表 $\\Sigma = \\{a\\}$ 上的正则表达式 $R = (a^*)^*$。\n\n机械地对正则表达式 $R$ 应用 Thompson 构造算法以生成等价的 NFA-$\\epsilon$。在构造之前或构造期间，不要对正则表达式进行任何化简。\n\n确定所生成自动机的以下属性：\n1. 状态总数。\n2. 开始状态的数量。\n3. 最终状态的数量。\n4. 转移总数（包括所有 $\\epsilon$-转移和基于 $\\Sigma$ 中符号的转移）。\n\n将您的四个数值答案表示为一个单行矩阵 `(States, Start States, Final States, Transitions)`。", "solution": "问题要求使用 Thompson 构造算法，根据正则表达式 $R = (a^*)^*$ 构建一个 NFA-$\\epsilon$，并确定其属性。我们将遵循该算法的递归定义，一步步构建自动机。\n\n**步骤 1：为基本表达式 `a` 构造 NFA。**\n\n设此自动机为 $N_a$。根据 Thompson 构造法对单个符号的规则，我们创建两个状态：一个开始状态和一个最终状态，两者之间通过该符号建立一个单向转移。\n- 状态, $Q_a$: $\\{q_0, q_1\\}$。总计：2 个状态。\n- 开始状态: $q_0$。\n- 最终状态: $q_1$。\n- 转移, $\\delta_a$: 一个从 $q_0$ 到 $q_1$ 的关于符号 'a' 的转移。\n- $N_a$ 的属性：2 个状态，1 个开始状态，1 个最终状态，1 个转移。\n\n**步骤 2：为内部表达式 `a*` 构造 NFA。**\n\n设此自动机为 $N_{a^*}$。我们对自动机 $N_a$ 应用克莱尼星号构造。该构造包括：\n1. 取自动机 $N_a$。\n2. 添加一个新的开始状态（我们称之为 $q_2$）和一个新的最终状态（我们称之为 $q_3$）。\n3. 添加四个新的 $\\epsilon$-转移：\n    - 从新的开始状态 ($q_2$) 到旧的开始状态 ($q_0$) 的转移。\n    - 从旧的最终状态 ($q_1$) 到新的最终状态 ($q_3$) 的转移。\n    - 从新的开始状态 ($q_2$) 直接到新的最终状态 ($q_3$) 的转移（用于处理空字符串的情况）。\n    - 从旧的最终状态 ($q_1$) 回到旧的开始状态 ($q_0$) 的转移（用于处理重复的情况）。\n\n我们来列出所生成的自动机 $N_{a^*}$ 的属性：\n- 状态, $Q_{a^*}$: $N_a$ 的状态加上两个新状态：$\\{q_0, q_1, q_2, q_3\\}$。总计：$2 + 2 = 4$ 个状态。\n- 开始状态：新的开始状态 $q_2$。总计：1 个开始状态。\n- 最终状态：新的最终状态 $q_3$。总计：1 个最终状态。\n- 转移, $\\delta_{a^*}$: $N_a$ 的原始转移加上四个新的 $\\epsilon$-转移。\n    - 原始转移：一个 'a' 转移 ($\\delta(q_0, a) = \\{q_1\\}$)。\n    - 新增转移：四个 $\\epsilon$-转移 ($\\delta(q_2, \\epsilon) = \\{q_0, q_3\\}$ 和 $\\delta(q_1, \\epsilon) = \\{q_0, q_3\\}$)。请注意，某些表示法将它们列为四个独立的有向边。\n    - 转移总数：$1 + 4 = 5$。\n\n**步骤 3：为完整表达式 `(a*)*` 构造 NFA。**\n\n设此自动机为 $N_{(a^*)^*}$。现在我们再次应用克莱尼星号构造，这次是针对我们刚刚构建的自动机 $N_{a^*}$。\n1. 取自动机 $N_{a^*}$。\n2. 添加一个新的开始状态（我们称之为 $q_4$）和一个新的最终状态（我们称之为 $q_5$）。\n3. 添加四个新的 $\\epsilon$-转移，这些转移引用 $N_{a^*}$ 的开始状态（即 $q_2$）和最终状态（即 $q_3$）：\n    - 从新的开始状态 ($q_4$) 到旧的开始状态 ($q_2$) 的转移。\n    - 从旧的最终状态 ($q_3$) 到新的最终状态 ($q_5$) 的转移。\n    - 从新的开始状态 ($q_4$) 直接到新的最终状态 ($q_5$) 的转移。\n    - 从旧的最终状态 ($q_3$) 回到旧的开始状态 ($q_2$) 的转移。\n\n我们来列出最终自动机 $N_{(a^*)^*}$ 的属性：\n- 状态, $Q_{(a^*)^*}$: $N_{a^*}$ 的状态加上两个新状态：$\\{q_0, q_1, q_2, q_3, q_4, q_5\\}$。总计：$4 + 2 = 6$ 个状态。\n- 开始状态：新的开始状态 $q_4$。总计：1 个开始状态。\n- 最终状态：新的最终状态 $q_5$。总计：1 个最终状态。\n- 转移, $\\delta_{(a^*)^*}$: 来自 $N_{a^*}$ 的转移加上四个新的 $\\epsilon$-转移。\n    - 来自 $N_{a^*}$ 的转移：5 个转移。\n    - 新的 $\\epsilon$-转移：4 个转移。\n    - 转移总数：$5 + 4 = 9$。\n\n**最终总结：**\n- 状态总数 = 6。\n- 开始状态数量 = 1。\n- 最终状态数量 = 1。\n- 转移总数 = 9。\n\n得到的属性向量为 (6, 1, 1, 9)。", "answer": "$$\\boxed{\\begin{pmatrix} 6 & 1 & 1 & 9 \\end{pmatrix}}$$", "id": "1379652"}, {"introduction": "现在，你已经准备好将所有学到的规则融会贯通了。最后的这个综合练习要求你为一个更复杂的正则表达式 $(a^*b)|(ba^*)$ 构建一个完整的 NFA。你需要系统性地应用克林尼星号、连接（concatenation）和并集（union）这三种核心构造规则。通过在每一步精确地计算状态和转移的数量，你将深刻体会到这些简单的递归规则是如何为任何正则表达式构建出相应的自动机，无论表达式本身看起来多么复杂。", "problem": "在自动机理论中，Kleene定理（Kleene's theorem）在正则表达式和有限自动机之间建立了根本性的联系。该定理的一个关键部分是一种构造性算法（常称为Thompson构造法），用于将任何正则表达式转换为等价的非确定性有限自动机（Nondeterministic Finite Automaton, NFA）。这种构造是归纳性的，它通过其子表达式的自动机来为复杂表达式构建自动机。\n\n考虑字母表 $\\Sigma = \\{a, b\\}$ 上的两个正则表达式：\n$R_1 = a^* b$\n$R_2 = b a^*$\n\n您的任务是为与正则表达式 $R_1 | R_2$ 对应的语言构造一个NFA。您必须严格遵循入门课程中教授的标准归纳构造方法，我们将其定义如下：\n1.  **基本情况**：对于一个符号 $x \\in \\Sigma$，其NFA有一个开始状态和一个接受状态，两者之间有一条标记为 $x$ 的单一转移。\n2.  **并集（$R|S$）**：给定NFA $N(R)$ 和 $N(S)$，创建一个新的开始状态和一个新的接受状态。从新的开始状态分别向 $N(R)$ 和 $N(S)$ 的开始状态添加Epsilon（$\\epsilon$）转移。也从 $N(R)$ 和 $N(S)$ 的接受状态分别向新的接受状态添加Epsilon转移。\n3.  **连接（$RS$）**：给定NFA $N(R)$ 和 $N(S)$，从 $N(R)$ 的接受状态向 $N(S)$ 的开始状态添加一个epsilon转移。新NFA的开始状态是 $N(R)$ 的开始状态，接受状态是 $N(S)$ 的接受状态。\n4.  **克林尼星号（$R^*$）**：给定一个NFA $N(R)$，创建一个新的开始状态和一个新的接受状态。添加Epsilon转移如下：\n    - 从新的开始状态到 $N(R)$ 的旧开始状态。\n    - 从 $N(R)$ 的旧接受状态到新的接受状态。\n    - 从 $N(R)$ 的旧接受状态回到 $N(R)$ 的旧开始状态（以允许重复）。\n    - 从新的开始状态直接到新的接受状态（以允许空字符串）。\n\n遵循此过程，首先分别为 $R_1$ 和 $R_2$ 构造NFA，然后使用并集构造将它们组合起来。不要对最终生成的自动机进行任何简化、状态约简或移除epsilon转移的操作。\n\n最终为 $R_1 | R_2$ 构造的NFA中总共有多少条转移？一条转移定义为两个状态之间带标签的有向边，标签可以是 $\\Sigma$ 中的符号或 $\\epsilon$。", "solution": "我们被要求计算使用标准Thompson构造法为正则表达式 $(a^* b) | (b a^*)$ 构造的NFA中的总转移数。我们将一步一步地构建这个自动机。\n\n**步骤1：基本情况自动机**\n首先，我们考虑基本符号“a”和“b”的自动机。\n-   “a”的NFA，我们称之为 $N(a)$：它有2个状态（一个开始状态和一个接受状态）和1条标记为“a”的转移。\n-   “b”的NFA，我们称之为 $N(b)$：它也有2个状态和1条标记为“b”的转移。\n\n**步骤2：构造 $a^*$ 的NFA**\n我们将克林尼星号构造法应用于 $N(a)$。\n-   我们从 $N(a)$ 开始，它有2个状态和1条转移。\n-   我们添加一个新的开始状态和一个新的接受状态，总共得到 $2+2=4$ 个状态。\n-   根据规则，我们添加4条新的 $\\epsilon$-转移：\n    1.  新开始状态 $\\to$ 旧开始状态\n    2.  旧接受状态 $\\to$ 新接受状态\n    3.  旧接受状态 $\\to$ 旧开始状态\n    4.  新开始状态 $\\to$ 新接受状态\n-   因此，$a^*$ 的NFA，我们称之为 $N(a^*)$，有4个状态和总共 $1 (\\text{来自 } N(a)) + 4 (\\epsilon\\text{-转移}) = 5$ 条转移。\n\n**步骤3：构造 $R_1 = a^* b$ 的NFA**\n我们将连接构造法应用于 $N(a^*)$ 和 $N(b)$。\n-   $N(a^*)$ 有4个状态和5条转移。\n-   $N(b)$ 有2个状态和1条转移。\n-   连接后的自动机 $N(a^*b)$ 的状态数是各部分状态数之和：$4 + 2 = 6$ 个状态。\n-   该构造会从 $N(a^*)$ 的接受状态向 $N(b)$ 的开始状态添加一条 $\\epsilon$-转移。\n-   $N(a^*b)$ 的总转移数是各组件转移数加上新的连接转移之和：$5 (\\text{来自 } N(a^*)) + 1 (\\text{来自 } N(b)) + 1 (\\epsilon\\text{-转移}) = 7$ 条转移。\n\n**步骤4：构造 $R_2 = b a^*$ 的NFA**\n这与步骤3对称。我们连接 $N(b)$ 和 $N(a^*)$。\n-   $N(b)$ 有2个状态和1条转移。\n-   $N(a^*)$ 有4个状态和5条转移。\n-   连接后的自动机 $N(ba^*)$ 的状态数是 $2 + 4 = 6$ 个状态。\n-   转移数是 $1 (\\text{来自 } N(b)) + 5 (\\text{来自 } N(a^*)) + 1 (\\epsilon\\text{-转移}) = 7$ 条转移。\n\n**步骤5：构造最终的 $(a^* b) | (b a^*)$ 的NFA**\n最后，我们将并集构造法应用于 $N(a^*b)$ 和 $N(ba^*)$。\n-   $N(a^*b)$ 有6个状态和7条转移。\n-   $N(ba^*)$ 有6个状态和7条转移。\n-   并集构造会添加一个新的开始状态和一个新的接受状态。总状态数是 $6 + 6 + 2 = 14$ 个状态。\n-   该构造会添加4条新的 $\\epsilon$-转移：\n    1.  新开始状态 $\\to$ $N(a^*b)$的开始状态\n    2.  新开始状态 $\\to$ $N(ba^*)$的开始状态\n    3.  $N(a^*b)$的接受状态 $\\to$ 新接受状态\n    4.  $N(ba^*)$的接受状态 $\\to$ 新接受状态\n-   最终NFA的总转移数是各组件转移数加上4条新的并集转移之和：\n总转移数 = ($N(a^*b)$中的转移数) + ($N(ba^*)$中的转移数) + 4\n总转移数 = $7 + 7 + 4 = 18$。\n\n因此，最终的NFA共有18条转移。", "answer": "$$\\boxed{18}$$", "id": "1379665"}]}