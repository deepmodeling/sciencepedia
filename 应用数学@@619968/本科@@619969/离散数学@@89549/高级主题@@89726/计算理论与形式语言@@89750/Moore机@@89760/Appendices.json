{"hands_on_practices": [{"introduction": "让我们从一个基础练习开始，这个练习将展示摩尔机如何执行简单的算术运算。我们将设计一个机器来计算输入二进制字符串各位数字之和对 3 的模。通过这个实践 [@problem_id:1386329]，你将清晰地看到如何将机器的每个状态与一个特定的计算结果（即模 $3$ 的余数）直接对应起来，这是理解摩尔机状态与输出关系的关键一步。", "problem": "一个数字通信系统中的组件被设计用于为输入的二进制数据流计算一个运行校验和。该组件被建模为一个摩尔机（Moore machine）。\n\n摩尔机是一种有限自动机，其形式化定义为一个六元组 $(Q, \\Sigma, \\Gamma, \\delta, \\lambda, q_{start})$，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是输入字母表。\n- $\\Gamma$ 是输出字母表。\n- $\\delta: Q \\times \\Sigma \\to Q$ 是转移函数，它根据当前状态和输入符号确定下一个状态。\n- $\\lambda: Q \\to \\Gamma$ 是输出函数，其输出仅取决于当前状态。\n- $q_{start} \\in Q$ 是起始状态。\n\n对于此特定问题，该机器从左到右处理一个二进制数字输入串。在处理任意数量的输入数字后，机器的输出被定义为到目前为止处理的所有数字的总和，以 $3$ 为模计算。机器从对应于空输入串的状态开始（此时总和为0）。\n\n该机器的输入字母表为 $\\Sigma = \\{0, 1\\}$，输出字母表为 $\\Gamma = \\{0, 1, 2\\}$。设机器的状态表示为 $S_0, S_1, S_2$，其中处于状态 $S_i$ 意味着到目前为止处理的所有二进制数字的总和与 $i$ 模 $3$ 同余。起始状态为 $S_0$。\n\n下列哪个选项正确描述了此摩尔机转移函数 $\\delta$ 的一部分？\n\nA. $\\delta(S_1, 1) = S_1$ 且 $\\delta(S_2, 1) = S_2$\n\nB. $\\delta(S_0, 1) = S_1$ 且 $\\delta(S_1, 1) = S_2$\n\nC. $\\delta(S_0, 0) = S_1$ 且 $\\delta(S_1, 0) = S_2$\n\nD. $\\delta(S_1, 1) = S_0$ 且 $\\delta(S_2, 0) = S_0$\n\nE. $\\delta(S_2, 1) = S_1$ 且 $\\delta(S_0, 1) = S_0$", "solution": "根据定义，处于状态 $S_{i}$ 意味着到目前为止处理的位的总和与 $i$ 模 $3$ 同余。当读取一个新的输入位 $a \\in \\{0,1\\}$时，新的总和模 $3$ 变为 $(i + a) \\bmod 3$。因此，转移函数必须满足\n$$\n\\delta(S_{i}, a) = S_{(i+a)\\bmod 3}.\n$$\n具体来说：\n- 对于 $a=0$，对所有 $i$ 都有 $\\delta(S_{i},0)=S_{i}$。\n- 对于 $a=1$，有 $\\delta(S_{0},1)=S_{1}$，$\\delta(S_{1},1)=S_{2}$，以及 $\\delta(S_{2},1)=S_{0}$。\n\n现在逐一检查选项：\n- A选项称 $\\delta(S_{1},1)=S_{1}$ 且 $\\delta(S_{2},1)=S_{2}$，这与 $\\delta(S_{1},1)=S_{2}$ 和 $\\delta(S_{2},1)=S_{0}$ 相矛盾，所以A是错误的。\n- B选项称 $\\delta(S_{0},1)=S_{1}$ 且 $\\delta(S_{1},1)=S_{2}$，这与推导出的转移相符，所以B是正确的。\n- C选项称 $\\delta(S_{0},0)=S_{1}$ 且 $\\delta(S_{1},0)=S_{2}$，但对于 $a=0$ 我们必须有自循环，所以C是错误的。\n- D选项称 $\\delta(S_{1},1)=S_{0}$ 且 $\\delta(S_{2},0)=S_{0}$，两者都与推导出的规则相矛盾，所以D是错误的。\n- E选项称 $\\delta(S_{2},1)=S_{1}$ 且 $\\delta(S_{0},1)=S_{0}$，两者都与推导出的规则相矛盾，所以E是错误的。\n\n因此，正确选项是B。", "answer": "$$\\boxed{B}$$", "id": "1386329"}, {"introduction": "现在，让我们提升一点难度，挑战一个模式识别问题。这个练习要求我们构建一个摩尔机，用于检测输入的二进制流是否严格地由 $0$ 和 $1$ 交替组成。这个任务 [@problem_id:1386354] 的核心在于学习如何设计一个包含“失败状态”的系统——一旦输入序列破坏了交替模式，机器就会进入一个不可恢复的状态。这是设计用于数据验证和语法分析的自动机时一种非常常见且强大的技术。", "problem": "摩尔机（Moore machine）是一种有限自动机，其输出完全由当前状态决定。它由一个六元组 $(Q, \\Sigma, \\Delta, \\delta, \\lambda, q_0)$ 正式定义，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是输入字母表。\n- $\\Delta$ 是输出字母表。\n- $\\delta: Q \\times \\Sigma \\to Q$ 是转移函数。\n- $\\lambda: Q \\to \\Delta$ 是输出函数。\n- $q_0 \\in Q$ 是起始状态。\n\n对于一个输入字符串，机器的输出是所访问状态的输出序列，从初始状态 $q_0$ 的输出开始。\n\n考虑一个设计用于验证数据流的摩尔机。该机器接受来自字母表 $\\Sigma = \\{0, 1\\}$ 的二进制输入字符串，并产生来自字母表 $\\Delta = \\{0, 1\\}$ 的二进制输出。如果到目前为止处理的输入字符串部分是“交替的”，机器必须输出 $1$，否则输出 $0$。一个字符串如果其字符在 $0$ 和 $1$ 之间严格交替，则被定义为“交替的”（例如 `0`, `1`, `01`, `10`, `010`）。空字符串也被认为是交替的。如果一个字符串包含连续相同的字符（例如 `00`, `11`, `100`），则它不是交替的。\n\n以下哪个选项正确定义了这样一台机器的状态 $Q$、起始状态 $q_0$、输出函数 $\\lambda$ 和转移函数 $\\delta$？\n\nA. $Q = \\{S_0, S_1, S_2\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=1, \\lambda(S_1)=1, \\lambda(S_2)=0$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_1$ | $S_1$ |\n| $S_1$ | $S_2$ | $S_2$ |\n| $S_2$ | $S_2$ | $S_2$ |\n\nB. $Q = \\{S_0, S_A, S_B, S_F\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=1, \\lambda(S_A)=1, \\lambda(S_B)=1, \\lambda(S_F)=0$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_F$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_F$ |\n| $S_F$ | $S_F$ | $S_F$ |\n\nC. $Q = \\{S_0, S_A, S_B, S_F\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=0, \\lambda(S_A)=1, \\lambda(S_B)=1, \\lambda(S_F)=0$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_F$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_F$ |\n| $S_F$ | $S_F$ | $S_F$ |\n\nD. $Q = \\{S_0, S_A, S_B\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=1, \\lambda(S_A)=1, \\lambda(S_B)=1$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_0$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_0$ |", "solution": "为了解决这个问题，我们需要确定需要哪些状态来记住到目前为止所见输入字符串的必要信息。机器的输出取决于字符串是否是严格交替的。\n\n让我们分析一个状态必须捕捉的属性：\n1.  初始状态，代表空字符串。问题陈述中说明空字符串是交替的，所以这个状态的输出必须是 $1$。\n2.  字符串是交替的，并且最后一个字符是 $0$。机器需要记住这一点来检查下一个字符是否是 $1$。这个状态的输出必须是 $1$。\n3.  字符串是交替的，并且最后一个字符是 $1$。机器需要记住这一点来检查下一个字符是否是 $0$。这个状态的输出必须是 $1$。\n4.  交替模式已被破坏（例如，出现了 `00` 或 `11`）。一旦模式被破坏，对于任何后续字符，它都将保持破坏状态。这是一个“失败”或“陷阱”状态。这个状态的输出必须是 $0$。\n\n基于此分析，我们可以定义四个不同的状态：\n- $S_0$：初始状态。对应于空字符串。字符串是交替的。输出 $\\lambda(S_0) = 1$。\n- $S_A$：处理一个以 $0$ 结尾的有效交替字符串后达到的状态。字符串是交替的。输出 $\\lambda(S_A) = 1$。\n- $S_B$：处理一个以 $1$ 结尾的有效交替字符串后达到的状态。字符串是交替的。输出 $\\lambda(S_B) = 1$。\n- $S_F$：失败状态。当交替模式被破坏时达到。字符串不是交替的。输出 $\\lambda(S_F) = 0$。\n\n现在，让我们为每个状态 $q$ 和输入 $i$ 定义转移 $\\delta(q, i)$：\n\n- **从状态 $S_0$ (起始状态)：**\n  - 如果输入是 $0$，新字符串是 `0`，它是交替的且以 $0$ 结尾。我们转移到 $S_A$。所以，$\\delta(S_0, 0) = S_A$。\n  - 如果输入是 $1$，新字符串是 `1`，它是交替的且以 $1$ 结尾。我们转移到 $S_B$。所以，$\\delta(S_0, 1) = S_B$。\n\n- **从状态 $S_A$ (交替，以 $0$ 结尾)：**\n  - 如果输入是 $0$，字符串现在以 `00` 结尾。模式被破坏。我们转移到失败状态 $S_F$。所以，$\\delta(S_A, 0) = S_F$。\n  - 如果输入是 $1$，字符串现在以 `01` 结尾。模式得以维持，并且字符串现在以 $1$ 结尾。我们转移到 $S_B$。所以，$\\delta(S_A, 1) = S_B$。\n\n- **从状态 $S_B$ (交替，以 $1$ 结尾)：**\n  - 如果输入是 $0$，字符串现在以 `10` 结尾。模式得以维持，并且字符串现在以 $0$ 结尾。我们转移到 $S_A$。所以，$\\delta(S_B, 0) = S_A$。\n  - 如果输入是 $1$，字符串现在以 `11` 结尾。模式被破坏。我们转移到失败状态 $S_F$。所以，$\\delta(S_B, 1) = S_F$。\n\n- **从状态 $S_F$ (失败状态)：**\n  - 一旦模式被破坏，任何额外的输入都无法修复它。字符串将保持非交替状态。因此，无论输入是什么，机器都应保持在失败状态。\n  - 所以，$\\delta(S_F, 0) = S_F$ 且 $\\delta(S_F, 1) = S_F$。\n\n让我们总结一下我们推导出的机器：\n- $Q = \\{S_0, S_A, S_B, S_F\\}$\n- $q_0 = S_0$\n- 输出函数：$\\lambda(S_0)=1, \\lambda(S_A)=1, \\lambda(S_B)=1, \\lambda(S_F)=0$。\n- 转移函数 $\\delta$：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_F$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_F$ |\n| $S_F$ | $S_F$ | $S_F$ |\n\n现在我们将这个正确的设计与给定的选项进行比较。\n\n- **选项 A：** 这台机器只有3个状态。它将“以 0 结尾”和“以 1 结尾”的状态合并为单个状态 $S_1$。从 $S_1$ 开始，任何输入都会导致进入失败状态 $S_2$。这是不正确的。例如，对于输入 `01`，路径是 $S_0 \\xrightarrow{0} S_1 \\xrightarrow{1} S_2$。字符串 `01` 的输出将是 0（来自状态 $S_2$），但 `01` 是交替的。所以，A 是不正确的。\n\n- **选项 B：** 这个选项在状态、起始状态、输出函数和转移函数方面与我们推导出的机器完全匹配。这是正确选项。\n\n- **选项 C：** 这台机器有正确的状态结构和转移，但输出函数是 $\\lambda(S_0)=0$。这意味着空字符串不是交替的，这与问题陈述相矛盾。所以，C 是不正确的。\n\n- **选项 D：** 这台机器有3个状态，并且没有永久的失败状态。如果接收到一个非交替的输入（例如，在状态 $S_A$ 时输入 `0`），它会转移回起始状态 $S_0$。让我们用字符串 `001` 来测试一下。状态路径是 $S_0 \\xrightarrow{0} S_A \\xrightarrow{0} S_0 \\xrightarrow{1} S_B$。在读取输入后，机器经过状态 $S_A$、$S_0$ 和 $S_B$。对于字符串 `0`、`00` 和 `001` 的输出将是 $\\lambda(S_A)=1$、$\\lambda(S_0)=1$ 和 $\\lambda(S_B)=1$。对于 `00` 的输出应该是 $0$，但在这里是 $1$。因此，这台机器不能正确识别非交替字符串。所以，D 是不正确的。\n\n因此，唯一正确的规范是选项 B。", "answer": "$$\\boxed{B}$$", "id": "1386354"}, {"introduction": "最后一个实践将摩尔机与信号处理中的一个常见概念——延迟线——联系起来。我们将构建一个能够输出两个时间步之前输入信号的机器，这在数字同步器等应用中非常有用。通过这个练习 [@problem_id:1386370]，你将学会如何利用状态来编码和维护一段固定长度的历史输入，从而实现一种有限的“记忆”功能。这突显了有限自动机在处理依赖于近期历史的数据流时的强大能力。", "problem": "需要设计一个摩尔机作为“两步信号同步器”。该机器从左到右逐位读取一个二进制输入字符串。对于任何给定的时间步 $t \\ge 3$，机器的输出必须等于在时间步 $t-2$ 接收到的输入位。对于前两个时间步（$t=1$ 和 $t=2$），来自时间 $t-1$ 和 $t-2$ 的特定输入是不可用的。在这些情况下，机器应产生默认输出0。\n\n机器的状态可以标记为 $S_{ab}$，其中 $a$ 和 $b$ 分别表示在时间 $t-2$ 和 $t-1$ 接收到的输入。机器从一个初始状态开始，该状态对应于假设前两位输入均为0。\n\n机器处理输入字符串 `10110`。在处理完整个字符串后，机器的最终状态是什么，与该最终状态相关联的输出是什么？\n\nA. 最终状态对应于历史'10'，其输出为1。\n\nB. 最终状态对应于历史'10'，其输出为0。\n\nC. 最终状态对应于历史'01'，其输出为0。\n\nD. 最终状态对应于历史'11'，其输出为1。\n\nE. 最终状态对应于历史'00'，其输出为0。", "solution": "我们将摩尔机建模，其状态标记为 $S_{ab}$，其中 $a$ 是时间 $t-2$ 的输入， $b$ 是时间 $t-1$ 的输入。在摩尔机中，输出仅取决于当前状态，因此输出函数为\n$$\nY(S_{ab})=a,\n$$\n这满足了在任何时间 $t \\ge 3$ 输出等于在时间 $t-2$ 接收到的输入的要求。初始状态为 $S_{00}$，以编码两个零的默认历史，确保在 $t=1$ 和 $t=2$ 时的输出为0。\n\n转移函数通过移入新的输入位 $c$ 来更新两位历史：\n$$\nT(S_{ab},c)=S_{bc}.\n$$\n\n我们从 $S_{00}$ 开始，逐步处理输入字符串 $1\\,0\\,1\\,1\\,0$：\n- 读取 $1$ 后：$S_{00} \\xrightarrow{1} S_{01}$。\n- 读取 $0$ 后：$S_{01} \\xrightarrow{0} S_{10}$。\n- 读取 $1$ 后：$S_{10} \\xrightarrow{1} S_{01}$。\n- 读取 $1$ 后：$S_{01} \\xrightarrow{1} S_{11}$。\n- 读取 $0$ 后：$S_{11} \\xrightarrow{0} S_{10}$。\n\n因此，在处理完整个字符串后，最终状态是 $S_{10}$。其关联的摩尔输出是\n$$\nY(S_{10})=1.\n$$\n因此，正确的选项是最终状态对应于历史 $10$ 且其输出为 $1$，这与选项A相符。", "answer": "$$\\boxed{A}$$", "id": "1386370"}]}