{"hands_on_practices": [{"introduction": "从理论到实践的第一步是学习如何将语言的抽象定义转化为具体的计算模型。本练习将指导你为一个特定语言 $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$ 构建一个下推自动机（PDA）。这个过程的关键在于利用栈来“计数”：我们为每个读入的符号 'a' 推入两个符号，然后为每个读入的 'b' 弹出一个符号，从而精确地匹配语言的 $1:2$ 比例要求。通过这个练习 [@problem_id:1359997]，你将掌握将计数关系编码到 PDA 状态转移和栈操作中的核心技能。", "problem": "您是一名工程师，正在为一种新的数据流协议设计一个验证组件。该协议以两种信号“a”和“b”的序列形式传输数据。一个流被认为是有效的，当且仅当它由一个或多个“a”信号组成的块，后跟一个“b”信号组成的块，其中“b”信号的数量恰好是“a”信号数量的两倍。这对应于语言 $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$。\n\n您的任务是为一个下推自动机（PDA）指定逻辑，这是一种带有栈的计算模型，用以识别该语言。一个PDA由一个七元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$ 形式化定义。\n\n所提议的PDA具有以下组件：\n- 一个状态集 $Q = \\{q_0, q_1, q_2\\}$，其中 $q_0$ 是初始状态，$q_1$ 是一个中间状态，$q_2$ 是唯一的接受状态。\n- 一个输入字母表 $\\Sigma = \\{a, b\\}$。\n- 一个栈字母表 $\\Gamma = \\{S, Z_0\\}$，其中 $Z_0$ 是栈上的初始符号。\n- 初始状态是 $q_0$。\n- 终止状态集是 $F = \\{q_2\\}$。\n\nPDA的核心逻辑由其转移函数 $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\times \\Gamma \\to \\mathcal{P}(Q \\times \\Gamma^*)$ 定义，其中 $\\epsilon$ 表示空字符串，$\\mathcal{P}$ 表示幂集。一个转移 $\\delta(q, x, Y) = \\{(p, \\gamma)\\}$ 意味着，如果PDA处于状态 $q$，读取输入符号 $x$，并且栈顶符号为 $Y$，那么它可以转移到状态 $p$ 并将 $Y$ 替换为符号串 $\\gamma$。\n\n下列哪一个转移函数 $\\delta$ 的定义能使该PDA正确识别语言 $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$？\n\nA.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SS)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nB.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SSZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SSS)\\}$\n$\\delta(q_0, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n\nC.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SSZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SSS)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nD.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SSZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SSS)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, \\epsilon, S) = \\{(q_2, S)\\}$", "solution": "我们必须设计并验证一个下推自动机，该自动机通过终止状态恰好接受语言 $L=\\{a^{n}b^{2n}\\mid n\\ge 1\\}$ 中的字符串，使用栈字母表 $\\{S,Z_{0}\\}$，且 $Z_{0}$ 初始时位于栈上。\n\n语言 $L$ 所需的关键计数不变量是：在读取 $n$ 个前导 $a$ 之后，栈必须在 $Z_{0}$ 上方恰好包含 $2n$ 个 $S$ 的副本，即 $S^{2n}Z_{0}$；在随后的 $b$ 块期间，每个 $b$ 必须恰好弹出一个 $S$；当输入被完全消耗且栈返回到 $Z_{0}$ 时（通过一个合适的 $\\epsilon$ 转移到终止状态），PDA应当恰好接受该字符串。从读取 $a$ 到读取 $b$ 的转换必须是单向的（在任何 $b$ 之后不能有 $a$），这通常通过在遇到第一个 $b$ 时从 $q_0$ 转移到 $q_1$ 来强制实现。\n\n通过追踪为 $a$ 推入和为 $b$ 弹出的 $S$ 的数量，并检查接受条件，来分析每个选项。\n\n选项 A:\n- $\\delta(q_{0},a,Z_{0})=(q_{0},SZ_{0})$ 在第一个 $a$ 时推入一个 $S$。\n- $\\delta(q_{0},a,S)=(q_{0},SS)$ 将 $S$ 替换为 $SS$，每个额外的 $a$ 净增加一个 $S$。\n因此，在 $n$ 个 $a$ 之后，栈为 $S^{n}Z_{0}$（只有 $n$ 个 $S$ 的副本）。对于 $b$：\n- $\\delta(q_{0},b,S)=(q_{1},\\epsilon)$ 在第一个 $b$ 时弹出一个 $S$ 并切换到 $q_1$。\n- $\\delta(q_{1},b,S)=(q_{1},\\epsilon)$ 继续为每个 $b$ 弹出一个 $S$。\n最后，$\\delta(q_{1},\\epsilon,Z_{0})=(q_{2},Z_{0})$ 允许在输入被消耗完且栈顶为 $Z_0$ 时接受。因此，该自动机恰好接受字符串 $a^{n}b^{n}$，而不是 $a^{n}b^{2n}$。选项 A 不正确。\n\n选项 B:\n- $\\delta(q_{0},a,Z_{0})=(q_{0},SSZ_{0})$ 在第一个 $a$ 时推入两个 $S$。\n- $\\delta(q_{0},a,S)=(q_{0},SSS)$ 将 $S$ 替换为 $SSS$，每个额外的 $a$ 净增加两个 $S$。\n因此，在 $n$ 个 $a$ 之后，栈为 $S^{2n}Z_{0}$，符合要求。对于 $b$：\n- $\\delta(q_{0},b,S)=(q_{1},\\epsilon)$ 然后 $\\delta(q_{1},b,S)=(q_{1},\\epsilon)$ 为每个 $b$ 弹出一个 $S$。\n然而，接受是通过终止状态 $q_2$ 实现的，而给定的唯一到 $q_2$ 的 $\\epsilon$ 转移是 $\\delta(q_{0},\\epsilon,Z_{0})=(q_{2},Z_{0})$，这会导致：\n1) 错误地接受了空字符串（输入为空，在初始时栈顶为 $Z_0$），违反了 $n\\ge 1$ 的条件。\n2) 在消耗了 $2n$ 个 $b$ 之后，当栈返回到 $Z_0$ 时，没有从 $q_1$ 到接受状态的转移。因此，有效的字符串将被拒绝。选项 B 不正确。\n\n选项 C:\n- $\\delta(q_{0},a,Z_{0})=(q_{0},SSZ_{0})$ 和 $\\delta(q_{0},a,S)=(q_{0},SSS)$ 确保在 $n$ 个 $a$ 之后，栈为 $S^{2n}Z_{0}$。\n- $\\delta(q_{0},b,S)=(q_{1},\\epsilon)$ 在第一个 $b$ 时转移到 $q_1$ 并弹出一个 $S$；$\\delta(q_{1},b,S)=(q_{1},\\epsilon)$ 继续为每个 $b$ 弹出一个 $S$。\n- 当所有 $2n$ 个 $S$ 都被弹出后，栈顶是 $Z_0$。转移 $\\delta(q_{1},\\epsilon,Z_{0})=(q_{2},Z_{0})$ 允许在输入被完全消耗且栈已返回到 $Z_0$ 状态时，恰好转移到接受状态。\n这种构造保证了：\n1) 每个 $a$ 恰好推入两个 $S$，因此在 $n$ 个 $a$ 之后有 $2n$ 个 $S$。\n2) 每个 $b$ 恰好弹出一个 $S$，因此只有在精确读取 $2n$ 个 $b$ 之后才可能接受。\n3) 在 $q_1$ 中没有关于 $a$ 的转移，这防止了在第一个 $b$ 之后出现任何 $a$。\n4) 从 $q_0$ 和 $Z_0$ 开始没有 $\\epsilon$ 接受转移，因此空字符串不被接受；至少需要一个 $a$ 在栈顶产生一个 $S$，以便可以读取一个 $b$。\n因此，选项 C 正确地识别了语言 $L$。\n\n选项 D:\n与选项 C 相同，只是接受的 $\\epsilon$ 转移是 $\\delta(q_{1},\\epsilon,S)=(q_{2},S)$，即它允许在栈上仍有 $S$ 时转移到接受状态。对于一个输入 $a^{n}b^{m}$ 且 $m<2n$，在消耗完所有输入后，我们处于状态 $q_1$ 且栈顶为 $S$，此时可以进行 $\\epsilon$ 转移到 $q_2$，因此会错误地接受 $b$ 过少的字符串。选项 D 不正确。\n\n因此，正确的选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1359997"}, {"introduction": "确定性计算并不能解决所有问题。这个练习 [@problem_id:1360031] 引入了非确定性的强大概念，这是上下文无关语言理论中的一个基石。我们将挑战一个看似简单的语言 $L = \\{ a^i b^j \\mid i \\neq j \\}$，它的识别在确定性模型下会很棘手。通过设计一个非确定性下推自动机（NPDA），你将学会如何利用“猜测”来将一个复杂问题分解为多个更简单的子问题（$i > j$ 或 $i < j$），并为每个子问题设计一条独立的接受路径。", "problem": "一个简化的网络协议被设计用于验证数据包序列。数据包有两种类型，A型和B型。一个有效的传输序列必须首先包含零个或多个A型数据包，后跟零个或多个B型数据包。令 'a' 代表一个A型数据包，'b' 代表一个B型数据包。核心验证规则是A型数据包的总数不能等于B型数据包的总数。因此，所有有效序列的语言 $L$ 是 $L = \\{ a^i b^j \\mid i \\geq 0, j \\geq 0, \\text{ and } i \\neq j \\}$。\n\n这种语言可以被下推自动机（Pushdown Automaton, PDA）识别，这是一种使用栈作为存储器的计算模型。以下哪种描述准确地刻画了接受语言 $L$ 的非确定性下推自动机的逻辑？\n\nA. 该PDA确定性地为每个 'a' 将一个符号压入栈，为每个 'b' 弹出一个符号。如果在读取整个输入字符串后，栈不为空，则接受。\n\nB. 该PDA使用有限数量的状态来计算 'a' 和 'b' 的数量，并在最终计数不相等时接受。不需要栈。\n\nC. 该PDA为每个 'a' 压入一个符号。当开始读取 'b' 时，它为每个 'b' 弹出一个符号。当且仅当处理最后一个 'b' 时栈恰好为空，该PDA才接受该字符串。\n\nD. 该PDA非确定性地选择两条路径之一。在第一条路径中，它为每个 'a' 压入一个符号，为每个 'b' 弹出一个符号，并在输入被消耗完且栈不为空时接受。在第二条路径中，它为 'a' 压栈并为 'b' 弹栈，并在输入中仍有 'b' 未读取时栈变为空的情况下接受。该PDA还处理 $i=0, j>0$ 或 $i>0, j=0$ 的情况。", "solution": "我们得到的语言是 $L=\\{a^{i}b^{j}\\mid i\\geq 0,\\ j\\geq 0,\\ i\\neq j\\}$，即所有由若干个 $a$ 后跟若干个 $b$ 组成的字符串，且其数量不相等。这包括 $i>j$ 和 $i<j$ 的情况，也包括 $i=0<j$ 和 $j=0<i$，但不包括 $i=j$，特别是不包括空字符串。\n\n我们根据识别 $L$ 的PDA的要求来分析每个选项。\n\n1) 选项A：确定性地为每个 $a$ 压入一个栈符号，为每个 $b$ 弹出一个，并在消耗完整个输入后如果栈不为空则接受。\n- 这种行为会接受 $i>j$ 的字符串，因为在末尾有剩余的栈符号，这与 $i>j$ 时 $i\\neq j$ 的情况一致。\n- 然而，对于 $i<j$ 的情况，在弹出 $i$ 个符号后，当栈到达其底部标记时，机器需要对一个 $b$ 进行弹出操作。在一个只对 $b$ 进行弹出操作的确定性设计中，它无法继续进行，因此会拒绝。因此，带有 $i<j$ 的字符串（必须被接受）将被拒绝。所以选项A无法接受所有 $L$ 中的字符串。\n\n2) 选项B：使用有限数量的状态来计算 $i$ 和 $j$ 并比较它们，不使用栈。\n- 这断言了该语言是正则的。考虑\n$$\n\\overline{L}\\cap a^{*}b^{*}=\\{a^{n}b^{n}\\mid n\\geq 0\\}.\n$$\n如果 $L$ 是正则的, 那么 $\\overline{L}$ 也是正则的, 并且由于 $a^{*}b^{*}$ 是正则的, $\\overline{L}\\cap a^{*}b^{*}$ 也将是正则的。但是 $\\{a^{n}b^{n}\\mid n\\geq 0\\}$ 不是正则的。这是一个矛盾。因此 $L$ 不是正则语言，不能被没有栈的有限自动机识别。所以选项B是错误的。\n\n3) 选项C：为每个 $a$ 压栈，为每个 $b$ 弹栈，当且仅当处理最后一个 $b$ 时栈恰好为空才接受。\n- 这是用于 $\\{a^{n}b^{n}\\mid n\\geq 0\\}$ 的标准PDA，也就是说，它在 $i=j$ 时接受。\n- 我们的语言要求 $i\\neq j$，所以这是互补的条件，是错误的。因此选项C是错误的。\n\n4) 选项D：非确定性地选择两条路径之一：\n- 路径1猜测 $i>j$：为每个 $a$ 压入一个符号，为每个 $b$ 弹出一个，并要求当输入完全被消耗时栈不为空；这强制了 $i>j$ 并拒绝了 $i\\leq j$。这会接受所有 $i>j$ 的字符串，包括 $j=0<i$。\n- 路径2猜测 $i<j$：为每个 $a$ 压入一个符号，为每个 $b$ 弹出一个，并在栈变为空且输入中仍有 $b$ 未读取时立即接受。这确保了 $b$ 的数量严格多于 $a$ 的数量，即 $i<j$。一个标准的实现是使用栈底标记来检测栈是否为空；在某个 $b$ 上弹出最后一个代表 $a$ 的标记后，它会转换到一个接受子程序，该子程序会消耗掉剩余的 $b$。这也通过在开始时非确定性地走这条路径（或立即检测到栈空）并消耗至少一个 $b$ 来适应 $i=0<j$ 的情况。空字符串 $i=j=0$ 会被拒绝，因为两条路径的接受条件都无法满足。\n\n这种非确定性的分支精确地覆盖了 $i>j$ 或 $i<j$ 的情况，并遵守了 $a^{*}b^{*}$ 的要求形式，同时拒绝了 $i=j$。因此，选项D正确地描述了用于语言 $L$ 的非确定性PDA。\n\n因此，正确选项是D。", "answer": "$$\\boxed{D}$$", "id": "1360031"}, {"introduction": "在形式语言理论中，描述一个集合的“补集”往往比描述集合本身更具挑战性。本练习 [@problem_id:1360018] 要求你为所有不是非空偶数长度回文串的二进制串设计一个上下文无关文法（CFG）。这个任务的关键在于思维的转变：我们不是去“排除”回文串，而是直接、创造性地去“生成”所有非回文串。你需要思考一个字符串不满足回文性质的根本原因（例如，长度为奇数，或存在一个不对称的位置），并将这些结构性特征转化为文法的产生式规则。", "problem": "考虑字母表 $\\Sigma = \\{0, 1\\}$。一个非空的偶数长度回文串是形如 $ww^R$ 的字符串，其中 $w$ 是 $\\Sigma^+$ 中的一个非空字符串，而 $w^R$ 是 $w$ 的反转。\n\n令 $L$ 为所有 **不是** 非空偶数长度回文串的 $\\Sigma$ 上的二进制字符串的语言。换句话说，$L = \\{x \\in \\{0,1\\}^* \\mid x \\neq ww^R \\text{ for any } w \\in \\{0,1\\}^+\\}$。\n\n以下哪个上下文无关文法（CFG）能生成语言 $L$？\n\n在所有选项中，开始符号是 $S$。非终结符用大写字母表示，终结符用 '0' 和 '1' 表示。符号 $\\epsilon$ 表示空字符串。非终结符 $E$ 由规则集 $E \\rightarrow 00E \\mid 01E \\mid 10E \\mid 11E \\mid \\epsilon$ 一致定义，该规则集生成所有偶数长度的字符串。\n\nA.\n$S \\rightarrow 0S1 \\mid 1S0 \\mid 0E \\mid 1E \\mid \\epsilon$\n\nB.\n$S \\rightarrow 0S0 \\mid 1S1 \\mid T$\n$T \\rightarrow 0T1 \\mid 1T0 \\mid \\epsilon$\n\nC.\n$S \\rightarrow T \\mid O \\mid \\epsilon$\n$O \\rightarrow 0E \\mid 1E$\n$T \\rightarrow 0T0 \\mid 1T1 \\mid 0E1 \\mid 1E0$\n\nD.\n$S \\rightarrow 0S0 \\mid 1S1 \\mid 0 \\mid 1 \\mid \\epsilon$\n\nE.\n$S \\rightarrow 0S0 \\mid 1S1 \\mid M$\n$M \\rightarrow 0A1 \\mid 1A0$\n$A \\rightarrow 0A \\mid 1A \\mid \\epsilon$", "solution": "我们必须精确地描述目标语言的特征。令 $\\Sigma=\\{0,1\\}$ 且令 $P=\\{ww^{R}\\mid w\\in\\Sigma^{+}\\}$ 为非空偶数长度回文串的集合。所讨论的语言是\n$$\nL=\\Sigma^{*}\\setminus P,\n$$\n即所有不是形如 $ww^{R}$（其中 $w\\neq\\epsilon$）的二进制字符串。等价地，$L$ 包含：\n- 所有奇数长度的字符串，\n- 所有不是回文串的偶数长度字符串，\n- 以及 $\\epsilon$（因为 $\\epsilon\\notin P$）。\n\n我们逐一分析每个文法。\n\n选项 A：$S\\rightarrow 0S1\\mid 1S0\\mid 0E\\mid 1E\\mid \\epsilon$。产生式 $0E$ 和 $1E$ 生成所有奇数长度的字符串，并且也生成了 $\\epsilon$。包裹规则 $0S1$ 和 $1S0$ 总是在两端放置不同的符号。通过对推导过程进行归纳，任何使用这些包裹规则派生出的偶数长度字符串的首尾符号必定不同（基础情况 $\\epsilon$ 在一次包裹下产生 $01$ 或 $10$；进一步的包裹会保持首尾不匹配的特性）。因此，A 无法生成首尾符号相同的偶数长度非回文串（例如 $0010$）。所以 A 不能生成整个语言 $L$。\n\n选项 B：\n$S\\rightarrow 0S0\\mid 1S1\\mid T$, $T\\rightarrow 0T1\\mid 1T0\\mid \\epsilon$。\n这里 $S\\Rightarrow 0S0\\Rightarrow\\cdots$ 可以产生像 $00,0000,\\ldots$ 这样的字符串，这些都是偶数长度的回文串。由于 $P\\subseteq L^{c}$，生成任何来自 $P$ 的字符串都不符合要求。因此 B 的语言不是 $L$。\n\n选项 D：$S\\rightarrow 0S0\\mid 1S1\\mid 0\\mid 1\\mid \\epsilon$。这是一个生成所有回文串（包括偶数和奇数长度，以及 $\\epsilon$）的标准文法。因此，它生成了 $P$ 以及更多字符串（奇数长度的回文串），而不是补集 $L$。\n\n选项 E：\n$S\\rightarrow 0S0\\mid 1S1\\mid M$, $M\\rightarrow 0A1\\mid 1A0$, $A\\rightarrow 0A\\mid 1A\\mid \\epsilon$。\n这里 $A$ 生成 $\\Sigma^{*}$，所以 $M$ 生成所有首尾符号不匹配的字符串。通过 $0S0$ 或 $1S1$ 在两端包裹相同的符号可以保持非回文串的特性，并产生许多非回文串；然而，$S$ 没有生成 $\\epsilon$、$0$ 或 $1$ 的产生式。因此它无法生成 $\\epsilon$，$0$ 和 $1$，而这些都必须在 $L$ 中。所以 E 的语言不是 $L$。\n\n选项 C：\n$S\\rightarrow T\\mid O\\mid \\epsilon$, $O\\rightarrow 0E\\mid 1E$, $T\\rightarrow 0T0\\mid 1T1\\mid 0E1\\mid 1E0$，其中 $E$ 恰好生成所有偶数长度的字符串。\n\n我们来证明 $L(C)=L$。\n\n1) $L(C)\\subseteq L$:\n- $S\\Rightarrow \\epsilon$ 得到 $\\epsilon\\in L$（这是允许的）。\n- 从 $S\\Rightarrow O$ 派生出的字符串，即由 $0E\\mid 1E$ 生成的，都是奇数长度的字符串。这些字符串都在 $L$ 中，因为 $P$ 只包含具有非空部分的偶数长度回文串。\n- 从 $S\\Rightarrow T$ 派生出的字符串。产生式 $0E1$ 和 $1E0$ 生成首尾不匹配的偶数长度字符串；这类字符串不可能是回文串，所以它们在 $L$ 中。产生式 $0T0$ 和 $1T1$ 在一个已在 $L(T)$ 中的字符串两端包裹相同的符号。如果内部字符串不是回文串，在两端添加相同的符号不可能使其成为回文串：一个首尾符号相同的回文串，其内部也必须是回文串。因此，由 $T$ 派生的每个字符串都是一个偶数长度的非回文串。因此 $L(T)\\subseteq L$。综上，由 C 生成的所有字符串都在 $L$ 中。\n\n2) $L\\subseteq L(C)$:\n- 令 $x\\in L$。如果 $x=\\epsilon$，则 $S\\Rightarrow \\epsilon$ 可生成它。\n- 如果 $|x|$ 是奇数，则 $x$ 可由 $O$ 生成，因为规则 $O \\rightarrow 0E \\mid 1E$ 中的 $E$ 可生成任意偶数长度的字符串，从而 $O$ 可生成任意奇数长度的字符串。\n- 如果 $|x|$ 是偶数且 $x$ 不是回文串，则考虑从外向内逐对剥离相同的首尾符号。形式上，可将 $x$ 写为 $x=a_{1}\\cdots a_{k}\\, y\\, a_{k}\\cdots a_{1}$，其中 $k \\ge 0$，且剩余的核心 $y$ 要么为空，要么首尾符号不同。由于 $x$ 不是回文串，这个过程不能以 $y=\\epsilon$ 结束；它必须在某个阶段停止，得到一个非空的核心 $y=bzc$，其中 $b\\neq c$ 是核心的首尾符号。因为 $|x|$ 是偶数，并且我们从两端剥离了相同数量的符号，所以核心 $|y|$ 的长度也是偶数。于是 $y$ 的形式为 $0z1$ 或 $1z0$，其中 $z$ 的长度为偶数。因为 $E$ 生成所有偶数长度的字符串，所以 $z$ 可由 $E$ 生成。因此，$y$ 可由产生式 $T \\rightarrow 0E1$ 或 $T \\rightarrow 1E0$ 生成，故 $y \\in L(T)$。将被剥离的符号串 $a_{1}\\cdots a_{k}$ 重新加回 $y$ 的两端，这个过程正对应于从 $y$ 开始，通过反复应用产生式 $T \\rightarrow 0T0$ 或 $T \\rightarrow 1T1$ 来生成 $x$。因此 $x \\in L(T)$。所以，所有偶数长度的非回文串都属于 $L(T)$，从而也属于 $L(C)$。\n\n综合两个方向的证明，$L(C)=L$。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1360018"}]}