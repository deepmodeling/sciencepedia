{"hands_on_practices": [{"introduction": "掌握下推自动机的第一步是理解如何解读其形式化定义并追踪其在输入字符串上的执行过程。本练习提供一个具体的下推自动机，让你扮演机器的角色，通过手动模拟其行为——跟踪状态、读取输入和操作堆栈——来获得对各组件如何协同工作的直观感受。这项基础技能对于分析和设计更复杂的自动机至关重要。[@problem_id:1394348]", "problem": "一个下推自动机 (Pushdown Automaton, PDA) 被形式化定义为一个七元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$。考虑下面定义的具体 PDA $M$：\n-   $Q = \\{q_0, q_1, q_2\\}$ 是状态集合。\n-   $\\Sigma = \\{a, b, c\\}$ 是输入字母表。\n-   $\\Gamma = \\{X, Z_0\\}$ 是堆栈字母表。\n-   $q_0$ 是起始状态。\n-   $Z_0$ 是初始堆栈符号。\n-   $F = \\{q_2\\}$ 是终止（接受）状态集合。\n-   $\\delta$ 是转移函数，由以下规则定义：\n    1.  $\\delta(q_0, a, Z_0) = \\{(q_0, XXZ_0)\\}$\n    2.  $\\delta(q_0, a, X) = \\{(q_0, XXX)\\}$\n    3.  $\\delta(q_0, c, X) = \\{(q_1, X)\\}$\n    4.  $\\delta(q_1, b, X) = \\{(q_1, \\epsilon)\\}$\n    5.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\n此处，一个转移规则 $\\delta(q_i, \\sigma, A) = \\{(q_j, B)\\}$ 意味着如果机器处于状态 $q_i$，读取输入符号 $\\sigma$，并且堆栈顶部是 $A$，那么它可以转移到状态 $q_j$ 并将堆栈上的 $A$ 替换为 $B$。输入符号 $\\epsilon$ 表示空字符串（该转移在不消耗输入符号的情况下发生），而替换字符串 $\\epsilon$ 表示一个弹出操作（该符号从堆栈中移除，不压入任何东西）。\n\n找出一个能被此 PDA $M$ 接受的非空字符串。", "solution": "我们分析每个转移的效果。在状态 $q_{0}$，当堆栈顶部是 $Z_{0}$ 时读取一个 $a$ 会应用 $\\delta(q_{0}, a, Z_{0})=(q_{0}, XXZ_{0})$，压入两个 $X$ 符号。对于后续的 $a$ 符号，若堆栈顶部为 $X$，$\\delta(q_{0}, a, X)=(q_{0}, XXX)$ 将顶部的 $X$ 替换为 $XXX$，使每个 $a$ 增加两个 $X$。因此，在 $q_{0}$ 状态下读取 $n\\geq 1$ 个 $a$ 后，堆栈在 $Z_{0}$ 上方存有 $2n$ 个 $X$。当堆栈顶部为 $X$ 时读取 $c$ 会执行 $\\delta(q_{0}, c, X)=(q_{1}, X)$，切换到状态 $q_{1}$ 而不改变堆栈。在 $q_{1}$ 中，每个堆栈顶部为 $X$ 时读取的 $b$ 会应用 $\\delta(q_{1}, b, X)=(q_{1}, \\epsilon)$，弹出一个 $X$。在读取了正好 $2n$ 个 $b$ 之后，堆栈顶部变为 $Z_{0}$，此时 $\\epsilon$-转移 $\\delta(q_{1}, \\epsilon, Z_{0})=(q_{2}, Z_{0})$ 会将状态转移到接受状态 $q_{2}$。因此，该 PDA 接受的语言是 $\\{a^{n}cb^{2n} \\mid n \\ge 1\\}$，所以一个具体的非空被接受字符串是 $acbb$（$n=1$ 的情况）。\n\n我们现在使用瞬时描述 $(\\text{状态}, \\text{剩余输入}, \\text{堆栈})$ 给出 $w=acbb$ 的显式计算过程，其中堆栈顶部在左侧：\n$$(q_{0}, acbb, Z_{0}) \\vdash (q_{0}, cbb, XXZ_{0}) \\quad\\text{根据 }\\delta(q_{0}, a, Z_{0})=(q_{0}, XXZ_{0})$$,\n$$(q_{0}, cbb, XXZ_{0}) \\vdash (q_{1}, bb, XXZ_{0}) \\quad\\text{根据 }\\delta(q_{0}, c, X)=(q_{1}, X)$$,\n$$(q_{1}, bb, XXZ_{0}) \\vdash (q_{1}, b, XZ_{0}) \\quad\\text{根据 }\\delta(q_{1}, b, X)=(q_{1}, \\epsilon)$$,\n$$(q_{1}, b, XZ_{0}) \\vdash (q_{1}, \\epsilon, Z_{0}) \\quad\\text{根据 }\\delta(q_{1}, b, X)=(q_{1}, \\epsilon)$$,\n$$(q_{1}, \\epsilon, Z_{0}) \\vdash (q_{2}, \\epsilon, Z_{0}) \\quad\\text{根据 }\\delta(q_{1}, \\epsilon, Z_{0})=(q_{2}, Z_{0})$$.\n由于 $q_{2}\\in F$ 并且输入已耗尽，所以 $acbb$ 被接受。", "answer": "$$\\boxed{acbb}$$", "id": "1394348"}, {"introduction": "在学会追踪一个给定的自动机后，下一步自然就是亲手设计一个。本练习要求你为特定语言 $L = \\{a^n b^{n+1}\\}$ 构建一个下推自动机，通过从给定选项中选择正确的转换规则来完成设计。这项引导式任务能帮助你从算法层面思考如何利用堆栈来实施语言的结构性约束，例如符号的计数与匹配。[@problem_id:1394394]", "problem": "考虑在字母表 $\\Sigma = \\{a, b\\}$ 上定义的语言 $L = \\{a^n b^{n+1} \\mid n \\ge 0\\}$。我们希望构造一个通过最终状态接受该语言的下推自动机 (Pushdown Automaton, PDA)。\n\n一个 PDA 由一个 7 元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$ 形式化定义。对于此问题，各组成部分固定如下：\n- 状态集合 $Q = \\{q_0, q_1, q_2\\}$\n- 输入字母表 $\\Sigma = \\{a, b\\}$\n- 堆栈字母表 $\\Gamma = \\{A, Z_0\\}$\n- 初始状态为 $q_0$\n- 初始堆栈符号为 $Z_0$\n- 最终（接受）状态集合 $F = \\{q_2\\}$\n\n转移定义为 $\\delta(\\text{current\\_state}, \\text{input\\_symbol}, \\text{stack\\_top}) = \\{(\\text{next\\_state}, \\text{string\\_to\\_push})\\}$。符号 $\\epsilon$ 表示空字符串。\n\n下列哪一个转移函数 $\\delta$ 的定义正确地指定了一个接受语言 $L$ 的 PDA？\n\nA.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, \\epsilon)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_1, \\epsilon)\\}$\n6.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nB.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, b, Z_0) = \\{(q_1, Z_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, A)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_1, \\epsilon)\\}$\n6.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nC.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, b, Z_0) = \\{(q_1, AZ_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, AA)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_1, \\epsilon)\\}$\n6.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nD.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, b, Z_0) = \\{(q_1, Z_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, A)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_2, \\epsilon)\\}$\n6.  $\\delta(q_2, b, A) = \\{(q_2, \\epsilon)\\}$", "solution": "我们需要一个 PDA，它通过最终状态来精确接受语言 $L = \\{a^{n} b^{n+1} \\mid n \\ge 0\\}$ 中的字符串。该 PDA 定义在字母表 $\\Sigma = \\{a,b\\}$ 上，其堆栈字母表为 $\\Gamma = \\{A, Z_{0}\\}$，初始状态为 $q_{0}$，初始堆栈符号为 $Z_{0}$，接受状态集为 $F = \\{q_{2}\\}$。一个标准的构造方法使用以下不变式驱动策略：在状态 $q_{0}$ 中读取 $a$ 时，为每个 $a$ 推入一个 $A$，因此在读取 $a^{n}$ 之后，堆栈为 $A^{n} Z_{0}$。当看到第一个 $b$ 时，转移到一个新状态 $q_{1}$，但不对第一个 $b$ 执行弹出操作；这对应了 $b^{n+1}$ 所需的那个额外的 $b$。然后，对于每个后续的 $b$，弹出一个 $A$。当所有的 $A$ 都被弹出后，堆栈顶部是 $Z_{0}$。此时，当且仅当第一个 $b$ 之后的 $b$ 的数量等于 $a$ 的数量时，输入必须被耗尽，然后我们通过一个 $\\epsilon$-转移到最终状态 $q_{2}$ 来接受。在第一个 $b$ 之后不允许出现 $a$，因此从 $q_{1}$ 不应有关于 $a$ 的转移。\n\n选项 B 精确地实现了这个计划：\n1. $\\delta(q_{0}, a, Z_{0}) = \\{(q_{0}, A Z_{0})\\}$ 在第一个 $a$ 上推入 $A$。\n2. $\\delta(q_{0}, a, A) = \\{(q_{0}, A A)\\}$ 在每个后续的 $a$ 上推入 $A$。\n3. $\\delta(q_{0}, b, Z_{0}) = \\{(q_{1}, Z_{0})\\}$ 当 $n = 0$ 时，消耗第一个 $b$ 并转移到 $q_{1}$，不进行弹出或推入操作。\n4. $\\delta(q_{0}, b, A) = \\{(q_{1}, A)\\}$ 当 $n \\ge 1$ 时，消耗第一个 $b$ 并转移到 $q_{1}$，不进行弹出操作（这对应了那个额外的 $b$）。\n5. $\\delta(q_{1}, b, A) = \\{(q_{1}, \\epsilon)\\}$ 为每个后续的 $b$ 弹出一个 $A$。\n6. $\\delta(q_{1}, \\epsilon, Z_{0}) = \\{(q_{2}, Z_{0})\\}$ 当堆栈顶部是 $Z_{0}$ 且输入耗尽时，通过最终状态精确地接受。\n\n选项 B 精确接受 $L$ 的正确性证明：\n- 对于任何 $w \\in L$，令 $w = a^{n} b^{n+1}$。在 $q_{0}$ 中读取 $a^{n}$ 后，堆栈为 $A^{n} Z_{0}$。下一个符号是第一个 $b$，此时应用规则 3（如果 $n = 0$）或规则 4（如果 $n \\ge 1$），转移到 $q_{1}$ 并且堆栈保持不变。此时还剩下 $n$ 个 $b$。这 $n$ 个 $b$ 中的每一个都会触发规则 5，弹出一个 $A$。在这 $n$ 个 $b$ 之后，堆栈为 $Z_{0}$ 且输入已耗尽。然后应用规则 6，转移到 $q_{2}$，字符串被最终状态接受。\n- 反之，假设 PDA 接受某个输入。到达 $q_{2}$ 的唯一方法是通过规则 6，从 $q_{1}$ 且堆栈顶部为 $Z_{0}$ 时转移。进入 $q_{1}$ 的唯一方法是在 $q_{0}$ 中读取一个 $b$（规则 3 或 4），因此输入的形式为 $a^{n} b^{m}$，其中 $m \\ge 1$，且在第一个 $b$ 之后不能出现 $a$，因为从 $q_{1}$ 没有关于 $a$ 的转移。在 $q_{1}$ 中，唯一消耗输入的转移是规则 5，它要求在第一个 $b$ 之后为每个 $b$ 弹出一个 $A$。由于离开 $q_{0}$ 时堆栈上恰好有 $n$ 个 $A$，因此在堆栈返回到 $Z_{0}$ 之前，恰好可以消耗 $n$ 个后续的 $b$。此时，对于 $Z_{0}$ 没有关于 $b$ 的转移，所以输入必须已耗尽；然后应用规则 6。因此，$b$ 的总数恰好是 $1 + n$，被接受的字符串恰好是 $a^{n} b^{n+1}$。\n\n所有其他选项都失败了：\n- 选项 A 错误地包含了 $\\delta(q_{0}, \\epsilon, Z_{0}) = \\{(q_{2}, Z_{0})\\}$，它会接受空字符串，而空字符串不在 $L$ 中；它也无法接受 $n=0$ 时的 $b$。\n- 选项 C 在第一个 $b$ 上推入一个 $A$，因此它会拒绝 $b$（即 $n=0$ 的情况），而 $b$ 必须在 $L$ 中。\n- 选项 D 缺少从 $q_{1}$ 在 $Z_{0}$ 上的接受性 $\\epsilon$-转移，因此它会拒绝 $n=0$ 时的 $b$。\n\n因此，正确的转移函数是选项 B。", "answer": "$$\\boxed{B}$$", "id": "1394394"}, {"introduction": "工程师和计算机科学家的一个关键能力是调试。本练习为你呈现一个意在识别 $w\\#w^R$ 形式回文串，但含有一个缺陷的下推自动机，你的任务是找出这条错误的转换规则。这项实践能磨练你的分析能力，因为它不仅需要你懂得正确的设计，更要能识别出微小错误如何导致整个系统失效，从而加深你对堆栈模式匹配精密逻辑的理解。[@problem_id:1394387]", "problem": "一位计算机科学家正在设计一个自动机来识别一个特定的语言。目标语言是 $L = \\{w\\#w^R \\mid w \\in \\{0,1\\}^*\\}$，其中 $w^R$ 是字符串 $w$ 的逆序。例如，字符串 `011#110` 属于 $L$，而 `01#01` 不属于。\n\n该科学家提出了一个下推自动机 (Pushdown Automaton, PDA)，这是一种配备了堆栈的自动机。所提出的 PDA 由一个 7-元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_{start}, Z_0, F)$ 定义，其组成部分如下：\n-   状态集：$Q = \\{q_0, q_1, q_2\\}$\n-   输入字母表：$\\Sigma = \\{0, 1, \\#\\}$\n-   堆栈字母表：$\\Gamma = \\{0, 1, Z_0\\}$\n-   起始状态：$q_{start} = q_0$\n-   初始堆栈符号：$Z_0$\n-   最终（接受）状态集：$F = \\{q_2\\}$\n\n该 PDA 被设计按以下方式运行：在状态 $q_0$ 时，它读取子字符串 $w$ 并将其符号推入堆栈。当它读取到 `#` 符号时，它切换到状态 $q_1$。在状态 $q_1$ 时，它将输入的 $w^R$ 符号与从堆栈中弹出的符号进行匹配。如果输入被完全读取且堆栈为空（除了 $Z_0$），它将转移到接受状态 $q_2$。\n\n转移函数 $\\delta$ 中恰好包含一条错误的规则，该规则导致 PDA 无法完成其识别语言 $L$ 的任务。这意味着 PDA 要么接受了不属于 $L$ 的字符串，要么拒绝了属于 $L$ 的字符串。转移集如下所列。\n\n-   $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ 对于任意 $X \\in \\Gamma$\n-   $\\delta(q_0, 1, X) = \\{(q_0, 1X)\\}$ 对于任意 $X \\in \\Gamma$\n-   $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n-   $\\delta(q_1, 0, 0) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, 1, 1) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\n你的任务是从下面提供的选项中找出错误的转移规则。\n\nA. 转移规则 $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ 对于任意 $X \\in \\Gamma$。\nB. 转移规则 $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$。\nC. 转移规则 $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$。\nD. 转移规则 $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$。", "solution": "我们希望 PDA 恰好接受语言 $L=\\{w\\#w^{R}\\mid w\\in\\{0,1\\}^{*}\\}$。设 $w=a_{1}a_{2}\\dots a_{n}$，其中每个 $a_{i}\\in\\{0,1\\}$。在状态 $q_{0}$，PDA 将读取的 $w$ 的每个符号都推入堆栈，以便在读取完整个 $w$ 后，堆栈内容（从顶到底）为 $a_{n}a_{n-1}\\dots a_{1}Z_{0}$。在读取到 $\\#$ 时，它必须切换到 $q_{1}$ 且不改变堆栈，这样在 $q_{1}$ 中它就可以将输入的符号与堆栈顶部进行比较。在 $q_{1}$ 中，为了强制匹配 $w^{R}$，每个接下来的输入符号必须等于当前的堆栈顶部符号，并被弹出；当所有输入都被消耗完且堆栈中只剩下 $Z_{0}$ 时，则通过一个 $\\epsilon$-转移进入接受状态 $q_{2}$。\n\n现在，我们对照这个预期的行为来检查每个列出的转移。\n\n1) $\\delta(q_{0},0,X)=\\{(q_{0},0X)\\}$ 对于任意 $X\\in\\Gamma$。在读取左半部分 $w$ 时，该规则正确地将一个 $0$ 推入堆栈顶部。这实现了所需的推入行为，因此它是一致的。\n\n2) $\\delta(q_{0},\\#,X)=\\{(q_{1},X)\\}$ 对于任意 $X\\in\\Gamma$。该规则在分隔符 $\\#$ 处正确地从构建堆栈阶段切换到匹配阶段，并保持堆栈不变，这正是所需要的。\n\n3) $\\delta(q_{1},0,1)=\\{(q_{1},\\epsilon)\\}$。在匹配阶段，对于语言 $w\\#w^{R}$，输入符号必须等于堆栈顶部符号才能将其弹出。然而，这条规则在读取一个 $0$ 时弹出了一个 $1$，从而允许了不匹配。这种对不匹配的接受导致 PDA 接受了不属于 $L$ 的字符串。一个具体的反例是输入 $1\\#0$：从初始堆栈符号 $Z_{0}$ 开始，在 $q_{0}$ 状态读取 $1$ 会将 $1$ 推入堆栈，使堆栈变为 $1Z_{0}$；读取 $\\#$ 转移到 $q_{1}$ 且堆栈不变；在 $q_{1}$ 状态读取 $0$ 时，错误的规则 $\\delta(q_{1},0,1)$ 会弹出 $1$；此时输入已耗尽，堆栈顶部为 $Z_{0}$，转移 $\\delta(q_{1},\\epsilon,Z_{0})=(q_{2},Z_{0})$ 使自动机进入 $q_{2}$。因此 $1\\#0$ 被接受，但 $1\\#0\\notin L$ 因为 $w=1$ 意味着 $w^{R}=1$，而不是 $0$。因此这条规则是错误的。\n\n4) $\\delta(q_{1},\\epsilon,Z_{0})=\\{(q_{2},Z_{0})\\}$。一旦输入被消耗完并且堆栈已返回到 $Z_{0}$，这条规则允许通过最终状态接受。它与预期的接受条件一致，并且不会引入不正确的接受，因为只有当输入被消耗完时，到达 $q_{2}$ 才是一个接受配置。\n\n因此，选项中唯一的错误转移是 $\\delta(q_{1},0,1)=\\{(q_{1},\\epsilon)\\}$，即选项 C。", "answer": "$$\\boxed{C}$$", "id": "1394387"}]}