{"hands_on_practices": [{"introduction": "确定性有限自动机（DFA）的一个核心能力是利用其有限的状态来“记忆”输入序列的关键信息。这个练习将引导你实践一个基本但非常强大的设计模式：如何使用状态来跟踪一个关于特定符号出现次数的模运算属性。通过构建一个能够识别输入串中 'a' 的数量模 $3$ 余 $1$ 的DFA，你将深入理解状态是如何作为计数器来工作的，这是构建更复杂模式识别器的基础 [@problem_id:1362816]。", "problem": "在计算理论中，确定性有限自动机（DFA）是一种机器的理论模型，它可以识别一个字符串集合，这个集合被称为形式语言。考虑一个定义在字母表 $\\Sigma = \\{a, b\\}$ 上的语言 $L$。一个字符串 $w$ 属于语言 $L$ 的充分必要条件是，$w$ 中字符 'a' 出现的总次数模 3 同余于 1。对于任意字符串 $w$，令 $n_a(w)$ 表示 $w$ 中 'a' 的数量。那么，用数学方式表示，该语言为 $L = \\{w \\in \\{a, b\\}^* \\mid n_a(w) \\equiv 1 \\pmod{3}\\}$。注意，空字符串包含零个 'a'。\n\n要识别该语言 $L$，一个 DFA 所需的最小状态数是多少？", "solution": "我们要寻找识别语言 $L = \\{w \\in \\{a,b\\}^* \\mid n_{a}(w) \\equiv 1 \\pmod{3}\\}$ 的 DFA 的最小状态数。该语言的行为仅取决于 $n_{a}(w) \\bmod 3$，因此我们考虑模 3 的同余类。\n\n下界（Myhill-Nerode 可区分性）：\n对于 $i \\in \\{0,1,2\\}$，定义集合\n$$\nC_{i} = \\{ w \\in \\{a,b\\}^* \\mid n_{a}(w) \\equiv i \\pmod{3} \\}.\n$$\n我们证明 $C_{0}, C_{1}, C_{2}$ 相对于 $L$ 是两两可区分的。设 $u \\in C_{i}$ 且 $v \\in C_{j}$，其中 $i \\neq j$。选择一个可区分的扩展字符串 $t = a^{k}$，其中 $k \\equiv 1 - i \\pmod{3}$。那么\n$$\nn_{a}(ut) \\equiv n_{a}(u) + n_{a}(t) \\equiv i + k \\equiv i + (1 - i) \\equiv 1 \\pmod{3},\n$$\n所以 $ut \\in L$。另一方面，\n$$\nn_{a}(vt) \\equiv n_{a}(v) + n_{a}(t) \\equiv j + k \\equiv j + (1 - i) \\equiv 1 + (j - i) \\pmod{3}.\n$$\n由于 $j - i \\not\\equiv 0 \\pmod{3}$，我们有 $n_{a}(vt) \\not\\equiv 1 \\pmod{3}$，所以 $vt \\notin L$。因此 $C_{i}$ 和 $C_{j}$ 是可区分的。所以，根据 Myhill-Nerode 定理，任何用于识别 $L$ 的 DFA 都至少需要 3 个状态。\n\n上界（构造一个 3 状态的 DFA）：\n定义一个 DFA，其状态集为 $Q = \\{q_{0}, q_{1}, q_{2}\\}$，开始状态为 $q_{0}$，接受状态集为 $\\{q_{1}\\}$，转移函数为\n$$\n\\delta(q_{r}, a) = q_{(r+1) \\pmod 3}, \\quad \\delta(q_{r}, b) = q_{r}.\n$$\n对输入字符串的长度进行归纳，在读取任意字符串 $w$ 后，自动机处于状态 $q_{n_{a}(w) \\bmod 3}$。因此，当且仅当 $n_{a}(w) \\equiv 1 \\pmod{3}$ 时，它会接受输入，所以它能识别语言 $L$。\n\n结合 3 个状态的下界和存在一个 3 状态的 DFA，我们得出所需的最小状态数为 3。", "answer": "$$\\boxed{3}$$", "id": "1362816"}, {"introduction": "在现实世界中，一个有效的数据或指令往往需要同时满足多个标准。DFA理论为此提供了一个优雅的解决方案：乘积构造（product construction）。如果我们可以为每个单独的标准构建一个DFA，那么我们就可以系统地将它们合并成一个单一的DFA，来识别同时满足所有标准的字符串。这个练习将通过一个具体的例子，让你亲手分析两个给定的DFA，并理解它们的乘积自动机是如何精确地识别出两个语言的交集的 [@problem_id:1362787]。", "problem": "考虑两个定义在字母表 $\\Sigma = \\{a, b\\}$ 上的确定性有限自动机 (DFA)，$M_1$ 和 $M_2$。\n\n第一个自动机 $M_1 = (Q_1, \\Sigma, \\delta_1, q_S, F_1)$ 定义如下：\n-   状态集为 $Q_1 = \\{q_S, q_A, q_B\\}$。\n-   起始状态为 $q_S$。\n-   接受（或终止）状态集为 $F_1 = \\{q_A, q_B\\}$。注意，起始状态是唯一一个非接受状态。\n-   转移函数 $\\delta_1: Q_1 \\times \\Sigma \\to Q_1$ 由以下规则给出：\n    -   $\\delta_1(q_S, a) = q_A$\n    -   $\\delta_1(q_S, b) = q_B$\n    -   $\\delta_1(q_A, a) = q_A$\n    -   $\\delta_1(q_A, b) = q_B$\n    -   $\\delta_1(q_B, a) = q_A$\n    -   $\\delta_1(q_B, b) = q_B$\n\n第二个自动机 $M_2 = (Q_2, \\Sigma, \\delta_2, p_0, F_2)$ 定义如下：\n-   状态集为 $Q_2 = \\{p_0, p_1\\}$。\n-   起始状态为 $p_0$。\n-   接受（或终止）状态集为 $F_2 = \\{p_1\\}$。\n-   转移函数 $\\delta_2: Q_2 \\times \\Sigma \\to Q_2$ 由以下规则给出：\n    -   $\\delta_2(p_0, a) = p_1$\n    -   $\\delta_2(p_0, b) = p_0$\n    -   $\\delta_2(p_1, a) = p_1$\n    -   $\\delta_2(p_1, b) = p_0$\n\n一个新的自动机 $M_3 = (Q_3, \\Sigma, \\delta_3, q_{start}, F_3)$ 根据 $M_1$ 和 $M_2$ 构建，其组成部分如下：\n-   状态集：$Q_3 = Q_1 \\times Q_2$（状态集的笛卡尔积）。\n-   起始状态：$q_{start} = (q_S, p_0)$。\n-   接受状态集：$F_3 = F_1 \\times F_2$。\n-   转移函数：对于任何状态 $(q, p) \\in Q_3$ 和任何符号 $\\sigma \\in \\Sigma$，$\\delta_3((q, p), \\sigma) = (\\delta_1(q, \\sigma), \\delta_2(p, \\sigma))$。\n\n下列哪个陈述准确地描述了自动机 $M_3$ 所接受的语言 $L(M_3)$？\n\nA. 字母表 $\\{a, b\\}$ 上所有非空字符串的语言。\n\nB. 字母表 $\\{a, b\\}$ 上所有以符号 'a' 结尾的字符串的语言。\n\nC. 字母表 $\\{a, b\\}$ 上所有至少包含一个 'a' 的字符串的语言。\n\nD. 字母表 $\\{a, b\\}$ 上所有以 'a' 开始并以 'a' 结尾的字符串的语言。\n\nE. 空语言。", "solution": "我们分析每个 DFA 以及乘积构造。\n\n对于 $M_1$，从转移函数中可以观察到，一旦从 $q_S$ 读入第一个输入符号，机器在遇到符号 $a$ 时会转移到 $q_A$，在遇到符号 $b$ 时会转移到 $q_B$，而 $q_A$ 和 $q_B$ 都是接受状态。对于任何后续符号，$\\delta_1$ 保持了状态指示最后读入符号的特性：$\\delta_{1}(q_{A},a)=q_{A}$，$\\delta_{1}(q_{A},b)=q_{B}$，$\\delta_{1}(q_{B},a)=q_{A}$，以及 $\\delta_{1}(q_{B},b)=q_{B}$。因此，对于任何非空字符串 $w \\in \\{a,b\\}^{+}$，处理完 $w$ 后，状态会处于 $F_1$ 中；而对于空字符串 $\\epsilon$，机器保持在 $q_S \\notin F_1$ 状态。因此，\n$$\nL(M_{1})=\\{a,b\\}^+。\n$$\n\n对于 $M_2$，从 $p_0$ 开始，遇到 $a$ 转移到 $p_1$，遇到 $b$ 则停留在 $p_0$；从 $p_1$ 开始，遇到 $a$ 停留在 $p_1$，遇到 $b$ 则转移到 $p_0$。通过对输入长度进行归纳，可以得出结论：在处理完任何字符串 $w \\in \\{a,b\\}^*$ 后，当且仅当 $w$ 的最后一个符号是 $a$ 时，自动机处于 $p_1$ 状态，否则（包括 $w=\\epsilon$ 的情况）处于 $p_0$ 状态。由于 $F_2=\\{p_1\\}$，我们有\n$$\nL(M_{2})=\\{\\,w \\in \\{a,b\\}^* : w \\text{ 的最后一个符号是 } a\\,\\}。\n$$\n\n对于乘积 DFA $M_3$，其构造为 $Q_{3}=Q_{1}\\times Q_{2}$，起始状态为 $q_{start}=(q_{S},p_{0})$，转移函数为 $\\delta_{3}((q,p),\\sigma)=(\\delta_{1}(q,\\sigma),\\delta_{2}(p,\\sigma))$，接受集为 $F_{3}=F_{1}\\times F_{2}$。对于任何输入 $w \\in \\{a,b\\}^*$，根据乘积构造的定义，$M_3$ 接受 $w$ 当且仅当 $M_1$ 和 $M_2$ 都接受 $w$，即：\n$$\nL(M_{3})=L(M_{1}) \\cap L(M_{2})。\n$$\n代入 $L(M_1)$ 和 $L(M_2)$ 的特征，我们得到：\n$$\nL(M_{3})=\\{a,b\\}^+ \\cap \\{\\,w \\in \\{a,b\\}^* : \\text{最后一个符号是 } a\\,\\}。\n$$\n因为每个以符号 $a$ 结尾的字符串必然是非空的，所以交集可以简化为\n$$\nL(M_{3})=\\{\\,w \\in \\{a,b\\}^* : w \\text{ 的最后一个符号是 } a\\,\\}。\n$$\n这与选项 B 相符：字母表 $\\{a,b\\}$ 上所有以符号 $a$ 结尾的字符串的语言。", "answer": "$$\\boxed{B}$$", "id": "1362787"}, {"introduction": "现在，让我们将前面学习的技巧综合起来，挑战一个更贴近实际应用的设计问题。在这个练习中，你需要从零开始设计一个DFA，它需要同时验证两个属性：二进制字符串所代表的整数值能被 $5$ 整除，并且字符串中 '1' 的个数为奇数。这要求你不仅要独立思考每个属性所需的DFA结构，还要应用乘积构造的思想来确定组合后所需的最小状态数，从而真正掌握理论知识与高效设计实践的结合 [@problem_id:1362807]。", "problem": "在一个专门的数据传输系统中，远程传感器向中央控制器发送数据包。每个数据包是一个非空的二进制字符串。一个数据包要被控制器视为有效并进行处理，必须同时满足两个不同的标准。二进制字符串从左到右读取，最左边的位是最高有效位。\n\n有效数据包的标准是：\n1.  二进制字符串表示的整数值必须能被 5 整除。\n2.  二进制字符串中“1”的总数必须是奇数。\n\n例如，字符串“101”表示整数 5，它包含两个“1”。它满足第一个标准但不满足第二个，因此是无效数据包。字符串“11001”表示整数 25，它包含三个“1”。它同时满足两个标准，因此是有效数据包。\n\n一个接受所有有效数据包语言的确定性有限自动机（DFA）所需的最少状态数是多少？", "solution": "设 $w \\in \\{0,1\\}^{+}$ 从左到右读取。设 $\\operatorname{val}(w)$ 为 $w$ 的二进制整数值，设 $\\operatorname{par}(w) \\in \\{E,O\\}$ 表示 $w$ 中 1 的数量的奇偶性（偶/奇）。该语言是\n$$\nL=\\{\\,w \\in \\{0,1\\}^+ : \\operatorname{val}(w) \\equiv 0 \\pmod{5}\\ \\text{and}\\ \\operatorname{par}(w)=O\\,\\}.\n$$\n\n一个识别 $L$ 的DFA必须同时跟踪：\n-   当前前缀模 5 的余数 $r \\in \\{0,1,2,3,4\\}$，以及\n-   到目前为止所见“1”的数量的奇偶性 $p \\in \\{E,O\\}$。\n\n因此，考虑状态集为\n$$\nQ=\\{0,1,2,3,4\\} \\times \\{E,O\\}\n$$\n的确定性自动机。从状态 $(r,p)$ 读取一个位 $b \\in \\{0,1\\}$，转移是\n$$\n(r,p) \\xrightarrow{b} \\big((2r+b) \\bmod 5,\\; p \\oplus [b=1]\\big),\n$$\n其中当且仅当 $b=1$ 时，$p \\oplus [b=1]$ 会翻转奇偶性。开始状态是 $(0,E)$，接受状态恰好是\n$$\nF=\\{(0,O)\\}.\n$$\n\n我们证明这个DFA有 10 个可达且两两可区分的状态，因此所需的最少状态数为 10。\n\n所有 10 个状态的可达性：\n-   对于任何 $r \\in \\{0,1,2,3,4\\}$，取 $r$ 的标准二进制表示 $x_{r}$（如果需要，允许前导零以确保输入非空），根据构造，读取 $x_{r}$ 后的余数为 $r$。$x_{r}$ 的奇偶性 $\\operatorname{par}(x_{r})$ 可能是 $E$ 或 $O$。\n-   为了在不改变模 5 余数的情况下独立地调整奇偶性，使用一个长度为 8、奇偶性为奇且 $\\operatorname{val}(y) \\equiv 0 \\pmod{5}$ 的固定字符串 $y$。一个明确的选择是 $y=00011001$，其 $\\operatorname{val}(y)=25 \\equiv 0 \\pmod{5}$ 且 $\\operatorname{par}(y)=O$。附加 $y$ 会翻转奇偶性（因为它增加了奇数个 1），同时保持模 5 的余数不变，因为\n$$\n2^{8} \\equiv (2^{4})^{2} \\equiv 1 \\pmod{5},\\quad \\operatorname{val}(y) \\equiv 0 \\pmod{5}.\n$$\n因此，对于任何期望的 $(r,p)$，读取 $x_{r}$ 以达到余数 $r$，如果需要，附加 $y$ 以将奇偶性调整为 $p$。因此 $Q$ 中的每一对状态都是可达的。\n\n两两可区分性 (Myhill–Nerode):\n设 $(r,p)$ 和 $(r',p')$ 是 $Q$ 中两个不同的状态。我们构造一个区分后缀 $s$，使得两个扩展计算中只有一个是接受的。\n\n首先，注意这个同余工具：由于 $2^{4}=16 \\equiv 1 \\pmod{5}$，对于任何 $a \\in \\{0,1,2,3,4\\}$，都存在一个 4 位字符串 $u$ 使得 $\\operatorname{val}(u) \\equiv a \\pmod{5}$。因此，对于任何 $r$，都存在一个 4 位字符串 $x$ 使得\n$$\n\\operatorname{val}(x) \\equiv -r \\pmod{5},\n$$\n这样，将 $x$ 附加到余数为 $r$ 的前缀上，会得到最终余数 0：\n$$\nr\\cdot 2^{4} + \\operatorname{val}(x) \\equiv r \\cdot 1 + (-r) \\equiv 0 \\pmod{5}.\n$$\n如果我们需要调整 $x$ 的奇偶性，我们可以附加 $y$（如上所述）；附加 $y$ 会在翻转奇偶性的同时保持余数 0，因为 $2^{8} \\equiv 1 \\pmod{5}$ 且 $\\operatorname{val}(y) \\equiv 0 \\pmod{5}$。\n\n现在区分两种情况：\n- 如果 $r \\neq r'$，如上定义 $x$ 使得 $\\operatorname{val}(x) \\equiv -r \\pmod{5}$。设 $q$ 是从 $(r,p)$ 开始达到接受状态所需的奇偶性，即如果 $p=E$ 则 $q=O$，如果 $p=O$ 则 $q=E$。如果 $\\operatorname{par}(x)=q$，则设 $s=x$；否则设 $s=xy$。从 $(r,p)$ 开始，s 给出余数 0 和奇偶性 O，所以是接受的。从 $(r',p')$ 开始，由于 $|s| \\equiv 4 \\pmod{8}$，我们有 $2^{|s|} \\equiv 1 \\pmod{5}$，因此最终余数是\n$$\nr'\\cdot 2^{|s|} + \\operatorname{val}(s) \\equiv r' + \\operatorname{val}(x) \\equiv r' - r \\not\\equiv 0 \\pmod{5},\n$$\n因此是被拒绝的。所以 $(r,p)$ 和 $(r',p')$ 是可区分的。\n- 如果 $r=r'$ 但 $p \\neq p'$，使用相同的 $x$ 使得 $\\operatorname{val}(x) \\equiv -r \\pmod{5}$，并选择 $s$ 使最终奇偶性与从 $(r,p)$ 达到接受状态的要求相匹配（即，选择 $s=x$ 或 $s=xy$ 以确保最终奇偶性为 $O$）。那么从 $(r,p)$ 开始，字符串 $s$ 是可接受的，而从 $(r,p')$ 开始，它产生余数 0 但奇偶性错误，因此被拒绝。因此这些状态是可区分的。\n\n由于 $Q$ 中所有 10 个状态都是可达且两两可区分的，因此 $L$ 的最小DFA恰好有 10 个状态。\n\n因此，所需的最少状态数为 10。", "answer": "$$\\boxed{10}$$", "id": "1362807"}]}