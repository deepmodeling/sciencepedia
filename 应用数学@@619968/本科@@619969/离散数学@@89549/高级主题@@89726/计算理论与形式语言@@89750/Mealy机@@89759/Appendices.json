{"hands_on_practices": [{"introduction": "第一个练习旨在检验你对基础知识的掌握程度。给定一个完整定义的米利机和一个输入字符串，你的任务是逐步追踪机器的执行过程，确定状态序列和相应的输出字符串。这项练习将巩固你对状态转移函数 $\\delta$ 和输出函数 $\\lambda$ 在米利机中如何协同工作的核心理解。[@problem_id:1383513]", "problem": "Mealy 机是一种有限状态机，它根据其当前状态和当前输入生成输出。它由一个六元组 $(Q, \\Sigma, \\Lambda, \\delta, \\lambda, q_0)$ 形式化定义，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是一个称为输入字母表的有限集。\n- $\\Lambda$ 是一个称为输出字母表的有限集。\n- $\\delta: Q \\times \\Sigma \\to Q$ 是转移函数。\n- $\\lambda: Q \\times \\Sigma \\to \\Lambda$ 是输出函数。\n- $q_0 \\in Q$ 是初始状态。\n\n考虑一个 Mealy 机 $M$，它被设计用来检测一个字符序列中的变化。该机器定义如下：\n- 状态集合为 $Q = \\{S_0, S_a, S_b, S_c\\}$。\n- 输入字母表为 $\\Sigma = \\{a, b, c\\}$。\n- 输出字母表为 $\\Lambda = \\{0, 1\\}$。\n- 初始状态为 $q_0 = S_0$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to Q$ 由规则 $\\delta(q, i) = S_i$ 定义，适用于任何状态 $q \\in Q$ 和任何输入符号 $i \\in \\Sigma$。（例如，$\\delta(S_b, c) = S_c$）。\n- 输出函数 $\\lambda: Q \\times \\Sigma \\to \\Lambda$ 定义如下：\n    1. 对于初始状态，对于任何输入 $i \\in \\Sigma$，$\\lambda(S_0, i) = 0$。\n    2. 对于任何其他状态 $S_x$（其中 $x \\in \\{a, b, c\\}$），输出由以下方式给出：\n       如果输入符号 $i$ 与状态的下标 $x$ 相同，则 $\\lambda(S_x, i) = 0$。\n       如果输入符号 $i$ 与状态的下标 $x$ 不同，则 $\\lambda(S_x, i) = 1$。\n\n给定输入字符串 `abacabcaab`，机器 $M$ 产生的相应输出字符串是什么？\n\nA) `0111111101`\n\nB) `1111111101`\n\nC) `0010000010`\n\nD) `0101011001`\n\nE) `0110110101`", "solution": "给定一个 Mealy 机，其状态集为 $Q=\\{S_{0}, S_{a}, S_{b}, S_{c}\\}$，输入字母表为 $\\Sigma=\\{a,b,c\\}$，输出字母表为 $\\Lambda=\\{0,1\\}$。转移函数为 $\\delta(q,i)=S_{i}$，适用于任何 $q\\in Q$ 和 $i\\in\\Sigma$，因此在读取符号 $i$ 后，下一个状态是 $S_{i}$。输出函数为：对于任何 $i$，$\\lambda(S_{0},i)=0$；对于 $S_{x}$（其中 $x\\in\\{a,b,c\\}$），如果 $i=x$，则 $\\lambda(S_{x},i)=0$，如果 $i\\neq x$，则 $\\lambda(S_{x},i)=1$。这意味着机器对第一个符号输出 $0$，并且随后仅当当前输入符号等于前一个输入符号时（因为状态编码了前一个输入）才输出 $0$，当输入改变时输出 $1$。\n\n我们使用 $\\lambda$ 和 $\\delta$ 逐个符号处理输入字符串 abacabcaab，跟踪当前状态、输出和下一个状态：\n- 从 $S_{0}$ 开始。\n- 读入 $a$：当前状态 $S_{0}$，输出 $\\lambda(S_{0},a)=0$，下一状态 $\\delta(S_{0},a)=S_{a}$。\n- 读入 $b$：当前状态 $S_{a}$，由于 $b\\neq a$，输出 $\\lambda(S_{a},b)=1$，下一状态 $S_{b}$。\n- 读入 $a$：当前状态 $S_{b}$，由于 $a\\neq b$，输出 $1$，下一状态 $S_{a}$。\n- 读入 $c$：当前状态 $S_{a}$，由于 $c\\neq a$，输出 $1$，下一状态 $S_{c}$。\n- 读入 $a$：当前状态 $S_{c}$，由于 $a\\neq c$，输出 $1$，下一状态 $S_{a}$。\n- 读入 $b$：当前状态 $S_{a}$，由于 $b\\neq a$，输出 $1$，下一状态 $S_{b}$。\n- 读入 $c$：当前状态 $S_{b}$，由于 $c\\neq b$，输出 $1$，下一状态 $S_{c}$。\n- 读入 $a$：当前状态 $S_{c}$，由于 $a\\neq c$，输出 $1$，下一状态 $S_{a}$。\n- 读入 $a$：当前状态 $S_{a}$，由于 $a=a$，输出 $0$，下一状态 $S_{a}$。\n- 读入 $b$：当前状态 $S_{a}$，由于 $b\\neq a$，输出 $1$，下一状态 $S_{b}$。\n\n按顺序收集输出，得到字符串 0111111101，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1383513"}, {"introduction": "现在，让我们从分析米利机转向为一个实际任务设计米利机。这个问题挑战你创建一个能够执行二进制算术运算的机器——具体来说，是将一个二进制输入数乘以三。解决问题的关键在于想清楚机器需要在其状态中“记住”什么信息（在此例中是进位值），以便逐位正确地计算结果。[@problem_id:1383549]", "problem": "Mealy机是一种有限状态机，其输出取决于当前状态和当前输入。它可以由一个六元组 $(S, S_0, \\Sigma, \\Lambda, T, G)$ 形式化定义，其中 $S$ 是一个有限的状态集，$S_0$ 是起始状态，$\\Sigma$ 是输入字母表，$\\Lambda$ 是输出字母表，$T: S \\times \\Sigma \\to S$ 是转移函数，$G: S \\times \\Sigma \\to \\Lambda$ 是输出函数。\n\n考虑一个数字流处理器，其设计用于将任意给定的二进制数乘以三。该处理器被实现为一个Mealy机。它从最低有效位（LSB）开始，一次读取一个比特的整数二进制表示。对于它读取的每个输入比特，它会产生一个输出比特。该机器有一个输入字母表 $\\Sigma = \\{0, 1\\}$ 和一个输出字母表 $\\Lambda = \\{0, 1\\}$。\n\n该机器从初始状态 $S_0$ 开始，该状态对应于零进位条件。状态用 $S_i$ 表示，其中索引 $i$ 代表机器存储的进位值。以下哪个表格正确地描述了执行此乘法操作的最小Mealy机的转移函数 $T$ 和输出函数 $G$ ？表格条目以（下一状态，输出）的格式呈现。\n\nA)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_2$, 0) |\n| $S_2$ | ($S_1$, 0) | ($S_2$, 1) |\n\nB)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_1$, 1) | ($S_2$, 0) |\n| $S_2$ | ($S_1$, 0) | ($S_0$, 1) |\n\nC)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_1$, 0) |\n| $S_2$ | ($S_1$, 0) | ($S_2$, 1) |\n\nD)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_0$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_1$, 0) |\n\nE)\n| 当前状态 | 输入 0 | 输入 1 |\n|:---:|:---:|:---:|\n| $S_0$ | ($S_0$, 0) | ($S_1$, 1) |\n| $S_1$ | ($S_0$, 1) | ($S_2$, 0) |\n| $S_2$ | ($S_2$, 0) | ($S_1$, 1) |", "solution": "我们用一个Mealy机来模拟对从最低有效位开始读取的二进制流乘以三的操作，该机器的状态 $S_{i}$ 编码了当前的进位 $i$。设当前输入比特为 $b \\in \\{0,1\\}$，当前进位为 $c \\in \\{0,1,2\\}$（因为 $3 \\cdot 1 + 2 = 5$，所以进位最多为 $2$）。在每一步，该比特位的和为\n$$\ns = 3b + c.\n$$\n输出比特是 $s$ 的最低有效位，所以\n$$\ny = s \\bmod 2,\n$$\n而下一个进位是其更高部分，\n$$\nc' = \\left\\lfloor \\frac{s}{2} \\right\\rfloor.\n$$\n因此，转移到状态 $S_{c'}$，输出为 $y$。\n\n计算所有情况：\n\n1) 对于 $c=0$：\n- 如果 $b=0$：$s=0, y=0, c'=0$ 得到 $(S_{0},0)$。\n- 如果 $b=1$：$s=3, y=1, c'=1$ 得到 $(S_{1},1)$。\n\n2) 对于 $c=1$：\n- 如果 $b=0$：$s=1, y=1, c'=0$ 得到 $(S_{0},1)$。\n- 如果 $b=1$：$s=4, y=0, c'=2$ 得到 $(S_{2},0)$。\n\n3) 对于 $c=2$：\n- 如果 $b=0$：$s=2, y=0, c'=1$ 得到 $(S_{1},0)$。\n- 如果 $b=1$：$s=5, y=1, c'=2$ 得到 $(S_{2},1)$。\n\n汇总各行：\n\n- $S_{0}$：输入 $0 \\to (S_{0},0)$，输入 $1 \\to (S_{1},1)$。\n- $S_{1}$：输入 $0 \\to (S_{0},1)$，输入 $1 \\to (S_{2},0)$。\n- $S_{2}$：输入 $0 \\to (S_{1},0)$，输入 $1 \\to (S_{2},1)$。\n\n这与选项A中的表格完全匹配，并且与所有其他选项都不同。三个进位 $\\{0,1,2\\}$ 都是必需的，因此该机器是最小的。", "answer": "$$\\boxed{A}$$", "id": "1383549"}, {"introduction": "我们最后的练习将抽象的米利机理论与它在数字电路中的物理实现联系起来。这个思想实验探讨了当输入在与机器时钟非同步的时刻发生变化时会发生什么。理解这种行为对于设计可靠的系统至关重要，并且能帮助你掌握米利机和摩尔机之间一个关键的实际区别——即输出“毛刺”（glitches）的可能性。[@problem_id:1968918]", "problem": "一个米利（Mealy）有限状态机被设计用于检测一个特定的输入序列。该状态机由以下参数定义：\n- 一组状态 $Q = \\{S_0, S_1\\}$。\n- 一个单位比特输入 $X$，其输入字母表为 $\\Sigma = \\{0, 1\\}$。\n- 一个单位比特输出 $Z$，其输出字母表为 $\\Gamma = \\{0, 1\\}$。\n- 一个状态转移函数 $\\delta: Q \\times \\Sigma \\to Q$，用于确定下一个状态。\n- 一个输出函数 $\\lambda: Q \\times \\Sigma \\to \\Gamma$，用于确定当前输出。\n\n该状态机在周期性时钟信号的上升沿更新其状态。转移函数和输出函数定义如下：\n\n状态转移函数 $\\delta(q, X)$:\n- $\\delta(S_0, 0) = S_0$\n- $\\delta(S_0, 1) = S_1$\n- $\\delta(S_1, 0) = S_0$\n- $\\delta(S_1, 1) = S_1$\n\n输出函数 $\\lambda(q, X)$:\n- $\\lambda(S_0, 0) = 0$\n- $\\lambda(S_0, 1) = 0$\n- $\\lambda(S_1, 0) = 1$\n- $\\lambda(S_1, 1) = 0$\n\n现在，考虑这样一种场景：该状态机当前处于状态 $S_1$，并且输入 $X$ 在一段时间内稳定为值 $1$。然后，在两个连续时钟上升沿的正中间，输入 $X$ 发生了一次从 $1$ 到 $0$ 的跳变。\n\n下列哪项陈述最准确地描述了从输入变化前到第二个时钟上升沿后这段时间内输出 $Z$ 的行为？\n\nA. 在两个时钟沿之间的整个区间内，输出 $Z$ 始终保持为 $0$。\n\nB. 输出 $Z$ 在第二个时钟上升沿时精确地从 $0$ 跳变到 $1$，并保持 $1$ 达一个完整的时钟周期。\n\nC. 在输入 $X$ 从 $1$ 变为 $0$ 的瞬间，输出 $Z$ 从 $0$ 跳变到 $1$，然后在下一个时钟上升沿后不久跳变回 $0$。\n\nD. 在输入 $X$ 从 $1$ 变为 $0$ 的瞬间，输出 $Z$ 从 $0$ 跳变到 $1$，并保持为 $1$ 直到输入 $X$ 在未来的某个时钟周期再次改变。\n\nE. 由于输入与时钟异步变化，输出 $Z$ 暂时未定义或进入亚稳态。", "solution": "我们使用给定的状态转移函数和输出函数来分析这个米利型状态机，注意到在米利型状态机中，输出 $Z$ 是当前状态 $q$ 和当前输入 $X$ 的一个组合函数，而状态 $q$ 仅在时钟上升沿更新。\n\n已知：\n- 状态转移函数 $\\delta(q,X)$:\n$$\n\\delta(S_{0},0)=S_{0},\\quad \\delta(S_{0},1)=S_{1},\\quad \\delta(S_{1},0)=S_{0},\\quad \\delta(S_{1},1)=S_{1}.\n$$\n- 输出函数 $\\lambda(q,X)$:\n$$\n\\lambda(S_{0},0)=0,\\quad \\lambda(S_{0},1)=0,\\quad \\lambda(S_{1},0)=1,\\quad \\lambda(S_{1},1)=0.\n$$\n\n假设两个连续的上升沿发生在时间 $t_{k}$ 和 $t_{k+1}$，输入跳变发生在这两者正中间的时刻 $t_{m}$，因此有 $t_{k}<t_{m}<t_{k+1}$ 且 $t_{m}-t_{k}=t_{k+1}-t_{m}$。在 $t_{m}$ 之前，状态机处于状态 $S_{1}$，并且 $X$ 在 $t_{m}$ 之前一直稳定为 $1$。\n\n1) 对于 $t<t_{m}$ (在输入变化之前)：状态为 $q=S_{1}$，输入为 $X=1$。因此输出为\n$$\nZ=\\lambda(S_{1},1)=0.\n$$\n\n2) 在 $t=t_{m}^{+}$ 时 (输入从 $1$ 变为 $0$ 之后立即)：状态尚未更新，因为在 $t_m$ 时刻没有时钟上升沿，所以 $q$ 保持为 $S_1$，而输入变为 $X=0$。因此，根据米利型输出函数，\n$$\nZ=\\lambda(S_{1},0)=1.\n$$\n因此，在输入变化的瞬间，输出从 $0$ 跳变到 $1$。\n\n3) 对于 $t_{m}<t<t_{k+1}$：状态仍然是 $q=S_{1}$ (因为还没有时钟沿)，输入保持为 $X=0$，所以输出保持为\n$$\nZ=\\lambda(S_{1},0)=1.\n$$\n\n4) 在 $t=t_{k+1}^{+}$ 时 (在下一个上升沿之后立即)：状态根据转移函数以及当前输入 $X=0$ 进行更新：\n$$\nq^{+}=\\delta(S_{1},0)=S_{0}.\n$$\n当 $q^{+}=S_{0}$ 且 $X=0$ 时，输出变为\n$$\nZ=\\lambda(S_{0},0)=0.\n$$\n因此，在下一个时钟上升沿之后不久（考虑到通过状态元件和输出逻辑的传播延迟），输出返回到 $0$。\n\n由于输入跳变发生在两个时钟沿的正中间，没有在时钟沿附近进行采样，因此不涉及亚稳态问题。该行为与“$Z$ 在输入跳变时变为高电平，并在下一个上升沿后返回低电平”的陈述相符。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1968918"}]}