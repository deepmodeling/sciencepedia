{"hands_on_practices": [{"introduction": "理论是抽象的，而实践是具体的。要真正理解图灵机的工作原理，最好的方法莫过于亲手模拟它的每一步操作。这个练习将带你深入一台特定图灵机的内部，通过追踪其在输入字符串上的执行过程，让你直观感受状态转移、读写头移动和符号变换的每一个细节。这不仅能巩固你对图灵机形式化定义的理解，也是掌握更复杂计算理论概念的基石。[@problem_id:1377268]", "problem": "图灵机（TM）是一种计算的理论模型，它在一个分为多个单元格的无限长的纸带上运行。它由一个状态集合、一个符号字母表和一个转移函数来形式化定义。转移函数 $\\delta(q, \\gamma)$ 根据当前状态 $q$ 和从纸带上读取的符号 $\\gamma$ 来决定机器的下一个动作。该动作包括转换到一个新状态 $q'$，在纸带上写入一个新符号 $\\gamma'$，并将读写头向左（L）或向右（R）移动一个位置。\n\n考虑一个具体定义的图灵机如下：\n- 状态集 $Q = \\{q_s, q_{f0}, q_{f1}, q_r, q_a, q_{rej}\\}$\n- 起始状态: $q_s$\n- 停机（接受）状态: $q_a$\n- 停机（拒绝）状态: $q_{rej}$\n- 输入字母表 $\\Sigma = \\{0, 1\\}$\n- 纸带字母表 $\\Gamma = \\{0, 1, X, \\sqcup\\}$，其中 $\\sqcup$ 是空白符号。\n- 转移函数 $\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L, R\\}$ 由以下规则定义：\n    1.  $\\delta(q_s, 0) = (q_{f0}, X, R)$\n    2.  $\\delta(q_s, 1) = (q_{f1}, X, R)$\n    3.  $\\delta(q_s, X) = (q_s, X, R)$\n    4.  $\\delta(q_s, \\sqcup) = (q_a, \\sqcup, R)$\n    5.  $\\delta(q_{f0}, 0) = (q_{f0}, 0, R)$\n    6.  $\\delta(q_{f0}, 1) = (q_r, X, L)$\n    7.  $\\delta(q_{f0}, X) = (q_{f0}, X, R)$\n    8.  $\\delta(q_{f0}, \\sqcup) = (q_{rej}, \\sqcup, R)$\n    9.  $\\delta(q_{f1}, 0) = (q_r, X, L)$\n    10. $\\delta(q_{f1}, 1) = (q_{f1}, 1, R)$\n    11. $\\delta(q_{f1}, X) = (q_{f1}, X, R)$\n    12. $\\delta(q_{f1}, \\sqcup) = (q_{rej}, \\sqcup, R)$\n    13. $\\delta(q_r, 0) = (q_r, 0, L)$\n    14. $\\delta(q_r, 1) = (q_r, 1, L)$\n    15. $\\delta(q_r, X) = (q_r, X, L)$\n    16. $\\delta(q_r, \\sqcup) = (q_s, \\sqcup, R)$\n\n一个机器的格局（configuration）可以通过其当前状态、纸带内容和读写头位置来描述。最初，纸带上从单元格1开始包含输入字符串 `1010`，所有其他单元格（左侧索引 $\\le 0$ 和右侧索引 $\\ge 5$）都包含空白符号 $\\sqcup$。机器从状态 $q_s$ 开始，其读写头位于单元格1。\n\n当机器进入状态 $q_a$ 或 $q_{rej}$ 时，它会停机。计算机器在停机前所执行的总步数（即转移函数的应用次数）。", "solution": "我们一步步地模拟图灵机的运行，将每次转移函数的应用计为一步。我们用整数标记纸带单元格，输入占据单元格 $1$ 到 $4$，其他位置为空白。最初，纸带在单元格 $0$ 处为 $\\sqcup$ ，然后在单元格 $1,2,3,4$ 处为 $1,0,1,0$，在单元格 $5$ 处为 $\\sqcup$。读写头在状态 $q_{s}$ 下从单元格 $1$ 开始。\n\n第 1 步：状态 $q_{s}$，读写头在单元格 $1$，读取 $1$。应用规则 $2$：$\\delta(q_{s},1)=(q_{f1},X,R)$。在单元格 $1$ 写入 $X$，移动到单元格 $2$，状态变为 $q_{f1}$。\n\n第 2 步：状态 $q_{f1}$，读写头在单元格 $2$，读取 $0$。应用规则 $9$：$\\delta(q_{f1},0)=(q_{r},X,L)$。在单元格 $2$ 写入 $X$，移动到单元格 $1$，状态变为 $q_{r}$。\n\n第 3 步：状态 $q_{r}$，读写头在单元格 $1$，读取 $X$。应用规则 $15$：$\\delta(q_{r},X)=(q_{r},X,L)$。移动到单元格 $0$，状态变为 $q_{r}$。\n\n第 4 步：状态 $q_{r}$，读写头在单元格 $0$，读取 $\\sqcup$。应用规则 $16$：$\\delta(q_{r},\\sqcup)=(q_{s},\\sqcup,R)$。移动到单元格 $1$，状态变为 $q_{s}$。\n\n第 5 步：状态 $q_{s}$，读写头在单元格 $1$，读取 $X$。应用规则 $3$：$\\delta(q_{s},X)=(q_{s},X,R)$。移动到单元格 $2$，状态变为 $q_{s}$。\n\n第 6 步：状态 $q_{s}$，读写头在单元格 $2$，读取 $X$。应用规则 $3$：移动到单元格 $3$，状态变为 $q_{s}$。\n\n第 7 步：状态 $q_{s}$，读写头在单元格 $3$，读取 $1$。应用规则 $2$：$\\delta(q_{s},1)=(q_{f1},X,R)$。在单元格 $3$ 写入 $X$，移动到单元格 $4$，状态变为 $q_{f1}$。\n\n第 8 步：状态 $q_{f1}$，读写头在单元格 $4$，读取 $0$。应用规则 $9$：$\\delta(q_{f1},0)=(q_{r},X,L)$。在单元格 $4$ 写入 $X$，移动到单元格 $3$，状态变为 $q_{r}$。\n\n第 9 步：状态 $q_{r}$，读写头在单元格 $3$，读取 $X$。应用规则 $15$：移动到单元格 $2$，状态变为 $q_{r}$。\n\n第 10 步：状态 $q_{r}$，读写头在单元格 $2$，读取 $X$。应用规则 $15$：移动到单元格 $1$，状态变为 $q_{r}$。\n\n第 11 步：状态 $q_{r}$，读写头在单元格 $1$，读取 $X$。应用规则 $15$：移动到单元格 $0$，状态变为 $q_{r}$。\n\n第 12 步：状态 $q_{r}$，读写头在单元格 $0$，读取 $\\sqcup$。应用规则 $16$：移动到单元格 $1$，状态变为 $q_{s}$。\n\n第 13 步：状态 $q_{s}$，读写头在单元格 $1$，读取 $X$。应用规则 $3$：移动到单元格 $2$，状态变为 $q_{s}$。\n\n第 14 步：状态 $q_{s}$，读写头在单元格 $2$，读取 $X$。应用规则 $3$：移动到单元格 $3$，状态变为 $q_{s}$。\n\n第 15 步：状态 $q_{s}$，读写头在单元格 $3$，读取 $X$。应用规则 $3$：移动到单元格 $4$, 状态变为 $q_{s}$。\n\n第 16 步：状态 $q_{s}$，读写头在单元格 $4$，读取 $X$。应用规则 $3$：移动到单元格 $5$，状态变为 $q_{s}$。\n\n第 17 步：状态 $q_{s}$，读写头在单元格 $5$，读取 $\\sqcup$。应用规则 $4$：$\\delta(q_{s},\\sqcup)=(q_{a},\\sqcup,R)$。进入停机状态 $q_{a}$。\n\n机器在恰好 $17$ 步后停机。", "answer": "$$\\boxed{17}$$", "id": "1377268"}, {"introduction": "在理解了图灵机的基本运作后，我们可以开始探讨关于图灵机本身的“问题”是否可计算。这个练习提出了一个关于图灵机“句法”属性的问题：我们能否判断一个图灵机的状态数量是偶数？通过设计一个判定算法，你将学会区分关于机器“描述”的属性（通常是可判定的）和关于机器“行为”的属性（可能是不可判定的），这是理解可判定性边界的关键一步。[@problem_id:1377291]", "problem": "在计算理论中，我们通过将算法建模为图灵机（TMs）来分析其性质。一台图灵机 $M$ 可以被一个元组形式化地描述，该元组代表了它的状态集、带字母表、转移函数、起始状态、接受状态和拒绝状态。任何这样的形式化描述都可以编码为一个有限长度的字符串，记为 $\\langle M \\rangle$。\n\n考虑一个在这些编码的字母表上定义的语言 $L$。语言 $L$ 由所有具有特定结构属性的图灵机字符串编码组成。具体来说，该语言定义为：\n$L = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine that has a finite, even number of states} \\}$\n\n语言 $L$ 是可判定的吗？从以下选项中选择正确的陈述和理由。\n\nA. 语言 $L$ 是可判定的，因为可以构造一个判定器来解析编码 $\\langle M \\rangle$，计算机器描述中指定的状态数量，如果这个数量是偶数，则接受。这个过程保证对任何输入都会停机。\n\nB. 语言 $L$ 是不可判定的，因为确定图灵机的属性需要解决停机问题，因为需要查看在计算过程中实际使用了哪些状态。\n\nC. 语言 $L$ 是不可判定的，因为根据 Rice 定理，图灵机所识别的语言的任何非平凡属性都是不可判定的。\n\nD. 语言 $L$ 是可判定的，因为可以使用通用图灵机在所有可能的输入上模拟 $M$，以计算它进入的状态数，并且由于状态数是有限的，模拟最终将确定访问过的状态数是否为偶数。", "solution": "给定语言 $L = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine that has a finite, even number of states} \\}$。在图灵机的标准形式化定义中，状态集 $Q$ 根据定义是有限的。因此，定义 $L$ 的属性可以归约为一个语法属性，即基数 $|Q|$ 是偶数。\n\n为了判定 $L$，构造一个判定器 $D$，它对任意输入字符串 $w$ 的操作如下：\n1. 验证 $w$ 是否是在固定的有效编码方案下一个图灵机的有效编码 $\\langle M \\rangle$。这个检查是一个对有限字符串的有限语法解析过程，是可判定的。如果 $w$ 不是一个有效的编码，则拒绝，因为 $w \\notin L$。\n2. 如果 $w = \\langle M \\rangle$ 是有效的，则解析该描述以提取 $M$ 的状态集 $Q$，并通过对编码中列出的状态进行计数来计算 $n = |Q|$。\n3. 计算 $n \\pmod 2$，当且仅当 $n \\pmod 2 = 0$ 时接受。\n\n正确性：根据构造，该机器恰好接受那些其图灵机具有偶数个状态的编码。\n停机性：每个步骤都包括解析有限字符串以及执行有限的计数和算术运算，因此该过程对所有输入都会停机。因此 $L$ 是可判定的。\n\n这与陈述 A 相符。陈述 B 是不正确的，因为该属性关系到描述中定义的状态数量，而不是在任何计算过程中访问了哪些状态，所以不需要求助于停机问题。陈述 C 错误地应用了 Rice 定理，该定理涉及图灵机所识别语言的语义属性；而这里的属性是关于机器编码的纯粹语法属性。陈述 D 是不正确的，因为在所有输入上进行模拟是不必要的，并且不会产生一个通用的判定器；此外，它计算的是访问过的状态，而不是定义的状态总数。\n\n因此，正确的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1377291"}, {"introduction": "停机问题是计算理论中不可判定问题的典型代表，但它的不可判定性源于其“无界性”。这个练习通过一个巧妙的变体来挑战你的理解：如果我们将图灵机的运行步数限制在一个固定的上限（例如 $4096$ 步）内，问题是否仍然不可判定？通过解决这个问题，你将深刻体会到“有界”和“无界”在计算理论中的本质区别，并厘清为何停机问题是困难的，而其许多看似相似的变体却是可判定的。[@problem_id:1377286]", "problem": "在计算理论中，我们研究机器的基本能力和局限性。图灵机（TM）是一个假想计算设备的数学模型，它根据规则表来操作一条带子上的符号。图灵机的描述，记为 $\\langle M \\rangle$，是一个对它的状态、字母表和转移函数进行编码的有限字符串。\n\n一个语言是一个字符串的集合。我们称一个语言 $L$ 是**可判定的**，如果存在一个特殊的图灵机（称为判定器），对于任意给定的输入字符串 $w$，它总会停机并正确判断 $w$ 是否在 $L$ 中。如果一台图灵机停机并进入一个指定的 `accept` 状态，我们就说它接受该输入。\n\n考虑以下语言，我们称之为 $L_{CyberGuard}$：\n$L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台图灵机，它在至多 4096 步内接受其自身的描述 } \\langle M \\rangle \\}$\n\n关于语言 $L_{CyberGuard}$，以下哪个陈述是正确的？\n\nA. $L_{CyberGuard}$ 是可判定的。\n\nB. $L_{CyberGuard}$ 是不可判定的，因为它等价于已知的不可判定的停机问题。\n\nC. $L_{CyberGuard}$ 是不可判定的，但它是图灵可识别的（也称为递归可枚举的）。\n\nD. 在不知道用于 $\\langle M \\rangle$ 的具体编码方案的情况下，无法确定 $L_{CyberGuard}$ 的可判定性。\n\nE. $L_{CyberGuard}$ 是一个空语言，因为没有图灵机可以分析自己的代码。", "solution": "我们旨在确定语言 $L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ 在至多 } 4096 \\text{ 步内接受 } \\langle M \\rangle \\}$ 的可判定性。\n\n关键原则：对于任何固定的时间界限 $t \\in \\mathbb{N}$，“$M$ 在至多 $t$ 步内接受 $w$” 这个性质是可判定的。这是因为一个通用模拟器可以在 $w$ 上模拟 $M$ 最多 $t$ 步，这是一个有限且有效有界的计算。因此，执行此模拟并在界限内检查是否接受的机器是一个判定器。\n\n为 $L_{CyberGuard}$ 构建一个判定器 $D$：\n- 对于输入字符串 $x$：\n  1. 检查 $x$ 是否为某个图灵机的有效编码。如果不是，则拒绝。对于任何固定的有效图灵机编码方案，这种解析检查都是可判定的。\n  2. 令 $x = \\langle M \\rangle$。使用标准的通用图灵机程序，在输入 $\\langle M \\rangle$ 上模拟 $M$ 最多 4096 步。维护一个初始化为 0 的计数器 $c$。\n  3. 当 $c  4096$ 且 $M$ 尚未停机时，执行一次模拟转移，并设置 $c := c + 1$。\n  4. 如果在此模拟期间，$M$ 在 $c$ 到达 4096 之前进入接受状态，则接受；否则拒绝。\n\n停机性：该循环最多执行 4096 次迭代，并且每个模拟步骤都是可计算的。因此 $D$ 会在所有输入上停机，所以 $D$ 是一个判定器。\n\n正确性：根据构造，$D$ 恰好接受那些使得 $M$ 在至多 4096 步内接受 $\\langle M \\rangle$ 的编码 $\\langle M \\rangle$，这正是 $L_{CyberGuard}$ 的定义。\n\n对各选项的推论：\n- A 是正确的：$L_{CyberGuard}$ 可由上述判定器 $D$ 判定。\n- B 是错误的：与停机问题（无界）不同，这里的时间被一个固定的常数所限制，这使得该性质是可判定的。\n- C 是错误的：该语言不仅仅是图灵可识别的；它是可判定的。\n- D 是错误的：可判定性不依赖于具体的标准编码方案，只要它是有效的编码即可；对于任何固定的有效编码，上述判定器都有效。\n- E 是错误的：该语言不是空的；例如，一台立即接受任何输入的图灵机，将在少于 4096 步内接受其自身的描述。\n\n因此，正确的陈述是 A。", "answer": "$$\\boxed{A}$$", "id": "1377286"}]}