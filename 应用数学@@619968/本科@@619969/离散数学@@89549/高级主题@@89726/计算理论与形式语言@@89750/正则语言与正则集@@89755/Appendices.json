{"hands_on_practices": [{"introduction": "在理论计算机科学中，将语言的描述性规则转化为精确的数学模型是第一步。这个练习将指导你为一个包含特定子串的简单语言构建一个非确定性有限自动机 (NFA)。通过这个过程，你将亲身体验到非确定性如何简化自动机的设计，并为模式匹配等实际应用打下基础。[@problem_id:1396488]", "problem": "一位计算机科学家正在为一个简单的命令语言设计一个解析器。该语言的字母表定义为 $\\Sigma = \\{a, b, c\\}$。一个命令字符串是有效的，当且仅当它包含子串 `ac` 或子串 `abc`。为了识别这些有效的命令，需要构建一个非确定性有限自动机（NFA）。\n\n接受这个有效命令语言的 NFA 所需的最少状态数（包括起始状态和任何最终状态）是多少？", "solution": "设该语言为 $L$。一个字符串 $w$ 属于 $L$，如果它的形式是 $x \\cdot s \\cdot y$，其中 $x, y \\in \\Sigma^*$（由字母表 $\\Sigma$ 中的符号组成的任意字符串），并且 $s$ 是 `ac` 或 `abc`。我们想找到接受语言 $L$ 的非确定性有限自动机（NFA）所需的最少状态数。\n\n两个所需的子串 `ac` 和 `abc` 共享一个共同的前缀 `a`。我们可以利用这个重叠部分来设计一个高效的 NFA。让我们逐个状态地构建 NFA。\n\n1.  **起始状态 ($q_0$)**：这是初始状态。在遇到目标子串的任何部分之前，我们都处于这个状态。读取任何字符都可能不会使我们更接近最终状态，因此我们需要一个对每个符号都设有回到该状态的转移。然而，符号 `a` 很特殊，因为它是两个目标子串的开头。因此，在读取一个 `a` 时，NFA 必须非确定性地选择留在 $q_0$（以处理 `a` 不是所需子串开头的情况，例如在像 `baac` 这样的字符串中）或转移到一个新状态，该状态表示一个潜在匹配的开始。\n    - 设 $q_0$ 为起始状态。\n    - 从 $q_0$ 的转移：$\\delta(q_0, a) = \\{q_0, q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_0, c) = \\{q_0\\}$。\n\n2.  **看到 'a' 后的状态 ($q_1$)**：此状态表示我们刚刚看到了一个 `a`，它可能是 `ac` 或 `abc` 的前缀。\n    - 从 $q_1$ 开始，如果下一个符号是 `c`，我们就成功找到了子串 `ac`。我们必须转移到一个最终（接受）状态。我们将此最终状态称为 $q_f$。因此，我们添加转移 $\\delta(q_1, c) = \\{q_f\\}$。\n    - 从 $q_1$ 开始，如果下一个符号是 `b`，我们可能正在形成子串 `abc`。我们需要转移到一个新状态来记住我们已经看到了 `ab`。我们将此状态称为 $q_2$。因此，我们添加转移 $\\delta(q_1, b) = \\{q_2\\}$。\n    - 如果下一个符号是 `a`，则 `ac` 和 `abc` 的序列都被破坏。这条非确定性路径终止。自动机依赖于另一条路径（即在遇到第一个 `a` 时停留在 $q_0$ 的那条路径）来在后面寻找有效的子串。\n\n3.  **看到 'ab' 后的状态 ($q_2$)**：此状态表示已经看到了前缀 `ab`。\n    - 从 $q_2$ 开始，如果下一个符号是 `c`，我们就找到了子串 `abc`。我们必须转移到最终状态 $q_f$。因此，我们添加转移 $\\delta(q_2, c) = \\{q_f\\}$。\n    - 对于任何其他符号（`a` 或 `b`），`abc` 序列被破坏，此路径终止。\n\n4.  **最终状态 ($q_f$)**：这是一个接受状态。到达此状态意味着我们已经找到了 `ac` 或 `abc`。因为该语言接受任何*包含*这些子串之一的字符串，所以出现在子串之后的任何字符都不会改变字符串的有效性。因此，一旦进入最终状态，NFA 应该保持在该状态，无论后续输入是什么。这是一个常见的“陷阱”式接受状态。\n    - 从 $q_f$ 的转移：$\\delta(q_f, a) = \\{q_f\\}$，$\\delta(q_f, b) = \\{q_f\\}$，$\\delta(q_f, c) = \\{q_f\\}$。\n\n构建的 NFA 有四个状态：$\\{q_0, q_1, q_2, q_f\\}$，其中 $q_0$ 是起始状态，$q_f$ 是唯一的最终状态。\n\n现在，我们必须论证 4 是最少状态数。我们可以通过证明所有四个状态都是必要的来做到这一点，因为它们代表了关于到目前为止已处理字符串的不同的、可区分的信息。如果存在某个字符串，从一个状态开始会导出接受状态，而从另一个状态开始则不会，那么这两个状态就是可区分的。\n\n-   **$q_f$ 与非最终状态 ($q_0, q_1, q_2$)**：$q_f$ 是一个最终状态，而其他状态不是。它们可以通过空字符串 $\\epsilon$ 来区分。\n\n-   **$q_0$ 与 $q_1$**：从 $q_1$ 开始，输入字符串 `c` 会导出最终状态 $q_f$。从 $q_0$ 开始，输入字符串 `c` 会返回到 $q_0$，对于这条路径来说，这不是一个最终状态。因此，$q_0$ 和 $q_1$ 是可区分的。\n\n-   **$q_0$ 与 $q_2$**：从 $q_2$ 开始，输入字符串 `c` 会导出 $q_f$。从 $q_0$ 开始，`c` 会导出 $q_0$。因此，$q_0$ 和 $q_2$ 是可区分的。\n\n-   **$q_1$ 与 $q_2$**：这是一个关键的比较。从 $q_1$ 和 $q_2$ 开始，输入字符串 `c` 都会导出接受状态。但是，考虑输入字符串 `bc`。从 $q_1$ 开始，读取 `b` 会将我们带到状态 $q_2$，然后读取 `c` 将我们带到状态 $q_f$（接受）。所以，从 $q_1$ 开始，字符串 `bc` 被接受。从 $q_2$ 开始，没有关于 `b` 的转移，所以该路径终止，字符串 `bc` 不被接受。因此，$q_1$ 和 $q_2$ 是可区分的。\n\n由于所有四个状态 ($q_0, q_1, q_2, q_f$) 都是两两可区分的，没有两个状态可以被合并。因此，最少需要 4 个状态。", "answer": "$$\\boxed{4}$$", "id": "1396488"}, {"introduction": "虽然 NFA 在设计上十分灵活，但在实际的计算机实现中，我们通常需要一个行为完全确定的模型，即确定性有限自动机 (DFA)。本练习将带你实践一个核心算法——子集构造法，将一个给定的 NFA 转换为等价的 DFA。这个转换过程是理解两种自动机模型之间等价关系的关键，也是编译原理和文本处理工具中的基础技术。[@problem_id:1396478]", "problem": "考虑一个非确定性有限自动机 (NFA)，记作 $M$，它被设计用于接受所有倒数第二个字符为 '1' 的二进制字符串集合。该自动机的字母表为 $\\Sigma = \\{0, 1\\}$。\n\nNFA $M$ 由一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 形式化定义，其中：\n- 状态集为 $Q = \\{q_0, q_1, q_2\\}$。\n- 字母表为 $\\Sigma = \\{0, 1\\}$。\n- 起始状态为 $q_0$。\n- 终止（接受）状态集为 $F = \\{q_2\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$（其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集）由下表给出：\n\n| 状态    | 输入 '0' | 输入 '1'    |\n|---------|-----------|-------------|\n| $q_0$   | $\\{q_0\\}$ | $\\{q_0, q_1\\}$|\n| $q_1$   | $\\{q_2\\}$ | $\\{q_2\\}$   |\n| $q_2$   | $\\emptyset$ | $\\emptyset$   |\n\n你的任务是使用标准的子集构造算法将此 NFA 转换为一个等价的确定性有限自动机 (DFA)。在你的构造中，你应当只包括从 DFA 的起始状态可达的状态。\n\n完成转换后，确定最终得到的 DFA 中的状态总数。", "solution": "我们应用子集构造法，将给定的 NFA $M=(Q, \\Sigma, \\delta, q_0, F)$ 转换为一个 DFA $M'=(Q', \\Sigma, \\delta', S_0, F')$，其中：\n- $Q' \\subseteq \\mathcal{P}(Q)$ 是从 $S_0$ 可达的 $Q$ 的所有子集组成的集合，\n- $S_0=\\{q_0\\}$ （因为没有 $\\epsilon$-转移，所以 $q_0$ 的 $\\epsilon$-闭包是 $\\{q_0\\}$），\n- 对于 $S\\subseteq Q$ 和 $a\\in\\Sigma$，有 $\\delta'(S,a) = \\bigcup_{q \\in S} \\delta(q,a)$，\n- $F'=\\{S \\subseteq Q \\mid S \\cap F \\neq \\emptyset\\}$。\n\n从 $S_0=\\{q_0\\}$ 开始计算可达子集。使用给定的 NFA 转移函数 $\\delta(q_0,0)=\\{q_0\\}$，$\\delta(q_0,1)=\\{q_0,q_1\\}$，$\\delta(q_1,0)=\\{q_2\\}$，$\\delta(q_1,1)=\\{q_2\\}$，$\\delta(q_2,0)=\\emptyset$，$\\delta(q_2,1)=\\emptyset$：\n\n1. 从 $\\{q_0\\}$ 出发：\n$$\n\\delta'(\\{q_0\\},0)=\\delta(q_0,0)=\\{q_0\\},\\quad\n\\delta'(\\{q_0\\},1)=\\delta(q_0,1)=\\{q_0,q_1\\}.\n$$\n目前可达的状态为：$\\{q_0\\}$、$\\{q_0, q_1\\}$。\n\n2. 从 $\\{q_0, q_1\\}$ 出发：\n$$\n\\delta'(\\{q_0,q_1\\},0)=\\delta(q_0,0)\\cup\\delta(q_1,0)=\\{q_0\\}\\cup\\{q_2\\}=\\{q_0,q_2\\},\n$$\n$$\n\\delta'(\\{q_0,q_1\\},1)=\\delta(q_0,1)\\cup\\delta(q_1,1)=\\{q_0,q_1\\}\\cup\\{q_2\\}=\\{q_0,q_1,q_2\\}.\n$$\n新的可达子集为：$\\{q_0, q_2\\}$、$\\{q_0, q_1, q_2\\}$。\n\n3. 从 $\\{q_0, q_2\\}$ 出发：\n$$\n\\delta'(\\{q_0,q_2\\},0)=\\delta(q_0,0)\\cup\\delta(q_2,0)=\\{q_0\\}\\cup\\emptyset=\\{q_0\\},\n$$\n$$\n\\delta'(\\{q_0,q_2\\},1)=\\delta(q_0,1)\\cup\\delta(q_2,1)=\\{q_0,q_1\\}\\cup\\emptyset=\\{q_0,q_1\\}.\n$$\n没有新的子集。\n\n4. 从 $\\{q_0,q_1,q_2\\}$ 出发：\n$$\n\\delta'(\\{q_0,q_1,q_2\\},0)=\\delta(q_0,0)\\cup\\delta(q_1,0)\\cup\\delta(q_2,0)=\\{q_0\\}\\cup\\{q_2\\}\\cup\\emptyset=\\{q_0,q_2\\},\n$$\n$$\n\\delta'(\\{q_0,q_1,q_2\\},1)=\\delta(q_0,1)\\cup\\delta(q_1,1)\\cup\\delta(q_2,1)=\\{q_0,q_1\\}\\cup\\{q_2\\}\\cup\\emptyset=\\{q_0,q_1,q_2\\}.\n$$\n没有新的子集。\n\n因此，可达的 DFA 状态恰好为 $\\{q_0\\}$、$\\{q_0, q_1\\}$、$\\{q_0, q_2\\}$ 和 $\\{q_0, q_1, q_2\\}$。空集以及任何不包含 $q_0$ 的子集都是不可达的，因为对于任意 $a \\in \\Sigma$，$\\delta(q_0,a)$ 都包含 $q_0$，这阻止了向不含 $q_0$ 的子集或向 $\\emptyset$ 的转移。因此，最终得到的 DFA（只计算可达状态）的状态总数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "1396478"}, {"introduction": "对于任何一个正则语言，都存在一个状态数最少的唯一 DFA，即最小 DFA。这个练习将引导你为一个由多个条件组合定义的语言，直接构建其最小 DFA。通过分析语言的内在属性（在本例中是两个独立的模数条件），你将学会如何运用 Myhill-Nerode 定理的思想和乘积构造法，来系统地确定最小状态数，这是设计高效状态机的终极目标。[@problem_id:1396516]", "problem": "设 $\\Sigma = \\{0, 1\\}$ 为二进制字母表。对于任意字符串 $w \\in \\Sigma^*$，记 $|w|_0$ 为 $w$ 中符号 '0' 出现的次数，记 $|w|_1$ 为 $w$ 中符号 '1' 出现的次数。\n\n考虑字母表 $\\Sigma$ 上的语言 $L$，其定义如下：\n$$ L = \\{ w \\in \\Sigma^* \\mid |w|_0 \\text{ 是偶数，且 } |w|_1 \\equiv 1 \\pmod 3 \\} $$\n\n确定有限自动机 (DFA) 是一种接受或拒绝给定符号串的有限状态机。对于任何正则语言，都存在一个接受该语言且状态数最少的唯一 DFA。这个自动机被称为最小 DFA。\n\n接受语言 $L$ 的最小 DFA 有多少个状态？", "solution": "我们追踪字符串 $w \\in \\{0,1\\}^*$ 的两个独立的模属性：\n1) $0$ 的数量的奇偶性，即 $|w|_0 \\pmod 2$ 是 $0$ (偶数) 还是 $1$ (奇数)。\n2) $1$ 的数量模 $3$ 的余数，即 $|w|_1 \\pmod 3 \\in \\{0,1,2\\}$。\n\n定义一个识别偶数个 $0$ 的 DFA $A$：\n- 状态：$\\{E,O\\}$，其中 $E$ 表示 $|w|_0 \\equiv 0 \\pmod 2$，$O$ 表示 $|w|_0 \\equiv 1 \\pmod 2$。\n- 起始状态：$E$。\n- 接受状态：$\\{E\\}$。\n- 转移：在输入为 $0$ 时，在 $E$ 和 $O$ 之间切换；在输入为 $1$ 时，保持在当前状态。\n这个 DFA 是最小的，有 $2$ 个状态，因为 $E$ 和 $O$ 可通过空后缀区分：一个状态是接受状态，而另一个不是。\n\n定义一个追踪 $|w|_1 \\pmod 3$ 的 DFA $B$：\n- 状态：$\\{0,1,2\\}$，表示 $|w|_1 \\pmod 3$ 的余数类。\n- 起始状态：$0$。\n- 接受状态：$\\{1\\}$。\n- 转移：在输入为 $1$ 时，从状态 $r$ 转移到 $r+1 \\pmod 3$；在输入为 $0$ 时，保持在当前状态。\n这个 DFA 是最小的，有 $3$ 个状态。为了证明两两可区分性，取不同的 $r_1, r_2 \\in \\{0,1,2\\}$，并追加 $t$ 个 $1$，其中 $t \\equiv 1 - r_1 \\pmod 3$。从 $r_1$ 开始，将到达接受状态 $1$，而从 $r_2$ 开始，将到达 $r_2 + t \\equiv r_2 - r_1 + 1 \\pmod 3$，当且仅当 $r_2 = r_1$ 时，该值才等于 $1$。因此，不同的余数是可区分的。\n\n为了识别 $L = \\{ w \\mid |w|_0 \\equiv 0 \\pmod 2 \\text{ 且 } |w|_1 \\equiv 1 \\pmod 3 \\}$，我们采用标准的乘积构造法 $C = A \\times B$：\n- 状态：$\\{E,O\\} \\times \\{0,1,2\\}$，总计 $2 \\times 3 = 6$ 个状态。\n- 起始状态：$(E,0)$。\n- 接受状态：$\\{(E,1)\\}$，因为两个条件都必须满足。\n- 转移：在输入为 $0$ 时，$(z,r) \\mapsto (\\text{toggle}(z), r)$；在输入为 $1$ 时，$(z,r) \\mapsto (z, r+1 \\pmod 3)$。\n\n可达性：所有 $6$ 个状态都可以通过合适的字符串从 $(E,0)$ 到达。例如：\n- $(O,0)$ 可通过 $0$ 到达，\n- $(E,1)$ 可通过 $1$ 到达，\n- $(O,1)$ 可通过 $10$ 到达，\n- $(E,2)$ 可通过 $11$ 到达，\n- $(O,2)$ 可通过 $110$ 到达。\n\n$C$ 的最小性：我们证明任意两个不同的状态都是可区分的。\n- 若 $(z_1, r_1)$ 和 $(z_2, r_2)$ 满足 $r_1 \\neq r_2$，则追加 $t$ 个 $1$，其中 $t \\equiv 1 - r_1 \\pmod 3$。这样，从第一个状态出发，其 $1$ 的余数分量会变为 $1$；而从第二个状态出发，其 $1$ 的余数分量不为 $1$。接下来，追加 $s$ 个 $0$，其中 $s$ 的奇偶性可被选择来使得从 $z_1$ 开始的路径的奇偶性分量变为 $E$（偶数）。这样，从 $(z_1, r_1)$ 出发后会到达接受状态，而从 $(z_2, r_2)$ 出发则一定不会（因为其 $1$ 的余数分量不为 $1$）。因此它们是可区分的。\n- 若 $r_1 = r_2$ 但 $z_1 \\neq z_2$，则追加 $t$ 个 $1$，其中 $t \\equiv 1 - r_1 \\pmod 3$，使得两个状态的 $1$ 的余数分量都变为 $1$。然后追加奇数个 $0$ 来切换奇偶性分量：这样，两个状态中恰好有一个的奇偶性分量会变为 $E$。因此，两者中恰好有一个会到达接受状态，所以它们是可区分的。\n\n因此，所有 $6$ 个乘积状态都位于不同的 Myhill-Nerode 等价类中，所以接受语言 $L$ 的最小 DFA 恰好有 $6$ 个状态。\n\n因此，接受语言 $L$ 的最小 DFA 的状态数是 $6$。", "answer": "$$\\boxed{6}$$", "id": "1396516"}]}