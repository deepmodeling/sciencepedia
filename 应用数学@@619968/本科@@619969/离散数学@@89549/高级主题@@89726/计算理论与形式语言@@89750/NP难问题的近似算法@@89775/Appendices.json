{"hands_on_practices": [{"introduction": "在许多计算和制造场景中，如何将一系列任务高效地分配到多个处理器或机器上是一个核心挑战，这个调度问题通常是 NP-难的。本练习将带你应用一种经典且直观的近似算法——“最长处理时间优先”(Longest Processing Time, LPT) 启发式算法。通过模拟一个高性能计算集群的任务调度过程，你将亲身体验如何使用简单的贪心规则来最小化所有任务完成的总时间（即完工时间），并理解这种策略为何能为复杂的优化问题提供一个高质量的近似解。[@problem_id:1349787]", "problem": "一个研究团队正在管理一个用于运行科学模拟的小型高性能计算集群。该集群由 $m=3$ 个相同的计算节点组成，可以并行处理作业。团队需要运行一批包含6个计算作业，其处理时间（以小时为单位）分别为：9、8、7、6、5 和 2。\n\n集群的自动调度器使用一种特定的“高需求优先”协议来分配这些作业。该协议的操作方式如下：\n1. 所有作业按其所需处理时间的降序排列在一个队列中。\n2. 调度器从队列头部逐一取出作业，并将每个作业分配给当前已分配总处理时间最短的计算节点。如果负载最小的节点存在平局，可以选择任何一个平局节点。\n\n计算整批作业的最终完成时间，也称为完工时间（makespan）。完工时间的定义是：从开始直到任何节点上的最后一个作业完成所经过的总时间。以小时为单位表示您的答案。", "solution": "我们应用所述的“高需求优先”协议，这实际上是在 $m=3$ 个相同并行机器上的最长处理时间优先规则。首先，将作业按处理时间的降序排序。给定的时间已经按降序排列：\n$$9,\\,8,\\,7,\\,6,\\,5,\\,2.$$\n设 $L_{1},L_{2},L_{3}$ 分别表示节点 1、2、3 上当前已分配的总负载（以小时为单位）。初始时，\n$$L_{1}=0,\\quad L_{2}=0,\\quad L_{3}=0.$$\n逐一处理作业，总是将下一个作业分配给当前负载最小的节点（按规定，平局时可任意选择）：\n\n1. 将作业 $9$ 分配给负载最小的节点（所有节点都处于平局）。选择节点 1：\n$$L_{1}=0+9=9,\\quad L_{2}=0,\\quad L_{3}=0.$$\n2. 将作业 $8$ 分配给负载最小的节点（节点 2 和 3 负载均为 $0$，处于平局）。选择节点 2：\n$$L_{1}=9,\\quad L_{2}=0+8=8,\\quad L_{3}=0.$$\n3. 将作业 $7$ 分配给负载最小的节点（节点 3，负载为 $0$）：\n$$L_{1}=9,\\quad L_{2}=8,\\quad L_{3}=0+7=7.$$\n4. 将作业 $6$ 分配给负载最小的节点（节点 3，负载为 $7$）：\n$$L_{1}=9,\\quad L_{2}=8,\\quad L_{3}=7+6=13.$$\n5. 将作业 $5$ 分配给负载最小的节点（节点 2，负载为 $8$）：\n$$L_{1}=9,\\quad L_{2}=8+5=13,\\quad L_{3}=13.$$\n6. 将作业 $2$ 分配给负载最小的节点（节点 1，负载为 $9$）：\n$$L_{1}=9+2=11,\\quad L_{2}=13,\\quad L_{3}=13.$$\n\n最终各节点的负载为 $L_{1}=11$，$L_{2}=13$，$L_{3}=13$。完工时间（makespan），定义为最后一个作业的完成时间，即最大负载：\n$$C_{\\max}=\\max\\{L_{1},L_{2},L_{3}\\}=13.$$\n因此，这批作业的总完成时间为 $13$ 小时。", "answer": "$$\\boxed{13}$$", "id": "1349787"}, {"introduction": "接下来，我们将从调度问题转向另一个基础的 NP-难问题——集合覆盖问题，其目标是用最少的集合覆盖一个全集中的所有元素。这个问题有一个著名的贪心近似算法：在每一步选择能覆盖最多未被覆盖元素的新集合。本练习提供了一个具体的集合覆盖实例，让你能够一步步地执行这个贪心策略，从而加深对“边际效益最大化”这一核心思想的理解，并观察到贪心选择是如何根据解的当前状态动态调整的。[@problem_id:1462666]", "problem": "集合覆盖（SET-COVER）问题是计算机科学中的一个经典问题。给定一个元素全集 $U$ 和一个 $U$ 的子集族 $\\mathcal{S}$，目标是找到 $\\mathcal{S}$ 的一个子集族（称为一个覆盖），它包含最少数量的集合，且这些集合的并集等于全集 $U$。\n\n由于找到精确的最小覆盖在计算上是困难的（这是一个NP-难问题），因此通常使用近似算法。一种常见的方法是贪心算法，其过程定义如下：\n1. 初始化未覆盖元素的集合 $U_{unc}$ 为整个全集 $U$。\n2. 初始化覆盖 $C$ 为一个空集。\n3. 当 $U_{unc}$ 不为空时：\n   a. 从原始集族 $\\mathcal{S}$ 中选择一个集合 $S$，该集合能覆盖当前 $U_{unc}$ 中最大数量的元素。如果存在多个集合覆盖的元素数量并列最多，则选择索引最小的集合（例如，如果 $i < j$，则选择 $S_i$ 而不是 $S_j$）。\n   b. 将选定的集合 $S$ 添加到覆盖 $C$ 中。\n   c. 通过移除所选集合 $S$ 的元素来更新 $U_{unc}$ （即 $U_{unc} \\leftarrow U_{unc} \\setminus S$）。\n4. 算法终止并返回覆盖 $C$。\n\n考虑一个由以下条件定义的集合覆盖问题实例：\n- 全集 $U = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\\}$。\n- 集族 $\\mathcal{S} = \\{S_1, S_2, S_3, S_4, S_5, S_6\\}$，其中：\n  - $S_1 = \\{1, 2, 3, 4, 5\\}$\n  - $S_2 = \\{6, 7, 8, 9\\}$\n  - $S_3 = \\{10, 11, 12\\}$\n  - $S_4 = \\{1, 6, 10, 11\\}$\n  - $S_5 = \\{2, 3, 7, 8\\}$\n  - $S_6 = \\{4, 9, 12\\}$\n\n令 $C_{greedy}$ 为对该实例应用贪心算法所找到的集合覆盖。计算 $C_{greedy}$ 中所有集合的基数（大小）之和。即，计算表达式 $\\sum_{S \\in C_{greedy}} |S|$ 的值。", "solution": "我们按照规定应用贪心算法。在每次迭代中，我们选择能够最大化边际覆盖（由 $|S \\cap U_{unc}|$ 衡量）的集合，并用最小索引打破平局。\n\n初始化 $U_{unc} = U = \\{1,2,3,4,5,6,7,8,9,10,11,12\\}$ 和 $C = \\emptyset$。\n\n第一次迭代：计算所有 $i$ 对应的 $|S_{i} \\cap U_{unc}|$。\n- $|S_{1} \\cap U_{unc}| = |S_{1}| = 5$。\n- $|S_{2} \\cap U_{unc}| = 4$。\n- $|S_{3} \\cap U_{unc}| = 3$。\n- $|S_{4} \\cap U_{unc}| = 4$。\n- $|S_{5} \\cap U_{unc}| = 4$。\n- $|S_{6} \\cap U_{unc}| = 3$。\n最大值为 $5$，仅由 $S_{1}$ 达到。选择 $S_{1}$。更新 $C \\leftarrow \\{S_{1}\\}$ 和 $U_{unc} \\leftarrow U_{unc} \\setminus S_{1} = \\{6,7,8,9,10,11,12\\}$。\n\n第二次迭代：计算 $|S_{i} \\cap U_{unc}|$。\n- $|S_{1} \\cap U_{unc}| = 0$。\n- $|S_{2} \\cap U_{unc}| = |\\{6,7,8,9\\}| = 4$。\n- $|S_{3} \\cap U_{unc}| = |\\{10,11,12\\}| = 3$。\n- $|S_{4} \\cap U_{unc}| = |\\{6,10,11\\}| = 3$。\n- $|S_{5} \\cap U_{unc}| = |\\{7,8\\}| = 2$。\n- $|S_{6} \\cap U_{unc}| = |\\{9,12\\}| = 2$。\n最大值为 $4$，仅由 $S_{2}$ 达到。选择 $S_{2}$。更新 $C \\leftarrow \\{S_{1}, S_{2}\\}$ 和 $U_{unc} \\leftarrow U_{unc} \\setminus S_{2} = \\{10,11,12\\}$。\n\n第三次迭代：计算 $|S_{i} \\cap U_{unc}|$。\n- $|S_{1} \\cap U_{unc}| = 0$。\n- $|S_{2} \\cap U_{unc}| = 0$。\n- $|S_{3} \\cap U_{unc}| = |\\{10,11,12\\}| = 3$。\n- $|S_{4} \\cap U_{unc}| = |\\{10,11\\}| = 2$。\n- $|S_{5} \\cap U_{unc}| = 0$。\n- $|S_{6} \\cap U_{unc}| = |\\{12\\}| = 1$。\n最大值为 $3$，仅由 $S_{3}$ 达到。选择 $S_{3}$。更新 $C \\leftarrow \\{S_{1}, S_{2}, S_{3}\\}$ 和 $U_{unc} \\leftarrow \\emptyset$。算法终止。\n\n因此 $C_{greedy} = \\{S_{1}, S_{2}, S_{3}\\}$，所要求的和为\n$$\\sum_{S \\in C_{greedy}} |S| = |S_{1}| + |S_{2}| + |S_{3}| = 5 + 4 + 3 = 12.$$", "answer": "$$\\boxed{12}$$", "id": "1462666"}, {"introduction": "虽然贪心算法很实用，但对于某些问题，我们可以设计出性能更强的近似方案。本练习将向你介绍一种更高级的近似算法类别——全多项式时间近似方案 (Fully Polynomial-Time Approximation Scheme, FPTAS)，它允许用户在解的精度和计算时间之间进行权衡。你将为一个经典的 0-1 背包问题应用 FPTAS，通过一个名为“值缩放”的关键技术，构建一个近似解，其总价值可以任意接近最优解。这个练习将揭示近似算法设计中一个深刻的思想：通过适当“模糊”问题的输入，我们可以显著降低求解的复杂度，同时保证解的质量。[@problem_id:1349838]", "problem": "星际项目委员会 (IPC) 正在为一项即将进行的深空任务最终确定其有效载荷选择。火箭有严格的有效载荷质量上限，不能超过。每个候选项目都有其相应的质量和一个指定的“科学价值”得分。目标是选择一个项目子集，在不超过质量上限的前提下，使总科学价值最大化。\n\n这个选择问题是 NP难的 0-1 背包问题的一个变体。由于为大量项目找到精确的最优解在计算上是不可行的，IPC 采用了一种全多项式时间近似方案 (FPTAS)。对于一个最大化问题，给定任意精度参数 $\\epsilon > 0$，FPTAS 能找到一个总价值至少为最优值 $(1 - \\epsilon)$ 倍的解，并且其运行时间在输入大小和 $1/\\epsilon$ 上都是多项式的。\n\nIPC 采用的具体 FPTAS 算法工作流程如下：\n1.  给定 $n$ 个项目，设 $V_{\\max}$ 为任意单个项目的最大科学价值。\n2.  计算缩放因子 $K = \\frac{\\epsilon V_{\\max}}{n}$。\n3.  对于每个原始价值为 $v_i$ 的项目 $i$，计算一个新的缩减后的整数价值 $v'_i = \\lfloor \\frac{v_i}{K} \\rfloor$。\n4.  然后，该算法使用原始质量和这些新的缩减价值 $v'_i$ 来找到一个新的背包问题的最优解。选择在质量上限内能够产生最大可能总缩减价值（$v'_i$ 的总和）的项目组合。\n\n假设有三个候选项目，其属性如下：\n-   **Project Alpha**: 科学价值 = 100, 质量 = 10 kg\n-   **Project Beta**: 科学价值 = 51, 质量 = 5 kg\n-   **Project Gamma**: 科学价值 = 51, 质量 = 5 kg\n\n火箭对这些项目的总质量上限为 10 kg。IPC 设定的精度参数为 $\\epsilon = 0.1$。如果多个项目组合产生相同的最大总缩减价值，IPC 的协议是选择具有最高总原始科学价值的组合。\n\n你的任务是确定此 FPTAS 算法所选有效载荷组合的总科学价值。请以单个整数形式提供最终答案。", "solution": "我们精确地应用给定的 FPTAS。有 $n=3$ 个项目，单个项目的最大科学价值为 $V_{\\max}=100$。当 $\\epsilon=0.1$ 时，缩放因子为\n$$\nK=\\frac{\\epsilon V_{\\max}}{n}=\\frac{\\left(\\frac{1}{10}\\right)\\cdot 100}{3}=\\frac{10}{3}.\n$$\n对于每个原始价值为 $v_{i}$ 的项目，其缩减价值为 $v_{i}'=\\left\\lfloor \\frac{v_{i}}{K}\\right\\rfloor=\\left\\lfloor v_{i}\\cdot \\frac{3}{10}\\right\\rfloor$。因此，\n$$\nv_{\\text{Alpha}}'=\\left\\lfloor 100\\cdot \\frac{3}{10}\\right\\rfloor=\\left\\lfloor 30\\right\\rfloor=30,\\quad\nv_{\\text{Beta}}'=\\left\\lfloor 51\\cdot \\frac{3}{10}\\right\\rfloor=\\left\\lfloor \\frac{153}{10}\\right\\rfloor=15,\\quad\nv_{\\text{Gamma}}'=\\left\\lfloor 51\\cdot \\frac{3}{10}\\right\\rfloor=\\left\\lfloor \\frac{153}{10}\\right\\rfloor=15.\n$$\n项目 Alpha 的质量仍为 10 kg，项目 Beta 和 Gamma 的质量各为 5 kg，而载荷上限为 10 kg。我们以最优方式解决这个缩减后的背包问题：\n- 单独选择 Alpha，总缩减价值为 $30$，质量为 $10$ kg。\n- 同时选择 Beta 和 Gamma，总缩减价值为 $15+15=30$，质量为 $5+5=10$ kg。\n- 任何包含 Alpha 以及 Beta 或 Gamma 中任意一个的组合都会超过质量上限，而单独选择 Beta 或 Gamma 得到的缩减价值为 $15$，这不是最优的。\n\n因此，可实现的最大总缩减价值为 $30$，在单独选择 Alpha 和选择 Beta+Gamma 组合之间出现了平局。根据指定的平局打破规则，我们选择具有更高总原始科学价值的组合。单独选择 Alpha 的原始总价值为 $100$，而 Beta+Gamma 组合的原始总价值为 $51+51=102$，因此算法选择 Beta+Gamma。因此，所选有效载荷的总科学价值为 $102$。", "answer": "$$\\boxed{102}$$", "id": "1349838"}]}