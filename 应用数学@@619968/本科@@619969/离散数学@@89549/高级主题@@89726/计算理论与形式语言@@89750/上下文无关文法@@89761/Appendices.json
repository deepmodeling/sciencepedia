{"hands_on_practices": [{"introduction": "掌握上下文无关文法的第一步是学习如何将语言的描述性规范转化为形式化的产生式规则。这个练习聚焦于一个经典的例子——回文，它优雅地展示了上下文无关文法的递归能力。通过为一个特定类型的回文语言构建文法，你将练习递归思考并在文法规则中实现约束条件[@problem_id:1359838]。", "problem": "在一种特殊数据传输协议的设计中，消息被编码为二进制字符串。为了增强错误检测并简化路由硬件，所有有效的消息包都必须遵循两条严格的规则：\n1.  每个有效的包都必须是回文串，即字符串从前向后读和从后向前读都相同。\n2.  每个有效的包都必须以比特 '1' 开始和结束。\n\n所有这些有效包的集合构成一个语言，我们称之为 $L$。例如，'1'、'11'、'101' 和 '11011' 都是语言 $L$ 中的字符串，而 '10'、'010' 和 '1011' 不是。\n\n要为该协议创建一个解析器，需要对语言 $L$ 进行形式化描述。上下文无关文法（CFG）是一组用于生成语言中所有可能字符串的产生式规则。一个文法由以下部分组成：\n-   一组终结符号（这里是 $\\{0, 1\\}$）。\n-   一组非终结符号（用大写字母表示）。\n-   一个指定的开始符号（这里是 $S$）。\n-   一组形如 $A \\to \\alpha$ 的产生式规则，其中 $A$ 是一个非终结符号，$\\alpha$ 是一个由终结符号和非终结符号组成的字符串。符号 `|` 用于表示产生式规则的备选选项（例如，$A \\to \\alpha | \\beta$），$\\varepsilon$ 代表空字符串。\n\n你的任务是确定以下哪个上下文无关文法能正确生成语言 $L$。\n\nA. 非终结符为 $\\{S\\}$，产生式为：\n$S \\to 1S1 \\mid 0S0 \\mid 1 \\mid 0 \\mid \\varepsilon$\n\nB. 非终结符为 $\\{S\\}$，产生式为：\n$S \\to 1 \\mid 1S1$\n\nC. 非终结符为 $\\{S, P\\}$，产生式为：\n$S \\to 1 \\mid 1P1$\n$P \\to 0P0 \\mid 1P1 \\mid 0 \\mid 1 \\mid \\varepsilon$\n\nD. 非终结符为 $\\{S, P\\}$，产生式为：\n$S \\to 1 \\mid 1P1$\n$P \\to 0P0 \\mid 1P1 \\mid 0 \\mid 1$\n\nE. 非终结符为 $\\{S, P\\}$，产生式为：\n$S \\to 1 \\mid 1P1$\n$P \\to 0P0 \\mid 1P1 \\mid \\varepsilon$", "solution": "我们将目标语言 $L$ 定义为所有以 $1$ 开始和结束的回文二进制字符串。等价地，一个字符串 $w$ 属于 $L$ 当且仅当 $w=1$ 或者存在一个在 $\\{0,1\\}$ 上的回文串 $x$（可能为空），使得 $w=1x1$。必要性成立，因为移除一个以 $1$ 开始和结束的回文串的首尾符号会得到一个回文串；充分性成立，因为只要 $x$ 是回文串，$1x1$ 也是回文串。\n\n我们现在根据这个特性来检验每个文法。\n\n文法 A：$S \\to 1S1 \\mid 0S0 \\mid 1 \\mid 0 \\mid \\varepsilon$。这个文法生成所有的二进制回文串，包括 $0$ 和 $\\varepsilon$。由于 $0,\\varepsilon \\notin L$，这个文法严格地过生成，并且不等于 $L$。\n\n文法 B：$S \\to 1 \\mid 1S1$。任何推导要么产生 $1$，要么在先前推导出的字符串周围添加匹配的 $1$。因此，所有推导出的字符串都只包含 $1$ 并且长度为奇数。特别地，$11 \\notin \\mathcal{L}(G_{B})$，但是 $11 \\in L$。因此，这个文法欠生成，并且不等于 $L$。\n\n文法 D：$S \\to 1 \\mid 1P1$，$P \\to 0P0 \\mid 1P1 \\mid 0 \\mid 1$。这里 $P$ 不能推导出 $\\varepsilon$。因此 $S$ 不能推导出 $11$（这需要 $P \\Rightarrow \\varepsilon$）。由于 $11 \\in L$，这个文法欠生成，并且不等于 $L$。\n\n文法 E：$S \\to 1 \\mid 1P1$，$P \\to 0P0 \\mid 1P1 \\mid \\varepsilon$。这里 $P$ 恰好推导出所有偶数长度的回文串（以 $\\varepsilon$ 为基础和对称增长）。因此，$S$ 推导出 $1$ 以及形如 $1x1$ 的字符串，其中 $x$ 是偶数长度的，即所有以 $1$ 开始和结束的偶数长度回文串，外加单个符号 $1$。它不能推导出长度至少为 $3$ 的奇数长度回文串，如 $101$ 或 $111$，而这些都在 $L$ 中。因此，它欠生成，并且不等于 $L$。\n\n文法 C：$S \\to 1 \\mid 1P1$，$P \\to 0P0 \\mid 1P1 \\mid 0 \\mid 1 \\mid \\varepsilon$。非终结符 $P$ 推导出所有的二进制回文串（包括 $\\varepsilon$）。可靠性（Soundness）：如果 $S \\Rightarrow 1$，那么 $1 \\in L$。如果 $S \\Rightarrow 1P1 \\Rightarrow^{*} 1x1$，其中 $x$ 是一个回文串，那么 $1x1$ 是一个以 $1$ 开始和结束的回文串，因此属于 $L$。完备性（Completeness）：令 $w \\in L$。如果 $w=1$，那么 $S \\Rightarrow 1$。否则，将 $w$ 写成 $w=1x1$ 的形式，其中 $x$ 是一个回文串（可能包括 $\\varepsilon$）；由于 $P$ 生成所有回文串，所以 $P \\Rightarrow^{*} x$，因此 $S \\Rightarrow 1P1 \\Rightarrow^{*} 1x1 = w$。所以文法 C 恰好生成语言 $L$。\n\n因此，选项中唯一正确的文法是 C。", "answer": "$$\\boxed{C}$$", "id": "1359838"}, {"introduction": "在设计出初步的文法后，我们常常需要对其进行优化。这个练习将引导你完成一个关键的文法简化过程：移除那些既不能派生出终端串（非生成符号）也无法从开始符号到达（不可达符号）的“无用”符号[@problem_id:1359823]。这不仅仅是一个理论练习，更是创建高效、简洁文法的实用技能，在编译器设计等领域至关重要。", "problem": "考虑一个上下文无关文法 (CFG)，记为 $G = (V, T, P, S)$，其中 $V$ 是变量集，$T$ 是终结符集，$P$ 是产生式集，$S$ 是开始符号。\n\n假设 $G$ 的各组成部分定义如下：\n-   变量集为 $V = \\{S, A, B, C, D, F\\}$。\n-   终结符集为 $T = \\{a, b, c\\}$。\n-   开始符号为 $S$。\n-   产生式集 $P$ 由以下各式给出：\n    $S \\to aA \\mid C$\n    $A \\to bS \\mid D$\n    $B \\to aB \\mid b$\n    $C \\to cC$\n    $D \\to a$\n    $F \\to cS \\mid A$\n\n一个符号 $X \\in V \\cup T$ 被定义为*可生成的*（generating），如果存在至少一个从 $X$ 开始的推导，其结果是一个终结符串。一个变量 $Y \\in V$ 被定义为*可达的*（reachable），如果存在一个从开始符号 $S$ 开始的推导，能产生一个包含 $Y$ 的句型。一个变量如果不是可生成的，或者不是可达的，则被认为是*无用的*（useless）。\n\n你的任务是通过系统地移除所有无用符号及其相关产生式来简化给定的文法 $G$。这是一个两步过程：\n1.  首先，移除所有非生成变量以及任何涉及它们的产生式。\n2.  其次，在第一步得到的文法基础上，移除所有不可达变量及其对应的产生式。\n\n选择正确列出最终简化文法 $G'$ 的产生式集 $P'$ 的选项。\n\nA.\n$S \\to aA$\n$A \\to bS \\mid D$\n$D \\to a$\n\nB.\n$S \\to aA$\n$A \\to bS \\mid D$\n$B \\to aB \\mid b$\n$D \\to a$\n$F \\to cS \\mid A$\n\nC.\n$S \\to aA \\mid C$\n$A \\to bS \\mid D$\n$C \\to cC$\n$D \\to a$\n\nD.\n$S \\to aA$\n$A \\to bS \\mid a$", "solution": "我们通过首先移除所有非生成变量及任何提到它们的产生式，然后从结果文法中移除所有不可达变量来识别无用符号。\n\n步骤 1（非生成变量）：\n如果一个符号可以推导出一个终结符串，那么它就是可生成的。根据定义，$T$ 中的终结符是可生成的。对于变量：\n- $D \\to a$ 意味着 $D$ 是可生成的。\n- $A \\to D$ 且 $D \\Rightarrow a$ 意味着 $A$ 是可生成的，因为 $A \\Rightarrow D \\Rightarrow a$。\n- $S \\to aA$ 且 $A \\Rightarrow D \\Rightarrow a$ 意味着 $S$ 是可生成的，因为 $S \\Rightarrow aA \\Rightarrow aD \\Rightarrow aa$。\n- $B \\to b$ 意味着 $B$ 是可生成的。\n- $F \\to A$ 且 $A$ 是可生成的，这意味着 $F$ 是可生成的；同样，$F \\to cS$ 中由于 $S$ 是可生成的，也能得到一个终结符串。\n- $C \\to cC$ 没有任何到终结符的推导，所以 $C$ 是非生成的。\n\n移除 $C$ 以及任何涉及 $C$ 的产生式。从 $P$ 中，移除 $C \\to cC$ 和 $S \\to C$ 这条选择。步骤 1 之后的文法是：\n$$\nS \\to aA\n$$\n$$\nA \\to bS \\mid D\n$$\n$$\nB \\to aB \\mid b\n$$\n$$\nD \\to a\n$$\n$$\nF \\to cS \\mid A\n$$\n\n步骤 2（不可达变量）：\n如果从 $S$ 推导出的某个句型包含一个变量，那么该变量就是可达的。\n- 根据定义，$S$ 是可达的。\n- 从 $S \\to aA$ 可知，$A$ 是可达的。\n- 从 $A \\to bS \\mid D$ 可知，$S$（已达）和 $D$ 都是可达的。\n- $D \\to a$ 不会引入新的变量。\n- 没有产生式的右侧包含 $B$ 或 $F$，所以它们从 $S$ 开始是不可达的。\n\n移除不可达变量 $B$ 和 $F$ 及其产生式。最终的文法是：\n$$\nS \\to aA\n$$\n$$\nA \\to bS \\mid D\n$$\n$$\nD \\to a\n$$\n这与选项 A 相匹配。注意，内联替换 $D$ 以得到 $A \\to bS \\mid a$ 并不属于指定的无用符号消除过程，因此在此不执行该操作。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1359823"}, {"introduction": "并非所有有效的文法都是等价的；有些文法具有“歧义性” ($ambiguity$)，这会对需要对字符串进行唯一解释的解析器造成问题。这个练习要求你分析和比较为同一语言设计的两个文法，通过为一个字符串寻找多个推导路径来判断哪个文法是歧义的[@problem_id:1359841]。理解和识别歧义性是设计可预测且可靠的解析器的关键一步。", "problem": "一个网络工程师团队正在为一款新的高速分组路由器开发固件。有效数据包的结构由一个基于字母表 $\\{0, 1\\}$ 的形式语言描述。该语言（我们称之为 $L$）包含所有满足以下两个条件之一的二进制字符串 $w$：\n1. $w$ 是一个仅由数字'1'组成的非空序列。\n2. $w$ 由零个或多个'1'后跟一个'0'组成。\n\n现有两个相互竞争的上下文无关文法 $G_1$ 和 $G_2$ 被提出来用于生成此语言 $L$。为了使路由器的解析器高效且完全确定，所选的文法必须是无歧义的。如果一个文法所生成的语言中的每个字符串都只有一个唯一的最左推导，则该文法是无歧义的。\n\n第一个提案，文法 $G_1$，由以下产生式定义，其中 $S$ 是开始符号：\n$S \\to 1S \\mid 0 \\mid Y$\n$Y \\to 1Y \\mid 1$\n\n第二个提案，文法 $G_2$，由以下产生式定义，其中 $S$ 是开始符号：\n$S \\to A \\mid B$\n$A \\to 1A \\mid 0$\n$B \\to 1B \\mid 1$\n\n你的任务是分析这两个文法对于特定数据包字符串 `111` 的行为。确定使用文法 $G_1$ 生成字符串 `111` 的不同最左推导的总数（设为 $N_1$），以及使用文法 $G_2$ 生成同一字符串的不同最左推导的总数（设为 $N_2$）。\n\n将你的答案表示为一个包含两个整数值 $(N_1, N_2)$ 的行矩阵。", "solution": "该语言是 $L=1^{+}\\cup 1^{*}0$，字符串 $111$ 属于其中的 $1^{+}$ 分支。我们计算在每个文法中生成 $111$ 的不同最左推导的数量。\n\n对于 $G_{1}$：\n产生式为 $S\\to 1S\\mid 0\\mid Y$ 和 $Y\\to 1Y\\mid 1$。为了生成一个只包含'1'的字符串，推导过程最终必须使用 $S\\to Y$，且永远不能使用 $S\\to 0$。设 $k$ 为在第一次使用 $S\\to Y$ 之前，初始应用 $S\\to 1S$ 的次数。那么经过 $k$ 步后我们得到 $1^{k}S$，接着是 $1^{k}Y$，并且 $Y$ 必须推导出恰好 $3-k$ 个'1'。由于对于一个固定长度（要生成 $n$ 个'1'，需应用 $n-1$ 次 $Y\\to 1Y$ 然后应用一次 $Y\\to 1$），$Y\\to 1Y\\mid 1$ 会产生一个唯一的最左推导，因此只要 $3-k\\geq 1$（即 $k\\in\\{0,1,2\\}$），每个 $k$ 值都对应一个唯一的最左推导。具体来说，这三个最左推导是：\n$$S\\Rightarrow Y\\Rightarrow 1Y\\Rightarrow 11Y\\Rightarrow 111,$$\n$$S\\Rightarrow 1S\\Rightarrow 1Y\\Rightarrow 11Y\\Rightarrow 111,$$\n$$S\\Rightarrow 1S\\Rightarrow 11S\\Rightarrow 11Y\\Rightarrow 111.$$\n因此 $N_{1}=3$。\n\n对于 $G_{2}$：\n产生式为 $S\\to A\\mid B$，$A\\to 1A\\mid 0$，$B\\to 1B\\mid 1$。由于 $A$ 只能推导出以'0'结尾的字符串，推导出 $111$ 的唯一方法是通过 $S\\Rightarrow B$。接着，$B\\to 1B\\mid 1$ 的形式与上面的 $Y$ 相同，对于一个固定数量的'1'，它会产生一个唯一的最左推导。为了得到三个'1'，我们必须应用两次 $B\\to 1B$，然后应用一次 $B\\to 1$：\n$$S\\Rightarrow B\\Rightarrow 1B\\Rightarrow 11B\\Rightarrow 111.$$\n所以 $N_{2}=1$。\n\n因此，所要求的行矩阵为 $\\begin{pmatrix}N_{1} & N_{2}\\end{pmatrix}=\\begin{pmatrix}3 & 1\\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}3 & 1\\end{pmatrix}}$$", "id": "1359841"}]}