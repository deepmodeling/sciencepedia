{"hands_on_practices": [{"introduction": "在库克-列文定理的证明中，第一步是将图灵机的物理状态转化为布尔逻辑的语言。这个练习将带你实践其中最基本的一项约束：如何确保在任意时刻，每个磁带单元只包含一个符号。掌握这个“独一性”约束的布尔编码是理解整个SAT规约过程的基础。[@problem_id:1405676]", "problem": "在库克-列文定理的证明中，一个多项式时间非确定性图灵机（TM）的计算被转换成一个布尔可满足性问题。这是通过构造一个合取范式（CNF）公式 $\\Phi$ 来实现的，该公式是可满足的当且仅当该图灵机接受其输入。\n\n考虑该构造的一部分，它用于一个磁带字母表为 $\\Gamma = \\{s_0, s_1, s_B\\}$ 的图灵机，其中 $s_B$ 是空白符号。磁带的状态由一组布尔变量 $P_{i,j,s}$ 描述，其中 $P_{i,j,s}$ 为真当且仅当在时间步 $i$，磁带单元 $j$ 包含符号 $s$。\n\n需要强制执行的一个基本约束是，在任何给定的时间，每个磁带单元必须包含来自字母表中的恰好一个符号。\n\n对于时间步 $i=5$ 和磁带单元 $j=2$ 的具体实例，设变量为 $A = P_{5,2,s_0}$，$B = P_{5,2,s_1}$ 和 $C = P_{5,2,s_B}$。下列哪个以合取范式（CNF）写成的公式，正确地表达了在时间 5，磁带单元 2 包含来自集合 $\\{s_0, s_1, s_B\\}$ 中的恰好一个符号的约束？\n\nA. $(A \\lor B \\lor C) \\land (\\neg A \\lor \\neg B) \\land (\\neg A \\lor \\neg C) \\land (\\neg B \\lor \\neg C)$\n\nB. $(A \\lor B \\lor C)$\n\nC. $(\\neg A \\lor \\neg B) \\land (\\neg A \\lor \\neg C) \\land (\\neg B \\lor \\neg C)$\n\nD. $(A \\land B \\land C)$\n\nE. $(A \\lor \\neg B) \\land (\\neg A \\lor C) \\land (B \\lor \\neg C)$", "solution": "我们正在使用布尔变量编码库克-列文“在给定时间每个磁带单元恰好一个符号”的约束。对于时间步 $i=5$ 和磁带单元 $j=2$，定义\n$$\nA = P_{5,2,s_{0}}, \\quad B = P_{5,2,s_{1}}, \\quad C = P_{5,2,s_{B}}.\n$$\n该单元包含来自 $\\{s_{0},s_{1},s_{B}\\}$ 中恰好一个符号的要求意味着：\n1) $A,B,C$ 中至少有一个为真。\n2) $A,B,C$ 中至多有一个为真。\n\n“至少一个”部分是单个子句\n$$\nA \\lor B \\lor C.\n$$\n“至多一个”部分禁止任何一对变量同时为真，等价于\n$$\n\\lnot(A \\land B), \\quad \\lnot(A \\land C), \\quad \\lnot(B \\land C),\n$$\n其 CNF 形式为\n$$\n(\\lnot A \\lor \\lnot B) \\land (\\lnot A \\lor \\lnot C) \\land (\\lnot B \\lor \\lnot C).\n$$\n将两者结合起来得到 CNF\n$$\n(A \\lor B \\lor C) \\land (\\lnot A \\lor \\lnot B) \\land (\\lnot A \\lor \\lnot C) \\land (\\lnot B \\lor \\lnot C),\n$$\n这对应于选项 A。\n\n为确认其他选项不正确：\n- B 只包含了“至少一个”的部分，并允许多个符号同时存在。\n- C 只包含了“至多一个”的部分，并允许三者全为假。\n- D 强制三者都为真，这违反了排他性。\n- E 不等价于“恰好一个”；例如，当 $A=\\text{false}$，$B=\\text{false}$，$C=\\text{false}$ 时，E 中的每个子句求值为\n$$\nA \\lor \\lnot B = \\text{false} \\lor \\text{true} = \\text{true}, \\quad \\lnot A \\lor C = \\text{true} \\lor \\text{false} = \\text{true}, \\quad B \\lor \\lnot C = \\text{false} \\lor \\text{true} = \\text{true},\n$$\n因此即使 $A,B,C$ 都不为真，E 也被满足，这违反了“至少一个”的要求。\n\n因此，正确的 CNF 是选项 A。", "answer": "$$\\boxed{A}$$", "id": "1405676"}, {"introduction": "一旦我们掌握了如何为图灵机的单个组件（如磁带单元）建立模型，下一步就是思考如何捕捉整个机器在任意时刻的完整“构型”（configuration）。这个思想实验要求你将标准的单带图灵机构造方法推广到一个更复杂的双带图灵机。成功解决这个问题，表明你深刻理解了完全描述一个计算状态所需的核心信息。[@problem_id:1456015]", "problem": "在计算复杂性的背景下，我们通常希望通过证明一个非确定性图灵机 (NTM) 可以用命题逻辑公式来表示，从而证明一个问题是 NP 完全的。这涉及创建一组命题变量，这些变量能够完全描述该机器在计算的每一步中的格局。\n\n考虑一种特殊类型的 NTM，它使用两条独立的、无限的、可读写的带，我们称之为带 1 和带 2。长度为 $n$ 的输入字符串初始时写在带 1 上，而带 2 初始时为空白。该机器的转移函数形式为 $\\delta(q, \\sigma_1, \\sigma_2) \\to \\{(q', \\sigma'_1, \\sigma'_2, D_1, D_2), ...\\}$，其中 $q$ 是当前状态，$\\sigma_1$ 和 $\\sigma_2$ 分别是从带 1 和带 2 读取的符号，在得到的新状态 $q'$ 中，机器写入符号 $\\sigma'_1$ 和 $\\sigma'_2$，并根据方向 $D_1, D_2 \\in \\{\\text{Left, Right}\\}$ 移动每条带上的读写头。保证该机器在 $p(n)$ 步内停机，其中 $p(n)$ 是一个关于 $n$ 的多项式。\n\n对于单带 NTM，一个标准的构造使用变量来编码在每个时间步 $t$ 的机器状态 ($Q_{q,t}$)、读写头位置 ($H_{i,t}$) 和每个磁带单元中的符号 ($S_{i,\\sigma,t}$)。为了正确并直接地为上述双带 NTM 的构型建模，必须如何扩展这组变量？\n\nA. 增加第二组读写头位置变量，每条带一个。原始的单组磁带单元变量就足够了，因为机器的状态决定了哪条带正在被修改。\n\nB. 增加第二组读写头位置变量（每条带一个）和第二组独立的磁带单元内容变量（每条带一个）。\n\nC. 扩展状态变量以指示活动的带，例如 $Q_{q,k,t}$，其中 $k \\in \\{1, 2\\}$，并扩展读写头位置变量以指示活动的带。磁带单元变量不需要改变。\n\nD. 保持状态变量不变，但创建新的变量类型来编码值对，例如一个变量用于读写头位置对 $(i_1, i_2)$，一个变量用于正在读取的符号对 $(\\sigma_1, \\sigma_2)$。\n\nE. 不需要新类型的变量。两条带可以建模为一条组合的单带，并且可以在这条更大的带上使用标准的变量集。", "solution": "核心任务是定义一组命题变量，这组变量可以唯一地描述双带非确定性图灵机 (NTM) 在其计算过程中的任何时间步 $t$ 的完整构型，其计算时间上限为多项式时间 $T=p(n)$，空间上限为多项式空间 $S=p(n)$。一个完整的构型，也称为瞬时描述 (ID)，必须捕捉关于机器状态的所有信息。\n\n对于指定的双带 NTM，在时间 $t$ 的构型包括：\n1.  机器的当前状态。\n2.  带 1 上读写头的位置。\n3.  带 2 上读写头的位置。\n4.  带 1 的全部内容。\n5.  带 2 的全部内容。\n\n我们需要创建代表这些组成部分的命题变量。让我们基于标准的单带构造来分析每个部分的需求。时间 $t$ 的索引范围从 $0$ 到 $T$，磁带位置 $i$ 的索引范围从 $0$ 到 $S$。\n\n**1. 机器状态：**\n机器有一个单一的有限状态集。在任何时间 $t$，它都恰好处于一个状态。这与单带情况相同。我们可以定义变量：\n$Q_{q,t}$ 为真当且仅当机器在时间 $t$ 处于状态 $q$。变量集的这一部分不改变。\n\n**2. 读写头位置：**\n机器有两个独立的读写头，每条带一个。带 1 上读写头的位置与带 2 上读写头的位置无关。为了捕捉这一点，我们不能使用单一一组读写头位置变量。我们需要为每个读写头设置一组变量。\n让我们将它们定义为：\n- $H_{1,i,t}$ 为真当且仅当带 1 的读写头在时间 $t$ 位于位置 $i$。\n- $H_{2,i,t}$ 为真当且仅当带 2 的读写头在时间 $t$ 位于位置 $i$。\n因此，我们必须引入第二组不同的读写头位置变量来跟踪第二个读写头。\n\n**3. 带内容：**\n两条带是独立的可读写带。带 1 的内容可以根据转移函数在每一步发生变化，而带 2 的内容也可以独立地发生变化。单一的变量集 $S_{i,\\sigma,t}$ 是不够的，因为它无法区分“带 1 上的单元 $i$ 含有符号 $\\sigma$”和“带 2 上的单元 $i$ 含有符号 $\\sigma$”。为了正确地为系统建模，我们需要分别跟踪每条带的内容。\n我们为磁带单元内容定义两组变量：\n- $S_{1,i,\\sigma,t}$ 为真当且仅当带 1 的单元 $i$ 在时间 $t$ 包含符号 $\\sigma$。\n- $S_{2,i,\\sigma,t}$ 为真当且仅当带 2 的单元 $i$ 在时间 $t$ 包含符号 $\\sigma$。\n这意味着我们还必须引入第二组独立的磁带单元内容变量。\n\n**结论：**\n为了直接为双带 NTM 建模，我们必须通过增加一组用于第二个读写头位置的新变量和一组用于第二条带内容的新变量来扩充单带变量集。这对应于选项 B。\n\n让我们回顾一下其他选项：\n- **A** 是不正确的，因为两条带的内容是独立演变的。单一一组磁带单元内容变量无法捕捉两条带上不同的字符串。\n- **C** 是不正确的，因为 NTM 有一个单一的中央状态，而不是“每条带一个”状态。转移函数依赖于这个单一状态和来自所有带的符号。\n- **D** 是不正确的，因为命题变量是原子的（它们只是真或假）。它们无法编码像“对”这样的复合结构。要表示一个“对”，将需要一个复杂得多的变量集，这最终等同于拥有两组独立的变量。\n- **E** 描述了在单带机上*模拟*多带机的方法。虽然这种模拟是可能的，但问题要求的是为构造命题公式而对双带机的构型进行*直接*建模。库克-列文定理的证明是基于机器的实际定义来构造公式的，而不是基于它的模拟。因此，对于直接构造来说，这不是正确的方法。", "answer": "$$\\boxed{B}$$", "id": "1456015"}, {"introduction": "库克-列文证明的核心在于将图灵机的动态“转移函数” $\\delta$ 编码成一个静态的布尔逻辑公式 $\\phi_{\\text{transition}}$。本练习让你从一个更高的视角思考，即设想一个实际执行此规约的算法。理解这个构造过程，你将明白一个机器的逐步计算行为是如何被一个庞大但结构清晰的逻辑表达式所捕捉的。[@problem_id:1455986]", "problem": "在库克-列文定理的背景下，我们关注的是从复杂度类NP中的任意语言到布尔可满足性（SAT）问题的多项式时间归约。这个归约过程涉及构造一个布尔公式 $\\phi$，该公式是可满足的当且仅当一个给定的非确定性图灵机（NDTM）$M$ 接受输入串 $w$。\n\n设该NDTM为 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{\\text{accept}}, q_{\\text{reject}})$，其中$Q$是状态集合，$\\Sigma$是输入字母表，$\\Gamma$是磁带字母表，$\\delta$是转移函数，$q_0$是起始状态，$q_{\\text{accept}}$和$q_{\\text{reject}}$是唯一的接受和拒绝状态。假设$M$在$p(n)$步内对所有输入停机，其中 $n = |w|$ 且 $p$ 是一个多项式。\n\n$M$在$w$上的计算由一个$p(n) \\times p(n)$的演算表（一个单元格网格）表示。为描述此演算表的内容，使用一个特殊符号集 $C = \\Gamma \\cup (Q \\times \\Gamma)$。单元格中的一个符号 $(q, a) \\in (Q \\times \\Gamma)$ 表示读写头位于该位置，机器处于状态$q$，且磁带单元包含符号$a$。一个来自$\\Gamma$的符号表示读写头不在该单元格。\n\n布尔变量$y_{i,j,s}$的定义域为 $0 \\le i, j < p(n)$ 和 $s \\in C$。当且仅当演算表的单元格$(i, j)$（第$i$行，第$j$列）包含符号$s$时，变量$y_{i,j,s}$为真。\n\n总的布尔公式$\\phi_{M,w}$是四个部分的合取：$\\phi_{\\text{cell}} \\land \\phi_{\\text{start}} \\land \\phi_{\\text{accept}} \\land \\phi_{\\text{transition}}$。公式$\\phi_{\\text{transition}}$负责确保演算表的每一行（一个格局）根据NDTM的转移函数$\\delta$正确地产生下一行。单元格$(i+1, j)$中符号的正确性仅取决于三个单元格$(i, j-1)$、$(i, j)$和$(i, j+1)$中的符号。这被称为一个$2 \\times 3$窗口。\n\n可以构造一个确定性图灵机（DTM）在多项式时间内执行此归约。以下哪个选项正确描述了该DTM用于为公式的$\\phi_{\\text{transition}}$部分生成子句的高层算法？\n\nA. 对于从$0$到$p(n)-2$的每个$i$和从$1$到$p(n)-2$的每个$j$，算法遍历$C$中所有可能的符号四元组$(s_1, s_2, s_3, s_4)$。如果在时间$i$，一个内容为$s_1, s_2, s_3$的$2 \\times 3$窗口在其中心的下方单元格于时间$i+1$产生符号$s_4$的这种局部格局被转移函数$\\delta$**禁止**，则算法输出子句$(\\neg y_{i,j-1,s_1} \\lor \\neg y_{i,j,s_2} \\lor \\neg y_{i,j+1,s_3} \\lor \\neg y_{i+1,j,s_4})$。\n\nB. 对于从$0$到$p(n)-2$的每个$i$和从$0$到$p(n)-1$的每个$j$，算法考虑单元格$(i,j)$和$(i+1,j)$的$2 \\times 2$窗口。它遍历$C$中所有的符号对$(s_1, s_2)$。如果根据$\\delta$，从包含$s_1$的单元格到包含$s_2$的单元格的转移不是一个有效的移动，它会输出子句$(\\neg y_{i,j,s_1} \\lor \\neg y_{i+1,j,s_2})$。\n\nC. 对于从$0$到$p(n)-2$的每个$i$，算法检查第$i$行所有可能的完整格局与第$i+1$行所有可能的完整格局。如果根据$\\delta$，从第$i$行的格局到第$i+1$行的格局的转移是**非法的**，它会生成一个单一、复杂的子句，禁止这对完整的行格局连续出现。\n\nD. 对于从$0$到$p(n)-2$的每个$i$和从$1$到$p(n)-2$的每个$j$，算法遍历$C$中所有可能的符号四元组$(s_1, s_2, s_3, s_4)$。如果在时间$i$，一个内容为$s_1, s_2, s_3$的$2 \\times 3$窗口在时间$i+1$产生$s_4$的这种局部格局是根据$\\delta$的**合法**转移，则算法输出子句$(y_{i,j-1,s_1} \\lor y_{i,j,s_2} \\lor y_{i,j+1,s_3} \\lor y_{i+1,j,s_4})$。", "solution": "我们首先重申定义转移子公式的约束。设 $C=\\Gamma \\cup (Q \\times \\Gamma)$，且演算表由时间 $i \\in \\{0,\\ldots,p(n)-1\\}$ 和磁带位置 $j \\in \\{0,\\ldots,p(n)-1\\}$ 索引。对于每个单元格 $(i,j)$ 和每个 $s \\in C$，布尔变量 $y_{i,j,s}$ 表示单元格 $(i,j)$ 包含符号 $s$。预期的局部一致性条件是，根据转移函数 $\\delta$ 和 $C$ 的定义，$(i+1,j)$ 中的符号完全由其上方$2 \\times 3$窗口中的三个符号，即 $(i,j-1)$、$(i,j)$ 和 $(i,j+1)$ 中的符号决定。\n\n形式上，定义局部允许的四元组集合\n$$\nT \\subseteq C^{4}\n$$\n其中 $(s_{1},s_{2},s_{3},s_{4}) \\in T$ 当且仅当在时间 $i$ 将 $s_{1}$、$s_{2}$、$s_{3}$ 放置在单元格 $(i,j-1)$、$(i,j)$、$(i,j+1)$ 中，可以在由 $\\delta$ 引起的瞬时描述更新下，在时间 $i+1$ 合法地在单元格 $(i+1,j)$ 中产生 $s_{4}$。\n\n为强制只出现允许的局部模式，我们禁止所有非法的局部模式。对于每个时间 $i \\in \\{0,\\ldots,p(n)-2\\}$ 和位置 $j \\in \\{1,\\ldots,p(n)-2\\}$（使得$2 \\times 3$窗口有定义的内部位置），以及对于每个四元组 $(s_{1},s_{2},s_{3},s_{4}) \\in C^{4} \\setminus T$，我们添加一个子句，该子句排除了所有四个相应文字同时成立的合取情况。非法的合取是\n$$\ny_{i,j-1,s_{1}} \\land y_{i,j,s_{2}} \\land y_{i,j+1,s_{3}} \\land y_{i+1,j,s_{4}},\n$$\n所以根据德摩根定律的分配形式，其合取范式的否定是单个子句\n$$\n\\neg y_{i,j-1,s_{1}} \\lor \\neg y_{i,j,s_{2}} \\lor \\neg y_{i,j+1,s_{3}} \\lor \\neg y_{i+1,j,s_{4}}.\n$$\n将所有这些子句对所有的 $i$、$j$ 以及所有的 $(s_{1},s_{2},s_{3},s_{4}) \\notin T$ 进行合取，就精确地得到了强制与 $\\delta$ 保持局部一致性的 $\\phi_{\\text{transition}}$ 部分。生成的子句数量是关于 $p(n)$ 和 $|C|$ 的多项式（具体为 $O(p(n)^{2} |C|^{4})$），因此确定性图灵机可以在多项式时间内生成它们。\n\n我们现在比较这些选项：\n\n选项A完全实现了上述“禁止每个非法的局部$2 \\times 3$模式”的方法，它对每个被禁止的 $(s_{1},s_{2},s_{3},s_{4})$，在 $i \\in \\{0,\\ldots,p(n)-2\\}$ 和 $j \\in \\{1,\\ldots,p(n)-2\\}$ 的范围内，生成子句\n$$\n\\neg y_{i,j-1,s_{1}} \\lor \\neg y_{i,j,s_{2}} \\lor \\neg y_{i,j+1,s_{3}} \\lor \\neg y_{i+1,j,s_{4}}。\n$$\n这与标准的库克-列文构造相匹配。\n\n选项B仅使用一个$2 \\times 2$窗口，忽略了对相邻单元格 $(i,j-1)$ 和 $(i,j+1)$ 的依赖。这不足以捕捉读写头的移动和同步的符号/状态更新，因此它不能正确地编码 $\\delta$。\n\n选项C试图比较整行，生成禁止完整格局对的子句。枚举所有行格局在 $p(n)$ 上是指数级的，所以这不是一个多项式时间归约。\n\n选项D为每个合法的四元组添加一个带有正文字的子句。形如\n$$\ny_{i,j-1,s_{1}} \\lor y_{i,j,s_{2}} \\lor y_{i,j+1,s_{3}} \\lor y_{i+1,j,s_{4}}\n$$\n的子句太弱了：无论特定的局部模式是否出现，它通常都会被满足，而且，即使对所有合法的四元组进行合取，它也无法禁止任何非法的组合。标准的合取范式（CNF）编码是转而禁止非法模式。\n\n因此，正确的高层算法是选项A中描述的那个。", "answer": "$$\\boxed{A}$$", "id": "1455986"}]}