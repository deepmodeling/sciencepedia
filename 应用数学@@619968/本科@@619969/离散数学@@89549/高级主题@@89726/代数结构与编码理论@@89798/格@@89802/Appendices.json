{"hands_on_practices": [{"introduction": "要真正理解格的结构，最好的方法是从其最基本的构成部分——偏序关系开始。这个练习通过一个关于开关控制面板的直观场景，帮助我们形象化地理解元素之间的“前驱”与“紧随”关系。通过确定哪些状态是另一个状态的“紧随后继”，我们实际上是在构建这个格的哈斯图（Hasse diagram）的边，从而揭示其底层的有序结构 [@problem_id:1380545]。这个练习是掌握格论可视化和结构基础的绝佳起点。", "problem": "一个简单的设备控制面板有两个独立的拨动开关，开关1和开关2。每个开关可以处于关闭（OFF）状态（用整数0表示）或开启（ON）状态（用整数1表示）。控制面板的整体状态由一个有序对 $(s_1, s_2)$ 描述，其中 $s_1$ 是开关1的状态，$s_2$ 是开关2的状态。\n\n如果可以仅通过将开关从关闭（OFF）拨到开启（ON）来从状态 $A$ 转换到状态 $B$，则状态 $A = (a_1, a_2)$ 被定义为状态 $B = (b_1, b_2)$ 的“前驱”。换句话说，在此过程中，已经处于开启（ON）状态的开关不能被拨到关闭（OFF）状态。我们用 $A \\preceq B$ 表示这种关系。\n\n此外，我们定义一个状态 $B$ 是状态 $A$ 的“直接后继”，如果 $A$ 是 $B$ 的前驱（$A \\preceq B$），$A$ 不等于 $B$，并且不存在一个不同的状态 $C$（其中 $C \\ne A$ 且 $C \\ne B$）使得 $A$ 是 $C$ 的前驱且 $C$ 是 $B$ 的前驱。\n\n下列哪个集合正确且完整地列出了所有满足 $B$ 是 $A$ 的直接后继的状态对 $(A, B)$？\n\nA. $\\{((0,0), (1,0)), ((0,0), (0,1)), ((1,0), (1,1)), ((0,1), (1,1))\\}$\n\nB. $\\{((0,0), (1,0)), ((0,0), (0,1)), ((0,0), (1,1))\\}$\n\nC. $\\{((0,0), (1,1)), ((1,0), (0,1))\\}$\n\nD. $\\{((0,0), (1,0)), ((0,0), (0,1)), ((1,0), (1,1)), ((0,1), (1,1)), ((0,0), (1,1))\\}$\n\nE. $\\{((1,0), (0,0)), ((0,1), (0,0)), ((1,1), (1,0)), ((1,1), (0,1))\\}$", "solution": "设控制面板的状态集合为 $S$。由于两个开关中的每一个都可以处于两种状态（0或1）之一，所以总的状态数为 $2 \\times 2 = 4$。状态集合为：\n$S = \\{(0,0), (1,0), (0,1), (1,1)\\}$。\n\n对于两个状态 $A = (a_1, a_2)$ 和 $B = (b_1, b_2)$，“前驱”关系 $A \\preceq B$ 被定义为只能通过将开关从关闭（0）拨到开启（1）来从 $A$ 转换到 $B$。这意味着对于每个开关，其在 $B$ 中的状态必须大于或等于其在 $A$ 中的状态。用数学语言来说，这等价于：\n当且仅当 $a_1 \\le b_1$ 且 $a_2 \\le b_2$ 时，有 $(a_1, a_2) \\preceq (b_1, b_2)$。\n这在状态集合 $S$ 上定义了一个偏序。\n\n问题要求找出所有 $B$ 是 $A$ 的“直接后继”的状态对 $(A, B)$。根据定义，这意味着：\n1. $A \\preceq B$\n2. $A \\ne B$（可以与第一个条件结合写成 $A \\prec B$）\n3. 不存在状态 $C$ 使得 $A \\prec C \\prec B$。\n\n这是偏序集中覆盖关系的定义。我们需要找到所有满足 $B$ 覆盖 $A$ 的对 $(A, B)$。我们可以通过系统地检查所有可能的不同状态对来做到这一点。\n\n为清晰起见，我们表示这些状态：\n$S_A = (0,0)$\n$S_B = (1,0)$\n$S_C = (0,1)$\n$S_D = (1,1)$\n\n我们可以分析 $X \\ne Y$ 的状态对 $(X, Y)$ 之间的关系：\n\n1.  **以 $S_A = (0,0)$ 为前驱的对：**\n    -   $S_B = (1,0)$ 是 $S_A$ 的直接后继吗？\n        我们有 $(0,0) \\preceq (1,0)$ 因为 $0 \\le 1$ 且 $0 \\le 0$。它们不相等。我们需要检查是否存在一个状态 $C=(c_1, c_2)$ 使得 $(0,0) \\prec (c_1, c_2) \\prec (1,0)$。这将意味着 $0 \\le c_1 \\le 1$，$0 \\le c_2 \\le 0$，并且 $C$ 必须不同于 $(0,0)$ 和 $(1,0)$。对第二个分量的条件意味着 $c_2 = 0$。对第一个分量的条件，结合 $C \\ne (0,0)$ 和 $C \\ne (1,0)$，是不可能的，因为 $c_1$ 必须是整数。因此，不存在这样的中间状态 $C$。所以，$((0,0), (1,0))$ 是一个有效的对。\n    -   $S_C = (0,1)$ 是 $S_A$ 的直接后继吗？\n        根据与前一种情况的对称性，我们有 $(0,0) \\preceq (0,1)$，并且没有中间状态。所以，$((0,0), (0,1))$ 是一个有效的对。\n    -   $S_D = (1,1)$ 是 $S_A$ 的直接后继吗？\n        我们有 $(0,0) \\preceq (1,1)$ 因为 $0 \\le 1$ 且 $0 \\le 1$。但是我们可以找到一个中间状态。例如，令 $C = S_B = (1,0)$。我们有 $(0,0) \\prec (1,0)$ 和 $(1,0) \\prec (1,1)$。所以，$(0,0) \\prec (1,0) \\prec (1,1)$。由于存在中间状态，$S_D$ 不是 $S_A$ 的直接后继。\n\n2.  **以 $S_B = (1,0)$ 为前驱的对：**\n    -   $S_C = (0,1)$ 是后继吗？不是，因为 $1 \\not\\le 0$，所以 $(1,0) \\not\\preceq (0,1)$。这两个状态是不可比较的。\n    -   $S_D = (1,1)$ 是 $S_B$ 的直接后继吗？\n        我们有 $(1,0) \\preceq (1,1)$ 因为 $1 \\le 1$ 且 $0 \\le 1$。我们检查是否存在中间状态 $C=(c_1, c_2)$ 使得 $(1,0) \\prec (c_1, c_2) \\prec (1,1)$。这要求 $1 \\le c_1 \\le 1$ 且 $0 \\le c_2 \\le 1$。第一部分意味着 $c_1 = 1$。不相等的要求 $C \\ne (1,0)$ 和 $C \\ne (1,1)$，对于一个整数 $c_2$ 这是不可能的。不存在中间状态。所以，$((1,0), (1,1))$ 是一个有效的对。\n\n3.  **以 $S_C = (0,1)$ 为前驱的对：**\n    -   $S_D = (1,1)$ 是 $S_C$ 的直接后继吗？\n        通过与 $S_B$ 情况的对称性，我们有 $(0,1) \\preceq (1,1)$，并且没有中间状态。所以，$((0,1), (1,1))$ 是一个有效的对。\n\n总结 $B$ 是 $A$ 的直接后继的状态对 $(A, B)$：\n- $((0,0), (1,0))$\n- $((0,0), (0,1))$\n- $((1,0), (1,1))$\n- $((0,1), (1,1))$\n\n这些对的完整集合是 $\\{((0,0), (1,0)), ((0,0), (0,1)), ((1,0), (1,1)), ((0,1), (1,1))\\}$。\n这对应于选项 A。\n\n让我们简要分析一下错误的选项：\n-   选项 B 不完整；它遗漏了 $(1,0)$ 和 $(0,1)$ 的后继。\n-   选项 C 包括 $((0,0), (1,1))$，这不是一个直接后继关系，以及 $((1,0), (0,1))$，其中两个状态是不可比较的。\n-   选项 D 是所有满足 $A \\ne B$ 的前驱关系集合（即直接后继关系的传递闭包），但它错误地包含了非直接后继对 $((0,0), (1,1))$。\n-   选项 E 颠倒了前驱关系。\n\n因此，唯一正确的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1380545"}, {"introduction": "在掌握了格的基本结构后，下一步是学习如何在格中进行运算。格不仅仅是元素的有序集合，它也是一个代数结构，其核心在于“交”（meet）和“并”（join）运算。本练习 [@problem_id:1380519] 探讨了一种常见且重要的格结构——积格（product lattice），它在计算机科学和数字逻辑中广泛应用。通过计算两个系统状态的“交”，我们将看到这些运算如何通过逐点（pointwise）方式简洁地定义和执行，从而加深对格运算本质的理解。", "problem": "考虑一个由四个数字组件组成的系统，其索引集为 $\\{1, 2, 3, 4\\}$。每个组件可以处于两种状态之一：'OFF'（关），由整数 0 表示；或 'ON'（开），由整数 1 表示。系统的完整状态可以用一个函数 $s: \\{1, 2, 3, 4\\} \\to \\{0, 1\\}$ 来描述，其中 $s(i)$ 给出组件 $i$ 的状态。\n\n所有可能的系统状态的集合具有一个偏序关系 $\\preceq$。对于任意两个状态 $s_1$ 和 $s_2$，我们定义 $s_1 \\preceq s_2$ 当且仅当对于每个组件 $i \\in \\{1, 2, 3, 4\\}$ 都有 $s_1(i) \\le s_2(i)$，这里使用标准的整数比较 $0 \\le 1$。这个结构形成一个格 (lattice)。\n\n定义了两个特定状态，$f$ 和 $g$，如下：\n- 状态 $f$：组件 1 和 3 为 'ON'（开），而组件 2 和 4 为 'OFF'（关）。\n- 状态 $g$：组件 2 和 3 为 'ON'（开），而组件 1 和 4 为 'OFF'（关）。\n\n您的任务是求这两个状态的交 (meet)，记作 $h = f \\land g$。交被定义为关于偏序关系 $\\preceq$ 的 $f$ 和 $g$ 的最大下界。结果状态 $h$ 由其值的元组 $(h(1), h(2), h(3), h(4))$ 表示。以下哪个选项正确地描述了状态 $h$？\n\nA. $(1, 1, 1, 0)$\n\nB. $(0, 0, 1, 0)$\n\nC. $(0, 0, 0, 0)$\n\nD. $(1, 0, 1, 0)$\n\nE. $(0, 1, 1, 0)$", "solution": "状态空间是函数集合 $s:\\{1,2,3,4\\}\\to\\{0,1\\}$，其上的偏序关系是逐分量定义的：$s_{1}\\preceq s_{2}$ 当且仅当对每个 $i\\in\\{1,2,3,4\\}$ 都有 $s_{1}(i)\\leq s_{2}(i)$。在这个积格 (product lattice) 中，交 $f\\land g$ 是通过在每个坐标上取 $\\{0,1\\}$ 中的交来逐点计算的，这等于取最小值：\n$$\n(f\\land g)(i)=\\min\\{f(i),g(i)\\}\\quad\\text{for all }i\\in\\{1,2,3,4\\}.\n$$\n根据描述：\n- $f$ 的分量 1 和 3 等于 $1$，分量 2 和 4 等于 $0$，所以 $f=(1,0,1,0)$。\n- $g$ 的分量 2 和 3 等于 $1$，分量 1 和 4 等于 $0$，所以 $g=(0,1,1,0)$。\n\n逐坐标计算交：\n$$\n\\begin{aligned}\nh(1)&=\\min\\{f(1),g(1)\\}=\\min\\{1,0\\}=0,\\\\\nh(2)&=\\min\\{f(2),g(2)\\}=\\min\\{0,1\\}=0,\\\\\nh(3)&=\\min\\{f(3),g(3)\\}=\\min\\{1,1\\}=1,\\\\\nh(4)&=\\min\\{f(4),g(4)\\}=\\min\\{0,0\\}=0.\n\\end{aligned}\n$$\n因此，交为 $h=(0,0,1,0)$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1380519"}, {"introduction": "在格论中，一个微妙但至关重要的概念是区分“本身是格的子集”与“格的子格”。一个子集可能自身满足格的公理，但其交和并运算可能与母格中的运算不同。本练习 [@problem_id:1380544] 旨在澄清这一常见误区。通过分析一个数论中的除数格，你将探索一个子集如何构成一个独立的格，却因其运算不封闭于母格的运算之下而不能成为一个“子格”。这个挑战性的问题将极大深化你对格的结构完整性和继承性的理解。", "problem": "在抽象代数和序理论中，一个整数 $n$ 的所有正因数组成的集合，按照“整除”关系（记作 $|$）排序，构成一个称为因数格的结构，记作 $D_n$。如果一个偏序集中的任意一对元素 $\\{a, b\\}$ 都具有唯一的最小上界（称为并，记作 $a \\lor b$）和唯一的最大下界（称为交，记作 $a \\land b$），那么这个偏序集就是一个**格**。对于因数格 $D_n$，并运算对应于最小公倍数（$\\text{lcm}$），交运算对应于最大公因数（$\\text{gcd}$）。\n\n格 $L$ 的一个非空子集 $S$ 是 $L$ 的一个**子格**，如果 $S$ 本身在相同的偏序关系下也是一个格，并且对于 $S$ 中的任意一对元素 $\\{a, b\\}$，它们在 $L$ 中的并和交也都在 $S$ 中。也就是说，$a \\lor b \\in S$ 且 $a \\land b \\in S$。\n\n一个子集 $S \\subseteq L$ 可能在与 $L$ 相同的偏序关系下是一个格，但却不是一个子格，因为对于至少一对元素，其并或交运算与在 $L$ 中的运算不同。\n\n考虑因数格 $D_{30}$。30 的因数集合是 $D_{30} = \\{1, 2, 3, 5, 6, 10, 15, 30\\}$。下列 $D_{30}$ 的子集中，哪一个在整除关系下构成一个格，但**不是** $D_{30}$ 的子格？\n\nA. $S_A = \\{1, 2, 3, 5, 30\\}$\n\nB. $S_B = \\{1, 2, 3, 6, 10\\}$\n\nC. $S_C = \\{1, 2, 3, 5, 6, 10, 15\\}$\n\nD. $S_D = \\{1, 2, 3, 6\\}$\n\nE. $S_E = \\{1, 5, 10, 15, 30\\}$", "solution": "我们在因数格 $D_{30}$ 中进行分析，其元素为 $\\{1,2,3,5,6,10,15,30\\}$，按整除关系排序。在 $D_{30}$ 中，对于任意 $a,b$，并是 $\\operatorname{lcm}(a,b)$，交是 $\\operatorname{gcd}(a,b)$。一个子集 $S$ 在诱导序下是一个格，如果 $S$ 中的每对元素在 $S$ 内部都有唯一的最小上界和最大下界。如果此外，对于每个 $a,b\\in S$，在 $D_{30}$ 中计算出的元素 $\\operatorname{lcm}(a,b)$ 和 $\\operatorname{gcd}(a,b)$ 都位于 $S$ 中，那么它就是 $D_{30}$ 的一个子格。\n\n检查每个选项：\n\nA. $S_{A}=\\{1,2,3,5,30\\}$。交运算：对于 $a\\in\\{2,3,5,30\\}$，$\\gcd(1,a)=1\\in S_{A}$；在 $\\{2,3,5\\}$ 中，$\\gcd(2,3)=\\gcd(2,5)=\\gcd(3,5)=1\\in S_{A}$；并且 $\\gcd(30,2)=2$，$\\gcd(30,3)=3$，$\\gcd(30,5)=5$，都在 $S_{A}$ 中。$S_{A}$ 内部的并运算：对于 $a\\in\\{2,3,5\\}$，$\\operatorname{lcm}(1,a)=a\\in S_{A}$；对于来自 $\\{2,3,5\\}$ 的任意两个不同元素，它们在 $D_{30}$ 中的 $\\operatorname{lcm}$ 是 $6$、$10$ 或 $15$，这些都不在 $S_{A}$ 中，但 $S_{A}$ 中唯一的公共上界是 $30$，因此 $S_{A}$ 中的并存在且等于 $30$；并且 $\\operatorname{lcm}(a,30)=30\\in S_{A}$。因此 $S_{A}$ 是一个格。它不是一个子格，因为例如 $\\operatorname{lcm}(2,3)=6\\notin S_{A}$，所以在 $D_{30}$ 中的并不在 $S_{A}$ 中，并且不同于 $S_{A}$ 中的并（为 $30$）。\n\nB. $S_{B}=\\{1,2,3,6,10\\}$。考虑 $3$ 和 $10$。在 $D_{30}$ 中，$\\operatorname{lcm}(3,10)=30$，但 $30\\notin S_{B}$。$S_{B}$ 中没有元素同时是 $3$ 和 $10$ 的倍数，所以元素对 $\\{3,10\\}$ 在 $S_{B}$ 中没有上界。因此 $S_{B}$ 不是一个格。\n\nC. $S_{C}=\\{1,2,3,5,6,10,15\\}$。考虑 $6$ 和 $10$。在 $D_{30}$ 中，$\\operatorname{lcm}(6,10)=30$，但 $30\\notin S_{C}$。$S_{C}$ 中没有元素同时是 $6$ 和 $10$ 的倍数，所以元素对 $\\{6,10\\}$ 在 $S_{C}$ 中没有上界。因此 $S_{C}$ 不是一个格。\n\nD. $S_{D}=\\{1,2,3,6\\}$。计算所有的并和交：$\\operatorname{lcm}(2,3)=6$, $\\gcd(2,3)=1$；$\\operatorname{lcm}(2,6)=6$, $\\gcd(2,6)=2$；$\\operatorname{lcm}(3,6)=6$, $\\gcd(3,6)=3$；与 $1$ 运算，对于 $a\\in\\{2,3,6\\}$，有 $\\operatorname{lcm}(1,a)=a$ 和 $\\gcd(1,a)=1$。所有这些结果都在 $S_{D}$ 中，所以 $S_{D}$ 是一个格，并且对于来自 $D_{30}$ 的 $\\operatorname{lcm}$ 和 $\\gcd$ 运算是封闭的。因此 $S_{D}$ 是一个子格。\n\nE. $S_{E}=\\{1,5,10,15,30\\}$。检查关键元素对：$\\operatorname{lcm}(10,15)=30$, $\\gcd(10,15)=5$，都在 $S_{E}$ 中；与 $5$ 运算，我们有 $\\operatorname{lcm}(5,10)=10$, $\\gcd(5,10)=5$ 和 $\\operatorname{lcm}(5,15)=15$, $\\gcd(5,15)=5$；与 $30$ 运算，对于 $a\\in\\{5,10,15\\}$，有 $\\operatorname{lcm}(a,30)=30$ 和 $\\gcd(a,30)=a$；与 $1$ 运算，$\\operatorname{lcm}(1,a)=a$ 和 $\\gcd(1,a)=1$。所有的并和交都在 $S_{E}$ 中，所以 $S_{E}$ 是一个格，也是一个子格。\n\n因此，唯一一个既是格但又不是子格的子集是 $S_{A}$。", "answer": "$$\\boxed{A}$$", "id": "1380544"}]}