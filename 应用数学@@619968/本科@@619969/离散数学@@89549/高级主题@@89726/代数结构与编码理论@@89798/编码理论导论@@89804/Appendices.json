{"hands_on_practices": [{"introduction": "在我们能够纠正错误之前，我们必须首先能够精确地描述它们。这个练习介绍了错误向量 $e$ 的基本概念，它使用按位异或（XOR）运算 $\\oplus$ 来记录在传输过程中哪些比特被翻转。掌握这个简单的模型 $r = c \\oplus e$ 是理解更复杂的错误检测和纠正码工作原理的第一步。[@problem_id:1377089]", "problem": "在数字通信系统中，错误检测是一项基本任务。考虑一个从火星探测器发送到地球的信号的简化模型。数据被编码成称为码字 (codeword) 的二进制字符串。一个码字 $c$ 被发送，但由于大气干扰和长距离传输造成的信号衰减，一些比特位可能会被翻转。到达地球的二进制字符串被称为接收字 (received word)，$r$。\n\n错误由一个错误向量 (error vector) $e$ 表示，它是一个与码字等长的二进制字符串。$e$ 中第 $i$ 位上的“1”表示码字的第 $i$ 位在传输过程中被翻转了，而“0”则表示没有。发送的码字 $c$、接收的字 $r$ 和错误向量 $e$ 之间的关系由按位异或（XOR，用 $\\oplus$ 表示）运算给出：\n$$r = c \\oplus e$$\n假设探测器发送了12位的码字 $c = 110101100011$。在传输到地球后，任务控制中心接收到的字是 $r = 111101000111$。\n\n以下哪个选项代表了描述传输错误的错误向量 $e$？\n\nA. `001000100100`\n\nB. `110101000011`\n\nC. `111101100111`\n\nD. `001000100110`\n\nE. `000000000000`", "solution": "问题使用按位异或（XOR, $\\oplus$）运算定义了发送码字（$c$）、接收字（$r$）和错误向量（$e$）之间的关系如下：\n$$r = c \\oplus e$$\n我们的目标是求出错误向量 $e$。为了分离出 $e$，我们可以利用异或运算的一个性质：对于任何二进制字符串 $x$，$x \\oplus x$ 会得到一个全零字符串，且 $x \\oplus 0 = x$。\n\n我们可以在给定方程的两边同时与 $c$ 进行异或运算：\n$$r \\oplus c = (c \\oplus e) \\oplus c$$\n根据异或运算的结合律和交换律，我们可以重新排列右边的项：\n$$r \\oplus c = (c \\oplus c) \\oplus e$$\n由于 $c \\oplus c$ 是一个全零字符串，我们称其为 $\\mathbf{0}$：\n$$r \\oplus c = \\mathbf{0} \\oplus e$$\n任何字符串与全零字符串的异或结果是其本身：\n$$r \\oplus c = e$$\n因此，错误向量 $e$ 可以通过对接收字 $r$ 和发送码字 $c$ 执行按位异或运算来找到。\n\n给定的值为：\n$c = 110101100011$\n$r = 111101000111$\n\n现在，我们逐位计算 $e = r \\oplus c$。如果两个比特位不同，异或运算结果为1；如果相同，则结果为0。\n\n```\n  r:  1 1 1 1 0 1 0 0 0 1 1 1\n  c:  1 1 0 1 0 1 1 0 0 0 1 1\n---------------------------------\ne=r⊕c:  0 0 1 0 0 0 1 0 0 1 0 0\n```\n\n让我们对每个位置进行显式计算：\n- 第1位：$1 \\oplus 1 = 0$\n- 第2位：$1 \\oplus 1 = 0$\n- 第3位：$1 \\oplus 0 = 1$\n- 第4位：$1 \\oplus 1 = 0$\n- 第5位：$0 \\oplus 0 = 0$\n- 第6位：$1 \\oplus 1 = 0$\n- 第7位：$0 \\oplus 1 = 1$\n- 第8位：$0 \\oplus 0 = 0$\n- 第9位：$0 \\oplus 0 = 0$\n- 第10位：$1 \\oplus 0 = 1$\n- 第11位：$1 \\oplus 1 = 0$\n- 第12位：$1 \\oplus 1 = 0$\n\n将这些比特组合起来，我们得到错误向量：\n$$e = 001000100100$$\n这个结果表明，在传输过程中，第3、7和10位（从左边开始，从1计数）的比特被翻转了。\n\n将此结果与给定的选项进行比较：\nA. `001000100100`\nB. `110101000011`\nC. `111101100111`\nD. `001000100110`\nE. `000000000000`\n\n计算出的错误向量与选项A匹配。", "answer": "$$\\boxed{A}$$", "id": "1377089"}, {"introduction": "在理解了如何量化单个错误之后，我们需要一种系统性的方法来构建能够处理这些错误的代码。这个实践介绍了两个核心工具：生成矩阵 $G$ 和校验矩阵 $H$。你将学习这些矩阵如何定义一个线性码的结构，以及它们在数学上是如何关联的，这为编码信息和后续的错误校验提供了蓝图。[@problem_id:1377138]", "problem": "在数字通信和数据存储中，二元线性码被用来保护信息免受错误影响。一个码可以由一个校验矩阵 $H$ 来定义。任何有效的码字 $\\mathbf{c}$ 都必须满足方程 $H\\mathbf{c}^T = \\mathbf{0}$，其中算术运算在模2下进行。一个生成矩阵 $G$ 提供了一种从一组信息字生成所有有效码字的方法。一个有效的生成矩阵的行向量必须构成所有有效码字集合的一个基。\n\n考虑一个由以下校验矩阵定义的二元线性码：\n$$H = \\begin{pmatrix} 1 & 1 & 0 & 1 \\end{pmatrix}$$\n\n下列哪个矩阵是该码的一个有效生成矩阵 $G$？\n\nA. $G = \\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}$\n\nB. $G = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}$\n\nC. $G = \\begin{pmatrix} 1 & 1 & 0 & 1 \\end{pmatrix}$\n\nD. $G = \\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 1 & 0 & 1 \\\\ 1 & 1 & 0 & 0 \\end{pmatrix}$\n\nE. $G = \\begin{pmatrix} 1 & 0 & 1 \\\\ 0 & 1 & 1 \\\\ 0 & 0 & 1 \\end{pmatrix}$", "solution": "一个校验矩阵为 $H$ 的二元线性码，其码字 $\\mathbf{c}$ 满足在模2算术下的方程 $H\\mathbf{c}^{T}=\\mathbf{0}$。一个有效的生成矩阵 $G$ 必须满足：\n- 具有正确的维度 $k \\times n$，其中 $n$ 等于码长（$H$ 的列数），且 $k=n-\\operatorname{rank}(H)$，\n- 其行向量构成 $H$ 的零空间的一个基，等价于 $HG^{T}=\\mathbf{0}$ 且 $\\operatorname{rank}(G)=k$。\n\n此处 $H=\\begin{pmatrix}1 & 1 & 0 & 1\\end{pmatrix}$ 是一个非零的 $1\\times 4$ 矩阵，所以 $\\operatorname{rank}(H)=1$，$n=4$，且码的维数是\n$$\nk=n-\\operatorname{rank}(H)=4-1=3.\n$$\n因此，任何有效的 $G$ 都必须是 $3\\times 4$ 矩阵，满足模2下的 $HG^{T}=\\mathbf{0}$，并且秩为 $3$。\n\n求解 $H\\mathbf{c}^{T}=\\mathbf{0}$：\n$$\nc_{1}+c_{2}+c_{4}=0 \\quad(\\text{mod } 2),\n$$\n所以我们可以自由选择 $c_{1},c_{2},c_{3}$，并令 $c_{4}=c_{1}+c_{2}$。零空间的一个基由以下向量给出，这些向量是通过将每个自由变量设为 $1$ 而其他自由变量设为 $0$ 得到的：\n$$\n(1,0,0,1), \\quad (0,1,0,1), \\quad (0,0,1,0).\n$$\n因此，一个有效的生成矩阵是\n$$\nG=\\begin{pmatrix}\n1 & 0 & 0 & 1\\\\\n0 & 1 & 0 & 1\\\\\n0 & 0 & 1 & 0\n\\end{pmatrix},\n$$\n这与选项A相符。明确地检验 $HG^{T}=\\mathbf{0}$：\n$$\nH\\begin{pmatrix}1\\\\0\\\\0\\\\1\\end{pmatrix}=1+0+0+1=0,\\quad\nH\\begin{pmatrix}0\\\\1\\\\0\\\\1\\end{pmatrix}=0+1+0+1=0,\\quad\nH\\begin{pmatrix}0\\\\0\\\\1\\\\0\\end{pmatrix}=0+0+0+0=0,\n$$\n结果都在模2下成立，并且这三个行向量是线性无关的，因此 $\\operatorname{rank}(G)=3$。\n\n现在排除其他选项：\n- B: $G$ 是 $3\\times 4$ 矩阵，但 $H\\begin{pmatrix}1\\\\0\\\\0\\\\0\\end{pmatrix}=1\\neq 0$，所以 $HG^{T}\\neq \\mathbf{0}$。\n- C: $G$ 是 $1\\times 4$ 矩阵（维数错误；$k$ 应为 $3$），并且 $H\\begin{pmatrix}1\\\\1\\\\0\\\\1\\end{pmatrix}=1\\neq 0$。\n- D: 行向量满足 $HG^{T}=\\mathbf{0}$，但第三行等于前两行之和，所以 $\\operatorname{rank}(G)=2\\neq 3$。\n- E: $G$ 是 $3\\times 3$ 矩阵（长度错误；码字长度必须为4）。\n\n因此，只有选项A是该码的有效生成矩阵。", "answer": "$$\\boxed{A}$$", "id": "1377138"}, {"introduction": "现在我们知道了如何使用校验矩阵 $H$ 来定义一个代码，我们可以探索其真正的威力：纠正错误。这个练习将引导你完成优雅的伴随式译码过程。你将通过计算接收到的字 $r$ 的“校验子” $s = Hr^T$，它就如一个独特的“指纹”，能直接指出单个比特错误的位置，从而使你能够完美地恢复原始信息。[@problem_id:1377111]", "problem": "在一个深空通信系统中，使用一种线性分组码将4比特的消息作为7比特的码字进行传输，以防止错误。在此背景下，所有的算术运算都是在模2下进行的。该码由其校验矩阵 $H$ 定义：\n$$ H = \\begin{pmatrix} 0 & 1 & 1 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 1 & 0 \\\\ 1 & 1 & 0 & 1 & 0 & 0 & 1 \\end{pmatrix} $$\n一个7比特字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ 是一个有效码字，当且仅当其转置 $c^T$ 满足方程 $Hc^T = \\boldsymbol{0}$，其中 $\\boldsymbol{0}$ 是零向量。该码是系统码，意味着任何码字的形式均为 $(m_1, m_2, m_3, m_4, p_1, p_2, p_3)$，其中 $(m_1, m_2, m_3, m_4)$ 是原始的4比特消息，而 $(p_1, p_2, p_3)$ 是校验位。\n\n一个地面站接收到7比特字 $r = (1, 0, 1, 0, 0, 0, 1)$。根据系统的设计规范，已知在单次传输中最多只有一个比特会发生翻转。你的任务是确定所发送的原始4比特消息 $(m_1, m_2, m_3, m_4)$。请将你的答案以包含这四个消息比特的单行矩阵形式呈现。", "solution": "我们在具有两个元素的有限域上进行运算，因此所有的加法和乘法都是模2的。设接收到的向量为 $r=(1,0,1,0,0,0,1)$。校验子 $s$ 定义为\n$$\ns = Hr^{T} \\pmod{2}.\n$$\n显式地计算 $s$：\n$$\ns = \\begin{pmatrix}\n0 & 1 & 1 & 1 & 1 & 0 & 0 \\\\\n1 & 0 & 1 & 1 & 0 & 1 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0\\cdot 1+1\\cdot 0+1\\cdot 1+1\\cdot 0+1\\cdot 0+0\\cdot 0+0\\cdot 1 \\\\\n1\\cdot 1+0\\cdot 0+1\\cdot 1+1\\cdot 0+0\\cdot 0+1\\cdot 0+0\\cdot 1 \\\\\n1\\cdot 1+1\\cdot 0+0\\cdot 1+1\\cdot 0+0\\cdot 0+0\\cdot 0+1\\cdot 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix}\n\\pmod{2}.\n$$\n假设最多有一个比特错误，写出 $r=c+e$，其中 $c$ 是一个有效码字，$e$ 是一个汉明权重最多为1的错误向量。那么\n$$\ns=Hr^{T}=H(c+e)^{T}=Hc^{T}+He^{T}= \\boldsymbol{0}+He^{T}=He^{T}.\n$$\n如果单个错误在位置 $i$ 上，那么 $e=e_{i}$ 并且 $He^{T}$ 等于 $H$ 的第 $i$ 列 $h_{i}$。因此，校验子 $s$ 必须等于 $H$ 的某一列。$H$ 的各列是\n$$\nh_{1}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}1\\\\1\\\\1\\end{pmatrix},\\quad\nh_{5}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\quad\nh_{6}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\quad\nh_{7}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}.\n$$\n因为 $s=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}=h_{5}$，所以错误在第5个位置。进行纠错得到\n$$\nc=r+e_{5}=(1,0,1,0,0,0,1)+(0,0,0,0,1,0,0)=(1,0,1,0,1,0,1)\\pmod{2}.\n$$\n因为该码是系统码，所以原始消息是 $c$ 的前四个比特，即 $(1,0,1,0)$。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1 & 0\\end{pmatrix}}$$", "id": "1377111"}]}