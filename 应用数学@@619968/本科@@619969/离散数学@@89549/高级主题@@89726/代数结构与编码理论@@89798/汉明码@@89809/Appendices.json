{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。让我们从汉明码最基本也是最核心的操作开始：编码。这个练习将带你亲手将一个4位的数据信息转换成一个7位的汉明码字，通过计算校验位，你将直观地理解冗余是如何被巧妙地添加到数据中以构建其纠错能力的。[@problem_id:1373675]", "problem": "在为远程环境监测站设计一个容错通信系统时，一位工程师采用标准的 $(7,4)$ 汉明码将4位数据消息编码为7位码字。这个过程增加了冗余，以便能够检测和纠正无线传输过程中可能出现的单位比特错误。\n\n编码方案定义如下：\n一个表示为 $(d_1, d_2, d_3, d_4)$ 的4位消息被嵌入到一个表示为 $(c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ 的7位码字中。位从左到右编号为1到7。\n- 数据位 $(d_1, d_2, d_3, d_4)$ 分别放置在码字的位置 $(3, 5, 6, 7)$ 上。因此，$c_3=d_1$，$c_5=d_2$，$c_6=d_3$，$c_7=d_4$。\n- 剩余的位置是2的幂 $(1, 2, 4)$，用校验位 $(p_1, p_2, p_3)$ 填充。因此，$c_1=p_1$，$c_2=p_2$，$c_4=p_3$。\n- 每个校验位被计算以在特定的码字位置集合上强制执行偶校验规则。校验检查使用异或 (XOR，用 $\\oplus$ 表示) 运算，其中被检查的位 (包括校验位本身) 的异或和结果必须为0。\n  - $p_1$ 管理位置 1, 3, 5, 7。( $c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$ )\n  - $p_2$ 管理位置 2, 3, 6, 7。( $c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$ )\n  - $p_3$ 管理位置 4, 5, 6, 7。( $c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$ )\n\n一个传感器传输了4位消息 `1011`。生成的相应7位汉明码字是什么？\n\nA. 0110011\n\nB. 1011011\n\nC. 1010101\n\nD. 0010011\n\nE. 1110011", "solution": "设消息为 $(d_{1},d_{2},d_{3},d_{4})=(1,0,1,1)$。将数据位放入码字位置：$c_{3}=d_{1}=1$，$c_{5}=d_{2}=0$，$c_{6}=d_{3}=1$，$c_{7}=d_{4}=1$。设校验位为 $c_{1}=p_{1}$，$c_{2}=p_{2}$，$c_{4}=p_{3}$ 并强制执行偶校验。\n\n对于位置 $1,3,5,7$ 上的 $p_{1}$：\n$$c_{1}\\oplus c_{3}\\oplus c_{5}\\oplus c_{7}=0 \\implies c_{1}\\oplus 1\\oplus 0\\oplus 1=0 \\implies c_{1}\\oplus 0=0 \\implies c_{1}=0.$$\n\n对于位置 $2,3,6,7$ 上的 $p_{2}$：\n$$c_{2}\\oplus c_{3}\\oplus c_{6}\\oplus c_{7}=0 \\implies c_{2}\\oplus 1\\oplus 1\\oplus 1=0 \\implies c_{2}\\oplus 1=0 \\implies c_{2}=1.$$\n\n对于位置 $4,5,6,7$ 上的 $p_{3}$：\n$$c_{4}\\oplus c_{5}\\oplus c_{6}\\oplus c_{7}=0 \\implies c_{4}\\oplus 0\\oplus 1\\oplus 1=0 \\implies c_{4}\\oplus 0=0 \\implies c_{4}=0.$$\n\n因此，码字为 $(c_{1},c_{2},c_{3},c_{4},c_{5},c_{6},c_{7})=(0,1,1,0,0,1,1)$，即 $0110011$，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1373675"}, {"introduction": "编码只是故事的一半，汉明码的真正威力在于其解码和纠错能力。这个练习将向你介绍“伴随式”这一关键概念，它就像是错误的“指纹”。你将学会如何计算伴随式，并利用它来定位并纠正接收到的码字中的单个比特错误，亲眼见证汉明码化腐朽为神奇的过程。[@problem_id:1373652]", "problem": "在一个监测环境数据的数字通信系统中，消息使用系统的(7,4)汉明码进行编码，以防止在通过噪声信道传输过程中可能发生的单比特错误。一个记为 $m = (d_1, d_2, d_3, d_4)$ 的4比特数据消息被编码成一个7比特码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$。\n\n码字的结构如下：\n- 数据位放置在不是2的幂次的位置上：$c_3 = d_1$，$c_5 = d_2$，$c_6 = d_3$ 和 $c_7 = d_4$。\n- 校验位 $p_1, p_2, p_3$ 放置在2的幂次的位置上：$c_1 = p_1$，$c_2 = p_2$ 和 $c_4 = p_3$。\n\n一个码字是有效的，当且仅当它满足条件 $Hc^T = \\mathbf{0}$，其中 $\\mathbf{0}$ 是 $3 \\times 1$ 的零向量，且所有算术运算都在模2下进行。该特定码的校验矩阵 $H$ 由下式给出：\n$$ H = \\begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix} $$\n从传感器接收到一个7比特字 $r = (0, 0, 0, 1, 0, 0, 1)$。假设在传输过程中最多只有一个比特发生了翻转，请确定被发送的原始4比特数据消息 $m = (d_1, d_2, d_3, d_4)$。\n\n从以下选项中选择正确的消息：\nA. 0001\nB. 0101\nC. 1001\nD. 0011\nE. 1100", "solution": "我们使用单比特纠错汉明码的伴随式译码规则：对于一个接收字 $r=(r_{1},\\dots,r_{7})$，其伴随式是在 $\\mathbb{F}_{2}$ 上计算的 $s=Hr^{T}$。如果在位置 $j$ 上恰好有一个比特错误，那么 $s$ 就等于 $H$ 的第 $j$ 列。\n\n已知\n$$\nH=\\begin{pmatrix}\n0 & 0 & 0 & 1 & 1 & 1 & 1\\\\\n0 & 1 & 1 & 0 & 0 & 1 & 1\\\\\n1 & 0 & 1 & 0 & 1 & 0 & 1\n\\end{pmatrix},\\qquad\nr=(0,0,0,1,0,0,1),\n$$\n通过逐行点积计算 $s=Hr^{T}$ 模 $2$：\n$$\ns_{1}=(0\\cdot 0)+(0\\cdot 0)+(0\\cdot 0)+(1\\cdot 1)+(1\\cdot 0)+(1\\cdot 0)+(1\\cdot 1)\\equiv 1+0+0+1\\equiv 0 \\pmod{2},\n$$\n$$\ns_{2}=(0\\cdot 0)+(1\\cdot 0)+(1\\cdot 0)+(0\\cdot 1)+(0\\cdot 0)+(1\\cdot 0)+(1\\cdot 1)\\equiv 1 \\pmod{2},\n$$\n$$\ns_{3}=(1\\cdot 0)+(0\\cdot 0)+(1\\cdot 0)+(0\\cdot 1)+(1\\cdot 0)+(0\\cdot 0)+(1\\cdot 1)\\equiv 1 \\pmod{2}.\n$$\n因此 $s=(0,1,1)^{T}$。$H$ 的各列为\n$$\nH_{\\cdot,1}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix},\\;\nH_{\\cdot,2}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\;\nH_{\\cdot,3}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\;\nH_{\\cdot,4}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\;\nH_{\\cdot,5}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\;\nH_{\\cdot,6}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\;\nH_{\\cdot,7}=\\begin{pmatrix}1\\\\1\\\\1\\end{pmatrix}.\n$$\n因为 $s=H_{\\cdot,3}$，所以单比特错误发生在位置 $3$。通过翻转 $r_{3}$ 来纠正 $r$，得到码字\n$$\n\\hat{c}=r+e_{3}=(0,0,1,1,0,0,1),\n$$\n其中 $e_{3}$ 是在位置3上为1的单位向量。使用 $c_{3}=d_{1}$，$c_{5}=d_{2}$，$c_{6}=d_{3}$，$c_{7}=d_{4}$ 提取数据位：\n$$\n(d_{1},d_{2},d_{3},d_{4})=(c_{3},c_{5},c_{6},c_{7})=(1,0,0,1).\n$$\n选项C对应于 $1001$。快速检查可确认其有效性：在 $\\mathbb{F}_{2}$ 上 $H\\hat{c}^{T}=\\mathbf{0}$。", "answer": "$$\\boxed{C}$$", "id": "1373652"}, {"introduction": "任何差错控制码都有其能力边界，理解这些限制与了解其功能同样重要。这个练习是一个重要的思想实验，它揭示了当(7,4)汉明码遇到其设计之外的情况（即超过一个比特的错误）时会发生什么。通过这个例子，你会发现解码机制可能会被误导，从而做出错误的纠正，这有助于我们更深刻地理解汉明码的设计假设和适用范围。[@problem_id:1373639]", "problem": "一个通信系统使用一个系统的(7,4)汉明码来传输4比特的数据字。一个7比特的码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ 由一个4比特的数据字构造而成，该数据字的比特被放置在码字的位置 3, 5, 6 和 7。三个校验比特经过计算后被放置在位置 1, 2 和 4。因此，码字的比特排列为 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$，其中 $c_1, c_2, c_4$ 是校验比特。校验比特使用以下偶校验方程计算，其中 $\\oplus$ 表示异或（XOR）运算：\n$c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$\n$c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$\n$c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$\n\n当接收到一个7比特的字 $y = (y_1, y_2, y_3, y_4, y_5, y_6, y_7)$ 时，接收端按如下方式计算一个3比特的伴随式 $s = (s_1, s_2, s_3)$：\n$s_1 = y_4 \\oplus y_5 \\oplus y_6 \\oplus y_7$\n$s_2 = y_2 \\oplus y_3 \\oplus y_6 \\oplus y_7$\n$s_3 = y_1 \\oplus y_3 \\oplus y_5 \\oplus y_7$\n\n该解码系统被设计为最多能纠正一个比特的错误。如果伴随式 $s$ 为 $(0,0,0)$，则该字被接受为正确的。如果 $s$ 非零，它被解释为单个错误比特位置的二进制表示，其中 $s_1$ 是最高有效位。例如，伴随式 $(1,0,1)$ 表示第5个比特位置存在错误。解码器随后会翻转指示位置的比特以尝试进行纠正。\n\n假设位置为 $(3, 5, 6, 7)$ 的比特由 $(1, 0, 1, 1)$ 给出的4比特数据字被编码为其对应的码字 $c$。在传输过程中，码字被损坏，导致位置3和6的比特被翻转。接收端的单比特纠错解码器将识别出哪个比特位置是错误的？", "solution": "该码是一个系统汉明码，数据比特位于位置 $3,5,6,7$，校验比特位于位置 $1,2,4$。偶校验方程为\n$$c_{1} \\oplus c_{3} \\oplus c_{5} \\oplus c_{7} = 0,$$\n$$c_{2} \\oplus c_{3} \\oplus c_{6} \\oplus c_{7} = 0,$$\n$$c_{4} \\oplus c_{5} \\oplus c_{6} \\oplus c_{7} = 0.$$\n当数据比特为 $(c_{3},c_{5},c_{6},c_{7})=(1,0,1,1)$ 时，求解校验比特：\n$$c_{1} = c_{3} \\oplus c_{5} \\oplus c_{7} = 1 \\oplus 0 \\oplus 1 = 0,$$\n$$c_{2} = c_{3} \\oplus c_{6} \\oplus c_{7} = 1 \\oplus 1 \\oplus 1 = 1,$$\n$$c_{4} = c_{5} \\oplus c_{6} \\oplus c_{7} = 0 \\oplus 1 \\oplus 1 = 0.$$\n因此，传输的码字是\n$$(c_{1},c_{2},c_{3},c_{4},c_{5},c_{6},c_{7})=(0,1,1,0,0,1,1)。$$\n在传输过程中，位置 $3$ 和 $6$ 的比特被翻转，得到接收到的字\n$$(y_{1},y_{2},y_{3},y_{4},y_{5},y_{6},y_{7})=(0,1,0,0,0,0,1)。$$\n伴随式计算如下：\n$$s_{1}=y_{4} \\oplus y_{5} \\oplus y_{6} \\oplus y_{7}=0 \\oplus 0 \\oplus 0 \\oplus 1=1,$$\n$$s_{2}=y_{2} \\oplus y_{3} \\oplus y_{6} \\oplus y_{7}=1 \\oplus 0 \\oplus 0 \\oplus 1=0,$$\n$$s_{3}=y_{1} \\oplus y_{3} \\oplus y_{5} \\oplus y_{7}=0 \\oplus 0 \\oplus 0 \\oplus 1=1.$$\n因此 $s=(s_{1},s_{2},s_{3})=(1,0,1)$，其中 $s_{1}$ 为最高有效位，这是位置5的二进制表示。因此，单比特纠错解码器识别出第5个比特位置存在错误。", "answer": "$$\\boxed{5}$$", "id": "1373639"}]}