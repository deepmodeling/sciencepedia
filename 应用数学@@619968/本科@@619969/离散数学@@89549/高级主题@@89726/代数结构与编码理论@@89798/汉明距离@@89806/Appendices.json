{"hands_on_practices": [{"introduction": "在深入探讨汉明距离的复杂应用之前，我们首先需要掌握其最基本的计算方法。这个练习将引导你直接应用汉明距离的定义，通过比较两个二进制字符串来量化它们之间的差异。这是理解和使用汉明距离解决更复杂问题不可或缺的第一步 [@problem_id:1941052]。", "problem": "在数字通信系统中，汉明距离是用于比较两个等长二进制字符串的度量标准。它被定义为两个字符串中对应比特位不相同的数量。考虑通过信道传输的两个8位二进制字，字A和字B。\n\n字A由二进制字符串 `01000001` 表示。\n字B由二进制字符串 `01111010` 表示。\n\n计算字A和字B之间的汉明距离。", "solution": "两个等长二进制字符串之间的汉明距离定义为对应比特位不相同的数量。对于长度为 $n$ 的字符串 $x$ 和 $y$，这可以写成\n$$\nd_{H}(x,y)=\\sum_{i=1}^{n} \\mathbf{1}\\{x_{i}\\neq y_{i}\\}=\\text{wt}(x\\oplus y),\n$$\n其中 $\\oplus$ 表示按位异或，$\\text{wt}(\\cdot)$ 是汉明权重（1的数量）。\n\n给定 $A=\\text{`01000001`}$ 和 $B=\\text{`01111010`}$，计算其异或值：\n- 按位计算：$0\\oplus 0=0$, $1\\oplus 1=0$, $0\\oplus 1=1$, $0\\oplus 1=1$, $0\\oplus 1=1$, $0\\oplus 0=0$, $0\\oplus 1=1$, $1\\oplus 0=1$。\n- 因此，\n$$\nA \\oplus B = \\text{`00111011`}\n$$\n计算 `00111011` 中1的数量：共有 $5$ 个1。因此，\n$$\nd_{H}(A,B)=5\n$$", "answer": "$$\\boxed{5}$$", "id": "1941052"}, {"introduction": "掌握了基本计算后，让我们来探索一个更具结构性的挑战：如何根据给定的距离约束来构造一个二进制字符串。这个练习巧妙地利用了全零和全一字符串的特殊性质，将抽象的汉明距离问题转化为关于汉明重量（即字符串中'1'的个数）的直观计数问题。通过解决此问题，你将深化对汉明距离与字符串内在属性之间关系的理解 [@problem_id:1373971]。", "problem": "在数字通信和编码理论中，汉明距离是检错与纠错的一个基本概念。二进制字符串是一个字符序列，其中每个字符是 0 或 1。两个等长二进制字符串之间的汉明距离定义为它们在相应位置上字符不同的数量。\n\n考虑两个参考二进制字符串，`u = '11111'` 和 `v = '00000'`。你的任务是找出一个长度为 5 的二进制字符串 $s$，它同时满足以下两个条件：\n1. $s$ 和 `u` 之间的汉明距离恰好为 2。\n2. $s$ 和 `v` 之间的汉明距离恰好为 3。\n\n下列哪个二进制字符串是 $s$ 的有效选择？\n\nA. `10110`\n\nB. `00110`\n\nC. `11110`\n\nD. `01010`", "solution": "设 $u=\\text{`11111`}$，$v=\\text{`00000`}$，并设 $s=s_{1}s_{2}s_{3}s_{4}s_{5}$ 是一个长度为 $5$ 的二进制字符串。两个等长二进制字符串 $x$ 和 $y$ 之间的汉明距离为 $d_{H}(x,y)=|\\{i:x_{i}\\neq y_{i}\\}|$。\n\n由于对所有 $i$ 都有 $u_{i}=1$，$d_{H}(s,u)$ 等于 $s_{i}=0$ 的位置数量，即 $s$ 中 0 的数量。由于对所有 $i$ 都有 $v_{i}=0$，$d_{H}(s,v)$ 等于 $s_{i}=1$ 的位置数量，即 $s$ 中 1 的数量。\n\n给定的条件是：\n$$d_{H}(s,u)=2 \\implies \\text{s 中 0 的数量}=2,$$\n$$d_{H}(s,v)=3 \\implies \\text{s 中 1 的数量}=3.$$\n这两个条件是一致的，因为字符串的长度为 $5$ 且 $2+3=5$。因此，一个有效的 $s$ 必须恰好包含三个 $1$ 和两个 $0$。\n\n通过计算 1 和 0 的数量来检查每个选项：\n- A: `10110` 有三个 $1$ 和两个 $0$，因此 $d_{H}(A,u)=2$ 和 $d_{H}(A,v)=3$。\n- B: `00110` 有两个 $1$ 和三个 $0$，因此 $d_{H}(B,u)=3$ 和 $d_{H}(B,v)=2$（不满足条件）。\n- C: `11110` 有四个 $1$ 和一个 $0$，因此 $d_{H}(C,u)=1$ 和 $d_{H}(C,v)=4$（不满足条件）。\n- D: `01010` 有两个 $1$ 和三个 $0$，因此 $d_{H}(D,u)=3$ 和 $d_{H}(D,v)=2$（不满足条件）。\n\n因此，只有选项 A 同时满足两个条件。", "answer": "$$\\boxed{A}$$", "id": "1373971"}, {"introduction": "汉明距离的核心价值在于其在错误检测和纠正中的强大应用。本练习模拟了一个经典的通信场景：从多个在传输过程中可能已损坏的信号中，重建最有可能的原始数据。你将学习如何通过寻找一个“共识”字符串来最小化与所有接收信号的总汉明距离，这是一种在现实世界中广泛应用的、既直观又有效的数据恢复策略 [@problem_id:1373967]。", "problem": "在数字通信和信息论中，汉明距离是用于比较两个等长二进制字符串的一种度量。它被定义为相应符号（比特）在不同位置上的数量。\n\n考虑一个简单的纠错场景：一个5比特的数据包通过三个冗余信道传输。由于传输过程中可能存在噪声，目的地接收到的三个数据包并不完全相同。接收到的数据包如下：\n$S_1 = \\text{`10100`}$\n$S_2 = \\text{`01100`}$\n$S_3 = \\text{`11110`}$\n\n为了重构最有可能的原始数据包，一个常见的策略是找到一个“共识”字符串。这是一个5比特的二进制字符串，我们称之为$C$，它能使与三个接收到的字符串的汉明距离之和最小化。也就是说，我们寻求找到字符串$C$，以最小化量 $d_H(C, S_1) + d_H(C, S_2) + d_H(C, S_3)$。\n\n请找到这个5比特的二进制共识字符串$C$。", "solution": "两个长度为5的二进制字符串$x$和$y$之间的汉明距离定义为$d_{H}(x,y)$，即它们在不同位置上的数量。我们寻求最小化的和可以按位置分解：\n$$\n\\sum_{i=1}^{3} d_{H}(C,S_{i})=\\sum_{j=1}^{5}\\sum_{i=1}^{3}\\mathbf{1}\\{C_{j}\\neq (S_{i})_{j}\\}.\n$$\n由于和是按位置$j$可分的，因此在每个位置上$C_{j}$的最优选择是最小化与该位置上接收到的三个比特的差异数量。因此，对于每个坐标$j$，$C_{j}$应该等于$\\{(S_{1})_{j},(S_{2})_{j},(S_{3})_{j}\\}$中的多数比特。\n\n我们对每个位置进行评估：\n- 位置 1：比特为$\\{1,0,1\\}$，多数为$1$，所以$C_{1}=1$。\n- 位置 2：比特为$\\{0,1,1\\}$，多数为$1$，所以$C_{2}=1$。\n- 位置 3：比特为$\\{1,1,1\\}$，多数为$1$，所以$C_{3}=1$。\n- 位置 4：比特为$\\{0,0,1\\}$，多数为$0$，所以$C_{4}=0$。\n- 位置 5：比特为$\\{0,0,0\\}$，多数为$0$，所以$C_{5}=0$。\n\n因此，共识字符串是$C = \\text{`11100`}$。最小总汉明距离等于每个位置上少数比特的数量之和，这里是$1+1+0+1+0=3$，这证实了最优性。", "answer": "$$\\boxed{11100}$$", "id": "1373967"}]}