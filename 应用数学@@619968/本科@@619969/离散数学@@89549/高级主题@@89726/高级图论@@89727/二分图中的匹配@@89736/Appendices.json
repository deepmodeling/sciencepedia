{"hands_on_practices": [{"introduction": "理论是实践的指南。在尝试寻找一个完美的任务分配方案之前，一个至关重要的问题是：这样的方案真的存在吗？这个练习将带你应用著名的霍尔婚配定理 (Hall's Marriage Theorem) 来回答这个问题。通过分析一个直观的宿舍分配场景，你将学会如何通过寻找一个“瓶颈”子集来证明完美匹配的不可能性，从而深入理解该定理的精髓。[@problem_id:1382813]", "problem": "一所大学的住宿部门正在将 Lavender 组的五名学生分配到 Gold 宿舍的五个单人间。一名学生只能被分配到他们列为可接受的房间。住宿部门希望找到一个“完美匹配”，即每位学生都被分配到一个唯一的可接受房间。\n\nLavender 组的五名学生是 {Amy, Brian, Chloe, David, Emily}。设此集合为 $L$。\nGold 宿舍的五个可用房间是 {G-101, G-102, G-103, G-104, G-105}。\n\n每位学生可接受的房间列表如下：\n- **Amy:** {G-103, G-104}\n- **Brian:** {G-101, G-102}\n- **Chloe:** {G-104, G-105}\n- **David:** {G-101}\n- **Emily:** {G-102}\n\n学生与房间的完美匹配是不可能的。根据 Hall 婚姻定理，这种不可能性可以通过找到一个学生子集 $S \\subseteq L$ 来证明，其中该子集学生共同可接受的房间总数小于该子集中的学生人数。如果我们令 $N(S)$ 为 $S$ 中至少一名学生可接受的所有房间的集合，则该条件写为 $|N(S)| < |S|$。\n\n下列哪个来自 Lavender 组的学生子集 $S$ 满足条件 $|N(S)| < |S|$？\n\nA. $S = \\{\\text{Amy, Chloe}\\}$\n\nB. $S = \\{\\text{Brian, David, Emily}\\}$\n\nC. $S = \\{\\text{Amy, Brian, Chloe}\\}$\n\nD. $S = \\{\\text{David, Emily}\\}$\n\nE. $S = \\{\\text{Amy, David}\\}$", "solution": "我们已知学生集合 $L=\\{\\text{Amy, Brian, Chloe, David, Emily}\\}$ 和房间集合 $\\{\\text{G-101, G-102, G-103, G-104, G-105}\\}$。对于每个子集 $S \\subseteq L$，令 $N(S)$ 表示 $S$ 中学生可接受房间的并集。根据 Hall 婚姻定理，如果存在某个子集 $S$ 满足 $|N(S)|<|S|$，则完美匹配是不可能的。我们逐一检查每个选项。\n\n对于选项 A，$S=\\{\\text{Amy, Chloe}\\}$。可接受的房间为：\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-104, G-105}\\}=\\{\\text{G-103, G-104, G-105}\\}.$$\n因此 $|S|=2$ 且 $|N(S)|=3$，所以 $|N(S)|\\not<|S|$。\n\n对于选项 B，$S=\\{\\text{Brian, David, Emily}\\}$。可接受的房间为：\n$$N(S)=\\{\\text{G-101, G-102}\\}\\cup\\{\\text{G-101}\\}\\cup\\{\\text{G-102}\\}=\\{\\text{G-101, G-102}\\}.$$\n因此 $|S|=3$ 且 $|N(S)|=2$，所以 $|N(S)|<|S|$。这满足了 Hall 定理中不存在完美匹配的条件。\n\n对于选项 C，$S=\\{\\text{Amy, Brian, Chloe}\\}$。可接受的房间为：\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-101, G-102}\\}\\cup\\{\\text{G-104, G-105}\\}=\\{\\text{G-101, G-102, G-103, G-104, G-105}\\}.$$\n因此 $|S|=3$ 且 $|N(S)|=5$，所以 $|N(S)|\\not<|S|$。\n\n对于选项 D，$S=\\{\\text{David, Emily}\\}$。可接受的房间为：\n$$N(S)=\\{\\text{G-101}\\}\\cup\\{\\text{G-102}\\}=\\{\\text{G-101, G-102}\\}.$$\n因此 $|S|=2$ 且 $|N(S)|=2$，所以 $|N(S)|\\not<|S|$。\n\n对于选项 E，$S=\\{\\text{Amy, David}\\}$。可接受的房间为：\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-101}\\}=\\{\\text{G-101, G-103, G-104}\\}.$$\n因此 $|S|=2$ 且 $|N(S)|=3$，所以 $|N(S)|\\not<|S|$。\n\n因此，在这些选项中，唯一满足 $|N(S)|<|S|$ 的子集是选项 B。", "answer": "$$\\boxed{B}$$", "id": "1382813"}, {"introduction": "知道了完美匹配存在的条件后，我们的下一个问题是：如何系统地找到一个最大匹配？这个练习将引导你手动模拟一个核心算法——增广路径算法。你将从一个空匹配开始，通过逐步寻找并应用增广路径来逐步扩大匹配的规模，亲身体验算法如何通过“对称差”操作迭代地优化匹配结果。[@problem_id:1520050]", "problem": "考虑一个二分图 $G = (U \\cup V, E)$，其中顶点划分为 $U = \\{u_1, u_2, u_3, u_4\\}$ 和 $V = \\{v_1, v_2, v_3, v_4\\}$。边集 $E$ 由 $\\{(u_1, v_1), (u_1, v_2), (u_1, v_3), (u_2, v_1), (u_3, v_1)\\}$ 给出。\n\n使用增广路径算法来寻找最大匹配，该算法从一个空匹配 $M_0 = \\emptyset$ 开始，并迭代地增加其大小。在每次迭代中，找到一条关于当前匹配的增广路径，并通过取匹配与该路径的对称差来更新匹配。\n\n你需要精确地执行此算法的两次迭代。在每个步骤中选择增广路径的规则如下：\n1.  路径必须具有尽可能少的边数（即，它必须是一条最短增广路径）。\n2.  如果存在多条最短增广路径，你必须选择字典序最小的那一条。路径由其顶点序列表示，例如 $(w_0, w_1, \\dots, w_k)$。路径根据顶点排序 $u_1 < u_2 < u_3 < u_4 < v_1 < v_2 < v_3 < v_4$ 逐个元素进行比较。\n\n从空匹配 $M_0$ 开始，根据规则确定第一条增广路径 $P_1$ 以创建新匹配 $M_1 = M_0 \\oplus P_1$。然后，对于 $M_1$，找到第二条增广路径 $P_2$ 以创建最终匹配 $M_2 = M_1 \\oplus P_2$。\n\n下列哪个边集表示最终匹配 $M_2$？\n\nA. $\\{(u_1, v_1), (u_2, v_1)\\}$\n\nB. $\\{(u_1, v_1)\\}$\n\nC. $\\{(u_1, v_2), (u_2, v_1)\\}$\n\nD. $\\{(u_1, v_3), (u_2, v_1)\\}$\n\nE. $\\{(u_1, v_2), (u_3, v_1)\\}$", "solution": "我们在二分图 $G=(U\\cup V,E)$ 中进行计算，其中 $U=\\{u_{1},u_{2},u_{3},u_{4}\\}$，$V=\\{v_{1},v_{2},v_{3},v_{4}\\}$，且 $E=\\{(u_{1},v_{1}), (u_{1},v_{2}), (u_{1},v_{3}), (u_{2},v_{1}), (u_{3},v_{1})\\}$。相对于一个匹配 $M$ 的增广路径是一条交错路径，它起止于自由顶点，并且其第一条和最后一条边不在 $M$ 中。该算法通过对称差进行更新：如果 $P$ 是一条增广路径，则 $M\\oplus P$ 会翻转路径 $P$ 上所有边的匹配状态。\n\n迭代1从 $M_{0}=\\emptyset$ 开始。此时每条边都未匹配，且其两个端点都是自由的，所以每条单独的边都是一条长度为 $1$ 的增广路径，这是可能的最小长度。在所有长度为 $1$ 的路径中，我们根据给定的顺序 $u_{1}<u_{2}<u_{3}<u_{4}<v_{1}<v_{2}<v_{3}<v_{4}$ 选择字典序最小的一条。候选路径有 $(u_{1},v_{1})$、$(u_{1},v_{2})$、$(u_{1},v_{3})$、$(u_{2},v_{1})$、$(u_{3},v_{1})$。比较这些序列，最小的是 $(u_{1},v_{1})$。因此 $P_{1}=(u_{1},v_{1})$ 并且\n$$\nM_{1}=M_{0}\\oplus P_{1}=\\{(u_{1},v_{1})\\}.\n$$\n\n迭代2在匹配 $M_{1}=\\{(u_{1},v_{1})\\}$ 的基础上进行。$U$ 中的自由顶点是 $u_{2},u_{3},u_{4}$，$V$ 中的自由顶点是 $v_{2},v_{3},v_{4}$。不存在长度为 $1$ 的增广路径，因为任何单条边必须连接两个自由顶点；而图中现有的边都接触到 $u_{1}$ 或 $v_{1}$，这两个顶点都已被匹配。因此，最短增广路径的长度为 $3$（因为增广路径的长度必须是奇数）。从 $u_{2}$ 出发，沿着“未匹配-匹配-未匹配”的边序列可以得到两个候选路径：\n$$\n(u_{2},v_{1},u_{1},v_{2}),\\quad (u_{2},v_{1},u_{1},v_{3}),\n$$\n这是因为 $(u_{2},v_{1})$ 是未匹配边，$(v_{1},u_{1})$ 是匹配边，而从 $u_{1}$ 出发的未匹配邻居是 $v_{2}$ 和 $v_{3}$，它们都是自由顶点。类似地，从 $u_{3}$ 出发可以得到 $(u_{3},v_{1},u_{1},v_{2})$ 和 $(u_{3},v_{1},u_{1},v_{3})$，而从自由顶点 $v_{2}$ 或 $v_{3}$ 出发会得到以 $v_{2}$ 或 $v_{3}$ 开始的对称路径。在所有这些长度为 $3$ 的路径中，我们选择字典序最小的一条：比较起始顶点，$u_{2}$ 在 $u_{2},u_{3},v_{2},v_{3}$ 中是最小的；在以 $u_{2}$ 开始的两条路径中，我们比较最后一个顶点 $v_{2}$ 和 $v_{3}$，得出 $(u_{2},v_{1},u_{1},v_{2})$ 是字典序最小的。因此 $P_{2}=(u_{2},v_{1},u_{1},v_{2})$。\n\n我们用 $P_{2}$ 与匹配进行对称差运算来更新匹配。$P_{2}$ 的边是 $(u_{2},v_{1})$、$(u_{1},v_{1})$、$(u_{1},v_{2})$。相对于 $M_{1}=\\{(u_{1},v_{1})\\}$ 翻转这些边的状态，会移除 $(u_{1},v_{1})$ 并添加 $(u_{2},v_{1})$ 和 $(u_{1},v_{2})$。因此\n$$\nM_{2}=M_{1}\\oplus P_{2}=\\{(u_{1},v_{2}),\\,(u_{2},v_{1})\\},\n$$\n这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1520050"}, {"introduction": "在现实世界的复杂问题中，寻找最优解的算法有时成本高昂。一种常见的策略是采用更简单、更快速的“贪心”算法。这个练习探讨了这种权衡，要求你分析一个特定贪心策略的性能，并将其与最优匹配进行比较。通过这个过程，你将接触到算法分析中的一个重要概念——性能比 (performance ratio)，理解贪心选择可能导致的后果。[@problem_id:1520052]", "problem": "在一个大规模分布式计算环境中，一个资源管理器需要将任务分配给处理节点。对于一个给定的整数参数 $k \\ge 1$，该系统由两组节点组成：一组 $2k$ 个“供应者”节点 $A$ 和一组 $2k$ 个“请求者”节点 $B$。这些节点被分组成 $k$ 个独立的集群，索引从 $1$ 到 $k$。对于每个索引 $i \\in \\{1, \\ldots, k\\}$，集群 $i$ 由两个供应者节点 $\\{a_{i,1}, a_{i,2}\\}$ 和两个请求者节点 $\\{b_{i,1}, b_{i,2}\\}$ 组成。\n\n在任何集群 $i$ 内，供应者和请求者之间的兼容性定义如下，形成一个二分图：\n1.  **直接链接**：节点 $a_{i,1}$ 可以服务于节点 $b_{i,1}$，节点 $a_{i,2}$ 可以服务于节点 $b_{i,2}$。这些构成了直接链接的集合。\n2.  **备用链接**：节点 $a_{i,1}$ 也可以服务于节点 $b_{i,2}$。这构成了备用链接的集合。\n不存在其他兼容性；具体来说，来自不同集群的节点不能连接。\n\n系统使用一个简单的、确定性的贪心算法进行分配。该算法优先处理备用链接，而不是直接链接。它分两个连续的阶段运行：\n- **阶段 1**：算法遍历整个系统中所有可能的备用链接。对于它所考虑的每个备用链接 $(u, v)$，如果节点 $u$ 和节点 $v$ 当前都未分配，则将它们相互分配。\n- **阶段 2**：完成阶段 1 后，算法遍历所有可能的直接链接。对于它所考虑的每个直接链接 $(u, v)$，如果节点 $u$ 和节点 $v$ 当前都未分配，则将它们相互分配。\n\n对于这个特定的系统架构，在每个阶段内考虑链接的顺序不影响结果。令 $N_{greedy}(k)$ 为此贪心算法所做的分配总数，令 $N_{opt}(k)$ 为系统可能的最大分配数（即最大匹配的大小）。\n\n确定该系统的性能比 $\\frac{N_{opt}(k)}{N_{greedy}(k)}$。结果是一个与 $k$ 无关的常数值。", "solution": "该问题要求计算在一个特殊构造的二分图族上，一个特定的贪心匹配算法相对于一个最优匹配的性能比。让我们来分析贪心算法所做的分配数 $N_{greedy}(k)$ 和可能的最大分配数 $N_{opt}(k)$。\n\n首先，对于给定的 $k \\ge 1$，我们形式化地定义二分图 $G_k = (L_k \\cup R_k, E_k)$。\n顶点的两个部分是供应者节点和请求者节点：\n$L_k = \\bigcup_{i=1}^{k} \\{a_{i,1}, a_{i,2}\\}$\n$R_k = \\bigcup_{i=1}^{k} \\{b_{i,1}, b_{i,2}\\}$\n每个部分的大小为 $|L_k| = |R_k| = 2k$。\n\n边集 $E_k$ 由直接链接和备用链接组成。\n备用链接的集合是 $E_{backup} = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n直接链接的集合是 $E_{direct} = \\{ (a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n总边集是 $E_k = E_{backup} \\cup E_{direct}$。该图由 $k$ 个不相交的相同组件构成，每个索引 $i$ 对应一个。\n\n**步骤 1：计算贪心匹配的大小, $N_{greedy}(k)$。**\n贪心算法分两个阶段进行。令 $M_G$ 表示该算法构建的匹配。\n\n**阶段 1：处理备用链接**\n算法考虑 $E_{backup}$ 中的所有边。让我们考虑一个任意集群 $i$ 的边 $(a_{i,1}, b_{i,2})$。最初，所有节点都未分配。由于集群是不相交的，一个集群内的分配不影响另一个集群的初始状态。\n对于每个 $i \\in \\{1, \\ldots, k\\}$，算法考虑备用链接 $(a_{i,1}, b_{i,2})$。由于节点 $a_{i,1}$ 和 $b_{i,2}$ 都未分配，所以这条边被添加到匹配 $M_G$ 中。这种情况对每个集群 $i$ 都会发生。\n阶段 1 完成后，匹配包含所有备用链接：\n$M_G = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n此时，匹配的大小为 $k$。\n已分配的节点集合为：\n- 来自部分 $L_k$ 的：$\\{a_{1,1}, a_{2,1}, \\ldots, a_{k,1}\\}$\n- 来自部分 $R_k$ 的：$\\{b_{1,2}, b_{2,2}, \\ldots, b_{k,2}\\}$\n\n**阶段 2：处理直接链接**\n算法现在考虑 $E_{direct}$ 中的所有边。只有当一条边的两个端点都未分配时，它才能被添加。\n对于每个集群 $i$，直接链接有两种类型：$(a_{i,1}, b_{i,1})$ 和 $(a_{i,2}, b_{i,2})$。\n- 对于链接 $(a_{i,1}, b_{i,1})$：节点 $a_{i,1}$ 在阶段 1 中已经被分配给了 $b_{i,2}$。因此，该链接不能被添加到匹配中。\n- 对于链接 $(a_{i,2}, b_{i,2})$：节点 $b_{i,2}$ 在阶段 1 中已经被分配给了 $a_{i,1}$。因此，该链接不能被添加到匹配中。\n这对于所有的 $i \\in \\{1, \\ldots, k\\}$ 都成立。因此，在阶段 2 中没有新的边被添加到匹配中。\n\n贪心算法产生的最终匹配是 $M_G = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n这个匹配的大小是 $N_{greedy}(k) = |M_G| = k$。\n\n**步骤 2：计算最大匹配的大小, $N_{opt}(k)$。**\n图 $G_k$ 是 $k$ 个相同子图的不相交并集，每个集群 $i$ 对应一个子图。$G_k$ 的最大匹配是这些子图的最大匹配的并集。让我们来找单个集群 $i$ 的最大匹配。\n集群 $i$ 的子图有节点 $\\{a_{i,1}, a_{i,2}\\}$ 和 $\\{b_{i,1}, b_{i,2}\\}$，以及边 $(a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}), (a_{i,1}, b_{i,2})$。\n我们可以在这个子图中找到一个完美匹配，例如，通过选择两个直接链接：\n$M_i^* = \\{ (a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}) \\}$。\n这个匹配覆盖了集群 $i$ 的子图中的所有四个节点。它的大小为 2。由于完美匹配覆盖了所有顶点，所以它必定是该子图的一个最大匹配。因此，一个集群的最大匹配大小为 2。\n\n为了找到整个图 $G_k$ 的最大匹配，我们将 $k$ 个不相交集群的每个最大匹配的大小相加。\n$N_{opt}(k) = \\sum_{i=1}^{k} |M_i^*| = \\sum_{i=1}^{k} 2 = 2k$。\n\n**步骤 3：计算性能比。**\n性能比是最优匹配的大小除以贪心匹配的大小。\n$$ \\text{性能比} = \\frac{N_{opt}(k)}{N_{greedy}(k)} = \\frac{2k}{k} = 2 $$\n该比值为 2，与 $k$ 的值无关 (对于 $k \\ge 1$）。", "answer": "$$\\boxed{2}$$", "id": "1520052"}]}