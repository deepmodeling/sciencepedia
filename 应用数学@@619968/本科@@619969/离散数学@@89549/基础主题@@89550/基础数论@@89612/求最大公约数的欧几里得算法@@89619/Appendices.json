{"hands_on_practices": [{"introduction": "我们学习算法的最佳方式之一就是将其应用于解决实际问题。这个练习将欧几里得算法置于一个常见的场景中：用相同的方砖铺设一个矩形区域。通过解决这个问题，你将亲身体会到如何将一个看似关于几何布局的挑战，转化为一个纯粹的数论问题，即寻找两个数的最大公约数 $gcd$。[@problem_id:1406858]", "problem": "一位景观设计师正在为一个新的城市公园设计一个矩形露台。该露台的指定区域长1164厘米，宽876厘米。设计师计划使用相同的、不重叠的正方形瓷砖铺满整个区域。为了最大限度地降低成本并减少砖缝带来的美观影响，设计师希望使用能完美覆盖该区域而无需切割任何瓷砖的、尽可能大的正方形瓷砖。\n\n可用于此项目的最大正方形瓷砖的边长是多少厘米？", "solution": "设每块正方形瓷砖的边长为 $s$。要用边长为 $s$ 的不重叠的正方形瓷砖精确地铺满 $1164 \\times 876$ 的矩形区域，1164和876都必须是 $s$ 的整数倍。因此，$s$ 必须是1164和876的一个公约数。最大的这样的 $s$ 是它们的最大公约数：\n$$\ns=\\gcd(1164,876).\n$$\n使用欧几里得算法计算 $\\gcd(1164,876)$：\n$$\n1164=1\\cdot 876+288,\n$$\n$$\n876=3\\cdot 288+12,\n$$\n$$\n288=24\\cdot 12+0.\n$$\n最后一个非零余数是12，因此\n$$\n\\gcd(1164,876)=12.\n$$\n所以，最大正方形瓷砖的边长是12厘米。", "answer": "$$\\boxed{12}$$", "id": "1406858"}, {"introduction": "如果你能正向执行一个过程，那么尝试逆向操作它将极大地加深你的理解。本练习为你提供了欧几里得算法在执行过程中产生的一系列余数，并要求你反推出原始的输入数字。这个“逆向工程”的挑战会促使你仔细思考算法每一步中除数、被除数、商和余数之间的确切关系。[@problem_id:1406844]", "problem": "欧几里得算法是一种用于求两个整数的最大公约数（GCD）的方法。当该算法应用于两个满足 $a > b$ 的正整数 $a$ 和 $b$ 时，它会生成一系列带余除法。第一次除法是 $a$ 除以 $b$ 得到余数 $r_1$。第二次是 $b$ 除以 $r_1$ 得到余数 $r_2$。这个过程持续进行，在随后的每一步中，都用上一步的除数除以上一步的余数，直到余数为0为止。最大公约数就是最后一个非零余数。\n\n假设对于一对满足 $a>b$ 的正整数 $a$ 和 $b$，执行欧几里得算法产生的连续非零余数序列如下：$r_1 = 24$，$r_2 = 18$ 和 $r_3 = 6$。\n\n求和 $a+b$ 的最小可能值。", "solution": "根据欧几里得算法，当连续余数为 $r_{1}=24$，$r_{2}=18$，$r_{3}=6$ 时，除法形式如下\n$$\na=q_{1}b+24,\\quad 0<24<b,\\quad q_{1}\\in\\mathbb{Z}_{\\ge 1},\n$$\n$$\nb=q_{2}\\cdot 24+18,\\quad 0<18<24,\\quad q_{2}\\in\\mathbb{Z}_{\\ge 1},\n$$\n$$\n24=q_{3}\\cdot 18+6,\\quad 0<6<18,\n$$\n$$\n18=q_{4}\\cdot 6+0.\n$$\n由 $24=q_{3}\\cdot 18+6$ 可得 $q_{3}=1$。由 $18=q_{4}\\cdot 6$ 可得 $q_{4}=3$。因此，仅有的自由商是 $q_{1},q_{2}\\in\\mathbb{Z}_{\\ge 1}$，并且\n$$\nb=24q_{2}+18,\\qquad a=q_{1}b+24.\n$$\n因此，和为\n$$\na+b=(q_{1}+1)b+24=(q_{1}+1)(24q_{2}+18)+24.\n$$\n为了在整数 $q_{1},q_{2}\\ge 1$ 的范围内最小化 $a+b$，选择 $q_{1}=1$ 和 $q_{2}=1$，得到\n$$\nb=24\\cdot 1+18=42,\\qquad a=1\\cdot 42+24=66,\n$$\n所以\n$$\na+b=66+42=108.\n$$\n这些值与给定的余数序列相符：\n$$\n66=1\\cdot 42+24,\\quad 42=1\\cdot 24+18,\\quad 24=1\\cdot 18+6,\\quad 18=3\\cdot 6+0.\n$$\n因此，$a+b$ 的最小可能值是 $108$。", "answer": "$$\\boxed{108}$$", "id": "1406844"}, {"introduction": "掌握一个算法不仅意味着知道如何使用它，还意味着理解其每一部分为何必不可少。这个练习将你的角色从计算者转变为分析师。你将面对一个看似正确但实际存在逻辑缺陷的欧几里得算法伪代码，你的任务是诊断出问题所在，从而深刻理解标准算法的结构对于保证其正确性和最终终止是多么关键。[@problem_id:1406857]", "problem": "一个学生需要实现一个递归函数，以求出两个非负整数的最大公约数（GCD）。GCD 是能够同时整除这两个数而没有余数的最大正整数。该学生编写了以下名为 `Altered_GCD` 的函数伪代码。\n\n```\nFUNCTION Altered_GCD(a, b):\n    // a and b are non-negative integers\n    // 'MOD' represents the modulo operator\n\n    IF b == 0:\n        RETURN a\n    ELSE:\n        RETURN Altered_GCD(a MOD b, b)\n```\n\n分析这个 `Altered_GCD` 函数的行为。对于任意非负整数输入 `a` 和 `b`，以下哪个陈述最准确地描述了其功能？\n\nA. 该函数能为所有非负整数 `a` 和 `b` 正确计算出 GCD。\n\nB. 当且仅当初始输入满足 `a >= b` 时，该函数才能正确计算出 GCD。\n\nC. 对于 `b` 为正整数的任何输入，该函数都无法终止。\n\nD. 该函数计算的是最小公倍数（LCM）而不是 GCD。\n\nE. 该函数能正确计算出 GCD，但仅限于 `a` 和 `b` 互质（其 GCD 为 1）时。", "solution": "题目要求我们分析一个用于求最大公约数（GCD）的、有缺陷的欧几里得算法的递归实现。我们通过检查 `Altered_GCD(a, b)` 函数的基线条件和递归步骤来分析其行为。\n\n提供的伪代码如下：\n```\nFUNCTION Altered_GCD(a, b):\n    IF b == 0:\n        RETURN a\n    ELSE:\n        RETURN Altered_GCD(a MOD b, b)\n```\n\n**情况1：基线条件**\n递归的基线条件是 `b == 0`。如果函数在调用时 `b=0`，例如 `Altered_GCD(a, 0)`，它会立即返回 `a`。这是正确的行为，因为任何数 `a` 和 0 的 GCD 定义为 `a`。因此，如果第二个参数初始为 0，函数会终止并给出正确答案。\n\n**情况2：递归步骤**\n当 `b > 0` 时，执行递归步骤。函数以新的参数 `Altered_GCD(a MOD b, b)` 调用自身。\n\n让我们跟踪一下参数。\n设初始调用为 `(a_0, b_0) = (a, b)`。\n第一次递归调用将使用 `(a_1, b_1)`，其中：\n$a_1 = a_0 \\text{ MOD } b_0$\n$b_1 = b_0$\n\n第二次递归调用将使用 `(a_2, b_2)`，其中：\n$a_2 = a_1 \\text{ MOD } b_1$\n$b_2 = b_1$\n\n注意这里的关键缺陷：第二个参数 `b` 在每次递归调用中都保持不变。我们用 `b_n` 表示第 n 次递归步骤中的第二个参数。我们有 $b_n = b_{n-1} = \\dots = b_1 = b_0 = b$。\n\n为了使递归算法能够终止，其状态必须向基线条件发展。在这个算法中，基线条件是 `b == 0`。由于第二个参数的值永远不会从其初始值 `b` 改变，除非 `b` 从一开始就是 0，否则 `b == 0` 这个条件永远不会被满足。\n\n让我们考虑一个任意输入 `(a, b)`，其中 `b > 0`。\n调用序列是：\n`Altered_GCD(a, b)`\n`-> Altered_GCD(a MOD b, b)`\n`-> Altered_GCD((a MOD b) MOD b, b)`\n`-> Altered_GCD(((a MOD b) MOD b) MOD b, b)`\n...以此类推。\n\n我们来检查第一个参数。设 $a' = a \\text{ MOD } b$。根据模运算符的定义，$0 \\le a' < b$。\n第一个位置的下一个参数是 $a' \\text{ MOD } b$。因为 $0 \\le a' < b$，所以 $a' \\text{ MOD } b = a'$。\n所以，在第一次递归调用 `Altered_GCD(a MOD b, b)` 之后，所有后续调用都将是 `Altered_GCD(a MOD b, b)`。函数进入了一个无法逃逸的状态。这导致了无限递归。\n\n例如，我们跟踪一下 `Altered_GCD(25, 10)`：\n1. `Altered_GCD(25, 10)` -> `b` 不为 0。返回 `Altered_GCD(25 MOD 10, 10)`，即 `Altered_GCD(5, 10)`。\n2. `Altered_GCD(5, 10)` -> `b` 不为 0。返回 `Altered_GCD(5 MOD 10, 10)`，即 `Altered_GCD(5, 10)`。\n3. `Altered_GCD(5, 10)` -> 返回 `Altered_GCD(5, 10)`。 ... 这个过程会永远持续下去。\n\n我们来跟踪另一个 `a < b` 的例子，比如 `Altered_GCD(10, 25)`：\n1. `Altered_GCD(10, 25)` -> `b` 不为 0。返回 `Altered_GCD(10 MOD 25, 25)`，即 `Altered_GCD(10, 25)`。\n2. 这会立即进入一个无限循环。\n\n唯一能够终止的情况是初始的 `b` 为 0。如果 `b` 是任何正整数，函数将进入无限递归并且无法终止。\n\n现在我们来评估这些选项：\nA. 该函数能为所有非负整数 `a` 和 `b` 正确计算出 GCD。这是错误的。如果 `b > 0`，它就无法终止。\nB. 当且仅当初始输入满足 `a >= b` 时，该函数才能正确计算出 GCD。这是错误的。我们的例子 `Altered_GCD(25, 10)` 表明，即使 `a > b`，它也会失败。\nC. 对于 `b` 为正整数的任何输入，该函数都无法终止。这是正确的，正如我们的分析所示。`b` 的值永远不会减小以达到基线条件 0。\nD. 该函数计算的是最小公倍数（LCM）而不是 GCD。这是错误的。该结构基于欧几里得算法，其失败模式是无法终止，而不是计算一个不同的量。\nE. 该函数能正确计算出 GCD，但仅限于 `a` 和 `b` 互质（其 GCD 为 1）时。这是错误的。例如，`Altered_GCD(7, 5)`（互质）与 `Altered_GCD(25, 10)` 一样无法终止。终止问题与输入是否互质无关。\n\n因此，最准确的描述是，对于任何正整数 `b`，该函数都无法终止。", "answer": "$$\\boxed{C}$$", "id": "1406857"}]}