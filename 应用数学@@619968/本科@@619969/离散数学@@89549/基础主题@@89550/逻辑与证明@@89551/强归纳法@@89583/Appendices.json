{"hands_on_practices": [{"introduction": "强归纳法是证明关于整数性质的强大工具，尤其是在处理存在性证明时。这个练习将带你探索一个独特的数字表示系统，其中数字由3的幂次方的和构成。通过解决这个问题，你将亲身体会到一个看似简单的计算任务背后，如何依赖于一个可以通过强归纳法证明的深刻数学定理——即任何正整数都存在这样一种唯一的表示形式。[@problem_id:1402576]", "problem": "一种被称为“Trit-Memory”的特殊数字存储器，使用一种独特的编码方案来存储正整数。在该方案中，任何正整数 $n$ 都被表示为3的幂之和，其中每个幂最多能使用两次。这意味着任何整数 $n$ 都可以唯一地写成以下形式：\n$$n = \\sum_{k=0}^{M} c_k 3^k$$\n其中系数 $c_k$ 只能是0、1或2，而 $M$ 是满足 $3^M \\le n$ 的最大整数。在Trit-Memory中存储一个数 $n$ 的“复杂度”定义为其表示中所有系数的总和。也就是说，Complexity$(n) = \\sum_{k=0}^{M} c_k$。\n\n例如，要存储数字 $n=17$，我们求得其表示为 $17 = 1 \\cdot 3^2 + 2 \\cdot 3^1 + 2 \\cdot 3^0$。系数为 $c_2=1, c_1=2, c_0=2$。因此，存储17的复杂度为 Complexity$(17) = 1 + 2 + 2 = 5$。\n\n求存储整数 $n = 1180$ 的复杂度。", "solution": "我们使用给定的、数位在 $\\{0,1,2\\}$ 中的类三进制表示法，这即是标准的三进制展开。所需的最大幂次满足 $3^{6} \\le 1180  3^{7}$，所以 $M=6$。我们通过除法算法来确定系数 $c_{k}$，由于在选择 $c_{k}$ 之前，余数总是小于 $3^{k+1}$，因此可以确保在每一步中都有 $0 \\le c_{k} \\le 2$。\n\n从余数 $r=1180$ 开始。\n对于 $k=6$：\n$$c_{6}=\\left\\lfloor \\frac{r}{3^{6}} \\right\\rfloor=\\left\\lfloor \\frac{1180}{729} \\right\\rfloor=1,\\quad r \\leftarrow r-c_{6}3^{6}=1180-1\\cdot 729=451.$$\n对于 $k=5$：\n$$c_{5}=\\left\\lfloor \\frac{r}{3^{5}} \\right\\rfloor=\\left\\lfloor \\frac{451}{243} \\right\\rfloor=1,\\quad r \\leftarrow 451-1\\cdot 243=208.$$\n对于 $k=4$：\n$$c_{4}=\\left\\lfloor \\frac{r}{3^{4}} \\right\\rfloor=\\left\\lfloor \\frac{208}{81} \\right\\rfloor=2,\\quad r \\leftarrow 208-2\\cdot 81=46.$$\n对于 $k=3$：\n$$c_{3}=\\left\\lfloor \\frac{r}{3^{3}} \\right\\rfloor=\\left\\lfloor \\frac{46}{27} \\right\\rfloor=1,\\quad r \\leftarrow 46-1\\cdot 27=19.$$\n对于 $k=2$：\n$$c_{2}=\\left\\lfloor \\frac{r}{3^{2}} \\right\\rfloor=\\left\\lfloor \\frac{19}{9} \\right\\rfloor=2,\\quad r \\leftarrow 19-2\\cdot 9=1.$$\n对于 $k=1$：\n$$c_{1}=\\left\\lfloor \\frac{r}{3^{1}} \\right\\rfloor=\\left\\lfloor \\frac{1}{3} \\right\\rfloor=0,\\quad r \\leftarrow 1-0\\cdot 3=1.$$\n对于 $k=0$：\n$$c_{0}=\\left\\lfloor \\frac{r}{3^{0}} \\right\\rfloor=\\left\\lfloor \\frac{1}{1} \\right\\rfloor=1,\\quad r \\leftarrow 1-1\\cdot 1=0.$$\n\n因此，\n$$1180=1\\cdot 3^{6}+1\\cdot 3^{5}+2\\cdot 3^{4}+1\\cdot 3^{3}+2\\cdot 3^{2}+0\\cdot 3^{1}+1\\cdot 3^{0}.$$\n复杂度是这些系数的和：\n$$\\text{Complexity}(1180)=c_{6}+c_{5}+c_{4}+c_{3}+c_{2}+c_{1}+c_{0}=1+1+2+1+2+0+1=8.$$", "answer": "$$\\boxed{8}$$", "id": "1402576"}, {"introduction": "许多组合计数问题都可以通过建立递推关系来解决，而强归纳法是验证这些关系正确性的关键。这个问题展示了一个经典场景，其中问题的解依赖于不止一个先前状态，这恰恰是强归纳法大显身手的领域。通过构建和求解该递推关系，你将理解为什么需要一个“强”的归纳假设（即假定命题对所有小于 $n$ 的情况都成立），而不是仅仅依赖于 $n-1$ 的情况。[@problem_id:1402596]", "problem": "某种类型的计算机存储器被设计为以二进制字符串（由0和1组成的序列）的形式存储数据。由于数据写入机制的物理限制，无法写入两个连续的'0'。任何不包含子字符串'00'的二进制字符串都被认为是'有效字'。您的任务是确定长度为 $n=17$ 的不同有效字的总数。", "solution": "设 $a_n$ 为长度为 $n$ 的有效二进制字符串的数量，其中有效字符串是指不包含子字符串 '00' 的字符串。我们要求解 $a_{17}$ 的值。\n\n为了解决这个问题，我们首先找到 $a_n$ 的一个递推关系。我们从建立 $n$ 较小值时的基本情况开始。\n\n对于 $n=1$：可能的字符串是 \"0\" 和 \"1\"。两者都不包含子字符串 \"00\"，因此它们都是有效的。所以，$a_1 = 2$。\n\n对于 $n=2$：可能的二进制字符串是 \"00\"、\"01\"、\"10\" 和 \"11\"。字符串 \"00\" 是被禁止的。其他三个字符串 \"01\"、\"10\" 和 \"11\" 是有效的。所以，$a_2 = 3$。\n\n现在，我们考虑一个长度为 $n$（其中 $n \\geq 3$）的有效字符串。我们可以根据它们的最后一位来对这些字符串进行分类。\n\n情况1：字符串以'1'结尾。\n如果一个长度为 $n$ 的有效字符串以'1'结尾，那么它的前 $n-1$ 位可以构成任何长度为 $n-1$ 的有效字符串。在任何有效字符串后面附加一个'1'，永远不会产生被禁止的 \"00\" 子字符串。因此，以'1'结尾的长度为 $n$ 的有效字符串的数量，等于长度为 $n-1$ 的有效字符串的总数，即 $a_{n-1}$。\n\n情况2：字符串以'0'结尾。\n如果一个长度为 $n$ 的有效字符串以'0'结尾，那么第 $n-1$ 位上的数字不能是 '0'，因为那样会产生被禁止的 \"00\" 子字符串。因此，第 $n-1$ 位上的数字必须是'1'。这意味着该字符串必须以 \"10\" 结尾。其前 $n-2$ 位可以构成任何长度为 $n-2$ 的有效字符串。在任何长度为 $n-2$ 的有效字符串后面附加 \"10\"，总会得到一个长度为 $n$ 的有效字符串。因此，以'0'结尾的长度为 $n$ 的有效字符串的数量，等于长度为 $n-2$ 的有效字符串的总数，即 $a_{n-2}$。\n\n由于这两种情况是互斥的（一个字符串不能同时以'0'和'1'结尾）并且是穷尽的（一个字符串必须以'0'或'1'结尾），我们可以通过将两种情况的计数相加来得到长度为 $n$ 的有效字符串的总数。这就得到了递推关系：\n$$ a_n = a_{n-1} + a_{n-2} $$\n此关系对于 $n \\geq 3$ 成立。这个依赖于前两项的递推关系的建立，可以利用强归纳法原理进行形式化证明，其中 $a_1$ 和 $a_2$ 作为归纳的基础。\n\n现在我们可以顺序计算 $a_n$ 的值，直到达到 $a_{17}$：\n$a_1 = 2$\n$a_2 = 3$\n$a_3 = a_2 + a_1 = 3 + 2 = 5$\n$a_4 = a_3 + a_2 = 5 + 3 = 8$\n$a_5 = a_4 + a_3 = 8 + 5 = 13$\n$a_6 = a_5 + a_4 = 13 + 8 = 21$\n$a_7 = a_6 + a_5 = 21 + 13 = 34$\n$a_8 = a_7 + a_6 = 34 + 21 = 55$\n$a_9 = a_8 + a_7 = 55 + 34 = 89$\n$a_{10} = a_9 + a_8 = 89 + 55 = 144$\n$a_{11} = a_{10} + a_9 = 144 + 89 = 233$\n$a_{12} = a_{11} + a_{10} = 233 + 144 = 377$\n$a_{13} = a_{12} + a_{11} = 377 + 233 = 610$\n$a_{14} = a_{13} + a_{12} = 610 + 377 = 987$\n$a_{15} = a_{14} + a_{13} = 987 + 610 = 1597$\n$a_{16} = a_{15} + a_{14} = 1597 + 987 = 2584$\n$a_{17} = a_{16} + a_{15} = 2584 + 1597 = 4181$\n\n长度为 $n=17$ 的不同有效字的总数是 4181。", "answer": "$$\\boxed{4181}$$", "id": "1402596"}, {"introduction": "强归纳法不仅能证明性质或计数，还能揭示递归过程中隐藏的不变性。在这个关于数据包分解的问题中，你将发现一个惊人的事实：无论分解过程如何进行，总计算成本都是一个定值。这个问题完美地展示了如何利用强归纳法来证明一个过程的不变量，从而将一个看似复杂、依赖于选择路径的问题简化为一个优美的、确定的公式。[@problem_id:1402593]", "problem": "在一种特定的数据通信协议中，大数据包在传输前必须进行分片。该分片过程是递归的。单次操作包括：取任意一个大小为 $k  1$ 字节的数据包，并将其分割成两个更小的、大小分别为 $k_1$ 和 $k_2$ 的非空数据包，其中 $k_1 + k_2 = k$。与单次分割操作相关的计算成本定义为两个新生成的数据包大小的乘积，即 $k_1 \\times k_2$。重复此过程，直到初始数据包被完全分解为多个大小为1字节的数据包。\n\n计算将一个大小为 $N = 50$ 字节的初始数据包完全分片成50个独立的1字节数据包所需的总计算成本。", "solution": "设总计算成本为 $S$。考虑一个势函数 $P$，其定义为在过程的任何阶段，当前所有数据包大小的平方和。\n\n初始时，只有一个大小为 $N$ 的数据包，所以初始势能为\n$$\nP_{\\text{initial}} = N^{2}.\n$$\n结束时，有 $N$ 个大小为1的数据包，所以最终势能为\n$$\nP_{\\text{final}} = N.\n$$\n现在分析单次分割：一个大小为 $k$ 的数据包被分割成大小为 $k_{1}$ 和 $k_{2}$ 的两个包，满足 $k_{1} + k_{2} = k$。这次分割引起的势能变化量为\n$$\n\\Delta P = k_{1}^{2} + k_{2}^{2} - k^{2} = k_{1}^{2} + k_{2}^{2} - (k_{1} + k_{2})^{2} = -2 k_{1} k_{2}.\n$$\n这次分割的成本是 $k_{1} k_{2}$，因此\n$$\n\\text{cost of split} = -\\frac{1}{2} \\Delta P = \\frac{1}{2}\\left(k^{2} - k_{1}^{2} - k_{2}^{2}\\right).\n$$\n对所有分割操作的此恒等式求和，中间项通过势函数裂项相消，得到总成本\n$$\nS = \\frac{1}{2}\\left(P_{\\text{initial}} - P_{\\text{final}}\\right) = \\frac{1}{2}\\left(N^{2} - N\\right).\n$$\n当 $N = 50$ 时，可得\n$$\nS = \\frac{1}{2}\\left(50^{2} - 50\\right) = \\frac{1}{2}\\cdot 2450 = 1225.\n$$", "answer": "$$\\boxed{1225}$$", "id": "1402593"}]}