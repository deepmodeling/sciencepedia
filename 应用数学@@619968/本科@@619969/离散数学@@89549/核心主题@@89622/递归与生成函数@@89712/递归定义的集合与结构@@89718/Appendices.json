{"hands_on_practices": [{"introduction": "递归地定义一个集合是一门精确的艺术。一个正确的定义必须同时具备*可靠性*（soundness），即它只生成确实属于该集合的元素，以及*完备性*（completeness），即它能生成集合中的每一个元素。第一个练习要求你扮演一个评判者的角色，通过评估几个候选的递归定义，找出一个能够完美描述给定字符串集合的定义。这项任务将锻炼你对递归规则的生成能力和约束进行逻辑推理的能力 [@problem_id:1395530]。", "problem": "设 $S$ 为字母表 $\\Sigma = \\{a, b\\}$ 上所有有限字符串的集合，使得对于任何字符串 $w \\in S$，$w$ 中 $a$ 的数量恰好是 $w$ 中 $b$ 的数量的两倍。我们用 $n_a(w)$ 和 $n_b(w)$ 分别表示符号 $a$ 和 $b$ 在字符串 $w$ 中出现的次数。因此，该集合被正式定义为 $S = \\{w \\in \\{a, b\\}^* \\mid n_a(w) = 2n_b(w)\\}$。空字符串，记作 $\\lambda$，属于 $S$，因为 $n_a(\\lambda) = 0$ 且 $n_b(\\lambda) = 0$。\n\n以下哪个选项为集合 $S$ 提供了一个正确且完备的递归定义？\n\nA.\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $u \\in S$ 且 $v \\in S$，那么它们的连接 $uv \\in S$。此外，字符串 $auavb$、$aubva$ 和 $buava$ 也在 $S$ 中。\n\nB.\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $u \\in S$ 且 $v \\in S$，那么字符串 $auavb$、$aubva$ 和 $buava$ 在 $S$ 中。\n\nC.\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $w \\in S$，则字符串 $aawb$ 在 $S$ 中。另外，如果 $u \\in S$ 且 $v \\in S$，那么它们的连接 $uv \\in S$。\n\nD.\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 字符串 $aab$、$aba$ 和 $baa$ 在 $S$ 中。另外，如果 $u \\in S$ 且 $v \\in S$，那么它们的连接 $uv \\in S$。\n\nE.\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $w \\in S$，那么字符串 $aabw$、$abaw$ 和 $baaw$ 在 $S$ 中。", "solution": "为了找到集合 $S = \\{w \\in \\{a, b\\}^* \\mid n_a(w) = 2n_b(w)\\}$ 的正确递归定义，我们必须评估每个选项，以判断其是否既*可靠*又*完备*。如果一个定义只生成属于 $S$ 的字符串，则该定义是可靠的。如果一个定义可以生成所有属于 $S$ 的字符串，则该定义是完备的。\n\n首先，我们来确定选项中出现的两种常见规则的可靠性。\n1.  **连接规则：** 如果 $u \\in S$ 且 $v \\in S$，那么 $n_a(u) = 2n_b(u)$ 且 $n_a(v) = 2n_b(v)$。对于它们的连接 $uv$，$a$ 的数量是 $n_a(uv) = n_a(u) + n_a(v) = 2n_b(u) + 2n_b(v) = 2(n_b(u) + n_b(v)) = 2n_b(uv)$。因此，连接规则“如果 $u, v \\in S$，那么 $uv \\in S$”是可靠的。$S$ 中的许多字符串是由连接形成的（例如，`aabbaa` 在 $S$ 中，并且可以看作是 `aab` 和 `baa` 的连接，它们也都属于 $S$）。一个完备的定义必须能解释这类字符串。\n\n2.  **基础步骤：** 空字符串 $\\lambda$ 有 $n_a(\\lambda)=0$ 和 $n_b(\\lambda)=0$。因为 $0=2 \\times 0$，所以 $\\lambda \\in S$。所有选项都正确地包含了这个基础步骤。\n\n现在，我们来分析每个选项：\n\n**选项 A：**\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $u, v \\in S$，那么 $uv \\in S$。并且，$auavb \\in S$，$aubva \\in S$ 和 $buava \\in S$。\n*   **可靠性：** `uv` 规则是可靠的。对于从 $u, v \\in S$ 生成 $w' = auavb$ 的规则：\n    $n_a(w') = n_a(u) + n_a(v) + 2 = 2n_b(u) + 2n_b(v) + 2 = 2(n_b(u) + n_b(v) + 1)$。\n    $n_b(w') = n_b(u) + n_b(v) + 1$。\n    所以，$n_a(w') = 2n_b(w')$。这个规则是可靠的。同样的逻辑也适用于其排列 `aubva` 和 `buava`。该定义是可靠的。\n*   **完备性：** 这个定义包含了连接规则，该规则处理复合字符串。其他规则，$auavb$ 及其排列，旨在生成 $S$ 中的“素”字符串（那些不能分解为 $S$ 中更小的非空字符串的字符串）。例如，取 $u=\\lambda$ 和 $v=\\lambda$，我们生成 $aab, aba, baa$。这种结构，将连接与生成素词的规则相结合，对于这种类型的语言是已知的完备的。这个选项看起来是正确的。\n\n**选项 B：**\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $u, v \\in S$，那么 $auavb \\in S$, $aubva \\in S$ 和 $buava \\in S$。\n*   **可靠性：** 如选项 A 所示，这些规则是可靠的。\n*   **完备性：** 这个定义缺少连接规则。考虑字符串 `aabbaa`。我们知道 `aabbaa` 在 $S$ 中，因为 $n_a=4, n_b=2$。这个字符串可以看作是 `aab` 和 `baa` 的连接。此选项中的规则可以生成 `aab`（当 $u=\\lambda, v=\\lambda$ 时）和 `baa`（当 $u=\\lambda, v=\\lambda$ 时）。然而，没有规则可以将它们组合起来。我们无法使用给定的递归步骤来构成 `aabbaa`，因为它必须匹配其中一种形式（例如 $auavb$），而这是不可能的。例如，要匹配 $auavb$，$u$ 必须是 `a`，而 `a` 不在 $S$ 中。所以，这个定义是不完备的。\n\n**选项 C：**\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $w \\in S$，则 $aawb \\in S$。如果 $u, v \\in S$，则 $uv \\in S$。\n*   **可靠性：** `uv` 规则是可靠的。我们来检查 `aawb` 规则。如果 $w \\in S$，$n_a(w)=2n_b(w)$。对于 $w'=aawb$，$n_a(w')=n_a(w)+2$ 且 $n_b(w')=n_b(w)+1$。所以，$n_a(w')=2n_b(w)+2=2(n_b(w)+1)=2n_b(w')$。该规则是可靠的。\n*   **完备性：** 这个定义可以生成 `aab`（通过设置 $w=\\lambda$）以及所有涉及它的连接。然而，它永远无法生成字符串 `aba` 或 `baa`，而它们都在 $S$ 中。素生成规则 `aawb` 只能产生相对于内部字符串 $w$ 而言以 `aa` 开头并以 `b` 结尾的字符串。因此，这个定义是不完备的。\n\n**选项 D：**\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 字符串 $aab$、$aba$、$baa$ 在 $S$ 中。如果 $u, v \\in S$，则 $uv \\in S$。\n*   **可靠性：** 基础情况 `aab`、`aba` 和 `baa` 都在 $S$ 中。`uv` 规则是可靠的。该定义是可靠的。\n*   **完备性：** 这个定义允许通过连接基本单元 `aab`、`aba` 和 `baa` 来构建字符串。然而，$S$ 中还有其他的“素”字符串。例如，考虑字符串 `aaaabb`。它在 $S$ 中，因为 $n_a=4, n_b=2$。它不能由 $S$ 中的任何非空字符串连接而成，所以它是一个素字符串。这个定义无法生成 `aaaabb`，因为它不是 `aab`、`aba` 或 `baa` 的连接。因此，该定义是不完备的。\n\n**选项 E：**\n*   **基础步骤：** $\\lambda \\in S$。\n*   **递归步骤：** 如果 $w \\in S$，则 $aabw \\in S$，$abaw \\in S$ 和 $baaw \\in S$。\n*   **可靠性：** 如果 $w \\in S$，那么对于 $w'=aabw$，$n_a(w') = n_a(aab)+n_a(w)=2+2n_b(w)$，而 $n_b(w')=n_b(aab)+n_b(w)=1+n_b(w)$。因为 $2n_b(w')=2(1+n_b(w))=2+2n_b(w)$，所以 $n_a(w')=2n_b(w')$。这个规则是可靠的。这同样适用于 `abaw` 和 `baaw`。\n*   **完备性：** 这个定义只允许在现有字符串前添加前缀。它无法生成那些基本块以不同方式排列的字符串。再次考虑素字符串 `aaaabb`。要生成它，它必须匹配 $aabw$、$abaw$ 或 $baaw$ 的形式。唯一可能的匹配是 $aabw$，此时 $w=aabb$。但字符串 `aabb` 不在 $S$ 中（因为它不满足 $n_a = 2n_b$ 的条件）。因此，`aaaabb` 无法被生成。这个定义是不完备的。\n\n**结论：**\n只有选项 A 提供了一套既可靠又完备的规则。它正确地包含了一个用于构建复合字符串的连接规则，以及一套可以从集合中已有的更小字符串生成所有素字符串的规则。", "answer": "$$\\boxed{A}$$", "id": "1395530"}, {"introduction": "一旦一个集合被递归规则所定义，一个基本问题随之而来：一个特定的项是否属于这个集合？本练习提供了一个动手机会，通过将笛卡尔平面上的一组递归“移动”规则转化为一个明确的代数条件来回答这个问题。通过解决这个问题，你将学会如何推导出一个通用的成员资格检验方法，这是验证递归生成结构性质的一项强大技能 [@problem_id:1395553]。", "problem": "考虑笛卡尔平面上一个整坐标点集 $S$。该集合 $S$ 被递归定义如下：\n- **基础情况：**点 $(0,0)$ 在 $S$ 中。\n- **递归步骤：**如果点 $(x, y)$ 在 $S$ 中，那么点 $(x+2, y+1)$ 和 $(x+1, y+2)$ 也在 $S$ 中。\n- **闭包：**只有通过以上规则生成的点才在 $S$ 中。\n\n以下哪个点属于集合 $S$？可能不止一个正确选项。将所有正确选项的字母按字母顺序连接起来作为您的答案。\n\nA) $(13, 11)$\nB) $(15, 12)$\nC) $(12, 14)$\nD) $(10, 15)$\nE) $(14, 13)$", "solution": "每一步都将当前点加上 $(2,1)$ 或 $(1,2)$，因此在使用 $m$ 次 $(2,1)$ 和 $n$ 次 $(1,2)$ 之后，$S$ 中的每个点都具有以下形式：\n$$\n(x,y) = m(2,1) + n(1,2).\n$$\n其中 $m,n \\in \\mathbb{Z}_{\\ge 0}$。这给出了线性方程组\n$$\nx = 2m + n, \\quad y = m + 2n.\n$$\n解出 $m$ 和 $n$：\n$$\n2x - y = 2(2m + n) - (m + 2n) = 3m \\;\\Rightarrow\\; m = \\frac{2x - y}{3},\n$$\n$$\n2y - x = 2(m + 2n) - (2m + n) = 3n \\;\\Rightarrow\\; n = \\frac{2y - x}{3}.\n$$\n因此，$(x,y) \\in S$ 当且仅当上面计算出的 $m$ 和 $n$ 是非负整数，即 $2x - y$ 和 $2y - x$ 是 $3$ 的非负倍数。\n\n检查每个选项：\n\nA) $(13,11)$: $m = \\frac{2\\cdot 13 - 11}{3} = \\frac{15}{3} = 5$, $n = \\frac{2\\cdot 11 - 13}{3} = \\frac{9}{3} = 3$; 有效。\n\nB) $(15,12)$: $m = \\frac{30 - 12}{3} = \\frac{18}{3} = 6$, $n = \\frac{24 - 15}{3} = \\frac{9}{3} = 3$; 有效。\n\nC) $(12,14)$: $m = \\frac{24 - 14}{3} = \\frac{10}{3}$; 不是整数；无效。\n\nD) $(10,15)$: $m = \\frac{20 - 15}{3} = \\frac{5}{3}$; 不是整数；无效。\n\nE) $(14,13)$: $m = \\frac{28 - 13}{3} = \\frac{15}{3} = 5$, $n = \\frac{26 - 14}{3} = \\frac{12}{3} = 4$; 有效。\n\n因此，正确选项是 A、B 和 E。", "answer": "$$\\boxed{ABE}$$", "id": "1395553"}, {"introduction": "除了识别单个成员，我们还可以利用递归来分析集合的全局属性，例如它的大小。最后一个练习要求你计算在一个递归定义的二元字符串集合中，特定长度的字符串有多少个。这个问题精彩地揭示了递归定义与递推关系——在本例中是著名的斐波那契数列——之间的深刻联系，这是算法分析和离散数学的基石 [@problem_id:1395524]。", "problem": "考虑所有由0和1组成的序列，即二进制字符串的集合。这些字符串的一个特定子集，我们称之为集合 $S$，由以下递归规则定义：\n\n- **基础步骤：** 空字符串 $\\lambda$ 在 $S$ 中。\n- **递归步骤：** 对于任何已在 $S$ 中的字符串 $w$：\n    1. 在 $w$ 后面附加一个 '1' 形成的字符串，记作 $w1$，也在 $S$ 中。\n    2. 如果字符串 $w$ 不以数字 '0' 结尾，则在 $w$ 后面附加一个 '0' 形成的字符串，记作 $w0$，也在 $S$ 中。\n\n除了通过应用这些规则生成的字符串外，$S$ 中没有其他字符串。基于此定义，确定 $S$ 中长度恰好为 15 的字符串总数。", "solution": "将定义 $S$ 的规则解释为强制要求不能出现两个连续的零。这是因为：\n- 附加 $1$ 总是允许的，所以 $1$ 不会带来任何限制。\n- 仅当当前字符串不以 $0$ 结尾时才允许附加 $0$，这等同于禁止创建子串 $00$。\n- 反过来，任何没有 $00$ 的二进制字符串都可以通过从左到右附加每个符号来构造；每个 $1$ 总是被允许的，而每个 $0$ 被允许恰好是因为它跟在 $1$ 后面（或者是第一个符号，因为空字符串不以 $0$ 结尾）。\n因此，$S$ 正是所有没有两个连续零的二进制字符串的集合。\n\n设 $a_{n}$ 表示 $S$ 中长度为 $n$ 的字符串的数量。定义：\n- $x_{n}$ 为长度为 $n$ 且以 $1$ 结尾的有效字符串的数量。\n- $y_{n}$ 为长度为 $n$ 且以 $0$ 结尾的有效字符串的数量。\n则 $a_{n} = x_{n} + y_{n}$。\n\n根据构造规则：\n- 在任何长度为 $n-1$ 的有效字符串后附加 $1$ 会得到一个长度为 $n$ 且以 $1$ 结尾的有效字符串，所以\n$$\nx_{n} = a_{n-1}.\n$$\n- 只有在长度为 $n-1$ 且以 $1$ 结尾的字符串后才允许附加 $0$，所以\n$$\ny_{n} = x_{n-1}.\n$$\n因此，\n$$\na_{n} = x_{n} + y_{n} = a_{n-1} + x_{n-1}.\n$$\n因为每个长度为 $n-1$ 且以 $1$ 结尾的有效字符串都是通过在长度为 $n-2$ 的有效字符串后附加 $1$ 得到的，所以我们有\n$$\nx_{n-1} = a_{n-2}.\n$$\n因此，序列 $\\{a_{n}\\}$ 满足斐波那契类型的递推关系\n$$\na_{n} = a_{n-1} + a_{n-2} \\quad \\text{for } n \\geq 2.\n$$\n\n初始条件由规则得出：\n- $a_{0} = 1$（只有空字符串）。\n- $a_{1} = 2$（从空字符串开始，可以附加 $0$ 和 $1$，因为空字符串不以 $0$ 结尾）。\n\n设 $\\{F_{n}\\}$ 是由 $F_{0} = 0$, $F_{1} = 1$ 和 $F_{n} = F_{n-1} + F_{n-2}$（对于 $n \\geq 2$）定义的斐波那契数列。那么通过归纳法，\n$$\na_{n} = F_{n+2} \\quad \\text{for all } n \\geq 0,\n$$\n因为 $a_{0} = 1 = F_{2}$ 且 $a_{1} = 2 = F_{3}$，并且递推关系相匹配。\n\n因此，\n$$\na_{15} = F_{17}.\n$$\n计算斐波那契数直到索引 $17$ 得到 $F_{17} = 1597$。因此，$S$ 中长度恰好为 $15$ 的字符串总数为 $1597$。", "answer": "$$\\boxed{1597}$$", "id": "1395524"}]}