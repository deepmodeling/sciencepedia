{"hands_on_practices": [{"introduction": "理论知识的真正价值在于应用。在算法设计中，我们常常需要在多种方案中做出选择。这个练习提供了一个经典场景：比较两种不同分治策略的渐近效率。通过应用主定理，你将学会如何超越表面参数（如子问题的数量和规模），精确判断哪个算法在大规模数据面前更具优势。[@problem_id:1408675]", "problem": "一家分布式计算公司正在开发一项新服务，并正在评估两种竞争算法——算法 A 和算法 B——用于处理大小为 $n$ 的数据集的核心处理任务。\n\n算法 A 是一种分治算法，它将问题分解为 2 个大小为 $n/2$ 的子问题，递归地解决它们，然后合并结果。合并步骤所需的时间与 $n^2$ 成正比。其运行时间 $T_A(n)$ 可以用递推关系式 $T_A(n) = 2T_A(n/2) + n^2$ 来描述。\n\n算法 B 是另一种分治算法，它生成 7 个子问题，每个子问题处理大小为 $n/3$ 的数据集，并递归地解决它们。其合并步骤所需的时间也与 $n^2$ 成正比。其运行时间 $T_B(n)$ 用递推式 $T_B(n) = 7T_B(n/3) + n^2$ 来描述。\n\n为了进行渐近分析，可以忽略基线条件和比例常数。根据这些递推关系，以下哪个陈述正确地描述了两种算法之间的长期效率关系？\n\nA. 算法 A 在渐近上比算法 B 更高效。用数学术语来说，$T_A(n) \\in o(T_B(n))$。\n\nB. 算法 B 在渐近上比算法 A 更高效。用数学术语来说，$T_B(n) \\in o(T_A(n))$。\n\nC. 两种算法具有相同的渐近时间复杂度。用数学术语来说，$T_A(n) \\in \\Theta(T_B(n))$。\n\nD. 主定理不适用于这些递推关系中的至少一个，因此无法用它来确定它们的复杂度。\n\nE. 根据给定的信息，无法确定一种或两种算法的渐近行为。", "solution": "我们使用主定理来分析每个递推关系。对于形式为 $T(n)=a\\,T(n/b)+f(n)$ 的递推关系，定义 $d=\\log_{b}(a)$ 并将 $f(n)$ 与 $n^{d}$ 进行比较。如果对于某个 $\\epsilon>0$，有 $f(n)=\\Omega\\!\\left(n^{d+\\epsilon}\\right)$，并且对于所有足够大的 $n$，正则性条件 $a\\,f(n/b)\\leq c\\,f(n)$ (其中常数 $c<1$) 成立，则 $T(n)=\\Theta\\!\\left(f(n)\\right)$。\n\n对于算法 A，我们有 $a=2$，$b=2$ 和 $f(n)=n^{2}$。那么\n$$\nd=\\log_{2}(2)=1,\\quad f(n)=n^{2}=\\Omega\\!\\left(n^{1+\\epsilon}\\right)\\ \\text{with}\\ \\epsilon=1.\n$$\n检查正则性条件：\n$$\na\\,f(n/b)=2\\left(\\frac{n}{2}\\right)^{2}=\\frac{n^{2}}{2}\\leq c\\,n^{2}\\ \\text{with}\\ c=\\frac{1}{2}<1.\n$$\n因此，根据主定理，\n$$\nT_{A}(n)=\\Theta\\!\\left(n^{2}\\right).\n$$\n\n对于算法 B，我们有 $a=7$，$b=3$ 和 $f(n)=n^{2}$。那么\n$$\nd=\\log_{3}(7),\\quad \\text{并且由于 }2>\\log_{3}(7),\\ f(n)=n^{2}=\\Omega\\!\\left(n^{\\log_{3}(7)+\\epsilon}\\right)\\ \\text{with}\\ \\epsilon=2-\\log_{3}(7)>0.\n$$\n检查正则性条件：\n$$\na\\,f(n/b)=7\\left(\\frac{n}{3}\\right)^{2}=\\frac{7}{9}\\,n^{2}\\leq c\\,n^{2}\\ \\text{with}\\ c=\\frac{7}{9}<1.\n$$\n因此，根据主定理，\n$$\nT_{B}(n)=\\Theta\\!\\left(n^{2}\\right).\n$$\n\n由于 $T_{A}(n)$ 和 $T_{B}(n)$ 都是 $\\Theta\\!\\left(n^{2}\\right)$，因此可得 $T_{A}(n)\\in\\Theta\\!\\left(T_{B}(n)\\right)$。因此，正确选项是 C，并且主定理适用于这两个递推关系。", "answer": "$$\\boxed{C}$$", "id": "1408675"}, {"introduction": "优化算法往往聚焦于其成本最高的部分，即“合并”步骤。本练习将带你深入探索合并成本的微小变化如何影响算法的整体性能，特别是当这些变化涉及对数因子时。你需要运用主定理的扩展情况，对四种不同的优化策略进行精细分析和排序，这有助于培养你对算法复杂度细微差异的洞察力。[@problem_id:1408691]", "problem": "一个计算机科学研究小组正在为高维数据分析设计一种新颖的递归算法。对于大小为 $n$ 的输入，该算法的时间复杂度 $T(n)$ 由一个分治递归关系描述。该递归关系的一般形式为 $T(n) = 9T(n/3) + f(n)$，其中 $n$ 是 3 的幂。$f(n)$ 项表示合并递归子问题结果的代价，该团队正在考虑四种不同的合并策略，分别标记为 A、B、C 和 D。每种策略对应不同的代价函数：\n\n- **策略 A：** 代价函数为 $f_A(n) = \\Theta(n^2 (\\log n)^{-1})$。\n- **策略 B：** 代价函数为 $f_B(n) = \\Theta(n^2)$。\n- **策略 C：** 代价函数为 $f_C(n) = \\Theta(n^2 \\log n)$。\n- **策略 D：** 代价函数为 $f_D(n) = \\Theta(n)$。\n\n您的任务是确定每种策略的渐进时间复杂度，然后根据它们在 $n$ 较大时的效率对这些策略进行排序。以下哪个选项正确地将策略按从最有效（时间复杂度增长最慢）到最无效（时间复杂度增长最快）的顺序列出？\n\nA. A, B, C, D\n\nB. D, C, B, A\n\nC. C, B, A, D\n\nD. D, A, B, C\n\nE. 主定理不适用于所有策略。", "solution": "我们分析以下分治递归关系\n$$\nT(n)=9\\,T\\!\\left(\\frac{n}{3}\\right)+f(n),\\quad \\text{with }n=3^{m}.\n$$\n这里 $a=9$，$b=3$，所以关键指数为\n$$\n\\log_{b}a=\\log_{3}9=2,\n$$\n因此 $n^{\\log_{b}a}=n^{2}$。在整个过程中，由于不同底数的对数之间仅相差常数因子，渐进因子中的对数可以视为自然对数；我们记作 $\\ln$。\n\n策略 D：$f_{D}(n)=\\Theta(n)$。由于 $n=\\mathcal{O}(n^{2-\\varepsilon})$ 且 $\\varepsilon=1$，适用主定理情况1，得到\n$$\nT_{D}(n)=\\Theta(n^{2}).\n$$\n\n策略 B：$f_{B}(n)=\\Theta(n^{2})=\\Theta\\!\\left(n^{2}(\\ln n)^{0}\\right)$。这符合主定理情况2，$k=0$，所以\n$$\nT_{B}(n)=\\Theta\\!\\left(n^{2}\\ln n\\right).\n$$\n\n策略 C：$f_{C}(n)=\\Theta\\!\\left(n^{2}\\ln n\\right)$ 符合主定理情况2，$k=1$，因此\n$$\nT_{C}(n)=\\Theta\\!\\left(n^{2}(\\ln n)^{2}\\right).\n$$\n\n策略 A：$f_{A}(n)=\\Theta\\!\\left(\\frac{n^{2}}{\\ln n}\\right)$ 比 $n^{2}$ 小一个对数因子，因此我们通过递归树求和进行分析。该树有 $L=\\log_{3}n$ 层。第 $i$ 层的总代价是\n$$\n\\text{cost}_{i}=9^{i}\\cdot \\Theta\\!\\left(\\frac{(n/3^{i})^{2}}{\\ln(n/3^{i})}\\right)\n=\\Theta\\!\\left(\\frac{n^{2}}{\\ln n - i\\ln 3}\\right).\n$$\n对 $i=0,1,\\dots,L-1$ 求和，\n$$\n\\sum_{i=0}^{L-1}\\text{cost}_{i}\n=\\Theta\\!\\left(n^{2}\\sum_{i=0}^{L-1}\\frac{1}{\\ln n - i\\ln 3}\\right).\n$$\n令 $j=L-i$，注意到 $L=\\frac{\\ln n}{\\ln 3}$，则 $\\ln n - i\\ln 3=j\\ln 3$，所以\n$$\n\\sum_{i=0}^{L-1}\\text{cost}_{i}\n=\\Theta\\!\\left(\\frac{n^{2}}{\\ln 3}\\sum_{j=1}^{L}\\frac{1}{j}\\right)\n=\\Theta\\!\\left(n^{2}\\,\\ln L\\right)\n=\\Theta\\!\\left(n^{2}\\,\\ln\\!\\ln n\\right).\n$$\n叶子节点的贡献为 $\\Theta(n^{2})$，其被 $\\Theta(n^{2}\\ln\\!\\ln n)$ 所主导。因此，\n$$\nT_{A}(n)=\\Theta\\!\\left(n^{2}\\ln\\!\\ln n\\right).\n$$\n\n对于较大的 $n$，从最有效（增长最慢）到最无效（增长最快）的排序如下：\n$$\n\\Theta(n^{2})\\ (\\text{D})\\;\\prec\\;\\Theta\\!\\left(n^{2}\\ln\\!\\ln n\\right)\\ (\\text{A})\\;\\prec\\;\\Theta\\!\\left(n^{2}\\ln n\\right)\\ (\\text{B})\\;\\prec\\;\\Theta\\!\\left(n^{2}(\\ln n)^{2}\\right)\\ (\\text{C}).\n$$\n因此，正确的顺序是 D、A、B、C。", "answer": "$$\\boxed{D}$$", "id": "1408691"}, {"introduction": "现代软件系统常常由相互调用的复杂模块构成。这个练习模拟了一个常见且更具挑战性的情况：一个分治算法的“合并”成本本身由另一个分治算法决定。解决这个问题需要你进行两步分析，首先确定子程序的复杂度，然后将其代入主算法的递推关系中。这个过程将锻炼你处理嵌套递推关系和分析分层算法的能力。[@problem_id:1408677]", "problem": "一位算法设计师正在开发一种新的计算方法，称为分层数据融合（HDF）算法，用于处理大规模结构化数据。对于大小为 $n$ 的输入，HDF 算法的操作如下：它将数据分成两个大小为 $n/2$ 的子问题，对每个子问题递归地调用自身，然后合并结果。\n\n合并步骤是计算密集型的，并由一个独立的子程序——互相关对齐器（CCA）处理。对于大小为 $n$ 的输入，CCA 的运行时间（表示为 $C(n)$）本身遵循分治策略。CCA 算法将其任务分解为三个大小为 $n/3$ 的子问题，递归地解决它们，然后在与输入大小 $n$ 呈线性的时间内合并结果。\n\n设 $T(n)$ 为 HDF 算法在大小为 $n$ 的输入上的总运行时间，设 $C(n)$ 为 CCA 子程序的运行时间，该子程序构成了 HDF 的合并成本。对于 $n > 1$ 的情况，运行时间由以下递推关系描述，假设 $T(1)$ 和 $C(1)$ 为常数。\n\nHDF 的递推关系是：\n$T(n) = 2T(n/2) + C(n)$\n\nCCA 的递推关系是：\n$C(n) = 3C(n/3) + f(n)$，其中 $f(n) = \\Theta(n)$。\n\n确定 HDF 算法运行时间 $T(n)$ 的最紧渐近界。请从以下选项中选择。\n\nA. $\\Theta(n^2)$\n\nB. $\\Theta(n \\log \\log n)$\n\nC. $\\Theta(n (\\log n)^2)$\n\nD. $\\Theta(n \\log n)$\n\nE. $\\Theta(n^{\\log_2 3})$", "solution": "我们已知两个递推关系。对于 $n>1$，\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+C(n),\\qquad C(n)=3\\,C\\!\\left(\\frac{n}{3}\\right)+f(n),\\quad f(n)=\\Theta(n),\n$$\n其中 $T(1)$ 和 $C(1)$ 是常数。我们首先求解 $C(n)$，然后将其代入 $T(n)$。\n\n为求解 $C(n)$，我们应用主定理，其中 $a=3$，$b=3$ 且 $f(n)=\\Theta(n)$。我们计算\n$$\nn^{\\log_{3}3}=n.\n$$\n因此 $f(n)=\\Theta\\!\\big(n^{\\log_{3}3}\\big)$，这符合主定理的第二种情况。因此，\n$$\nC(n)=\\Theta\\!\\big(n\\log_{3}n\\big).\n$$\n由于不同底数的对数之间仅相差一个常数因子，即 $\\log_{3}n=\\frac{\\log_{2}n}{\\log_{2}3}$，我们可以等价地写作\n$$\nC(n)=\\Theta\\!\\big(n\\log_{2}n\\big).\n$$\n\n现在将此结果代入 $T(n)$ 的递推关系中：\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+\\Theta\\!\\big(n\\log_{2}n\\big).\n$$\n这里 $a=2$，$b=2$，所以 $n^{\\log_{2}2}=n$。附加项满足\n$$\nf(n)=\\Theta\\!\\big(n\\log_{2}n\\big)=\\Theta\\!\\big(n^{\\log_{2}2}\\,(\\log_{2}n)^{1}\\big).\n$$\n这符合扩展主定理中 $f(n)=\\Theta\\!\\big(n^{\\log_{b}a}(\\log n)^{k}\\big)$ 且 $k=1$ 的情况。因此，\n$$\nT(n)=\\Theta\\!\\big(n^{\\log_{2}2}(\\log_{2}n)^{k+1}\\big)=\\Theta\\!\\big(n(\\log_{2}n)^{2}\\big).\n$$\n\n为了完整性，递归树求和法也得出同样的结果。在 $T$ 递推的第 $i$ 层（$0\\le i\\le \\log_{2}n-1$），有 $2^{i}$ 个节点，每个节点的大小为 $n/2^{i}$，每个节点贡献的合并成本为 $C(n/2^{i})=\\Theta\\!\\big(\\frac{n}{2^{i}}\\log_{2}\\frac{n}{2^{i}}\\big)$。第 $i$ 层的总合并成本是\n$$\n2^{i}\\cdot \\Theta\\!\\left(\\frac{n}{2^{i}}\\log_{2}\\frac{n}{2^{i}}\\right)=\\Theta\\!\\big(n(\\log_{2}n-i)\\big).\n$$\n对所有层求和，设 $L=\\log_{2}n$，\n$$\n\\sum_{i=0}^{L-1}\\Theta\\!\\big(n(\\log_{2}n-i)\\big)\n=\\Theta\\!\\left(n\\sum_{i=0}^{L-1}(L-i)\\right)\n=\\Theta\\!\\left(n\\cdot \\frac{L(L+1)}{2}\\right)\n=\\Theta\\!\\big(n(\\log_{2}n)^{2}\\big).\n$$\n叶子节点的贡献为 $\\Theta(n)$，它在渐近意义上被 $\\Theta\\!\\big(n(\\log_{2}n)^{2}\\big)$ 主导。因此，\n$$\nT(n)=\\Theta\\!\\big(n(\\log_{2}n)^{2}\\big)=\\Theta\\!\\big(n(\\log n)^{2}\\big).\n$$\n\n在给出的选项中，这与选项 C 相匹配。", "answer": "$$\\boxed{C}$$", "id": "1408677"}]}