{"hands_on_practices": [{"introduction": "我们从一个基础练习开始，旨在将一个直接的算法描述转化为其渐进时间复杂度。这个实践的核心在于识别算法中的主导操作，并理解为何在渐进分析中，即使是很大的常数因子也会被忽略。这是一个基本但至关重要的技能，可以帮助你分析在实际代码中遇到的简单循环结构的时间效率 [@problem_id:1349082]。", "problem": "一位工程师正在为一个社交媒体平台开发一个系统，以验证其用户帐户的完整性。他们设计了一种名为 `verifyAllAccounts` 的算法，该算法接收一个包含 $n$ 个用户个人资料的列表作为输入。该算法会逐一遍历这 $n$ 个个人资料。对于每个个人资料，它会调用一个名为 `runComplianceScan` 的子程序。这个 `runComplianceScan` 子程序被设计用来执行一组固定且恒定的1000次原始计算操作（例如数据字段比较和哈希检查），以确保帐户符合平台的服务条款。无论个人资料中的具体数据或用户总数 $n$ 如何，`runComplianceScan` 执行的操作次数始终为1000次。\n\n假设访问列表中的每个个人资料花费的时间是恒定的，那么整个 `verifyAllAccounts` 算法的渐近时间复杂度（大O表示法）是什么？（以用户数 $n$ 作为函数）\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n^2)$\n\nE. $O(1000^n)$\n\nF. $O(1)$", "solution": "要确定 `verifyAllAccounts` 算法的时间复杂度，我们需要分析其作为输入大小 $n$ 的函数所执行的原始操作的总数。设 $T(n)$ 代表这个操作总数。\n\n该算法包含一个主循环，遍历 $n$ 个用户个人资料中的每一个。这个结构可以建模为一个从 $i=1$ 到 $n$ 运行的 `for` 循环。\n\n对于主循环的每次迭代（即，对于每个用户个人资料），算法都会调用 `runComplianceScan` 子程序。题目说明 `runComplianceScan` 执行恒定数量的操作，具体为1000次。\n\n所以，在第一次迭代中（为第一个用户），执行1000次操作。\n在第二次迭代中（为第二个用户），再执行1000次操作。\n这个过程对所有 $n$ 个用户都会继续。\n\n为了求出总操作数 $T(n)$，我们将主循环的 $n$ 次迭代中每次执行的操作数相加。由于每次迭代都恰好贡献了1000次操作，总数为：\n$$T(n) = \\sum_{i=1}^{n} 1000$$\n这等价于将1000自身相加 $n$ 次：\n$$T(n) = 1000 + 1000 + \\dots + 1000 \\quad (n \\text{ times})$$\n$$T(n) = 1000 \\cdot n$$\n\n现在，我们必须求出 $T(n)$ 的大O复杂度。根据大O表示法的定义，如果存在正常数 $c$ 和 $n_0$，使得对于所有 $n \\ge n_0$，都有 $0 \\le T(n) \\le c \\cdot g(n)$ 成立，则函数 $T(n)$ 属于 $O(g(n))$。\n\n在我们的例子中，$T(n) = 1000n$。我们正在寻找能够界定 $T(n)$ 的最简单的函数 $g(n)$。我们来测试函数 $g(n) = n$。\n我们需要检查是否存在某个常数 $c$ 使得对于所有 $n \\ge n_0$，$1000n \\le c \\cdot n$ 都成立。\n如果我们选择常数 $c = 1000$，则不等式变为 $1000n \\le 1000n$。这对所有 $n \\ge 1$ 都成立。所以，我们可以取 $c=1000$ 和 $n_0=1$。\n既然我们找到了这样的常数，我们可以得出结论：$T(n)$ 属于 $O(n)$。\n\n在大O分析中，常数因子被忽略，因为我们关心的是当 $n$ 变得非常大时函数的增长率。函数 $1000n$ 随 $n$ 线性增长，就像函数 $n$ 一样。因此，渐近时间复杂度是 $O(n)$。\n\n将我们的结果与给定选项进行比较：\nA. $O(\\log n)$: 不正确。对数增长远慢于线性增长。\nB. $O(n)$: 正确。运行时间随用户数量线性增长。\nC. $O(n \\log n)$: 不正确。这是超线性增长，常见于高效的排序算法。\nD. $O(n^2)$: 不正确。这是二次增长，典型情况是嵌套循环，其中内层循环的迭代次数也依赖于 $n$。\nE. $O(1000^n)$: 不正确。这是指数级增长，远大于实际的线性增长。\nF. $O(1)$: 不正确。恒定时间复杂度意味着运行时间与 $n$ 无关。\n\n因此，正确的时间复杂度是 $O(n)$。", "answer": "$$\\boxed{B}$$", "id": "1349082"}, {"introduction": "许多高效的算法，特别是在分治策略中，其运行时间由递归关系式定义。这个练习将引导你分析一个非标准的递归关系式 $T(n) = 2T(\\sqrt{n}) + \\log_{2}n$。解决这个问题的关键在于掌握一种强大的数学技巧——变量替换，它能将一个看似复杂的问题转化为我们熟悉的形式，这充分展示了算法分析中创造性思维的重要性 [@problem_id:1349048]。", "problem": "一种称为“分层聚合变换”（Hierarchical Aggregation Transform, HAT）的实验性数据处理算法，旨在分析大规模高维数据集。HAT 算法作用于一个大小为 $n$ 的数据集。在每一步中，它会执行一系列比较和合并操作，所需时间与数据集大小的以 2 为底的对数成正比。此步骤之后，它会对两个独立的、经过变换的子问题进行递归调用，其中每个子问题的有效大小是原始数据集大小的平方根。对于一个大小为 $n$ 的数据集，HAT 算法的运行时间 $T(n)$ 可以用以下递推关系式来建模：\n\n$$T(n) = 2T(\\sqrt{n}) + \\log_{2}n$$\n\n假设对于小输入（$n \\le 4$），运行时间 $T(n)$ 是一个常数。请确定该算法运行时间 $T(n)$ 的最紧渐近上下界（$\\Theta$ 记号）。\n\n从以下选项中选择正确的渐近界。\n\nA. $\\Theta(\\log_{2}n)$\n\nB. $\\Theta((\\log_{2}n)^2)$\n\nC. $\\Theta(\\sqrt{n})$\n\nD. $\\Theta(\\log_{2}n \\cdot \\log_{2}(\\log_{2}n))$\n\nE. $\\Theta(n)$", "solution": "给定递推关系式\n$$T(n)=2T(\\sqrt{n})+\\log_{2}n,$$\n且当 $n \\leq 4$ 时，基本情况为 $T(n)$ 是 $\\Theta(1)$。\n\n引入变量替换 $n=2^{m}$，则 $m=\\log_{2}n$，并定义 $S(m)=T(2^{m})$。那么 $\\sqrt{n}=2^{m/2}$，所以递推关系式变为\n$$S(m)=2S\\left(\\frac{m}{2}\\right)+m,$$\n其中当 $m \\leq 2$ 时，$S(m)=\\Theta(1)$。\n\n这是一个标准的分治递推式，其形式为 $S(m)=aS(m/b)+f(m)$，其中 $a=2$，$b=2$，$f(m)=m$。我们有 $m^{\\log_{b}a}=m^{\\log_{2}2}=m$。因此 $f(m)=\\Theta\\!\\left(m^{\\log_{2}2}\\right)$，这符合主定理的第二种情况，得出\n$$S(m)=\\Theta\\!\\left(m\\log m\\right).$$\n为了明确对数的底，可以将其写作 $S(m)=\\Theta\\!\\left(m\\log_{2}m\\right)$，因为改变对数的底只会影响常数因子。\n\n另外，使用递归树法分析：在第 $i$ 层，有 $2^{i}$ 个大小为 $m/2^{i}$ 的子问题，每个子问题产生的非递归成本为 $m/2^{i}$，所以每层的总成本是 $2^{i}\\cdot(m/2^{i})=m$。树的深度是满足 $m/2^{d}\\leq 2$ 的最小 $d$，即 $d=\\Theta(\\log_{2}m)$，所以所有非叶节点的成本总和为 $\\Theta(m\\log_{2}m)$。叶节点的数量为 $2^{d}=\\Theta(m)$，每个叶节点的成本为 $\\Theta(1)$，因此叶节点的总成本为 $\\Theta(m)$，总时间复杂度仍然是 $\\Theta(m\\log_{2}m)$。\n\n使用 $m=\\log_{2}n$ 将变量换回 $n$，我们得到\n$$T(n)=S(\\log_{2}n)=\\Theta\\!\\left(\\log_{2}n\\cdot\\log_{2}\\!\\bigl(\\log_{2}n\\bigr)\\right).$$\n在所提供的选项中，这与选项 D 相符。", "answer": "$$\\boxed{D}$$", "id": "1349048"}, {"introduction": "在掌握了分析具体算法的技巧之后，我们必须深入理解渐进符号本身的数学性质。这个练习是一个概念性的挑战，它探讨了当函数以指数形式增长时，如 $2^{f(n)}$，渐进关系是否依然成立。通过证明或证伪这些陈述，你将锻炼严谨的、基于定义的推理能力，并加深对不同渐进符号（$O$、$o$、$\\Theta$、$\\omega$）之间微妙差异的理解 [@problem_id:1349043]。", "problem": "在算法分析中，我们经常比较描述计算资源使用（如时间或内存）的函数的增长率。标准的渐进符号（$O, \\Theta, \\Omega, o, \\omega$）对此至关重要。设 $f(n)$ 和 $g(n)$ 是将正整数映射到正实数的函数。给定 $f(n)$ 和 $g(n)$ 对于所有整数 $n \\ge 1$ 都是严格为正且单调递增的。\n\n考虑 $f(n)$ 和 $g(n)$ 的渐进增长与 $2^{f(n)}$ 和 $2^{g(n)}$ 的相应增长之间的关系。例如，当一个算法的复杂度形式为 $2^{T(n)}$，并且我们将其与一个已知的复杂度类进行比较时，就可能出现这种情况。\n\n下面提出了关于这些关系的四个陈述。渐进符号使用当 $n \\to \\infty$ 时的极限来定义：\n- 如果 $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0$，则 $f(n) \\in o(g(n))$。\n- 如果 $\\limsup_{n \\to \\infty} \\frac{|f(n)|}{|g(n)|} < \\infty$，则 $f(n) \\in O(g(n))$。\n- 如果 $f(n) \\in O(g(n))$ 且 $g(n) \\in O(f(n))$，则 $f(n) \\in \\Theta(g(n))$。\n- 如果 $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\infty$，则 $f(n) \\in \\omega(g(n))$。\n\n假设 $f(n)$ 和 $g(n)$ 始终是严格为正且单调递增的函数，以下哪个陈述必然为真？\n\nA. 如果 $f(n) \\in o(g(n))$，那么 $2^{f(n)} \\in o(2^{g(n)})$。\n\nB. 如果 $f(n) \\in O(g(n))$，那么 $2^{f(n)} \\in O(2^{g(n)})$。\n\nC. 如果 $f(n) \\in \\Theta(g(n))$，那么 $2^{f(n)} \\in \\Theta(2^{g(n)})$。\n\nD. 如果 $f(n) \\in \\omega(g(n))$，那么 $2^{f(n)} \\in \\omega(2^{g(n)})$。\n\n你的任务是找出所提供选项中所有为真的陈述。", "solution": "我们给定在正整数上严格为正、单调递增的函数 $f(n)$ 和 $g(n)$，并使用基于极限的定义来分析每个论断。\n\nA. 假设 $f(n) \\in o(g(n))$，即 $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)}=0$。首先，我们证明 $g(n) \\to \\infty$。如果 $g(n)$ 有上界，由于它是单调递增且严格为正的，它将收敛到某个 $L>0$，这将迫使 $f(n)=\\frac{f(n)}{g(n)}g(n) \\to 0$。这是不可能的，因为 $f$ 是严格为正且单调递增的，所以它的极限至少是 $f(1)>0$。因此 $g(n) \\to \\infty$。根据 $\\frac{f(n)}{g(n)} \\to 0$，存在一个 $N$，使得对于所有 $n \\geq N$，有 $f(n) \\leq \\frac{1}{2}g(n)$，所以 $g(n)-f(n) \\geq \\frac{1}{2}g(n) \\to \\infty$。那么\n$$\n\\frac{2^{f(n)}}{2^{g(n)}}=2^{f(n)-g(n)}=2^{-(g(n)-f(n))} \\leq 2^{-g(n)/2} \\to 0.\n$$\n因此 $\\lim_{n \\to \\infty} \\frac{2^{f(n)}}{2^{g(n)}}=0$，即 $2^{f(n)} \\in o(2^{g(n)})$。陈述 A 为真。\n\nB. 考虑 $f(n)=2n$ 和 $g(n)=n$。两者都是严格为正且单调递增的。我们有 $f(n) \\in O(g(n))$ 因为 $\\limsup_{n \\to \\infty} \\frac{f(n)}{g(n)}=2<\\infty$。然而，\n$$\n\\frac{2^{f(n)}}{2^{g(n)}}=\\frac{2^{2n}}{2^{n}}=2^{n} \\to \\infty,\n$$\n所以 $2^{f(n)} \\notin O(2^{g(n)})$。因此 B 为假。\n\nC. 使用相同的例子 $f(n)=2n$ 和 $g(n)=n$，我们有 $f(n) \\in \\Theta(g(n))$，因为 $f(n) \\in O(g(n))$ 和 $g(n) \\in O(f(n))$ 都成立。但如上计算，$\\frac{2^{f(n)}}{2^{g(n)}}=2^{n} \\to \\infty$，所以 $2^{f(n)} \\notin O(2^{g(n)})$，因此 $2^{f(n)} \\notin \\Theta(2^{g(n)})$。因此 C 为假。\n\nD. 假设 $f(n) \\in \\omega(g(n))$，即 $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)}=\\infty$。我们证明 $f(n)-g(n) \\to \\infty$。固定任意 $K>0$ 并定义 $C=\\frac{K}{g(1)}+1$。由于 $\\frac{f(n)}{g(n)} \\to \\infty$，存在一个 $N$，使得对于所有 $n \\geq N$，有 $\\frac{f(n)}{g(n)} \\geq C$，即 $f(n) \\geq C g(n)$。那么对于 $n \\geq N$，\n$$\nf(n)-g(n) \\geq (C-1)g(n) \\geq (C-1)g(1)=K.\n$$\n因为 $K$ 是任意的，这意味着 $f(n)-g(n) \\to \\infty$。因此，\n$$\n\\frac{2^{f(n)}}{2^{g(n)}}=2^{f(n)-g(n)} \\to \\infty,\n$$\n这恰好是 $2^{f(n)} \\in \\omega(2^{g(n)})$。陈述 D 为真。\n\n综合结果：A 和 D 为真；B 和 C 为假。", "answer": "$$\\boxed{AD}$$", "id": "1349043"}]}