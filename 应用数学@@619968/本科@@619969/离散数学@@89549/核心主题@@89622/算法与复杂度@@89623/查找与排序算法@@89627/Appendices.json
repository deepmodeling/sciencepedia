{"hands_on_practices": [{"introduction": "精通算法不仅意味着能背诵其步骤，更重要的是能够追踪其执行过程并诊断潜在问题。本练习将带你追踪一个有缺陷的二分查找算法的执行，通过亲手计算每一步的状态，你将深入理解算法的内部机制。这个过程有助于培养调试和分析算法行为的关键技能，并凸显了更新搜索边界时精确性的重要性。[@problem_id:1398583]", "problem": "一位程序员正在实现一个二分查找程序，用于在一个已排序的、从0开始索引的数组 `A` 中查找目标值 `T`。然而，该实现包含一个不易察觉的错误。\n\n该算法定义如下：\n1. 初始化搜索边界：`low = 0` 和 `high = n-1`，其中 `n` 是数组中元素的数量。\n2. 当 `low <= high` 时，执行以下步骤：\n   a. 计算中间索引：`mid = floor((low + high) / 2)`。\n   b. 将目标值 `T` 与元素 `A[mid]` 进行比较。\n   c. 如果 `T == A[mid]`，搜索成功终止。\n   d. 如果 `T < A[mid]`，上边界被正确更新为：`high = mid - 1`。\n   e. 如果 `T > A[mid]`，由于一个错误，下边界被错误地更新为：`low = mid`。（正确的实现应使用 `low = mid + 1`）。\n\n你的任务是，在已排序数组 `A = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]` 上搜索目标值 `T = 25` 时，追踪这个有错误的算法的执行过程。\n\n计算在此次搜索执行过程中，与目标值 `T` 进行比较的前三个数组元素的和。", "solution": "我们有一个已排序的、从0开始索引的数组 $A = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]$，其中 $n = 10$，目标值为 $T = 25$。该算法初始化 $low = 0$ 和 $high = n - 1 = 9$，并在每次迭代中计算 $mid = \\left\\lfloor \\frac{low + high}{2} \\right\\rfloor$。由于那个错误，当 $T > A[mid]$ 时，它将 $low$ 更新为 $low \\leftarrow mid$ 而不是 $low \\leftarrow mid + 1$。\n\n迭代 1:\n- 初始边界: $low = 0$, $high = 9$。\n- 中间索引: $mid_{1} = \\left\\lfloor \\frac{0 + 9}{2} \\right\\rfloor = \\left\\lfloor \\frac{9}{2} \\right\\rfloor = 4$。\n- 比较的元素: $A[mid_{1}] = A[4] = 16$。\n- 比较: $T = 25 > 16 = A[4]$。\n- 错误的更新: $low \\leftarrow mid = 4$；$high$ 保持为 $9$。\n\n迭代 2:\n- 边界: $low = 4$, $high = 9$。\n- 中间索引: $mid_{2} = \\left\\lfloor \\frac{4 + 9}{2} \\right\\rfloor = \\left\\lfloor \\frac{13}{2} \\right\\rfloor = 6$。\n- 比较的元素: $A[mid_{2}] = A[6] = 38$。\n- 比较: $T = 25 < 38 = A[6]$。\n- 正确的上边界更新: $high \\leftarrow mid - 1 = 5$；$low$ 保持为 $4$。\n\n迭代 3:\n- 边界: $low = 4$, $high = 5$。\n- 中间索引: $mid_{3} = \\left\\lfloor \\frac{4 + 5}{2} \\right\\rfloor = \\left\\lfloor \\frac{9}{2} \\right\\rfloor = 4$。\n- 比较的元素: $A[mid_{3}] = A[4] = 16$。\n- 比较: $T = 25 > 16 = A[4]$。\n- 错误的更新: $low \\leftarrow mid = 4$（这将导致搜索陷入死循环，但题目只要求前三次比较）。\n\n前三个被比较的元素是 $16$、$38$ 和 $16$。因此，所要求的和是\n$$S = 16 + 38 + 16 = 70.$$", "answer": "$$\\boxed{70}$$", "id": "1398583"}, {"introduction": "快速排序是最高效的排序算法之一，而其核心操作是“分区”（partition）步骤。这个练习将该关键步骤独立出来，让你亲手执行一次分区过程，将列表中的元素围绕一个“基准”（pivot）值重新排列。掌握分区不仅是理解快速排序的关键，也为解决许多其他需要数据划分的问题奠定了基础。[@problem_id:1398611]", "problem": "在一个分布式计算环境中，负载均衡器需要根据传入任务分配的优先级值来快速重排任务列表。目标是执行一次分区操作，以一个选定的基准任务为准，将优先级较低的任务排在优先级较高的任务前面。这有助于更高效地分配任务。\n\n给定五个任务的优先级值列表：$[7, 2, 9, 1, 5]$。\n\n要使用的分区算法如下：\n1. 选择列表中的最后一个元素作为基准值。\n2. 将边界索引 `i` 初始化为列表第一个元素之前的一个位置。\n3. 第二个索引 `j` 从列表的第一个元素开始遍历，直到但不包括基准元素。\n4. 在遍历过程中，如果索引 `j` 处的元素小于或等于基准值，则先将边界索引 `i` 加一，然后将索引 `i` 处的元素与索引 `j` 处的元素交换。\n5. 遍历完成后，将基准元素与索引 `i+1` 处的元素交换。\n\n在完成这一次分区过程后，以下哪个列表表示任务列表的状态？\n\nA. $[2, 1, 5, 7, 9]$\n\nB. $[1, 2, 5, 7, 9]$\n\nC. $[2, 1, 9, 7, 5]$\n\nD. $[5, 2, 7, 1, 9]$\n\nE. $[2, 1, 7, 5, 9]$", "solution": "我们将所述的 Lomuto 式分区应用于列表 $A = [7,2,9,1,5]$，并使用最后一个元素作为基准。\n\n设置基准 $p = A[4] = 5$ 并初始化边界索引 $i = -1$。从 $0$ 到 $3$ 遍历 $j$，并在 $A[j] \\leq p$ 时执行条件交换。\n\n当 $j=0$ 时：$A[0] = 7$。因为 $7 \\leq 5$ 为假，所以不执行任何操作；$i=-1$，$A=[7,2,9,1,5]$。\n\n当 $j=1$ 时：$A[1] = 2$。因为 $2 \\leq 5$ 为真，所以将 $i$ 增加到 $0$ 并交换 $A[0]$ 和 $A[1]$，得到 $A=[2,7,9,1,5]$。\n\n当 $j=2$ 时：$A[2] = 9$。因为 $9 \\leq 5$ 为假，所以不执行任何操作；$i=0$，$A=[2,7,9,1,5]$。\n\n当 $j=3$ 时：$A[3] = 1$。因为 $1 \\leq 5$ 为真，所以将 $i$ 增加到 $1$ 并交换 $A[1]$ 和 $A[3]$，得到 $A=[2,1,9,7,5]$。\n\n循环结束后，将基准与 $A[i+1]$ 交换，即交换 $A[2]$ 和 $A[4]$，结果为 $A=[2,1,5,7,9]$。\n\n因此，经过一次分区操作后，列表的状态为 $[2,1,5,7,9]$，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1398611"}, {"introduction": "在现实世界的系统设计中，我们常常需要在不同的算法策略之间做出权衡。这个练习模拟了一个经典场景：我们应该对每次查询都进行线性搜索，还是先花时间排序数据，再利用更快的二分搜索？通过计算这个“盈亏平衡点”，你将学会如何用量化分析来证明某个算法策略在特定条件下的优越性，这是从理论走向实践的关键一步。[@problem_id:1398631]", "problem": "一个数据处理系统必须在一个包含 $n$ 个唯一项的静态数据集（存储为数组）上执行 $k$ 次独立的搜索查询。为处理这些查询，现有两种策略可供考虑。每种策略的效率由其总计算时间衡量，该时间取决于两种基本操作的数量：键值比较和数据移动。单次键值比较所需的时间为 $T_c$，单次数据移动所需的时间为 $T_m$。您可以假设 $n \\ge 3$。\n\n**策略1：重复线性搜索**\n对于 $k$ 次查询中的每一次，都在原始未排序的数组上执行一次线性搜索。在最坏情况下，单次线性搜索需要 $n$ 次键值比较。\n\n**策略2：先排序后搜索**\n首先，使用一种基于比较的排序算法的特定实现对数组进行一次排序。在最坏情况下，该算法执行恰好 $A \\cdot n \\log_2(n)$ 次键值比较和 $B \\cdot n \\log_2(n)$ 次数据移动，其中 $A$ 和 $B$ 是该算法的特征常数。排序后，对 $k$ 次查询中的每一次执行一次二分搜索。在最坏情况下，对大小为 $n$ 的已排序数组进行一次二分搜索需要 $\\lfloor \\log_2(n) \\rfloor + 1$ 次键值比较。在搜索阶段，数据移动不是一个影响因素。\n\n确定使策略2的总最坏情况时间成本严格小于策略1的总最坏情况时间成本的最小整数值 $k$。您的答案应该是一个以 $n, T_c, T_m, A$ 和 $B$ 表示的公式。", "solution": "令 $L=\\lfloor \\log_{2}(n) \\rfloor + 1$ 表示对大小为 $n$ 的数组进行二分搜索时最坏情况下的键值比较次数。\n\n策略1（重复线性搜索）的最坏情况总时间：\n每次查询的成本为 $n$ 次比较，因此\n$$\nT_{1}=k \\cdot n \\cdot T_{c}.\n$$\n\n策略2（先排序后搜索）的最坏情况总时间：\n排序的成本为 $A \\cdot n \\log_{2}(n)$ 次比较和 $B \\cdot n \\log_{2}(n)$ 次移动，其时间为\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right).\n$$\n$k$ 次二分搜索中的每一次成本为 $L$ 次比较，因此搜索阶段的成本为\n$$\nk \\cdot L \\cdot T_{c}.\n$$\n因此，\n$$\nT_{2}=n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}.\n$$\n\n我们要求 $T_{2}<T_{1}$：\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}<k n T_{c}.\n$$\n整理得，\n$$\nk T_{c}(n-L)>n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right).\n$$\n对于 $n \\ge 3$，我们有 $n-L>0$ 且 $T_{c}>0$，所以两边相除得到\n$$\nk>\\frac{n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)}{T_{c}(n-L)}\n=\\frac{n \\log_{2}(n)}{n-L}\\left(A+B \\frac{T_{m}}{T_{c}}\\right).\n$$\n因此，满足此严格不等式的最小整数 $k$ 是\n$$\nk_{\\min}=\\left\\lfloor \\frac{n \\log_{2}(n)}{n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1.\n$$", "answer": "$$\\boxed{\\left\\lfloor \\frac{n \\log_{2}(n)}{\\,n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)\\,}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1}$$", "id": "1398631"}]}