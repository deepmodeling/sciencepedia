{"hands_on_practices": [{"introduction": "深入理解任何算法的第一步都是亲手模拟其执行过程。这个练习将带你逐步完成一个完整的广度优先搜索（BFS）[@problem_id:1485198]。通过在一个由邻接矩阵 $A$ 表示的图上进行遍历，你将练习使用队列这一核心数据结构，并学习如何按照“先入先出”的原则，逐层探索图的节点，从而牢固掌握BFS的基本工作流程。", "problem": "在一个小规模的隔离数据中心，一个由8台服务器（标记为1至8）组成的网络相互连接。该网络拓扑是双向的，并由一个 $8 \\times 8$ 的邻接矩阵 $A$ 表示，其中如果服务器 $i$ 和服务器 $j$ 之间有直接链接，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。矩阵 $A$ 如下所示：\n$$\nA = \\begin{pmatrix}\n0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\n\\end{pmatrix}\n$$\n为了将一个关键更新从源服务器分发到网络中的所有其他服务器，启动了一个广播协议。该协议使用广度优先搜索（BFS）算法来确定服务器被访问的顺序。遍历从服务器 3 开始。当探索一个服务器的邻居时，如果发现多个未访问过的邻居，它们将按照其服务器标签的升序被添加到访问队列中（例如，服务器 2 会在服务器 4 之前入队）。\n\n确定在 BFS 遍历过程中，服务器标签按其首次被发现（即标记为“已访问”）的顺序所组成的序列。", "solution": "将对称邻接矩阵 $A$ 所代表的图解释为一个无向图。从矩阵的行中读取的邻居集合如下：\n$$\nN(1)=\\{2,3,4\\},\\quad N(2)=\\{1\\},\\quad N(3)=\\{1,5,6\\},\\quad N(4)=\\{1\\},\n$$\n$$\nN(5)=\\{3,8\\},\\quad N(6)=\\{3,7\\},\\quad N(7)=\\{6\\},\\quad N(8)=\\{5\\}.\n$$\n从服务器 3 开始使用 BFS。原则：将起始节点入队并标记为已访问；然后迭代地将一个节点出队，按升序扫描其邻居，并在发现任何未访问的邻居时立即将其入队（同时标记为已访问）。发现顺序就是节点首次入队的顺序。\n\n初始化：队列 $Q$ 为 `[]`，已访问序列为空。将 3 入队并标记为已访问。到目前为止的发现顺序：$3$；队列 $Q$ 为 `[3]`。\n\n将 3 出队。其升序排列的邻居是 $1,5,6$。它们都未被访问，因此按此顺序将它们入队，并在入队时标记为已访问。发现顺序：$3,1,5,6$；队列 $Q$ 为 `[1,5,6]`。\n\n将 1 出队。其升序排列的邻居是 $2,3,4$。其中，3 已被访问；将 2 然后是 4 入队。发现顺序：$3,1,5,6,2,4$；队列 $Q$ 为 `[5,6,2,4]`。\n\n将 5 出队。其邻居是 $3,8$。节点 3 已被访问；将 8 入队。发现顺序：$3,1,5,6,2,4,8$；队列 $Q$ 为 `[6,2,4,8]`。\n\n将 6 出队。其邻居是 $3,7$。节点 3 已被访问；将 7 入队。发现顺序：$3,1,5,6,2,4,8,7$；队列 $Q$ 为 `[2,4,8,7]`。\n\n将 2 出队。邻居 1 已被访问；无变化。队列 $Q$ 为 `[4,8,7]`。\n\n将 4 出队。邻居 1 已被访问；无变化。队列 $Q$ 为 `[8,7]`。\n\n将 8 出队。邻居 5 已被访问；无变化。队列 $Q$ 为 `[7]`。\n\n将 7 出队。邻居 6 已被访问；无变化。队列为空；BFS 完成。\n\n因此，首次发现的顺序是 $3,1,5,6,2,4,8,7$。", "answer": "$$\\boxed{\\begin{pmatrix}3 & 1 & 5 & 6 & 2 & 4 & 8 & 7\\end{pmatrix}}$$", "id": "1485198"}, {"introduction": "广度优先搜索最著名的应用之一，是在无权图中寻找两个节点之间的最短路径。本练习 [@problem_id:1354134] 模拟了一个网络路由场景，你的任务不仅仅是找到一条最短路径，而是在存在多条最短路径时，根据字母顺序选择“字典序”最小的那一条。这个挑战将深化你对BFS如何保证路径最短的理解，并让你体会到在实际问题中，明确的规则对于获得唯一解是多么重要。", "problem": "在一个小型实验性计算机网络中，数据包在节点之间进行路由。网络拓扑可以建模为一个无权无向图，其中节点是路由器，用大写字母标识，两个节点之间的边表示一条直接的双向通信链路。所有链路都具有统一的成本，因此“最佳”路径是“跳数”最少的路径（即最短路径）。\n\n该网络由路由器集合 $V = \\{\\text{A, B, C, D, E, G}\\}$ 组成。直接通信链路由边集 $E = \\{\\{\\text{A, B}\\}, \\{\\text{A, C}\\}, \\{\\text{B, D}\\}, \\{\\text{C, E}\\}, \\{\\text{D, E}\\}, \\{\\text{D, G}\\}, \\{\\text{E, G}\\}\\}$ 给出。\n\n当源和目标之间存在多条最短路径时，路由协议采用一种打破平局的规则：选择字典序最靠前的路径。一条路径表示为路由器标签的序列，如 $P_1 = v_1-v_2-\\dots-v_k$，如果它在第一个不同的位置 $i$ 上的路由器 $v_i$ 在字母表顺序上先于另一条路径 $P_2 = u_1-u_2-\\dots-u_k$ 的路由器 $u_i$，则称路径 $P_1$ 的字典序小于 $P_2$。\n\n确定一个数据包从路由器 `A` 传输到路由器 `G` 的字典序最靠前的最短路径。\n\n下列哪一个表示这条路径？\n\nA. A-B-D-G\n\nB. A-C-E-G\n\nC. A-B-D-E-G\n\nD. A-C-E-D-G\n\nE. 从 A 到 G 没有路径。", "solution": "由于该图是无权无向图，从源到目标跳数最少的路径可以通过广度优先搜索（BFS）获得。令 $L_k$ 表示第 $k$ 个 BFS 层（所有与 A 距离为 $k$ 的顶点），并令 $d(u,v)$ 表示顶点 $u$ 和 $v$ 之间的跳数距离。\n\n初始化 $L_0=\\{\\text{A}\\}$。A 的邻居是 B 和 C，所以\n$$\nL_1=\\{\\text{B},\\text{C}\\}.\n$$\n从 $L_1$ 开始，探索尚未访问过的新邻居。从 B 我们可以到达 D；从 C 我们可以到达 E，因此\n$$\nL_2=\\{\\text{D},\\text{E}\\}.\n$$\n从 $L_2$ 开始，探索尚未访问过的新邻居。从 D 我们可以到达 G（以及 E，但 E 已被发现），从 E 我们可以到达 G（以及 D，也已被发现）。因此 G 首次出现在\n$$\nL_3=\\{\\text{G}\\},\n$$\n所以最小跳数是\n$$\nd(\\text{A},\\text{G})=3.\n$$\n\n所有与这些层一致的、长度为 3 条边的 A 到 G 的最短路径是：\n- $A-B-D-G$，途经 $\\text{B} \\in L_1$ 和 $\\text{D} \\in L_2$，\n- $A-C-E-G$，途经 $\\text{C} \\in L_1$ 和 $\\text{E} \\in L_2$。\n\n不存在从 A 到 G 的 2 边路径，因为 A 的邻居只有 B 和 C，而 $\\{\\text{B},\\text{G}\\}$ 和 $\\{\\text{C},\\text{G}\\}$ 都不是边。诸如 $A-B-D-E-G$ 或 $A-C-E-D-G$ 之类的路径有 4 条边，不是最短的。\n\n根据打破平局的规则，在长度相等的最小路径中，我们选择字典序最靠前的一条。比较 $A-B-D-G$ 和 $A-C-E-G$，第一个不同点在第二个顶点：B 对 C，而 B 在字母表顺序上先于 C。因此，字典序最靠前的最短路径是 $A-B-D-G$，对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1354134"}, {"introduction": "当图的边带有权重时，我们还能直接使用BFS寻找“最短”路径吗？这个问题 [@problem_id:1414543] 旨在澄清一个关键概念：BFS的最短路径是基于“跳数”（边的数量），而非边的权重之和。通过在一个加权图上执行标准的（无权）BFS，并计算其生成树的总权重，你将亲身体会到BFS的局限性，并为学习更复杂的加权图最短路径算法（如Dijkstra算法）打下坚实的基础。", "problem": "考虑一个无向加权图 $G$，其顶点集为 $V = \\{\\text{A, B, C, D, E, F, G}\\}$。边及其对应的整数权重以元组（顶点1, 顶点2, 权重）列表的形式给出：\n$E = \\{(\\text{A, B, 3}), (\\text{A, C, 8}), (\\text{A, D, 10}), (\\text{B, C, 2}), (\\text{B, E, 5}), (\\text{C, F, 4}), (\\text{D, F, 7}), (\\text{E, G, 6}), (\\text{F, G, 1})\\}$.\n\n你的任务是找出以源顶点 A 为根的广度优先搜索（BFS）树。在运行搜索算法时，你必须将该图视为无权图，这意味着决定接下来访问哪些顶点仅取决于图的拓扑结构，而不取决于边的权重。当一个顶点有多个待访问的邻居时，你必须按照字母顺序进行探索。\n\n在 BFS 遍历完成并确定了所产生的生成树后，计算构成此 BFS 树的所有边的原始权重之和。将此总权重作为你的最终答案。", "solution": "我们对该无向图执行广度优先搜索（BFS），将其视为无权图，并按字母顺序探索邻居。用源顶点 A 初始化队列，将 A 标记为已发现，并通过添加首次到达每个新发现顶点的边来构建 BFS 树。\n\n从队列包含 A 开始。将 A 出队，并按字母顺序检查其邻居：B、C、D。它们都未被发现，所以我们按此顺序发现它们，将其父节点设置为 A，然后将它们入队。BFS 树增加了边 $(\\text{A, B})$、$(\\text{A, C})$ 和 $(\\text{A, D})$。\n\n队列现在是 `[B, C, D]`。将 B 出队，并按字母顺序检查其邻居：A、C、E。A 和 C 已经被发现，E 未被发现，因此发现 E，其父节点为 B，并将其入队。BFS 树增加了边 $(\\text{B, E})$。\n\n队列现在是 `[C, D, E]`。将 C 出队，并按字母顺序检查其邻居：A、B、F。A 和 B 已经被发现，F 未被发现，因此发现 F，其父节点为 C，并将其入队。BFS 树增加了边 $(\\text{C, F})$。\n\n队列现在是 `[D, E, F]`。将 D 出队，并按字母顺序检查其邻居：A、F。两者都已被发现；没有新顶点被添加。\n\n队列现在是 `[E, F]`。将 E 出队，并按字母顺序检查其邻居：B、G。B 已经被发现，G 未被发现，因此发现 G，其父节点为 E，并将其入队。BFS 树增加了边 $(\\text{E, G})$。\n\n队列现在是 `[F, G]`。将 F 出队，并按字母顺序检查其邻居：C、D、G。所有邻居都已被发现；没有新顶点被添加。\n\n队列现在是 `[G]`。将 G 出队，并按字母顺序检查其邻居：E、F。两者都已被发现；BFS 终止。\n\n因此，BFS 树的边为\n$$\\{(\\text{A, B}), (\\text{A, C}), (\\text{A, D}), (\\text{B, E}), (\\text{C, F}), (\\text{E, G})\\}.$$\n使用原始的边权重，此 BFS 树的总权重为\n$$3+8+10+5+4+6=36.$$", "answer": "$$\\boxed{36}$$", "id": "1414543"}]}