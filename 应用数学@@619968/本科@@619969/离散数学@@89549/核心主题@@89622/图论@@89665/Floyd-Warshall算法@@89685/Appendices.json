{"hands_on_practices": [{"introduction": "理解一个算法最好的方式就是亲手实践。这个练习将带你深入Floyd-Warshall算法的核心：动态规划的递推步骤。你将通过手动计算，一步步追踪在允许更多中间节点的情况下，两个特定节点间最短路径距离的变化，这将帮助你牢固掌握其基本逻辑。[@problem_id:1370950]", "problem": "在一个小型实验性数据中心，五个标记为 $N_1, N_2, N_3, N_4, N_5$ 的处理节点相互连接。该网络的性能由从一个节点直接向另一个节点发送数据包的延迟（单位为毫秒 (ms)）来表征。由于存在专门的硬件优化，一些直接链路可能具有负延迟，从而有效减少多跳数据传输的总时间。\n\n已知的直接延迟如下：\n- 从 $N_1$ 到 $N_2$：3 ms\n- 从 $N_1$ 到 $N_3$：8 ms\n- 从 $N_1$ 到 $N_5$：-2 ms\n- 从 $N_2$ 到 $N_4$：1 ms\n- 从 $N_2$ 到 $N_5$：7 ms\n- 从 $N_3$ 到 $N_2$：4 ms\n- 从 $N_4$ 到 $N_1$：2 ms\n- 从 $N_4$ 到 $N_3$：-5 ms\n- 从 $N_5$ 到 $N_4$：6 ms\n\n如果两个节点之间的直接路径未列出，则认为其延迟为无穷大。任何节点到其自身的延迟为 0 ms。\n\n从源节点 $N_i$ 到目的节点 $N_j$ 的路径可以经过一组中间节点。我们将 $L(i, j, k)$ 定义为从节点 $N_i$ 到节点 $N_j$ 的路径的最小可能延迟，该路径只允许使用集合 $\\{N_1, N_2, \\dots, N_k\\}$ 中的节点作为中间节点。从 $N_i$ 到 $N_j$ 的直接路径没有中间节点。\n\n计算 $L(4, 2, 3)$ 的值。以毫秒为单位给出最终答案。", "solution": "我们使用标准的 Floyd–Warshall 动态规划算法来求解带有限制性中间节点的最短路径问题。设 $w(i,j)$ 为从 $N_{i}$ 到 $N_{j}$ 的直接延迟，若未列出则 $w(i,j)=\\infty$，且 $w(i,i)=0$。定义\n$$\nL(i,j,0)=w(i,j), \\quad L(i,j,k)=\\min\\big(L(i,j,k-1),\\,L(i,k,k-1)+L(k,j,k-1)\\big),\n$$\n这会将中间节点限制在集合 $\\{N_{1},\\dots,N_{k}\\}$ 内。\n\n我们需要计算 $L(4,2,3)$。首先，根据数据：\n$$\nw(1,2)=3,\\quad w(1,3)=8,\\quad w(1,5)=-2,\\quad w(2,4)=1,\\quad w(2,5)=7,\n$$\n$$\nw(3,2)=4,\\quad w(4,1)=2,\\quad w(4,3)=-5,\\quad w(5,4)=6,\n$$\n并且所有其他的 $w(i,j)=\\infty$，除了 $w(i,i)=0$。\n\n对所需节点对进行初始化（$k=0$）：\n$$\nL(4,2,0)=\\infty,\\quad L(4,1,0)=2,\\quad L(1,2,0)=3,\\quad L(4,3,0)=-5,\\quad L(3,2,0)=4.\n$$\n\n步骤 $k=1$（允许 $N_{1}$ 作为中间节点）：\n$$\nL(4,2,1)=\\min\\big(L(4,2,0),\\,L(4,1,0)+L(1,2,0)\\big)=\\min(\\infty,\\,2+3)=5,\n$$\n并且为后续计算所需，\n$$\nL(4,3,1)=\\min(L(4,3,0),\\,L(4,1,0)+L(1,3,0)\\big) = \\min(-5,\\,2+8)=-5,\n$$\n$$\nL(3,2,1)=\\min(L(3,2,0),\\,L(3,1,0)+L(1,2,0)\\big) = \\min(4,\\,\\infty+3)=4.\n$$\n\n步骤 $k=2$（允许 $\\{N_{1},N_{2}\\}$ 作为中间节点）：\n$$\nL(4,2,2)=\\min\\big(L(4,2,1),\\,L(4,2,1)+L(2,2,1)\\big)=\\min(5,\\,5+0)=5,\n$$\n并且为后续计算所需，\n$$\nL(4,3,2)=\\min\\big(L(4,3,1),\\,L(4,2,1)+L(2,3,1)\\big)=\\min(-5,\\,5+\\infty)=-5,\n$$\n$$\nL(3,2,2)=\\min\\big(L(3,2,1),\\,L(3,2,1)+L(2,2,1)\\big)=\\min(4,\\,4+0)=4.\n$$\n\n步骤 $k=3$（允许 $\\{N_{1},N_{2},N_{3}\\}$ 作为中间节点）：\n$$\nL(4,2,3)=\\min\\big(L(4,2,2),\\,L(4,3,2)+L(3,2,2)\\big)=\\min(5,\\,-5+4)=-1.\n$$\n\n因此，仅使用 $\\{N_{1},N_{2},N_{3}\\}$ 作为中间节点，从 $N_{4}$ 到 $N_{2}$ 的最小可能延迟为 $-1$ ms。", "answer": "$$\\boxed{-1}$$", "id": "1370950"}, {"introduction": "在我们掌握了单个路径距离如何更新之后，让我们将视野放大，观察一次完整迭代对整个图的影响。在这个练习中，你将计算引入第一个可能的中间节点后的完整距离矩阵。这会让你对算法的全局进展有一个清晰的快照。[@problem_id:1370977]", "problem": "一个小型数据中心由四个服务器组成，分别标记为 1、2、3 和 4。网络管理员测量了某些服务器对之间的直接通信延迟（以毫秒为单位）。这些延迟由一个加权有向图表示，其中从服务器 $i$ 到服务器 $j$ 的边的权重等于其延迟。直接延迟的初始矩阵 $D^{(0)}$ 如下所示。$\\infty$ 条目表示服务器之间没有直接连接。\n\n$$\nD^{(0)} = \\begin{pmatrix}\n0 & 8 & \\infty & 1 \\\\\n\\infty & 0 & 1 & \\infty \\\\\n4 & \\infty & 0 & \\infty \\\\\n\\infty & 2 & 9 & 0\n\\end{pmatrix}\n$$\n\n为了找到所有服务器对之间的最短通信时间，管理员使用了 Floyd-Warshall 算法。该算法迭代计算一系列矩阵 $D^{(k)}$，其中条目 $D^{(k)}_{ij}$ 表示从服务器 $i$ 到服务器 $j$ 仅使用集合 $\\{1, 2, \\dots, k\\}$ 中的中间服务器的最短路径。\n\n确定 Floyd-Warshall 算法第一次完整迭代（即 $k=1$）后得到的矩阵 $D^{(1)}$。您的答案应该是一个完整的 $4 \\times 4$ 矩阵。", "solution": "我们应用 Floyd–Warshall 算法在 $k=1$ 时的更新。递推关系式为\n$$\nD^{(1)}_{ij}=\\min\\!\\left(D^{(0)}_{ij},\\,D^{(0)}_{i1}+D^{(0)}_{1j}\\right).\n$$\n- 对于 $i=1$，由于 $D^{(0)}_{11}=0$，对于所有 $j$，我们有 $D^{(0)}_{11}+D^{(0)}_{1j}=D^{(0)}_{1j}$，因此 $D^{(1)}_{1j}=D^{(0)}_{1j}$。所以第 1 行保持为 $\\big(0,\\,8,\\,\\infty,\\,1\\big)$。\n- 对于 $i=2$，由于 $D^{(0)}_{21}=\\infty$，对于所有 $j$，我们有 $D^{(0)}_{21}+D^{(0)}_{1j}=\\infty$，因此 $D^{(1)}_{2j}=D^{(0)}_{2j}$。所以第 2 行保持为 $\\big(\\infty,\\,0,\\,1,\\,\\infty\\big)$。\n- 对于 $i=3$，$D^{(0)}_{31}=4$ 是有限的，所以计算每个 $j$：\n$$\n\\begin{aligned}\nD^{(1)}_{31}&=\\min\\!\\big(D^{(0)}_{31},\\,D^{(0)}_{31}+D^{(0)}_{11}\\big)=4,\\\\\nD^{(1)}_{32}&=\\min\\!\\big(\\infty,\\,4+8\\big)=12,\\\\\nD^{(1)}_{33}&=\\min\\!\\big(D^{(0)}_{33},\\,D^{(0)}_{31}+D^{(0)}_{13}\\big)=0,\\\\\nD^{(1)}_{34}&=\\min\\!\\big(\\infty,\\,4+1\\big)=5.\n\\end{aligned}\n$$\n因此第 3 行变为 $\\big(4,\\,12,\\,0,\\,5\\big)$。\n- 对于 $i=4$，由于 $D^{(0)}_{41}=\\infty$，所以 $D^{(1)}_{4j}=D^{(0)}_{4j}$。因此第 4 行保持为 $\\big(\\infty,\\,2,\\,9,\\,0\\big)$。\n\n因此，\n$$\nD^{(1)}=\\begin{pmatrix}\n0 & 8 & \\infty & 1\\\\\n\\infty & 0 & 1 & \\infty\\\\\n4 & 12 & 0 & 5\\\\\n\\infty & 2 & 9 & 0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\n0 & 8 & \\infty & 1\\\\\n\\infty & 0 & 1 & \\infty\\\\\n4 & 12 & 0 & 5\\\\\n\\infty & 2 & 9 & 0\n\\end{pmatrix}}$$", "id": "1370977"}, {"introduction": "Floyd-Warshall算法是渐进式地发现最短路径的。这最后一个练习旨在挑战你思考特定路径的“发现时机”。通过追踪该算法在几轮迭代中的变化，你将对其路径在特定时刻被更新的原因（这取决于可用的中间节点）建立起更深刻的直觉。[@problem_id:1370958]", "problem": "考虑一个有 5 个顶点的有向图，顶点标记为 {1, 2, 3, 4, 5}。这些顶点之间最短路径的初始权重矩阵，记为 $D^{(0)}$，如下所示。值为 $\\infty$ 的项表示相应顶点之间没有直接路径。\n\n$$\nD^{(0)} = \\begin{pmatrix}\n0 & \\infty & \\infty & \\infty & 5 \\\\\n3 & 0 & 1 & \\infty & \\infty \\\\\n\\infty & \\infty & 0 & 2 & \\infty \\\\\n\\infty & 6 & \\infty & 0 & \\infty \\\\\n\\infty & \\infty & \\infty & 4 & 0\n\\end{pmatrix}\n$$\n\nFloyd-Warshall 算法通过迭代地改进路径估计来找到所有节点对之间的最短路径。它生成一个矩阵序列 $D^{(0)}, D^{(1)}, D^{(2)}, \\dots, D^{(5)}$。矩阵中的一个元素，由其行 $i$ 和列 $j$ 表示为 $(i,j)$ 项，如果它在矩阵 $D^{(k)}$ 中的值小于其在 $D^{(k-1)}$ 中的值，并且在之前的所有迭代中其值都未曾改变（即，对于所有 $1 \\le m < k$，其在 $D^{(m)}$ 中的值与在 $D^{(m-1)}$ 中的值相同），则称该元素在第 $k$ 次迭代（其中 $k \\ge 1$）时首次被更新。\n\n以下哪个元素是在算法的第 $k=3$ 次迭代中首次被更新的？\n\nA. $(2,5)$ 项\n\nB. $(4,1)$ 项\n\nC. $(4,3)$ 项\n\nD. $(2,4)$ 项\n\nE. $(1,2)$ 项", "solution": "Floyd–Warshall 的递推关系式为\n$$\nD^{(k)}_{ij}=\\min\\left(D^{(k-1)}_{ij},\\,D^{(k-1)}_{i k}+D^{(k-1)}_{k j}\\right),\n$$\n这意味着在第 $k$ 次迭代中，我们只允许使用集合 $\\{1,\\dots,k\\}$ 中的顶点作为中间顶点。\n\n从给定的 $D^{(0)}$ 开始，考虑 $k=1$（中间顶点为 1）。我们使用 $D^{(0)}$ 的第 1 列和第 1 行：\n- 对于 $i=2$，$D^{(0)}_{21}=3$ 且 $D^{(0)}_{1 5}=5$，所以\n$$\nD^{(1)}_{25}=\\min\\left(D^{(0)}_{25},\\,D^{(0)}_{21}+D^{(0)}_{15}\\right)=\\min\\left(\\infty,\\,3+5\\right)=8,\n$$\n这是一次首次更新。所有其他经过顶点 1 的路径对都保持不变，因为 $D^{(0)}_{i1}=\\infty$ 或 $D^{(0)}_{1j}=\\infty$。\n\n因此在 $k=1$ 之后，\n$$\nD^{(1)}=\\begin{pmatrix}\n0 & \\infty & \\infty & \\infty & 5\\\\\n3 & 0 & 1 & \\infty & 8\\\\\n\\infty & \\infty & 0 & 2 & \\infty\\\\\n\\infty & 6 & \\infty & 0 & \\infty\\\\\n\\infty & \\infty & \\infty & 4 & 0\n\\end{pmatrix}.\n$$\n\n对于 $k=2$（中间顶点为 2），使用 $D^{(1)}$ 的第 2 列和第 2 行。由于 $D^{(1)}_{42}=6$ 且第 2 行为 $(3,0,1,\\infty,8)$，我们得到\n$$\nD^{(2)}_{41}=\\min\\left(\\infty,\\,6+3\\right)=9,\\quad\nD^{(2)}_{43}=\\min\\left(\\infty,\\,6+1\\right)=7,\\quad\nD^{(2)}_{45}=\\min\\left(\\infty,\\,6+8\\right)=14,\n$$\n这些都是首次更新。没有其他顶点对通过顶点 2 得到改善。因此\n$$\nD^{(2)}=\\begin{pmatrix}\n0 & \\infty & \\infty & \\infty & 5\\\\\n3 & 0 & 1 & \\infty & 8\\\\\n\\infty & \\infty & 0 & 2 & \\infty\\\\\n9 & 6 & 7 & 0 & 14\\\\\n\\infty & \\infty & \\infty & 4 & 0\n\\end{pmatrix}.\n$$\n\n对于 $k=3$（中间顶点为 3），使用 $D^{(2)}$ 的第 3 列和第 3 行。我们有 $D^{(2)}_{23}=1$ 且第 3 行为 $(\\infty,\\infty,0,2,\\infty)$。那么\n$$\nD^{(3)}_{24}=\\min\\left(D^{(2)}_{24},\\,D^{(2)}_{23}+D^{(2)}_{34}\\right)=\\min\\left(\\infty,\\,1+2\\right)=3,\n$$\n这是一次首次更新。对于 $k=3$ 时的所有其他候选选项，没有发生改善：$(2,5)$ 已在 $k=1$ 时更新，$(4,1)$ 和 $(4,3)$ 在 $k=2$ 时更新，而 $(1,2)$ 不会通过顶点 3 得到改善，因为 $D^{(2)}_{13}=\\infty$ 且 $D^{(2)}_{32}=\\infty$。\n\n因此，所列选项中唯一在第 $k=3$ 次迭代时首次更新的元素是 $(2,4)$ 项。", "answer": "$$\\boxed{D}$$", "id": "1370958"}]}