{"hands_on_practices": [{"introduction": "掌握如何从不同的遍历序列中重建二叉树是理解其结构和算法的基础。本练习将指导你如何利用后序和中序遍历来识别根节点，并准确地划分出左右子树。通过这个实践，你将能够将抽象的遍历序列转化为具体的树形结构。[@problem_id:1352772]", "problem": "一个非空二叉树由其唯一的节点遍历序列定义。一个包含7个节点且标有唯一字符的特定二叉树，其后序遍历序列为 `[D, E, B, F, G, C, A]`。该二叉树的中序遍历序列为 `[D, B, E, A, F, C, G]`。\n\n根据这两个遍历序列，确定根节点的右子树的中序遍历序列。\n\n从以下选项中选择正确的序列。\n\nA. `F, C, G`\n\nB. `F, G, C`\n\nC. `C, F, G`\n\nD. `D, B, E`\n\nE. `G, C, F`", "solution": "我们已知一个具有唯一节点标签的二叉树，其后序遍历序列为 $[D,E,B,F,G,C,A]$，中序遍历序列为 $[D,B,E,A,F,C,G]$。\n\n根据后序遍历（左、右、根）的定义，后序遍历序列中的最后一个元素是根节点。因此，根节点是 $A$。\n\n根据中序遍历（左、根、右）的定义，在中序序列 $[D,B,E,A,F,C,G]$ 中找到 $A$ 的位置，可以将树划分为：\n- 左子树的中序遍历：$[D,B,E]$\n- 右子树的中序遍历：$[F,C,G]$\n\n为了与后序序列保持一致性，注意到在后序遍历中，右子树的节点出现在根节点 $A$ 的紧前面。因此，右子树的后序遍历是 $[F,G,C]$，其最后一个元素 $C$ 是右子树的根节点。在右子树的中序序列中，以 $C$ 为根，其左部和右部分别是 $[F]$ 和 $[G]$，从而得出右子树的中序遍历为 $[F,C,G]$。\n\n因此，根节点的右子树的中序遍历是 $F, C, G$，这与选项 A 相对应。", "answer": "$$\\boxed{A}$$", "id": "1352772"}, {"introduction": "在二叉树的基础上，二叉搜索树（BST）增加了一个关键属性：有序性。这个练习将向你展示如何利用这一特性，仅从一个先序遍历序列中就能推导出其后序遍历序列，而无需画出整个树。这凸显了特定数据结构属性在简化问题和提高算法效率方面的重要作用。[@problem_id:1352792]", "problem": "二叉搜索树 (BST) 是一种有根二叉树数据结构，其每个内部节点的键值都大于其左子树中所有节点的键值，且小于其右子树中所有节点的键值。二叉树的三种最常见的深度优先遍历方法是：\n- 前序遍历：访问根节点，然后遍历左子树，再遍历右子树。\n- 中序遍历：遍历左子树，然后访问根节点，再遍历右子树。\n- 后序遍历：遍历左子树，然后遍历右子树，再访问根节点。\n\n给定一个特定二叉搜索树的前序遍历所得到的节点值序列。该序列为：`[30, 20, 10, 25, 40, 35, 45]`。\n\n请在不画出此树的情况下，确定该二叉搜索树的正确后序遍历序列。\n\n从以下选项中选择正确的序列。\n\nA. `10, 25, 20, 35, 45, 40, 30`\n\nB. `10, 20, 25, 30, 35, 40, 45`\n\nC. `45, 35, 40, 25, 10, 20, 30`\n\nD. `35, 45, 40, 10, 25, 20, 30`", "solution": "使用二叉搜索树的性质和遍历的定义：\n\n1) 在二叉搜索树中，根节点左子树的所有键值都小于根节点的键值，右子树的所有键值都大于根节点的键值。在前序遍历中，第一个元素是根节点，其后是左子树的前序遍历，然后是右子树的前序遍历。\n\n给定前序遍历序列 $[30,20,10,25,40,35,45]$，根节点是 $30$。通过与 $30$ 比较，将剩余元素划分为左右子树：\n$$\\text{Left subsequence: }[20,10,25]\\quad(\\text{all }<30),\\qquad \\text{Right subsequence: }[40,35,45]\\quad(\\text{all }>30).$$\n\n2) 对左子序列 $[20,10,25]$ 进行递归。根节点是 $20$。通过与 $20$ 比较进行划分：\n$$\\text{Left of }20:\\ [10],\\qquad \\text{Right of }20:\\ [25].$$\n因此，左子树的根节点为 $20$，左子节点为 $10$，右子节点为 $25$。\n\n3) 对右子序列 $[40,35,45]$ 进行递归。根节点是 $40$。通过与 $40$ 比较进行划分：\n$$\\text{Left of }40:\\ [35],\\qquad \\text{Right of }40:\\ [45].$$\n因此，右子树的根节点为 $40$，左子节点为 $35$，右子节点为 $45$。\n\n4) 计算后序遍历（左、右、根）：\n- 左子树的后序遍历：访问 $[10]$，然后是 $[25]$，再是 $20$，得到 $[10,25,20]$。\n- 右子树的后序遍历：访问 $[35]$，然后是 $[45]$，再是 $40$，得到 $[35,45,40]$。\n- 整棵树的后序遍历：左子树 $[10,25,20]$、右子树 $[35,45,40]$，然后是根节点 $30$，最终得到\n$$[10,25,20,35,45,40,30].$$\n\n5) 与选项比较：这与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1352792"}, {"introduction": "理论知识的最终目的是解决实际问题。本练习模拟了一个数据完整性校验的场景：一个本应有序的中序遍历序列因节点值被意外交换而出现错误。你的任务是扮演一名“数据侦探”，通过分析序列中的异常来定位被交换的节点，这不仅考验你对二叉搜索树性质的深刻理解，也锻炼了你的分析和调试能力。[@problem_id:1352833]", "problem": "一个数据采集系统被设计用于记录一系列不同的测量值。该系统将这些测量值作为节点存储在二叉搜索树 (BST) 中。二叉搜索树是一种数据结构，其中对于任意给定节点，其左子树中的所有值都小于该节点的值，而其右子树中的所有值都大于该节点的值。为了导出数据，系统执行中序遍历。对于一个结构正确的BST，中序遍历应产生一个严格递增顺序的值序列。\n\n在一次例行数据完整性检查中，系统输出了以下序列。已知该序列是一棵BST中序遍历的结果，但这棵BST因内存故障导致恰好有两个节点的值被交换：\n$$\nS = [22, 35, 94, 48, 56, 65, 71, 89, 41, 99, 105]\n$$\n您的任务是找出被交换的两个值。请将您的答案表示为一个 $1 \\times 2$ 的矩阵，且较小的数字在前。例如，如果您确定被交换的数字是5和10，您的答案应格式化为 $\\begin{pmatrix} 5 & 10 \\end{pmatrix}$。", "solution": "对于一个有效的二叉搜索树 (BST)，中序遍历会产生一个严格递增的序列。如果恰好有两个节点的值被交换，那么在中序序列中，将会出现一个或两个索引位置不满足排序条件，即出现 $S_{i} > S_{i+1}$ 的位置。如果被交换的元素在正确顺序中不相邻，则会出现两次这样的违规；如果它们相邻，则只会出现一次。\n\n给定序列 $S = [22, 35, 94, 48, 56, 65, 71, 89, 41, 99, 105]$，我们扫描满足 $S_{i} > S_{i+1}$ 的索引 $i$：\n- 比较 $22 < 35$ 和 $35 < 94$：没有违规。\n- 在 $94$ 和 $48$ 处，我们有 $94 > 48$：第一次违规。记录下较大的前一个元素作为候选值 $x = 94$。\n- 继续：$48 < 56 < 65 < 71 < 89$：没有违规。\n- 在 $89$ 和 $41$ 处，我们有 $89 > 41$：第二次违规。记录下较小的后一个元素作为另一个候选值 $y = 41$。\n- 继续：$41 < 99 < 105$：没有更多违规。\n\n既然存在两次违规，被交换的值就是第一次违规中较大的元素和第二次违规中较小的元素，即 $x = 94$ 和 $y = 41$。\n\n通过在 $S$ 中交换这两个值进行验证，得到：\n$$[22, 35, 41, 48, 56, 65, 71, 89, 94, 99, 105],$$\n该序列是严格递增的，这证实了我们的判断。\n\n因此，被交换的值是 $41$ 和 $94$，所要求的将较小数放在前面的 $1 \\times 2$ 矩阵是 $\\begin{pmatrix} 41 & 94 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 41 & 94 \\end{pmatrix}}$$", "id": "1352833"}]}