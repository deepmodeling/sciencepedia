{"hands_on_practices": [{"introduction": "要真正掌握深度优先搜索（DFS），没有什么比亲手追踪其在图上的执行过程更有效了。这个练习将带你一步步执行递归式 DFS，并记录每个顶点的“发现时间”和“完成时间”。通过这个过程，你将直观地理解 DFS 是如何深入图的“深处”然后回溯的，而时间戳的概念是后续学习拓扑排序和寻找强连通分量等高级应用的基础。[@problem_id:1362166]", "problem": "一个软件构建系统使用一种“依赖解析协议”来确定编译一组相互关联的代码模块的正确顺序。该协议作用于一个由模块及其依赖关系构成的图。此过程涉及为每个模块分配两个时间戳：“发现时间”和“完成时间”。\n\n协议如下：\n1.  将一个全局时间戳计数器初始化为 1。\n2.  该过程从一个起始模块开始。如果未指定起始模块，则从按字母顺序排在最前面的模块开始。\n3.  当一个模块首次被访问时，它被标记为“已发现”，其发现时间被设为全局时间戳的当前值，然后时间戳加 1。\n4.  然后，系统检查刚发现的模块的邻居。它会按照字母顺序，对找到的第一个未访问的邻居递归调用此协议。\n5.  在针对一个模块所有邻居的递归调用都返回后，该模块被标记为“已完成”，其完成时间被设为全局时间戳的当前值，然后时间戳加 1。然后该过程返回其调用处。\n6.  如果初始遍历完成后仍有未访问的模块，则从按字母顺序排在最前面的未访问模块开始重复此过程。\n\n考虑一个包含八个模块的项目：A、B、C、D、E、F、G、H。依赖关系是对称的（即，如果 X 依赖于 Y，那么 Y 也依赖于 X），定义如下：\n-   模块 A 与 B、D 和 E 相连。\n-   模块 B 与 A 和 C 相连。\n-   模块 C 与 B、G 和 H 相连。\n-   模块 D 与 A 和 F 相连。\n-   模块 E 与 A 和 F 相连。\n-   模块 F 与 D、E 和 G 相连。\n-   模块 G 与 C 和 F 相连。\n-   模块 H 与 C 相连。\n\n从模块 A 开始执行该协议，确定所有八个模块的发现时间和完成时间。以下哪个选项正确列出了所有模块从 A 到 H 按字母顺序排列的 `(discovery_time, finish_time)` 对？\n\nA. A:(1,16), B:(8,9), C:(7,12), D:(2,15), E:(4,5), F:(3,14), G:(6,13), H:(10,11)\n\nB. A:(1, 16), B:(2, 15), C:(3, 14), D:(8, 9), E:(6, 7), F:(5, 10), G:(4, 11), H:(12, 13)\n\nC. A:(1, 16), B:(2, 15), C:(3, 14), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(12, 13)\n\nD. A:(1, 16), B:(2, 15), C:(3, 12), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(13, 14)", "solution": "我们执行一次深度优先遍历，全局时间戳 $t$ 初始化为 $1$，从 $A$ 开始，并按字母顺序探索邻居。首次访问节点 $v$ 时，设置其发现时间 $d(v)=t$ 并将 $t$ 增加 $1$。在对 $v$ 的所有邻居的递归调用返回后，设置其完成时间 $f(v)=t$ 并将 $t$ 增加 $1$。\n\n初始化 $t=1$。\n\n从 $A$ 开始，其邻居按顺序为 $B,D,E$。\n$$d(A)=1,\\quad t=2$$\n前往 $B$（$A$ 的第一个未访问邻居）。$B$ 的邻居按顺序为 $A,C$。\n$$d(B)=2,\\quad t=3$$\n$A$ 已被访问；前往 $C$。$C$ 的邻居按顺序为 $B,G,H$。\n$$d(C)=3,\\quad t=4$$\n$B$ 已被访问；前往 $G$。$G$ 的邻居按顺序为 $C,F$。\n$$d(G)=4,\\quad t=5$$\n$C$ 已被访问；前往 $F$。$F$ 的邻居按顺序为 $D,E,G$。\n$$d(F)=5,\\quad t=6$$\n前往 $D$（第一个未访问的）。$D$ 的邻居按顺序为 $A,F$。\n$$d(D)=6,\\quad t=7$$\n$A$ 和 $F$ 都已被访问；完成 $D$：\n$$f(D)=7,\\quad t=8$$\n回到 $F$；下一个邻居是 $E$（未访问）。\n$$d(E)=8,\\quad t=9$$\n$E$ 的邻居是 $A,F$，均已被访问；完成 $E$：\n$$f(E)=9,\\quad t=10$$\n回到 $F$；下一个邻居 $G$ 已被访问；完成 $F$：\n$$f(F)=10,\\quad t=11$$\n回到 $G$；没有更多邻居；完成 $G$：\n$$f(G)=11,\\quad t=12$$\n回到 $C$；下一个邻居是 $H$（未访问）。\n$$d(H)=12,\\quad t=13$$\n$H$ 的邻居 $C$ 已被访问；完成 $H$：\n$$f(H)=13,\\quad t=14$$\n回到 $C$；没有更多邻居；完成 $C$：\n$$f(C)=14,\\quad t=15$$\n回到 $B$；没有更多邻居；完成 $B$：\n$$f(B)=15,\\quad t=16$$\n回到 $A$；剩下的邻居 $D,E$ 都已被访问；完成 $A$：\n$$f(A)=16,\\quad t=17$$\n\n因此，发现/完成时间如下：\n- $A:(1,16)$\n- $B:(2,15)$\n- $C:(3,14)$\n- $D:(6,7)$\n- $E:(8,9)$\n- $F:(5,10)$\n- $G:(4,11)$\n- $H:(12,13)$\n\n这与选项 C 相符。", "answer": "$$\\boxed{C}$$", "id": "1362166"}, {"introduction": "在执行了基础的 DFS 追踪之后，一个自然而然的问题是：如果改变访问邻接顶点的顺序，结果会如何变化？这个练习通过在同一个图上使用两种不同的邻接表顺序来进行 DFS，让你直接对比结果的差异。通过比较两棵不同的 DFS 树以及边（树边、后向边）的分类，你将深刻认识到算法的输出并非唯一，它依赖于具体的实现选择，这是一个在设计和分析图算法时至关重要的洞察。[@problem_id:1496211]", "problem": "考虑一个无向图 $G = (V, E)$，其顶点集为 $V = \\{A, B, C, D, E, F\\}$，边集为 $E = \\{\\{A, B\\}, \\{A, C\\}, \\{A, D\\}, \\{B, C\\}, \\{C, D\\}, \\{C, E\\}, \\{D, F\\}, \\{E, F\\}\\}$。\n\n深度优先搜索（DFS）是一种遍历图的算法。当从一个源顶点开始执行DFS时，图的边会被分类。如果顶点 $v$ 是通过从顶点 $u$ 探索而首次被发现的，则边 $(u, v)$ 是一条“树边”。如果顶点 $v$ 是DFS树中顶点 $u$ 的一个祖先，但不是其父节点，则边 $(u, v)$ 是一条“回边”。所有树边的集合构成一个DFS树（或森林）。\n\nDFS树的结构和边的分类取决于访问相邻顶点的顺序。该顺序由图的邻接表表示确定。\n\n对图 $G$ 执行两次不同的DFS遍历，两次遍历均从顶点 $A$ 开始。\n1.  **遍历 1**：使用邻接表表示 $L_1$，其中每个顶点的邻居按字母顺序列出。本次遍历生成一棵DFS树 $T_1$。\n2.  **遍历 2**：使用一个不同的邻接表表示 $L_2$，其中每个顶点的邻居按下面给出的特定顺序列出。本次遍历生成一棵DFS树 $T_2$。\n\n邻接表 $L_2$：\n- A: [D, C, B]\n- B: [C, A]\n- C: [E, D, B, A]\n- D: [F, C, A]\n- E: [F, C]\n- F: [E, D]\n\n基于这两次遍历，以下哪个陈述是正确的？\n\nA. 两次遍历的回边集合相同。\n\nB. DFS树 $T_1$ 的高度大于DFS树 $T_2$ 的高度。（树的高度是指从根到叶的最长路径上的边数。）\n\nC. 边 $\\{C, D\\}$ 在 $T_1$ 中是树边，在 $T_2$ 中也是树边。\n\nD. 边 $\\{A, D\\}$ 在 $T_1$ 中是回边，但在 $T_2$ 中是树边。\n\nE. 顶点 $C$ 在两棵DFS树 $T_1$ 和 $T_2$ 中有相同的父节点。", "solution": "我们首先根据 $E=\\{\\{A,B\\},\\{A,C\\},\\{A,D\\},\\{B,C\\},\\{C,D\\},\\{C,E\\},\\{D,F\\},\\{E,F\\}\\}$ 构建按字母顺序排列的邻接表 $L_1$：\n- $A:[B,C,D]$, $B:[A,C]$, $C:[A,B,D,E]$, $D:[A,C,F]$, $E:[C,F]$, $F:[D,E]$.\n\n使用 $L_1$ 从 $A$ 开始的深度优先搜索过程如下。\n- 从 $A$ 访问 $B$：树边 $\\{A,B\\}$。\n- 从 $B$ 访问 $C$：树边 $\\{B,C\\}$。遇到 $C\\to A$，$A$ 是祖先但不是父节点：回边 $\\{A,C\\}$。\n- 从 $C$ 访问 $D$：树边 $\\{C,D\\}$。\n- 在 $D$ 处，遇到 $D\\to A$，$A$ 是祖先但不是父节点：回边 $\\{A,D\\}$。然后访问 $F$：树边 $\\{D,F\\}$。\n- 从 $F$ 访问 $E$：树边 $\\{F,E\\}$。\n- 在 $E$ 处，遇到 $E\\to C$，$C$ 是祖先但不是父节点：回边 $\\{C,E\\}$。\n\n因此，对于 $T_1$，树边为 $\\{\\{A,B\\},\\{B,C\\},\\{C,D\\},\\{D,F\\},\\{F,E\\}\\}$，构成路径 $A\\!-\\!B\\!-\\!C\\!-\\!D\\!-\\!F\\!-\\!E$。回边为 $\\{\\{A,C\\},\\{A,D\\},\\{C,E\\}\\}$。$T_1$ 的高度为 $5$（最长的根到叶路径有 $5$ 条边）。\n\n现在使用 $L_2$：\n- $A:[D,C,B]$, $B:[C,A]$, $C:[E,D,B,A]$, $D:[F,C,A]$, $E:[F,C]$, $F:[E,D]$.\n\n使用 $L_2$ 从 $A$ 开始的深度优先搜索过程如下。\n- 从 $A$ 访问 $D$：树边 $\\{A,D\\}$。\n- 从 $D$ 访问 $F$：树边 $\\{D,F\\}$。\n- 从 $F$ 访问 $E$：树边 $\\{F,E\\}$。\n- 从 $E$ 访问 $C$：树边 $\\{E,C\\}$。\n- 在 $C$ 处，遇到 $C\\to D$，$D$ 是祖先但不是父节点：回边 $\\{C,D\\}$。然后访问 $B$：树边 $\\{C,B\\}$。\n- 在 $B$ 处，遇到 $B\\to A$，$A$ 是祖先但不是父节点：回边 $\\{A,B\\}$。回到 $C$ 处，遇到 $C\\to A$，$A$ 是祖先但不是父节点：回边 $\\{A,C\\}$。\n\n因此，对于 $T_2$，树边为 $\\{\\{A,D\\},\\{D,F\\},\\{F,E\\},\\{E,C\\},\\{C,B\\}\\}$，构成路径 $A\\!-\\!D\\!-\\!F\\!-\\!E\\!-\\!C\\!-\\!B$。回边为 $\\{\\{A,B\\},\\{A,C\\},\\{C,D\\}\\}$。$T_2$ 的高度也是 $5$。\n\n评估各个陈述：\n- A：回边集合不同（$\\{\\{A,C\\},\\{A,D\\},\\{C,E\\}\\}$ vs $\\{\\{A,B\\},\\{A,C\\},\\{C,D\\}\\}$），所以为假。\n- B：高度相等（$5$ 和 $5$），所以为假。\n- C：$\\{C,D\\}$ 在 $T_1$ 中是树边，但在 $T_2$ 中是回边，所以为假。\n- D：$\\{A,D\\}$ 在 $T_1$ 中是回边，在 $T_2$ 中是树边，所以为真。\n- E：在 $T_1$ 中 $C$ 的父节点是 $B$，而在 $T_2$ 中是 $E$，所以为假。\n\n因此，只有陈述D是正确的。", "answer": "$$\\boxed{D}$$", "id": "1496211"}, {"introduction": "掌握了 DFS 的工作原理后，让我们来看一个更具挑战性的应用：在一个有向无环图（DAG）中计算从起点到终点的所有不同路径数量。这个问题模拟了现代软件构建系统中分析编译序列的场景，是图算法在现实世界中的典型应用。解决这个问题需要你将图遍历的思路与动态规划的思想相结合，这不仅能巩固你对图结构的理解，还能展示如何利用图的特性（如无环）来设计高效的算法。[@problem_id:1362142]", "problem": "一个软件构建系统会分析不同模块之间的依赖关系，以确定有效的编译顺序。这些依赖关系表示为一个有向无环图 (DAG)，其中一组顶点表示模块，一条从模块 U 到模块 V 的有向边表示模块 U 是 V 的一个先决条件（即，U 必须在 V 之前编译）。\n\n“简单编译序列”定义为从一个起始模块到一个最终模块且不重复访问任何模块的路径。为了进行性能分析，该系统需要确定一个特定的起始模块和一个目标模块之间不同简单编译序列的总数。\n\n考虑一个具有以下依赖图的系统：\n- 模块（顶点）集合为 $V = \\{0, 1, 2, 3, 4, 5, 6, 7, 8\\}$。\n- 依赖（边）集合为 $E = \\{(0, 1), (0, 2), (1, 3), (1, 4), (2, 4), (2, 5), (3, 6), (4, 6), (4, 7), (5, 7), (6, 8), (7, 8)\\}$。\n- `start_module` 是 $s = 0$。\n- `target_module` 是 $t = 8$。\n\n从 `start_module` 到 `target_module` 的不同简单编译序列的总数是多少？", "solution": "我们用函数 $N(v)$ 表示从顶点 $v$ 到目标顶点 $t$ 的不同简单路径的数量。在有向无环图中，简单路径的数量满足以下动态规划关系\n$$\nN(v)=\\sum_{(v,u)\\in E}N(u),\n$$\n其基本情况为\n$$\nN(t)=1,\n$$\n因为从 $t$ 到其自身只有一条平凡路径。我们按照与给定边的方向一致的逆拓扑顺序来处理顶点。\n\n给定 $t=8$，我们设定\n$$\nN(8)=1.\n$$\n根据出边：\n- 从 $7$ 到 $8$，我们有\n$$\nN(7)=N(8)=1.\n$$\n- 从 $6$ 到 $8$，我们有\n$$\nN(6)=N(8)=1.\n$$\n- 从 $5$ 到 $7$，我们有\n$$\nN(5)=N(7)=1.\n$$\n- 从 $4$ 到 $6$ 和 $7$，我们有\n$$\nN(4)=N(6)+N(7)=1+1=2.\n$$\n- 从 $3$ 到 $6$，我们有\n$$\nN(3)=N(6)=1.\n$$\n- 从 $2$ 到 $4$ 和 $5$，我们有\n$$\nN(2)=N(4)+N(5)=2+1=3.\n$$\n- 从 $1$ 到 $3$ 和 $4$，我们有\n$$\nN(1)=N(3)+N(4)=1+2=3.\n$$\n- 从 $0$ 到 $1$ 和 $2$，我们有\n$$\nN(0)=N(1)+N(2)=3+3=6.\n$$\n\n因此，从 $s=0$ 到 $t=8$ 的不同简单编译序列的总数为 $N(0)=6$。", "answer": "$$\\boxed{6}$$", "id": "1362142"}]}