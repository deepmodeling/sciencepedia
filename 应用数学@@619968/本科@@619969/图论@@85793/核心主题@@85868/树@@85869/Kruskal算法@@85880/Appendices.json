{"hands_on_practices": [{"introduction": "掌握任何算法的第一步都是通过手动执行来熟悉其流程。这个练习提供了一个具体的网络设计场景，让你模拟Kruskal算法的初始步骤。通过按权重排序边并逐步构建最小生成树，你将亲身体验该算法的贪心选择机制和避免环路的核心规则，这是理解其工作原理的基础 [@problem_id:1517280]。", "problem": "一家科技公司正在设计一个私有的加密广域网 (WAN)，以连接其八个主要的数据中心，这些数据中心被标记为 DC1 到 DC8。目标是建立一个能够直接或间接连接所有数据中心的网络拓扑，并使光纤链路的年租赁成本达到最低。可用的点对点链路及其相关的年成本（单位：千美元）如下所列。该列表是根据另一项内部指标预先排序的，而不是按成本排序。\n\n*   (DC5, DC7) - 成本: 17\n*   (DC1, DC2) - 成本: 11\n*   (DC3, DC8) - 成本: 20\n*   (DC5, DC6) - 成本: 13\n*   (DC1, DC5) - 成本: 18\n*   (DC2, DC4) - 成本: 15\n*   (DC7, DC8) - 成本: 16\n*   (DC1, DC3) - 成本: 14\n*   (DC3, DC4) - 成本: 12\n*   (DC2, DC6) - 成本: 19\n\n网络工程团队决定应用 Kruskal 算法来确定要租赁的最优链路集合。根据该算法，成功添加前五个链路后，构成的网络链路集合是什么？\n\nA. `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`\n\nB. `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC2, DC4)}`\n\nC. `{(DC1, DC2), (DC3, DC4), (DC1, DC3), (DC5, DC7), (DC1, DC5)}`\n\nD. `{(DC3, DC8), (DC2, DC6), (DC1, DC5), (DC5, DC7), (DC7, DC8)}`", "solution": "Kruskal 算法通过迭代地从所有可用边的列表中选择权重最低的边来构建一个最小生成树 (MST)，前提是添加该边不会与已选择的边形成环路。\n\n首先，我们必须将所有可用的链路（边）按其成本（权重）进行非递减排序。\n\n提供的列表是：\n*   (DC5, DC7), 成本: 17\n*   (DC1, DC2), 成本: 11\n*   (DC3, DC8), 成本: 20\n*   (DC5, DC6), 成本: 13\n*   (DC1, DC5), 成本: 18\n*   (DC2, DC4), 成本: 15\n*   (DC7, DC8), 成本: 16\n*   (DC1, DC3), 成本: 14\n*   (DC3, DC4), 成本: 12\n*   (DC2, DC6), 成本: 19\n\n按成本排序后得到以下有序列表：\n1.  (DC1, DC2), 成本: 11\n2.  (DC3, DC4), 成本: 12\n3.  (DC5, DC6), 成本: 13\n4.  (DC1, DC3), 成本: 14\n5.  (DC2, DC4), 成本: 15\n6.  (DC7, DC8), 成本: 16\n7.  (DC5, DC7), 成本: 17\n8.  (DC1, DC5), 成本: 18\n9.  (DC2, DC6), 成本: 19\n10. (DC3, DC8), 成本: 20\n\n接下来，我们追踪该算法的执行过程。最初，每个数据中心都位于其自己的不相交集合中，形成一个由八个连通分量组成的森林：`{DC1}, {DC2}, {DC3}, {DC4}, {DC5}, {DC6}, {DC7}, {DC8}`。已选择的边集合为空。\n\n**第 1 步 (第一次成功添加):**\n我们考虑成本最低的边：(DC1, DC2)，成本为 11。数据中心 DC1 和 DC2 位于不同的集合中 (`{DC1}` 和 `{DC2}`)。添加这条边不会产生环路。所以，我们添加它。\n*   已选中的边: `{(DC1, DC2)}`\n*   现在的集合为: `{{DC1, DC2}, {DC3}, {DC4}, {DC5}, {DC6}, {DC7}, {DC8}}`\n\n**第 2 步 (第二次成功添加):**\n成本次低的边是 (DC3, DC4)，成本为 12。DC3 和 DC4 位于不同的集合中 (`{DC3}` 和 `{DC4}`)。我们添加这条边。\n*   已选中的边: `{(DC1, DC2), (DC3, DC4)}`\n*   现在的集合为: `{{DC1, DC2}, {DC3, DC4}, {DC5}, {DC6}, {DC7}, {DC8}}`\n\n**第 3 步 (第三次成功添加):**\n下一条边是 (DC5, DC6)，成本为 13。DC5 和 DC6 位于不同的集合中 (`{DC5}` 和 `{DC6}`)。我们添加这条边。\n*   已选中的边: `{(DC1, DC2), (DC3, DC4), (DC5, DC6)}`\n*   现在的集合为: `{{DC1, DC2}, {DC3, DC4}, {DC5, DC6}, {DC7}, {DC8}}`\n\n**第 4 步 (第四次成功添加):**\n下一条边是 (DC1, DC3)，成本为 14。DC1 位于集合 `{DC1, DC2}` 中，而 DC3 位于集合 `{DC3, DC4}` 中。由于它们是不同的集合，添加该边不会产生环路。我们添加它，并将这两个集合合并。\n*   已选中的边: `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3)}`\n*   现在的集合为: `{{DC1, DC2, DC3, DC4}, {DC5, DC6}, {DC7}, {DC8}}`\n\n**第 5 步 (环路检测):**\n下一条边是 (DC2, DC4)，成本为 15。我们检查 DC2 和 DC4 属于哪个集合。DC2 位于 `{DC1, DC2, DC3, DC4}` 中，DC4 也位于 `{DC1, DC2, DC3, DC4}` 中。由于它们在同一个集合中，添加这条边会形成一个环路（具体来说是 DC1-DC2-DC4-DC3-DC1）。因此，我们**拒绝**这条边。\n\n**第 6 步 (第五次成功添加):**\n我们处理排序列表中的下一条边：(DC7, DC8)，成本为 16。DC7 位于 `{DC7}` 中，DC8 位于 `{DC8}` 中。它们是不同的集合，所以我们添加这条边。这是我们成功添加的第五条边。\n*   已选中的边: `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`\n*   现在的集合为: `{{DC1, DC2, DC3, DC4}, {DC5, DC6}, {DC7, DC8}}`\n\n过程到此结束，因为题目要求的是前五个成功添加的边的集合。得到的集合是 `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`。\n\n将此结果与给定选项进行比较，我们发现它与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1517280"}, {"introduction": "在了解了Kruskal算法如何操作之后，探索其正确性的理论基础至关重要。这个练习提出了一个关于图中权重第二小的边是否必须包含在最小生成树中的猜想。通过评估这个猜想，你将被引导去思考算法每一步选择的“安全边”属性，从而加深对Kruskal算法贪心策略为何有效的根本性理解 [@problem_id:1517301]。", "problem": "在一门关于算法的计算机科学课程中，一名学生正在研究用于寻找最小生成树（MST）的 Kruskal 算法。最小生成树是一个子图，它连接了所有顶点，没有任何环，并且总边权重尽可能小。这名学生提出了以下猜想：\n\n“在任何至少有3个顶点、所有边权重都不同的连通、简单、无向图中，整个图中权重第二小的边必定包含在最小生成树中。”\n\n你的任务是评估这个猜想。以下哪个陈述是正确的，并提供了最准确的推理？\n\nA. 该猜想是错误的。考虑一个由三个顶点组成的环（一个三角形），其中的边是图中权重最轻的三条边。被考虑的第三条边（它可能是整体权重第二小的边）会因为它形成一个环而被丢弃，所以它不总是被包含。\n\nB. 该猜想是正确的。权重最小的边总是最先被包含。权重第二小的边紧接着被考虑。由于该图是简单图且所有边权重都不同，这两条边不可能连接同一对顶点。因此，第二条边不可能与第一条边形成环，所以它将总是被包含。\n\nC. 该猜想是错误的。如果一条边的两个端点已经相连，Kruskal 算法会排除这条边。权重第二小的边的两个端点有可能通过一条由若干条比它权重更小的其他边组成的路径相连接。\n\nD. 该猜想是正确的。Kruskal 算法是一种贪心算法。为了确保最终的树权重最小化，它必须选择两条最轻的可用边来开始构建树，因为这些边提供了“最便宜”的连接。\n\nE. 该猜想的有效性无法保证，它取决于图的具体结构。在稀疏连通图中，它很可能是正确的，但在稠密图中，它很可能是错误的。", "solution": "设 $G=(V,E)$ 是一个连通、简单、无向图，其中 $|V| \\geq 3$ 且所有边权重都不同。设所有边按权重严格递增排序为 $e_{1}, e_{2}, \\dots, e_{m}$，其中 $w(e_{1}) < w(e_{2}) < \\dots < w(e_{m})$。Kruskal 算法按此顺序考虑各边，并且当且仅当一条边不会与已选边形成环时才将其加入；等价地说，如果一条边的端点位于当前森林的不同连通分量中，则加入该边。\n\n首先，当考虑 $e_{1}$ 时，尚未选择任何边，因此添加 $e_{1}$ 不可能形成环。所以 $e_{1}$ 总是被包含。\n\n接下来，考虑 $e_{2}$。在考虑 $e_{2}$ 的那一刻，唯一被考虑过且可能已被包含的边是 $e_{1}$。当前的森林最多只有一条边，即 $e_{1}$，它将其两个端点连接成一个连通分量，而所有其他顶点仍旧是孤立的单点分量。在这个阶段，根据 Kruskal 算法的规则，$e_{2}$ 被排除的唯一可能是其端点已经通过已包含的边构成路径相连。唯一可用的已包含边是 $e_{1}$。因此，要使 $e_{2}$ 的端点已经相连，$e_{2}$ 就必须连接与 $e_{1}$ 相同的无序顶点对。然而，由于该图是简单图，任意一对顶点之间最多只有一条边，所以 $e_{2}$ 不可能是 $e_{1}$ 的平行边。因此，在考虑 $e_{2}$ 时，其端点位于不同的连通分量中，添加 $e_{2}$ 不会形成环。故 Kruskal 算法必须包含 $e_{2}$。\n\n由于所有边权重都不同，最小生成树是唯一的，而 Kruskal 算法能够生成这个唯一的最小生成树。因此，$e_{2}$ 包含在最小生成树中。这直接验证了该猜想。\n\n评估各个选项：\n- A 是不正确的，因为它错误地将考虑的第三条边识别为可能是第二轻的边；第二轻的边是第二条被考虑的边，并且如前所述，它被包含了。\n- B 是正确的：它精确地抓住了这一点，即在一个简单图和不同权重的情况下，$e_{2}$ 在被考虑时不可能形成环，因此它总是被包含。\n- C 对于第二轻的边是错误的：不可能存在一条由多条都比 $e_{2}$ 轻的边组成的路径，因为只有 $e_{1}$ 比它轻。\n- D 得出了正确的结论，但给出的理由不精确；Kruskal 算法选择边并不仅仅因为它们是抽象意义上最轻的两条边，而是因为第二轻的边在轮到它时不会形成环。\n- E 是不正确的；在给定假设下，该属性不依赖于图的稀疏性或稠密性。\n\n因此，理由准确的正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1517301"}, {"introduction": "现实世界中的网络是动态变化的，而不仅仅是静态构建。这个高级练习将我们从零开始构建最小生成树的场景，推进到更现实的问题：当网络中某条链路的成本发生变化时，如何高效地更新现有的最优结构。此问题聚焦于最小生成树的“环路性质”，它揭示了如何通过添加新边并移除环路中最“昂贵”的边来智能地调整树，这展示了将图论性质应用于实际问题解决的强大能力 [@problem_id:1517296]。", "problem": "一家航空航天公司管理着一个由 $n$ 颗在轨通信卫星组成的大型卫星星座。这些卫星之间可能的通信链路网络被建模为一个加权无向图 $G=(V, E)$，其中 $V$ 是 $n$ 颗卫星的集合，$E$ 是所有可能的直接通信链路的集合。$E$ 中一条边 $(u, v)$ 的权重表示卫星 $u$ 和卫星 $v$ 之间的信号延迟。为确保通信高效可靠且整体延迟最小，活动链路被配置成图 $G$ 的一个最小生成树（MST），记为 $T$。\n\n假设在一对卫星 $(u, v)$ 上部署了一项新的激光通信技术。这条特定链路 $(u, v)$ *不*属于原来的最小生成树 $T$。这次升级将其通信延迟从原始值 $w(u,v)$ 降低到一个新的、更低的值 $w'(u,v)$。网络管理员必须确定是否应将这条新的、更快的链路并入通信骨干网，如果需要，又该如何形成新的最小生成树 $T'$。\n\n一个提议的更新流程如下：\n1. 暂时将新升级的链路 $(u, v)$ 添加到现有的最小生成树 $T$ 中。这个操作会创建一个新图 $T \\cup \\{(u,v)\\}$，该图恰好包含一个环。\n2. 为了形成新的最小生成树 $T'$，并保持最小总延迟的特性，必须从这个新形成的环中恰好移除一条链路。\n\n下列哪个陈述正确地指出了从环中选择要移除的链路的规则，以及识别这条特定链路的最坏情况下的时间复杂度？给定现有的最小生成树 $T$（以允许高效遍历的方式表示，例如邻接表），以及两颗卫星 $u$ 和 $v$。卫星总数为 $n$。\n\nA. 移除环中延迟最小的链路。复杂度为 $O(n \\log n)$。\n\nB. 移除环中延迟最大的链路。复杂度为 $O(n)$。\n\nC. 如果 $w'(u, v)$ 小于环中其他所有链路的延迟，则移除环中延迟最大的链路；否则，最小生成树保持不变。做出此判断的复杂度为 $O(n^2)$。\n\nD. 移除环中延迟最大的链路。复杂度为 $O(\\log n)$。\n\nE. 总是移除链路 $(u, v)$ 本身，因为它是最近添加的。复杂度为 $O(1)$。\n\nF. 移除环中延迟最大的链路。复杂度为 $O(n^2)$。", "solution": "我们将卫星星座建模为一个加权无向图 $G=(V,E)$，其中权重表示延迟。设 $T$ 是 $G$ 的一个最小生成树。一条非树边 $(u,v)$ 的权重从 $w(u,v)$ 降低到 $w'(u,v)$，我们考虑更新 $T$。\n\n将 $(u,v)$ 添加到 $T$ 中会恰好产生一个环，因为 $T$ 是一棵树，所以在 $T$ 中 $u$ 和 $v$ 之间存在一条唯一的简单路径 $P_{T}(u,v)$；因此这个环是\n$$\nC \\;=\\; P_{T}(u,v) \\cup \\{(u,v)\\}.\n$$\n设 $e^{\\ast}$ 是 $C$ 中延迟最大的一条边：\n$$\ne^{\\ast} \\;\\in\\; \\arg\\max_{e \\in C} w(e),\n$$\n其中对于 $(u,v)$，我们使用其更新后的权重 $w'(u,v)$。根据最小生成树的环性质：在任何环中，一条其权重严格大于环中任何其他边的边，不属于任何最小生成树。因此，为了在添加 $(u,v)$ 后保持最小的总延迟，正确的操作是从 $C$ 中移除一条具有最大延迟的边。有两种情况：\n- 如果 $w'(u,v) < \\max_{e \\in P_{T}(u,v)} w(e)$，那么 $e^{\\ast} \\neq (u,v)$ 并且\n$$\nw(T \\cup \\{(u,v)\\} \\setminus \\{e^{\\ast}\\}) \\;=\\; w(T) + w'(u,v) - w(e^{\\ast}) \\;<\\; w(T),\n$$\n所以更新后的最小生成树是 $T' = T \\cup \\{(u,v)\\} \\setminus \\{e^{\\ast}\\}$。\n- 如果 $w'(u,v) \\ge \\max_{e \\in P_{T}(u,v)} w(e)$，那么 $e^{\\ast} = (u,v)$（或存在权重相等的边），此时移除 $(u,v)$ 会得到原始的 $T$，它仍然是一个最小生成树。\n\n因此，选择规则是“移除环中延迟最大的链路”。\n\n为了确定要移除的具体链路，我们需要找到唯一路径 $P_{T}(u,v)$ 上的最大权重边。给定以邻接表表示的 $T$ 以及顶点 $u$ 和 $v$，我们可以：\n1. 从 $u$ 开始执行深度优先搜索（DFS）或广度优先搜索（BFS）以找到 $v$，并记录父指针；因为 $T$ 是一棵树，这个过程最多遍历 $n-1$ 条边，所以需要 $O(n)$ 的时间。\n2. 从父指针重构路径 $P_{T}(u,v)$，并扫描其上的边以找到最大延迟；在最坏情况下，这同样需要 $O(n)$ 的时间。\n\n因此，总的最坏情况时间复杂度为 $O(n)$。在这些选项中，这对应于“移除延迟最大的链路”，且时间复杂度为 $O(n)$。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1517296"}]}