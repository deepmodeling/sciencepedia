{"hands_on_practices": [{"introduction": "我们从一个最基本的练习开始：将抽象的父子关系集合转化为一个具体的有根树结构。这个练习旨在巩固根、叶、节点深度和树高这些核心定义。通过亲手构建树形图并计算其关键参数，你将能够深化对树结构基本性质的理解，这是在计算机科学和数据分析中一项至关重要的技能 [@problem_id:1531605]。", "problem": "一个层次化数据结构由一组父子关系描述。该结构由用大写字母标记的节点组成。这组关系以有序对 `(P, C)` 的集合形式给出，其中 `P` 是 `C` 的父节点。\n\n关系集为：`{(F, B), (F, J), (B, A), (B, D), (D, C), (D, E), (J, G), (J, K), (G, I), (K, H), (K, L)}`。\n\n理解此结构需要以下几个定义：\n- **根节点**是唯一没有父节点的节点。\n- **叶节点**是没有子节点的节点。\n- 节点的**深度**是从根节点到该节点的唯一路径上的边的数量。根据定义，根节点的深度为 0。\n- 整个结构的**高度**是结构中所有节点深度的最大值。\n\n根据所给的关系，确定以下三个值：\n1. 结构的高度。\n2. 结构中叶节点的总数。\n3. 节点 `K` 的深度。\n\n将你的答案以单行矩阵 `(h, l, d)` 的形式给出，其中 `h` 是高度，`l` 是叶节点数量，`d` 是节点 `K` 的深度。", "solution": "设关系集为 $R=\\{(F,B),(F,J),(B,A),(B,D),(D,C),(D,E),(J,G),(J,K),(G,I),(K,H),(K,L)\\}$。设 $P$ 是 $R$ 中出现的所有父节点的集合，$C$ 是所有子节点的集合：\n$$P=\\{F,B,D,J,G,K\\},\\quad C=\\{B,J,A,D,C,E,G,K,I,H,L\\}.$$\n根节点是没有任何父节点的节点，即集合 $P\\setminus C$ 中的唯一元素，也就是 $F$。\n\n定义深度函数 $d(\\cdot)$ 为 $d(F)=0$，且对于 $R$ 中的每个 $(u,v)$，都有 $d(v)=d(u)+1$。递归地应用此定义：\n- 从 $(F,B)$ 和 $(F,J)$ 可得：$d(B)=1, d(J)=1$。\n- 从 $(B,A)$ 和 $(B,D)$ 可得：$d(A)=2, d(D)=2$。\n- 从 $(D,C)$ 和 $(D,E)$ 可得：$d(C)=3, d(E)=3$。\n- 从 $(J,G)$ 和 $(J,K)$ 可得：$d(G)=2, d(K)=2$。\n- 从 $(G,I)$ 可得：$d(I)=3$。\n- 从 $(K,H)$ 和 $(K,L)$ 可得：$d(H)=3, d(L)=3$。\n\n高度是最大深度：\n$$h=\\max\\{d(v)\\colon v\\in V\\}=3.$$\n\n叶节点是没有子节点的节点，即对于节点 $v$，不存在任何节点 $w$ 使得 $(v,w)\\in R$。叶节点为 $\\{A,C,E,I,H,L\\}$，因此叶节点的总数是\n$$l=6.$$\n\n节点 `K` 的深度是\n$$d=d(K)=2.$$", "answer": "$$\\boxed{\\begin{pmatrix} 3 & 6 & 2 \\end{pmatrix}}$$", "id": "1531605"}, {"introduction": "掌握了单个树的构建后，我们将视野拓宽到一类具有特定规则的树——满 $m$ 叉树。这个练习将引导你发现任何满 $m$ 叉树中，其叶子节点数量 $l$ 和内部节点数量 $i$ 之间存在的固定数学关系。这个关系可以通过一个简洁的公式 $l = (m - 1)i + 1$ 来描述，它展示了简单的结构约束如何产生强大的预测能力，使我们无需遍历整个树就能推断其属性 [@problem_id:1531606]。", "problem": "在计算机科学领域，有根树是用于分层组织信息的基本数据结构。考虑一种为高性能数据库索引系统设计的专用树结构。该结构被建模为一个**满m叉树**。\n\n我们来定义一些术语：\n- **有根树**是一棵指定了一个顶点作为根的树。\n- **m叉树**是一棵每个顶点最多有 $m$ 个子节点的有根树。\n- **满m叉树**是一种特殊的m叉树，其中每个非叶子顶点都恰好有 $m$ 个子节点。\n- **叶子**是没有任何子节点的顶点。\n- **内部顶点**是任何至少有一个子节点的顶点（即，任何非叶子顶点）。\n\n该数据库系统使用一个满5叉树实现。一次系统诊断显示该树当前恰好包含21个叶子。根据这些信息，请确定该树中内部顶点的数量。", "solution": "设 $m$ 表示分支度，$i$ 表示内部顶点数，$l$ 表示叶子数，$V$ 表示总顶点数，$E$ 表示边数。\n\n在有根树中，边数满足\n$$\nE = V - 1.\n$$\n在满$m$叉树中，每个内部顶点都恰好有 $m$ 个子节点，因此总边数也等于所有顶点的出度之和，而出度仅由内部顶点贡献：\n$$\nE = m i.\n$$\n总顶点数是内部顶点数与叶子数之和：\n$$\nV = i + l.\n$$\n令关于 $E$ 的两个表达式相等，可得\n$$\nm i = V - 1 = i + l - 1.\n$$\n整理后，\n$$\nl = (m - 1)i + 1.\n$$\n对于一个有 $l = 21$ 个叶子的满5叉树，代入 $m = 5$ 和 $l = 21$：\n$$\n21 = (5 - 1)i + 1 = 4i + 1.\n$$\n解出 $i$：\n$$\n4i = 20 \\quad \\Rightarrow \\quad i = 5.\n$$\n因此，内部顶点的数量为 $5$。", "answer": "$$\\boxed{5}$$", "id": "1531606"}, {"introduction": "最后，我们将注意力转向在树上解决算法问题，并使用计算机科学中一种常见的数据表示法——父节点数组。此练习要求你应用路径和祖先的概念，来寻找两个节点的“最低公共祖先”（Lowest Common Ancestor, LCA）。这是一个经典且实用的算法问题，其应用范围从文件系统到演化生物学，它能训练你进行算法思维，并以编程方式在树结构中进行导航 [@problem_id:1531615]。", "problem": "在一家现代科技公司中，其组织结构被建模为一棵有根树。每位员工由一个节点表示，汇报关系由一个父节点数组定义。该公司有 $N=15$ 名员工，索引从 0 到 14。该结构由一个大小为 15 的零索引父节点数组 `P` 给出，其中 `P[i]` 是员工 `i` 的直接经理的索引。公司总裁是树的根节点，没有经理，这通过根节点员工 `i` 的 `P[i] = -1` 来表示。\n\n父节点数组 `P` 如下：\n`P = [10, 3, 0, 8, 1, 0, 3, 1, -1, 4, 8, 10, 4, 14, 3]`\n\n我们为此层级结构定义两个概念：\n1.  **深度 (Depth)**：员工节点的深度是指在其指挥链中严格位于其上方的经理人数。例如，总裁的深度为 0。经理是总裁的员工深度为 1。\n2.  **最低共同经理 (Lowest Common Manager, LCM)**：对于任意两名不同的员工，他们的最低共同经理是同时作为这两名员工祖先，并且在组织树中位于可能的最大深度的经理。\n\n根据此结构，确定员工 `e_1 = 9` 和员工 `e_2 = 7` 的最低共同经理的深度。", "solution": "问题要求解出在由父节点数组 `P` 表示的组织层级中，两名员工 `e_1 = 9` 和 `e_2 = 7` 的最低共同经理（LCM）的深度。\n\n首先，我们来确定树的根节点。根节点是满足 `P[i] = -1` 的员工 `i`。检查数组 `P`，我们发现 `P[8] = -1`，所以员工 8 是总裁，也是树的根节点。\n\n解决方案的核心包括三个主要步骤：\n1.  找到员工 `e_1 = 9` 的指挥链（即到根节点的路径）。\n2.  找到员工 `e_2 = 7` 的指挥链。\n3.  从这两条路径中识别出最低共同经理（LCM）并计算其深度。\n\n**步骤 1：找到员工 9 到根节点的路径。**\n我们向上追溯员工 9 的经理，直到到达根节点（员工 8，其父节点为 -1）。\n- 起始员工是 `9`。\n- `9` 的经理是 `P[9] = 4`。\n- `4` 的经理是 `P[4] = 1`。\n- `1` 的经理是 `P[1] = 3`。\n- `3` 的经理是 `P[3] = 8`。\n- `8` 的经理是 `P[8] = -1`，表示我们已到达根节点。\n\n员工 9 到根节点的路径是 `9 -> 4 -> 1 -> 3 -> 8`。我们可以列出员工 9 的所有祖先集合（包括员工自身）：`{9, 4, 1, 3, 8}`。\n\n**步骤 2：找到员工 7 到根节点的路径。**\n同样，我们向上追溯员工 7 的经理。\n- 起始员工是 `7`。\n- `7` 的经理是 `P[7] = 1`。\n- `1` 的经理是 `P[1] = 3`。\n- `3` 的经理是 `P[3] = 8`。\n- `8` 的经理是 `P[8] = -1`。我们已到达根节点。\n\n员工 7 到根节点的路径是 `7 -> 1 -> 3 -> 8`。员工 7 的祖先集合是 `{7, 1, 3, 8}`。\n\n**步骤 3：识别 LCM 并计算其深度。**\nLCM 是两位员工的共同祖先中深度最大的一个。我们通过对找到的两个祖先集合求交集来找到共同祖先集合：\n共同祖先 = `{9, 4, 1, 3, 8}` $\\cap$ `{7, 1, 3, 8}` = `{1, 3, 8}`。\n\n现在我们必须确定这些共同祖先（`1`、`3` 或 `8`）中哪一个的深度最大。节点的深度是从该节点到达根节点所需的步数。\n\n-   **员工 8 的深度：** 员工 8 是根节点。到根节点的路径是平凡的（0 步）。所以，`depth(8) = 0`。\n-   **员工 3 的深度：** 从 3 到根节点的路径是 `3 -> 8`。这需要 1 步。所以，`depth(3) = 1`。\n-   **员工 1 的深度：** 从 1 到根节点的路径是 `1 -> 3 -> 8`。这需要 2 步。所以，`depth(1) = 2`。\n\n比较共同祖先的深度：`depth(1) = 2`，`depth(3) = 1`，`depth(8) = 0`。最大深度是 2，对应于员工 1。\n\n因此，员工 9 和 7 的最低共同经理（LCM）是员工 1。\n\n问题要求的是这个 LCM 的深度。正如我们刚刚计算的，员工 1 的深度是 2。", "answer": "$$\\boxed{2}$$", "id": "1531615"}]}