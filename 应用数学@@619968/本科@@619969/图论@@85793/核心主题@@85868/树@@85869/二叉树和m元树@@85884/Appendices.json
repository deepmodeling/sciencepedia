{"hands_on_practices": [{"introduction": "在设计基于树的数据结构时，一个核心的考量是如何在容纳大量节点的同时，保持树的高度尽可能小，因为树的高度直接影响到查找、插入等操作的效率。这个练习将引导你探索$m$叉树的高度与其节点容量之间的基本数学关系。通过解决这个问题[@problem_id:1483741]，你将学会如何为一个$m$叉树计算其在给定节点数量下的最小可能高度，这是数据库索引和网络路由等领域的一项基本技能。", "problem": "在图论中，*m*叉树是一种有根树，其中每个节点最多有 $m$ 个子节点。有根树的*高度*定义为从根节点到叶节点的最长路径上的边数。根节点位于第0层。一个包含至少2000个总节点的5叉树（其中 $m=5$），其最小可能高度是多少？", "solution": "一个高度为 $h$ 的 $m$ 叉有根树所能拥有的最大节点数，是通过将每一层（直至第 $h$ 层）完全填满得到的。各层的节点数分别为 $1, m, m^{2}, \\ldots, m^{h}$，因此高度为 $h$ 的树的最大总节点数是一个几何级数\n$$\nT_{m}(h)=\\sum_{i=0}^{h} m^{i}=\\frac{m^{h+1}-1}{m-1}.\n$$\n对于给定的节点数 $N$，要使高度最小化，我们必须确保该高度下的最大容量至少为 $N$，因为高度为 $h$ 的 $m$ 叉树的节点数不能超过 $T_{m}(h)$。因此，最小高度 $h$ 满足\n$$\nT_{5}(h)=\\frac{5^{h+1}-1}{4}\\geq 2000.\n$$\n该不等式等价于\n$$\n5^{h+1}\\geq 4\\cdot 2000+1=8001.\n$$\n我们比较 $5$ 的幂：\n$$\n5^{5}=3125<8001<15625=5^{6}.\n$$\n因此，满足该不等式的最小整数 $h+1$ 是 $6$，从而得出 $h=5$。因此，最小可能高度是 $5$。", "answer": "$$\\boxed{5}$$", "id": "1483741"}, {"introduction": "树的遍历序列，如前序、中序和后序，可以看作是树结构在不同视角下的“快照”。一个有趣且重要的问题是：我们能否仅凭这些一维的序列，重构出唯一的二维树结构？这个练习[@problem_id:1483739]将向你展示，通过结合中序和后序遍历序列，我们确实可以精确地重建出原始的二叉树。这个过程就像一个逻辑解谜，能加深你对树的递归定义和遍历算法本质的理解。", "problem": "在数据结构的研究中，如果一棵二叉树的中序遍历和后序遍历序列都已知，那么这棵二叉树是唯一确定的。\n\n考虑一棵具有七个不同节点的二叉树，这些节点用字符标记。其节点的中序遍历序列为 `D, B, E, A, F, C, G`，后序遍历序列为 `D, E, B, F, G, C, A`。\n\n根据这些信息，确定这棵二叉树的正确前序遍历序列。\n\n请从以下选项中选择你的答案：\n\nA. `A, B, D, E, C, F, G`\n\nB. `A, C, G, F, B, E, D`\n\nC. `D, E, B, F, G, C, A`\n\nD. `D, B, E, A, F, C, G`\n\nE. `A, B, C, D, E, F, G`\n\nF. `G, C, F, A, E, B, D`", "solution": "我们利用树遍历的性质：\n1) 在后序遍历中，最后一个元素是根节点。给定后序遍历 $D, E, B, F, G, C, A$，根节点是 $A$。\n2) 在中序遍历中，根节点左侧的元素属于左子树，右侧的元素属于右子树。给定中序遍历 $D, B, E, A, F, C, G$，我们在 $A$ 处进行分割，得到：\n$$\\text{中序左子树} = D, B, E \\quad \\text{和} \\quad \\text{中序右子树} = F, C, G.$$\n后序遍历序列也相应地在最后一个元素 $A$ 之前（并保持原有顺序）分割为左右子树的序列：\n$$\\text{后序左子树} = D, E, B \\quad \\text{和} \\quad \\text{后序右子树} = F, G, C.$$\n\n重建左子树：\n- 根据 $\\text{后序左子树} = D, E, B$，其根节点是 $B$。\n- 在 $\\text{中序左子树} = D, B, E$ 中，以 $B$ 为分割点：左边是 $D$，右边是 $E$。\n- 因此，左子树是以 $B$ 为根，$D$ 为左孩子，$E$ 为右孩子的树。\n\n重建右子树：\n- 根据 $\\text{后序右子树} = F, G, C$，其根节点是 $C$。\n- 在 $\\text{中序右子树} = F, C, G$ 中，以 $C$ 为分割点：左边是 $F$，右边是 $G$。\n- 因此，右子树是以 $C$ 为根，$F$ 为左孩子，$G$ 为右孩子的树。\n\n计算前序遍历（根、左、右）：\n- 访问根节点 $A$。\n- 然后前序遍历左子树：$B, D, E$。\n- 然后前序遍历右子树：$C, F, G$。\n因此，前序遍历序列为 $A, B, D, E, C, F, G$，对应选项 A。", "answer": "$$\\boxed{A}$$", "id": "1483739"}, {"introduction": "在许多层次结构中，例如文件系统、组织架构或版本控制系统，确定两个节点的“最低公共祖先”（LCA）是一个常见的核心操作。这个练习[@problem_id:1483709]模拟了一个只能通过父节点指针向上导航的场景，要求你分析一个寻找LCA的实用算法的效率。通过推导其操作次数的表达式，你不仅能解决一个具体问题，更能锻炼分析树上算法复杂度的能力，并最终得出一个与节点深度相关的简洁而优美的结论。", "problem": "在一个大规模分布式系统中，一个分层命名空间被建模为一个有根二叉树。该树中的每个节点代表一种资源，并被分配一个唯一的标识符。为了执行特定的一致性和权限检查，系统需要频繁地查找两个给定节点的最近公共祖先（LCA）。两个节点 $u$ 和 $v$ 的 LCA 被定义为同时拥有 $u$ 和 $v$ 作为其后代的最低（即最深）的节点。\n\n系统中每个节点的数据结构仅提供一个与遍历树结构相关的操作：`getParent()`，该操作返回父节点的标识符。根节点是唯一一个调用 `getParent()` 会返回特殊值 `NULL` 的节点。一个节点的“深度”是指从根节点到该节点的路径上的边数，因此根节点的深度为 0。\n\n现设计一个算法来寻找两个不同节点 $u$ 和 $v$ 的 LCA。该算法的操作如下，假设 $u$ 和 $v$ 的深度（分别表示为 $d_u$ 和 $d_v$）已经预先计算好并且无需成本即可获知：\n1.  将两个节点中较深的那个节点通过重复调用 `getParent()` 向上移动，直到它与较浅的节点处于同一深度。\n2.  一旦两个节点处于相同深度，就在每一步中同时对两个节点调用 `getParent()`。重复此过程，直到这两个节点变为同一个节点。这个公共节点就是它们的 LCA。\n\n设节点 $u$ 和 $v$ 的 LCA 位于深度 $d_{LCA}$ 处。推导该算法为找到 LCA 而进行的 `getParent()` 调用的总次数的简化表达式。请用 $d_u$、$d_v$ 和 $d_{LCA}$ 来表示你的答案。", "solution": "设节点的深度为 $d_{u}$ 和 $d_{v}$，LCA的深度为 $d_{LCA}$。定义 $m=\\min(d_{u},d_{v})$ 和 $M=\\max(d_{u},d_{v})$。\n\n阶段 1 (深度对齐)：较深的节点向上移动了 $M-m=|d_{u}-d_{v}|$ 条边，因此在此阶段的调用次数为\n$$\n|d_{u}-d_{v}|.\n$$\n\n对齐后，两个节点都处于深度 $m$。阶段 2 (同步上升)：它们一起向上移动，直到达到深度 $d_{LCA}$。上升的步数是 $m-d_{LCA}$，并且每一步进行两次调用（每个节点一次），所以此阶段的调用次数是\n$$\n2(m-d_{LCA}).\n$$\n\n因此，总调用次数是\n$$\n|d_{u}-d_{v}|+2(m-d_{LCA}).\n$$\n由于 $M-m=|d_{u}-d_{v}|$ 且 $M+m=d_{u}+d_{v}$，我们简化表达式：\n$$\n|d_{u}-d_{v}|+2(m-d_{LCA})=(M-m)+2m-2d_{LCA}=M+m-2d_{LCA}=d_{u}+d_{v}-2d_{LCA}.\n$$\n\n等价地，这等于 $u$ 和 $v$ 到其 LCA 的距离之和：$(d_{u}-d_{LCA})+(d_{v}-d_{LCA})=d_{u}+d_{v}-2d_{LCA}$。", "answer": "$$\\boxed{d_{u}+d_{v}-2d_{LCA}}$$", "id": "1483709"}]}