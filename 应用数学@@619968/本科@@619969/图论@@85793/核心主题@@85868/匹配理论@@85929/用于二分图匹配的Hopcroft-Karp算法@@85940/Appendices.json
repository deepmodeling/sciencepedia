{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。让我们从一个基础练习开始，深入剖析 Hopcroft-Karp 算法的“心脏”——单个增广阶段。通过在一个理想化的完全二分图 $K_{n,n}$ 上从零开始追踪算法的第一阶段，我们将清晰地看到算法如何通过广度优先搜索（BFS）确定最短增广路径的长度，并利用深度优先搜索（DFS）找出一组最大的顶点不相交的此类路径。这个练习 [@problem_id:1512374] 将为你掌握算法的核心机制奠定坚实的基础。", "problem": "一位算法设计者正在分析 Hopcroft-Karp 算法在二分图中寻找最大基数匹配的性能。其考虑的具体图是完全二分图，记作 $K_{n,n}$，其中 $n$ 是一个正整数。该图由两个不相交的顶点集 $U = \\{u_1, u_2, \\dots, u_n\\}$ 和 $V = \\{v_1, v_2, \\dots, v_n\\}$ 构成，其中集合 $U$ 中的每个顶点都与集合 $V$ 中的每个顶点相连。\n\nHopcroft-Karp 算法通过分阶段地增广一个匹配 $M$ 来工作。单个阶段由以下操作序列定义：\n1.  从 U 部的所有未匹配顶点同时启动广度优先搜索 (BFS)。该搜索会构建一个分层图，并确定相对于当前匹配 $M$ 的最短增广路径的长度 $k$。如果搜索没有找到增广路径，则算法终止，因为当前匹配已是最大匹配。\n2.  在 BFS 之后，使用深度优先搜索 (DFS) 来寻找一个顶点不相交的增广路径的极大集 $\\mathcal{P} = \\{P_1, P_2, \\dots, P_m\\}$，其中集合中的每条路径长度均为上一步找到的 $k$。\n3.  然后，通过与找到的所有路径取对称差来增广匹配：$M_{\\text{new}} = M \\oplus P_1 \\oplus P_2 \\oplus \\dots \\oplus P_m$。\n\n分析从一个空匹配 $M_0 = \\emptyset$ 开始。请确定在图 $K_{n,n}$ 上完整执行一轮 Hopcroft-Karp 算法后，匹配的基数（即边的数量）。请将你的答案表示为 $n$ 的函数。", "solution": "我们分析在 $K_{n,n}$ 上从空匹配 $M_{0}=\\emptyset$ 开始的一轮 Hopcroft-Karp 算法。\n\n根据 Hopcroft-Karp 算法中 BFS 步骤的定义，我们从 $U$ 中的所有自由顶点同时开始。当 $M_{0}=\\emptyset$ 时，$U$ 和 $V$ 中的每个顶点都是自由的。BFS 通过遍历从 $U$ 到 $V$ 的未匹配边和从 $V$ 到 $U$ 的匹配边来构建分层。由于初始时没有匹配边，从 $U$ 通过未匹配边进行的第一次扩展会到达 $V$ 中的所有顶点。因为 $V$ 中的所有顶点都是自由的，BFS 会在距离为 $1$ 的位置发现 $V$ 中的自由顶点，因此最短增广路径的长度为\n$$\nk=1.\n$$\n\n因此，每条最短增广路径都是一条连接自由顶点 $u\\in U$ 和自由顶点 $v\\in V$ 的单边 $\\{u,v\\}$。在 DFS 步骤中，算法会找到一个长度为 $k=1$ 的顶点不相交增广路径的极大集 $\\mathcal{P}$，即连接 $U$ 和 $V$ 中自由顶点的不相交边的极大集。令 $m=|\\mathcal{P}|$。\n\n由于该图是完全二分图，$U$ 中的任何自由顶点 $u\\in U$ 都与 $V$ 中的任何自由顶点 $v\\in V$ 相邻。假设 $m<n$ 以导出矛盾。那么，在选择了 $m$ 条不相交的边之后，$U$ 中还剩下 $n-m>0$ 个自由顶点，$V$ 中也剩下 $n-m>0$ 个自由顶点。任取一个剩余的自由顶点 $u\\in U$ 和一个剩余的自由顶点 $v\\in V$；边 $\\{u,v\\}$ 存在于 $K_{n,n}$ 中，它构成了一条长度为 $1$ 的增广路径，且与 $\\mathcal{P}$ 中的所有路径顶点不相交，这与 $\\mathcal{P}$ 的极大性相矛盾。因此，我们必须有\n$$\nm=n.\n$$\n\n增广步骤将 $M_{0}$ 替换为\n$$\nM_{\\text{new}} \\;=\\; M_{0}\\,\\oplus\\,\\bigoplus_{P\\in\\mathcal{P}} P,\n$$\n并且由于每条增广路径使匹配的大小增加 $1$，新匹配的基数为\n$$\n|M_{\\text{new}}| \\;=\\; |M_{0}| + m \\;=\\; 0 + n \\;=\\; n.\n$$\n\n因此，在完整执行一轮之后，匹配的基数为 $n$。", "answer": "$$\\boxed{n}$$", "id": "1512374"}, {"introduction": "理解了单个阶段的运作方式后，一个自然的问题是：为什么 Hopcroft-Karp 算法要如此设计？为什么不简单地每次只寻找一条增广路径，直到找不到为止？这个练习 [@problem_id:1512380] 旨在通过一个精心构建的例子来回答这个问题。你将对比一个简单的“贪心”增广算法与 Hopcroft-Karp 算法的执行效率，从而亲身体会到“分阶段寻找最短增广路径”这一核心思想的力量所在。这不仅关乎算法的正确性，更关乎其卓越的效率。", "problem": "考虑一个由参数 $k$ 定义的二分图 $G = (U \\cup V, E)$。两个顶点划分是 $U = \\{u_1, u_2, \\dots, u_{k+1}\\}$ 和 $V = \\{v_1, v_2, \\dots, v_{k+1}\\}$。对于此特定问题，设参数为 $k=5$。\n\n边集 $E$ 由以下三个边子集的并集构成：\n1.  一组“直接”边：$E_1 = \\{ (u_i, v_i) \\mid 1 \\le i \\le k \\}$\n2.  一组“交叉”边：$E_2 = \\{ (u_i, v_{i+1}) \\mid 1 \\le i < k \\}$\n3.  一组“端点”边：$E_3 = \\{ (u_{k+1}, v_1), (u_k, v_{k+1}) \\}$\n\n总边集为 $E = E_1 \\cup E_2 \\cup E_3$。图中的匹配初始为空。\n\n我们想要比较两种从空匹配开始寻找最大匹配的算法的性能。\n\n**算法 A（简单增广路径）：** 该算法迭代地寻找增广路径。在每次迭代中，它从 $U$ 中可用的自由顶点（按其索引升序考虑，例如 $u_1, u_2, \\dots, u_{k+1}$）开始执行一次深度优先搜索（DFS），以找到第一条可用的增广路径。当从任何顶点进行探索时，其邻居按索引升序访问（例如，从 $u_i$ 出发，如果 $j < l$，则邻居 $v_j$ 在 $v_l$ 之前被探索）。一旦找到一条增广路径，匹配即被增广，然后该次迭代结束。此过程重复进行，直到找不到更多增广路径为止。\n\n**算法 B (Hopcroft-Karp)：** 该算法分阶段（我们称之为迭代）进行。在每次迭代中，它首先使用广度优先搜索（BFS）来确定最短增广路径的长度。然后，它使用深度优先搜索（DFS）来寻找一个由该特定长度的顶点不交增广路径组成的极大集。然后用在此集合中找到的所有路径来增广匹配。该次迭代结束，然后重复此过程。\n\n计算比率 $\\frac{N_A}{N_B}$，其中 $N_A$ 是算法 A 找到最大匹配所需的总迭代次数，而 $N_B$ 是算法 B 所需的总迭代次数。", "solution": "我们为 $k=5$ 实例化该图：\n- $U=\\{u_{1},u_{2},u_{3},u_{4},u_{5},u_{6}\\}$ 和 $V=\\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6}\\}$。\n- $E_{1}=\\{(u_{i},v_{i}) \\mid 1 \\leq i \\leq 5\\}$，$E_{2}=\\{(u_{i},v_{i+1}) \\mid 1 \\leq i \\leq 4\\}$，$E_{3}=\\{(u_{6},v_{1}),(u_{5},v_{6})\\}$，以及 $E=E_{1}\\cup E_{2}\\cup E_{3}$。\n\n首先，最大匹配的大小等于 $6$，因为存在完美匹配\n$$\\{(u_{6},v_{1}),(u_{1},v_{2}),(u_{2},v_{3}),(u_{3},v_{4}),(u_{4},v_{5}),(u_{5},v_{6})\\}$$。\n\n算法 A（简单增广路径，DFS，每次迭代一条路径，按升序从自由顶点 $u$ 开始，并按升序访问邻居）：\n- 从空匹配开始。迭代 $1$：从 $u_{1}$ 出发，访问的第一个邻居是 $v_{1}$，它是自由的，所以我们用 $(u_{1},v_{1})$ 进行增广。\n- 迭代 $2$：从下一个自由顶点 $u$（即 $u_{2}$）出发，访问的第一个邻居是 $v_{2}$（自由的），所以用 $(u_{2},v_{2})$ 进行增广。\n- 迭代 $3$：从 $u_{3}$ 出发，用 $(u_{3},v_{3})$ 进行增广。\n- 迭代 $4$：从 $u_{4}$ 出发，用 $(u_{4},v_{4})$ 进行增广。\n- 迭代 $5$：从 $u_{5}$ 出发，邻居是 $v_{5}$ 和 $v_{6}$；$v_{5}$ 是自由的，所以用 $(u_{5},v_{5})$ 进行增广。\n\n经过这 $5$ 次迭代后，匹配为 $M=\\{(u_{1},v_{1}),(u_{2},v_{2}),(u_{3},v_{3}),(u_{4},v_{4}),(u_{5},v_{5})\\}$；自由顶点是 $u_{6}$ 和 $v_{6}$。迭代 $6$：从 $u_{6}$ 开始，DFS 沿着唯一的交替链（从 $U$ 到 $V$ 走未匹配边，从 $V$ 到 $U$ 走匹配边）到达自由顶点 $v_{6}$：\n$$u_{6}-v_{1}-u_{1}-v_{2}-u_{2}-v_{3}-u_{3}-v_{4}-u_{4}-v_{5}-u_{5}-v_{6}.$$\n这是一条长度为 $11$ 条边的增广路径。沿着它进行增广，得到完美匹配 $\\{(u_{6},v_{1}),(u_{1},v_{2}),(u_{2},v_{3}),(u_{3},v_{4}),(u_{4},v_{5}),(u_{5},v_{6})\\}$。因此算法 A 使用了\n$$N_{A}=6.$$\n\n算法 B (Hopcroft–Karp，其阶段包括：用 BFS 寻找最短增广路径，然后用 DFS 寻找一个由该长度的顶点不交增广路径组成的极大集）：\n- 阶段 $1$ BFS：所有 $u \\in U$ 都是自由的；$V$ 中的每个邻居在距离为 $1$ 时可达，因此最短增广路径长度为 $1$。寻找极大顶点不交最短增广路径集的 DFS，在按升序处理自由顶点 $u$ 和其邻居时，会选择\n$$\\{(u_{1},v_{1}),(u_{2},v_{2}),(u_{3},v_{3}),(u_{4},v_{4}),(u_{5},v_{5})\\},$$\n使得 $u_{6}$ 未被匹配，因为它的唯一邻居 $v_{1}$ 已经在此集合中被使用。该集合在长度为 $1$ 的路径中是极大的。增广后，匹配为 $M=\\{(u_{1},v_{1}),\\dots,(u_{5},v_{5})\\}$。\n- 阶段 $2$ BFS：仅有的自由顶点是 $u_{6}$ 和 $v_{6}$。BFS 分层揭示了唯一的、长度为 $11$ 条边的最短增广路径：\n$$u_{6}-v_{1}-u_{1}-v_{2}-u_{2}-v_{3}-u_{3}-v_{4}-u_{4}-v_{5}-u_{5}-v_{6},$$\nDFS 找到了这条唯一的路径，增广后即可得到完美匹配。\n\n因此，\n$$N_{B}=2.$$\n\n所求的比率是\n$$\\frac{N_{A}}{N_{B}}=\\frac{6}{2}=3.$$", "answer": "$$\\boxed{3}$$", "id": "1512380"}, {"introduction": "算法学习的最终目的是解决实际问题，而现实世界中的系统是动态变化的。如果一个图的结构发生了微小的改变（例如增加了一条边），我们是否需要从头重新运行整个复杂的算法？这个练习 [@problem_id:1512347] 将挑战你将已有的知识应用于动态场景。你需要基于一个已知的最大匹配，判断在图中增加一条新边后，匹配能否被进一步增大，这需要你灵活运用增广路径的概念来高效地更新解，而不是进行不必要的重复计算。", "problem": "考虑一个二分图 $G = (U \\cup V, E)$，其中两个顶点划分是 $U = \\{u_1, u_2, u_3, u_4, u_5\\}$ 和 $V = \\{v_1, v_2, v_3, v_4, v_5\\}$。边集为 $E = \\{(u_1, v_2), (u_2, v_3), (u_4, v_5), (u_2, v_2), (u_3, v_3), (u_4, v_4)\\}$。\n\n已知集合 $M = \\{(u_2, v_2), (u_3, v_3), (u_4, v_4)\\}$ 是图 $G$ 的一个最大匹配。\n\n现在，向图中添加一条新边 $e' = (u_3, v_4)$，形成一个新图 $G' = (U \\cup V, E \\cup \\{e'\\})$。\n\n在新图 $G'$ 中，最大匹配的大小是多少？\n\nA) 2\n\nB) 3\n\nC) 4\n\nD) 5\n\nE) 6", "solution": "给定一个二分图 $G=(U\\cup V,E)$，其中 $U=\\{u_{1},u_{2},u_{3},u_{4},u_{5}\\}$，$V=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\}$，以及\n$$E=\\{(u_{1},v_{2}),(u_{2},v_{3}),(u_{4},v_{5}),(u_{2},v_{2}),(u_{3},v_{3}),(u_{4},v_{4})\\}.$$\n匹配 $M=\\{(u_{2},v_{2}),(u_{3},v_{3}),(u_{4},v_{4})\\}$ 是 $G$ 中的最大匹配，因此 $|M|=3$。在 $M$ 中，$U$ 中未匹配的顶点是 $u_{1},u_{5}$，$V$ 中未匹配的顶点是 $v_{1},v_{5}$。\n\n添加一条新边 $e'=(u_{3},v_{4})$，形成图 $G'$。为了确定最大匹配的大小是否增加，我们在 $G'$ 中寻找一条 $M$-增广路径。根据定义 (Berge 定理)，如果存在一条 $M$-增广路径，那么就存在一个比 $M$ 更大的匹配。\n\n考虑路径\n$$u_{1}-v_{2}-u_{2}-v_{3}-u_{3}-v_{4}-u_{4}-v_{5}.$$\n在这条路径上，相对于匹配 $M$，边在非匹配边和匹配边之间交替出现：\n- $(u_{1},v_{2})\\notin M$,\n- $(u_{2},v_{2})\\in M$,\n- $(u_{2},v_{3})\\notin M$,\n- $(u_{3},v_{3})\\in M$,\n- $(u_{3},v_{4})=e'\\notin M$,\n- $(u_{4},v_{4})\\in M$,\n- $(u_{4},v_{5})\\notin M$.\n\n这条路径从未匹配的顶点 $u_{1}$ 开始，到未匹配的顶点 $v_{5}$ 结束，因此它是 $G'$ 中的一条 $M$-增广路径。沿着这条路径对 $M$ 进行增广（取其与路径上各边的对称差），可以得到一个新的匹配\n$$M'=\\{(u_{1},v_{2}),(u_{2},v_{3}),(u_{3},v_{4}),(u_{4},v_{5})\\},$$\n其大小为 $|M'|=4$。\n\n要说明不存在大小为 5 的匹配，可以观察到在 $G'$ 中，顶点 $u_{5}$ 和 $v_{1}$ 都没有邻接边，因此它们都不能被匹配。因此，任何匹配最多只能包含 4 条边。因此，$G'$ 中的最大匹配大小恰好为 4。\n\n因此，正确选项是 $C$。", "answer": "$$\\boxed{C}$$", "id": "1512347"}]}