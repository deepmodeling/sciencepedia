{"hands_on_practices": [{"introduction": "在应用任何强大的算法之前，专家的第一步是验证是否满足了必要条件。这个练习正是要求你这样做，通过分析为何用于寻找欧拉回路的 Hierholzer 算法不能应用于轮图 $W_5$。掌握这种前置条件的检查，是在实践中正确应用图论定理的基础。[@problem_id:1512112]", "problem": "考虑一个轮图，记作 $W_5$。该图由一个有四个顶点的圈图 $C_4$ 添加一个新的第五个顶点（“轮毂”或“中心顶点”）构成，该中心顶点与 $C_4$ 的四个顶点中的每一个都通过一条边相连。Hierholzer算法提供了一种在图中寻找欧拉回路的方法。欧拉回路是有限图中的一条迹，它恰好访问每条边一次并返回到起始顶点。\n\n下列哪个陈述正确解释了为何Hierholzer算法不能用于在图 $W_5$ 上寻找欧拉回路？\n\nA. 图中所有顶点的度数均为奇数。\n\nB. 该图不是连通的。\n\nC. 中心顶点的度数为奇数。\n\nD. 该图包含度数为奇数的顶点。\n\nE. 图中边的总数为奇数。", "solution": "我们回顾欧拉回路的判定准则：一个有限图存在欧拉回路，当且仅当它是连通的并且每个顶点的度数都是偶数。\n\n对于通过在 $C_{4}$ 的基础上添加一个与所有四个圈顶点相连的轮毂而构造的轮图 $W_{5}$：\n- 设 $h$ 表示轮毂。它与所有四个轮缘顶点相邻，因此\n$$\n\\deg(h)=4,\n$$\n为偶数。\n- 设 $v_{1},v_{2},v_{3},v_{4}$ 是构成 $C_{4}$ 的轮缘顶点。每个轮缘顶点与圈上的两个邻居以及轮毂相邻，因此对于每个 $i$，\n$$\n\\deg(v_{i})=2+1=3,\n$$\n为奇数。\n\n因此，该图包含度数为奇数的顶点（具体来说，是所有四个轮缘顶点）。尽管 $W_{5}$ 是连通的，但它不满足所有顶点度数均为偶数的必要条件，因此它没有欧拉回路。因此，Hierholzer算法不能用于在 $W_{5}$ 上寻找欧拉回路，正确的解释是该图包含度数为奇数的顶点。\n\n为完整起见，选项C是错误的，因为 $\\deg(h)=4$ 是偶数；选项B是错误的，因为 $W_{5}$ 是连通的；选项A是错误的，因为并非所有顶点的度数都是奇数；而选项E在此处是无关且错误的，因为 $|E(W_{5})|=4+4=8$ 是偶数，并且无论如何，边数的奇偶性不是欧拉回路的条件。", "answer": "$$\\boxed{D}$$", "id": "1512112"}, {"introduction": "一旦我们确定存在欧拉回路，Hierholzer 算法就会从追踪一个初始回路开始。这个练习提供了一个在小型多重图上动手模拟这一关键步骤的机会。通过遵循一个清晰、确定的路径选择规则，你将对算法如何启动获得具体的理解。[@problem_id:1512142]", "problem": "考虑一个无向多重图 $G$，其顶点集为 $V = \\{A, B, C, D\\}$，边多重集为 $E = \\{\\{A, C\\}, \\{A, D\\}, \\{B, C\\}, \\{B, D\\}, \\{C, D\\}, \\{C, D\\}\\}$。该图是连通的，且所有顶点的度均为偶数，这保证了欧拉回路的存在。\n\n你的任务是应用 Hierholzer 算法来找到一个欧拉回路。该算法首先找到一个初始回路，然后逐步用子回路对其进行扩展，直到所有边都被包含在内。\n\n你的具体任务是，在以下条件下，确定算法找到的构成**初始回路**的顶点序列：\n1. 回路的起始和结束顶点必须是 $C$。\n2. 在追踪路径时，如果沿未遍历的边有多个下一顶点的选择，必须总是选择按字母顺序排在最前面的顶点。\n\n下列哪个序列代表这个初始回路？\n\nA. C-A-D-B-C\n\nB. C-D-B-C\n\nC. C-A-D-C-D-B-C\n\nD. A-C-B-D-A\n\nE. C-D-A-B-C", "solution": "我们重申 Hierholzer 算法的相关步骤：从指定的顶点开始，沿着一条未使用边的路径行进，在每一步总是选择一条未使用的关联边，直到首次返回起始顶点。这个闭合路径就是初始回路；后续用子回路进行扩展的步骤在之后进行。\n\n该多重图的顶点为 $V=\\{A,B,C,D\\}$，边（含重数）为 $E=\\{\\{A,C\\},\\{A,D\\},\\{B,C\\},\\{B,D\\},\\{C,D\\},\\{C,D\\}\\}$。每个顶点通过未使用边连接的邻接点，按字母顺序列出如下：\n- 从 $C$ 出发：$A$、$B$、$D$（到 $D$ 有两条平行边）。\n- 从 $A$ 出发：$C$、$D$。\n- 从 $B$ 出发：$C$、$D$。\n- 从 $D$ 出发：$A$、$B$、$C$（到 $C$ 有两条平行边）。\n\n从 $C$ 开始，应用规则“在所有可通过未使用边到达的顶点中，总是选择字母顺序最靠前的顶点”：\n1. 在 $C$ 点，可达的邻接点是 $A$、$B$、$D$（两个）。选择 $A$。遍历 $C \\to A$。边 $\\{A,C\\}$ 现已被使用。\n2. 在 $A$ 点，通过未使用边可达的邻接点只有 $D$（因为 $\\{A,C\\}$ 已被使用）。遍历 $A \\to D$。边 $\\{A,D\\}$ 现已被使用。\n3. 在 $D$ 点，通过未使用边可达的邻接点是 $B$ 和 $C$（两个）。根据字母顺序，选择 $B$。遍历 $D \\to B$。边 $\\{B,D\\}$ 现已被使用。\n4. 在 $B$ 点，通过未使用边唯一可达的邻接点是 $C$。遍历 $B \\to C$。边 $\\{B,C\\}$ 现已被使用。\n5. 我们已经返回到起始顶点 $C$。根据 Hierholzer 算法中初始回路的定义，我们在此停止。\n\n因此，初始回路是序列 $C-A-D-B-C$，对应于选项 A。所有其他列出的序列要么违反了字母顺序选择规则，要么违反了指定的起始顶点条件，或者不代表首次返回到 $C$ 的路径。", "answer": "$$\\boxed{A}$$", "id": "1512142"}, {"introduction": "Hierholzer 算法真正的精妙之处在于其“拼接”过程，即通过合并子回路来形成完整的游览路径。这个练习深入探讨了该操作的计算层面，比较了两种不同的数据结构。你将分析在动态数组和链表之间的选择如何极大地影响算法效率，这对任何有志于计算机科学的学生来说都是一个关键的见解。[@problem_id:1512147]", "problem": "在实现用于在连通无向图中寻找欧拉回路的Hierholzer算法时，一个关键操作是“回路拼接”（circuit splicing）。当算法已经追踪出一条回路但尚未使用所有边时，会执行此操作。然后，它会在当前回路上找到一个仍有未使用边的顶点`u`，从`u`开始并结束追踪一条新回路，然后将这条新回路拼接到原始回路中。\n\n考虑一个有$V$个顶点和$E$条边的连通图，其中每个顶点的度都为偶数。你的任务是分析Hierholzer算法的两种不同C++实现的性能，这两种实现的唯一区别在于存储回路中顶点序列所使用的数据结构。\n\n**方法1：** 回路的顶点序列存储在`std::vector<Vertex>`中，这是一个动态数组。为了将一个新回路（一个向量`new_tour`）拼接到现有回路（`main_tour`）中顶点`u`首次出现的位置，该实现会找到指向`main_tour`中`u`的迭代器`it`，并使用`main_tour.insert(it + 1, new_tour.begin() + 1, new_tour.end())`。\n\n**方法2：** 回路的顶点序列存储为一个自定义的循环双向链表的节点。每个节点包含一个顶点以及指向回路中下一个和上一个节点的指针。拼接操作通过重新连接常数数量的指针来合并两个循环链表。对于此分析，如果你有指向节点的指针，可以在$O(1)$时间内访问该列表中的任何节点。\n\n设单次拼接操作的复杂度为将一条新子回路合并到主回路中所花费的时间。设整体复杂度为整个算法找到最终欧拉回路的最坏情况时间。\n\n以下哪个四元组正确表示了`(方法1中单次拼接的最坏情况复杂度, 方法1的整体最坏情况复杂度, 方法2中单次拼接的最坏情况复杂度, 方法2的整体最坏情况复杂度)`的复杂度？\n\nA. $(O(E), O(V \\cdot E), O(1), O(V+E))$\n\nB. $(O(E), O(E^2), O(\\log V), O(E \\log V))$\n\nC. $(O(V), O(V^2), O(1), O(V+E))$\n\nD. $(O(E), O(V \\cdot E), O(V), O(V^2))$\n\nE. $(O(\\log E), O(E \\log E), O(1), O(V+E))$", "solution": "给定一个有$V$个顶点和$E$条边的连通无向图，所有顶点的度都为偶数，因此存在欧拉回路。Hierholzer算法重复地形成回路并进行拼接。我们分析两种实现，它们仅在用于表示回路的数据结构上有所不同。\n\n本次分析中拼接操作的定义：仅指将新子回路合并到主回路中的时间（不包括寻找`u`或追踪新子回路的时间）。\n\n方法1 (`std::vector`)：\n- 回路存储为顶点向量。要将一个长度为$k$（插入的顶点数，不包括重叠的第一个`u`）的新回路拼接到当前长度为$m$的主回路的位置$i$处，需要：\n  - 移动主向量中位置$i$之后的后缀，成本为$\\Theta(m - i)$。\n  - 将新回路中的$k$个顶点复制到空隙中，成本为$\\Theta(k)$。\n- 因此，当$i$接近开头且$m$和$k$尽可能大时，单次拼接的最坏情况成本为\n$$\n\\text{single-splice cost} = O((m - i) + k) = O(E).\n$$\n\n为了界定总拼接次数，观察Hierholzer算法的一个标准属性：\n- 在任何拼接步骤中，我们会在当前主回路上选择一个顶点`u`，该顶点在未使用边的残留图中至少有一条未使用的关联边。\n- 在所有顶点度均为偶数的图中，从`u`开始追踪新环路的子程序将一直运行，直到它返回`u`且`u`没有未使用的关联边为止。实际上，这个过程会耗尽包含`u`的残留图连通分量中的所有未使用边。\n- 因此，在拼接完这个子回路后，顶点`u`将没有未使用的关联边，并且永远不会再被选为拼接点。\n- 两个不同的拼接不能从同一个顶点开始。因此，拼接的次数最多为曾经有过未使用关联边的顶点数量，即最多为$V$。\n\n因此，在方法1中：\n- 每次拼接在最坏情况下的成本为$O(E)$。\n- 最多有$V$次拼接。\n- 所有对每条边的处理（标记/移除已使用的边）贡献了$O(E)$，但这并不会改变由拼接主导的渐进界。\n\n因此，方法1的整体最坏情况复杂度为\n$$\nO(V \\cdot E).\n$$\n\n方法2（循环双向链表）：\n- 在节点`u`处拼接两个循环链表需要更改常数数量的指针，前提是我们已经有了指向相关节点的指针。因此，\n$$\n\\text{single-splice cost} = O(1).\n$$\n- 根据与上述相同的推理，拼接次数同样最多为$V$。\n- 每条边被遍历并移除恰好一次，因此边处理的时间为$O(E)$。\n\n因此，方法2的整体最坏情况复杂度为\n$$\nO(V + E).\n$$\n\n按指定顺序（方法1单次拼接，方法1整体，方法2单次拼接，方法2整体）收集这四个量，得到：\n$$\n(O(E),\\, O(V \\cdot E),\\, O(1),\\, O(V+E)).\n$$\n\n在选项中，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1512147"}]}