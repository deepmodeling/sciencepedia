{"hands_on_practices": [{"introduction": "广度优先搜索 (BFS) 和深度优先搜索 (DFS) 是图论中最基本的两种遍历算法，但它们生成的生成树结构却可能大相径庭。此练习旨在探索一个核心问题：在何种图结构下，这两种截然不同的搜索策略会产生完全相同的生成树？通过分析和比较不同拓扑结构下图的遍历结果，你将建立起关于图结构如何影响算法行为的直观理解 [@problem_id:1483515]。", "problem": "考虑一个简单的无向连通图 $G=(V,E)$，其中 $V$ 是顶点集，$E$ 是边集。遍历此类图的两种标准算法是广度优先搜索 (BFS) 和深度优先搜索 (DFS)。从源顶点 $v_s$ 开始的遍历会生成该图连通分量的一个生成树，根据所用算法的不同，称为 BFS 树或 DFS 树。\n\n这些树的结构取决于图的拓扑结构、起始顶点以及当一个顶点有多个未访问邻居时用于打破僵局的规则。对于本问题，假设当有多个未访问的邻居可用时，算法总是优先访问整数标签最小的邻居。如果 BFS 树和 DFS 树以同一顶点为根，并且具有完全相同的边集，则认为它们在结构上是相同的。\n\n下面选项中的所有图共享相同的顶点集 $V = \\{1, 2, 3, 4, 5\\}$。每个图的遍历都从源顶点 $v_s = 1$ 开始。\n\n在这些条件下，下列哪个图会产生结构上相同的 BFS 树和 DFS 树？\n\nA. 图 $G_A$ 的边集为 $E_A = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}\\}$。\n\nB. 图 $G_B$ 的边集为 $E_B = \\{\\{1,2\\}, \\{1,3\\}, \\{1,4\\}, \\{2,3\\}, \\{2,4\\}, \\{3,4\\}, \\{1,5\\}\\}$。\n\nC. 图 $G_C$ 的边集为 $E_C = \\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}, \\{1,4\\}, \\{4,5\\}, \\{5,1\\}\\}$。\n\nD. 图 $G_D$ 的边集为 $E_D = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,1\\}\\}$。", "solution": "我们分析在以 $1$ 为根并使用最小标签打破僵局规则的情况下，BFS 和 DFS 生成树何时会产生相同的边集。BFS 使用队列逐层探索顶点，当从 $u$ 首次发现 $v$ 时添加树边 $(u,v)$；DFS 通过使用栈/递归总是前进到最小的未访问邻居来探索，当递归到未访问的邻居时添加树边。\n\n选项 A：$E_{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}$。这是一个路径 $1$–$2$–$3$–$4$–$5$。\n- 从 $1$ 开始 DFS：每一步都前进到最小的未访问邻居，产生路径 $1 \\to 2 \\to 3 \\to 4 \\to 5$。DFS 树的边是 $E_{T,\\mathrm{DFS}}^{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}$。\n- 从 $1$ 开始 BFS：从 $1$ 发现 $2$，然后从 $2$ 发现 $3$，然后从 $3$ 发现 $4$，然后从 $4$ 发现 $5$。BFS 树的边是 $E_{T,\\mathrm{BFS}}^{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}$。\n因此 $E_{T,\\mathrm{DFS}}^{A}=E_{T,\\mathrm{BFS}}^{A}$，所以它们是相同的。\n\n选项 B：$E_{B}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{2,3\\},\\{2,4\\},\\{3,4\\},\\{1,5\\}\\}$。这是在 $\\{1,2,3,4\\}$ 上的 $K_{4}$ 再加上 $\\{1,5\\}$。\n- 从 $1$ 开始 DFS：访问 $2$，然后到 $3$，然后到 $4$，回溯到 $1$，然后到 $5$。DFS 树的边是 $E_{T,\\mathrm{DFS}}^{B}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{1,5\\}\\}$。\n- 从 $1$ 开始 BFS：按递增顺序发现 $1$ 的所有邻居：$2,3,4,5$。BFS 树的边是 $E_{T,\\mathrm{BFS}}^{B}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{1,5\\}\\}$。\n这两个集合不同，所以不相同。\n\n选项 C：$E_{C}=\\{\\{1,2\\},\\{2,3\\},\\{3,1\\},\\{1,4\\},\\{4,5\\},\\{5,1\\}\\}$。这是两个共享顶点 $1$ 的三角形 $\\{1,2,3\\}$ 和 $\\{1,4,5\\}$。\n- 从 $1$ 开始 DFS：访问 $2$，然后到 $3$，回溯到 $1$，然后到 $4$，然后到 $5$。DFS 树的边是 $E_{T,\\mathrm{DFS}}^{C}=\\{\\{1,2\\},\\{2,3\\},\\{1,4\\},\\{4,5\\}\\}$。\n- 从 $1$ 开始 BFS：从 $1$ 发现 $2,3,4,5$。BFS 树的边是 $E_{T,\\mathrm{BFS}}^{C}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{1,5\\}\\}$。\n这两个集合不同，所以不相同。\n\n选项 D：$E_{D}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,1\\}\\}$，一个 $5$-环。\n- 从 $1$ 开始 DFS：访问路径为 $1 \\to 2 \\to 3 \\to 4 \\to 5$。DFS 树的边是 $E_{T,\\mathrm{DFS}}^{D}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}$。\n- 从 $1$ 开始 BFS：从 $1$ 发现 $2$ 和 $5$，然后从 $2$ 发现 $3$，从 $5$ 发现 $4$。BFS 树的边是 $E_{T,\\mathrm{BFS}}^{D}=\\{\\{1,2\\},\\{1,5\\},\\{2,3\\},\\{5,4\\}\\}$。\n这两个集合不同，所以不相同。\n\n因此，在所述条件下，只有选项 A 产生结构上相同的 BFS 和 DFS 树。", "answer": "$$\\boxed{A}$$", "id": "1483515"}, {"introduction": "我们已经知道 BFS 和 DFS 生成的树通常是不同的，但它们的差异究竟能有多大？本练习将带你探究一个极端情况，即在一个精心设计的图（轮图）中，BFS 生成的树高度最小，而 DFS 生成的树高度最大。通过计算轮图上 BFS 树和 DFS 树的高度差，你将深刻体会到 BFS “广度”扩展与 DFS “深度”探索的本质区别，这对理解算法的性能和适用场景至关重要 [@problem_id:1483546]。", "problem": "考虑一个由 $N$ 个顶点构成的简单、连通、无向图，称为轮图，记作 $W_N$。顶点被标记为 $v_0, v_1, \\dots, v_{N-1}$。顶点 $v_0$ 被称为“轮毂”，它与每个“轮辐”顶点 $v_i$（其中 $i \\in \\{1, 2, \\dots, N-1\\}$）通过一条边相连。轮辐顶点也连接成一个环，包含边 $(v_i, v_{i+1})$（$i=1, \\dots, N-2$）以及边 $(v_{N-1}, v_1)$。\n\n我们从轮毂顶点 $v_0$ 开始执行两种独立的图遍历：广度优先搜索 (BFS) 和深度优先搜索 (DFS)。这些遍历分别生成一个 BFS 树和一个 DFS 树，它们都是以 $v_0$ 为根的 $W_N$ 的生成树。对于这两种算法，如果一个顶点有多个未访问的邻居可供选择，算法必须总是先探索顶点索引最小的邻居。\n\n有根树的高度定义为从根到任意叶节点的最长路径上的边数。设 $H_{BFS}$ 为 BFS 树的高度，$H_{DFS}$ 为 DFS 树的高度。\n\n对于一个有 $N=50$ 个顶点的轮图，计算差值 $H_{DFS} - H_{BFS}$ 的值。", "solution": "我们分析以轮毂 $v_{0}$ 为根的轮图 $W_{N}$ 的 BFS 和 DFS 生成树，遵循当存在多个未访问的邻居时，选择索引最小的顶点的规则。\n\n根据定义，$v_{0}$ 与每个轮辐顶点 $v_{i}$（其中 $i \\in \\{1,\\dots,N-1\\}$）相邻，并且轮辐顶点通过边 $(v_{i},v_{i+1})$（$i=1,\\dots,N-2$）和边 $(v_{N-1},v_{1})$ 构成一个环。\n\n首先，考虑以 $v_{0}$ 为根的 BFS 树。在开始时，BFS 发现 $v_{0}$ 的所有邻居，即 $v_{1},v_{2},\\dots,v_{N-1}$，并将它们置于距离 $v_{0}$ 为 $1$ 的位置。当之后处理每个 $v_{i}$ 时，它的所有邻居都已经被发现：$v_{0}$ 是根节点，而每个轮辐邻居 $v_{i-1}$ 或 $v_{i+1}$ 也都已从 $v_{0}$ 被发现。没有顶点会出现在层级 $1$ 之外。因此，BFS 树是一个以 $v_{0}$ 为中心的星形图，其高度为 $H_{BFS}=1$。\n\n接下来，考虑遵循最小索引规则的、以 $v_{0}$ 为根的 DFS 树。从 $v_{0}$ 出发，索引最小的邻居是 $v_{1}$，所以第一条 DFS 边是 $(v_{0},v_{1})$。在 $v_{1}$ 处，其邻居为 $\\{v_{0},v_{2},v_{N-1}\\}$；排除已访问的 $v_{0}$，最小的未访问邻居是 $v_{2}$，所以下一条边是 $(v_{1},v_{2})$。依此类推，对于 $k=2,\\dots,N-2$，在 $v_{k}$ 处，其邻居 $\\{v_{0},v_{k-1},v_{k+1}\\}$ 中的未访问邻居在最小索引规则下只剩下 $\\{v_{k+1}\\}$（因为 $v_{0}$ 和 $v_{k-1}$ 均已被访问），DFS 沿着 $(v_{k},v_{k+1})$ 继续进行。在 $v_{N-1}$ 处，其所有邻居 $v_{0},v_{N-2},v_{1}$ 都已被访问，因此 DFS 一路回溯到 $v_{0}$，此时所有顶点均已被访问。因此，DFS 树的边构成了路径 $(v_{0},v_{1}),(v_{1},v_{2}),\\dots,(v_{N-2},v_{N-1})$，这条路径包含从 $v_{0}$ 到 $v_{N-1}$ 的 $N-1$ 条边。因此，DFS 树是一个以一端为根、长度为 $N-1$ 的路径，其高度为 $H_{DFS}=N-1$。\n\n对于 $N=50$，我们有：\n$$\nH_{DFS}-H_{BFS}=(50-1)-1=48\n$$", "answer": "$$\\boxed{48}$$", "id": "1483546"}, {"introduction": "深度优先搜索 (DFS) 的强大之处不仅在于构建生成树，更在于它能对有向图中的所有边进行分类，从而揭示图的深层结构。这些边的类型（树边、后向边、前向边和交叉边）为许多高级算法提供了基础。这个练习将引导你识别一种特殊的“交叉边”，它连接了 DFS 森林中两个不相关的子树。掌握边分类是理解拓扑排序、查找强连通分量等高级图算法的关键一步 [@problem_id:1483505]。", "problem": "考虑一个有向图 $G = (V, E)$，其顶点集为 $V = \\{s, a, b, c, d\\}$，边集为 $E = \\{(s, a), (s, c), (a, b), (c, d), (d, b)\\}$。\n\n从顶点 $s$ 开始，对该图执行深度优先搜索 (DFS)。该算法遵循一个标准约定：当一个顶点有多个未访问的邻居时，按字母顺序选择访问它们。\n\n在有向图的 DFS 中，根据边 $(u, v)$ 的源顶点 $u$ 和目标顶点 $v$ 在最终生成的 DFS 树/森林中的关系，边被分为四种类型：\n1.  **树边 (Tree edge)**：通过遍历 $(u, v)$ 第一次发现顶点 $v$ 时所经过的边。\n2.  **返祖边 (Back edge)**：边 $(u, v)$ 中，$v$ 是 $u$ 的祖先。\n3.  **前向边 (Forward edge)**：非树边 $(u, v)$ 中，$v$ 是 $u$ 的后代。\n4.  **交叉边 (Cross edge)**：既不是树边、返祖边，也不是前向边的边。它通常连接两个不同的子树，其中 $v$ 已被完全探索（即它的发现时间和完成时间都在 $u$ 被发现之前）。\n\n根据指定的 DFS 遍历，下列哪条边是交叉边？\n\nA. (s, c)\nB. (a, b)\nC. (d, b)\nD. (c, d)", "solution": "为了确定每条边的类型，我们必须从顶点 $s$ 开始对图 $G$ 进行深度优先搜索（DFS），并遵循按字母顺序访问未访问邻居的规则。我们将为每个顶点记录其发现时间（首次访问顶点时的时间）和完成时间（该顶点的所有后代都已被访问完毕时的时间）。我们将发现时间记为 $d[v]$，完成时间记为 $f[v]$，并维护一个全局计时器 `time`。\n\n**分步 DFS 遍历：**\n\n1.  **从 `s` 开始**：`time` = 1。$d[s]$ = 1。`s` 的邻居是 `a` 和 `c`。按字母顺序，我们先访问 `a`。探索边 `(s, a)`。\n2.  **移动到 `a`**：`time` = 2。$d[a]$ = 2。顶点 `a` 未被访问过，所以 `(s, a)` 是一条 **树边**。`a` 的邻居是 `b`。我们访问 `b`。探索边 `(a, b)`。\n3.  **移动到 `b`**：`time` = 3。$d[b]$ = 3。顶点 `b` 未被访问过，所以 `(a, b)` 是一条 **树边**。顶点 `b` 没有出边。我们完成了从 `b` 的探索。\n4.  **完成 `b`**：`time` = 4。$f[b]$ = 4。回溯到 `a`。\n5.  **返回 `a`**：顶点 `a` 没有其他未访问的邻居。我们完成了从 `a` 的探索。\n6.  **完成 `a`**：`time` = 5。$f[a]$ = 5。回溯到 `s`。\n7.  **返回 `s`**：`s` 的下一个未访问邻居是 `c`。我们访问 `c`。探索边 `(s, c)`。\n8.  **移动到 `c`**：`time` = 6。$d[c]$ = 6。顶点 `c` 未被访问过，所以 `(s, c)` 是一条 **树边**。`c` 的邻居是 `d`。我们访问 `d`。探索边 `(c, d)`。\n9.  **移动到 `d`**：`time` = 7。$d[d]$ = 7。顶点 `d` 未被访问过，所以 `(c, d)` 是一条 **树边**。`d` 的邻居是 `b`。我们探索边 `(d, b)`。\n10. **分析边 `(d, b)`**：目标顶点 `b` 已经被访问过。我们必须对这条边进行分类。我们将 `b` 的发现时间和完成时间与 `d` 的发现时间进行比较。\n    - $d[b]$ = 3\n    - $f[b]$ = 4\n    - $d[d]$ = 7\n    交叉边 $(u, v)$ 的条件是 $d[v] < f[v] < d[u]$。对于我们的边 `(d, b)`，这对应于 $d[b] < f[b] < d[d]$。代入数值，我们得到 $3 < 4 < 7$，这是成立的。因此，`(d, b)` 是一条 **交叉边**。\n11. **返回 `d`**：顶点 `d` 没有其他邻居。我们完成了从 `d` 的探索。\n12. **完成 `d`**：`time` = 8。$f[d]$ = 8。回溯到 `c`。\n13. **返回 `c`**：顶点 `c` 没有其他未访问的邻居。我们完成了从 `c` 的探索。\n14. **完成 `c`**：`time` = 9。$f[c]$ = 9。回溯到 `s`。\n15. **返回 `s`**：顶点 `s` 没有其他未访问的邻居。我们完成了从 `s` 的探索。\n16. **完成 `s`**：`time` = 10。$f[s]$ = 10。DFS 遍历完成。\n\n**发现/完成时间总结：**\n- `s`: $d=1, f=10$\n- `a`: $d=2, f=5$\n- `b`: $d=3, f=4$\n- `c`: $d=6, f=9$\n- `d`: $d=7, f=8$\n\n**分析选项：**\n\n-   **A. (s, c)**：当从 `s` 探索这条边时，`c` 尚未被访问。这是一条 **树边**。\n-   **B. (a, b)**：当从 `a` 探索这条边时，`b` 尚未被访问。这是一条 **树边**。\n-   **C. (d, b)**：当从 `d` 探索这条边时，`b` 已经被访问并完成（$d[b]=3, f[b]=4$）。因为 $d[b] < f[b] < d[d]$，所以这是一条 **交叉边**。\n-   **D. (c, d)**：当从 `c` 探索这条边时，`d` 尚未被访问。这是一条 **树边**。\n\n因此，选项中唯一的交叉边是 `(d, b)`。", "answer": "$$\\boxed{C}$$", "id": "1483505"}]}