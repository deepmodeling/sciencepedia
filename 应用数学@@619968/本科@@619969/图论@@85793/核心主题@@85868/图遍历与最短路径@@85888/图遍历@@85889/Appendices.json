{"hands_on_practices": [{"introduction": "掌握图遍历的第一步是透彻理解广度优先搜索（BFS）等算法的运行机制。本练习提供了一个实际场景，即在一个网络中验证节点配置，你将需要一步步地追踪一个基于BFS的验证算法。通过手动模拟队列和已访问集合的变化，你将对BFS如何逐层探索图建立起牢固的直观认识 [@problem_id:1508906]。", "problem": "一家电信公司正在部署一个由 $N$ 座传输塔组成的新无线网络。为了防止信号干扰，网络中的相邻塔必须分配不同的频率信道。一位初级工程师为所有塔提出了一个初始频率分配方案。您的任务是分析一个特定的验证算法的输出，该算法旨在检查此分配方案是否存在冲突。\n\n该网络被建模为一个简单的无向图，其中塔是顶点，索引从$0$到$N-1$，如果两个顶点对应的塔距离足够近以至于会产生干扰，则这两个顶点之间存在一条边。频率分配以一个数组的形式给出，其中第$i$个元素是分配给塔$i$的信道。\n\n该验证算法的执行过程如下：\n1. 它对图执行一次广度优先搜索（BFS）遍历。\n2. 遍历从索引最小的顶点（顶点0）开始。如果图有多个不连通的分量，遍历将只探索与顶点0相连的分量。\n3. 维护一个待访问顶点的队列。初始时，它只包含顶点0。同时维护一个已访问顶点的集合，初始时也只包含顶点0。\n4. 在每一步中，从队列中取出一个顶点`u`。对于它的每一个邻居`v`（按索引值升序排列），算法会检查顶点`v`是否与顶点`u`分配了相同的频率。\n5. 如果 `frequency(u) = frequency(v)`，则检测到冲突。算法立即终止并输出顶点索引对 `(u, v)`。\n6. 如果 `frequency(u) != frequency(v)` 并且 `v` 尚未被访问，则将 `v` 标记为已访问并加入队列。\n7. 如果BFS完成且没有发现任何此类冲突，算法将报告该分配方案在已探索的分量中是有效的。\n\n考虑一个有$N=8$座塔的网络，编号从0到7。\n频率分配由信道给出：`[红色, 绿色, 蓝色, 绿色, 红色, 蓝色, 绿色, 红色]`，分别对应塔0到7。\n干扰链路（边）是：\n`(0, 1), (0, 4), (1, 2), (1, 3), (1, 6), (2, 5), (3, 7), (4, 5), (6, 7)`\n\n对于给定的网络配置，该验证算法产生的输出是什么？\n\nA. 点对 `(1, 3)`\n\nB. 点对 `(0, 4)`\n\nC. 点对 `(2, 5)`\n\nD. 频率分配有效。\n\nE. 点对 `(4, 5)`", "solution": "我们将网络建模为顶点为 $0,1,\\ldots,7$ 的无向图，其边集为 $\\{(0,1),(0,4),(1,2),(1,3),(1,6),(2,5),(3,7),(4,5),(6,7)\\}$。分配的频率（信道）是 $c(0)=\\text{红色}$, $c(1)=\\text{绿色}$, $c(2)=\\text{蓝色}$, $c(3)=\\text{绿色}$, $c(4)=\\text{红色}$, $c(5)=\\text{蓝色}$, $c(6)=\\text{绿色}$, $c(7)=\\text{红色}$。\n\n该验证算法从索引最小的顶点0开始执行BFS。它将队列初始化为 $[0]$，已访问集合初始化为 $\\{0\\}$。在每一步中，它从队列中取出一个顶点$u$，并按索引升序扫描其邻居$v$。对于每个邻居$v$，它首先检查是否有$c(u)=c(v)$。如果是，则立即终止并输出点对$(u,v)$。如果$c(u)\\neq c(v)$且$v$尚未被访问，则将$v$标记为已访问并将其加入队列。\n\n执行过程：\n- 从队列中取出 $u=0$。顶点0的邻居是 $\\{1,4\\}$，按顺序为 $[1,4]$。\n  - 对于 $v=1$：$c(0)=\\text{红色}$ 且 $c(1)=\\text{绿色}$，所以 $c(0)\\neq c(1)$。由于1未被访问，将其标记为已访问，得到集合 $\\{0,1\\}$，并将1加入队列，队列变为 $[1]$。\n  - 对于 $v=4$：$c(0)=\\text{红色}$ 且 $c(4)=\\text{红色}$，所以 $c(0)=c(4)$。检测到冲突，算法立即终止，输出点对 $(0,4)$。\n\n由于算法在检测到第一个冲突时即停止，所以输出是 $(0,4)$，对应选项B。", "answer": "$$\\boxed{B}$$", "id": "1508906"}, {"introduction": "图遍历算法的用途远不止于寻找路径，它还是揭示图内在结构的强大工具。本练习要求你判断两点之间是否存在偶数长度的路径，这个问题初看起来可能有些复杂。你将发现，通过一次标准的图遍历，可以巧妙地判断图的二分性，从而解决此问题，由此将遍历过程与图的一个深层结构特性联系起来 [@problem_id:1508937]。", "problem": "在容错通信网络的设计中，工程师们正在探索一种冗余协议。为了验证一个数据包，它必须能够通过一条具有偶数条链路的路径，从源节点传输到目标节点。路径被定义为由边连接的、一系列不重复的顶点。\n\n该网络拓扑由一个无向图表示，该图包含8个节点，标记为A到H。连接（边）由以下邻接表给出：\n- A: [B, D]\n- B: [A, C, G]\n- C: [B, D, F]\n- D: [A, C, E]\n- E: [D, F, H]\n- F: [C, E, G]\n- G: [B, F, H]\n- H: [E, G]\n\n根据这个网络结构，以下哪个陈述是正确的？\n\nA. 存在从节点A到节点G的偶数条链路的路径，但不存在从节点B到节点E的此类路径。\n\nB. 存在从节点B到节点E的偶数条链路的路径，但不存在从节点A到节点G的此类路径。\n\nC. 对于(A, G)和(B, E)两对节点，都存在偶数条链路的路径。\n\nD. 对于(A, G)和(B, E)两对节点，都不存在偶数条链路的路径。", "solution": "我们需要确定，对于给定的无向图，在指定的顶点对之间是否存在长度为偶数的简单路径（所有顶点均不重复的路径）。我们使用的关键图论原理是二分图的特性：一个图是二分图，当且仅当它不包含奇数环，这等价于它的顶点可以被划分到两个不相交的集合中，使得每条边都连接着分属两个不同集合的顶点。在一个分区集为 $X$ 和 $Y$ 的二分图中，任何路径都在 $X$ 和 $Y$ 之间交替，因此对于任何从 $u$ 到 $v$ 的路径，其长度 $\\ell$ 满足\n$$\n\\ell \\equiv \n\\begin{cases}\n0 \\pmod{2}, & \\text{如果 } u,v \\in X \\text{ 或 } u,v \\in Y, \\\\\n1 \\pmod{2}, & \\text{如果 } u \\in X, v \\in Y \\text{ 或 } u \\in Y, v \\in X.\n\\end{cases}\n$$\n因此，当图在两个顶点之间是连通时，它们之间存在偶数长度的路径，当且仅当它们位于二分划分的同一部分中。\n\n现在我们通过构建一个有效的二着色（划分）来证明该图是二分图。首先将 $A$ 放入 $X$。由于 $A$ 与 $B$ 和 $D$ 相邻，我们必须将 $B,D$ 放入 $Y$。由于 $B$ 与 $C$ 和 $G$ 相邻，我们必须将 $C,G$ 放入 $X$。由于 $D$ 与 $C$ 和 $E$ 相邻，这要求 $C \\in X$（与之前一致）并且 $E \\in X$。接着，由于 $C$ 与 $F$ 相邻，我们将 $F$ 放入 $Y$。由于 $E$ 与 $H$ 相邻，我们将 $H$ 放入 $Y$。检查所有剩余的邻接关系：$F$ 与 $C,E,G$ 相邻，它们都在 $X$ 中；$G$ 与 $B,F,H$ 相邻，它们都在 $Y$ 中；$H$ 与 $E,G$ 相邻，它们都在 $X$ 中。这个分配是一致的，因此该图是二分图，其划分为\n$$\nX = \\{A,C,E,G\\}, \\quad Y = \\{B,D,F,H\\}.\n$$\n\n应用奇偶性规则：\n- 对于 $(A,G)$，我们有 $A \\in X$ 和 $G \\in X$，所以任何 $A$–$G$ 路径的长度都为偶数，因此存在偶数长度的路径。一个明确的例子是 $A-B-G$，其长度为 $2$ 且使用不重复的顶点。\n- 对于 $(B,E)$，我们有 $B \\in Y$ 和 $E \\in X$，所以任何 $B$–$E$ 路径的长度都为奇数。因此，不存在从 $B$ 到 $E$ 的偶数长度路径。例如，不存在长度为 $2$ 的路径，因为从 $B$ 到其任何邻居 $\\{A,C,G\\}$，这些邻居都不与 $E$ 相邻，而二分划分的论证则从根本上排除了所有偶数长度的可能性。\n\n因此，存在从 $A$ 到 $G$ 的偶数长度路径，但不存在从 $B$ 到 $E$ 的偶数长度路径，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1508937"}, {"introduction": "在大型网络中，路径查找算法的效率至关重要。本练习向你介绍一种巧妙的优化技术——双向搜索，它通过同时从源点和终点开始探索来显著加快搜索速度。通过模拟此算法的执行过程，你不仅能巩固对BFS的理解，还能体会到算法设计上的改进如何解决现实世界（如服务器路由）中的性能瓶颈问题 [@problem_id:1508918]。", "problem": "一家名为“ConnectSphere”的科技公司正在为其服务器网状网络测试一种新的路由算法。该网络由一组服务器组成，这些服务器由整数ID标识。数据可以通过双向链接在特定的服务器对之间传输。该算法名为“双向收敛搜索 (Bidirectional Convergence Search, BCS)”，旨在寻找源服务器 `s` 和目标服务器 `t` 之间的一条通信路径。\n\nBCS 算法规定如下：\n- 同时启动两个搜索过程：一个从 `s` 开始的“正向搜索”和一个从 `t` 开始的“反向搜索”。\n- 算法维护两个已访问服务器的集合：`V_s` 用于正向搜索，`V_t` 用于反向搜索。初始时，`V_s = {s}` 且 `V_t = {t}`。\n- 算法还维护两个待访问服务器的先进先出队列，代表每次搜索的前沿：`Q_s` 和 `Q_t`。初始时，`Q_s` 仅包含 `s`，`Q_t` 仅包含 `t`。\n- 算法以离散、交替的步骤进行（一个正向扩展后跟一个反向扩展）。\n\n1.  **正向扩展步骤**：正向搜索扩展一层。对于 `Q_s` 当前前沿中的每个服务器 `u`，检查其所有邻居。任何尚未被添加到 `V_s` 的邻居 `v` 都会被添加到 `V_s` 中，并被加入一个用于下一个正向前沿的临时队列。在处理完当前 `Q_s` 中的所有服务器后，`Q_s` 被这个临时队列替换。\n2.  **正向终止检查**：正向扩展完成后，算法检查集合 `V_s` 和 `V_t` 是否有任何共同的服务器。如果 `V_s \\cap V_t` 不是空集，算法立即终止。\n3.  **反向扩展步骤**：如果算法尚未终止，则反向搜索扩展一层。此步骤与正向扩展类似：对于 `Q_t` 中的每个服务器 `u`，任何不在 `V_t` 中的邻居 `v` 都会被添加到 `V_t` 中，并被加入一个用于下一个反向前沿的临时队列。然后 `Q_t` 被这个临时队列替换。\n4.  **反向终止检查**：反向扩展后，算法再次检查 `V_s \\cap V_t` 是否非空。如果是，算法终止。否则，过程从正向扩展步骤开始重复。\n\n考虑一个由12个服务器组成的网络，其连接由以下服务器ID对给出：\n(1, 2), (1, 3), (1, 4), (2, 5), (3, 6), (3, 7), (4, 8), (5, 9), (6, 9), (7, 10), (8, 11), (9, 12), (10, 12), (11, 12).\n\n源服务器是 `s=2`，目标服务器是 `t=11`。您的任务是确定当算法终止时，它所访问过的唯一服务器的总数。这是两个已访问集合的并集的大小，即 `|V_s \\cup V_t|`。", "solution": "将网络视为一个无向图，其邻居集合由给定的双向链接确定。从这些服务器ID对中，可以得出邻居集合为\n$$\n\\begin{aligned}\n&N(1)=\\{2,3,4\\},\\quad N(2)=\\{1,5\\},\\quad N(3)=\\{1,6,7\\},\\quad N(4)=\\{1,8\\},\\\\\n&N(5)=\\{2,9\\},\\quad N(6)=\\{3,9\\},\\quad N(7)=\\{3,10\\},\\quad N(8)=\\{4,11\\},\\\\\n&N(9)=\\{5,6,12\\},\\quad N(10)=\\{7,12\\},\\quad N(11)=\\{8,12\\},\\quad N(12)=\\{9,10,11\\}.\n\\end{aligned}\n$$\n用源 $s=2$ 和目标 $t=11$ 初始化双向搜索：\n$$\nV_{s}=\\{2\\},\\quad Q_{s}=[2],\\quad V_{t}=\\{11\\},\\quad Q_{t}=[11].\n$$\n正向扩展步骤1（处理 $Q_{s}$ 中的所有节点）：\n从 $2$ 添加未访问过的邻居 $1,5$：\n$$\nV_{s}=\\{2,1,5\\},\\quad Q_{s}=[1,5].\n$$\n正向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5\\}\\cap\\{11\\}=\\varnothing.\n$$\n反向扩展步骤1（处理 $Q_{t}$ 中的所有节点）：\n从 $11$ 添加未访问过的邻居 $8,12$：\n$$\nV_{t}=\\{11,8,12\\},\\quad Q_{t}=[8,12].\n$$\n反向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5\\}\\cap\\{11,8,12\\}=\\varnothing.\n$$\n正向扩展步骤2（处理 $Q_{s}$ 中的所有节点）：\n从 $1$ 添加未访问过的邻居 $3,4$；从 $5$ 添加未访问过的邻居 $9$：\n$$\nV_{s}=\\{2,1,5,3,4,9\\},\\quad Q_{s}=[3,4,9].\n$$\n正向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5,3,4,9\\}\\cap\\{11,8,12\\}=\\varnothing.\n$$\n反向扩展步骤2（处理 $Q_{t}$ 中的所有节点）：\n从 $8$ 添加未访问过的邻居 $4$；从 $12$ 添加未访问过的邻居 $9,10$：\n$$\nV_{t}=\\{11,8,12,4,9,10\\},\\quad Q_{t}=[4,9,10].\n$$\n反向终止检查：\n$$\nV_{s}\\cap V_{t}=\\{2,1,5,3,4,9\\}\\cap\\{11,8,12,4,9,10\\}=\\{4,9\\}\\neq\\varnothing,\n$$\n因此算法在此处终止。终止时访问过的唯一服务器总数为\n$$\n|V_{s}\\cup V_{t}|=\\left|\\{1,2,3,4,5,9\\}\\cup\\{11,8,12,4,9,10\\}\\right|=\\left|\\{1,2,3,4,5,8,9,10,11,12\\}\\right|=10.\n$$", "answer": "$$\\boxed{10}$$", "id": "1508918"}]}