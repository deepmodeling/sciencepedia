{"hands_on_practices": [{"introduction": "理解一个算法的最佳方式之一就是亲手执行它。这个练习将引导你逐步模拟贝尔曼-福特算法的核心机制——边的迭代松弛。通过手动追踪几轮迭代中距离估计值的更新，你将具体地体会到算法是如何在图中，尤其是在存在负权重边的情况下，逐步逼近并找到更短路径的。[@problem_id:1482434]", "problem": "在一个未来的研究项目中，科学家们正在研究一个由五个时间节点（标记为 A、B、C、D 和 E）组成的网络，这些节点通过有向的“时子链接”互联。每条链接 $(u, v)$ 都有一个相关的整数“时间偏移”值，代表从节点 $u$ 遍历到节点 $v$ 时所经历的时间扭曲。一些高级链接甚至允许负的时间偏移。\n\n该网络由一个有向带权图表示，其顶点为 $V = \\{A, B, C, D, E\\}$。时子链接的集合及其相应的时间偏移（权重）以元组 $(u, v, w)$ 的列表形式给出：\n$E = [(\\text{A}, \\text{B}, 6), (\\text{A}, \\text{C}, 7), (\\text{B}, \\text{D}, 5), (\\text{B}, \\text{E}, -4), (\\text{C}, \\text{B}, -2), (\\text{C}, \\text{D}, 8), (\\text{D}, \\text{E}, 9), (\\text{E}, \\text{A}, 2), (\\text{E}, \\text{C}, 7)]$\n\n为了计算从一个指定的源节点到所有其他节点的最小可能总时间偏移，科研团队采用了贝尔曼-福特（Bellman-Ford）算法。源节点是 A。该算法将节点 A 的时间偏移估计值初始化为 0，并将所有其他节点的估计值初始化为无穷大。然后，它迭代地对边进行松弛操作。在算法的每一轮中，边都按照它们在上面列表 $E$ 中出现的确切顺序进行顺序松弛。\n\n在 Bellman-Ford 算法完成整整两轮之后，节点 $(\\text{A}, \\text{B}, \\text{C}, \\text{D}, \\text{E})$ 的时间偏移估计值的有序元组是什么？\n\nA. $(0, 5, 7, 10, 1)$\n\nB. $(0, 5, 7, 11, 2)$\n\nC. $(0, 6, 7, 11, 2)$\n\nD. $(0, 5, 7, 10, 2)$\n\nE. $(0, 4, 5, 10, 1)$", "solution": "我们从源点 A 开始应用 Bellman-Ford 算法，初始估计值为 $d(A)=0$ 和 $d(B)=d(C)=d(D)=d(E)=+\\infty$。松弛规则是：对于每条边 $(u,v,w)$，如果 $d(u)+w  d(v)$，则设置 $d(v) \\leftarrow d(u)+w$。每一轮中，边都按给定的顺序进行处理。\n\n第一轮：\n1. $(A,B,6): d(A)+6=0+6=6+\\infty\\Rightarrow d(B)=6$。\n2. $(A,C,7): d(A)+7=0+7=7+\\infty\\Rightarrow d(C)=7$。\n3. $(B,D,5): d(B)+5=6+5=11+\\infty\\Rightarrow d(D)=11$。\n4. $(B,E,-4): d(B)-4=6-4=2+\\infty\\Rightarrow d(E)=2$。\n5. $(C,B,-2): d(C)-2=7-2=5d(B)=6\\Rightarrow d(B)=5$。\n6. $(C,D,8): d(C)+8=7+8=15\\notd(D)=11\\Rightarrow$ 无变化。\n7. $(D,E,9): d(D)+9=11+9=20\\notd(E)=2\\Rightarrow$ 无变化。\n8. $(E,A,2): d(E)+2=2+2=4\\notd(A)=0\\Rightarrow$ 无变化。\n9. $(E,C,7): d(E)+7=2+7=9\\notd(C)=7\\Rightarrow$ 无变化。\n\n第一轮后：$(d(A),d(B),d(C),d(D),d(E))=(0,5,7,11,2)$。\n\n第二轮：\n1. $(A,B,6): 0+6=6\\not5\\Rightarrow$ 无变化。\n2. $(A,C,7): 0+7=7\\not7\\Rightarrow$ 无变化。\n3. $(B,D,5): 5+5=1011\\Rightarrow d(D)=10$。\n4. $(B,E,-4): 5-4=12\\Rightarrow d(E)=1$。\n5. $(C,B,-2): 7-2=5\\not5\\Rightarrow$ 无变化。\n6. $(C,D,8): 7+8=15\\not10\\Rightarrow$ 无变化。\n7. $(D,E,9): 10+9=19\\not1\\Rightarrow$ 无变化。\n8. $(E,A,2): 1+2=3\\not0\\Rightarrow$ 无变化。\n9. $(E,C,7): 1+7=8\\not7\\Rightarrow$ 无变化。\n\n第二轮后：$(d(A),d(B),d(C),d(D),d(E))=(0,5,7,10,1)$，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1482434"}, {"introduction": "计算出最短路径的成本通常只是问题的一半，我们往往还需要知道这条路径本身。这个练习将我们的关注点从计算过程转移到解读最终结果。你将学习如何利用前驱节点数组 (predecessor array)——贝尔曼-福特算法的一个关键输出来回溯并重构出从源点到目标点的最短路径所经过的实际节点序列。[@problem_id:1482432]", "problem": "一位网络管理员正在分析一个小型有向计算机网络，以找到从源服务器 S 出发的最有效路由路径。该网络由四个节点组成：S（源点）、A、B 和 T（目标点）。节点之间的链接有一个相关的成本，该成本可以是正数（代表延迟），也可以是负数（代表处理加速或优化链接）。\n\n该网络由以下有向边及其对应的成本定义：\n- S 到 A：成本 4\n- S 到 B：成本 2\n- S 到 T：成本 7\n- A 到 B：成本 -3\n- A 到 T：成本 6\n- B 到 T：成本 4\n\n管理员以 S 为源顶点运行 Bellman-Ford 算法，以找到到所有其他节点的最短路径。算法完成后，最终的最短路径距离估计值 (D) 和前驱顶点 (P) 计算如下：\n\n| 顶点 `v` | 距离 `D[v]` | 前驱 `P[v]` |\n|:----------:|:----------------:|:------------------:|\n|      S     |         0        |        NIL         |\n|      A     |         4        |         S          |\n|      B     |         1        |         A          |\n|      T     |         5        |         B          |\n\n根据 Bellman-Ford 算法的这个最终输出，从源点 S 到目标点 T 的最短路径是什么？\n\nA. S → T\n\nB. S → B → T\n\nC. S → A → T\n\nD. S → A → B → T\n\nE. 无法根据所提供的信息确定路径。", "solution": "我们使用 Bellman-Ford 算法的路径重构属性：收敛后，前驱映射 $P$ 定义了一个以源点 $S$ 为根的最短路径树。具体来说，对于任何前驱为 $P[v]=u$ 的顶点 $v \\neq S$，其最终距离满足\n$$D[v] = D[u] + w(u,v)$$\n并且在前驱图中从 $S$ 到 $v$ 的唯一路径是一条总成本为 $D[v]$ 的最短路径。\n\n为了获得从 $S$ 到 $T$ 的最短路径，我们从 T 开始回溯前驱：\n- $P[T] = B$ 意味着最短 $S \\to T$ 路径上的最后一条边是 $B \\to T$。\n- $P[B] = A$ 意味着前一条边是 $A \\to B$。\n- $P[A] = S$ 意味着第一条边是 $S \\to A$。\n- $P[S] = \\text{NIL}$ 表示我们已经到达了源点。\n\n因此，从前驱链重构出的路径是 $S \\to A \\to B \\to T$。根据 Bellman-Ford 算法的正确性条件，\n$$D[T] = D[B] + w(B,T) = D[A] + w(A,B) + w(B,T) = D[S] + w(S,A) + w(A,B) + w(B,T)$$\n所以，这条由前驱定义的路径就是从 $S$ 到 $T$ 的最短路径。\n\n对照选项，这正是选项 D。", "answer": "$$\\boxed{D}$$", "id": "1482432"}, {"introduction": "贝尔曼-福特算法最关键的功能之一是它能够检测到负权重环，这种环在许多应用中代表了无解或异常的情况。当算法报告存在这样一个环时，仅仅知道它的存在是不够的，我们还需要定位它。本练习将向你展示一种诊断方法：如何通过回溯前驱节点数组来精确定位负权重环中的具体节点，这对于调试网络模型至关重要。[@problem_id:1482418]", "problem": "在奇异粒子物理学的研究中，网络模型常被用来分析粒子间的相互作用。考虑一个有向图来表示一个网络，其中节点是稳定的粒子状态，边代表可能的跃迁。边 `(u,v)` 的权重对应于粒子从状态 `u` 跃迁到状态 `v` 时的能量变化。环路上的负总权重意味着一种物理上的异常情况，即粒子可以无休止地获得能量。\n\n该网络由一组状态（顶点）`V = {S, A, B, C, D, E}` 和一组跃迁（带权重的有向边）定义。状态 `S` 是所有粒子的初始状态。Bellman-Ford 算法被用来分析从状态 `S` 开始的能量景观。\n\n跃迁及其能量变化如下所示，按算法每次迭代中松弛边的规范顺序给出：\n1.  (S, A)，权重：4\n2.  (S, B)，权重：2\n3.  (A, C)，权重：3\n4.  (B, C)，权重：6\n5.  (B, D)，权重：1\n6.  (C, E)，权重：5\n7.  (D, C)，权重：-7\n8.  (E, D)，权重：1\n\n在运行 Bellman-Ford 算法的主循环 $|V|-1 = 5$ 次迭代后，该算法计算出以下前驱数组 `pred`，该数组存储了从 `S` 出发的最短路径上的前一个状态：\n*   `pred[S] = null`\n*   `pred[A] = S`\n*   `pred[B] = S`\n*   `pred[C] = D`\n*   `pred[D] = E`\n*   `pred[E] = C`\n\n在最后的环路检测步骤中，算法以相同的规范顺序重新检查所有边。它发现边 `(C, E)`（权重为 5）是第一个违反最短路径最优性条件的边，这表明存在一个从 `S` 可达的负权重环路。\n\n你的任务是重建这个负权重环路。标准的步骤是从违规边的目标顶点（本例中为 `v=E`）开始，使用前驱数组向后追溯，直到某个顶点第二次被遇到。环路中的顶点是这个重复顶点第一次和第二次遇到之间访问过的那些顶点。\n\n以下哪个选项正确地列出了检测到的负权重环路中的顶点序列，该序列按照它们在环路路径上出现的顺序列出，并从字母顺序最靠前的顶点开始？\n\nA) C, E, D\n\nB) E, D, C\n\nC) D, C, E\n\nD) S, B, D\n\nE) B, C, E, D", "solution": "如果在完成主循环后，存在一条边 $(u,v)$ 使得松弛条件仍然被违反，那么 Bellman-Ford 算法就检测到了一个可达的负权重环路。给定的违规边是 $(C,E)$。\n\n根据提供的前驱数组：\n- $\\mathrm{pred}[C]=D$\n- $\\mathrm{pred}[D]=E$\n- $\\mathrm{pred}[E]=C$\n\n从违规边的目标顶点 $v=E$ 开始，并追溯前驱直到一个顶点重复出现：\n- $E$ (第一次访问)\n- $\\mathrm{pred}[E]=C$\n- $\\mathrm{pred}[C]=D$\n- $\\mathrm{pred}[D]=E$ ($E$ 的第二次访问)\n\n因此，环路中的顶点是 $E$ 的第一次和第二次遇到之间访问过的顶点：$E, C, D$。形成有向环路的前驱边是 $D \\to C$、$C \\to E$ 和 $E \\to D$，所以沿着有向边的环路顺序是 $D \\to C \\to E \\to D$。\n\n从 $\\{C,D,E\\}$ 中字母顺序最靠前的顶点（即 $C$）开始，序列是 $C, E, D$。\n\n验证总权重为负：\n$$w(C,E)+w(E,D)+w(D,C)=5+1+(-7)=-10.$$\n\n因此，正确的选项是序列 $C, E, D$。", "answer": "$$\\boxed{A}$$", "id": "1482418"}]}