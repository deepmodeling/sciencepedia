{"hands_on_practices": [{"introduction": "深度优先搜索 (DFS) 不仅仅是访问图中的所有顶点。通过记录每个顶点的“发现时间”和“完成时间”，我们能捕捉到搜索过程的丰富结构信息。这些时间戳是许多高级图算法的基石，例如拓扑排序和寻找强连通分量。这个练习将带你手动模拟DFS的执行过程，精确计算这些时间戳，从而为理解更复杂的应用打下坚实的基础。[@problem_id:1362166]", "problem": "一个软件构建系统使用“依赖解析协议”来确定一组相互连接的代码模块的正确编译顺序。该协议在一个由模块及其依赖关系组成的图上运行。这个过程涉及为每个模块分配两个时间戳：“发现时间”和“完成时间”。\n\n协议如下：\n1.  一个全局时间戳计数器初始化为 1。\n2.  该过程从一个起始模块开始。如果未指定起始模块，则从按字母顺序排在最前面的模块开始。\n3.  当一个模块首次被访问时，它被标记为“已发现”，其发现时间被设为全局时间戳的当前值，并且时间戳加 1。\n4.  系统接着检查刚刚发现的模块的邻居。它会按照字母顺序，对找到的第一个未访问的邻居递归调用该协议。\n5.  在对一个模块所有邻居的递归调用都返回之后，该模块被标记为“已完成”，其完成时间被设为全局时间戳的当前值，并且时间戳加 1。然后该过程返回到其被调用的地方。\n6.  如果初始遍历完成但仍有未访问的模块，则从按字母顺序排在最前面的未访问模块开始重复该过程。\n\n考虑一个有八个模块的项目：A, B, C, D, E, F, G, H。依赖关系是对称的（即，如果 X 依赖于 Y，那么 Y 也依赖于 X），定义如下：\n-   模块 A 与 B、D 和 E 相连。\n-   模块 B 与 A 和 C 相连。\n-   模块 C 与 B、G 和 H 相连。\n-   模块 D 与 A 和 F 相连。\n-   模块 E 与 A 和 F 相连。\n-   模块 F 与 D、E 和 G 相连。\n-   模块 G 与 C 和 F 相连。\n-   模块 H 与 C 相连。\n\n从模块 A 开始执行协议，确定所有八个模块的发现时间和完成时间。以下哪个选项正确列出了所有模块的 `(发现时间, 完成时间)` 对，并按从 A 到 H 的字母顺序列出？\n\nA. A:(1,16), B:(8,9), C:(7,12), D:(2,15), E:(4,5), F:(3,14), G:(6,13), H:(10,11)\n\nB. A:(1, 16), B:(2, 15), C:(3, 14), D:(8, 9), E:(6, 7), F:(5, 10), G:(4, 11), H:(12, 13)\n\nC. A:(1, 16), B:(2, 15), C:(3, 14), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(12, 13)\n\nD. A:(1, 16), B:(2, 15), C:(3, 12), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(13, 14)", "solution": "我们执行一次深度优先遍历，全局时间戳 $t$ 初始化为 $1$，从 $A$ 开始，并按字母顺序探索邻居。首次访问节点 $v$ 时，设置其发现时间 $d(v)=t$ 并将 $t$ 增加 $1$。在 $v$ 的邻居的所有递归调用都返回后，设置其完成时间 $f(v)=t$ 并将 $t$ 增加 $1$。\n\n初始化 $t=1$。\n\n从 $A$ 开始，其邻居按顺序为 $B,D,E$。\n$$d(A)=1,\\quad t=2$$\n前往 $B$（$A$ 的第一个未访问的邻居）。$B$ 的邻居按顺序为 $A,C$。\n$$d(B)=2,\\quad t=3$$\n$A$ 已被访问过；前往 $C$。$C$ 的邻居按顺序为 $B,G,H$。\n$$d(C)=3,\\quad t=4$$\n$B$ 已被访问过；前往 $G$。$G$ 的邻居按顺序为 $C,F$。\n$$d(G)=4,\\quad t=5$$\n$C$ 已被访问过；前往 $F$。$F$ 的邻居按顺序为 $D,E,G$。\n$$d(F)=5,\\quad t=6$$\n前往 $D$（第一个未访问的）。$D$ 的邻居按顺序为 $A,F$。\n$$d(D)=6,\\quad t=7$$\n$A$ 和 $F$ 都已被访问过；完成 $D$：\n$$f(D)=7,\\quad t=8$$\n返回到 $F$；下一个邻居是 $E$（未访问）。\n$$d(E)=8,\\quad t=9$$\n$E$ 的邻居是 $A,F$，两者均已被访问过；完成 $E$：\n$$f(E)=9,\\quad t=10$$\n返回 $F$；下一个邻居 $G$ 已被访问过；完成 $F$：\n$$f(F)=10,\\quad t=11$$\n返回 $G$；没有更多邻居；完成 $G$：\n$$f(G)=11,\\quad t=12$$\n返回 $C$；下一个邻居是 $H$（未访问）。\n$$d(H)=12,\\quad t=13$$\n$H$ 的邻居 $C$ 已被访问过；完成 $H$：\n$$f(H)=13,\\quad t=14$$\n返回 $C$；没有更多邻居；完成 $C$：\n$$f(C)=14,\\quad t=15$$\n返回 $B$；没有更多邻居；完成 $B$：\n$$f(B)=15,\\quad t=16$$\n返回 $A$；剩余的邻居 $D,E$ 已被访问过；完成 $A$：\n$$f(A)=16,\\quad t=17$$\n\n因此，发现/完成时间如下：\n- $A:(1,16)$\n- $B:(2,15)$\n- $C:(3,14)$\n- $D:(6,7)$\n- $E:(8,9)$\n- $F:(5,10)$\n- $G:(4,11)$\n- $H:(12,13)$\n\n这与选项 C 匹配。", "answer": "$$\\boxed{C}$$", "id": "1362166"}, {"introduction": "虽然递归为深度优先搜索提供了简洁的表达方式，但使用显式栈的迭代方法同样重要，它能帮助我们更深入地理解算法的底层机制，并避免递归深度过大的问题。通过追踪栈内容的变化，你可以直观地看到DFS是如何通过“后进先出”的原则来探索图的深处。这个练习能让你精确地体验这一过程，揭示递归背后由栈驱动的执行本质。[@problem_id:1496233]", "problem": "考虑一个无向图 $G = (V, E)$，它由顶点集 $V = \\{0, 1, 2, 3, 4\\}$ 和构成一个轮图 $W_5$ 的边集 $E$ 定义。在这个图中，顶点0是中心顶点，与所有其他顶点相连。剩余的顶点 $\\{1, 2, 3, 4\\}$ 形成一个环，其中边连接1到2，2到3，3到4，以及4回到1。\n\n该图的邻接表定义如下，每个顶点的邻居按数字升序列出：\n- `Adj(0): [1, 2, 3, 4]`\n- `Adj(1): [0, 2, 4]`\n- `Adj(2): [0, 1, 3]`\n- `Adj(3): [0, 2, 4]`\n- `Adj(4): [0, 1, 3]`\n\n你需要对这个图执行一次迭代深度优先搜索（DFS）。该算法按以下步骤进行：\n1. 初始化一个空栈和一个空的已访问顶点集合。\n2. 将起始顶点推入栈中。\n3. 当栈不为空时，弹出一个顶点 `u`。\n4. 如果 `u` 已被访问过，则不执行任何操作并继续下一次迭代。\n5. 如果 `u` 未被访问过，则将其标记为已访问。然后，按顶点标签的降序（例如，先处理邻居4，再处理邻居3）遍历 `u` 的邻居 `v`。对于每个这样的邻居 `v`，如果 `v` 尚未被访问过，就将其推入栈中。\n\nDFS 遍历从顶点 0 开始。你的任务是确定，在顶点 2 从栈中弹出后，栈的内容（从栈顶到栈底）是什么。\n\n下列哪个列表表示那一刻栈的内容？\n\nA. `[4, 2, 3, 4]`\n\nB. `[3, 4]`\n\nC. `[2, 4, 2, 3, 4]`\n\nD. `[1, 3, 2, 1]`\n\nE. `[2, 3, 4]`", "solution": "我们使用一个栈来执行指定的迭代DFS，按降序推入邻居，并且仅当顶点未被访问时才将其推入栈中（如果一个顶点在先前被推入栈时还未被访问，那么栈中可能会存在重复的顶点）。\n\n初始化栈和已访问集合为空。将起始顶点 $0$ 推入栈，此时栈为 [0]。弹出 $0$；由于 $0$ 未被访问，将其标记为已访问，因此 visited $=\\{0\\}$。处理 $0$ 的邻居，即 $[1,2,3,4]$；降序为 $[4,3,2,1]$。它们都未被访问，因此按该顺序推入，生成的栈为 [4, 3, 2, 1]，栈顶为 $1$。\n\n弹出 $1$；它未被访问，因此标记 visited $=\\{0,1\\}$。$1$ 的邻居是 $[0,2,4]$；降序为 $[4,2,0]$。其中，$4$ 和 $2$ 未被访问，所以先推入 $4$ 再推入 $2$。栈变为 [4, 3, 2, 4, 2]，栈顶为 $2$。\n\n现在弹出顶点 $2$。在这次弹出操作之后，处理 $2$ 之前，栈的内容（从栈底到栈顶）是 [4, 3, 2, 4]。因此，从栈顶到栈底，栈的内容是 [4, 2, 3, 4]，这与选项 A 相符。", "answer": "$$\\boxed{A}$$", "id": "1496233"}, {"introduction": "真正掌握算法意味着不仅能实现它，更能将其改造以解决新的、更复杂的问题。许多现实世界中的寻路任务都带有额外的约束条件，标准的DFS或BFS算法无法直接适用。这个问题要求你设计一个能够找到颜色交替路径的搜索策略，这是一个将问题约束转化为算法逻辑的绝佳练习，它展示了图搜索算法作为通用问题解决框架的强大威力。[@problem_id:1496213]", "problem": "一个先进的机器人探险家正在一颗新发现的行星上探索一个隧道网络。这些隧道为不同的运输系统进行了颜色编码。该网络可以建模为一个无向图，其中顶点代表交叉口，边代表隧道。每条隧道都被染成红色（'R'）或蓝色（'B'）。\n\n探险家必须从一个起始交叉口移动到一个目标交叉口。为了节省能源并防止系统过载，其移动被限制在“严格交替颜色路径”上。如果路径上任意三个连续顶点 $v_i, v_{i+1}, v_{i+2}$，边 $(v_i, v_{i+1})$ 的颜色与边 $(v_{i+1}, v_{i+2})$ 的颜色不同，则该路径被认为是具有严格交替颜色序列的。路径必须是简单的，这意味着它不能多次访问任何一个交叉口。路径的第一条边可以是任意一种颜色。\n\n给定隧道网络的结构：\n- 交叉口（顶点）集合是 `{0, 1, 2, 3, 4, 5, 6, 7, 8}`。\n- 起始交叉口是 `0`，目标交叉口是 `8`。\n- 隧道（边）以 `(交叉口1, 交叉口2, 颜色)` 三元组列表的形式给出：\n  - `(0, 1, 'B')`\n  - `(0, 2, 'R')`\n  - `(1, 3, 'R')`\n  - `(2, 5, 'B')`\n  - `(3, 4, 'B')`\n  - `(3, 6, 'R')`\n  - `(4, 6, 'R')`\n  - `(4, 7, 'R')`\n  - `(5, 3, 'R')`\n  - `(6, 8, 'B')`\n  - `(7, 8, 'R')`\n\n您的任务是确定从交叉口 `0` 到交叉口 `8` 的可能的最短严格交替颜色路径的长度。路径的长度定义为其包含的边的数量。如果不存在这样的路径，您的答案应为 -1。", "solution": "我们将隧道网络建模为一个顶点集为 $\\{0,1,2,3,4,5,6,7,8\\}$ 且边带颜色的无向图。严格交替颜色路径要求连续的边具有不同的颜色，并且路径必须是简单的（没有重复的顶点）。我们通过增加路径长度来寻找从 $0$ 到 $8$ 的最短严格交替简单路径。\n\n长度为 $2$：路径 $0\\to x\\to 8$ 必须满足 $x$ 同时与 $0$ 和 $8$ 相邻，并且两条边的颜色不同。邻接点为 $\\mathcal{N}(0)=\\{1,2\\}$ 和 $\\mathcal{N}(8)=\\{6,7\\}$。由于 $\\{1,2\\}\\cap\\{6,7\\}=\\varnothing$，因此不存在长度为 $2$ 的路径。\n\n长度为 $3$：考虑路径 $0\\to a\\to b\\to 8$。最后一步必须从 $8$ 的一个邻接点出发。\n- 如果 $b=6$，则边 $(6,8)$ 的颜色是 $\\text{B}$，所以前一条边 $(a,6)$ 的颜色必须是 $\\text{R}$，这要求 $a\\in\\{3,4\\}$。那么第一条边 $(0,a)$ 的颜色必须是 $\\text{B}$，这要求 $a=1$。由于 $1\\notin\\{3,4\\}$，这种情况是不可能的。\n- 如果 $b=7$，则边 $(7,8)$ 的颜色是 $\\text{R}$，所以边 $(a,7)$ 的颜色必须是 $\\text{B}$。顶点 $7$ 没有颜色为 $\\text{B}$ 的关联边，所以这种情况是不可能的。\n因此，不存在长度为 $3$ 的交替路径。\n\n长度为 $4$：考虑路径 $0\\to a\\to b\\to c\\to 8$。\n- 从颜色为 $\\text{B}$ 的边 $(0,1)$ 开始，则要求边 $(1,3)$ 的颜色为 $\\text{R}$，接着边 $(3,4)$ 的颜色为 $\\text{B}$，因此最后一条边必须是从 $4$ 到 $8$ 且颜色为 $\\text{R}$。但不存在边 $(4,8)$，所以这个分支失败了。\n- 从颜色为 $\\text{R}$ 的边 $(0,2)$ 开始，则要求边 $(2,5)$ 的颜色为 $\\text{B}$，接着边 $(5,3)$ 的颜色为 $\\text{R}$，因此最后一条边必须是从 $3$ 到 $8$ 且颜色为 $\\text{B}$。但不存在边 $(3,8)$，所以这个分支失败了。\n因此，不存在长度为 $4$ 的交替路径。\n\n长度为 $5$：尝试路径\n$$0\\to 1\\to 3\\to 4\\to 6\\to 8.$$\n各条边的颜色依次为 $(0,1):\\text{B}$，$(1,3):\\text{R}$，$(3,4):\\text{B}$，$(4,6):\\text{R}$，$(6,8):\\text{B}$，它们严格地以 $\\text{B},\\text{R},\\text{B},\\text{R},\\text{B}$ 的形式交替。所有顶点都是不同的，所以该路径是简单的。这就得到了一个长度为 $5$ 的有效的严格交替简单路径。\n\n由于不存在长度为 $2,3,4$ 的路径，但存在长度为 $5$ 的路径，因此从 $0$ 到 $8$ 的可能的最短严格交替简单路径的长度为 $5$。", "answer": "$$\\boxed{5}$$", "id": "1496213"}]}