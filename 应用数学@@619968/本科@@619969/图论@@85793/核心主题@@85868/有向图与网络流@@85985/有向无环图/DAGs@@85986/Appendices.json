{"hands_on_practices": [{"introduction": "有向无环图 (DAG) 的定义性特征是其“无环”属性。本练习旨在让你将这个核心概念应用于项目管理中的一个实际场景，其中的依赖关系绝不能形成逻辑循环。通过分析一组给定的任务，你将学会如何发现这些循环依赖，这是验证任何基于 DAG 建模的系统的关键技能。[@problem_id:1496996]", "problem": "一家软件公司的项目经理正在为一个新的基于微服务的应用程序规划构建流程。该应用程序由六个不同的模块组成：`Auth`、`Billing`、`Catalog`、`Delivery`、`Frontend` 和 `Orders`。构建流程受一组依赖关系的制约，其中一个模块必须在另一个模块之前编译和部署。这些依赖关系以有序对 `(U, V)` 的形式给出，表示模块 `U` 必须在模块 `V` 的构建开始之前成功构建。\n\n此项目的完整依赖关系集合 `D` 为：\n`D = {(Frontend, Auth), (Auth, Orders), (Orders, Billing), (Catalog, Frontend), (Billing, Auth), (Orders, Delivery)}`\n\n分析这组依赖关系，以确定项目构建流程的结构特性。以下哪个陈述准确地描述了这种情况？\n\nA. 依赖关系有效，一个可能的构建顺序是：`Catalog, Frontend, Auth, Orders, Billing, Delivery`。\n\nB. 依赖关系有效，一个可能的构建顺序是：`Catalog, Frontend, Auth, Orders, Delivery, Billing`。\n\nC. 依赖关系包含逻辑矛盾，具体来说是形成了一个长度为 3 的环。\n\nD. 依赖关系包含逻辑矛盾，具体来说是形成了一个长度为 4 的环。\n\nE. 依赖关系集合有效，但存在多种不同的构建顺序。", "solution": "定义有向图 $G=(V,E)$，其中 $V=\\{\\text{Auth}, \\text{Billing}, \\text{Catalog}, \\text{Delivery}, \\text{Frontend}, \\text{Orders}\\}$ 且 $E=D=\\{(\\text{Frontend}, \\text{Auth}), (\\text{Auth}, \\text{Orders}), (\\text{Orders}, \\text{Billing}), (\\text{Catalog}, \\text{Frontend}), (\\text{Billing}, \\text{Auth}), (\\text{Orders}, \\text{Delivery})\\}$。一个有效的构建顺序存在的充分必要条件是 $G$ 是一个有向无环图；等价地，当且仅当图中没有有向环，此时存在拓扑排序。\n\n从 $E$ 中，观察到三条边\n$$(\\text{Auth}, \\text{Orders}),\\quad (\\text{Orders}, \\text{Billing}),\\quad (\\text{Billing}, \\text{Auth}).$$\n这些边意味着存在一个有向环\n$$\\text{Auth} \\to \\text{Orders} \\to \\text{Billing} \\to \\text{Auth},$$\n这是一个长度为 $3$ 的环。因此， $G$ 不是无环图，不存在拓扑排序。所以：\n- 任何提议的具体构建顺序（例如选项 A 和 B 中的顺序）都无法满足所有依赖关系；例如，两者都将 `Auth` 列在 `Billing` 之前，这违反了 $(\\text{Billing}, \\text{Auth})$。\n- 由于存在环，依赖关系集是无效的，因此不存在“集合有效但有多种不同构建顺序”的情况。\n\n因此，正确的描述是依赖关系中包含一个逻辑矛盾，形成了一个长度为 $3$ 的环，这与选项 C 相符。", "answer": "$$\\boxed{C}$$", "id": "1496996"}, {"introduction": "在确认一个图是无环的之后，我们可以利用其结构进行强大的分析，例如计算所有可能的路径。本练习模拟了一个微服务架构（DAG 的一个常见用例），要求你计算数据从起点到终点的所有不同路由的总数。这个实践展示了如何利用动态规划在 DAG 上高效地解决路径计数问题。[@problem_id:1496941]", "problem": "一个软件工程师团队正在为一个新应用程序设计架构。该架构由多个微服务组成，这些微服务之间有特定的依赖关系，形成一个有向无环图（DAG）。一个数据包必须通过一个有效的连接服务序列，从一个初始服务传输到一个最终服务。一条有效路径是指一个服务序列 $s_1, s_2, \\dots, s_k$，其中数据可以对所有的 $i=1, \\dots, k-1$ 从 $s_i$ 流向 $s_{i+1}$。\n\n该系统有一个单一入口点，即 `Start` 服务，以及一个单一出口点，即 `End` 服务。依赖关系如下：\n\n- `Start` 服务将数据导向 `Auth`、`UI` 和 `API` 服务。\n- `Auth` 服务是 `DB_Read` 和 `DB_Write` 服务的前置条件。\n- `UI` 服务是 `DB_Read` 和 `DB_Write` 服务的前置条件。\n- `API` 服务是 `DB_Read` 和 `DB_Write` 服务的前置条件。\n- `DB_Read` 服务是 `Analytics` 和 `Processing` 服务的前置条件。\n- `DB_Write` 服务是 `Analytics` 和 `Processing` 服务的前置条件。\n- `Analytics` 服务是 `End` 服务的前置条件。\n- `Processing` 服务是 `End` 服务的前置条件。\n\n计算一个数据包从 `Start` 服务传输到 `End` 服务所能采用的不同路径的总数。", "solution": "我们将微服务依赖关系建模为一个有向无环图，并使用基于拓扑排序的动态规划来计算从唯一源点到唯一汇点的有向路径数量。令 $P(v)$ 表示从 $\\text{Start}$ 到节点 $v$ 的不同有向路径的数量。基本原理是，对于任何节点 $v$（源点除外），到达 $v$ 的路径数等于到达其所有直接前驱节点的路径数之和：\n$$\nP(v)=\\sum_{u \\in \\operatorname{pred}(v)} P(u).\n$$\n基准情况是源点：\n$$\nP(\\text{Start})=1.\n$$\n根据给定的边，前驱节点如下：\n- $\\operatorname{pred}(\\text{Auth})=\\{\\text{Start}\\}$, $\\operatorname{pred}(\\text{UI})=\\{\\text{Start}\\}$, $\\operatorname{pred}(\\text{API})=\\{\\text{Start}\\}$,\n- $\\operatorname{pred}(\\text{DB\\_Read})=\\{\\text{Auth},\\text{UI},\\text{API}\\}$, $\\operatorname{pred}(\\text{DB\\_Write})=\\{\\text{Auth},\\text{UI},\\text{API}\\}$,\n- $\\operatorname{pred}(\\text{Analytics})=\\{\\text{DB\\_Read},\\text{DB\\_Write}\\}$, $\\operatorname{pred}(\\text{Processing})=\\{\\text{DB\\_Read},\\text{DB\\_Write}\\}$,\n- $\\operatorname{pred}(\\text{End})=\\{\\text{Analytics},\\text{Processing}\\}$.\n\n逐层计算路径数：\n$$\nP(\\text{Auth})=P(\\text{Start})=1,\\quad P(\\text{UI})=P(\\text{Start})=1,\\quad P(\\text{API})=P(\\text{Start})=1.\n$$\n$$\nP(\\text{DB\\_Read})=P(\\text{Auth})+P(\\text{UI})+P(\\text{API})=1+1+1=3,\n$$\n$$\nP(\\text{DB\\_Write})=P(\\text{Auth})+P(\\text{UI})+P(\\text{API})=1+1+1=3.\n$$\n$$\nP(\\text{Analytics})=P(\\text{DB\\_Read})+P(\\text{DB\\_Write})=3+3=6,\n$$\n$$\nP(\\text{Processing})=P(\\text{DB\\_Read})+P(\\text{DB\\_Write})=3+3=6.\n$$\n最后，\n$$\nP(\\text{End})=P(\\text{Analytics})+P(\\text{Processing})=6+6=12.\n$$\n因此，从 `Start` 到 `End` 的不同路径总数为 $12$。", "answer": "$$\\boxed{12}$$", "id": "1496941"}, {"introduction": "在解决选择受限于依赖关系的复杂优化问题时，DAG 是一个基础工具。这个更进一步的练习将让你扮演一名生物技术专家的角色，设计一种药物组合，这个问题被建模为在一棵树（一种特殊的 DAG）上寻找最大权重独立集。此问题介绍了一种强大的动态规划技巧，并突显了 DAG 在前沿科学研究中的应用。[@problem_id:1496951]", "problem": "一家生物技术研究公司正在对一个复杂的细胞信号网络进行建模，以优化一种新的药物组合。该网络表示为一个有向无环图（DAG），其中节点是蛋白质，有向边 `(u, v)` 表示蛋白质 `u` 直接激活蛋白质 `v`。已知整个网络是一个森林，即一个由不相交的树组成的集合，边从父节点指向子节点。\n\n网络中的每种蛋白质 `i` 都被赋予一个“治疗价值” `w(i)`，它是一个正整数，代表其作为药物靶点的有效性。目标是选择一个蛋白质子集作为药物组合的靶点，以实现可能的最大总治疗价值。\n\n然而，基于结合机制存在一个关键约束：如果两种蛋白质直接相连（即一个是另一个的激活剂），它们不能同时被选为靶点。用图论的术语来说，所选的蛋白质集合必须形成一个独立集，其中任意两个被选中的蛋白质在图中都不相邻。\n\n现给出网络中一个这样的信号树的结构，它包含 8 种蛋白质，标记为 0 到 7。\n其结构由以下父子关系定义，其中边 `(u, v)` 表示 `u` 是 `v` 的父节点：\n(0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (3, 6), (3, 7)。\n蛋白质 0 是该树的根节点。\n\n各种蛋白质的治疗价值如下：\n- `w(0) = 3`\n- `w(1) = 5`\n- `w(2) = 6`\n- `w(3) = 2`\n- `w(4) = 8`\n- `w(5) = 4`\n- `w(6) = 7`\n- `w(7) = 3`\n\n计算通过选择一个有效的蛋白质靶点集合可以实现的最大可能总治疗价值。", "solution": "该问题要求在一个给定的顶点加权树中找到最大权重的独立集。独立集是一个顶点集合，其中任意两个顶点之间都没有边相连。由于该图是一棵树（一种特殊类型的 DAG），这个问题可以使用动态规划高效解决。通用策略是计算子树的解，并使用这些结果来计算更大树的解。这通常通过后序遍历完成，从叶节点开始，向上移动到根节点。\n\n对于树中的每个节点 `u`，我们将计算两个值：\n1. `dp_in(u)`：在以 `u` 为根的子树中，且 `u` **被包含**在独立集内的前提下，独立集的最大权重。\n2. `dp_out(u)`：在以 `u` 为根的子树中，且 `u` **不被包含**在独立集内的前提下，独立集的最大权重。\n\n这些值的递推关系如下：\n- 如果我们将节点 `u` 包含在集合中（计算 `dp_in(u)`），其权重 `w(u)` 会被加到总和中。根据独立集的定义，我们不能包含它的任何邻居。在树中，这意味着我们不能包含它的父节点（这由向上的 DP 流程处理）或任何它的直接子节点。因此，对于 `u` 的每个子节点 `v`，我们必须选择不包含 `v` 的选项。\n    $$dp_{\\text{in}}(u) = w(u) + \\sum_{v \\in \\text{children}(u)} dp_{\\text{out}}(v)$$\n- 如果我们不将节点 `u` 包含在集合中（计算 `dp_out(u)`），我们可以自由地为它的每个子节点的子树独立地做出最优选择。对于每个子节点 `v`，我们可以选择包含 `v` 或不包含 `v`，因此我们取其子树的两个选项中的最大值。\n    $$dp_{\\text{out}}(u) = \\sum_{v \\in \\text{children}(u)} \\max(dp_{\\text{in}}(v), dp_{\\text{out}}(v))$$\n\n这个递归的基本情况是树的叶节点。对于任何叶节点 `l`：\n- `dp_in(l) = w(l)` (集合仅为 `{l}`）。\n- `dp_out(l) = 0` (集合为空）。\n\n我们将从叶节点开始，向上移动到根节点，应用此过程。给定的树结构是：\n根节点: 0\n节点 0 的子节点: {1, 2, 3}\n节点 1 的子节点: {4, 5}\n节点 3 的子节点: {6, 7}\n叶节点: {2, 4, 5, 6, 7}\n\n节点 `0` 到 `7` 的权重为：`w = {3, 5, 6, 2, 8, 4, 7, 3}`。\n\n**步骤 1：计算叶节点的 DP 值。**\n-   节点 2: `dp_in(2) = w(2) = 6`, `dp_out(2) = 0`。\n-   节点 4: `dp_in(4) = w(4) = 8`, `dp_out(4) = 0`。\n-   节点 5: `dp_in(5) = w(5) = 4`, `dp_out(5) = 0`。\n-   节点 6: `dp_in(6) = w(6) = 7`, `dp_out(6) = 0`。\n-   节点 7: `dp_in(7) = w(7) = 3`, `dp_out(7) = 0`。\n\n**步骤 2：以后序遍历计算内部节点的 DP 值。**\n-   节点 1 (子节点 {4, 5}):\n    -   `dp_in(1) = w(1) + dp_out(4) + dp_out(5) = 5 + 0 + 0 = 5`。\n    -   `dp_out(1) = \\max(dp_in(4), dp_out(4)) + \\max(dp_in(5), dp_out(5)) = \\max(8, 0) + \\max(4, 0) = 8 + 4 = 12`。\n-   节点 3 (子节点 {6, 7}):\n    -   `dp_in(3) = w(3) + dp_out(6) + dp_out(7) = 2 + 0 + 0 = 2`。\n    -   `dp_out(3) = \\max(dp_in(6), dp_out(6)) + \\max(dp_in(7), dp_out(7)) = \\max(7, 0) + \\max(3, 0) = 7 + 3 = 10`。\n\n**步骤 3：计算根节点的 DP 值。**\n-   节点 0 (子节点 {1, 2, 3}):\n    -   `dp_in(0) = w(0) + dp_out(1) + dp_out(2) + dp_out(3) = 3 + 12 + 0 + 10 = 25`。\n    -   `dp_out(0) = \\max(dp_in(1), dp_out(1)) + \\max(dp_in(2), dp_out(2)) + \\max(dp_in(3), dp_out(3)) = \\max(5, 12) + \\max(6, 0) + \\max(2, 10) = 12 + 6 + 10 = 28`。\n\n**步骤 4：确定最终答案。**\n整棵树的最大治疗价值是包含根节点或不包含根节点两种情况中的最大值。\n最终答案 = `\\max(dp_in(0), dp_out(0)) = \\max(25, 28) = 28`。\n\n为了验证，与 `dp_out(0)=28` 相对应的集合是通过向下采取最优选择来构建的：\n- 不包含 0。\n- 对于子树 1，取最大值，即 `dp_out(1)=12`。这意味着我们不包含 1。对于其子节点 4 和 5，我们取最大值，即 `dp_in(4)=8` 和 `dp_in(5)=4`。所以我们选择 {4, 5}。\n- 对于子树 2，取最大值，即 `dp_in(2)=6`。所以我们选择 {2}。\n- 对于子树 3，取最大值，即 `dp_out(3)=10`。这意味着我们不包含 3。对于其子节点 6 和 7，我们取最大值，即 `dp_in(6)=7` 和 `dp_in(7)=3`。所以我们选择 {6, 7}。\n最终得到的独立集是 {2, 4, 5, 6, 7}。\n总权重为 `w(2) + w(4) + w(5) + w(6) + w(7) = 6 + 8 + 4 + 7 + 3 = 28`。这证实了结果。", "answer": "$$\\boxed{28}$$", "id": "1496951"}]}