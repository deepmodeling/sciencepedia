{"hands_on_practices": [{"introduction": "要真正掌握使用深度优先搜索（DFS）检测环路，最好的方法莫过于亲手实践。我们将从一个具体的应用场景开始：城市交通网络规划。这个练习 [@problem_id:1493924] 旨在帮助你通过手动追踪 DFS 算法的执行过程，来巩固对“回边”（back edge）的理解，正是这种边揭示了图中环路的存在。通过这个实践，你将能清晰地看到算法如何利用顶点的状态来识别导致无限循环的交通路线。", "problem": "一位城市规划师正在为一个新的市中心区设计交通流，该区域有6个交叉路口，编号从0到5。为了管理交通，所有街道都将是单行道。一项关键任务是确保所提出的布局不包含任何“交通环路”——即允许驾驶员仅通过遵循一系列单行道就能返回其起始交叉路口的路线。\n\n为了检查此类环路，采用了一种基于深度优先搜索（DFS）的算法。交叉路口被视为图中的顶点，单行道被视为有向边。如果DFS过程中发现了一条“返祖边”（back edge），则检测到一个环路。返祖边是指从当前访问的顶点指向仍在探索过程中的祖先顶点（即，在当前递归路径上）的边。\n\n提议的单行道如下：\n- 0 到 1\n- 1 到 2\n- 2 到 0\n- 1 到 3\n- 3 到 4\n- 4 到 1\n- 5 到 4\n\nDFS算法遵循以下规则：\n1. 搜索从顶点0开始。\n2. 如果图有多个不连通分量，则通过选择编号最小的未访问顶点继续搜索。\n3. 从任何给定顶点进行探索时，其相邻邻接点按数字升序访问。\n\n通过DFS算法的这次特定执行，总共会检测到多少条返祖边？\n\nA. 0\nB. 1\nC. 2\nD. 3\nE. 4", "solution": "我们将交叉路口建模为顶点 $0,1,2,3,4,5$，将单行道建模为有向边。DFS从$0$开始，按升序访问邻接点，并在一个连通分量完成后，从编号最小的未访问顶点继续。返祖边是从当前正在探索的顶点到当前递归栈上某个祖先的边。\n\n按升序构建邻接表：$0:\\{1\\}$, $1:\\{2,3\\}$, $2:\\{0\\}$, $3:\\{4\\}$, $4:\\{1\\}$, $5:\\{4\\}$。\n\n从$0$开始DFS。将$0$标记为活动状态（在递归栈上）。从$0$访问$1$；边$0\\to 1$是树边。在$1$，首先访问$2$；边$1\\to 2$是树边。在$2$，其邻接点是$0$。顶点$0$处于活动状态并且是$2$的祖先，所以$2\\to 0$是一条返祖边；计数为$1$。完成$2$的访问（它离开栈）。返回到$1$并访问下一个邻接点$3$；边$1\\to 3$是树边。在$3$，访问$4$；边$3\\to 4$是树边。在$4$，其邻接点是$1$。$1$仍处于活动状态并且是$4$的祖先，所以$4\\to 1$是一条返祖边；计数为$2$。完成$4$的访问，然后是$3$，然后是$1$，然后是$0$。\n\n完成这个连通分量后，编号最小的未访问顶点是$5$。从$5$开始DFS。其邻接点是$4$，但$4$已经被访问完成（不在当前栈上），所以$5\\to 4$不是返祖边。没有发现其他返祖边。\n\n因此，检测到的返祖边总数为$2$。", "answer": "$$\\boxed{C}$$", "id": "1493924"}, {"introduction": "掌握了基础知识后，让我们来挑战一个更需要创造性建模的问题。在复杂的系统设计中，我们常常遇到不寻常的约束，例如信号必须在两种不同协议间交替传输。这个练习 [@problem_id:1493919] 介绍了一个“协议共振”的场景，其中标准的 DFS 算法无法直接应用。你的任务是通过构建一个新的“状态空间图”来对问题进行转化，在这个新图中，一个简单的环路就直接对应于原始问题中的交替协议环路。这种将复杂约束编码到图结构中的思想，是高级算法设计的关键一环。", "problem": "在设计下一代片上系统（SoC）时，使用了两种不同的通信协议“Synchro”和“Asynchro”在功能组件之间进行数据传输。\n\n一种称为“协议共振”的关键故障模式可能会发生，如果一个信号陷入一个反馈回路中，其中通信协议在每一步都严格交替。\n\n给定一个芯片架构模型如下：\n- 一组 $n$ 个功能组件，由整数 $V = \\{0, 1, \\dots, n-1\\}$ 索引。\n- Synchro 协议网络，建模为有向图 $G_S = (V, E_S)$，其中一条有向边 $(u, v) \\in E_S$ 表示组件 $u$ 可以使用 Synchro 协议向组件 $v$ 发送数据。\n- Asynchro 协议网络，建模为有向图 $G_A = (V, E_A)$，其中一条边 $(u, v) \\in E_A$ 代表一次从 $u$ 到 $v$ 使用 Asynchro 协议的有效数据传输。\n\n“交替反馈回路”是一个组件序列 $v_0, v_1, \\dots, v_k=v_0$（其中路径至少包含一条边），使得用于连接 $(v_0, v_1), (v_1, v_2), \\dots, (v_{k-1}, v_k)$ 的通信协议在 Synchro 和 Asynchro 之间严格交替。例如，如果 $(v_0, v_1)$ 是一个 Synchro 连接，那么 $(v_1, v_2)$ 必须是 Asynchro 连接，$(v_2, v_3)$ 必须是 Synchro 连接，依此类推，该模式对于闭合回路的最后一条边 $(v_{k-1}, v_k = v_0)$ 也同样成立。\n\n给定一个特定的芯片设计，你的任务是确定属于至少一个此类交替反馈回路的唯一功能组件的总数。\n\n**芯片规格：**\n- 组件数量，$n = 8$。\n- Synchro 边集，$E_S = \\{(0, 1), (1, 2), (3, 4), (5, 6), (7, 0)\\}$。\n- Asynchro 边集，$E_A = \\{(2, 3), (4, 5), (6, 7), (6, 1)\\}$。", "solution": "题目要求我们计算至少存在于一个有向环中的顶点数量，该环的边在来自 $E_S$ 的 Synchro 边和来自 $E_A$ 的 Asynchro 边之间严格交替。一个交替环必须有偶数长度，这样交替模式才能在整个环路中保持一致。\n\n我们通过追踪每一步都必须类型交替的边来枚举可能的交替环。\n\n首先，检查以 Synchro 边开始的环：\n- 从 $(0,1) \\in E_S$ 出发：下一条边必须是从 $1$ 出发的 Asynchro 边。但 $E_A$ 中没有 $(1, \\cdot)$ 这样的边，因此不会形成环。\n- 从 $(1,2) \\in E_S$ 出发：接下来的边由交替规则所确定：\n$$1 \\to 2 \\text{ (S) },\\quad 2 \\to 3 \\text{ (A) },\\quad 3 \\to 4 \\text{ (S) },\\quad 4 \\to 5 \\text{ (A) },\\quad 5 \\to 6 \\text{ (S) },\\quad 6 \\to 1 \\text{ (A) }$$\n这就闭合了一个经过顶点 $\\{1,2,3,4,5,6\\}$ 的有向交替环。\n- 从 $(3,4) \\in E_S$ 和 $(5,6) \\in E_S$ 出发：同样的强制交替规则会导向与上面相同的环 $\\{1,2,3,4,5,6\\}$。\n- 从 $(7,0) \\in E_S$ 出发：下一条边必须是从 $0$ 出发的 Asynchro 边，但 $E_A$ 中没有 $(0,\\cdot)$ 这样的边，因此不会形成环。\n\n接下来，检查以 Asynchro 边开始的环：\n- 从 $(2,3) \\in E_A$ 出发：交替规则强制要求：\n$$2 \\to 3 \\text{ (A) },\\quad 3 \\to 4 \\text{ (S) },\\quad 4 \\to 5 \\text{ (A) },\\quad 5 \\to 6 \\text{ (S) },\\quad 6 \\to 1 \\text{ (A) },\\quad 1 \\to 2 \\text{ (S) }$$\n这与经过 $\\{1,2,3,4,5,6\\}$ 的交替环是同一个。\n- 从 $(4,5) \\in E_A$ 和 $(6,1) \\in E_A$ 出发：通过同样的交替规则，我们得到相同的环 $\\{1,2,3,4,5,6\\}$。\n- 从 $(6,7) \\in E_A$ 出发：交替规则强制要求下一条边为通过 Synchro 的 $(7,0)$，但之后需要一条从 $0$ 出发的 Asynchro 边，而这样的边不存在，因此不会形成环。\n\n最后，我们证明顶点 $0$ 和 $7$ 不可能属于任何交替环。要想让 $0$ 处于一个交替环中，当进入 $0$ 的前驱边是 Synchro 边时，必须存在一条从 $0$ 出发的 Asynchro 出边（或者当出边是 Synchro 边时，必须有一条 Asynchro 入边）。然而，$E_A$ 中既没有 $(0,\\cdot)$ 这样的边，也没有 $(\\cdot,0)$ 这样的边。对于顶点 $7$，唯一的入边是 Asynchro 边 $(6,7)$，这强制要求下一条从 $7$ 出发的边为 Synchro 边 $(7,0)$，而之后则需要一条从 $0$ 出发的 Asynchro 边，但这样的边并不存在。因此，$0$ 和 $7$ 都不可能处于任何交替环中。\n\n因此，唯一的交替环是 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6 \\to 1$，而处于至少一个交替反馈回路中的顶点集合是 $\\{1,2,3,4,5,6\\}$。\n\n此类顶点的总数是 $6$。", "answer": "$$\\boxed{6}$$", "id": "1493919"}, {"introduction": "最后的这个练习将引导你探索算法本身的适应性与扩展性。与上一个问题中我们通过修改图来解决问题不同，这个问题 [@problem_id:1493933] 需要你直接修改 DFS 算法。问题的核心是寻找一个边权重乘积为 $-1$ 的环路，这等价于寻找一个包含奇数条权重为 $-1$ 的边的环路。为了解决它，你需要在 DFS 遍历的状态中增加额外的信息——奇偶性。这个练习深刻地揭示了，搜索算法不仅可以用于判断连通性，更可以通过“状态增强”来解决涉及路径属性的复杂问题，其时间复杂度仍能保持高效的 $O(N + M)$。", "problem": "考虑一个有向图 $G = (V, E)$，其中 $V$ 是顶点集合，数量为 $|V| = N$，$E$ 是边的集合，数量为 $|E| = M$。每条边 $(u, v) \\in E$ 都被赋予一个权重 $w(u, v)$，其值来自集合 $\\{-1, 1\\}$。你的任务是设计一个算法，以确定 $G$ 中是否存在至少一个简单环，其构成边的权重之积等于 $-1$。简单环是一条起点和终点相同，且不重复经过任何其他顶点的路径。\n\n对于任何通用有向图，能够正确解决此问题的最有效算法，其最坏情况时间复杂度的最紧界是以下哪个选项？\n\nA. $O(N + M)$\nB. $O((N+M)\\log N)$\nC. $O(N \\cdot M)$\nD. $O(N^2)$\nE. 该问题是 NP-hard 问题，意味着不存在已知的多项式时间算法。", "solution": "问题的核心是找到一个简单环，其边的权重之积为 $-1$。这等价于找到一个包含奇数条权重为 $-1$ 的边的简单环。这种重新表述将问题从乘积计算转换为了一个奇偶性校验问题。\n\n我们可以通过扩展标准的图遍历算法（如深度优先搜索，DFS）来解决此问题，使其能够跟踪奇偶性信息。其关键思想是，在有向图中，任何简单环都可以在DFS遍历过程中通过发现一条非树边（返祖边、前向边或交叉边）来识别，这条非树边与现有的树边构成一个闭环。\n\n我们来定义在DFS期间需要维护的状态。对于我们访问的每个顶点 $u$，我们将计算 $\\text{parity}[u]$，它表示从当前DFS树的根到 $u$ 的唯一路径上，权重为 $-1$ 的边的数量的奇偶性。我们可以将这个奇偶性定义为：偶数次为 $0$，奇数次为 $1$。合并奇偶性的操作将是异或（XOR）运算（$\\oplus$）。\n\n算法流程如下：\n1.  为所有 $N$ 个顶点初始化一个 $\\text{color}$ 数组为 `WHITE`（未访问）。\n2.  为所有 $N$ 个顶点初始化一个 $\\text{parity}$ 数组。\n3.  遍历 $V$ 中的每个顶点 $v$。如果 $\\text{color}[v]$ 是 `WHITE`，则从 $v$ 开始进行DFS。对于这棵新的DFS树，设置 $\\text{parity}[v] = 0$ 并调用 $\\text{DFS}(v)$。\n\n递归函数 $\\text{DFS}(u)$ 的工作方式如下：\n1.  将 $\\text{color}[u]$ 设置为 `GRAY`（正在访问）。\n2.  对于 $u$ 的每个通过边 $(u,v)$ 连接的邻居 $v$：\n    a. 如果 $w(u,v) = -1$，则令 $\\text{edge\\_parity}$ 为 $1$；如果 $w(u,v) = 1$，则为 $0$。\n    b. **情况1：$v$ 是 `WHITE`。** 这是一条树边。我们根据从根节点到 $u$ 的路径（该路径延伸至 $v$）来更新 $v$ 的奇偶性。因此，$\\text{parity}[v] = \\text{parity}[u] \\oplus \\text{edge\\_parity}$。然后，我们递归调用 $\\text{DFS}(v)$。如果递归调用表明已找到目标环，我们将此信息向上传播。\n    c. **情况2：$v$ 不是 `WHITE`。** 这意味着 $(u,v)$ 是一条非树边（返祖边、前向边或交叉边）。这条边构成了一个简单环。该环由边 $(u,v)$ 和DFS树中连接 $v$ 和 $u$ 的路径组成。连接 $v$ 和 $u$ 的树路径由从 $u$ 和 $v$ 的最低公共祖先（LCA）到 $u$ 的路径，以及从LCA到 $v$ 的路径组成。这条树路径上权重为 $-1$ 的边的数量的奇偶性是 $\\text{parity}[u] \\oplus \\text{parity}[v]$。\n        - 原因如下：设 $P_r(x)$ 为从DFS根节点 $r$ 到顶点 $x$ 的树路径的奇偶性。根据我们的定义，$\\text{parity}[x] = P_r(x)$。\n        - 设 $\\text{lca} = \\text{LCA}(u,v)$。从 $r$ 到 $u$ 的树路径可以看作是从 $r$ 到 $\\text{lca}$ 的路径，后接从 $\\text{lca}$ 到 $u$ 的路径。因此，$\\text{parity}[u] = P_r(\\text{lca}) \\oplus P_{\\text{lca}}(u)$。同理，$\\text{parity}[v] = P_r(\\text{lca}) \\oplus P_{\\text{lca}}(v)$。\n        - 将这两个等式进行异或运算，我们得到：$\\text{parity}[u] \\oplus \\text{parity}[v] = (P_r(\\text{lca}) \\oplus P_{\\text{lca}}(u)) \\oplus (P_r(\\text{lca}) \\oplus P_{\\text{lca}}(v)) = P_{\\text{lca}}(u) \\oplus P_{\\text{lca}}(v)$。这正是连接 $u$ 和 $v$ 的树路径上权重为 $-1$ 的边的奇偶性。\n    d. 现在，我们可以计算由非树边 $(u,v)$ 形成的整个环的奇偶性。环的总奇偶性是树路径的奇偶性与边 $(u,v)$ 本身的奇偶性的（异或）和。\n       $\\text{cycle\\_parity} = (\\text{parity}[u] \\oplus \\text{parity}[v]) \\oplus \\text{edge\\_parity}$。\n    e. 如果 $\\text{cycle\\_parity}$ 为 $1$，我们就找到了一个包含奇数条权重为 $-1$ 的边的简单环。我们可以立即停止并报告存在这样的环。\n\n3.  访问完 $u$ 的所有邻居后，将 $\\text{color}[u]$ 设置为 `BLACK`（已完成）。\n\n该算法本质上是对整个图进行一次DFS遍历。$\\text{color}$ 数组（用于分类边）和 $\\text{parity}$ 数组为每个顶点增加了常数级别的存储空间。在每个顶点和每条边上进行的计算都是常数次操作（异或和比较）。因此，该算法的总时间复杂度受DFS的复杂度限制，即 $O(N + M)$。\n\n虽然许多涉及具有特定属性的“简单环”的问题是NP-hard的（这可能让人联想到选项E），但由于奇偶性约束的特性，这个问题存在一个高效的多项式时间解。最有效的算法其最坏情况时间复杂度的紧界为 $O(N + M)$。", "answer": "$$\\boxed{A}$$", "id": "1493933"}]}