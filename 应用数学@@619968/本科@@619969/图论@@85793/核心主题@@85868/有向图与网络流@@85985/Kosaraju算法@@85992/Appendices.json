{"hands_on_practices": [{"introduction": "Kosaraju 算法的核心在于其两遍深度优先搜索（DFS）过程。第一个练习旨在帮助你掌握算法的第一步：在原始图 $G$ 上执行 DFS 并计算每个顶点的“完成时间”。这个过程是后续识别强连通分量的基础，精确地手动计算一次可以加深你对 DFS 工作机制的理解 [@problem_id:1517012]。", "problem": "考虑一个有向图 $G = (V, E)$，其顶点集为 $V = \\{v_0, v_1, v_2, v_3, v_4\\}$，有向边集为 $E$。边的定义如下：\n- 有一个中心顶点 $v_0$，它有指向所有其他顶点的出边。\n- 其他顶点根据其索引按顺时针方向形成一个有向环。\n具体来说，边集为 $E = \\{(v_0, v_1), (v_0, v_2), (v_0, v_3), (v_0, v_4), (v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$。\n\n我们将对该图 $G$ 执行深度优先搜索 (DFS)。DFS 过程使用一个初始化为 0 的全局整数计时器。\n- 当一个顶点 `u` 首次被发现时，其发现时间 `d[u]` 被记录为计时器的当前值，然后计时器加 1。\n- 在访问完 `u` 的所有邻接点后，`u` 的访问就完成了。其完成时间 `f[u]` 被记录为计时器的当前值，然后计时器加 1。\n\nDFS 遍历遵循以下特定规则：\n1. DFS 主循环按顶点索引顺序处理顶点：$v_0, v_1, v_2, v_3, v_4$。此序列中第一个未被访问的顶点被选为新搜索树的起点。\n2. 在探索任何给定顶点的邻接点时，会按照顶点索引的升序访问这些邻接点。例如，从顶点 $v_0$ 出发，算法将尝试先访问 $v_1$，然后是 $v_2$，接着是 $v_3$，最后是 $v_4$。\n\n你的任务是确定在 DFS 遍历完成后，所有顶点 $v_0, v_1, v_2, v_3, v_4$ 的完成时间。请按 $v_0, v_1, v_2, v_3, v_4$ 的顺序，将它们的完成时间表示为一个包含五个整数的序列。", "solution": "我们执行一次标准的 DFS，全局计时器初始化为 $t=0$。当发现一个顶点 $u$ 时，我们设置 $d[u]=t$，然后更新 $t \\leftarrow t+1$。在完成对 $u$ 的所有邻接点的访问后，我们设置 $f[u]=t$，然后更新 $t \\leftarrow t+1$。主循环按 $v_{0},v_{1},v_{2},v_{3},v_{4}$ 的顺序访问顶点，邻接表按索引升序进行探索。\n\n从 $v_{0}$（未访问）开始，因此我们调用 $\\mathrm{DFS\\mbox{-}Visit}(v_{0})$：\n- 发现 $v_{0}$：\n$$d[v_{0}]=0,\\quad t\\leftarrow 1.$$\n按顺序 $v_{1},v_{2},v_{3},v_{4}$ 探索 $v_{0}$ 的邻接点。\n\n从 $v_{0}$ 出发，访问 $v_{1}$（白色）：\n- 发现 $v_{1}$：\n$$d[v_{1}]=1,\\quad t\\leftarrow 2.$$\n$v_{1}$ 的邻接点：只有 $v_{2}$。访问 $v_{2}$（白色）：\n- 发现 $v_{2}$：\n$$d[v_{2}]=2,\\quad t\\leftarrow 3.$$\n$v_{2}$ 的邻接点：只有 $v_{3}$。访问 $v_{3}$（白色）：\n- 发现 $v_{3}$：\n$$d[v_{3}]=3,\\quad t\\leftarrow 4.$$\n$v_{3}$ 的邻接点：只有 $v_{4}$。访问 $v_{4}$（白色）：\n- 发现 $v_{4}$：\n$$d[v_{4}]=4,\\quad t\\leftarrow 5.$$\n$v_{4}$ 的邻接点：只有 $v_{1}$，该顶点已被发现（灰色），因此不进行递归。完成 $v_{4}$：\n$$f[v_{4}]=5,\\quad t\\leftarrow 6.$$\n\n返回到 $v_{3}$，没有更多邻接点。完成 $v_{3}$：\n$$f[v_{3}]=6,\\quad t\\leftarrow 7.$$\n\n返回到 $v_{2}$，没有更多邻接点。完成 $v_{2}$：\n$$f[v_{2}]=7,\\quad t\\leftarrow 8.$$\n\n返回到 $v_{1}$，没有更多邻接点。完成 $v_{1}$：\n$$f[v_{1}]=8,\\quad t\\leftarrow 9.$$\n\n回到 $v_{0}$，继续其邻接点列表：$v_{2},v_{3},v_{4}$ 都已完成（黑色），因此没有新的访问。完成 $v_{0}$：\n$$f[v_{0}]=9,\\quad t\\leftarrow 10.$$\n\n主循环检查 $v_{1},v_{2},v_{3},v_{4}$，它们都已被访问，因此 DFS 终止。所以，按 $(v_{0},v_{1},v_{2},v_{3},v_{4})$ 顺序的完成时间为\n$$f[v_{0}]=9,\\quad f[v_{1}]=8,\\quad f[v_{2}]=7,\\quad f[v_{3}]=6,\\quad f[v_{4}]=5.$$", "answer": "$$\\boxed{\\begin{pmatrix}9 & 8 & 7 & 6 & 5\\end{pmatrix}}$$", "id": "1517012"}, {"introduction": "在完成了第一遍 DFS 并获得了所有顶点的完成时间后，下一步就是利用这些时间来指导第二遍 DFS。这个练习将检验你是否理解了两个阶段之间的关键联系：如何根据第一阶段的完成时间来确定在转置图 $G^T$ 上开始新一轮 DFS 的顶点顺序。正确排序是 Kosaraju 算法能够准确划分强连通分量的保证 [@problem_id:1517044]。", "problem": "考虑一个有向图 $G = (V, E)$，其中顶点集为 $V = \\{A, B, C, D, E, F, G, H\\}$。边集 $E$ 由以下邻接表表示：\n\n- $A: B$\n- $B: C, E, F$\n- $C: D, G$\n- $D: C, H$\n- $E: A, F$\n- $F: G$\n- $G: F$\n- $H: D$\n\n在寻找该图强连通分量的算法的第一阶段，对图 $G$ 执行一次深度优先搜索 (DFS)。该 DFS 的主循环按字母顺序（A、B、C 等）考虑顶点，如果顶点尚未被访问，则从其开始新的搜索树。DFS 完成后，每个顶点的完成时间记录如下：\n\n- $f(A) = 16$\n- $f(B) = 15$\n- $f(C) = 12$\n- $f(D) = 7$\n- $f(E) = 14$\n- $f(F) = 10$\n- $f(G) = 11$\n- $f(H) = 6$\n\n算法的第二阶段涉及在图的转置图 $G^T$ 上执行一次 DFS。第二次 DFS 的起始顶点的选择顺序由第一阶段的结果决定。在第二阶段，用作 DFS 遍历的起始点的正确顶点序列是什么？\n\nA. A, B, E, C, G, F, D, H\n\nB. A, B, C, D, E, F, G, H\n\nC. H, D, F, G, C, E, B, A\n\nD. C, G, F, D, H, A, E, B\n\nE. A, E, B, F, C, G, D, H", "solution": "在 Kosaraju 算法中，第一阶段对图 $G$ 运行 DFS，并记录每个顶点 $v$ 的完成时间 $f(v)$。第二阶段在转置图 $G^{T}$ 上运行 DFS，并按照第一阶段得到的完成时间的严格递减顺序选择新的 DFS 起始顶点。\n\n根据给定的数据，\n$f(A)=16$, $f(B)=15$, $f(E)=14$, $f(C)=12$, $f(G)=11$, $f(F)=10$, $f(D)=7$, $f(H)=6$。\n按 $f$ 的递减顺序对顶点进行排序，得到序列\n$$A, B, E, C, G, F, D, H.$$\n这与选项 A 一致。", "answer": "$$\\boxed{A}$$", "id": "1517044"}, {"introduction": "你是否想过，为什么 Kosaraju 算法必须先在 $G$ 上运行 DFS，再按完成时间递减的顺序在 $G^T$ 上运行第二次 DFS？这个思想实验将挑战你对算法正确性的深层理解 [@problem_id:1517055]。通过分析一个“反向”的算法流程，你将揭示出为什么 Kosaraju 算法的特定步骤顺序是不可或缺的，从而真正掌握其背后的精妙原理。", "problem": "一位算法设计者正在研究如何寻找有向图 $G=(V, E)$ 的强连通分量 (SCCs)。他们熟悉 Kosaraju 算法，该算法包含以下步骤：\n1.  对图 $G$ 运行深度优先搜索 (DFS) 以确定所有顶点的完成时间（或后序遍历序列）。\n2.  计算转置图 $G^T$，即图 $G$ 将所有边反向后得到的图。\n3.  对 $G^T$ 运行 DFS，主循环按照步骤 1 中确定的完成时间的降序处理顶点。所得到的 DFS 森林中的每棵树都对应于原图 $G$ 的一个不同的 SCC。\n\n该设计者通过交换 $G$ 和 $G^T$ 在主要步骤中的角色，提出了一个“反向 Kosaraju 算法”。所提议的算法如下：\n1.  计算转置图 $G^T$。\n2.  对转置图 $G^T$ 运行 DFS 以确定所有顶点的完成时间。\n3.  对原图 $G$ 运行 DFS，主循环按照步骤 2 中确定的完成时间的降序处理顶点。该设计者声称，这第二个 DFS 森林中的每棵树都将对应一个不同的 SCC。\n\n以下哪个陈述准确地评估了此“反向 Kosaraju 算法”的正确性？\n\nA. 是的，这个反向算法也是一种找到任何有向图的所有强连通分量的正确方法。\n\nB. 不，对于任何包含一个以上强连通分量的有向图，这个反向算法都会失败。\n\nC. 不，这个反向算法不正确，因为从 $G^T$ 派生的处理顺序不能保证在处理完第一个分量后，对 $G$ 的 DFS 会被限制在单个 SCC 内。\n\nD. 不，这个反向算法不正确，因为最后一步对原图 $G$ 的 DFS 无法利用从转置图 $G^T$ 计算出的完成时间。", "solution": "设 $G=(V,E)$ 是一个有向图，并设 $G^{T}$ 是其转置图。设 $C(G)$ 表示其缩点 DAG，其顶点是 $G$ 的 SCC，并且如果 $E$ 中包含某条从 SCC $S$ 中的顶点到 SCC $T$ 中的顶点的边，则 $C(G)$ 中存在一条有向边 $S \\to T$。根据定义，$C(G)$ 是一个 DAG。对于有向图 $H$ 上的 DFS，将 $v$ 的完成时间记为 $f_{H}(v)$，对于 $H$ 的一个 SCC $S$，定义 $f_{H}(S) \\coloneqq \\max\\{f_{H}(v): v \\in S\\}$。\n\n关于 DAG 的一个标准 DFS 属性指出，如果 $D$ 是一个 DAG 且 $(x,y)$ 是 $D$ 的一条边，那么在 $D$ 上进行的任何 DFS 都满足 $f_{D}(x) > f_{D}(y)$。将此应用于缩点 DAG，缩点保留了分量间的无环性，因此对于任何有向图 $H$ 和 $C(H)$ 中的任何边 $S \\to T$，我们有\n$$\nf_{H}(S) > f_{H}(T).\n$$\n等价地，在 $H$ 上运行 DFS，当按 $f_{H}(\\cdot)$ 的降序排序时，会对 $H$ 的 SCC 进行一次 $C(H)$ 的拓扑排序。\n\n在标准的 Kosaraju 算法中，第一次 DFS 在 $G$ 上运行，因此如果在 $C(G)$ 中有 $S \\to T$，则 $f_{G}(S) > f_{G}(T)$，因此具有最大 $f_{G}$ 值的 SCC 是 $C(G)$ 中的一个源点。从这个 SCC 开始在 $G^{T}$ 上运行第二次 DFS 是可行的，因为该 SCC 是 $C(G^{T})$ 中的一个汇点，因此在 $G^{T}$ 上的 DFS 无法离开它，所以每棵 DFS 树都恰好与一个 SCC 重合。\n\n在所提出的反向算法中，第一次 DFS 在 $G^{T}$ 上运行。由于 $C(G^{T})$ 是通过反转 $C(G)$ 的所有边得到的，因此对于 $C(G)$ 中的任何边 $S \\to T$，我们在 $C(G^{T})$ 中有一条边 $T \\to S$，因此\n$$\nf_{G^{T}}(T) > f_{G^{T}}(S) \\quad \\text{whenever } S \\to T \\text{ in } C(G).\n$$\n因此，按 $f_{G^{T}}$ 的降序排序会将 $C(G)$ 的源点放在最前面。反向算法的第二次 DFS 使用这个顺序在 $G$ 上运行。从 $C(G)$ 的一个源点 SCC $S$ 中的一个顶点开始，可能存在指向其他 SCC $T$ 的出边 $S \\to T$，由于那些顶点在那一刻尚未被访问，对 $G$ 的 DFS 将会遍历这些边并进入 $T$。因此，DFS 树将不会局限于 $S$，而是会将多个 SCC 合并到一棵树中，这违反了每棵 DFS 树对应一个 SCC 的要求。\n\n一个具体的反例说明了这种失败。设 $V=\\{u,v\\}$ 且 $E=\\{(u,v)\\}$。SCC 分别为 $\\{u\\}$ 和 $\\{v\\}$，$C(G)$ 中有边 $\\{u\\} \\to \\{v\\}$。在 $G^{T}$（边为 $(v,u)$）上运行第一次 DFS，得到的完成时间降序以 $u$ 开始，而 $u$ 位于 $C(G)$ 的一个源点 SCC 中。第二次 DFS 从 $u$ 开始在 $G$ 上运行，会沿着 $(u,v)$ 访问两个顶点，从而将两个 SCC 错误地合并成一个。因此，该反向算法通常是不正确的。\n\n对选项进行评估：A 是错误的；B 的说法过于绝对，因为拥有多个 SCC 但没有 SCC 间边的图不会导致失败；D 不是问题所在——从 $G^{T}$ 得到的完成时间是可用的，但它们导致从 $C(G)$ 的源点开始，这无法将第二次在 $G$ 上的 DFS 限制在单个 SCC 内。陈述 C 精确地指出了不正确的原因。", "answer": "$$\\boxed{C}$$", "id": "1517055"}]}