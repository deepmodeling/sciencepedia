{"hands_on_practices": [{"introduction": "让我们从一个近似算法的基石开始动手实践：基于最大匹配的顶点覆盖算法。这个算法不仅实现简单，而且有形式化的性能保证——其解的大小不会超过最优解的两倍。通过在一个给定图上手动追踪其执行过程 [@problem_id:1481691]，你将具体理解它的工作原理，并培养将算法输出与真实最优解进行比较的关键技能。", "problem": "在计算复杂性理论领域，顶点覆盖问题是NP难问题的一个典型例子。给定一个图，目标是找到一个规模最小的顶点子集，使得图中的每条边都与该子集中的至少一个顶点相连。这样的子集被称为最小（或最优）顶点覆盖，其对于图$G$的大小记为$\\tau(G)$。\n\n由于对大规模图找到最优解在计算上是困难的，因此常使用近似算法。其中一种算法是基于极大匹配的2-近似算法。它保证得到的解的大小不超过最优解大小的两倍。该算法流程如下：\n1.  从一个空集开始作为匹配，即$M = \\emptyset$。匹配是一个边的集合，其中任意两条边都不共享公共顶点。\n2.  构造一个**极大匹配**。如果一个匹配无法通过从图中添加任何其他边来扩展，则称该匹配为极大匹配。对于本问题，你将使用一个特定的贪心过程来构造极大匹配：遍历一个预先定义的边列表，对于每条边，当且仅当它不与$M$中已有的任何边共享端点时，才将其添加到$M$中。\n3.  得到的顶点覆盖（我们称之为$C_{approx}$）由极大匹配$M$中所有边的所有端点构成。\n\n考虑一个无向图$G = (V, E)$，其顶点集为$V = \\{A, B, C, D, E, F, G, H\\}$，边集为$E = \\{(A,B), (A,C), (B,C), (C,D), (D,E), (D,F), (E,F), (F,G), (G,H)\\}$。\n\n为了构造极大匹配，请按以下特定顺序处理集合$E$中的边：\n$(G,H), (F,G), (E,F), (D,F), (D,E), (C,D), (B,C), (A,C), (A,B)$。\n\n你的任务是计算本次特定执行的近似比。近似比定义为所生成的顶点覆盖的大小与最优顶点覆盖的大小的比值，即$\\frac{|C_{approx}|}{\\tau(G)}$。\n\n计算这个近似比。将最终答案表示为保留两位有效数字的小数。", "solution": "我们遵循指定的贪心过程来构造极大匹配。初始化$M=\\emptyset$，并按给定顺序处理边，如果某条边不与$M$中已有的任何边共享端点，则将其加入$M$。\n\n- 处理 $(G,H)$：添加，因此 $M=\\{(G,H)\\}$，已用端点为 $\\{G,H\\}$。\n- $(F,G)$ 共享顶点 $G$，跳过。\n- $(E,F)$ 与 $\\{G,H\\}$ 不共享端点，添加：$M=\\{(G,H),(E,F)\\}$，已用端点为 $\\{E,F,G,H\\}$。\n- $(D,F)$ 共享顶点 $F$，跳过。\n- $(D,E)$ 共享顶点 $E$，跳过。\n- $(C,D)$ 与 $\\{E,F,G,H\\}$ 不共享端点，添加：$M=\\{(G,H),(E,F),(C,D)\\}$，已用端点为 $\\{C,D,E,F,G,H\\}$。\n- $(B,C)$ 共享顶点 $C$，跳过。\n- $(A,C)$ 共享顶点 $C$，跳过。\n- $(A,B)$ 与当前 $M$ 中的边不共享端点，添加：$M=\\{(G,H),(E,F),(C,D),(A,B)\\}$，已用端点为 $\\{A,B,C,D,E,F,G,H\\}$。\n\n因此，极大匹配的大小为 $|M|=4$，2-近似算法输出的顶点覆盖 $C_{approx}$ 由 $M$ 中所有边的所有端点组成，因此 $C_{approx}=V$ 并且\n$$\n|C_{approx}|=8.\n$$\n\n接下来，计算最优顶点覆盖的大小 $\\tau(G)$。一个通用的下界由最大匹配 $\\nu(G)$ 的大小给出：\n$$\n\\tau(G)\\geq \\nu(G).\n$$\n因为我们找到了一个大小为 $4$ 的匹配，所以 $\\nu(G)\\geq 4$，因此 $\\tau(G)\\geq 4$。\n\n我们证明 $\\tau(G)\\geq 5$。由 $\\{A,B,C\\}$ 构成的子图是一个三元环，所以任何顶点覆盖都必须至少包含 $\\{A,B,C\\}$中的 $2$ 个顶点。同样，由 $\\{D,E,F\\}$ 构成的子图是一个三元环，所以它必须至少包含 $\\{D,E,F\\}$ 中的 $2$ 个顶点。如果 $\\tau(G)=4$，那么该覆盖将恰好由 $\\{A,B,C\\}$ 中的 $2$ 个顶点和 $\\{D,E,F\\}$ 中的 $2$ 个顶点组成，而不会包含 $\\{G,H\\}$ 中的任何顶点。这将导致边 $(G,H)$ 未被覆盖，这是一个矛盾。因此\n$$\n\\tau(G)\\geq 5.\n$$\n\n我们现在给出一个大小为 $5$ 的顶点覆盖来证明其最优性。取\n$$\nS=\\{A,C,D,E,G\\}.\n$$\n该集合覆盖了：\n- 通过 $A$ 和 $C$ 覆盖了 $\\{A,B,C\\}$ 上的三元环；\n- 通过 $C$ 或 $D$ 覆盖了边 $(C,D)$；\n- 通过 $D$ 和 $E$ 覆盖了 $\\{D,E,F\\}$ 上的三元环；\n- 通过 $G$ 覆盖了路径上的边 $(F,G)$ 和 $(G,H)$。\n\n因此 $S$ 是一个大小为 $5$ 的顶点覆盖，所以\n$$\n\\tau(G)=5.\n$$\n\n因此，近似比为\n$$\n\\frac{|C_{approx}|}{\\tau(G)}=\\frac{8}{5}=1.6,\n$$\n其保留两位有效数字的小数形式为 $1.6$。", "answer": "$$\\boxed{1.6}$$", "id": "1481691"}, {"introduction": "接下来，我们将探索一种不同的策略：贪心启发式算法。这种方法非常直观——在每一步，我们只需选择能覆盖最多剩余边的顶点。虽然这种“度数优先”的方法看起来像是常识性策略，但批判性地分析其性能至关重要。这个练习 [@problem_id:1481665] 将你置于一个现实的网络安全场景中，并挑战你应用这个贪心算法，让你亲眼看到它的选择与最优解相比表现如何。", "problem": "一位网络安全分析师的任务是在一个小型关键子网络上部署一个监控软件包。该网络由节点（例如服务器、路由器）以及它们之间的直接通信链路组成。该网络可以建模为一个简单无向图 $G = (V, E)$，其中 $V$ 是节点集，$E$ 是链路集。\n\n节点集为 $V = \\{\\text{A, B, C, D, E, F, G, H, I, J, K, L, M}\\}$。\n通信链路为 $E = \\{(\\text{A, B}), (\\text{A, C}), (\\text{A, D}), (\\text{A, E}), (\\text{B, F}), (\\text{B, G}), (\\text{C, H}), (\\text{C, I}), (\\text{D, J}), (\\text{D, K}), (\\text{E, L}), (\\text{E, M})\\}$。\n\n为确保全面覆盖，该软件必须安装在一个称为顶点覆盖的节点子集上，使得每条通信链路都至少连接到一个运行该软件的节点。找到最小可能节点集的计算难度很大。因此，该分析师使用一个贪心近似算法。该算法的工作方式如下：重复选择连接到当前未受保护链路数量最多的节点。该节点被添加到受监控节点集中，与其相连的所有链路现在都被视为已受保护。这个过程持续进行，直到网络中的所有链路都受到保护为止。如果出现连接到未受保护链路数量最多的节点有多个（即平局），则选择按字母顺序排在最前面的节点。\n\n你的任务是确定此贪心算法对于此特定网络的性能。计算实际的近似比，其定义为贪心算法找到的顶点覆盖的大小除以该图的真实最小顶点覆盖的大小。将您的答案表示为小数，并保留三位有效数字。", "solution": "将网络建模为简单无向图 $G=(V,E)$，其中 $V=\\{\\text{A,B,C,D,E,F,G,H,I,J,K,L,M}\\}$ 且\n$$E=\\{(\\text{A,B}),(\\text{A,C}),(\\text{A,D}),(\\text{A,E}),(\\text{B,F}),(\\text{B,G}),(\\text{C,H}),(\\text{C,I}),(\\text{D,J}),(\\text{D,K}),(\\text{E,L}),(\\text{E,M})\\}.$$\n贪心算法重复选择与当前未受保护边数最多的顶点（按字母顺序打破平局），将其添加到覆盖集中，并将其关联的边标记为已受保护。\n\n最初，相对于所有边，各顶点的度数为：$\\deg(\\text{A})=4$，$\\deg(\\text{B})=\\deg(\\text{C})=\\deg(\\text{D})=\\deg(\\text{E})=3$，所有叶节点的度数为 $1$。贪心选择是 $\\text{A}$（唯一的最大度数为 $4$）。选择 $\\text{A}$ 后，边 $(\\text{A,B}),(\\text{A,C}),(\\text{A,D}),(\\text{A,E})$ 被保护。剩余的未受保护的边是 $(\\text{B,F}),(\\text{B,G}),(\\text{C,H}),(\\text{C,I}),(\\text{D,J}),(\\text{D,K}),(\\text{E,L}),(\\text{E,M})$。\n\n在这个残差图上，度数为 $\\deg(\\text{B})=\\deg(\\text{C})=\\deg(\\text{D})=\\deg(\\text{E})=2$，每个叶节点的度数为 $1$。算法根据字母顺序在 $\\{\\text{B,C,D,E}\\}$ 中进行选择：它选择 $\\text{B}$，保护了 $(\\text{B,F}),(\\text{B,G})$；然后是 $\\text{C}$，保护了 $(\\text{C,H}),(\\text{C,I})$；然后是 $\\text{D}$，保护了 $(\\text{D,J}),(\\text{D,K})$；最后是 $\\text{E}$，保护了 $(\\text{E,L}),(\\text{E,M})$。此时，所有的边都已被保护。因此，贪心算法找到的顶点覆盖是\n$$C_{\\text{greedy}}=\\{\\text{A,B,C,D,E}\\},\\quad |C_{\\text{greedy}}|=5.$$\n\n接下来，确定最小顶点覆盖的大小 $\\tau(G)$。该图是一棵树，因此是二分图，所以根据 Kőnig's theorem，最小顶点覆盖的大小等于最大匹配的大小。对于以 $\\text{B},\\text{C},\\text{D},\\text{E}$ 为中心的每个分支，在 $\\{(\\text{A,child}),(\\text{child,leaf1}),(\\text{child,leaf2})\\}$ 中最多只有一条边可以存在于一个匹配中，因为这三条边共享一个子节点。因此，任何匹配的大小最多为 $4$。这个界是紧的：例如，\n$$M=\\{(\\text{B,F}),(\\text{C,H}),(\\text{D,J}),(\\text{E,L})\\}$$\n是一个大小为 $4$ 的匹配。因此，最大匹配的大小为 $4$，所以\n$$\\tau(G)=4.$$\n\n另外，可以直接给出一个最小顶点覆盖：$C^*=\\{\\text{B,C,D,E}\\}$ 覆盖了所有边，因为每条边都与这些顶点之一邻接。不存在更小的覆盖，因为从 $\\{\\text{B,C,D,E}\\}$ 中移除任意一个顶点，都将迫使我们将其两个叶节点以及可能还有 $\\text{A}$ 加入覆盖集，以覆盖所有三条邻接边，而这使用的顶点数并不会更少。\n\n近似比定义为\n$$\\rho=\\frac{|C_{\\text{greedy}}|}{\\tau(G)}=\\frac{5}{4}=1.25.$$\n保留三位有效数字，结果是 $1.25$。", "answer": "$$\\boxed{1.25}$$", "id": "1481665"}, {"introduction": "我们最后的练习将介绍一种更复杂的技术，称为局部搜索，其目标是迭代地改进一个现有解。然而，这类方法的一个普遍挑战是陷入“局部最优”的风险——一个在其直接邻域内看起来是最好，但并非全局最好的解。这个问题 [@problem_id:1481689] 为这一现象提供了一个绝佳的例子，它将引导你发现为什么一个看似合理的改进策略可能无法找到全局最优解，这是对启发式算法局限性的一个关键洞察。", "problem": "一家信息技术公司正在开发一种新颖的局部搜索启发式算法，用于在图 $G=(V, E)$ 中寻找一个小的顶点覆盖。顶点覆盖是一个顶点子集 $C \\subseteq V$，使得 $E$ 中的每条边都至少有一个端点在 $C$ 中。目标是找到一个包含顶点数量尽可能少的顶点覆盖。\n\n所提出的算法如下所示：\n1.  **初始化**：从一个给定的候选集 $C \\subseteq V$ 开始，该集合保证是一个顶点覆盖。\n2.  **缩减步骤**：当当前的覆盖 $C$ 不是极小（即，存在一个顶点 $u \\in C$ 使得 $C \\setminus \\{u\\}$ 也是一个顶点覆盖）时，将 $C$ 更新为 $C \\setminus \\{u\\}$ 并重复此步骤。\n3.  **交换步骤**：缩减步骤终止后，当前的覆盖 $C$ 是一个极小顶点覆盖。算法现在搜索一个“交换”。交换被定义为一个顶点对 $(u, v)$，其中 $u \\in C$ 且 $v \\in V \\setminus C$。如果新集合 $C' = (C \\setminus \\{u\\}) \\cup \\{v\\}$ 也是一个顶点覆盖，则算法通过设置 $C \\leftarrow C'$ 来执行交换，并返回到步骤2以尝试进一步的缩减。\n4.  **终止**：如果当前的极小覆盖 $C$ 没有可能的缩减（根据完成步骤2的定义），并且在步骤3中找不到有效的交换，则算法终止并返回 $C$ 作为其结果。\n\n考虑一个按如下方式构造的特定二分图。其顶点集被划分为两个不相交的集合 $A = \\{a_1, a_2\\}$ 和 $B = \\{b_1, b_2, b_3\\}$。边仅存在于集合 $A$ 的一个顶点和集合 $B$ 的一个顶点之间。具体来说，该图是一个完全二分图 $K_{2,3}$。\n\n算法使用起始顶点覆盖 $C_0 = B = \\{b_1, b_2, b_3\\}$ 进行初始化。\n\n你的任务是分析该算法的执行过程。确定算法返回的顶点覆盖的大小。然后，确定该图的真正最小顶点覆盖的大小。\n\n将你的答案表示为一对整数 $(S_L, S_O)$，其中 $S_L$ 是算法返回的局部最优覆盖的大小，而 $S_O$ 是全局最优（最小）顶点覆盖的大小。", "solution": "我们在部集为 $A=\\{a_{1},a_{2}\\}$ 和 $B=\\{b_{1},b_{2},b_{3}\\}$ 的图 $K_{2,3}$ 上分析该算法，该算法以 $C_{0}=B=\\{b_{1},b_{2},b_{3}\\}$ 为初始值。\n\n步骤2（缩减）：如果存在 $u \\in C$ 使得 $C \\setminus \\{u\\}$ 仍是顶点覆盖，则覆盖 $C$ 不是极小的。取任意 $u=b_j \\in C_0$。考虑 $C_0 \\setminus \\{b_j\\} = \\{b_1, b_2, b_3\\} \\setminus \\{b_j\\}$。与 $b_j$ 相关联的边是 $(a_1, b_j)$ 和 $(a_2, b_j)$。由于 $a_1, a_2 \\notin C_0 \\setminus \\{b_j\\}$ 且 $b_j \\notin C_0 \\setminus \\{b_j\\}$，这些边中的任何一条的两个端点都不在 $C_0 \\setminus \\{b_j\\}$ 中，因此 $C_0 \\setminus \\{b_j\\}$ 不是一个顶点覆盖。因此，没有 $b_j$ 可以被移除，所以 $C_0$ 是极小的。因此，步骤2终止，得到大小为3的覆盖 $C=B$。\n\n步骤3（交换）：一次交换是将 $C$ 中的某个 $u$ 替换为 $V \\setminus C$ 中的某个 $v$，同时保持顶点覆盖的性质。这里 $C=B$ 且 $V\\setminus C=A$。令 $u=b_j$ 和 $v=a_i$，并定义 $C'=(C\\setminus\\{b_j\\})\\cup\\{a_i\\}$。考虑边 $(a_k, b_j)$，其中 $\\{i,k\\}=\\{1,2\\}$。在 $C'$ 中，我们有 $a_k \\notin C'$ 且 $b_j \\notin C'$，所以 $(a_k, b_j)$ 未被覆盖。因此，没有这样的交换能产生一个顶点覆盖，步骤3找不到有效的交换。算法终止，并返回大小为 $S_L=3$ 的覆盖 $C=B$。\n\n全局最优解：根据 Kőnig 定理（或匹配下界），对于二分图，最小顶点覆盖的大小 $\\tau(G)$ 等于最大匹配的大小 $\\nu(G)$。在 $K_{2,3}$ 中，$\\nu(G)=2$（例如，将每个 $a_i$ 匹配到一个不同的 $b_j$），因此 $\\tau(G)=2$。所以最小顶点覆盖的大小为 $S_{O}=2$。", "answer": "$$\\boxed{\\begin{pmatrix} 3 & 2 \\end{pmatrix}}$$", "id": "1481689"}]}