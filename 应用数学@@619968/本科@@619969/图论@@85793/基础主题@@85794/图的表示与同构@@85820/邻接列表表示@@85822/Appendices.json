{"hands_on_practices": [{"introduction": "我们首先从一个基本问题入手，探讨邻接表示法的一个基本属性：它的大小。这个练习要求你计算一个完全图 $K_n$ 的邻接表中所有项的总数。通过解决这个问题 [@problem_id:1479131]，你将在数据结构的内存占用与图论核心概念（如顶点度数和总边数）之间建立直接的联系。", "problem": "设 $K_n$ 是一个有 $n$ 个顶点的完全图，其中 $n \\geq 2$。完全图是一个简单无向图，其中每对不同的顶点都由一条唯一的边连接。\n\n该图使用邻接表结构来表示。在这种表示方法中，对于 $n$ 个顶点中的每一个，我们都维护一个列表，其中包含所有与其直接相连的其他顶点。\n\n确定图 $K_n$ 的所有邻接表中的条目总数的公式。请将您的答案表示为 $n$ 的函数。", "solution": "在邻接表表示法中，所有列表中的条目总数等于所有顶点的度数之和，因为每个顶点为其每个相邻顶点在邻接表中贡献一个条目。\n\n在完全图 $K_{n}$ 中，每个顶点都与所有其他顶点相邻，因此每个顶点的度为 $n-1$。因此，直接对度数求和可得\n$$\n\\sum_{v \\in V} \\deg(v) = n \\cdot (n-1) = n(n-1).\n$$\n等价地，根据握手引理，度数之和等于边数的两倍：\n$$\n\\sum_{v \\in V} \\deg(v) = 2|E|.\n$$\n对于 $K_{n}$，其边数为\n$$\n|E| = \\binom{n}{2} = \\frac{n(n-1)}{2},\n$$\n所以\n$$\n\\sum_{v \\in V} \\deg(v) = 2 \\cdot \\frac{n(n-1)}{2} = n(n-1).\n$$\n因此，$K_{n}$ 的邻接表条目总数为 $n(n-1)$。", "answer": "$$\\boxed{n(n-1)}$$", "id": "1479131"}, {"introduction": "从无向图转向有向图后，我们常常需要寻找具有特定属性的顶点，例如那些没有入边的顶点（即源顶点）。这个练习 [@problem_id:1479134] 挑战你仅使用一个存储出边的标准邻接表来识别所有的源顶点。这种情况很常见，它突显了如何推导出未被显式存储的图属性，这是算法问题求解中的一项关键技能。", "problem": "在一个大型软件项目中，构建系统会分析不同模块之间的依赖关系，以确定正确的编译顺序。这些依赖关系可以被建模为一个有向图 $G = (V, E)$，其中顶点集合 $V$ 代表模块，一条有向边 $(U, V) \\in E$ 表示模块 $U$ 必须在模块 $V$ 之前编译。\n\n依赖信息存储在标准的邻接表表示中。对于每个模块 $U \\in V$，都有一个列表 `adj[U]`，其中包含所有存在边 $(U, V)$ 的模块 $V$。\n\n“基础模块”被定义为没有任何先决条件的模块；它不依赖于任何其他模块。用图论的术语来说，这对应于“源顶点”，即入度为零的顶点。\n\n考虑一个有8个模块的项目，标记为 $V = \\{0, 1, 2, 3, 4, 5, 6, 7\\}$。该依赖图的邻接表如下所示：\n- `adj[0] = [1, 2]`\n- `adj[1] = [3]`\n- `adj[2] = [3, 4]`\n- `adj[3] = []`\n- `adj[4] = []`\n- `adj[5] = [6]`\n- `adj[6] = [4]`\n- `adj[7] = []`\n\n仅使用所提供的邻接表，找出所有基础模块的完整集合。\n\nA. {3, 4, 7}\n\nB. {0, 5, 7}\n\nC. {0, 5}\n\nD. {7}\n\nE. {0, 1, 2, 5, 6}", "solution": "我们给定了一个有向图，其顶点集为 $V=\\{0,1,2,3,4,5,6,7\\}$，以及指定出边的邻接表。一个基础模块是一个源顶点，即入度为零的顶点。令 $\\deg^{-}(v)$ 表示顶点 $v$ 的入度。\n\n对所有 $v \\in V$ 初始化：\n$$\n\\deg^{-}(v)=0.\n$$\n\n处理每个邻接表，并为每条有向边的目标顶点增加 $\\deg^{-}$ 的值：\n- 从 $0$ 出发：边 $(0,1)$ 和 $(0,2)$ 得到\n$$\n\\deg^{-}(1)\\leftarrow \\deg^{-}(1)+1=1,\\quad \\deg^{-}(2)\\leftarrow \\deg^{-}(2)+1=1.\n$$\n- 从 $1$ 出发：边 $(1,3)$ 得到\n$$\n\\deg^{-}(3)\\leftarrow \\deg^{-}(3)+1=1.\n$$\n- 从 $2$ 出发：边 $(2,3)$ 和 $(2,4)$ 得到\n$$\n\\deg^{-}(3)\\leftarrow \\deg^{-}(3)+1=2,\\quad \\deg^{-}(4)\\leftarrow \\deg^{-}(4)+1=1.\n$$\n- 从 $3$ 出发：没有边，无变化。\n- 从 $4$ 出发：没有边，无变化。\n- 从 $5$ 出发：边 $(5,6)$ 得到\n$$\n\\deg^{-}(6)\\leftarrow \\deg^{-}(6)+1=1.\n$$\n- 从 $6$ 出发：边 $(6,4)$ 得到\n$$\n\\deg^{-}(4)\\leftarrow \\deg^{-}(4)+1=2.\n$$\n- 从 $7$ 出发：没有边，无变化。\n\n收集最终的入度值：\n$$\n\\deg^{-}(0)=0,\\ \\deg^{-}(1)=1,\\ \\deg^{-}(2)=1,\\ \\deg^{-}(3)=2,\\ \\deg^{-}(4)=2,\\ \\deg^{-}(5)=0,\\ \\deg^{-}(6)=1,\\ \\deg^{-}(7)=0.\n$$\n\n入度 $\\deg^{-}(v)=0$ 的顶点是\n$$\n\\{0,5,7\\}.\n$$\n与选项比较，这与选项B匹配。", "answer": "$$\\boxed{B}$$", "id": "1479134"}, {"introduction": "邻接表是许多复杂图算法的基础。最后一个练习 [@problem_id:1479126] 深入探讨了在有向无环图 (DAG) 上使用动态规划来寻找从每个顶点出发的最长路径。解决这个问题表明你已经掌握了如何利用图结构的递归性质（通过邻接表进行导航），从而高效地解决复杂的优化问题。", "problem": "一个软件项目由多个相互依赖的模块组成。这些依赖关系形成一个有向图，其中从模块 `u` 到模块 `v` 的一条边表示 `u` 必须在 `v` 开始之前完成。项目管理团队已确认不存在循环依赖，这意味着该图是一个有向无环图 (DAG)。一个任务序列的“完成时间”取决于顺序依赖步骤的数量。具体来说，该图中路径的长度定义为其包含的边的数量。\n\n考虑一个有7个模块的项目，标记为0到6。这些依赖关系由以下邻接表表示给出，其中 `Adj[i]` 包含直接依赖于模块 `i` 的模块列表：\n\n*   `Adj[0] = [1, 2]`\n*   `Adj[1] = [3]`\n*   `Adj[2] = [3, 4]`\n*   `Adj[3] = [5]`\n*   `Adj[4] = [5, 6]`\n*   `Adj[5] = []`\n*   `Adj[6] = []`\n\n您的任务是确定对于每个模块，在其之后必须完成的最长依赖模块序列的长度。这对应于在依赖关系图中找出从每个顶点出发的最长路径的长度。\n\n请分别计算从顶点0到6出发的最长路径的长度。请将您的最终答案以一个行矩阵的形式呈现，其中按顺序包含从顶点0到顶点6的这七个整数长度。", "solution": "设给定的有向无环图为 $G = (V, E)$，其中 $V = \\{0, 1, 2, 3, 4, 5, 6\\}$ 是顶点（模块）的集合，而 $E$ 是由邻接表定义的边（依赖关系）的集合。我们需要找到从每个顶点 $u \\in V$ 出发的最长路径的长度。我们用 $L(u)$ 表示这个量。路径的长度是它所包含的边的数量。\n\n这个问题可以使用动态规划和记忆化来高效解决。关键的思路是递归地定义 $L(u)$。\n一个没有出边（汇点）的顶点 $u$ 不可能作为任何路径的起点，因此从它开始的最长路径长度为0。\n对于任何其他顶点 $u$，从 $u$ 开始的路径包含一条到其邻居 $v$ 的边 $(u, v)$，后面跟着一条从 $v$ 开始的路径。为了找到从 $u$ 出发的最长路径，我们必须选择从其出发的路径最长的邻居 $v$。\n\n这为我们提供了关于 $L(u)$ 的以下递推关系：\n- 如果 $u$ 的出度为0（即 `Adj[u]` 为空），则 $L(u) = 0$。\n- 否则，$L(u) = 1 + \\max_{v \\in \\text{Adj}[u]} \\{L(v)\\}$.\n\n该公式的一个朴素的递归实现效率会很低，因为单个顶点 $v$ 的 $L(v)$ 值可能会被多次重复计算。例如，在我们的图中，计算 $L(1)$ 和 $L(2)$ 都需要 $L(3)$ 的值。\n\n为避免冗余计算，我们使用记忆化。我们将使用一个与顶点数量大小相同的数组，称之为 `memo`，并用一个哨兵值（例如-1）进行初始化，以表示该顶点的最长路径尚未计算。\n\n算法流程如下：我们定义一个函数 `compute_L(u)`，用于计算 $L(u)$。\n1.  如果 `memo[u]` 不等于 -1，意味着我们已经计算过 $L(u)$，因此我们返回存储的值 `memo[u]`。\n2.  如果 `Adj[u]` 为空，则 $u$ 是一个汇点。我们设置 `memo[u] = 0` 并返回 0。\n3.  否则，我们对 `Adj[u]` 中的所有邻居 $v$ 递归调用 `compute_L(v)`。我们取这些返回值的最大值，加1，并将结果存储在 `memo[u]` 中。\n4.  最后，我们遍历 $V$ 中的所有顶点 $i$，如果其值尚未计算，则调用 `compute_L(i)`。\n\n让我们将此方法应用于给定的图。初始化 `memo = [-1, -1, -1, -1, -1, -1, -1]`。\n\n我们需要计算 $L(0), L(1), \\dots, L(6)$。让我们从 `compute_L(0)` 开始，以深度优先的方式计算它们。\n\n- **`compute_L(0)`**：`memo[0]` 是-1。`Adj[0] = [1, 2]`。我们需要 $L(1)$ 和 $L(2)$。\n    - **`compute_L(1)`**：`memo[1]` 是-1。`Adj[1] = [3]`。我们需要 $L(3)$。\n        - **`compute_L(3)`**：`memo[3]` 是-1。`Adj[3] = [5]`。我们需要 $L(5)$。\n            - **`compute_L(5)`**：`memo[5]` 是-1。`Adj[5]` 为空。所以，$L(5) = 0$。设置 `memo[5] = 0`。返回 0。\n        - 回到 `compute_L(3)`，我们有 $L(5)=0$。所以，$L(3) = 1 + L(5) = 1 + 0 = 1$。设置 `memo[3] = 1`。返回 1。\n    - 回到 `compute_L(1)`，我们有 $L(3)=1$。所以，$L(1) = 1 + L(3) = 1 + 1 = 2$。设置 `memo[1] = 2`。返回 2。\n    - 现在 `compute_L(0)` 需要 $L(2)$。\n    - **`compute_L(2)`**：`memo[2]` 是-1。`Adj[2] = [3, 4]`。我们需要 $L(3)$ 和 $L(4)$。\n        - **`compute_L(3)`**：`memo[3]` 是 1（已计算）。返回 1。\n        - **`compute_L(4)`**：`memo[4]` 是-1。`Adj[4] = [5, 6]`。我们需要 $L(5)$ 和 $L(6)$。\n            - **`compute_L(5)`**：`memo[5]` 是 0（已计算）。返回 0。\n            - **`compute_L(6)`**：`memo[6]` 是-1。`Adj[6]` 为空。所以，$L(6) = 0$。设置 `memo[6] = 0`。返回 0。\n        - 回到 `compute_L(4)`，我们有 $L(5)=0$ 和 $L(6)=0$。所以，$L(4) = 1 + \\max(L(5), L(6)) = 1 + \\max(0, 0) = 1$。设置 `memo[4] = 1`。返回 1。\n    - 回到 `compute_L(2)`，我们有 $L(3)=1$ 和 $L(4)=1$。所以，$L(2) = 1 + \\max(L(3), L(4)) = 1 + \\max(1, 1) = 2$。设置 `memo[2] = 2`。返回 2。\n- 回到 `compute_L(0)`，我们有 $L(1)=2$ 和 $L(2)=2$。所以，$L(0) = 1 + \\max(L(1), L(2)) = 1 + \\max(2, 2) = 3$。设置 `memo[0] = 3`。\n\n此时，`memo` 数组为 `[3, 2, 2, 1, 1, 0, 0]`。所有值都已在对 `compute_L(0)` 的初始调用中计算完毕。我们可以验证我们的结果：\n- $L(6) = 0$ (汇点)\n- $L(5) = 0$ (汇点)\n- $L(4) = 1 + \\max(L(5), L(6)) = 1 + \\max(0, 0) = 1$\n- $L(3) = 1 + L(5) = 1 + 0 = 1$\n- $L(2) = 1 + \\max(L(3), L(4)) = 1 + \\max(1, 1) = 2$\n- $L(1) = 1 + L(3) = 1 + 1 = 2$\n- $L(0) = 1 + \\max(L(1), L(2)) = 1 + \\max(2, 2) = 3$\n\n计算结果是一致的。最终从顶点0到6的最长路径长度列表为 (3, 2, 2, 1, 1, 0, 0)。", "answer": "$$\\boxed{\\begin{pmatrix} 3 & 2 & 2 & 1 & 1 & 0 & 0 \\end{pmatrix}}$$", "id": "1479126"}]}