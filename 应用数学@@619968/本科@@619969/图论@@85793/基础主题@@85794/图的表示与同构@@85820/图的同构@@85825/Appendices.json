{"hands_on_practices": [{"introduction": "要证明两个图是同构的，最直接的方法是找到一个保持结构不变的顶点映射。这个练习让你亲手构建这样一个映射，将抽象的同构定义应用于一个具体的例子。通过为一对看似不同（路径图$P_4$及其补图）的图找到一个有效的同构函数，你将加深对图同构核心意义的理解。", "problem": "考虑两个不同的通信网络，Alpha和Beta，每个网络都由四个标记为 $\\{n_1, n_2, n_3, n_4\\}$ 的节点组成。这两个网络由其节点之间的直接通信链路定义。\n\n在网络Alpha中，链路被配置为一条简单路径：在 $n_1$ 和 $n_2$ 之间、 $n_2$ 和 $n_3$ 之间、以及 $n_3$ 和 $n_4$ 之间存在链路。网络Alpha中不存在其他链路。\n\n网络Beta的设计基于与网络Alpha互补的原则。在网络Beta中，任意两个节点之间存在直接链路，当且仅当在网络Alpha中这两个相同的节点之间*没有*直接链路。\n\n如果一个网络可以通过简单地重新标记其节点来变换成另一个网络，那么这两个网络被认为是结构相同或同构的。形式上，这意味着存在一个一对一且映上的函数 $f$（一个双射），将网络Alpha的节点映射到网络Beta的节点，使得网络Alpha中的任意两个节点 $u$ 和 $v$ 之间存在链路，当且仅当网络Beta中对应的节点 $f(u)$ 和 $f(v)$ 之间也存在链路。\n\n下列哪个函数 $f: \\{n_1, n_2, n_3, n_4\\} \\to \\{n_1, n_2, n_3, n_4\\}$ 表示一个从网络Alpha到网络Beta的有效同构？\n\nA. $f(n_1) = n_1$, $f(n_2) = n_2$, $f(n_3) = n_3$, $f(n_4) = n_4$\n\nB. $f(n_1) = n_4$, $f(n_2) = n_3$, $f(n_3) = n_2$, $f(n_4) = n_1$\n\nC. $f(n_1) = n_2$, $f(n_2) = n_4$, $f(n_3) = n_1$, $f(n_4) = n_3$\n\nD. $f(n_1) = n_2$, $f(n_2) = n_1$, $f(n_3) = n_4$, $f(n_4) = n_3$\n\nE. $f(n_1) = n_1$, $f(n_2) = n_3$, $f(n_3) = n_2$, $f(n_4) = n_4$", "solution": "令 $V=\\{n_{1},n_{2},n_{3},n_{4}\\}$。在网络Alpha中（称之为$A$），其边集为\n$$\nE_{A}=\\big\\{\\{n_{1},n_{2}\\},\\{n_{2},n_{3}\\},\\{n_{3},n_{4}\\}\\big\\}。\n$$\n网络Beta（称之为$B$）是$A$在$V$上的补图，因此它的边恰好是$A$的非边。由于$K_{4}$有$6$条边，而$E_{A}$有$3$条边，所以补图的边是\n$$\nE_{B}=\\big\\{\\{n_{1},n_{3}\\},\\{n_{1},n_{4}\\},\\{n_{2},n_{4}\\}\\big\\}。\n$$\n一个函数 $f:V\\to V$ 是从 $A$ 到 $B$ 的一个同构，当且仅当对于所有不同的 $u,v\\in V$，\n$$\n\\{u,v\\}\\in E_{A}\\quad\\Longleftrightarrow\\quad \\{f(u),f(v)\\}\\in E_{B}。\n$$\n\n检验每个选项：\n\nA. 恒等函数 $f(n_{i})=n_{i}$ 不成立，因为 $\\{n_{1},n_{2}\\}\\in E_{A}$ 映射到 $\\{n_{1},n_{2}\\}\\notin E_{B}$。\n\nB. $f(n_{1})=n_{4}$, $f(n_{2})=n_{3}$, $f(n_{3})=n_{2}$, $f(n_{4})=n_{1}$ 不成立，因为 $\\{n_{1},n_{2}\\}\\in E_{A}$ 映射到 $\\{n_{4},n_{3}\\}=\\{n_{3},n_{4}\\}\\notin E_{B}$。\n\nC. $f(n_{1})=n_{2}$, $f(n_{2})=n_{4}$, $f(n_{3})=n_{1}$, $f(n_{4})=n_{3}$ 成立。检查 $A$ 的边：\n- $\\{n_{1},n_{2}\\}\\mapsto\\{n_{2},n_{4}\\}\\in E_{B}$，\n- $\\{n_{2},n_{3}\\}\\mapsto\\{n_{4},n_{1}\\}=\\{n_{1},n_{4}\\}\\in E_{B}$，\n- $\\{n_{3},n_{4}\\}\\mapsto\\{n_{1},n_{3}\\}\\in E_{B}$。\n检查 $A$ 的非边（它们必须映射到 $B$ 的非边）：\n- $\\{n_{1},n_{3}\\}\\mapsto\\{n_{2},n_{1}\\}=\\{n_{1},n_{2}\\}\\notin E_{B}$，\n- $\\{n_{1},n_{4}\\}\\mapsto\\{n_{2},n_{3}\\}\\notin E_{B}$，\n- $\\{n_{2},n_{4}\\}\\mapsto\\{n_{4},n_{3}\\}=\\{n_{3},n_{4}\\}\\notin E_{B}$。\n因此，当且仅当条件成立，所以 $f$ 是一个同构。\n\nD. $f(n_{1})=n_{2}$, $f(n_{2})=n_{1}$, $f(n_{3})=n_{4}$, $f(n_{4})=n_{3}$ 不成立，因为 $\\{n_{1},n_{2}\\}\\in E_{A}$ 映射到 $\\{n_{1},n_{2}\\}\\notin E_{B}$。\n\nE. $f(n_{1})=n_{1}$, $f(n_{2})=n_{3}$, $f(n_{3})=n_{2}$, $f(n_{4})=n_{4}$ 不成立，因为 $\\{n_{2},n_{3}\\}\\in E_{A}$ 映射到 $\\{n_{3},n_{2}\\}=\\{n_{2},n_{3}\\}\\notin E_{B}$。\n\n所以，选项中唯一有效的同构是C。", "answer": "$$\\boxed{C}$$", "id": "1379138"}, {"introduction": "相比于证明同构，证明两个图“不同构”通常更为直接，关键在于找到一个“图不变量”——一个在同构变换下保持不变的图属性。这个练习将挑战你分辨两个在顶点数、边数甚至度序列上都完全相同的图。这迫使我们寻找更精细的结构不变量，例如二分性或奇数环的存在性，从而锻炼我们解决复杂问题的分析能力。", "problem": "在图论中，一个无向图 $G$ 由一个集合对 $(V, E)$ 定义，其中 $V$ 是一个顶点集，$E$ 是一个边集，每条边是不同顶点的一个无序对。如果存在一个双射（即一一对应的函数）$f: V_1 \\to V_2$，使得 $V_1$ 中的任意两个顶点 $u$ 和 $v$ 相邻，当且仅当顶点 $f(u)$ 和 $f(v)$ 在 $G_2$ 中相邻，那么称两个图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$ 是同构的。\n\n考虑四个图，$G_A, G_B, G_C,$ 和 $G_D$，它们都定义在同一个顶点集 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6\\}$ 上。它们的边集如下所示。注意，为简洁起见，边 $\\{u, v\\}$ 记作 $(u, v)$。\n\n**图 $G_A$：**\n$E_A = \\{(v_1, v_2), (v_2, v_3), (v_3, v_1), (v_4, v_5), (v_5, v_6), (v_6, v_4), (v_1, v_4), (v_2, v_5), (v_3, v_6)\\}$\n\n**图 $G_B$：**\n$E_B = \\{(v_1, v_4), (v_1, v_5), (v_1, v_6), (v_2, v_4), (v_2, v_5), (v_2, v_6), (v_3, v_4), (v_3, v_5), (v_3, v_6)\\}$\n\n**图 $G_C$：**\n$E_C = \\{(v_1, v_3), (v_3, v_5), (v_5, v_1), (v_2, v_4), (v_4, v_6), (v_6, v_2), (v_1, v_2), (v_3, v_4), (v_5, v_6)\\}$\n\n**图 $G_D$：**\n$E_D = \\{(v_1, v_2), (v_1, v_4), (v_1, v_6), (v_3, v_2), (v_3, v_4), (v_3, v_6), (v_5, v_2), (v_5, v_4), (v_5, v_6)\\}$\n\n根据所提供的定义，以下哪个陈述是正确的？\n\nA. $G_A$ 与 $G_B$ 同构。\n\nB. $G_A$ 与 $G_D$ 同构。\n\nC. $G_B$ 与 $G_C$ 同构。\n\nD. $G_A$ 与 $G_C$ 同构，且 $G_B$ 与 $G_D$ 同构。\n\nE. 所有四个图都彼此同构。", "solution": "我们使用图同构不变量：度序列、奇圈的存在性（二分性）和显式双射。\n\n1) 分析 $G_{A}$。\n- 其边包括在 $\\{v_{1},v_{2},v_{3}\\}$ 和 $\\{v_{4},v_{5},v_{6}\\}$ 上的两个不相交的三角形，以及连接这两个三角形的一个完美匹配 $(v_{1},v_{4}),(v_{2},v_{5}),(v_{3},v_{6})$。\n- 每个顶点的度都为 $3$（其所在三角形内的两条边和一条匹配边）。\n- $G_{A}$ 包含三角形，因此它不是二部图。\n\n2) 分析 $G_{B}$。\n- 其边由集合 $\\{v_{1},v_{2},v_{3}\\}$ 中的顶点与集合 $\\{v_{4},v_{5},v_{6}\\}$ 中的顶点构成所有可能的配对，即 $K_{3,3}$。\n- 每个顶点的度都为 $3$。\n- $G_{B}$ 是二部图（根据 $K_{3,3}$ 的定义），不包含奇圈。\n\n3) 比较 $G_{A}$ 和 $G_{B}$。\n- $G_{A}$ 不是二部图（有三角形），$G_{B}$ 是二部图。由于二分性是同构不变量，所以 $G_{A} \\not\\cong G_{B}$。因此选项A是错误的。\n\n4) 分析 $G_{C}$。\n- 其边形成了在 $\\{v_{1},v_{3},v_{5}\\}$ 和 $\\{v_{2},v_{4},v_{6}\\}$ 上的两个三角形，以及连接这两个三角形的一个完美匹配 $(v_{1},v_{2}),(v_{3},v_{4}),(v_{5},v_{6})$。\n- 每个顶点的度都为 $3$；$G_{C}$ 包含三角形，不是二部图。\n\n5) 证明 $G_{A} \\cong G_{C}$。\n- 定义 $f:V\\to V$ 为 $f(v_{1})=v_{1}$，$f(v_{2})=v_{3}$，$f(v_{3})=v_{5}$，$f(v_{4})=v_{2}$，$f(v_{5})=v_{4}$，$f(v_{6})=v_{6}$。\n- 检查边：\n  - $G_{A}$ 中的三角形：$(v_{1},v_{2})\\mapsto(v_{1},v_{3})$，$(v_{2},v_{3})\\mapsto(v_{3},v_{5})$，$(v_{3},v_{1})\\mapsto(v_{5},v_{1})$ 都在 $E_{C}$ 中。\n  - 在 $\\{v_{4},v_{5},v_{6}\\}$ 上的三角形：$(v_{4},v_{5})\\mapsto(v_{2},v_{4})$，$(v_{5},v_{6})\\mapsto(v_{4},v_{6})$，$(v_{6},v_{4})\\mapsto(v_{6},v_{2})$ 都在 $E_{C}$ 中。\n  - 匹配边：$(v_{1},v_{4})\\mapsto(v_{1},v_{2})$，$(v_{2},v_{5})\\mapsto(v_{3},v_{4})$，$(v_{3},v_{6})\\mapsto(v_{5},v_{6})$ 都在 $E_{C}$ 中。\n- 因此 $G_{A} \\cong G_{C}$。\n\n6) 分析 $G_{D}$。\n- 其边由集合 $\\{v_{1},v_{3},v_{5}\\}$ 中的顶点与集合 $\\{v_{2},v_{4},v_{6}\\}$ 中的顶点构成所有可能的配对，即 $K_{3,3}$。\n- 因此 $G_{D}$ 是二部图，且每个顶点的度都为 $3$。\n\n7) 证明 $G_{B} \\cong G_{D}$。\n- 两者都是 $K_{3,3}$。一个显式双射：$g(v_{1})=v_{1}$，$g(v_{3})=v_{2}$，$g(v_{5})=v_{3}$，$g(v_{2})=v_{4}$，$g(v_{4})=v_{5}$，$g(v_{6})=v_{6}$ 将 $G_{D}$ 的二分划映射到 $G_{B}$ 的二分划，并将每条边映射到一条边，因为两个图都存在所有部集间的边。\n\n8) 排除其他选项：\n- B：$G_{A}$ 不是二部图但 $G_{D}$ 是；不同构。\n- C：$G_{B}$ 是二部图但 $G_{C}$ 不是；不同构。\n- E：由于二分性的差异，这四个图并非都彼此同构。\n\n因此，正确的陈述是 $G_A$ 与 $G_C$ 同构，且 $G_B$ 与 $G_D$ 同构。", "answer": "$$\\boxed{D}$$", "id": "1507615"}, {"introduction": "当手工检验变得困难时，我们可以转向算法来系统性地解决问题。此练习引入了“范式标签”这一强大概念，即为每个图生成一个唯一的“签名”字符串，从而将图同构问题转化为字符串比较问题。你将通过为一个有根树实现一个递归算法，亲身体验这一过程，这不仅解决了树同构这一特殊情况，也揭示了解决一般图同构难题的理论思路。", "problem": "在为层次化数据设计的数据库系统中，通常需要为树状数据结构生成一个唯一的、紧凑的“结构签名”。这个签名仅取决于树的拓扑结构，可用于快速相等性检查和索引。\n\n您的任务是为一个给定的有根树生成这样一种签名，我们称之为规范层次字符串 (Canonical Hierarchical String, CHS)。CHS 由以下递归规则定义：\n\n1.  **叶节点规则**：叶节点（没有子节点的节点）的 CHS 是字符串 \"0\"。\n2.  **内部节点规则**：对于一个内部节点（有子节点的节点），其 CHS 按如下方式构造：\n    a. 首先，递归地计算其每个子节点的 CHS。这将为每个子节点的子树生成一组字符串。\n    b. 按字典序对此组字符串进行排序（即，基于标准字符编码，按字母顺序，如同它们在字典中的出现顺序一样）。\n    c. 将排序后的字符串按顺序连接起来，不加任何分隔符，形成一个单一的新字符串。\n    d. 最后，用一对括号 `(` 和 `)` 将这个新连接的字符串括起来。得到的结果字符串就是该内部节点的 CHS。\n\n考虑以下由其父子关系定义的有根树：\n- 树的根节点是节点 `N0`。\n- `N0` 有两个子节点：`N1` 和 `N2`。\n- `N1` 有两个子节点：`N3` 和 `N4`。\n- `N2` 有三个子节点：`N5`、`N6` 和 `N7`。\n- `N3` 有两个子节点：`N8` 和 `N9`。\n- `N4` 有一个子节点：`N10`。\n- `N5` 有一个子节点：`N11`。\n- `N6` 有一个子节点：`N12`。\n- 节点 `N7`、`N8`、`N9`、`N10`、`N11` 和 `N12` 都是叶节点。\n\n确定根节点 `N0` 的规范层次字符串 (CHS)。", "solution": "我们应用规范层次字符串 (CHS) 的递归定义。\n\n根据叶节点规则，对于所有叶节点我们有：\n$$\\mathrm{CHS}(N_{7})=\\text{0},\\quad \\mathrm{CHS}(N_{8})=\\text{0},\\quad \\mathrm{CHS}(N_{9})=\\text{0},\\quad \\mathrm{CHS}(N_{10})=\\text{0},\\quad \\mathrm{CHS}(N_{11})=\\text{0},\\quad \\mathrm{CHS}(N_{12})=\\text{0}.$$\n\n对于上一层的内部节点，我们使用内部节点规则。\n\n对于有子节点 $N_{8}$ 和 $N_{9}$ 的 $N_{3}$，其子节点 CHS 字符串的多重集是 $\\{\\text{0},\\text{0}\\}$。排序后得到 $\\text{0},\\text{0}$，连接后得到 $\\text{00}$，用括号括起来得到：\n$$\\mathrm{CHS}(N_{3})=\\text{(00)}.$$\n\n对于有子节点 $N_{10}$ 的 $N_{4}$，我们对 $\\{\\text{0}\\}$ 进行排序（微不足道），连接得到 $\\text{0}$，然后括起来得到：\n$$\\mathrm{CHS}(N_{4})=\\text{(0)}.$$\n\n对于有子节点 $N_{11}$ 的 $N_{5}$，根据同样的推理得到：\n$$\\mathrm{CHS}(N_{5})=\\text{(0)}.$$\n\n对于有子节点 $N_{12}$ 的 $N_{6}$，类似地：\n$$\\mathrm{CHS}(N_{6})=\\text{(0)}.$$\n\n现在计算 $N_{1}$ 的 CHS，其子节点是 $N_{3}$ 和 $N_{4}$，对应的 CHS 字符串是 $\\text{(00)}$ 和 $\\text{(0)}$。为了进行字典序排序，逐个字符比较 $\\text{(0)}$ 和 $\\text{(00)}$：两者都以 $\\text{(}$ 开头，然后是 $\\text{0}$；在第三个字符处，$\\text{(0)}$ 中的 $\\text{)}$ 在标准字符顺序中先于 $\\text{(00)}$ 中的 $\\text{0}$。因此，排序后的顺序是 $\\text{(0)},\\text{(00)}$。连接后得到 $\\text{(0)(00)}$，括起来得到：\n$$\\mathrm{CHS}(N_{1})=\\text{((0)(00))}.$$\n\n接下来计算 $N_{2}$ 的 CHS，其子节点是 $N_{5}$、$N_{6}$ 和 $N_{7}$，对应的 CHS 字符串是 $\\text{(0)}$、$\\text{(0)}$ 和 $\\text{0}$。按字典序排序时，任何以 $\\text{(}$ 开头的字符串都在 \"0\" 之前，所以排序后的顺序是 $\\text{(0)},\\text{(0)},\\text{0}$。连接后得到 $\\text{(0)(0)0}$，括起来得到：\n$$\\mathrm{CHS}(N_{2})=\\text{((0)(0)0)}.$$\n\n最后，计算根节点 $N_{0}$ 的 CHS，其子节点是 $N_{1}$ 和 $N_{2}$，对应的 CHS 字符串是 $\\text{((0)(00))}$ 和 $\\text{((0)(0)0)}$。为了排序，我们逐个字符地比较 $\\text{((0)(00))}$ 和 $\\text{((0)(0)0)}$。它们的前六个字符 $\\text{((0)(0}$ 相同；在第七个字符处，$\\text{((0)(0)0)}$ 中的 $\\text{)}$ 先于 $\\text{((0)(00))}$ 中的 $\\text{0}$。因此，排序后的顺序是 $\\text{((0)(0)0)},\\text{((0)(00))}$。连接后得到 $\\text{((0)(0)0)((0)(00))}$，括起来得到：\n$$\\mathrm{CHS}(N_{0})=\\text{(((0)(0)0)((0)(00)))}.$$", "answer": "$$\\boxed{(((0)(0)0)((0)(00)))}$$", "id": "1507616"}]}