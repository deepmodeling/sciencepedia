{"hands_on_practices": [{"introduction": "托马斯-费米模型为我们描绘了原子内势能的整体图像。我们的第一个实践将聚焦于原子中一个至关重要的区域——无限靠近原子核的地方 ($r \\to 0$)。通过这个练习，我们将揭示电子云的屏蔽效应如何在原子中心修正裸核势，并看到这一修正如何与通用托马斯-费米函数的初始斜率 $\\phi'(0)$ 直接关联，后者是描述中性原子解的一个关键参数。[@problem_id:1161968]", "problem": "在原子序数为 $Z$ 的中性原子的 Thomas-Fermi 模型中，距离原子核 $r$ 处的电子的有效势能 $U(r)$ 由下式给出\n$$U(r) = -\\frac{Ze^2}{4\\pi\\epsilon_0 r} \\phi(x)$$\n其中 $e$ 是元电荷，$\\epsilon_0$ 是真空介电常数，$\\phi(x)$ 是通用 Thomas-Fermi 函数。无量纲距离 $x$ 通过标度关系 $r=bx$ 与径向距离 $r$ 相关，其中 $b$ 是一个依赖于 $Z$ 的特征长度。\n\n函数 $\\phi(x)$ 是 Thomas-Fermi 微分方程的解\n$$x^{1/2} \\frac{d^2\\phi}{dx^2} = \\phi^{3/2}$$\n对于中性原子，需满足以下边界条件：\n$$\\phi(0) = 1 \\quad \\text{and} \\quad \\phi(\\infty) = 0$$\n\n总势能 $U(r)$ 可被视为两部分贡献之和：来自与原子核相互作用的势能 $U_{\\text{nuc}}(r)$，以及来自与球对称电子云相互作用的势能 $U_{\\text{el}}(r)$。已知在点状原子核场中电子的势能为 $U_{\\text{nuc}}(r) = -Ze^2/(4\\pi\\epsilon_0 r)$，请推导在原子核位置处，由电子云贡献的势能 $U_{\\text{el}}(0)$ 的表达式。\n\n请用 $Z$、$e$、$\\epsilon_0$、标度长度 $b$ 和通用函数的初始斜率 $\\phi'(0) \\equiv \\left. \\frac{d\\phi}{dx} \\right|_{x=0}$ 来表示你的答案。", "solution": "1. 相关方程：\n总势能为 \n$$U(r)=U_{\\text{nuc}}(r)+U_{\\text{el}}(r),$$\n其中\n$$U_{\\text{nuc}}(r)=-\\frac{Ze^2}{4\\pi\\epsilon_0\\,r},\\quad \nU(r)=-\\frac{Ze^2}{4\\pi\\epsilon_0\\,r}\\,\\phi(x),\\quad x=\\frac{r}{b}.$$\n因此\n$$U_{\\text{el}}(r)=U(r)-U_{\\text{nuc}}(r)\n=-\\frac{Ze^2}{4\\pi\\epsilon_0\\,r}\\bigl[\\phi(x)-1\\bigr].$$\n\n2. 小 $r$ 展开：\n在 $r=0$ 附近，$x\\to0$，并且\n$$\\phi(x)=\\phi(0)+\\phi'(0)\\,x+\\cdots=1+\\phi'(0)\\,\\frac{r}{b}+\\cdots.$$\n因此\n$$\\phi(x)-1=\\phi'(0)\\,\\frac{r}{b}+\\cdots,$$\n所以\n$$U_{\\text{el}}(r)\n=-\\frac{Ze^2}{4\\pi\\epsilon_0\\,r}\\,\\phi'(0)\\,\\frac{r}{b}+\\cdots\n=-\\frac{Z e^2\\,\\phi'(0)}{4\\pi\\epsilon_0\\,b}+\\cdots.$$\n\n3. 在原子核处的值：\n取 $r\\to0$ 得到有限的贡献\n$$U_{\\text{el}}(0)=-\\frac{Z e^2\\,\\phi'(0)}{4\\pi\\epsilon_0\\,b}.$$", "answer": "$$\\boxed{-\\frac{Z e^2\\,\\phi'(0)}{4\\pi\\epsilon_0\\,b}}$$", "id": "1161968"}, {"introduction": "在探究了原子核附近的行为之后，我们现在将目光转向原子的外围区域 ($r \\to \\infty$)。这个实践旨在展示如何运用托马斯-费米方程已知的渐近解来计算宏观物理量。我们将以一个重原子为例，推导其在第一玻尔半径之外的电子数，并得出一个令人惊讶的结论——这个数值竟然是一个不依赖于原子序数 $Z$ 的普适常数。[@problem_id:1161957]", "problem": "Thomas-Fermi模型为原子序数 $Z \\gg 1$ 的重的中性原子中的电子云提供了一种统计描述。在此模型中，电子被视为处于自洽静电势中的简并费米气体。该模型导出了一个满足Thomas-Fermi方程的普适无量纲势函数 $\\phi(x)$：\n$$\n\\frac{d^2\\phi}{dx^2} = \\frac{\\phi(x)^{3/2}}{\\sqrt{x}}\n$$\n离原子核的径向距离 $r$ 与无量纲变量 $x$ 的关系为 $r=bx$，其中标度因子 $b$ 由下式给出：\n$$\nb = \\left(\\frac{9\\pi^2}{128}\\right)^{1/3} \\frac{a_0}{Z^{1/3}}\n$$\n且 $a_0$ 是玻尔半径。对于中性原子，势函数的边界条件为 $\\phi(0) = 1$ 和 $\\phi(\\infty) = 0$。\n\n电子数密度 $n(r)$ 可以用 $\\phi(x)$ 表示为：\n$$\nn(r) = \\frac{Z}{4\\pi b^3} \\frac{\\phi(x)^{3/2}}{x^{3/2}}\n$$\n对于大的 $x$ 值，普适函数 $\\phi(x)$ 具有众所周知的渐近行为：\n$$\n\\phi(x) \\approx \\frac{144}{x^3}\n$$\n使用该模型，推导在径向距离大于第一玻尔半径 $r > a_0$ 处的电子总数 $N_{out}(a_0)$ 的表达式。结果将是一个与 $Z$ 无关的常数。", "solution": "题目要求计算第一玻尔半径 $a_0$ 之外的电子数。这个量 $N_{out}(a_0)$ 是通过将电子数密度 $n(r)$ 从 $r=a_0$ 积分到无穷大得到的。\n$$\nN_{out}(a_0) = \\int_{a_0}^{\\infty} n(r) 4\\pi r^2 dr\n$$\n我们已知用Thomas-Fermi函数 $\\phi(x)$ 表示的数密度 $n(r)$ 的表达式：\n$$\nn(r) = \\frac{Z}{4\\pi b^3} \\frac{\\phi(x)^{3/2}}{x^{3/2}}\n$$\n我们可以使用Thomas-Fermi方程本身，即 $\\frac{d^2\\phi}{dx^2} = \\frac{\\phi^{3/2}}{\\sqrt{x}}$，来简化 $n(r)$ 的表达式：\n$$\n\\phi(x)^{3/2} = \\sqrt{x} \\frac{d^2\\phi}{dx^2}\n$$\n将此代入 $n(r)$ 的表达式中：\n$$\nn(r) = \\frac{Z}{4\\pi b^3} \\frac{\\sqrt{x} \\phi''(x)}{x^{3/2}} = \\frac{Z}{4\\pi b^3} \\frac{\\phi''(x)}{x}\n$$\n现在，将这个简化后的密度代入 $N_{out}(a_0)$ 的积分中。我们还必须将积分变量从 $r$ 更改为 $x$。关系为 $r=bx$，因此 $dr = bdx$。积分下限 $r=a_0$ 对应于标度坐标 $X_0 = a_0/b$。\n$$\nN_{out}(a_0) = \\int_{X_0}^{\\infty} \\left( \\frac{Z}{4\\pi b^3} \\frac{\\phi''(x)}{x} \\right) 4\\pi (bx)^2 (b dx)\n$$\n简化积分内的项：\n$$\nN_{out}(a_0) = Z \\int_{X_0}^{\\infty} \\frac{1}{4\\pi b^3} \\frac{\\phi''(x)}{x} 4\\pi b^2 x^2 b dx = Z \\int_{X_0}^{\\infty} x \\phi''(x) dx\n$$\n这个积分可以用分部积分法求解，$\\int u \\, dv = uv - \\int v \\, du$。令 $u=x$ 和 $dv = \\phi''(x)dx$，可得 $du=dx$ 和 $v=\\phi'(x)$。\n$$\n\\int_{X_0}^{\\infty} x \\phi''(x) dx = [x \\phi'(x)]_{X_0}^{\\infty} - \\int_{X_0}^{\\infty} \\phi'(x) dx\n$$\n$$\n= \\left(\\lim_{x\\to\\infty} x \\phi'(x) - X_0 \\phi'(X_0)\\right) - [\\phi(x)]_{X_0}^{\\infty}\n$$\n$$\n= \\left(\\lim_{x\\to\\infty} x \\phi'(x) - X_0 \\phi'(X_0)\\right) - \\left(\\lim_{x\\to\\infty} \\phi(x) - \\phi(X_0)\\right)\n$$\n我们使用给定的大 $x$ 值的渐近行为，$\\phi(x) \\approx A/x^3$，其中 $A=144$。其导数为 $\\phi'(x) \\approx -3A/x^4$。\n在无穷远处的极限为：\n$$\n\\lim_{x\\to\\infty} \\phi(x) = \\lim_{x\\to\\infty} \\frac{A}{x^3} = 0\n$$\n$$\n\\lim_{x\\to\\infty} x \\phi'(x) = \\lim_{x\\to\\infty} x \\left(\\frac{-3A}{x^4}\\right) = \\lim_{x\\to\\infty} \\frac{-3A}{x^3} = 0\n$$\n将这些极限代入积分后的表达式中：\n$$\n\\int_{X_0}^{\\infty} x \\phi''(x) dx = (0 - X_0\\phi'(X_0)) - (0 - \\phi(X_0)) = \\phi(X_0) - X_0\\phi'(X_0)\n$$\n因此，对应于半径 $X_0$ 之外的电子数为：\n$$\nN_{out}(X_0) = Z (\\phi(X_0) - X_0\\phi'(X_0))\n$$\n现在我们求出 $r=a_0$ 时 $X_0$ 的值。\n$$\nX_0 = \\frac{a_0}{b} = \\frac{a_0}{\\left(\\frac{9\\pi^2}{128}\\right)^{1/3} \\frac{a_0}{Z^{1/3}}} = \\left(\\frac{128}{9\\pi^2}\\right)^{1/3} Z^{1/3}\n$$\n由于题目考虑的是 $Z \\gg 1$ 的情况，所以 $X_0$ 很大，因此我们可以使用 $\\phi(X_0)$ 和 $\\phi'(X_0)$ 的渐近形式。\n$$\n\\phi(X_0) \\approx \\frac{A}{X_0^3} \\quad, \\quad \\phi'(X_0) \\approx -\\frac{3A}{X_0^4}\n$$\n将这些代入 $N_{out}(a_0)$ 的表达式中：\n$$\nN_{out}(a_0) \\approx Z \\left( \\frac{A}{X_0^3} - X_0 \\left(-\\frac{3A}{X_0^4}\\right) \\right) = Z \\left( \\frac{A}{X_0^3} + \\frac{3A}{X_0^3} \\right) = \\frac{4AZ}{X_0^3}\n$$\n现在我们代入 $X_0$ 的表达式：\n$$\nX_0^3 = \\left( \\left(\\frac{128}{9\\pi^2}\\right)^{1/3} Z^{1/3} \\right)^3 = \\frac{128 Z}{9\\pi^2}\n$$\n最后，我们计算 $N_{out}(a_0)$：\n$$\nN_{out}(a_0) = \\frac{4AZ}{X_0^3} = \\frac{4(144)Z}{(128Z)/(9\\pi^2)} = \\frac{576 Z \\cdot 9\\pi^2}{128 Z}\n$$\n因子 $Z$ 被消掉了，正如预期的那样。\n$$\nN_{out}(a_0) = \\frac{576 \\cdot 9\\pi^2}{128}\n$$\n分数简化为：$\\frac{576}{128} = \\frac{4 \\cdot 144}{128} = \\frac{144}{32} = \\frac{9 \\cdot 16}{2 \\cdot 16} = \\frac{9}{2}$。\n$$\nN_{out}(a_0) = \\frac{9}{2} \\cdot 9\\pi^2 = \\frac{81\\pi^2}{2}\n$$", "answer": "$$\n\\boxed{\\frac{81\\pi^2}{2}}\n$$", "id": "1161957"}, {"introduction": "前面的练习依赖于解在极限情况下的解析性质，但我们如何获得在所有尺度上都成立的完整解函数 $\\phi(x)$ 呢？这个实践将带你深入问题的计算核心，指导你使用有限差分法和牛顿迭代法来求解非线性的托马斯-费米方程。这正是物理学家们实际确定通用函数形态及其重要属性（如初始斜率 $\\phi'(0) \\approx -1.588$）所采用的方法，它连接了理论分析与可计算的物理现实。[@problem_id:2392752]", "problem": "考虑球对称中性原子的托马斯-费米模型。经过无量纲化后，有效势$\\phi(x)$满足以下奇异非线性边值问题\n$$\n\\phi''(x) \\;=\\; \\frac{\\phi(x)^{3/2}}{\\sqrt{x}}, \\qquad x \\in (0,\\infty),\n$$\n边界条件为\n$$\n\\phi(0)=1, \\qquad \\phi(\\infty)=0,\n$$\n以及物理要求$\\phi(x) \\ge 0$且$\\phi(x)$单调递减。$x=0$处的奇异性源于非线性项的乘子$1/\\sqrt{x}$，但解在$\\phi(0)$有限且$\\phi'(0)$有限的意义下保持有限和光滑。为了进行数值计算，我们将问题截断到有限域$x \\in [0,L]$上，并使用边界条件$\\phi(L)=0$，其中$L>0$的选择需足够大以使得$\\phi(L) \\approx 0$。使用一个包含$N$个区间的均匀网格，网格点为$x_i = i h$（$i=0,1,\\dots,N$），其中$h=L/N$。通过在$x_0=0$和$x_N=L$处强制施加边界值来处理奇异性，并仅在$x_i>0$的内部节点$i=1,2,\\dots,N-1$上对微分方程进行离散化。\n\n仅从二阶导数作为对称差商极限的基本定义以及导数的幂法则出发，推导该问题在均匀网格上的一个二阶精度有限差分离散格式。针对内部未知数$\\{\\phi_i\\}_{i=1}^{N-1}$，结合边界值$\\phi_0=1$和$\\phi_N=0$，构建由此产生的非线性代数方程组。然后，设计并实现一个牛顿迭代法，该方法在每个迭代步中将非线性残差线性化，并求解所得到的三对角线性系统。使用阻尼（线搜索）策略以在迭代过程中保持$\\phi_i \\ge 0$。当内部残差向量的无穷范数低于容差$\\varepsilon$，或达到最大迭代次数时，您的实现必须停止。您可以假设$\\varepsilon = 10^{-10}$，并设置一个足够大的迭代上限以确保收敛。\n\n测试套件：\n- 情况 $A$ (理想情况): $L=20$, $N=400$。\n- 情况 $B$ (更紧的域截断): $L=10$, $N=200$。\n- 情况 $C$ (更粗的网格和更紧的截断): $L=5$, $N=100$。\n\n对每种情况，计算以下两个标量诊断量：\n- 通过单边差分$(\\phi_1-\\phi_0)/h$估算的近似初始斜率$\\phi'(0)$。\n- 通过对$x=1$周围最近的两个网格点上的网格值进行线性插值得到的值$\\phi(1)$ (如果$x=1$恰好是网格点，则直接使用该网格点的值)。\n\n所有量均为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[\\;\\phi'_A(0),\\;\\phi_A(1),\\;\\phi'_B(0),\\;\\phi_B(1),\\;\\phi'_C(0),\\;\\phi_C(1)\\;].\n$$\n不应打印任何额外文本。所有计算必须使用双精度浮点运算进行。", "solution": "所给出的问题是一个源于计算原子物理学的、适定的、有科学依据的边值问题。它要求数值求解托马斯-费米方程，这是一个在原点处具有奇异性的非线性二阶常微分方程。所有的参数和要求都已明确指定，构成了一个完整且一致的陈述。该任务是有效的，我将着手进行求解。\n\n问题的核心是求解非线性边值问题\n$$\n\\phi''(x) \\;=\\; \\frac{\\phi(x)^{3/2}}{\\sqrt{x}}, \\qquad x \\in (0,L]\n$$\n其边界条件为$\\phi(0)=1$和$\\phi(L)=0$。我们需要推导一个二阶精度的有限差分格式，并使用牛顿法求解得到的非线性代数方程组。\n\n首先，我们对域进行离散化。我们引入一个包含$N$个区间的均匀网格，网格间距为$h=L/N$。网格点为$x_i = ih$ ($i=0, 1, \\dots, N$)。我们将这些点上解的数值近似记为$\\phi_i \\approx \\phi(x_i)$。给定的边界条件规定了$\\phi_0 = 1$和$\\phi_N = 0$。未知数是内部网格点上的值$\\{\\phi_i\\}_{i=1}^{N-1}$。\n\n问题要求从二阶导数的基本定义出发进行推导。一阶导数定义为$\\phi'(x) = \\lim_{\\delta \\to 0} \\frac{\\phi(x+\\delta/2) - \\phi(x-\\delta/2)}{\\delta}$。再次应用此定义可得到对称二阶导数：\n$$\n\\phi''(x) = \\lim_{h \\to 0} \\frac{\\phi'(x+h/2) - \\phi'(x-h/2)}{h} = \\lim_{h \\to 0} \\frac{\\left(\\frac{\\phi(x+h)-\\phi(x)}{h}\\right) - \\left(\\frac{\\phi(x)-\\phi(x-h)}{h}\\right)}{h} = \\lim_{h \\to 0} \\frac{\\phi(x+h) - 2\\phi(x) + \\phi(x-h)}{h^2}\n$$\n对于一个小的有限值$h$，这给出了在网格点$x_i$处二阶导数的二阶精度中心差分近似：\n$$\n\\phi''(x_i) \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{h^2}\n$$\n我们在内部网格点$x_i$ ($i=1, 2, \\dots, N-1$)处对微分方程进行离散化，在这些点上$x_i > 0$且方程是良定的。将有限差分近似代入托马斯-费米方程，得到一个包含$N-1$个非线性代数方程的方程组：\n$$\n\\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{h^2} = \\frac{\\phi_i^{3/2}}{\\sqrt{x_i}}, \\qquad i=1, 2, \\dots, N-1\n$$\n为求解该方程组，我们为每个内部节点定义一个残差函数$F_i$，对于一个解，该函数必须为零：\n$$\nF_i(\\phi_1, \\dots, \\phi_{N-1}) = \\phi_{i-1} - 2\\phi_i + \\phi_{i+1} - \\frac{h^2}{\\sqrt{ih}} \\phi_i^{3/2} = 0\n$$\n在这里，$\\phi_0=1$和$\\phi_N=0$是已知常数。我们可以将这些方程组合成一个向量方程$\\vec{F}(\\vec{\\Phi}) = \\vec{0}$，其中$\\vec{\\Phi} = [\\phi_1, \\phi_2, \\dots, \\phi_{N-1}]^T$是$M=N-1$个未知数组成的向量。\n\n这个非线性系统使用牛顿法求解。给定第$k$次迭代的近似解$\\vec{\\Phi}^{(k)}$，通过求解更新量$\\Delta\\vec{\\Phi}^{(k)}$的线性化系统来找到下一个近似解$\\vec{\\Phi}^{(k+1)}$：\n$$\nJ(\\vec{\\Phi}^{(k)}) \\Delta\\vec{\\Phi}^{(k)} = -\\vec{F}(\\vec{\\Phi}^{(k)})\n$$\n然后，解按$\\vec{\\Phi}^{(k+1)} = \\vec{\\Phi}^{(k)} + \\alpha \\Delta\\vec{\\Phi}^{(k)}$进行更新，其中$\\alpha \\in (0,1]$是一个阻尼因子。矩阵$J$是$\\vec{F}$的雅可比矩阵，其元素为$J_{ij} = \\frac{\\partial F_i}{\\partial \\phi_j}$。该系统的结构使得$F_i$仅依赖于$\\phi_{i-1}, \\phi_i, \\phi_{i+1}$，这使得雅可比矩阵是三对角的。非零元素按要求使用导数的幂法则 $(\\frac{d}{du} u^n = n u^{n-1})$ 推导如下：\n次对角线 ($j = i-1$)：\n$$\n\\frac{\\partial F_i}{\\partial \\phi_{i-1}} = 1\n$$\n主对角线 ($j=i$)：\n$$\n\\frac{\\partial F_i}{\\partial \\phi_i} = -2 - \\frac{h^2}{\\sqrt{ih}} \\frac{\\partial}{\\partial \\phi_i}(\\phi_i^{3/2}) = -2 - \\frac{h^2}{\\sqrt{ih}} \\left(\\frac{3}{2} \\phi_i^{1/2}\\right) = -2 - \\frac{3h^{3/2}}{2\\sqrt{i}} \\sqrt{\\phi_i}\n$$\n超对角线 ($j=i+1$)：\n$$\n\\frac{\\partial F_i}{\\partial \\phi_{i+1}} = 1\n$$\n在每个牛顿迭代步中，我们构建这个三对角雅可比矩阵和残差向量，使用高效的三对角求解器求解线性系统以得到$\\Delta\\vec{\\Phi}^{(k)}$，然后找到一个合适的阻尼因子$\\alpha$。物理约束$\\phi(x) \\ge 0$要求更新后的解向量$\\vec{\\Phi}^{(k+1)}$的所有分量保持非负。我们采用一个简单的回溯线搜索：从$\\alpha=1$开始，并相继将其减半，直到满足条件$\\vec{\\Phi}^{(k)} + \\alpha \\Delta\\vec{\\Phi}^{(k)} \\ge \\vec{0}$。\n\n初始猜测值我们使用连接边界条件的线性剖面：$\\phi_i^{(0)} = 1 - x_i/L = 1-i/N$。迭代持续进行，直到残差向量的无穷范数$||\\vec{F}||_\\infty = \\max_{i} |F_i|$小于容差$\\varepsilon=10^{-10}$。\n\n收敛后，我们得到解向量$\\vec{\\Phi}$。由此，我们计算所需的诊断量：\n1. 初始斜率$\\phi'(0)$使用一阶向前差分进行近似，这与可用的网格值一致：$\\phi'(0) \\approx \\frac{\\phi_1 - \\phi_0}{h}$。\n2. 确定$\\phi(1)$的值。对于给定的测试用例，$x=1$与网格点$x_k = kh = 1$重合。该值就是计算出的网格值$\\phi_k$。如果它不是一个网格点，则会使用两个包夹网格点之间的线性插值：$\\phi(1) \\approx \\phi_{i_{\\text{low}}} + (\\phi_{i_{\\text{high}}} - \\phi_{i_{\\text{low}}})(1-x_{i_{\\text{low}}})/h$。\n\n至此，完成了根据问题陈述求解托马斯-费米方程的推导和算法规范。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the Thomas-Fermi equation for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (20.0, 400), # Case A\n        (10.0, 200), # Case B\n        (5.0, 100),  # Case C\n    ]\n\n    results = []\n    \n    # Parameters for the numerical method\n    epsilon = 1e-10\n    max_iter = 100\n\n    for L, N in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        h = L / N\n        M = N - 1 # Number of interior points\n\n        # Grid for interior points\n        x_interior = np.arange(1, N) * h\n        \n        # Initial guess: linear profile from phi(0)=1 to phi(L)=0\n        phi = 1.0 - x_interior / L\n\n        # Newton's method iteration\n        for k in range(max_iter):\n            # Ensure phi is non-negative for the sqrt in the Jacobian\n            phi[phi  0] = 0\n\n            # 1. Compute residual vector F\n            F = np.zeros(M)\n            \n            # Nonlinear term f(phi) = phi^(3/2) / sqrt(x)\n            f_phi = phi**1.5 / np.sqrt(x_interior)\n            \n            # Assemble residual vector F\n            # F[i] = (phi_{i-1} - 2*phi_i + phi_{i+1})/h^2 - f(phi_i)\n            # Rearranged: h^2 * F_i = phi_{i-1} - 2*phi_i + phi_{i+1} - h^2 * f(phi_i)\n            # We solve for the root of this scaled residual.\n            \n            # For i=1 (j=0 in 0-based index)\n            # phi_0 - 2*phi_1 + phi_2 - h^2 * f(phi_1)\n            # phi_0 = 1\n            F[0] = 1.0 - 2.0 * phi[0] + phi[1] - h**2 * f_phi[0]\n            \n            # For i=2,...,N-2 (j=1,...,M-2)\n            # phi_{i-1} - 2*phi_i + phi_{i+1} - h^2 * f(phi_i)\n            F[1:-1] = phi[:-2] - 2.0 * phi[1:-1] + phi[2:] - h**2 * f_phi[1:-1]\n\n            # For i=N-1 (j=M-1)\n            # phi_{N-2} - 2*phi_{N-1} + phi_N - h^2 * f(phi_{N-1})\n            # phi_N = 0\n            F[-1] = phi[-2] - 2.0 * phi[-1] - h**2 * f_phi[-1]\n            \n            # 2. Check for convergence\n            residual_norm = np.linalg.norm(F, np.inf)\n            if residual_norm  epsilon:\n                break\n\n            # 3. Compute Jacobian matrix J in banded format\n            # J_ii = -2 - (3/2) * h^2 * phi_i^(1/2) / sqrt(x_i)\n            diag_prime = -1.5 * h**1.5 * np.sqrt(phi) / np.sqrt(np.arange(1, N))\n            \n            ab = np.zeros((3, M))\n            ab[0, 1:] = 1.0   # Super-diagonal\n            ab[1, :] = -2.0 + diag_prime # Main diagonal\n            ab[2, :-1] = 1.0  # Sub-diagonal\n            \n            # 4. Solve the linear system J * delta_phi = -F\n            delta_phi = solve_banded((1, 1), ab, -F)\n            \n            # 5. Damping (line search) to ensure phi >= 0\n            alpha = 1.0\n            for _ in range(10): # Max 10 halvings of alpha\n                phi_next = phi + alpha * delta_phi\n                if np.all(phi_next >= 0):\n                    break\n                alpha /= 2.0\n            else:\n                # This should not happen with a good initial guess\n                # If it does, the iteration has failed.\n                # For this problem, we can assume it converges.\n                pass\n            \n            phi = phi_next\n\n        # After convergence, calculate diagnostic quantities\n        # phi_0 = 1.0, phi_1 = phi[0]\n        slope_at_0 = (phi[0] - 1.0) / h\n\n        # Calculate phi(1.0)\n        idx_float = 1.0 / h\n        if np.isclose(idx_float, np.round(idx_float)):\n            idx = int(np.round(idx_float))\n            # Grid point x_idx = 1.0. The value is phi_idx.\n            # phi is vector of phi_1, ..., phi_{N-1}\n            # so phi_idx corresponds to phi[idx-1]\n            if idx == 0:\n                 phi_at_1 = 1.0\n            else:\n                 phi_at_1 = phi[idx - 1]\n        else:\n            # Linear interpolation\n            i_low = int(np.floor(idx_float))\n            # x_low = i_low * h\n            \n            if i_low == 0:\n                phi_low = 1.0\n            else:\n                phi_low = phi[i_low-1]\n            \n            i_high = i_low + 1\n            phi_high = phi[i_high-1]\n            \n            # phi_at_1 = phi_low + (phi_high - phi_low) * (1.0 - x_low)/h\n            phi_at_1 = phi_low + (phi_high - phi_low) * (1.0 - i_low * h) / h\n\n        results.extend([slope_at_0, phi_at_1])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392752"}]}