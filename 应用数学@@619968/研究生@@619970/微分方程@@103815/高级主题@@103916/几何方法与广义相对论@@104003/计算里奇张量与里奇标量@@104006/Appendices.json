{"hands_on_practices": [{"introduction": "我们从一个直观的例子开始动手实践，计算一个嵌入在三维欧几里得空间中的二维曲面的里奇标量。这个练习将帮助你熟悉从度规张量出发，通过克氏符号，最终得到曲率的基本流程。通过分析双曲抛物面这样一个具体的形状 [@problem_id:1076518]，你不仅能练习核心的计算技巧，还能发现二维情况下里奇标量 $R$ 与高斯曲率 $K$ 之间的深刻联系，即 $R = 2K$。", "problem": "双曲抛物面是一个双规曲面，由方程 $z = xy$ 定义。在本问题中，我们考虑嵌入在三维欧几里得空间 $\\mathbb{R}^3$ 中的这个曲面，其几何由标准欧几里得线元 $ds^2 = dx^2 + dy^2 + dz^2$ 描述。该曲面从环境空间继承了一个度规，称为诱导度规。\n\n使用坐标为 $(u^1, u^2) = (x, y)$ 的自然参数化，曲面上的一点可以由向量 $\\mathbf{r}(x, y) = (x, y, xy)$ 描述。\n\n您的任务是计算此双曲抛物面曲面的里奇标量 $R$，作为坐标 $x$ 和 $y$ 的函数。\n\n此推导所需的黎曼几何标准公式如下：\n- 诱导度规张量：$g_{ij} = \\frac{\\partial \\mathbf{r}}{\\partial u^i} \\cdot \\frac{\\partial \\mathbf{r}}{\\partial u^j}$\n- 第二类克里斯托费尔符号：$\\Gamma^k_{ij} = \\frac{1}{2} g^{kl} (\\partial_i g_{jl} + \\partial_j g_{il} - \\partial_l g_{ij})$，其中 $\\partial_i = \\frac{\\partial}{\\partial u^i}$ 且 $g^{kl}$ 是度规张量的逆。\n- 里奇张量：$R_{ik} = \\partial_j \\Gamma^j_{ik} - \\partial_k \\Gamma^j_{ij} + \\Gamma^p_{ik}\\Gamma^j_{pj} - \\Gamma^p_{ij}\\Gamma^j_{pk}$\n- 里奇标量：$R = g^{ik} R_{ik}$\n\n推导里奇标量 $R(x, y)$ 的表达式。", "solution": "我们用 $(u^1,u^2)=(x,y)$ 和 $\\mathbf r(x,y)=(x,y,xy)$ 来参数化该曲面。\n\n1. 计算诱导度规\n$$\\frac{\\partial \\mathbf r}{\\partial x}=(1,0,y),\\quad \\frac{\\partial \\mathbf r}{\\partial y}=(0,1,x),$$\n因此\n$$g_{11}=1+y^2,\\quad g_{12}=g_{21}=xy,\\quad g_{22}=1+x^2.$$\n行列式为\n$$\\det g=(1+y^2)(1+x^2)-x^2y^2=1+x^2+y^2.$$\n\n2. 我们不直接计算克里斯托费尔符号，而是利用以下事实：对于曲面 $z=f(x,y)$，其高斯曲率为\n$$K=\\frac{f_{xx}f_{yy}-f_{xy}^2}{(1+f_x^2+f_y^2)^2}.$$\n这里 $f(x,y)=xy$，所以\n$$f_x=y,\\quad f_y=x,\\quad f_{xx}=0,\\quad f_{yy}=0,\\quad f_{xy}=1.$$\n因此\n$$K=\\frac{0\\cdot0-1^2}{(1+y^2+x^2)^2}=-\\frac{1}{(1+x^2+y^2)^2}.$$\n\n3. 在二维情况下，里奇标量为 $R=2K$，可得\n$$R=-\\frac{2}{(1+x^2+y^2)^2}.$$", "answer": "$$\\boxed{-\\frac{2}{(1+x^2+y^2)^2}\\,}$$", "id": "1076518"}, {"introduction": "在掌握了二维曲面的计算后，我们将挑战一个更复杂的情形：一个三维空间中的非对角度规。现实世界和理论物理中遇到的许多度规都不是简单的对角形式，处理它们的能力至关重要。这个练习 [@problem_id:1076389] 要求你计算一个具有非对角分量的度规张量 $g_{\\mu\\nu}$ 的里奇张量分量 $R_{xx}$，这将着重锻炼你处理复杂的张量运算，特别是求逆度规和管理众多非零的克氏符号的能力。", "problem": "在微分几何和广义相对论的背景下，流形的曲率由黎曼曲率张量及其缩并（里奇张量和里奇标量）来描述。本问题涉及为一个特定的三维黎曼流形计算里奇张量的一个分量。\n\n考虑流形 $\\mathbb{R}^3$，其坐标为 $(x, y, z)$。该空间的几何由黎曼度规定义，其线元为：\n$$\nds^2 = dx^2 + dy^2 + (x dy + y dz)^2\n$$\n你的任务是计算该度规的里奇张量的分量 $R_{xx}$。\n\n**背景公式：**\n\n设坐标记为 $x^\\mu$，其中 $(x^1, x^2, x^3) = (x, y, z)$。度规张量为 $g_{\\mu\\nu}$。\n\n1.  第二类克里斯托费尔符号由下式给出：\n    $$\n    \\Gamma^\\rho_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\frac{\\partial g_{\\nu\\sigma}}{\\partial x^\\mu} + \\frac{\\partial g_{\\mu\\sigma}}{\\partial x^\\nu} - \\frac{\\partial g_{\\mu\\nu}}{\\partial x^\\sigma} \\right)\n    $$\n    其中 $g^{\\rho\\sigma}$ 是度规张量 $g_{\\rho\\sigma}$ 的逆。\n\n2.  里奇张量 $R_{\\mu\\nu}$ 由克里斯托费尔符号定义如下：\n    $$\n    R_{\\mu\\nu} = \\frac{\\partial \\Gamma^\\rho_{\\mu\\nu}}{\\partial x^\\rho} - \\frac{\\partial \\Gamma^\\rho_{\\mu\\rho}}{\\partial x^\\nu} + \\Gamma^\\rho_{\\rho\\sigma} \\Gamma^\\sigma_{\\mu\\nu} - \\Gamma^\\rho_{\\nu\\sigma} \\Gamma^\\sigma_{\\mu\\rho}\n    $$\n\n**问题：**\n使用所提供的公式，推导给定度规的里奇张量分量 $R_{xx} \\equiv R_{11}$ 的解析表达式。", "solution": "我们记 $(x^1,x^2,x^3)=(x,y,z)$，并计算度规及其逆。从\n$$ds^2=dx^2+(1+x^2)\\,dy^2+2xy\\,dy\\,dz+y^2\\,dz^2$$\n我们可以读出\n$$g_{11}=1,\\quad g_{22}=1+x^2,\\quad g_{23}=g_{32}=xy,\\quad g_{33}=y^2.$$\n$(y,z)$ 空间中的 $2\\times2$ 子矩阵的行列式为 $y^2$，所以\n$$g^{11}=1,\\;\ng^{22}=1,\\;g^{23}=-\\frac{x}{y},\\;g^{33}=\\frac{1+x^2}{y^2}.$$\n所有其他的 $g^{\\mu\\nu}=0$。\n\n1.  具有两个“1”指标的克里斯托费尔符号为零：\n    $$\\Gamma^\\rho_{11}=0.$$\n2.  迹 $\\Gamma^\\rho_{1\\rho}=\\Gamma^2_{12}+\\Gamma^3_{13}$。我们得到\n    $$\\Gamma^2_{12}=\\frac{x}{2},\\qquad\\Gamma^3_{13}=-\\frac{x}{2},\\quad\n      \\Longrightarrow\\ \\Gamma^\\rho_{1\\rho}=0.$$\n3.  因此，在\n    $$R_{11}\n      =\\partial_\\rho\\Gamma^\\rho_{11}-\\partial_1\\Gamma^\\rho_{1\\rho}\n       +\\Gamma^\\rho_{\\rho\\sigma}\\Gamma^\\sigma_{11}\n       -\\Gamma^\\rho_{1\\sigma}\\Gamma^\\sigma_{1\\rho}$$\n    中的前两项为零，并且 $\\Gamma^\\sigma_{11}=0$，所以\n    $$R_{11}=-\\Gamma^\\rho_{1\\sigma}\\,\\Gamma^\\sigma_{1\\rho}.$$\n4.  唯一不为零的 $\\Gamma^\\rho_{1\\sigma}$ 是\n    $$\\Gamma^2_{12}=\\frac{x}{2},\\quad \\Gamma^2_{13}=\\frac{y}{2},\\quad\n      \\Gamma^3_{12}=\\frac{1-x^2}{2y},\\quad \\Gamma^3_{13}=-\\frac{x}{2}.$$\n   对 $\\rho,\\sigma$ 求和得到\n    $$\\sum_{\\rho,\\sigma}\\Gamma^\\rho_{1\\sigma}\\Gamma^\\sigma_{1\\rho}\n      =\\Big(\\frac{x}{2}\\Big)^2+\\Big(\\frac{x}{2}\\Big)^2\n       +2\\Big(\\frac{y}{2}\\cdot\\frac{1-x^2}{2y}\\Big)\n      =\\frac12.$$\n   因此\n    $$R_{11}=-\\frac12.$$", "answer": "$$\\boxed{-\\frac12}$$", "id": "1076389"}, {"introduction": "最后的练习将理论与现代计算科学连接起来。在处理广义相对论或工程学中极其复杂的度规时，纯粹的解析计算往往变得不切实际，必须依赖于计算方法。这个练习 [@problem_id:2442518] 引导你将里奇张量的抽象定义 $R_{ij} = R^k_{ikj}$ 转化为具体的计算机代码，通过实现张量缩并的算法来验证恒定曲率空间中的一个著名公式。这不仅是对理论知识的检验，更是对将抽象数学概念应用于实际问题解决能力的宝贵训练。", "problem": "在计算工程中，爱因斯坦求和约定提供了一种与坐标无关的方式，通过指数表示法来表达张量运算。给定一度规张量 $g_{ij}$，其逆 $g^{ij}$ 满足 $g^{ik} g_{kj} = \\delta^{i}{}_{j}$，其中 $\\delta^{i}{}_{j}$ 是克罗内克δ符号。指标的升降分别通过与 $g^{ij}$ 和 $g_{ij}$ 进行缩并来执行。一个逆变指标和一个协变指标对的缩并会将张量的阶数降低 $2$，这是从黎曼曲率张量获得里奇张量的基本运算。\n\n你的任务是编写一个完整的程序，该程序针对一小组测试用例，为一个常截面曲率 $K$ 的空间构建一个全协变黎曼曲率张量 $R_{l i k j}$，然后通过以下步骤计算里奇张量 $R_{i j}$：\n- 首先，用逆度规 $g^{a l}$ 提升 $R_{l i k j}$ 的第一个协变指标，形成混合指标张量 $R^{a}{}_{i k j}$，由 $R^{a}{}_{i k j} = g^{a l} R_{l i k j}$ 给出，然后\n- 接着，将提升后的第一个指标与第三个协变指标进行缩并，得到2阶张量 $R_{i j}$。\n\n你必须使用以下经过充分检验的公式，用于计算在某一点的常曲率空间的全协变黎曼张量：\n$$\nR_{l i k j} = K \\left( g_{l k} g_{i j} - g_{l j} g_{i k} \\right).\n$$\n仅使用上述基本规则，实现升标和缩并步骤，从 $R_{l i k j}$ 计算 $R_{i j}$。\n\n对于每个测试用例，将你计算出的 $R_{i j}$ 与常曲率空间的解析表达式\n$$\nR_{i j}^{(\\text{expected})} = (n - 1) K \\, g_{i j}\n$$\n进行比较，其中 $n$ 是空间的维度。报告你计算的 $R_{i j}$ 和 $R_{i j}^{(\\text{expected})}$ 之间的最大绝对差是否小于或等于容差 $\\tau = 10^{-12}$。每个测试用例产生一个布尔结果。你的程序必须将所有布尔结果聚合到单行输出中，格式为方括号内以逗号分隔的列表，例如 [True, False]，但需使用确切的 Python 布尔字面量。\n\n测试套件规范：\n- 测试用例 1 (常规正常路径)：\n  - 维度 $n = 2$。\n  - 度规 $g_{ij} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$。\n  - 曲率 $K = \\dfrac{3}{7}$。\n  - 期望值 $R_{i j}^{(\\text{expected})} = (2 - 1) \\cdot \\dfrac{3}{7} \\, g_{i j} = \\dfrac{3}{7} \\, g_{i j}$。\n- 测试用例 2 (非平凡度规，常曲率)：\n  - 维度 $n = 3$。\n  - 度规 $g_{ij} = \\mathrm{diag}(2, 1.5, 0.7) = \\begin{bmatrix} 2  0  0 \\\\ 0  1.5  0 \\\\ 0  0  0.7 \\end{bmatrix}$。\n  - 曲率 $K = \\dfrac{1}{3}$。\n  - 期望值 $R_{i j}^{(\\text{expected})} = (3 - 1) \\cdot \\dfrac{1}{3} \\, g_{i j} = \\dfrac{2}{3} \\, g_{i j}$。\n- 测试用例 3 (平直空间边界情况)：\n  - 维度 $n = 2$。\n  - 度规 $g_{ij} = \\mathrm{diag}(1.7, 0.9) = \\begin{bmatrix} 1.7  0 \\\\ 0  0.9 \\end{bmatrix}$。\n  - 曲率 $K = 0$。\n  - 期望值 $R_{i j}^{(\\text{expected})} = (2 - 1) \\cdot 0 \\cdot g_{i j} = 0 \\cdot g_{i j} = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix}$。\n- 测试用例 4 (边界维度 $n=1$)：\n  - 维度 $n = 1$。\n  - 度规 $g_{ij} = \\begin{bmatrix} 4.2 \\end{bmatrix}$。\n  - 曲率 $K = 0.8$。\n  - 期望值 $R_{i j}^{(\\text{expected})} = (1 - 1) \\cdot 0.8 \\cdot g_{i j} = 0 \\cdot g_{i j} = \\begin{bmatrix} 0 \\end{bmatrix}$。\n\n实现要求：\n- 对于每个测试用例，使用提供的 $g_{i j}$ 和 $K$，通过上述常曲率公式构建 $R_{l i k j}$。\n- 计算 $g^{i j}$ 作为 $g_{i j}$ 的逆。\n- 形成 $R^{a}{}_{i k j} = g^{a l} R_{l i k j}$，然后将提升的指标与第三个指标进行缩并以产生 $R_{i j}$。\n- 对于每种情况，计算 $R_{i j}$ 和 $R_{i j}^{(\\text{expected})}$ 之间逐元素的最大绝对差，并返回一个布尔值，指示该差值是否小于或等于 $\\tau = 10^{-12}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 [True, False, True, True]。", "solution": "所提出的问题是计算张量代数中一个明确定义的练习，其基础是微分几何的原理。它在科学上是合理的，自成体系的，并且在算法上是可处理的。因此，我将提供一个完整的解决方案。\n\n任务是从常截面曲率 $K$ 空间的全协变黎曼曲率张量 $R_{likj}$ 计算里奇张量 $R_{ij}$，并根据已知的解析公式验证此计算。我们已知空间的维度 $n$、度规张量 $g_{ij}$ 和曲率 $K$。\n\n过程如下：\n$1$. 构建4阶黎曼张量 $R_{likj}$。\n$2$. 计算逆度规张量 $g^{ij}$。\n$3$. 提升黎曼张量的第一个指标，得到混合指标张量 $R^{a}{}_{ikj}$。\n$4$. 缩并 $R^{a}{}_{ikj}$ 的第一个和第三个指标，得到2阶里奇张量 $R_{ij}$。\n$5$. 将计算出的 $R_{ij}$ 与预期的解析结果 $R_{i j}^{(\\text{expected})} = (n-1) K g_{ij}$ 进行比较。\n\n让我们详细说明计算的每一步。我们将张量表示为多维数组，爱因斯坦求和约定将通过张量缩并来实现，对此，`numpy.einsum` 函数非常适用，因为它提供了从指数表示法到计算的直接映射。\n\n**步骤 1：构建黎曼曲率张量 $R_{l i k j}$**\n问题提供了常曲率 $K$ 空间中黎曼张量的公式：\n$$\nR_{l i k j} = K \\left( g_{l k} g_{i j} - g_{l j} g_{i k} \\right)\n$$\n在这里，$R_{likj}$ 是一个4阶张量，我们将其表示为一个4维数组。指标 $l, i, k, j$ 的取值范围都是 $0$ 到 $n-1$。项 $g_{lk}g_{ij}$ 是两个度规张量的外积，可以通过计算构建。$g_{lj}g_{ik}$ 也是如此。在指数表示法中，这是一个直接的组合。使用 `einsum`，我们可以将这两项表示为：\n- $g_{lk} g_{ij} \\rightarrow \\text{`np.einsum('lk,ij-likj', g, g)`}$\n- $g_{lj} g_{ik} \\rightarrow \\text{`np.einsum('lj,ik-likj', g, g)`}$\n然后根据公式组合所得到的4维数组，即可得出 $R_{likj}$。\n\n**步骤 2：计算逆度规张量 $g^{ij}$**\n逆度规张量 $g^{ij}$ 由关系式 $g^{ik} g_{kj} = \\delta^{i}{}_{j}$ 定义，其中 $\\delta^{i}{}_{j}$ 是克罗内克δ符号。这意味着表示 $g^{ij}$ 的矩阵是表示 $g_{ij}$ 的矩阵的代数逆。这是一个标准的线性代数运算。\n$$\n[g^{ij}] = ([g_{ij}])^{-1}\n$$\n\n**步骤 3：提升黎曼张量的第一个指标**\n我们要通过使用逆度规来提升 $R_{likj}$ 的第一个指标，从而计算混合张量 $R^{a}{}_{ikj}$。这是对 $R_{likj}$ 第一个指标的缩并：\n$$\nR^{a}{}_{i k j} = g^{a l} R_{l i k j}\n$$\n在爱因斯坦表示法中，重复的指标 $l$（一个逆变，一个协变）意味着求和。此操作将 $g^{al}$ 的第二个指标与 $R_{likj}$ 的第一个指标进行缩并。得到的张量具有指标 $(a, i, k, j)$。使用 `einsum`，此转换表示为：\n- $g^{al} R_{likj} \\rightarrow \\text{`np.einsum('al,likj-aikj', g_inv, R)`}$\n其中 `g_inv` 是表示 $g^{ij}$ 的数组，`R` 是表示 $R_{likj}$ 的数组。\n\n**步骤 4：通过缩并计算里奇张量 $R_{ij}$**\n里奇张量 $R_{ij}$ 是通过缩并混合黎曼张量 $R^{a}{}_{ikj}$ 的第一个（逆变）和第三个（协变）指标得到的。\n$$\nR_{i j} = R^{k}{}_{i k j}\n$$\n这涉及到对指标 $k$ 进行求和，它同时出现在逆变（第一）和协变（第三）位置上。这将张量的阶数从 $4$ 降到 $2$，留下自由指标 $i$ 和 $j$。此缩并的 `einsum` 表达式为：\n- $R^{k}{}_{ikj} \\rightarrow \\text{`np.einsum('kikj-ij', R_mixed)`}$\n其中 `R_mixed` 是表示 $R^{a}{}_{ikj}$ 的数组。\n\n**步骤 5：验证**\n最后，我们根据以下公式计算常曲率空间的期望里奇张量：\n$$\nR_{i j}^{(\\text{expected})} = (n - 1) K \\, g_{i j}\n$$\n这是一个对度规张量 $g_{ij}$ 的简单标量乘法。\n然后我们计算计算出的里奇张量和期望的里奇张量条目之间的最大绝对差：\n$$\n\\Delta = \\max_{i,j} | R_{ij} - R_{i j}^{(\\text{expected})} |\n$$\n每个测试用例的结果是一个布尔值，如果 $\\Delta \\le \\tau$（其中容差 $\\tau$ 给定为 $10^{-12}$），则为 `True`，否则为 `False`。\n\n这一系列步骤提供了一种稳健且可验证的方法来计算里奇张量并根据理论验证结果。`einsum` 的使用确保了实现忠实于张量指数表示法的数学形式。对于 $n=1$ 的特殊情况，黎曼张量 $R_{likj}$ 恒为零，因为 $R_{1111} = K(g_{11}g_{11} - g_{11}g_{11}) = 0$。因此，计算出的里奇张量 $R_{11}$ 也将为 $0$，这与期望结果 $R_{11}^{(\\text{expected})} = (1-1)Kg_{11} = 0$ 相匹配。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational engineering problem of calculating and verifying the Ricci tensor.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: n=2, Euclidean metric\n        {\n            \"n\": 2,\n            \"g\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"K\": 3.0 / 7.0,\n        },\n        # Test case 2: n=3, diagonal metric\n        {\n            \"n\": 3,\n            \"g\": np.array([[2.0, 0.0, 0.0], [0.0, 1.5, 0.0], [0.0, 0.0, 0.7]]),\n            \"K\": 1.0 / 3.0,\n        },\n        # Test case 3: n=2, flat space\n        {\n            \"n\": 2,\n            \"g\": np.array([[1.7, 0.0], [0.0, 0.9]]),\n            \"K\": 0.0,\n        },\n        # Test case 4: n=1, boundary dimension\n        {\n            \"n\": 1,\n            \"g\": np.array([[4.2]]),\n            \"K\": 0.8,\n        },\n    ]\n\n    tolerance = 1e-12\n    results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        g = case[\"g\"]\n        K = case[\"K\"]\n\n        # Step 1: Construct the fully covariant Riemann tensor R_likj.\n        # R_likj = K * (g_lk * g_ij - g_lj * g_ik)\n        # The 'einsum' function directly translates index notation to computation.\n        term1 = np.einsum('lk,ij-likj', g, g)\n        term2 = np.einsum('lj,ik-likj', g, g)\n        R_likj = K * (term1 - term2)\n\n        # Step 2: Compute the inverse metric g^ij.\n        # This is the matrix inverse of g_ij.\n        g_inv = np.linalg.inv(g)\n\n        # Step 3: Raise the first index to form the mixed tensor R^a_ikj.\n        # R^a_ikj = g^al * R_likj\n        # This is a contraction over the index 'l'.\n        R_a_ikj = np.einsum('al,likj-aikj', g_inv, R_likj)\n\n        # Step 4: Contract to find the Ricci tensor R_ij.\n        # R_ij = R^k_ikj\n        # This contracts the first ('a', here renamed to 'k') and third ('k') indices.\n        Ricci_computed = np.einsum('kikj-ij', R_a_ikj)\n\n        # Step 5: Compute the expected Ricci tensor for comparison.\n        # R_ij^(expected) = (n - 1) * K * g_ij\n        Ricci_expected = (n - 1) * K * g\n\n        # Step 6: Compare the computed and expected tensors.\n        # Calculate the maximum absolute difference between the two tensors.\n        max_abs_diff = np.max(np.abs(Ricci_computed - Ricci_expected))\n\n        # Check if the difference is within the specified tolerance.\n        is_verified = max_abs_diff = tolerance\n        results.append(is_verified)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442518"}]}