{"hands_on_practices": [{"introduction": "本节的动手实践旨在将理论付诸实践。第一个练习 [@problem_id:958179] 演示了如何通过利用矩阵的结构来简化计算，你将学习如何通过分别处理每个子块来计算一个块对角矩阵的指数。这是一个理想的入门练习，展示了一种基本的“分而治之”策略，并处理了经典的 $2 \\times 2$ 旋转类矩阵块。", "id": "958179", "problem": "考虑一个分块对角矩阵 $A$，定义如下：\n$$\nA = \\begin{bmatrix}\n0 & -2 & 0 \\\\\n2 & 0 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n该矩阵包含两个可对角化的块：一个 $2 \\times 2$ 的块 $\\begin{bmatrix} 0 & -2 \\\\ 2 & 0 \\end{bmatrix}$ 和一个 $1 \\times 1$ 的块 $\\begin{bmatrix} 1 \\end{bmatrix}$。计算矩阵指数 $e^A$。将结果表示为具有精确符号项的单个 $3 \\times 3$ 矩阵，使用标准数学函数和常数。最终答案必须完全化简。", "solution": "1. 分解\n$$\nA=\\begin{pmatrix}0&-2&0\\\\2&0&0\\\\0&0&1\\end{pmatrix}\n=\\begin{pmatrix}A_2&0\\\\0&1\\end{pmatrix},\\quad\nA_2=\\begin{pmatrix}0&-2\\\\2&0\\end{pmatrix}.\n$$\n2. 注意到 $A_2^2=\\begin{pmatrix}-4&0\\\\0&-4\\end{pmatrix}=-4I_2$。因此 $\\exp(A_2)$ 的级数分裂为偶数项和奇数项：\n$$\n\\exp(A_2)=\\sum_{k=0}^\\infty\\frac{A_2^{2k}}{(2k)!}\n+\\sum_{k=0}^\\infty\\frac{A_2^{2k+1}}{(2k+1)!}\n=I_2\\sum_{k=0}^\\infty\\frac{(-4)^k}{(2k)!}\n+A_2\\sum_{k=0}^\\infty\\frac{(-4)^k}{(2k+1)!}.\n$$\n3. 识别级数\n$$\n\\sum_{k=0}^\\infty\\frac{(-4)^k}{(2k)!}=\\cos(2), \n\\qquad\n\\sum_{k=0}^\\infty\\frac{(-4)^k}{(2k+1)!}=\\frac{\\sin(2)}{2}.\n$$\n因此\n$$\n\\exp(A_2)=\\cos(2)\\,I_2+\\frac{\\sin(2)}{2}\\,A_2\n=\\begin{pmatrix}\\cos2&-\\sin2\\\\\\sin2&\\cos2\\end{pmatrix}.\n$$\n4. 对于 $1\\times1$ 的块，$\\exp(1)=e$。根据分块对角性，\n$$\n\\exp(A)=\\begin{pmatrix}\\exp(A_2)&0\\\\0&\\exp(1)\\end{pmatrix}\n=\\begin{pmatrix}\\cos2&-\\sin2&0\\\\\\sin2&\\cos2&0\\\\0&0&e\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\cos(2)&-\\sin(2)&0\\\\\\sin(2)&\\cos(2)&0\\\\0&0&e\\end{pmatrix}}$$"}, {"introduction": "这个练习 [@problem_id:958287] 提升了问题的复杂度，引入了一个受物理启发的耦合系统。你的任务是计算一个大型 $6 \\times 6$ 块矩阵的指数中的一个元素，而解题的关键在于识别和利用其潜在的对称性。这个问题旨在训练你发现隐藏结构，从而使看似棘手的问题变得易于解决的能力。", "id": "958287", "problem": "考虑一个由两条相同的一维链组成的物理系统，每条链有 $N=3$ 个格点。每条链内部的动力学由哈密顿矩阵 $L$ 描述。这两条链相互耦合。这个包含 $2N=6$ 个格点的总系统的哈密顿量由一个 $6 \\times 6$ 的分块矩阵 $M$ 给出。\n\n链内哈密顿量 $L$ 是一个 $3 \\times 3$ 的矩阵，定义如下：\n$$\nL = \\begin{pmatrix} -2 & 1 & 0 \\\\ 1 & -2 & 1 \\\\ 0 & 1 & -2 \\end{pmatrix}\n$$\n这个矩阵对应于一个具有最近邻跃迁的紧束缚模型，或者等效地，是在带狄利克雷边界条件的 3 点网格上二阶导数算符的有限差分表示。\n\n耦合系统的总哈密顿量由 $6 \\times 6$ 的矩阵 $M$ 给出：\n$$\nM = \\begin{pmatrix} L & cI \\\\ cI & L \\end{pmatrix}\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵，$c$ 是一个实常数，表示两条链上对应格点之间的均匀耦合强度。\n\n量子态的时间演化由哈密顿量的矩阵指数决定。在更一般的背景下，矩阵指数出现在线性微分方程组的解中。你的任务是计算矩阵指数 $e^{\\alpha M}$ 的一个特定元素，其中 $\\alpha$ 是一个实参数。\n\n计算矩阵 $e^{\\alpha M}$ 的第 $(1,1)$ 个元素。", "solution": "1. 将 $6\\times6$ 的哈密顿量分解为对称和反对称子空间。定义投影算符\n$$\nP_{\\pm}=\\frac12\\Bigl(I_{2}\\otimes I_{3}\\pm\\sigma_{x}\\otimes I_{3}\\Bigr),\n$$\n使得\n$$\nM=P_{+}(L+cI_{3})+P_{-}(L-cI_{3}),\\quad\ne^{\\alpha M}=P_{+}e^{\\alpha(L+cI_{3})}+P_{-}e^{\\alpha(L-cI_{3})}.\n$$\n因此，对于第一条链上的格点 1，\n$$\n\\bigl[e^{\\alpha M}\\bigr]_{11}\n=\\langle1|e^{\\alpha M}|1\\rangle\n=\\tfrac12\\bigl[e^{\\alpha(L+cI)}_{11}+e^{\\alpha(L-cI)}_{11}\\bigr]\n=\\cosh(\\alpha c)\\,e^{\\alpha L}_{11}.\n$$\n\n2. 通过对角化 $3\\times3$ 的三对角矩阵来计算 $e^{\\alpha L}_{11}$\n$$\nL=\\begin{pmatrix}-2&1&0\\\\1&-2&1\\\\0&1&-2\\end{pmatrix}.\n$$\n其特征值为\n$\\mu_{j}=-2+2\\cos\\frac{j\\pi}{4}$，$j=1,2,3$，对应的归一化特征向量具有\n$$\nv_{j}(1)=\\frac{\\sin\\bigl(j\\pi/4\\bigr)}{\\sqrt{\\sum_{i=1}^{3}\\sin^{2}(i j\\pi/4)}}.\n$$\n可以得到\n$$\ne^{\\alpha L}_{11}\n=\\sum_{j=1}^{3}e^{\\alpha\\mu_{j}}\\bigl[v_{j}(1)\\bigr]^{2}\n=\\frac14e^{\\alpha(-2+\\sqrt2)}+\\frac12e^{-2\\alpha}+\\frac14e^{\\alpha(-2-\\sqrt2)}\n=\\frac{e^{-2\\alpha}}{2}\\bigl(1+\\cosh(\\alpha\\sqrt2)\\bigr).\n$$\n\n3. 综合结果，\n$$\n\\bigl[e^{\\alpha M}\\bigr]_{11}\n=\\cosh(\\alpha c)\\;\\frac{e^{-2\\alpha}}{2}\\bigl(1+\\cosh(\\alpha\\sqrt2)\\bigr).\n$$", "answer": "$$\\boxed{\\frac{e^{-2\\alpha}\\,\\cosh(\\alpha c)\\,\\bigl(1+\\cosh(\\alpha\\sqrt{2})\\bigr)}{2}}$$"}, {"introduction": "最后的这个计算练习 [@problem_id:2439853] 填补了抽象理论与实际应用之间的鸿沟。你将探索计算矩阵指数的常用方法（如对角化和泰勒级数）在数值计算中可能遇到的陷阱。通过在精心选择的案例（包括近始奇异矩阵和刚性系统）上测试这些方法，你将对数值稳定性这一关键概念获得深刻的理解。", "id": "2439853", "problem": "考虑线性时不变常微分方程 (ODE) $\\,\\dot{v}(t) = M\\,v(t)\\,$，其初始条件为 $\\,v(0)\\,$，其中 $\\,M\\,$ 是一个常实数 $\\,2\\times 2\\,$ 矩阵，且 $\\,v(t)\\in\\mathbb{R}^2\\,$。其精确解为 $\\,v(t) = \\exp(M t)\\,v(0)\\,$，其中 $\\,\\exp(\\cdot)\\,$ 表示矩阵指数。您的任务是，在几个指定的情况下，量化并比较两种用于计算 $\\,v(t)\\,$ 的不同近似策略所产生的数值误差：\n\n- 方法 D（对角化）：当 $\\,M\\,$ 可对角化时，设 $\\,M = V \\Lambda V^{-1}\\,$，其中 $\\,\\Lambda\\,$ 为对角矩阵。定义近似解 $\\,\\tilde{v}_D(t) := V\\,\\exp(\\Lambda t)\\,V^{-1}\\,v(0)\\,$，在浮点数运算中计算。如果因奇异性而无法生成 $\\,V^{-1}\\,$，您必须将方法D的误差报告为“非数值”（not-a-number），并将特征向量矩阵的条件数报告为 $+\\infty$。\n- 方法 T（截断泰勒级数）：使用矩阵指数的 $\\,N\\,$ 阶截断泰勒级数，定义 $\\,\\tilde{v}_T(t) := \\sum_{k=0}^{N} \\frac{(M t)^k}{k!}\\,v(0)\\,$，在浮点数运算中计算，其中 $\\,N = 20\\,$。\n\n对于每个测试用例，使用数值上可靠的矩阵指数计算方法，计算一个高精度参考解 $\\,v_{\\mathrm{ref}}(t) := \\exp(M t)\\,v(0)\\,$。对于每种方法 $\\,X \\in \\{D,T\\}\\,$，计算相对 $\\,2$-范数误差 $\\,\\varepsilon_X := \\frac{\\lVert \\tilde{v}_X(t) - v_{\\mathrm{ref}}(t)\\rVert_2}{\\lVert v_{\\mathrm{ref}}(t)\\rVert_2}\\,$。对于方法D，还需计算特征向量矩阵 $\\,V\\,$ 的 $\\,2$-范数条件数 $\\,\\kappa(V)\\,$。如果 $\\,M\\,$ 在浮点数运算中因无法生成 $\\,V^{-1}\\,$ 而不可对角化，则报告 $\\,\\varepsilon_D = \\mathrm{NaN}\\,$ 和 $\\,\\kappa(V) = +\\infty\\,$。\n\n使用以下参数值的测试套件，该套件涵盖了不同的数值体系。在每个用例中，$\\,M\\in\\mathbb{R}^{2\\times 2}\\,$, $\\,t\\in\\mathbb{R}\\,$, 且 $\\,v(0)\\in\\mathbb{R}^2\\,$：\n\n- 用例 $\\,1\\,$（对称，良态特征基，中等时间）：\n  $$M_1=\\begin{pmatrix}-1 & 0.2\\\\ 0.2 & -2\\end{pmatrix},\\quad t_1 = 1,\\quad v_1(0)=\\begin{pmatrix}1\\\\ 0\\end{pmatrix}.$$\n- 用例 $\\,2\\,$（非正规，近乎亏损，特征值接近）：\n  $$M_2=\\begin{pmatrix}-1 & 1\\\\ 0 & -1+10^{-6}\\end{pmatrix},\\quad t_2 = 1,\\quad v_2(0)=\\begin{pmatrix}1\\\\ 1\\end{pmatrix}.$$\n- 用例 $\\,3\\,$（亏损若尔当块，在精确算术中对角化失败）：\n  $$M_3=\\begin{pmatrix}-1 & 1\\\\ 0 & -1\\end{pmatrix},\\quad t_3 = 1,\\quad v_3(0)=\\begin{pmatrix}1\\\\ 0\\end{pmatrix}.$$\n- 用例 $\\,4\\,$（刚性衰减，$\\,\\lVert M t\\rVert\\,$ 值大，易于相消的级数）：\n  $$M_4=\\begin{pmatrix}-10 & 0\\\\ 0 & -20\\end{pmatrix},\\quad t_4 = 5,\\quad v_4(0)=\\begin{pmatrix}1\\\\ -1\\end{pmatrix}.$$\n- 用例 $\\,5\\,$（纯旋转生成元，短时间）：\n  $$M_5=\\begin{pmatrix}0 & -1\\\\ 1 & 0\\end{pmatrix},\\quad t_5 = 0.1,\\quad v_5(0)=\\begin{pmatrix}1\\\\ 0\\end{pmatrix}.$$\n\n对于每个用例 $\\,i\\in\\{1,2,3,4,5\\}\\,$，生成三元组 $\\,\\big[\\varepsilon_D^{(i)},\\ \\varepsilon_T^{(i)},\\ \\kappa(V^{(i)})\\big]\\,$，其中 $\\,\\kappa(V^{(i)})\\,$ 是方法D在用例 $\\,i\\,$ 中使用的特征向量矩阵的 $\\,2$-范数条件数。如果由于无法对 $\\,V\\,$ 求逆而无法应用方法D，则输出 $\\,\\varepsilon_D^{(i)}=\\mathrm{NaN}\\,$ 及 $\\,\\kappa(V^{(i)})=+\\infty\\,$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由逗号分隔的列表组成的列表形式的结果，每个内部列表包含三个科学记数法表示的浮点数，每个浮点数均格式化为 $12$ 位有效数字（例如，数字 $\\,\\pi\\,$ 将被打印为 $\\,3.141592653590\\mathrm{e}{+00}\\,$）。最后一行必须严格采用以下形式\n$$\\big[\\,[\\varepsilon_D^{(1)},\\varepsilon_T^{(1)},\\kappa(V^{(1)})],\\ [\\varepsilon_D^{(2)},\\varepsilon_T^{(2)},\\kappa(V^{(2)})],\\ \\dots,\\ [\\varepsilon_D^{(5)},\\varepsilon_T^{(5)},\\kappa(V^{(5)})]\\,\\big],$$\n前后不得有任何附加文本。本问题不涉及角度和物理单位。所有数值答案必须按上述规定以十进制浮点数报告；不要使用百分号，也不要包含单位。", "solution": "所提出的问题要求对求解线性常微分方程(ODE)系统 $\\dot{v}(t) = M v(t)$ 的两种数值方法进行定量比较，其中 $v(t) \\in \\mathbb{R}^2$ 且 $M \\in \\mathbb{R}^{2 \\times 2}$ 是一个常数矩阵。这个初值问题的精确解由矩阵指数给出，$v(t) = \\exp(M t) v(0)$。我们必须针对五个不同的测试用例，评估两种近似方案——方法D(对角化)和方法T(截断泰勒级数)——的数值精度，并与一个高保真度的参考解进行对比。\n\n首先，必须确定每次计算的方法。\n\n**参考解的计算**\n为了作为基准，需要一个高精度的参考解，记为 $v_{\\mathrm{ref}}(t)$。我们使用一个数值上稳健的矩阵指数库实现，即 `scipy.linalg.expm`，来计算这个解。该函数采用缩放平方算法结合帕德近似法（Padé approximants），这是数值线性代数中一种标准且可靠的方法。因此，参考解计算为 $v_{\\mathrm{ref}}(t) = \\text{expm}(M t) v(0)$。任何近似解 $\\tilde{v}(t)$ 的相对误差，都通过与此参考解比较，使用 $2$-范数来衡量：\n$$\n\\varepsilon = \\frac{\\lVert \\tilde{v}(t) - v_{\\mathrm{ref}}(t) \\rVert_2}{\\lVert v_{\\mathrm{ref}}(t) \\rVert_2}\n$$\n\n**方法D：对角化**\n该方法利用了矩阵 $M$ 的特征分解。如果 $M$ 可对角化，它可以表示为 $M = V \\Lambda V^{-1}$，其中 $\\Lambda$ 是包含 $M$ 的特征值 $\\lambda_i$ 的对角矩阵，而 $V$ 的列是相应的特征向量。这种分解使得矩阵指数的计算变得简单：$\\exp(M t) = V \\exp(\\Lambda t) V^{-1}$。对角矩阵 $\\Lambda t$ 的指数是一个对角矩阵，其元素为 $e^{\\lambda_i t}$。近似解定义为 $\\tilde{v}_D(t) = V \\exp(\\Lambda t) V^{-1} v(0)$。\n\n该方法的数值稳定性和准确性严重依赖于特征向量矩阵 $V$ 的条件。条件数 $\\kappa(V) = \\lVert V \\rVert_2 \\lVert V^{-1} \\rVert_2$ 量化了这种敏感性。大的 $\\kappa(V)$ 值意味着特征向量近似线性相关，并且在 $V$ 或 $v(0)$ 计算中的任何浮点误差都将在最终结果中被大大放大。如果 $M$ 是亏损的（不可对角化），或在数值上如此接近亏损以至于 $V$ 在浮点运算中是奇异的，那么它的逆 $V^{-1}$ 就无法形成。在这种情况下，问题规定将误差 $\\varepsilon_D$ 报告为非数值（$\\mathrm{NaN}$），并将条件数 $\\kappa(V)$ 报告为正无穷大（$+\\infty$）。我们的实现使用 `numpy.linalg.eig` 计算特征值和特征向量，并使用 `try-except` 块来处理在 $V$ 求逆过程中可能出现的 `LinAlgError`。\n\n**方法T：截断泰勒级数**\n这种方法使用矩阵指数函数在零点附近的泰勒级数展开式，并截断至指定阶数 $N=20$ 来进行近似。近似式由下式给出：\n$$\n\\exp(A) \\approx \\sum_{k=0}^{N} \\frac{A^k}{k!}\n$$\n将 $A = M t$ 代入，近似解向量为 $\\tilde{v}_T(t) = \\left( \\sum_{k=0}^{N} \\frac{(M t)^k}{k!} \\right) v(0)$。直接计算 $(Mt)^k$ 和 $k!$ 的简单实现，很容易由于潜在的溢出和灾难性抵消而导致数值不稳定。一种更好的方法是迭代计算总和。设 $x_k = \\frac{(Mt)^k}{k!} v(0)$ 为级数中的第 $k$ 个向量项。这些项可以通过递推关系生成：\n$$\nx_0 = v(0) \\quad \\text{且} \\quad x_k = \\frac{Mt}{k} x_{k-1} \\quad \\text{对于 } k \\geq 1\n$$\n最终的近似解是总和 $\\tilde{v}_T(t) = \\sum_{k=0}^{N} x_k$。这种迭代方案避免了直接计算大幂次和阶乘，但如果 $\\lVert Mt \\rVert$ 很大，它仍然容易受到灾难性抵消的影响，因为大幅值的项相加可能得到一个很小的结果。\n\n**具体测试用例分析**\n这五个测试用例旨在探究这些方法在不同数值条件下的弱点：\n- **用例1（对称）：**矩阵 $M_1$ 是对称的，这保证了其特征向量矩阵 $V_1$是正交的，因此 $\\kappa(V_1)=1$。方法D预计会非常准确。\n- **用例2（近乎亏损）：** $M_2$ 是一个具有近简并特征值的非正规矩阵。这将导致一个高度病态的特征向量矩阵 $V_2$ (即 $\\kappa(V_2) \\gg 1$), 从而严重降低方法D的准确性。\n- **用例3（亏损）：** $M_3$ 是一个若尔当块，在精确算术中是不可对角化的。在数值上，其计算出的特征向量矩阵 $V_3$ 将是奇异的或接近奇异的。我们预计对 $V_3$ 的求逆尝试将会失败，导致 $\\varepsilon_D = \\mathrm{NaN}$ 和 $\\kappa(V_3) = +\\infty$。\n- **用例4（刚性系统）：** $M_4$ 是对角矩阵，所以方法D应该在机器精度内是精确的。然而，$M_4 t_4$ 的范数很大。对于大的负数（例如 $e^{-50}$ 和 $e^{-100}$）的指数函数的泰勒级数会遭受极端的灾难性抵消。我们预计方法T会产生一个非常不准确的结果。\n- **用例5（旋转生成元）：** $M_5$ 是斜对称的，生成一个旋转。其特征向量矩阵 $V_5$ 是良态的。参数 $M_5 t_5$ 的范数很小，因此泰勒级数收敛很快，应该会很准确。两种方法预计都会表现良好。\n\n实现过程是遍历每个用例，执行所述计算，并根据指定的输出格式来格式化结果。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes and compares numerical errors for two methods of solving dv/dt = Mv.\n    \"\"\"\n\n    def format_sci(num):\n        \"\"\"Formats a number into scientific notation with 12 significant digits.\"\"\"\n        if np.isnan(num):\n            return 'nan'\n        if np.isinf(num):\n            return 'inf'\n        return f\"{num:.12e}\"\n\n    def analyze_case(M, t, v0):\n        \"\"\"\n        Analyzes a single case by computing errors for Method D and Method T.\n\n        Args:\n            M (np.ndarray): The 2x2 matrix.\n            t (float): The time for evolution.\n            v0 (np.ndarray): The initial condition vector.\n\n        Returns:\n            tuple: A tuple containing (error_D, error_T, kappa_V).\n        \"\"\"\n        N_TAYLOR = 20\n        Mt = M * t\n\n        # 1. Compute high-accuracy reference solution using scipy.linalg.expm\n        try:\n            v_ref = linalg.expm(Mt) @ v0\n        except Exception:\n            # Fallback for extreme cases, though unlikely with these inputs\n            return np.nan, np.nan, np.nan\n        \n        norm_v_ref = np.linalg.norm(v_ref, 2)\n\n        # If the reference solution is a zero vector, relative errors are undefined or 0.\n        # This is not expected for the given test cases.\n        # To prevent division by zero, we handle this edge case.\n        if norm_v_ref == 0.0:\n            # error is 0 if approximation is also 0, otherwise it is inf.\n            # a simple check to avoid crashing:\n            # we will assume non-zero v_ref based on problem statement.\n            # If it occurs, NaN is a reasonable report for such ambiguity.\n             return np.nan, np.nan, np.nan\n\n\n        # 2. Method D (Diagonalization)\n        try:\n            eigvals, V = np.linalg.eig(M)\n            V_inv = np.linalg.inv(V)\n\n            # 2-norm condition number of the eigenvector matrix V\n            kappa_V = np.linalg.cond(V, 2)\n            \n            # Diagonal matrix exp(Lambda*t)\n            exp_Lt = np.diag(np.exp(eigvals * t))\n            \n            # Approximate solution\n            v_tilde_D = V @ exp_Lt @ V_inv @ v0\n            \n            # Relative 2-norm error\n            error_D = np.linalg.norm(v_tilde_D - v_ref, 2) / norm_v_ref\n            \n        except np.linalg.LinAlgError:\n            # Handles singular V matrix (defective or numerically singular case)\n            error_D = np.nan\n            kappa_V = np.inf\n\n        # 3. Method T (Truncated Taylor Series)\n        # Iterative calculation to avoid overflow and cancellation\n        v_tilde_T = np.zeros_like(v0, dtype=np.float64)\n        term = v0.copy().astype(np.float64)\n        \n        # Sum a_k = ((Mt)^k / k!) * v0 from k=0 to N\n        # using recurrence x_k = (Mt/k) * x_{k-1} on vector terms\n        v_tilde_T += term # k=0 term\n        for k in range(1, N_TAYLOR + 1):\n            term = (Mt @ term) / k\n            v_tilde_T += term\n            \n        error_T = np.linalg.norm(v_tilde_T - v_ref, 2) / norm_v_ref\n        \n        return error_D, error_T, kappa_V\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: Symmetric, well-conditioned\n        (np.array([[-1.0, 0.2], \n                   [0.2, -2.0]]), \n         1.0, \n         np.array([1.0, 0.0])),\n\n        # Case 2: Non-normal, nearly defective\n        (np.array([[-1.0, 1.0], \n                   [0.0, -1.0 + 1e-6]]), \n         1.0, \n         np.array([1.0, 1.0])),\n\n        # Case 3: Defective Jordan block\n        (np.array([[-1.0, 1.0], \n                   [0.0, -1.0]]), \n         1.0, \n         np.array([1.0, 0.0])),\n\n        # Case 4: Stiff decay, large ||Mt||\n        (np.array([[-10.0, 0.0], \n                   [0.0, -20.0]]), \n         5.0, \n         np.array([1.0, -1.0])),\n\n        # Case 5: Pure rotation generator\n        (np.array([[0.0, -1.0], \n                   [1.0, 0.0]]), \n         0.1, \n         np.array([1.0, 0.0]))\n    ]\n\n    all_results = []\n    for M, t, v0 in test_cases:\n        eD, eT, kV = analyze_case(M, t, v0)\n        \n        eD_str = format_sci(eD)\n        eT_str = format_sci(eT)\n        kV_str = format_sci(kV)\n\n        all_results.append(f\"[{eD_str}, {eT_str}, {kV_str}]\")\n    \n    # Print the final output in the required format\n    print(f\"[{', '.join(all_results)}]\")\n\nsolve()\n```"}]}