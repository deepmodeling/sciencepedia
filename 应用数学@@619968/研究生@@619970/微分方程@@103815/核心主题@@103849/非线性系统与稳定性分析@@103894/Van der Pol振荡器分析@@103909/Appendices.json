{"hands_on_practices": [{"introduction": "要理解范德波振子为何能自发产生振荡，我们首先需要考察其在平衡点附近的行为。这个练习将引导你使用线性稳定性分析这一动力学中的基本工具，通过计算雅可比矩阵的特征值，揭示范德波振子在原点附近是如何放大微小扰动的。这个过程阐明了系统在小振幅下的“负阻尼”特性，正是这一特性启动了整个振荡过程。[@problem_id:1067889]", "problem": "Van der Pol 振子是一种著名的具有非线性阻尼的非保守振子。Van der Pol 方程的广义形式由以下二阶常微分方程给出：\n$$ \\frac{d^2x}{dt^2} - \\mu(1-\\alpha x^2)\\frac{dx}{dt} + \\omega_0^2 x = 0 $$\n其中 $x(t)$ 是位移，$\\mu > 0$ 是阻尼系数，$\\alpha > 0$ 是与非线性相关的参数，而 $\\omega_0 > 0$ 是无阻尼线性振子的固有频率。\n\n该系统可以通过将其转换为一个一阶微分方程组进行分析。其平衡点的稳定性由雅可比矩阵在这些平衡点上的特征值决定。该系统在原点 $(x, \\frac{dx}{dt}) = (0,0)$ 处有一个平衡点。\n\n对于系统在原点周围表现出稳定或不稳定螺旋行为的情况，雅可比矩阵的特征值为一对共轭复数。这种情况在参数满足条件 $\\mu^2 < 4\\omega_0^2$ 时发生。\n\n你的任务是推导这些复数特征值虚部的大小（绝对值）。", "solution": "我们设 $x_1=x,\\;x_2=\\dot x$。则该系统变为\n$$x_1' = x_2,$$\n$$x_2' = \\mu\\bigl(1-\\alpha x_1^2\\bigr)x_2-\\omega_0^2x_1.$$\n雅可比矩阵为\n$$J=\\begin{pmatrix}\n\\partial_{x_1}x_1' & \\partial_{x_2}x_1'\\\\\n\\partial_{x_1}x_2' & \\partial_{x_2}x_2'\n\\end{pmatrix}\n=\\begin{pmatrix}\n0 & 1\\\\\n-\\omega_0^2-2\\mu\\alpha x_1x_2 & \\mu(1-\\alpha x_1^2)\n\\end{pmatrix}.$$\n在平衡点 $(0,0)$ 处，此矩阵简化为\n$$J(0,0)=\\begin{pmatrix}0&1\\\\-\\omega_0^2&\\mu\\end{pmatrix}.$$\n特征方程为\n$$\\det\\bigl(J(0,0)-\\lambda I\\bigr)\n=\\begin{vmatrix}-\\lambda&1\\\\-\\omega_0^2&\\mu-\\lambda\\end{vmatrix}\n=\\lambda^2-\\mu\\lambda+\\omega_0^2=0.$$\n因此特征值为\n$$\\lambda=\\frac{\\mu\\pm\\sqrt{\\mu^2-4\\omega_0^2}}{2}.$$\n当 $\\mu^2<4\\omega_0^2$ 时，这些特征值为共轭复数，\n$$\\lambda=\\frac\\mu2\\pm i\\,\\frac{\\sqrt{4\\omega_0^2-\\mu^2}}{2},$$\n所以虚部的大小为\n$$\\frac{\\sqrt{4\\omega_0^2-\\mu^2}}{2}\\,. $$", "answer": "$$\\boxed{\\frac{\\sqrt{4\\omega_0^2-\\mu^2}}{2}}$$", "id": "1067889"}, {"introduction": "既然我们知道系统在原点是不稳定的，一个自然的问题是：为什么振幅不会无限增大？这个练习将向你介绍用于排除周期轨道的本迪克森判据 (Bendixson's criterion)，并解释为何它对范德波系统失效。通过分析矢量场的散度，你将发现系统的阻尼如何从负值（能量输入）变为正值（能量耗散），这正是形成稳定极限环的关键机制。[@problem_id:1689776]", "problem": "考虑范德波尔振荡器，这是一种具有非线性阻尼的非保守振荡器。其动力学可由以下一阶常微分方程组描述：\n$$\n\\frac{dx}{dt} = y\n$$\n$$\n\\frac{dy}{dt} = -x + \\mu(1-x^2)y\n$$\n其中 $\\mu$ 是一个代表非线性阻尼强度的正常数。\n\nBendixson判据是动力系统理论中的一个结果，可用于排除相平面内特定区域中闭轨（极限环）的存在。该判据基于与系统相关的向量场的性质。\n\n基于对该系统的分析，对于所有的 $x, y \\in \\mathbb{R}$，下列哪个陈述正确解释了Bendixson判据对范德波尔振荡器的适用性？\n\nA. 对于 $\\mu > 0$，系统向量场的散度恒为正，因此Bendixson判据证明了不存在极限环。\n\nB. 对于 $\\mu > 0$，系统向量场的散度恒为负，因此Bendixson判据证明了不存在极限环。\n\nC. 系统向量场的散度恒等于零，这意味着Bendixson判据没有定论。\n\nD. 系统向量场的散度符号随 $x$ 值的变化而变化。因此，Bendixson判据不能用于排除在整个相平面上存在极限环的可能性。\n\nE. 系统向量场的散度符号随 $y$ 值的变化而变化。因此，Bendixson判据不能用于排除在整个相平面上存在极限环的可能性。", "solution": "系统由 $\\dot{x}=y$ 和 $\\dot{y}=-x+\\mu(1-x^{2})y$ 给出。将向量场记为 $F(x,y)=(f_{1}(x,y),f_{2}(x,y))$，其中 $f_{1}(x,y)=y$ 且 $f_{2}(x,y)=-x+\\mu(1-x^{2})y$。\n\nBendixson判据表明：如果在单连通区域 $R$ 上，散度 $\\partial f_{1}/\\partial x+\\partial f_{2}/\\partial y$ 的符号不变且不恒为零，那么不存在完全位于 $R$ 内的非常数周期轨道。\n\n计算散度：\n$$\n\\frac{\\partial f_{1}}{\\partial x}+\\frac{\\partial f_{2}}{\\partial y}\n=\\frac{\\partial}{\\partial x}(y)+\\frac{\\partial}{\\partial y}\\big(-x+\\mu(1-x^{2})y\\big)\n=0+\\mu(1-x^{2})\n=\\mu(1-x^{2}).\n$$\n对于 $\\mu>0$，$\\mu(1-x^{2})$ 的符号取决于 $x$：当 $|x|<1$ 时为正，当 $|x|=1$ 时为零，当 $|x|>1$ 时为负。因此，在整个平面上散度是变号的（并在曲线 $x=\\pm 1$ 上为零），所以Bendixson判据的假设在整个平面上不成立。因此，Bendixson判据不能用于排除在整个相平面上存在极限环的可能性。\n\n这对应于陈述“散度符号随 $x$ 的值变化而非 $y$”，因此正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1689776"}, {"introduction": "最后的这个动手实践将理论与可观测的现象联系起来，要求你亲手构建一个范德波振子的数值模拟。运用龙格-库塔 (Runge-Kutta) 方法，你将把抽象的微分方程带入现实，并直观地看到极限环的概念。通过这个计算练习，你将验证无论轨迹从极限环内部还是外部开始，它们最终都会收敛到这个独特的稳定轨道上，从而巩固你的理解。[@problem_id:2395985]", "problem": "您需要编写一个完整、可运行的程序，使用经典的四阶龙格-库塔方法来研究范德波尔振子。范德波尔振子是一个二阶常微分方程 (ODE)：$$\\frac{d^2 x}{dt^2} - \\mu \\left(1 - x^2\\right)\\frac{dx}{dt} + x = 0,$$ 您必须通过定义 $y = \\frac{dx}{dt}$ 将其转换为一阶系统，从而得到 $$\\frac{dx}{dt} = y,\\quad \\frac{dy}{dt} = \\mu \\left(1 - x^2\\right) y - x.$$ 所有变量均为无量纲。\n\n您的任务是实现一个具有固定步长的经典四阶龙格-库塔时间步进方法，用于对上述系统在几组参数集和初始条件下进行积分。然后，您必须通过从长时间行为中提取渐近振幅来量化极限环的出现，并证明对于正 $\\mu$ 值，从极限环内部或外部开始的轨迹都会收敛到它。\n\n您可以假定的基本知识：常微分方程的定义、初值问题的概念，以及将 $\\frac{dx}{dt}$、$\\frac{dy}{dt}$ 与状态演化联系起来的牛顿运动学。您不得使用任何预构建的 ODE 求解器。\n\n实现以下步骤：\n- 使用具有固定时间步长 $h$ 的经典四阶龙格-库塔方法，根据上面定义的右侧函数，来随时间推进状态 $(x,y)$。不要使用任何自适应时间步进。\n- 对于每次模拟，定义一个总时间 $T$，并在分析中舍弃持续时间为 $T_{\\mathrm{trans}}$ 的初始瞬态过程。在剩余数据上，计算振幅估计值 $$A = \\frac{1}{2}\\left(\\max x - \\min x\\right),$$ 其中极值取自时间区间 $[T - T_{\\mathrm{trans}}, T]$。\n- 对于给定的 $\\mu$，模拟两条具有不同初始条件的轨迹，一条在最终极限环“内部”，另一条在“外部”，并计算两个振幅 $A_{\\mathrm{in}}$ 和 $A_{\\mathrm{out}}$。然后，使用指定的容差 $\\varepsilon$ 计算一个布尔收敛指标，定义为 $$\\left|A_{\\mathrm{in}} - A_{\\mathrm{out}}\\right| < \\varepsilon,$$。\n\n使用以下由参数值、时间网格和容差组成的测试套件：\n- 测试 1 (非刚性，可见收敛到一个唯一的极限环)：$\\mu = 1$，$T = 120$，$T_{\\mathrm{trans}} = 60$，$h = 0.01$，初始条件 $(x_0,y_0) = (0.1,0.1)$ 和 $(x_0,y_0) = (3.0,0.0)$，容差 $\\varepsilon = 2\\times 10^{-2}$。\n- 测试 2 (更强的非线性，弛豫振荡；使用小的固定步长来控制误差)：$\\mu = 5$，$T = 200$，$T_{\\mathrm{trans}} = 100$，$h = 0.002$，初始条件 $(x_0,y_0) = (0.1,0.1)$ 和 $(x_0,y_0) = (3.0,0.0)$，容差 $\\varepsilon = 5\\times 10^{-2}$。\n- 测试 3 (边界情况，无非线性，无吸引极限环)：$\\mu = 0$，$T = 60$，$T_{\\mathrm{trans}} = 30$，$h = 0.01$，初始条件 $(x_0,y_0) = (0.1,0.1)$ 和 $(x_0,y_0) = (3.0,0.0)$，容差 $\\varepsilon = 5\\times 10^{-2}$。\n\n对于每个测试，计算振幅对 $A_{\\mathrm{in}}$ 和 $A_{\\mathrm{out}}$，并计算上面定义的布尔收敛指标。您的程序必须将所有结果汇总到单行输出中，按以下顺序包含这 $9$ 个值：\n$$[A_{1,\\mathrm{in}}, A_{1,\\mathrm{out}}, C_1, A_{2,\\mathrm{in}}, A_{2,\\mathrm{out}}, C_2, A_{3,\\mathrm{in}}, A_{3,\\mathrm{out}}, C_3],$$\n其中 $C_k$ 是测试 $k$ 的布尔收敛指标。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $\\left[\\dots\\right]$。不应打印任何额外文本。\n\n角度单位不适用。由于系统是无量纲的，因此没有物理单位。所有数值必须在最终输出中表示为适当的浮点数或布尔值。程序必须是自包含的，并且不得读取任何输入。请确保您的实现严格遵守经典的四阶龙格-库塔方法和指定的时间步进参数，不使用任何外部 ODE 求解器。", "solution": "问题陈述需经过验证。\n\n### 步骤 1：提取给定信息\n该问题要求对范德波尔振子方程进行数值求解，这是一个二阶常微分方程 (ODE)：\n$$\n\\frac{d^2 x}{dt^2} - \\mu \\left(1 - x^2\\right)\\frac{dx}{dt} + x = 0\n$$\n通过定义一个新变量 $y = \\frac{dx}{dt}$，需要将其转换为一个由两个一阶 ODE 组成的系统。得到的系统是：\n$$\n\\frac{dx}{dt} = y\n$$\n$$\n\\frac{dy}{dt} = \\mu \\left(1 - x^2\\right) y - x\n$$\n将要使用的数值方法是具有固定时间步长 $h$ 的经典四阶龙格-库塔 (RK4) 方法。\n\n对于在总时间 $T$ 内运行的每次模拟，需要根据轨迹数据计算振幅 $A$。与瞬态时间 $T_{\\mathrm{trans}}$ 相对应的初始部分数据将被舍弃。振幅定义为：\n$$\nA = \\frac{1}{2}\\left(\\max x - \\min x\\right)\n$$\n其中最大值和最小值在时间区间 $[T - T_{\\mathrm{trans}}, T]$ 上进行评估。\n\n对于每组参数，模拟两条轨迹，一条从极限环“内部”开始 ($A_{\\mathrm{in}}$)，另一条从“外部”开始 ($A_{\\mathrm{out}}$)。然后计算一个布尔收敛指标 $C$：\n$$\nC = \\left(\\left|A_{\\mathrm{in}} - A_{\\mathrm{out}}\\right| < \\varepsilon\\right)\n$$\n其中 $\\varepsilon$ 是给定的容差。\n\n具体的测试案例如下：\n1.  **测试 1**：$\\mu = 1$，$T = 120$，$T_{\\mathrm{trans}} = 60$，$h = 0.01$。\n    初始条件：$(x_0, y_0) = (0.1, 0.1)$ (“内部”) 和 $(x_0, y_0) = (3.0, 0.0)$ (“外部”)。\n    容差：$\\varepsilon = 2 \\times 10^{-2}$。\n2.  **测试 2**：$\\mu = 5$，$T = 200$，$T_{\\mathrm{trans}} = 100$，$h = 0.002$。\n    初始条件：$(x_0, y_0) = (0.1, 0.1)$ (“内部”) 和 $(x_0, y_0) = (3.0, 0.0)$ (“外部”)。\n    容差：$\\varepsilon = 5 \\times 10^{-2}$。\n3.  **测试 3**：$\\mu = 0$，$T = 60$，$T_{\\mathrm{trans}} = 30$，$h = 0.01$。\n    初始条件：$(x_0, y_0) = (0.1, 0.1)$ (“内部”) 和 $(x_0, y_0) = (3.0, 0.0)$ (“外部”)。\n    容差：$\\varepsilon = 5 \\times 10^{-2}$。\n\n最终输出必须是包含九个值的单行，顺序如下：$[A_{1,\\mathrm{in}}, A_{1,\\mathrm{out}}, C_1, A_{2,\\mathrm{in}}, A_{2,\\mathrm{out}}, C_2, A_{3,\\mathrm{in}}, A_{3,\\mathrm{out}}, C_3]$。\n\n### 步骤 2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估。\n-   **科学依据**：该问题基于范德波尔振子，这是非线性动力学和混沌理论领域的一个典型模型。四阶龙格-库塔方法是求解 ODE 的一种标准、成熟的数值技术。极限环及其吸引特性是研究此类系统的基础。该问题在科学上是合理的。\n-   **适定性**：该问题是一个 ODE 系统的初值问题。所有必需的参数（$\\mu$）、初始条件（$(x_0, y_0)$）、积分参数（$h, T$）以及后处理步骤（分析窗口、振幅公式、收敛标准）都得到了明确无误的定义。对于给定的设置，预期会有一个唯一的数值解。\n-   **客观性**：该问题使用精确的数学语言和客观的量化标准进行规定。没有主观或基于观点的内容。\n-   **无其他缺陷**：问题是自包含的，没有缺失信息。参数对于数值研究是一致且物理上合理的。问题不是微不足道的、比喻性的或无法验证的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将开发一个解决方案。\n\n解决方案的核心是为给定的 ODE 系统实现经典的四阶龙格-库塔方法。设系统在时间 $t$ 的状态由向量 $\\mathbf{z}(t) = [x(t), y(t)]^T$ 表示。该 ODE 系统可以写成向量形式 $\\frac{d\\mathbf{z}}{dt} = \\mathbf{f}(\\mathbf{z}, \\mu)$，其中函数 $\\mathbf{f}$ 为：\n$$\n\\mathbf{f}(\\mathbf{z}, \\mu) = \\begin{pmatrix} y \\\\ \\mu(1-x^2)y - x \\end{pmatrix}\n$$\nRK4 方法使用以下步骤将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$：\n1.  计算第一个斜率估计值：$\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{z}_n, \\mu)$。\n2.  使用 $\\mathbf{k}_1$ 在中点计算第二个斜率估计值：$\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{z}_n + \\frac{h}{2}\\mathbf{k}_1, \\mu)$。\n3.  使用 $\\mathbf{k}_2$ 在中点计算第三个斜率估计值：$\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{z}_n + \\frac{h}{2}\\mathbf{k}_2, \\mu)$。\n4.  使用 $\\mathbf{k}_3$ 在区间末端计算第四个斜率估计值：$\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{z}_n + h\\mathbf{k}_3, \\mu)$。\n5.  组合斜率以获得下一个时间步的状态：$\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$。\n\n从给定的初始条件 $\\mathbf{z}_0 = [x_0, y_0]^T$ 开始，这个过程重复总步数 $N = T/h$。在积分过程中，状态向量的 $x$ 分量的历史记录被存储起来。\n\n模拟完成后，进行分析。问题规定极值取自时间区间 $[T - T_{\\mathrm{trans}}, T]$。对于所有测试用例，恰好有 $T - T_{\\mathrm{trans}} = T_{\\mathrm{trans}}$。这意味着分析窗口对应于模拟数据的后半部分。在包含 $N+1$ 个点的历史数组中，此分析窗口的起始索引为 $i_{\\mathrm{start}} = T_{\\mathrm{trans}} / h$。然后，算法在该历史数组从该索引到末尾的切片中找到 $x$ 的最大值和最小值。这些值被用来计算振幅 $A$。\n\n对于每个测试用例，整个过程（模拟和分析）执行两次：一次针对“内部”初始条件以找到 $A_{\\mathrm{in}}$，一次针对“外部”初始条件以找到 $A_{\\mathrm{out}}$。然后评估收敛条件 $|A_{\\mathrm{in}} - A_{\\mathrm{out}}| < \\varepsilon$ 以产生布尔结果 $C$。\n\n$\\mu = 0$ 的特殊情况对应于简谐振子 $\\frac{d^2x}{dt^2} + x = 0$。该系统没有吸引极限环；其振幅是守恒的，完全取决于初始条件。因此，我们预期 $A_{\\mathrm{in}}$ 和 $A_{\\mathrm{out}}$ 会有显著差异，导致收敛指标为 `False`。对于 $\\mu > 0$ 的情况，系统有一个唯一的、稳定的极限环，因此从内部和外部开始的轨迹预期会收敛到它，如果模拟时间和数值精度足够，收敛指标将为 `True`。所提供的参数旨在演示此行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the van der Pol oscillator problem for a set of test cases.\n    Implements the classical RK4 method and analyzes trajectory convergence.\n    \"\"\"\n\n    def f(z, mu):\n        \"\"\"\n        Calculates the derivative vector for the van der Pol system.\n        z: state vector [x, y]\n        mu: nonlinearity parameter\n        \"\"\"\n        x, y = z\n        dxdt = y\n        dydt = mu * (1.0 - x**2) * y - x\n        return np.array([dxdt, dydt])\n\n    def rk4_step(z, h, mu):\n        \"\"\"\n        Performs a single step of the classical 4th-order Runge-Kutta method.\n        z: current state vector [x, y]\n        h: time step\n        mu: nonlinearity parameter\n        \"\"\"\n        k1 = f(z, mu)\n        k2 = f(z + 0.5 * h * k1, mu)\n        k3 = f(z + 0.5 * h * k2, mu)\n        k4 = f(z + h * k3, mu)\n        return z + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def run_simulation(mu, ic, T, h):\n        \"\"\"\n        Runs a full simulation for the van der Pol oscillator.\n        mu: nonlinearity parameter\n        ic: initial condition (x0, y0)\n        T: total simulation time\n        h: time step\n        Returns: array of x-positions over time.\n        \"\"\"\n        n_steps = int(T / h)\n        x_history = np.zeros(n_steps + 1)\n        \n        z = np.array(ic, dtype=float)\n        x_history[0] = z[0]\n        \n        for i in range(n_steps):\n            z = rk4_step(z, h, mu)\n            x_history[i+1] = z[0]\n            \n        return x_history\n\n    def calculate_amplitude(x_history, T_trans, h):\n        \"\"\"\n        Calculates the asymptotic amplitude from the trajectory.\n        x_history: array of x-positions\n        T_trans: duration of transient to discard\n        h: time step\n        \"\"\"\n        # The analysis is over the interval [T_trans, T].\n        # The start index corresponds to time t = T_trans.\n        analysis_start_index = int(T_trans / h)\n        \n        # Slice the history to get the analysis window\n        analysis_window = x_history[analysis_start_index:]\n        \n        max_x = np.max(analysis_window)\n        min_x = np.min(analysis_window)\n        \n        return 0.5 * (max_x - min_x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (mu, T, T_trans, h, ic_in, ic_out, epsilon)\n        (1.0, 120.0, 60.0, 0.01, (0.1, 0.1), (3.0, 0.0), 2e-2),\n        (5.0, 200.0, 100.0, 0.002, (0.1, 0.1), (3.0, 0.0), 5e-2),\n        (0.0, 60.0, 30.0, 0.01, (0.1, 0.1), (3.0, 0.0), 5e-2)\n    ]\n\n    all_results = []\n    \n    for mu, T, T_trans, h, ic_in, ic_out, epsilon in test_cases:\n        # Run simulation for the \"inside\" trajectory\n        x_history_in = run_simulation(mu, ic_in, T, h)\n        A_in = calculate_amplitude(x_history_in, T_trans, h)\n        \n        # Run simulation for the \"outside\" trajectory\n        x_history_out = run_simulation(mu, ic_out, T, h)\n        A_out = calculate_amplitude(x_history_out, T_trans, h)\n        \n        # Calculate the boolean convergence indicator\n        C = abs(A_in - A_out)  epsilon\n        \n        all_results.extend([A_in, A_out, C])\n\n    # Final print statement in the exact required format.\n    # map(str, ...) converts floats and booleans to their string representations.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2395985"}]}