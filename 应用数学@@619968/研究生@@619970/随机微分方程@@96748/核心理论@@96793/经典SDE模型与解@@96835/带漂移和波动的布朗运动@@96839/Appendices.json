{"hands_on_practices": [{"introduction": "深入理解诸如布朗运动等随机过程的基本对称性至关重要。本练习将探讨当我们“倒放”一个带有漂移的布朗运动 $X_t = \\mu t + \\sigma W_t$ 时会发生什么，揭示其漂移项的一个关键而有趣的反转特性。通过解决这个问题，你将加深对布朗运动增量独立性和平稳性定义的理解，并学会如何通过变换来识别新的随机过程。[@problem_id:1286690]", "problem": "考虑一个随机过程 $X_t$，其时间为 $t \\in [0, T]$，该过程是一个具有恒定漂移 $\\mu$ 和恒定波动率 $\\sigma > 0$ 的布朗运动。该过程始于 $X_0=0$。回顾一下，这样的过程可以表示为 $X_t = \\mu t + \\sigma W_t$，其中 $W_t$ 是一个标准布朗运动。一个过程 $W_t$ 是标准布朗运动，需满足：(i) $W_0=0$；(ii) 对于任意 $0 \\le s < t$，增量 $W_t - W_s$ 是一个均值为 0、方差为 $t-s$ 的正态分布随机变量；(iii) 对于任意不重叠的时间区间，相应的增量是独立的随机变量；以及 (iv) 样本路径 $t \\mapsto W_t$ 是连续的。\n\n现在，我们在相同的时间区间 $t \\in [0, T]$ 上定义一个新的时间反转过程 $Y_t$ 如下：\n$$Y_t = X_{T-t} - X_T$$\n确定过程 $Y_t$ 的性质。下列哪个陈述是正确的？\n\nA. $Y_t$ 是一个漂移为 $\\mu$、波动率为 $\\sigma$ 的布朗运动。\n\nB. $Y_t$ 是一个漂移为 $-\\mu$、波动率为 $\\sigma$ 的布朗运动。\n\nC. $Y_t$ 是一个漂移为 $0$、波动率为 $\\sigma$ 的布朗运动。\n\nD. $Y_t$ 不是一个布朗运动，因为它的增量不是独立的。", "solution": "我们从给定的过程 $X_{t}=\\mu t+\\sigma W_{t}$（其中 $W_{t}$ 是标准布朗运动）出发，对 $t\\in[0,T]$ 定义\n$$\nY_{t}=X_{T-t}-X_{T}.\n$$\n使用 $X$ 的表示法展开，得到\n$$\nY_{t}=\\mu(T-t)+\\sigma W_{T-t}-\\mu T-\\sigma W_{T}=-\\mu t+\\sigma\\bigl(W_{T-t}-W_{T}\\bigr).\n$$\n定义时间反转的布朗运动\n$$\n\\widehat{W}_{t}:=W_{T}-W_{T-t},\\qquad t\\in[0,T].\n$$\n则 $W_{T-t}-W_{T}=-\\widehat{W}_{t}$，所以\n$$\nY_{t}=-\\mu t-\\sigma\\widehat{W}_{t}.\n$$\n我们现在验证 $\\widehat{W}_{t}$ 是一个标准布朗运动。首先，$\\widehat{W}_{0}=W_{T}-W_{T}=0$。其连续性由 $W$ 的连续性得出。对于 $0\\leq s<t\\leq T$，\n$$\n\\widehat{W}_{t}-\\widehat{W}_{s}=(W_{T}-W_{T-t})-(W_{T}-W_{T-s})=W_{T-s}-W_{T-t}.\n$$\n根据 $W$ 的平稳增量性质，增量 $W_{T-s}-W_{T-t}$ 是高斯分布的，其均值为 $0$，方差为 $(T-s)-(T-t)=t-s$。此外，对于 $[0,T]$ 中的不相交区间 $(s_{1},t_{1}]$ 和 $(s_{2},t_{2}]$，对应的 $W$ 的区间是 $[T-t_{1},T-s_{1}]$ 和 $[T-t_{2},T-s_{2}]$，它们也是不相交的；因此，根据 $W$ 的增量独立性，$\\widehat{W}$ 在不相交时间区间上的增量是独立的。所以 $\\widehat{W}$ 是一个标准布朗运动。\n\n由于标准布朗运动的相反数也是一个标准布朗运动，我们可以记 $-\\widehat{W}_{t}=\\widetilde{W}_{t}$，其中 $\\widetilde{W}$ 是一个标准布朗运动。因此\n$$\nY_{t}=-\\mu t+\\sigma\\widetilde{W}_{t}.\n$$\n等价地，对于 $0\\leq s<t\\leq T$，\n$$\nY_{t}-Y_{s}=-\\mu(t-s)+\\sigma\\bigl(W_{T-t}-W_{T-s}\\bigr),\n$$\n该增量服从均值为 $-\\mu(t-s)$、方差为 $\\sigma^{2}(t-s)$ 的正态分布，并且这些增量在不相交的区间上是独立的。同样有 $Y_{0}=0$。因此 $Y$ 是一个漂移为 $-\\mu$、波动率为 $\\sigma$ 的布朗运动。\n\n因此，正确的陈述是 $Y_{t}$ 是一个漂移为 $-\\mu$、波动率为 $\\sigma$ 的布朗运动。", "answer": "$$\\boxed{B}$$", "id": "1286690"}, {"introduction": "虽然我们知道任一固定时间 $t$ 处 $X_t$ 的分布，但要理解其统计特性（如均值、方差、偏度）如何随时间演化，则需要更强大的工具。本练习将运用伊藤公式 (Itô's formula)，推导出控制过程各阶矩 $m_n(t) = \\mathbb{E}[X_t^n]$ 演化的常微分方程，这是随机分析中的一项核心技术。掌握这项技能对于分析任何由随机微分方程定义的动态系统都是必不可少的。[@problem_id:2970465]", "problem": "考虑一个由标准布朗运动（也称为维纳过程）驱动的一维Itô过程，其定义为 $X_t = x_0 + \\mu t + \\sigma W_t$，其中常数 $x_0 \\in \\mathbb{R}$，$\\mu \\in \\mathbb{R}$，且 $\\sigma \\in (0,\\infty)$。对每个整数 $n \\geq 0$，定义n阶原点矩 $m_n(t) = \\mathbb{E}[X_t^n]$。仅使用布朗运动的基本性质和对于$C^2$函数$f$的Itô公式，推导序列 $\\{m_n(t)\\}_{n \\geq 0}$ 关于$t$的确定性递推关系，并包含其初始条件。然后，对于 $n = 1, 2, 3$ 的情况，显式求解此递推关系，以获得 $m_1(t)$、$m_2(t)$ 和 $m_3(t)$ 作为 $t$、$x_0$、$\\mu$ 和 $\\sigma$ 的函数的闭式表达式。给出 $m_1(t)$、$m_2(t)$ 和 $m_3(t)$ 的最终显式表达式。", "solution": "过程 $X_t$ 是一个算术布朗运动（或广义维纳过程），其动态由以下随机微分方程（SDE）描述：\n$$\ndX_t = \\mu dt + \\sigma dW_t\n$$\n初始条件为确定性的 $X_0 = x_0$。这里 $W_t$ 是一个标准维纳过程，且 $x_0 \\in \\mathbb{R}$，$\\mu \\in \\mathbb{R}$，$\\sigma \\in (0, \\infty)$ 均为常数。\n\n我们需要找到n阶原点矩 $m_n(t) = \\mathbb{E}[X_t^n]$ 的递推关系。我们将对函数 $f(x) = x^n$ 使用Itô公式。对于任意整数 $n \\geq 2$，该函数属于 $C^\\infty$ 类，因此是$C^2$函数，满足该公式的应用前提。\n\n用于Itô过程 $X_t$ 的函数 $f(t,x)$ 的Itô公式的一般形式为：\n$$\ndf(t, X_t) = \\frac{\\partial f}{\\partial t} dt + \\frac{\\partial f}{\\partial x} dX_t + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial x^2} (dX_t)^2\n$$\n在本例中，$f(x) = x^n$ 不显式依赖于 $t$。其偏导数分别为：\n$$\n\\frac{\\partial f}{\\partial t} = 0, \\quad \\frac{\\partial f}{\\partial x} = n x^{n-1}, \\quad \\frac{\\partial^2 f}{\\partial x^2} = n(n-1) x^{n-2}\n$$\n二次变分项 $(dX_t)^2$ 使用Itô积分的乘法规则（$dt \\cdot dt = 0$，$dt \\cdot dW_t = 0$ 和 $dW_t \\cdot dW_t = dt$）计算如下：\n$$\n(dX_t)^2 = (\\mu dt + \\sigma dW_t)^2 = \\mu^2 (dt)^2 + 2\\mu\\sigma dt dW_t + \\sigma^2 (dW_t)^2 = \\sigma^2 dt\n$$\n将这些表达式代入 $f(X_t) = X_t^n$ 的Itô公式，我们得到：\n$$\nd(X_t^n) = n X_t^{n-1} dX_t + \\frac{1}{2} n(n-1) X_t^{n-2} (dX_t)^2\n$$\n$$\nd(X_t^n) = n X_t^{n-1} (\\mu dt + \\sigma dW_t) + \\frac{1}{2} n(n-1) X_t^{n-2} (\\sigma^2 dt)\n$$\n合并 $dt$ 和 $dW_t$ 项，得到 $X_t^n$ 的SDE：\n$$\nd(X_t^n) = \\left( n \\mu X_t^{n-1} + \\frac{n(n-1)}{2} \\sigma^2 X_t^{n-2} \\right) dt + n \\sigma X_t^{n-1} dW_t\n$$\n将此方程从 $s=0$ 到 $s=t$ 积分，可得：\n$$\nX_t^n - X_0^n = \\int_0^t \\left( n \\mu X_s^{n-1} + \\frac{n(n-1)}{2} \\sigma^2 X_s^{n-2} \\right) ds + \\int_0^t n \\sigma X_s^{n-1} dW_s\n$$\n现在我们对等式两边取期望。使用的关键性质有：\n1. 初始条件是确定性的，因此 $\\mathbb{E}[X_0^n] = \\mathbb{E}[x_0^n] = x_0^n$。\n2. 对于一个合适的被积函数 $g$，关于维纳过程的Itô积分的期望为零，即 $\\mathbb{E}\\left[\\int_0^t g(s, \\omega) dW_s\\right] = 0$。\n3. 根据随机Fubini定理，我们可以交换期望和时间积分的顺序。\n应用这些性质，我们得到：\n$$\n\\mathbb{E}[X_t^n] - x_0^n = \\mathbb{E}\\left[ \\int_0^t \\left( n \\mu X_s^{n-1} + \\frac{n(n-1)}{2} \\sigma^2 X_s^{n-2} \\right) ds \\right]\n$$\n$$\nm_n(t) - x_0^n = \\int_0^t \\left( n \\mu \\mathbb{E}[X_s^{n-1}] + \\frac{n(n-1)}{2} \\sigma^2 \\mathbb{E}[X_s^{n-2}] \\right) ds\n$$\n代入矩的定义 $m_k(t) = \\mathbb{E}[X_t^k]$：\n$$\nm_n(t) - x_0^n = \\int_0^t \\left( n \\mu m_{n-1}(s) + \\frac{n(n-1)}{2} \\sigma^2 m_{n-2}(s) \\right) ds\n$$\n题目的第一部分要求一个确定性的递推关系。利用微积分基本定理对 $t$ 求导，得到关于 $m_n(t)$ 的常微分方程（ODE）：\n$$\n\\frac{d}{dt} m_n(t) = n \\mu m_{n-1}(t) + \\frac{n(n-1)}{2} \\sigma^2 m_{n-2}(t)\n$$\n此递推关系对 $n \\geq 2$ 有效。对于 $n=0$ 和 $n=1$，我们有：\n- 对于 $n=0$：$m_0(t) = \\mathbb{E}[X_t^0] = \\mathbb{E}[1] = 1$。\n- 对于 $n=1$：公式给出 $\\frac{d}{dt} m_1(t) = 1 \\cdot \\mu m_0(t) + \\frac{1(0)}{2} \\sigma^2 m_{-1}(t) = \\mu m_0(t) = \\mu$。\n每个ODE的初始条件为 $m_n(0) = \\mathbb{E}[X_0^n] = x_0^n$。\n\n现在我们求解 $n=1, 2, 3$ 时的这个常微分方程组。\n\n**一阶矩 ($n=1$)：**\n常微分方程为 $\\frac{d}{dt} m_1(t) = \\mu$，初始条件为 $m_1(0) = x_0^1 = x_0$。\n对 $t$ 积分得到 $m_1(t) = \\mu t + C_1$。\n应用初始条件：$m_1(0) = x_0 \\implies C_1 = x_0$。\n因此，一阶矩为：\n$$m_1(t) = x_0 + \\mu t$$\n\n**二阶矩 ($n=2$)：**\n常微分方程为 $\\frac{d}{dt} m_2(t) = 2 \\mu m_1(t) + \\frac{2(1)}{2} \\sigma^2 m_0(t) = 2 \\mu m_1(t) + \\sigma^2 m_0(t)$。\n代入 $m_1(t)$ 和 $m_0(t)$ 的表达式：\n$$\n\\frac{d}{dt} m_2(t) = 2 \\mu (x_0 + \\mu t) + \\sigma^2 (1) = 2 \\mu x_0 + 2 \\mu^2 t + \\sigma^2\n$$\n初始条件为 $m_2(0) = x_0^2$。对 $t$ 积分：\n$$\nm_2(t) = \\int (2 \\mu x_0 + 2 \\mu^2 t + \\sigma^2) dt = 2 \\mu x_0 t + \\mu^2 t^2 + \\sigma^2 t + C_2\n$$\n应用初始条件：$m_2(0) = x_0^2 \\implies C_2 = x_0^2$。\n因此，二阶矩为：\n$$\nm_2(t) = x_0^2 + 2 \\mu x_0 t + \\mu^2 t^2 + \\sigma^2 t\n$$\n这可以更紧凑地写为：\n$$m_2(t) = (x_0 + \\mu t)^2 + \\sigma^2 t$$\n\n**三阶矩 ($n=3$)：**\n常微分方程为 $\\frac{d}{dt} m_3(t) = 3 \\mu m_2(t) + \\frac{3(2)}{2} \\sigma^2 m_1(t) = 3 \\mu m_2(t) + 3 \\sigma^2 m_1(t)$。\n代入 $m_1(t)$ 和 $m_2(t)$ 的表达式：\n$$\n\\frac{d}{dt} m_3(t) = 3 \\mu \\left( (x_0 + \\mu t)^2 + \\sigma^2 t \\right) + 3 \\sigma^2 (x_0 + \\mu t)\n$$\n展开各项：\n$$\n\\frac{d}{dt} m_3(t) = 3 \\mu (x_0^2 + 2\\mu x_0 t + \\mu^2 t^2 + \\sigma^2 t) + 3x_0\\sigma^2 + 3\\mu\\sigma^2 t\n$$\n$$\n\\frac{d}{dt} m_3(t) = 3\\mu x_0^2 + 6\\mu^2 x_0 t + 3\\mu^3 t^2 + 3\\mu\\sigma^2 t + 3x_0\\sigma^2 + 3\\mu\\sigma^2 t\n$$\n按 $t$ 的幂次合并各项：\n$$\n\\frac{d}{dt} m_3(t) = (3\\mu x_0^2 + 3x_0\\sigma^2) + (6\\mu^2 x_0 + 6\\mu\\sigma^2)t + 3\\mu^3 t^2\n$$\n初始条件为 $m_3(0) = x_0^3$。对 $t$ 积分：\n$$\nm_3(t) = \\int \\left( (3\\mu x_0^2 + 3x_0\\sigma^2) + (6\\mu^2 x_0 + 6\\mu\\sigma^2)t + 3\\mu^3 t^2 \\right) dt\n$$\n$$\nm_3(t) = (3\\mu x_0^2 + 3x_0\\sigma^2)t + (3\\mu^2 x_0 + 3\\mu\\sigma^2)t^2 + \\mu^3 t^3 + C_3\n$$\n应用初始条件：$m_3(0) = x_0^3 \\implies C_3 = x_0^3$。\n$$\nm_3(t) = x_0^3 + (3\\mu x_0^2 + 3x_0\\sigma^2)t + (3\\mu^2 x_0 + 3\\mu\\sigma^2)t^2 + \\mu^3 t^3\n$$\n这个表达式可以重排成一个更有洞察力的形式：\n$$\nm_3(t) = (x_0^3 + 3\\mu x_0^2 t + 3\\mu^2 x_0 t^2 + \\mu^3 t^3) + (3x_0\\sigma^2 t + 3\\mu\\sigma^2 t^2)\n$$\n$$\nm_3(t) = (x_0 + \\mu t)^3 + 3\\sigma^2 t(x_0 + \\mu t)\n$$\n\n前三阶矩的最终显式表达式在最终答案中给出。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nx_0 + \\mu t & (x_0 + \\mu t)^2 + \\sigma^2 t & (x_0 + \\mu t)^3 + 3 \\sigma^2 t (x_0 + \\mu t)\n\\end{pmatrix}\n}\n$$", "id": "2970465"}, {"introduction": "理论模型的力量在于其能够生成具体的预测和情景，而模拟是实现这一点的关键。本练习旨在搭建从抽象的随机微分方程 $dX_t = \\mu dt + \\sigma dW_t$ 到具象的、由计算机生成的样本路径之间的桥梁。你将学习如何基于过程的基本属性来“精确”地模拟它，这是一种将理论转化为实践的关键计算技能，与对一般随机微分方程使用的欧拉-丸山法等近似方案形成对比。[@problem_id:2970492]", "problem": "考虑随机微分方程 (SDE) $dX_t = \\mu \\, dt + \\sigma \\, dW_t$，其初始条件为 $X_0 = x_0$，其中 $W_t$ 是一个标准布朗运动。请仅使用布朗运动的基本性质：$W_0 = 0$、独立增量，以及对于 $0 \\le s < t$，$W_t - W_s$ 服从均值为 $0$、方差为 $t - s$ 的正态分布。过程 $X_t$ 服从 $X_t = x_0 + \\mu t + \\sigma W_t$。请基于这些性质，在固定的时间网格 $0 = t_0 < t_1 < \\cdots < t_n = T$ 上，推导出一个依赖于从标准正态分布中抽取的独立随机变量的 $X_t$ 精确路径模拟方案，并证明该方案为何是精确的（即，其输出为何与 $X_t$ 具有相同的有限维分布）。然后，您必须将此精确方案实现为一个程序，为下方的测试套件生成数值结果。\n\n实现要求：\n- 对每个测试用例，使用从标准正态分布中进行的独立抽样，并通过指定的整数种子初始化的可复现伪随机数生成器，在所提供的网格上模拟单一样本路径。不允许使用除基本随机抽样之外的任何近似方法。\n- 对每个测试用例，仅计算并返回与最终网格时间 $T$ 对应的终端值 $X_T$。\n- 为确保确定性输出，您必须为每个测试用例使用给定的种子。终端值必须四舍五入到10位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的终端值，格式为方括号内以逗号分隔的列表，例如 $[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是测试用例 $i$ 的四舍五入后的终端值。\n\n测试套件：\n- 测试用例1：$x_0 = 1.2$，$\\mu = -0.3$，$\\sigma = 0.7$，网格 $t = [0.0, 0.1, 0.5, 1.0]$，种子 $20231011$。\n- 测试用例2：$x_0 = 0.0$，$\\mu = 2.5$，$\\sigma = 0.0$，网格 $t = [0.0, 0.3, 0.7, 1.0]$，种子 $777$。\n- 测试用例3：$x_0 = -3.0$，$\\mu = 0.0$，$\\sigma = 2.0$，网格 $t = [0.0, 0.25, 0.5, 0.9, 1.3]$，种子 $12345$。\n- 测试用例4：$x_0 = 0.5$，$\\mu = 1 \\times 10^{-9}$，$\\sigma = 1.0$，网格 $t = [0.0, 10^{-6}, 2 \\times 10^{-6}, 10^{-4}, 3 \\times 10^{-4}]$，种子 $98765$。\n\n答案规格：\n- 输出值为实数（浮点数）。\n- 您的程序应生成单行输出，其中包含结果，格式为方括号内以逗号分隔的列表，四舍五入到10位小数，并与测试用例顺序相同：$[v_1,v_2,v_3,v_4]$。", "solution": "### 精确模拟方案的推导与证明\n\n目标是在离散时间点 $t_0, t_1, \\ldots, t_n$ 模拟过程 $X_t$ 的值。精确模拟方案的基础是SDE的解析解，该解已给出，为 $X_t = x_0 + \\mu t + \\sigma W_t$。\n\n考虑网格中两个连续的时间点 $t_{i-1}$ 和 $t_i$，其中 $i \\in \\{1, 2, \\ldots, n\\}$。我们可以使用解析解写出过程在这些点上的值：\n$$X_{t_i} = x_0 + \\mu t_i + \\sigma W_{t_i}$$\n$$X_{t_{i-1}} = x_0 + \\mu t_{i-1} + \\sigma W_{t_{i-1}}$$\n\n将第二个方程从第一个方程中减去，得到过程 $X_t$ 增量的关系式：\n$$X_{t_i} - X_{t_{i-1}} = (\\mu t_i - \\mu t_{i-1}) + (\\sigma W_{t_i} - \\sigma W_{t_{i-1}})$$\n重新整理这个方程，得到 $X_{t_i}$ 的迭代公式：\n$$X_{t_i} = X_{t_{i-1}} + \\mu (t_i - t_{i-1}) + \\sigma (W_{t_i} - W_{t_{i-1}})$$\n\n令 $\\Delta t_i = t_i - t_{i-1}$ 为时间步长。该方程变为：\n$$X_{t_i} = X_{t_{i-1}} + \\mu \\Delta t_i + \\sigma (W_{t_i} - W_{t_{i-1}})$$\n\n模拟的核心在于对布朗增量 $W_{t_i} - W_{t_{i-1}}$ 进行建模。根据问题中提供的布朗运动基本性质，对于任意 $s < t$，增量 $W_t - W_s$ 是一个服从正态分布的随机变量，其均值为 $0$，方差为 $t-s$。因此，对于我们的时间步长 $\\Delta t_i$：\n$$W_{t_i} - W_{t_{i-1}} \\sim \\mathcal{N}(0, \\Delta t_i)$$\n\n一个随机变量 $Y \\sim \\mathcal{N}(0, \\sigma^2)$ 可以表示为 $Y = \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0, 1)$ 是一个标准正态随机变量。将此应用于布朗增量，我们得到：\n$$W_{t_i} - W_{t_{i-1}} = \\sqrt{\\Delta t_i} \\cdot Z_i$$\n其中 $Z_i$ 代表从标准正态分布 $Z_i \\sim \\mathcal{N}(0, 1)$ 中进行的一次独立抽样。\n\n将其代入我们的迭代公式，我们得到精确的模拟方案：\n$$X_{t_i} = X_{t_{i-1}} + \\mu \\Delta t_i + \\sigma \\sqrt{\\Delta t_i} Z_i$$\n\n模拟流程如下：\n1.  在时间 $t_0 = 0$ 处，使用给定的初始值初始化过程：$X_{t_0} = x_0$。\n2.  对于从 $1$ 到 $n$ 的每一步 $i$：\n    a. 计算时间间隔 $\\Delta t_i = t_i - t_{i-1}$。\n    b. 从标准正态分布 $\\mathcal{N}(0, 1)$ 中生成一个独立的随机变量 $Z_i$。\n    c. 使用推导出的方案更新过程值：$X_{t_i} = X_{t_{i-1}} + \\mu \\Delta t_i + \\sigma \\sqrt{\\Delta t_i} Z_i$。\n3.  最终值 $X_{t_n}$ 即为所要求的终端值 $X_T$。\n\n**精确性证明：**\n该方案被称为“精确”的，因为模拟值 $(X_{t_0}, X_{t_1}, \\ldots, X_{t_n})$ 的联合分布与真实过程在相同时间点上采样的联合分布完全相同。这是我们推导的直接结果。我们没有对SDE进行近似（如欧拉-丸山方法中对 $dX_t$ 进行离散化）。相反，我们从精确的积分解 $X_t = x_0 + \\mu t + \\sigma W_t$ 出发，并利用了其性质。模拟过程的增量 $X_{t_i} - X_{t_{i-1}}$ 被定义为与真实过程的增量具有完全相同的分布：\n$$X_{t_i} - X_{t_{i-1}} \\sim \\mathcal{N}(\\mu \\Delta t_i, \\sigma^2 \\Delta t_i)$$\n此外，由于随机抽样 $Z_i$ 是独立的，因此模拟的增量也是独立的，这与底层布朗运动的独立增量性质完全匹配。对我们的迭代步骤求和便可证实这一点：\n$$X_{t_n} = X_{t_0} + \\sum_{i=1}^{n} (\\mu \\Delta t_i + \\sigma \\sqrt{\\Delta t_i} Z_i) = x_0 + \\mu \\sum_{i=1}^{n} \\Delta t_i + \\sigma \\sum_{i=1}^{n} (W_{t_i} - W_{t_{i-1}})$$\n由于 $\\sum \\Delta t_i = t_n - t_0 = T$ 且 $\\sum(W_{t_i} - W_{t_{i-1}}) = W_{t_n} - W_{t_0} = W_T$ 是伸缩求和，该式恢复了终端时间的精确解 $X_T = x_0 + \\mu T + \\sigma W_T$，从而证明了终端值（并可引申至整个路径）具有正确的分布。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an exact simulation scheme for Brownian motion with drift.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x0\": 1.2, \"mu\": -0.3, \"sigma\": 0.7,\n            \"t_grid\": [0.0, 0.1, 0.5, 1.0],\n            \"seed\": 20231011\n        },\n        {\n            \"x0\": 0.0, \"mu\": 2.5, \"sigma\": 0.0,\n            \"t_grid\": [0.0, 0.3, 0.7, 1.0],\n            \"seed\": 777\n        },\n        {\n            \"x0\": -3.0, \"mu\": 0.0, \"sigma\": 2.0,\n            \"t_grid\": [0.0, 0.25, 0.5, 0.9, 1.3],\n            \"seed\": 12345\n        },\n        {\n            \"x0\": 0.5, \"mu\": 1e-9, \"sigma\": 1.0,\n            \"t_grid\": [0.0, 1e-6, 2e-6, 1e-4, 3e-4],\n            \"seed\": 98765\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x0 = case[\"x0\"]\n        mu = case[\"mu\"]\n        sigma = case[\"sigma\"]\n        t_grid = case[\"t_grid\"]\n        seed = case[\"seed\"]\n\n        # Initialize the pseudo-random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Initialize the process value and time.\n        x_current = x0\n        t_prev = t_grid[0]\n\n        # Iterate through the time grid to simulate the path.\n        # The first time point t_grid[0] is the initial condition.\n        for t_current in t_grid[1:]:\n            # Calculate the time step.\n            dt = t_current - t_prev\n            \n            # Generate an independent draw from the standard normal distribution N(0, 1).\n            z = rng.normal(0.0, 1.0)\n            \n            # Apply the exact update formula:\n            # X_t = X_{t-1} + mu * dt + sigma * sqrt(dt) * Z\n            # The stochastic component is sigma * dW, where dW ~ N(0, dt).\n            # This is equivalent to sigma * sqrt(dt) * Z, where Z ~ N(0, 1).\n            drift_term = mu * dt\n            stochastic_term = sigma * np.sqrt(dt) * z\n            \n            x_current += drift_term + stochastic_term\n            \n            # Update the previous time for the next iteration.\n            t_prev = t_current\n\n        # After the loop, x_current holds the terminal value X_T.\n        # Round the final result to 10 decimal places as required.\n        terminal_value = round(x_current, 10)\n        results.append(terminal_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2970492"}]}