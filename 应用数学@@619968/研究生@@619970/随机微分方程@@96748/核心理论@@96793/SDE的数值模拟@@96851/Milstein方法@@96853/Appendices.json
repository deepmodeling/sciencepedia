{"hands_on_practices": [{"introduction": "米尔斯坦方法的核心在于其修正项，该修正项将强收敛阶数提升至超越了更简单的欧拉-丸山格式。本练习将引导你探索一个基础情景：加性噪声下的随机微分方程。通过从第一性原理出发推导该数值格式，你将证明在这种特殊情况下，米尔斯坦修正项会消失，从而深刻理解其威力主要针对乘性噪声过程而释放 [@problem_id:3002576]。", "problem": "考虑标量随机微分方程（SDE）的 Itô 形式\n$$\ndX_t = a(X_t,t)\\,dt + b(X_t,t)\\,dW_t,\n$$\n其中 $a$ 和 $b$ 足够光滑以支持 Itô-Taylor 展开，而 $W_t$ 是一个标准维纳过程。假设为加性噪声情况 $b(x,t)=\\sigma(t)$，其中 $\\sigma$ 是一个具有适当正则性的确定性函数。仅使用 Itô 过程的基本结果（即 Itô 公式和截至可产生一阶强收敛格式项的随机 Taylor 展开），推导通过匹配所有为达到一阶强收敛所必需的项而得到的单步方法。特别地，严格证明当 $b(x,t)=\\sigma(t)$ 时，涉及扩散系数空间导数的乘性噪声校正项为零，并得出从 $t_n$ 到 $t_{n+1}=t_n+h$、步长为 $h>0$ 的离散时间更新结果。\n\n然后，讨论相对于一般的乘性噪声情况，加性噪声结构对所得方法的强收敛阶和弱收敛阶的影响，解释在标准 Lipschitz 条件和线性增长条件下，收敛阶在均方和分布意义上受影响的机制。\n\n请提供 $X_{n+1}$ 关于 $X_n$、$a$、$\\sigma$、$h$ 和 $\\Delta W_n:=W_{t_{n+1}}-W_{t_n}$ 的单步更新的闭式解析表达式作为最终答案。最终答案中不要包含等号或解释性文字。", "solution": "该问题要求从 Itô-Taylor 展开的一般原理出发，为具有加性噪声的标量随机微分方程（SDE）推导一个 $1.0$ 阶强收敛的数值方法。该 SDE 由下式给出：\n$$\ndX_t = a(X_t,t)\\,dt + b(X_t,t)\\,dW_t\n$$\n附加特定条件为加性噪声，其中扩散系数 $b(x,t)$ 与状态变量 $x$ 无关，即 $b(x,t) = \\sigma(t)$。\n\n首先，我们推导能达到 $1.0$ 阶强收敛的一般单步格式，即 Milstein 方法。我们从解在时间步 $[t_n, t_{n+1}]$（大小为 $h = t_{n+1} - t_n$）上的精确积分表示开始：\n$$\nX_{t_{n+1}} = X_{t_n} + \\int_{t_n}^{t_{n+1}} a(X_s, s)\\,ds + \\int_{t_n}^{t_{n+1}} b(X_s, s)\\,dW_s\n$$\n为了构造一个数值格式，我们对积分进行近似。最简单的近似方法是假设被积函数在区间上为常数，取其在区间起点 $t_n$ 的值，这便导出了 Euler-Maruyama 方法。\n漂移项积分近似为：\n$$\n\\int_{t_n}^{t_{n+1}} a(X_s, s)\\,ds \\approx a(X_{t_n}, t_n) \\int_{t_n}^{t_{n+1}} ds = a(X_{t_n}, t_n)h\n$$\n随机积分近似为：\n$$\n\\int_{t_n}^{t_{n+1}} b(X_s, s)\\,dW_s \\approx b(X_{t_n}, t_n) \\int_{t_n}^{t_{n+1}} dW_s = b(X_{t_n}, t_n)\\Delta W_n\n$$\n其中 $\\Delta W_n = W_{t_{n+1}} - W_{t_n}$。得到的 Euler-Maruyama 格式为：\n$$\nX_{n+1} = X_n + a(X_n, t_n)h + b(X_n, t_n)\\Delta W_n\n$$\n这里，我们使用记号 $X_n = X_{t_n}$。在一般的乘性噪声情况下，该格式的强收敛阶为 $0.5$。\n\n为达到 $1.0$ 阶强收敛，需要对随机积分进行更精确的近似。这可以通过对被积函数 $b(X_s, s)$ 在点 $(X_{t_n}, t_n)$ 附近进行 Itô-Taylor 展开来实现。对 $b(X_t, t)$ 使用 Itô 公式，其微分为：\n$$\ndb(X_t, t) = \\left( \\frac{\\partial b}{\\partial t} + a \\frac{\\partial b}{\\partial x} + \\frac{1}{2} b^2 \\frac{\\partial^2 b}{\\partial x^2} \\right) dt + b \\frac{\\partial b}{\\partial x} dW_t\n$$\n对于 $s \\in [t_n, t_{n+1}]$，我们可以将 $b(X_s, s)$ 写成积分形式：\n$$\nb(X_s, s) = b(X_{t_n}, t_n) + \\int_{t_n}^s \\dots du + \\int_{t_n}^s b(X_u, u) \\frac{\\partial b}{\\partial x}(X_u, u) dW_u\n$$\n将此式代入 $X_{t_{n+1}}$ 的随机积分中，并仅保留达到 $1.0$ 阶强收敛所必需的项，我们将内部被积函数 $b(X_u, u) \\frac{\\partial b}{\\partial x}(X_u, u)$ 用其在 $t_n$ 处的值来近似：\n$$\n\\int_{t_n}^{t_{n+1}} b(X_s, s)\\,dW_s \\approx \\int_{t_n}^{t_{n+1}} \\left( b(X_{t_n}, t_n) + b(X_{t_n}, t_n) \\frac{\\partial b}{\\partial x}(X_{t_n}, t_n) \\int_{t_n}^s dW_u \\right) dW_s\n$$\n这给出：\n$$\n\\int_{t_n}^{t_{n+1}} b(X_s, s)\\,dW_s \\approx b(X_n, t_n)\\int_{t_n}^{t_{n+1}}dW_s + b(X_n, t_n)\\frac{\\partial b}{\\partial x}(X_n, t_n) \\int_{t_n}^{t_{n+1}}\\int_{t_n}^s dW_u dW_s\n$$\n第一项是 $b(X_n, t_n)\\Delta W_n$。第二项涉及一个双重 Itô 积分，其计算结果为：\n$$\n\\int_{t_n}^{t_{n+1}}\\int_{t_n}^s dW_u dW_s = \\int_{t_n}^{t_{n+1}} (W_s - W_{t_n}) dW_s = \\frac{1}{2}((W_{t_{n+1}} - W_{t_n})^2 - (t_{n+1}-t_n)) = \\frac{1}{2}((\\Delta W_n)^2 - h)\n$$\n综合这些结果，得到的单步更新，即 Milstein 方法，是：\n$$\nX_{n+1} = X_n + a(X_n, t_n)h + b(X_n, t_n)\\Delta W_n + \\frac{1}{2}b(X_n, t_n)\\frac{\\partial b}{\\partial x}(X_n, t_n)((\\Delta W_n)^2 - h)\n$$\n在 $a$ 和 $b$ 及其导数满足足够的光滑性和有界性条件下，该格式对于一般 SDE 能达到 $1.0$ 阶强收敛。\n\n现在，我们施加问题中的加性噪声条件：$b(x,t) = \\sigma(t)$。由于 $\\sigma(t)$ 是一个关于时间的确定性函数，它不依赖于状态变量 $x$。因此，它关于 $x$ 的偏导数为零：\n$$\n\\frac{\\partial b}{\\partial x}(x, t) = \\frac{\\partial \\sigma(t)}{\\partial x} = 0\n$$\n将此结果代入一般的 Milstein 格式，代表对 Euler-Maruyama 方法的校正的最后一项恒为零：\n$$\n\\frac{1}{2}b(X_n, t_n)\\frac{\\partial b}{\\partial x}(X_n, t_n)((\\Delta W_n)^2 - h) = \\frac{1}{2}\\sigma(t_n) \\cdot 0 \\cdot ((\\Delta W_n)^2 - h) = 0\n$$\n因此，对于具有加性噪声的 SDE，Milstein 方法简化为：\n$$\nX_{n+1} = X_n + a(X_n, t_n)h + \\sigma(t_n)\\Delta W_n\n$$\n这个更新公式在形式上与 Euler-Maruyama 方法完全相同。\n\n最后，我们讨论加性噪声结构对收敛阶的影响。\n强收敛关心的是路径近似的均方误差，$E[|X_T - X_N|]$。对于带乘性噪声的一般 SDE，Euler-Maruyama 格式的强收敛阶是 $0.5$。Milstein 格式正是通过包含与 $((\\Delta W_n)^2 - h)$ 成比例的项来达到 $1.0$ 阶强收敛的。对于具有加性噪声的 SDE，这个校正项为零。这意味着形式上为 Euler-Maruyama 的格式已经包含了达到 $1.0$ 阶强收敛所需的所有项。在一般情况下将 Euler-Maruyama 格式的收敛阶限制在 $0.5$ 的主要误差来源，在噪声是加性时是不存在的。因此，方法 $X_{n+1} = X_n + a_n h + \\sigma_n \\Delta W_n$ 对于加性噪声SDE具有 $1.0$ 的强收敛阶，这是对一般情况的改进。\n\n弱收敛关心的是解的矩的近似误差， $|E[f(X_T)]-E[f(X_N)]|$。对于一般的 SDE，Euler-Maruyama 格式的弱收敛阶为 $1.0$。Milstein 校正项 $\\frac{1}{2}b b_x ((\\Delta W_n)^2 - h)$ 的期望为零，因为 $E[(\\Delta W_n)^2] = h$。因此，将此项添加到 Euler-Maruyama 格式中并不能提高其弱收敛阶，它仍然是 $1.0$。要达到更高的弱收敛阶（例如 $2.0$），必须包含 Itô-Taylor 展开中的其他项。由于加性噪声结构 ($b_x=0$) 只影响一个与一阶弱误差无关的项，因此简化方法的弱收敛阶仍然是 $1.0$，就像 Euler-Maruyama 方法在一般乘性噪声情况下的弱收敛阶一样。因此，与强收敛不同，加性噪声结构对这一特定格式的弱收敛阶没有任何助益。\n\n总而言之，对于具有加性噪声的 SDE，为达到 $1.0$ 阶强收敛所需的 Milstein 方法，简化为了计算成本低得多的 Euler-Maruyama 格式。\n\n得到的 $X_{n+1}$ 的单步更新为：\n$X_{n+1} = X_n + a(X_n, t_n)h + \\sigma(t_n)\\Delta W_n$。", "answer": "$$\n\\boxed{X_n + a(X_n, t_n)h + \\sigma(t_n)\\Delta W_n}\n$$", "id": "3002576"}, {"introduction": "在理解了*何时*需要米尔斯坦方法之后，我们转向一个实际应用：著名的 Cox-Ingersoll-Ross (CIR) 模型，它是金融建模的基石。这个动手编程练习将挑战你为这个乘性噪声过程实现米尔斯坦格式，并研究一个关键的实际问题：非负性的保持。你会发现，尽管具有更高阶的精度，标准的显式米尔斯坦方法可能无法遵守这一基本的模型边界，这是数值模拟中一个至关重要的教训 [@problem_id:3002529]。", "problem": "考虑 Cox–Ingersoll–Ross 过程，这是一个模拟非负扩散的一维随机微分方程 (SDE)，其定义为 $dX_t = \\kappa(\\theta - X_t)\\,dt + \\sigma\\sqrt{X_t}\\,dW_t$，其中参数 $\\kappa > 0$、$\\theta > 0$ 和 $\\sigma > 0$。在文献中标准的条件下，该过程存在唯一的强解，并且该解保持非负。您的任务是研究显式 Milstein 方法应用于此 SDE 时，是否能保持数值解的非负性。\n\n从 SDE 的 Itô 微积分的第一性原理和达到强一阶的 Itô–Taylor 展开出发，推导针对一般标量 SDE $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的 Milstein 方法的单步显式离散格式，然后将其特化到 Cox–Ingersoll–Ross 模型。使用基本定义和 Itô 公式进行所需阶数的展开，并清晰地陈述所有假设。基于此推导，分析该方法是否能保证在所有离散时间点 $t_n$ 上 $X_n \\ge 0$，并根据漂移项和扩散项系数的结构以及随机增量来解释任何对非负性的违反。\n\n实现一个程序，使用推导出的显式 Milstein 方法为指定的参数集模拟独立的样本路径。对于每个测试案例，在 $[0,T]$ 区间上使用均匀时间步长 $h$ 模拟 $N_{\\text{paths}}$ 条独立路径，并计算在模拟期间任一时刻达到负值（严格小于 0）的路径所占的比例。一旦某条路径首次变为负值，其后应一直被计为负值；不要应用任何修正性修改（如投影、截断或反射）来强制非负性。\n\n程序必须：\n- 使用从第一性原理推导并特化到 Cox–Ingersoll–Ross 模型的显式 Milstein 离散格式。\n- 使用固定的随机数生成器种子以确保可复现性。在程序开始时用种子 $2025$ 初始化一个生成器，并将其用于所有随机过程。\n- 为提高效率，对跨路径的计算进行向量化，并在边界处谨慎处理平方根项：该项为 $X_n \\ge 0$ 定义，并且格式不得尝试对 $X_n < 0$ 的情况计算 $\\sqrt{X_n}$。\n- 对于每条路径，一旦出现 $X_n < 0$，则将该路径标记为负值并停止对其的后续更新；其后的步骤应保持其值不变，并且该路径应保持被标记为负值。\n\n使用以下参数值测试套件，旨在探究正性的不同方面：\n- 案例 A（强均值回归和中等波动率的一般情况）：$\\kappa = 3.0$，$ \\theta = 1.0$，$ \\sigma = 1.0$，$ X_0 = 1.0$，$ h = 0.005$，$ T = 1.0$，$ N_{\\text{paths}} = 5000$。\n- 案例 B（更粗的时间步长以测试离散化误差的影响）：$\\kappa = 3.0$，$ \\theta = 1.0$，$ \\sigma = 1.0$，$ X_0 = 1.0$，$ h = 0.02$，$ T = 1.0$，$ N_{\\text{paths}} = 5000$。\n- 案例 C（Feller 条件 $2\\kappa\\theta = \\sigma^2$ 的边界情况）：$\\kappa = 2.0$，$ \\theta = 1.0$，$ \\sigma = 2.0$，$ X_0 = 1.0$，$ h = 0.005$，$ T = 1.0$，$ N_{\\text{paths}} = 5000$。\n- 案例 D（接近零的初始状态）：$\\kappa = 3.0$，$ \\theta = 1.0$，$ \\sigma = 1.0$，$ X_0 = 10^{-6}$，$ h = 0.005$，$ T = 1.0$，$ N_{\\text{paths}} = 5000$。\n\n所有量均为无量纲，因此不需要物理单位。每个案例的输出必须是一个浮点数，等于曾经变为负值的路径所占的比例，四舍五入到六位小数。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[resultA,resultB,resultC,resultD]\"），其中每个条目分别对应案例 A、B、C 和 D 的结果，四舍五入到六位小数。例如，如果比例为 $0.012345$、$0.067890$、$0.000000$ 和 $0.123456$，程序必须打印 \"[0.012345,0.067890,0.000000,0.123456]\"。", "solution": "该问题被评估为有效。它在随机微分方程和数值方法的理论上具有科学依据，是适定的，具有一套完整且一致的参数，并使用客观、规范的语言。它代表了计算金融和随机分析领域中的一个非平凡的练习。\n\n### 显式 Milstein 方法的推导\n\n我们从一个一般的一维 Itô 随机微分方程 (SDE) 开始：\n$$\ndX_t = a(X_t) \\, dt + b(X_t) \\, dW_t\n$$\n其中 $a(X_t)$ 是漂移系数，$b(X_t)$ 是扩散系数，$W_t$ 是一个标准维纳过程。目标是给定 $X_{t_n}$，推导出一个计算 $X_{t_{n+1}}$ 的数值格式，其中 $t_{n+1} = t_n + h$，步长 $h > 0$ 很小。\n\nSDE 在区间 $[t_n, t_{n+1}]$ 上的积分形式为：\n$$\nX_{t_{n+1}} = X_{t_n} + \\int_{t_n}^{t_{n+1}} a(X_s) \\, ds + \\int_{t_n}^{t_{n+1}} b(X_s) \\, dW_s\n$$\nMilstein 方法通过更精确地近似随机积分来改进 Euler-Maruyama 方法。漂移积分的近似与 Euler 方法中相同：\n$$\n\\int_{t_n}^{t_{n+1}} a(X_s) \\, ds \\approx a(X_{t_n}) h\n$$\n对于随机积分，我们首先对被积函数 $b(X_s)$ 在 $t_n$ 点进行 Itô-Taylor 展开。对函数 $b(x)$ 使用 Itô 公式，我们有：\n$$\nb(X_s) = b(X_{t_n}) + \\int_{t_n}^s L^0 b(X_u) \\, du + \\int_{t_n}^s L^1 b(X_u) \\, dW_u\n$$\n其中 $L^0 = a(x)\\frac{\\partial}{\\partial x} + \\frac{1}{2}b(x)^2\\frac{\\partial^2}{\\partial x^2}$ 和 $L^1 = b(x)\\frac{\\partial}{\\partial x}$ 是生成元算子。对于一个强 1.0 阶格式，我们可以用在 $t_n$ 处的值来近似 $b(X_s)$ 展开式中的被积函数。\n$$\nb(X_s) \\approx b(X_{t_n}) + L^1 b(X_{t_n}) \\int_{t_n}^s dW_u = b(X_{t_n}) + b(X_{t_n}) b'(X_{t_n}) (W_s - W_{t_n})\n$$\n将此近似代入随机积分中：\n$$\n\\int_{t_n}^{t_{n+1}} b(X_s) \\, dW_s \\approx \\int_{t_n}^{t_{n+1}} \\left[ b(X_{t_n}) + b(X_{t_n}) b'(X_{t_n}) (W_s - W_{t_n}) \\right] \\, dW_s\n$$\n$$\n= b(X_{t_n}) \\int_{t_n}^{t_{n+1}} dW_s + b(X_{t_n}) b'(X_{t_n}) \\int_{t_n}^{t_{n+1}} (W_s - W_{t_n}) \\, dW_s\n$$\n第一个积分是维纳增量，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$。第二个是标准的双重 Itô 积分，其值是已知的：\n$$\n\\int_{t_n}^{t_{n+1}} (W_s - W_{t_n}) \\, dW_s = \\frac{1}{2} \\left[ (W_{t_{n+1}} - W_{t_n})^2 - (t_{n+1} - t_n) \\right] = \\frac{1}{2} \\left[ (\\Delta W_n)^2 - h \\right]\n$$\n结合这些项，我们得到单步显式 Milstein 离散格式，使用记号 $X_n = X_{t_n}$：\n$$\nX_{n+1} = X_n + a(X_n)h + b(X_n)\\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left[ (\\Delta W_n)^2 - h \\right]\n$$\n\n### 针对 Cox–Ingersoll–Ross (CIR) 模型的特化\n\nCIR 过程由以下 SDE 定义：\n$$\ndX_t = \\kappa(\\theta - X_t) \\, dt + \\sigma\\sqrt{X_t} \\, dW_t\n$$\n与一般 SDE 形式比较，我们确定其系数：\n$$\na(x) = \\kappa(\\theta - x)\n$$\n$$\nb(x) = \\sigma\\sqrt{x} = \\sigma x^{1/2}\n$$\n扩散系数的导数（对于 $x > 0$）为：\n$$\nb'(x) = \\frac{d}{dx}(\\sigma x^{1/2}) = \\frac{1}{2}\\sigma x^{-1/2} = \\frac{\\sigma}{2\\sqrt{x}}\n$$\nCIR Milstein 格式的一个关键特性是 $b(x)b'(x)$ 的乘积是一个常数：\n$$\nb(x)b'(x) = (\\sigma\\sqrt{x}) \\left(\\frac{\\sigma}{2\\sqrt{x}}\\right) = \\frac{\\sigma^2}{2}\n$$\n将这些系数代入通用的 Milstein 公式中，我们得到 CIR 模型的格式：\n$$\nX_{n+1} = X_n + \\kappa(\\theta - X_n)h + \\sigma\\sqrt{X_n}\\Delta W_n + \\frac{1}{2}\\left(\\frac{\\sigma^2}{2}\\right)\\left[ (\\Delta W_n)^2 - h \\right]\n$$\n为实现此格式，我们利用 $\\Delta W_n \\sim \\mathcal{N}(0, h)$ 的性质，因此可以写成 $\\Delta W_n = \\sqrt{h}Z_n$，其中 $Z_n \\sim \\mathcal{N}(0, 1)$。这使得 $(\\Delta W_n)^2 = h Z_n^2$。最终的格式为：\n$$\nX_{n+1} = X_n + \\kappa(\\theta - X_n)h + \\sigma\\sqrt{X_n h}Z_n + \\frac{\\sigma^2}{4}\\left[ h Z_n^2 - h \\right]\n$$\n$$\nX_{n+1} = X_n + \\kappa(\\theta - X_n)h + \\sigma\\sqrt{X_n h}Z_n + \\frac{\\sigma^2 h}{4}(Z_n^2 - 1)\n$$\n这就是将要实现的 CIR 过程的显式 Milstein 离散格式。\n\n### 非负性保持的分析\n\n如果满足 Feller 条件 $2\\kappa\\theta \\geq \\sigma^2$，则 CIR SDE 的真实解保证是非负的。我们现在分析数值格式是否保持此性质。\n我们可以将 $X_{n+1}$ 的表达式重新整理为标准正态随机变量 $Z_n$ 的二次函数：\n$$\nX_{n+1} = \\left(\\frac{\\sigma^2 h}{4}\\right)Z_n^2 + \\left(\\sigma\\sqrt{X_n h}\\right)Z_n + \\left(X_n + \\kappa(\\theta - X_n)h - \\frac{\\sigma^2 h}{4}\\right)\n$$\n这是一个关于 $Z_n$ 的抛物线，形式为 $AZ_n^2 + BZ_n + C$，其中 $A = \\frac{\\sigma^2 h}{4} > 0$。由于抛物线开口向上，仅当其最小值是负数时，才可能取到负值。抛物线的最小值在 $Z_n^* = -B/(2A)$ 处取得，最小值为 $X_{n+1}^{\\text{min}} = C - B^2/(4A)$。\n\n让我们计算这个最小值。\n- $B^2 = (\\sigma\\sqrt{X_n h})^2 = \\sigma^2 X_n h$\n- $4A = 4 \\left(\\frac{\\sigma^2 h}{4}\\right) = \\sigma^2 h$\n- $\\frac{B^2}{4A} = \\frac{\\sigma^2 X_n h}{\\sigma^2 h} = X_n$\n- $C = X_n(1 - \\kappa h) + \\kappa\\theta h - \\frac{\\sigma^2 h}{4}$\n\n最小值为：\n$$\nX_{n+1}^{\\text{min}} = C - X_n = \\left(X_n(1 - \\kappa h) + \\kappa\\theta h - \\frac{\\sigma^2 h}{4}\\right) - X_n = -\\kappa h X_n + \\kappa\\theta h - \\frac{\\sigma^2 h}{4}\n$$\n$$\nX_{n+1}^{\\text{min}} = h \\left( \\kappa\\theta - \\frac{\\sigma^2}{4} - \\kappa X_n \\right)\n$$\n如果这个最小值是负的，数值解 $X_{n+1}$ 就可以变为负值。由于 $h > 0$，如果以下条件成立，则可能出现负值：\n$$\n\\kappa\\theta - \\frac{\\sigma^2}{4} - \\kappa X_n < 0 \\quad \\iff \\quad X_n > \\theta - \\frac{\\sigma^2}{4\\kappa}\n$$\n这个条件揭示了，对于任何一组参数 $(\\kappa, \\theta, \\sigma, h)$ 以及足够大的当前状态值 $X_n$，存在一个非零的概率（与随机变量 $Z_n$ 取到接近 $Z_n^*$ 的值相关联），使得下一状态 $X_{n+1}$ 为负。例如，在案例 A 中，该不等式变为 $X_n > 1 - 1/12 \\approx 0.9167$。由于过程从 $X_0 = 1.0$ 开始，它立即处于一个可能出现负值的区域。\n\n即使 $4\\kappa\\theta > \\sigma^2$，从而保证原点对于小的 $X_n$ 是排斥的（即对于小的 $X_n$，$X_{n+1}^{\\text{min}} > 0$），过程的均值回归性质也会将 $X_t$ 推向 $\\theta$。如果 $\\theta$ 位于“可能为负”的区域（即 $\\theta > \\theta - \\frac{\\sigma^2}{4\\kappa}$，这总是成立的），过程将在此区域花费时间，使其暴露于因大的随机冲击而变为负值的风险中。\n\n因此，显式 Milstein 方法通常不保持 CIR 过程的非负性。这种违反是该格式的一个结构性属性，其中二次修正项不足以抵消所有可能状态和随机冲击下扩散项产生的大负值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the explicit Milstein method for the Cox-Ingersoll-Ross (CIR) process\n    to determine the fraction of paths that become negative.\n    \"\"\"\n    # Set the global seed for the random number generator for reproducibility.\n    # A single generator is initialized and used for all simulations.\n    rng = np.random.default_rng(seed=2025)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General case with strong mean reversion and moderate volatility\n        {'label': 'A', 'kappa': 3.0, 'theta': 1.0, 'sigma': 1.0, 'X0': 1.0, 'h': 0.005, 'T': 1.0, 'N_paths': 5000},\n        # Case B: Coarser time step to test discretization error impact\n        {'label': 'B', 'kappa': 3.0, 'theta': 1.0, 'sigma': 1.0, 'X0': 1.0, 'h': 0.02, 'T': 1.0, 'N_paths': 5000},\n        # Case C: Boundary of the Feller condition 2*kappa*theta = sigma^2\n        {'label': 'C', 'kappa': 2.0, 'theta': 1.0, 'sigma': 2.0, 'X0': 1.0, 'h': 0.005, 'T': 1.0, 'N_paths': 5000},\n        # Case D: Near-zero initial state\n        {'label': 'D', 'kappa': 3.0, 'theta': 1.0, 'sigma': 1.0, 'X0': 1e-6, 'h': 0.005, 'T': 1.0, 'N_paths': 5000},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current simulation\n        kappa = case['kappa']\n        theta = case['theta']\n        sigma = case['sigma']\n        X0 = case['X0']\n        h = case['h']\n        T = case['T']\n        N_paths = case['N_paths']\n\n        num_steps = int(T / h)\n        \n        # Initialize all paths to the starting value X0\n        X = np.full(N_paths, X0, dtype=np.float64)\n        \n        # Boolean array to track paths that have ever become negative.\n        # Once a path is marked, it ceases to be updated.\n        is_negative = np.zeros(N_paths, dtype=bool)\n\n        # Pre-compute constants for efficiency\n        sqrt_h = np.sqrt(h)\n        sigma2_h_4 = 0.25 * sigma**2 * h\n        kappa_theta_h = kappa * theta * h\n        kappa_h = kappa * h\n\n        for _ in range(num_steps):\n            # A mask to select active paths (those that have not yet turned negative)\n            active_mask = ~is_negative\n            \n            # Optimization: if all paths have turned negative, we can exit the loop\n            if not np.any(active_mask):\n                break\n\n            num_active = np.sum(active_mask)\n            \n            # Current state values for only the active paths\n            X_n = X[active_mask]\n\n            # Generate standard normal random increments for active paths\n            Z = rng.standard_normal(size=num_active)\n\n            # Apply the explicit Milstein method for the CIR process:\n            # X_{n+1} = X_n + kappa*(theta - X_n)*h + sigma*sqrt(X_n)*sqrt(h)*Z + 0.25*sigma^2*h*(Z^2 - 1)\n            # The sqrt(X_n) is safe because X_n >= 0 for all active paths.\n            term_drift = kappa_theta_h - X_n * kappa_h\n            term_diffusion = sigma * np.sqrt(X_n) * sqrt_h * Z\n            term_milstein = sigma2_h_4 * (Z**2 - 1)\n            \n            X_next = X_n + term_drift + term_diffusion + term_milstein\n\n            # Update the state of the active paths in the main state array\n            X[active_mask] = X_next\n\n            # Identify any of the just-updated paths that have now become negative.\n            # Update the master 'is_negative' tracker accordingly for these paths.\n            is_negative[active_mask] = (X_next  0)\n            \n        # After the simulation, compute the fraction of paths that ever became negative\n        fraction_negative = np.mean(is_negative)\n        results.append(fraction_negative)\n\n    # Format the final output string as a comma-separated list in brackets,\n    # with each result rounded to six decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3002529"}, {"introduction": "固定步长求解器可能效率低下，在平滑区域采用不必要的小步长，而在动态剧烈变化的区域则可能采用危险的大步长。本练习将引导你构建一个更智能的求解器，运用自适应步长控制这一现代科学计算中的标准技术。你将利用欧拉-丸山和米尔斯坦两种格式更新值的差异作为局部误差估计，创建一个能够自动调整步长以优化精度和计算效率的控制器 [@problem_id:3002532]。", "problem": "考虑一个标量 Itō 随机微分方程 (SDE)，其形式为 $\\,\\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t\\,$，其中 $\\,W_t\\,$ 是一个标准布朗运动。从 Itō SDE 的定义、Itō–Taylor 展开以及在时间步长 $\\,h0\\,$ 上的布朗运动增量 $\\,\\Delta W \\sim \\mathcal{N}(0,h)\\,$ 的性质出发，设计一个嵌入式误差估计器的蓝图，该估计器通过比较单步 Euler–Maruyama (EM) 更新和 Milstein 更新，来产生一个接受决策和一个建议的下一时间步长。\n\n您的程序必须为单个试探步实现以下概念性流程：\n- 给定函数 $\\,a(x)\\,$、$\\,b(x)\\,$ 以及关于 $\\,x\\,$ 的导数 $\\,b'(x)\\,$，根据各自方法适用的 Itō–Taylor 展开原理，构建单步 Euler–Maruyama 更新和单步 Milstein 更新。\n- 将误差估计器定义为在相同状态 $\\,x\\,$ 和相同增量 $\\,\\Delta W\\,$ 下两个单步更新之间的绝对差。\n- 使用混合的绝对-相对容差对误差进行缩放，以形成一个无量纲的误差度量 $\\,\\varepsilon\\,$：\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert y_{\\text{Milstein}} - y_{\\text{EM}} \\rvert}{a_{\\text{tol}} + r_{\\text{tol}}\\,\\lvert y_{\\text{Milstein}} \\rvert},\n$$\n其中 $\\,a_{\\text{tol}}0\\,$ 是一个绝对容差，$\\,r_{\\text{tol}}\\ge 0\\,$ 是一个相对容差。\n- 接受准则：如果 $\\,\\varepsilon \\le 1\\,$，则宣布该试探步被接受，否则被拒绝。\n- 步长自适应：设 $\\,p\\,$ 为用于推进解的已接受方法的强收敛阶（对于标量交换噪声的 Milstein 方法，取 $\\,p=1\\,$）。提出一个新的步长\n$$\nh_{\\text{new}} \\;=\\; h \\,\\cdot\\, \\operatorname{clip}\\!\\left(\\gamma \\,\\varepsilon^{-1/p},\\, \\mathrm{fac}_{\\min},\\, \\mathrm{fac}_{\\max}\\right),\n$$\n其中 $\\,\\gamma\\in(0,1)\\,$ 是一个安全因子，$\\,\\operatorname{clip}(u, L, U) = \\min\\{\\max\\{u,L\\},U\\}\\,$ 将乘法变化限制在 $\\,\\mathrm{fac}_{\\min}\\,$ 和 $\\,\\mathrm{fac}_{\\max}\\,$ 之间。\n\n为特定的方程族 $\\,a(x) = \\alpha x\\,$ 和 $\\,b(x) = \\beta x\\,$（其中 $\\,\\alpha\\,$ 和 $\\,\\beta\\,$ 为常数）实现上述过程。使用以下测试套件，其中每个案例指定了 $\\,(\\alpha, \\beta, x, h, a_{\\text{tol}}, r_{\\text{tol}}, \\gamma, \\mathrm{fac}_{\\min}, \\mathrm{fac}_{\\max}, z)\\,$，并且布朗增量由 $\\,\\Delta W = \\sqrt{h}\\,z\\,$ 确定性地给出：\n\n- 案例 1 (理想路径，中等噪声)：$\\,(0.5,\\,0.2,\\,1.0,\\,0.05,\\,10^{-3},\\,10^{-2},\\,0.9,\\,0.2,\\,5.0,\\,0.1)\\,$。\n- 案例 2 (边界情况，大扩散和增量)：$\\,(0.1,\\,2.5,\\,1.0,\\,0.05,\\,10^{-3},\\,10^{-2},\\,0.9,\\,0.2,\\,5.0,\\,3.0)\\,$。\n- 案例 3 (边界情况，极小状态和步长)：$\\,(0.1,\\,0.8,\\,10^{-6},\\,10^{-4},\\,10^{-8},\\,10^{-1},\\,0.9,\\,0.2,\\,5.0,\\,0.3)\\,$。\n- 案例 4 (压力情况，大步长伴随负增量)：$\\,(0.1,\\,1.0,\\,1.0,\\,0.5,\\,10^{-4},\\,10^{-3},\\,0.8,\\,0.2,\\,5.0,\\,-1.0)\\,$。\n\n您的程序应为每个案例计算：\n- 接受决策，接受时编码为 $\\,1\\,$，拒绝时编码为 $\\,0\\,$，\n- 建议的下一时间步长 $\\,h_{\\text{new}}\\,$，\n- 无量纲的误差度量 $\\,\\varepsilon\\,$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由四个列表组成的逗号分隔列表，每个测试案例对应一个列表，每个内部列表的格式为 $[ \\text{accept}, h_{\\text{new}}, \\varepsilon ]$。例如，形如 $[[1,0.0623,0.54],[0,0.01,2.3],[\\dots],[\\dots]]$ 的一行。", "solution": "所提出的问题是有效的。它在科学上基于随机微分方程 (SDE) 数值方法的成熟理论，特别是 Itō-Taylor 展开以及由此产生的 Euler-Maruyama 和 Milstein 格式。该问题是适定的，提供了所有必需的参数、函数以及维纳增量的确定性设置，确保每个测试案例都有唯一且可验证的解。其语言客观而精确。\n\n我们的任务是为以下形式的标量 Itō SDE 设计并实现一个自适应步长控制机制：\n$$\n\\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t\n$$\n其中 $W_t$ 是一个标准维纳过程（布朗运动）。该自适应策略的核心在于，通过比较一个低阶数值近似与一个高阶数值近似，来估计单步的局部误差。\n\nEuler-Maruyama 和 Milstein 方法的基础都是过程 $X_t$ 在时间 $t_n$ 附近的 Itō-Taylor 展开，它给出了在 $t_{n+1} = t_n + h$ 时的值：\n$$\nX_{n+1} = X_n + a(X_n)h + b(X_n)\\Delta W_n + \\frac{1}{2} b(X_n)b'(X_n) \\left( (\\Delta W_n)^2 - h \\right) + \\mathcal{O}(h^{3/2})\n$$\n在此，$X_n \\equiv X_{t_n}$，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 是在区间 $[t_n, t_{n+1}]$ 上的维纳增量，它是一个服从 $\\mathcal{N}(0, h)$ 分布的随机变量。记号 $b'(x)$ 表示 $b(x)$ 关于其自变量 $x$ 的导数。\n\n从这个展开式中，我们推导出两种不同强收敛阶的数值格式：\n\n1.  **Euler-Maruyama (EM) 格式**：该方法通过在随机积分项之后截断 Itō-Taylor 展开得到。它的强收敛阶为 $0.5$。从状态 $x$ 开始，使用步长 $h$ 和增量 $\\Delta W$ 的单步更新（我们记作 $y_{\\text{EM}}$）是：\n    $$\n    y_{\\text{EM}}(x, h, \\Delta W) = x + a(x)h + b(x)\\Delta W\n    $$\n\n2.  **Milstein 格式**：通过在展开式中包含下一项，我们得到 Milstein 方法。对于标量 SDE（其中噪声总是可交换的），该方法的强收敛阶为 $1.0$。单步更新 $y_{\\text{Milstein}}$ 是：\n    $$\n    y_{\\text{Milstein}}(x, h, \\Delta W) = x + a(x)h + b(x)\\Delta W + \\frac{1}{2}b(x)b'(x)\\left( (\\Delta W)^2 - h \\right)\n    $$\n    我们可以将其简明地表示为 $y_{\\text{Milstein}} = y_{\\text{EM}} + \\frac{1}{2}b(x)b'(x)\\left( (\\Delta W)^2 - h \\right)$。\n\n该问题为几何布朗运动指定了 SDE：\n$$\n\\mathrm{d}X_t = \\alpha X_t\\,\\mathrm{d}t + \\beta X_t\\,\\mathrm{d}W_t\n$$\n由此，我们确定漂移系数、扩散系数以及扩散系数的导数：\n$$\na(x) = \\alpha x, \\quad b(x) = \\beta x, \\quad b'(x) = \\beta\n$$\n\n自适应控制机制采用了一种嵌入式方法，其中高阶 (Milstein) 更新与低阶 (EM) 更新之间的差异可作为低阶方法局部误差的估计。这个误差估计器 $E$ 是：\n$$\nE = \\lvert y_{\\text{Milstein}} - y_{\\text{EM}} \\rvert = \\left\\lvert \\frac{1}{2}b(x)b'(x)\\left( (\\Delta W)^2 - h \\right) \\right\\rvert\n$$\n对于这个特定的 SDE，它变成：\n$$\nE = \\left\\lvert \\frac{1}{2}(\\beta x)(\\beta)\\left( (\\Delta W)^2 - h \\right) \\right\\rvert = \\left\\lvert \\frac{1}{2}\\beta^2 x \\left( (\\Delta W)^2 - h \\right) \\right\\rvert\n$$\n问题将维纳增量确定性地规定为 $\\Delta W = \\sqrt{h}\\,z$，其中 $z$ 是一个给定值。将此代入误差表达式可得到一个更直接的公式：\n$$\nE = \\left\\lvert \\frac{1}{2}\\beta^2 x \\left( (\\sqrt{h}z)^2 - h \\right) \\right\\rvert = \\left\\lvert \\frac{1}{2}\\beta^2 x \\left( h z^2 - h \\right) \\right\\rvert = \\left\\lvert \\frac{1}{2}\\beta^2 x h (z^2-1) \\right\\rvert\n$$\n为做出接受决策，此绝对误差 $E$ 通过一个混合绝对-相对容差准则进行缩放，形成一个无量纲的误差度量 $\\varepsilon$：\n$$\n\\varepsilon = \\frac{E}{a_{\\text{tol}} + r_{\\text{tol}}\\,\\lvert y_{\\text{Milstein}} \\rvert}\n$$\n其中 $a_{\\text{tol}}$ 是绝对容差，$r_{\\text{tol}}$ 是相对容差。解使用更精确的 Milstein 更新 $y_{\\text{Milstein}}$ 来推进。如果 $\\varepsilon \\le 1$，则试探步被接受，否则被拒绝。\n\n最后，根据计算出的误差 $\\varepsilon$ 提出一个新的步长 $h_{\\text{new}}$。该公式源于这样一个原理：对于一个 $p$ 阶方法，误差表现为 $E \\propto h^p$。为达到目标误差，步长应按与 $\\varepsilon^{-1/p}$ 成比例的因子进行调整。指定的公式是：\n$$\nh_{\\text{new}} = h \\cdot \\operatorname{clip}\\!\\left(\\gamma \\,\\varepsilon^{-1/p},\\, \\mathrm{fac}_{\\min},\\, \\mathrm{fac}_{\\max}\\right)\n$$\n此处，$p$ 是被接受方法 (Milstein) 的强阶，因此 $p=1$。安全因子 $\\gamma$ 防止过于乐观的步长增加，而 $\\mathrm{fac}_{\\min}, \\mathrm{fac}_{\\max}$ 则限制变化以保持稳定性。$\\operatorname{clip}(u, L, U)$ 函数将值 $u$ 约束在区间 $[L, U]$ 内。在 $\\varepsilon=0$ 的特殊情况下，$\\varepsilon^{-1/p}$ 项在形式上是无限的；在此背景下的标准解释是，将步长按允许的最大因子 $\\mathrm{fac}_{\\max}$ 进行增加。\n\n单个试探步的算法如下：\n1.  给定参数 $(\\alpha, \\beta, x, h, a_{\\text{tol}}, r_{\\text{tol}}, \\gamma, \\mathrm{fac}_{\\min}, \\mathrm{fac}_{\\max}, z)$。\n2.  计算维纳增量：$\\Delta W = \\sqrt{h}\\,z$。\n3.  直接计算误差估计：$E = |\\frac{1}{2}\\beta^2 x h (z^2-1)|$。\n4.  计算高阶更新：$y_{\\text{Milstein}} = x + \\alpha x h + \\beta x \\Delta W + \\frac{1}{2}\\beta^2 x h (z^2-1)$。\n5.  计算无量纲误差：$\\varepsilon = E / (a_{\\text{tol}} + r_{\\text{tol}}\\,|y_{\\text{Milstein}}|)$。\n6.  确定是否接受：如果 $\\varepsilon \\le 1$，`accept` 为 $1$，否则为 $0$。\n7.  使用 $p=1$ 的自适应公式计算新步长 $h_{\\text{new}}$。如果 $\\varepsilon=0$，则乘法因子为 $\\mathrm{fac}_{\\max}$。\n\n此过程被系统地应用于所提供的每个测试案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive step-size controller for a scalar SDE\n    based on an embedded Euler-Maruyama and Milstein method pair.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (alpha, beta, x, h, a_tol, r_tol, gamma, fac_min, fac_max, z)\n    test_cases = [\n        (0.5, 0.2, 1.0, 0.05, 1e-3, 1e-2, 0.9, 0.2, 5.0, 0.1),\n        (0.1, 2.5, 1.0, 0.05, 1e-3, 1e-2, 0.9, 0.2, 5.0, 3.0),\n        (0.1, 0.8, 1e-6, 1e-4, 1e-8, 1e-1, 0.9, 0.2, 5.0, 0.3),\n        (0.1, 1.0, 1.0, 0.5, 1e-4, 1e-3, 0.8, 0.2, 5.0, -1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, x, h, a_tol, r_tol, gamma, fac_min, fac_max, z = case\n\n        # The strong convergence order of the Milstein method (scalar commutative case)\n        p = 1.0\n\n        # Calculate the deterministic Wiener increment\n        delta_W = np.sqrt(h) * z\n\n        # The term that differentiates Milstein from Euler-Maruyama\n        # This is also the local error estimate before taking the absolute value.\n        # E = |milstein_term|\n        milstein_correction = 0.5 * beta**2 * x * (delta_W**2 - h)\n        # Note: delta_W**2 - h = (sqrt(h)*z)**2 - h = h*z**2 - h = h * (z**2 - 1)\n        # So, milstein_correction = 0.5 * beta**2 * x * h * (z**2 - 1)\n        \n        # Absolute error estimator\n        error_est = np.abs(milstein_correction)\n\n        # Calculate the one-step Euler-Maruyama update\n        y_em = x + alpha * x * h + beta * x * delta_W\n        \n        # Calculate the one-step Milstein update by adding the correction term\n        y_milstein = y_em + milstein_correction\n        \n        # Calculate the dimensionless error metric epsilon\n        # Handle the case where the denominator could be zero, though unlikely with a_tol  0\n        tolerance_scale = a_tol + r_tol * np.abs(y_milstein)\n        if tolerance_scale == 0:\n            # If both error and tolerance are zero, error is controlled.\n            # If error is non-zero and tolerance is zero, error is infinite.\n            epsilon = 0.0 if error_est == 0.0 else np.inf\n        else:\n            epsilon = error_est / tolerance_scale\n\n        # Acceptance criterion\n        accept = 1 if epsilon = 1.0 else 0\n\n        # Step-size adaptation\n        if epsilon == 0.0:\n            # If error is zero, increase step size by the maximum factor\n            scaling_factor = fac_max\n        else:\n            # Standard PI controller-based step size adaptation\n            raw_scaling_factor = gamma * (epsilon**(-1.0 / p))\n            scaling_factor = np.clip(raw_scaling_factor, fac_min, fac_max)\n        \n        h_new = h * scaling_factor\n\n        results.append([accept, h_new, epsilon])\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation and join with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3002532"}]}