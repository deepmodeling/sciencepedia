{"hands_on_practices": [{"introduction": "在随机微分方程领域，一项核心技能是将关于随机过程期望值的问题，转化为确定性的微分方程问题。这种方法威力巨大，因为它允许我们运用成熟的分析工具来解决随机问题。本练习将通过为一个带漂移的布朗运动 $X_t$ 推导其首次到达时间 $\\tau_a$ 的拉普拉斯变换 $\\mathbb{E}[e^{-\\lambda \\tau_a}]$，来具体展示这一技巧 [@problem_id:2970748]。你将学习如何利用一个过程的无穷小生成元 (infinitesimal generator) 来构建并求解相应的边值问题，这是连接随机分析与偏微分方程的关键桥梁。", "id": "2970748", "problem": "考虑一个由随机微分方程 (SDE) 定义的一维扩散 $$\\mathrm{d}X_{t}=\\mu\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}W_{t},$$ 其中 $W_{t}$ 是标准布朗运动，$\\mu\\in\\mathbb{R}$ 是常数漂移，$\\sigma>0$ 是常数波动率，且 $X_{0}=0$。对于固定的 $a>0$，定义首次到达时间 $$\\tau_{a}=\\inf\\{t\\geq 0:X_{t}=a\\}.$$ 对于参数 $\\lambda>0$，该到达时间的拉普拉斯变换为 $$\\mathbb{E}\\big[\\exp(-\\lambda\\,\\tau_{a})\\big].$$\n\n从适用于时间齐次扩散的第一性原理出发，包括伊藤公式、强马尔可夫性、无穷小生成元和登金公式，推导函数 $$u(x)=\\mathbb{E}_{x}\\big[\\exp(-\\lambda\\,\\tau_{a})\\big]$$ 所满足的边值问题，其中 $\\mathbb{E}_{x}$ 表示在 $X_{0}=x$ 条件下的期望，然后求解此边值问题，以获得 $$u(0)=\\mathbb{E}\\big[\\exp(-\\lambda\\,\\tau_{a})\\big]$$ 的闭式表达式。\n\n最终答案必须是关于 $a$、$\\mu$、$\\sigma$ 和 $\\lambda$ 的单个闭式解析表达式。无需四舍五入，也不涉及物理单位。请以精确形式表示答案。", "solution": "我们首先回顾时间齐次扩散的基本工具。对于一个充分光滑的函数 $f$，由 $$\\mathrm{d}X_{t}=\\mu\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}W_{t}$$ 定义的过程 $X_{t}$ 的伊藤公式得出\n$$\n\\mathrm{d}f(X_{t})=f'(X_{t})\\,\\mathrm{d}X_{t}+\\frac{1}{2}f''(X_{t})\\,\\mathrm{d}\\langle X\\rangle_{t}\n=f'(X_{t})\\mu\\,\\mathrm{d}t+f'(X_{t})\\sigma\\,\\mathrm{d}W_{t}+\\frac{1}{2}\\sigma^{2}f''(X_{t})\\,\\mathrm{d}t.\n$$\n因此，$X_{t}$ 的无穷小生成元 $\\mathcal{L}$ 作用于 $f$ 的形式为\n$$\n\\mathcal{L}f(x)=\\mu f'(x)+\\frac{\\sigma^{2}}{2}f''(x).\n$$\n\n对于固定的 $\\lambda>0$，定义函数\n$$\nu(x)=\\mathbb{E}_{x}\\big[\\exp(-\\lambda\\tau_{a})\\big],\\quad x<a.\n$$\n我们的目标是推导 $u$ 的边值问题。考虑过程\n$$\nM_{t}=\\exp(-\\lambda t)\\,u(X_{t}),\n$$\n并对 $M_{t}$ 应用伊藤公式，直至停时 $\\tau_{a}$。为使其精确，取局部化停时 $\\tau_{a}\\wedge t$（其中 $t>0$）并计算\n$$\n\\mathrm{d}\\big(\\exp(-\\lambda t)u(X_{t})\\big)=\\exp(-\\lambda t)\\left[-\\lambda u(X_{t})\\,\\mathrm{d}t+\\mathrm{d}u(X_{t})\\right].\n$$\n使用 $\\mathrm{d}u(X_{t})$ 的生成元表达式，\n$$\n\\mathrm{d}u(X_{t})=\\left(\\mu u'(X_{t})+\\frac{\\sigma^{2}}{2}u''(X_{t})\\right)\\mathrm{d}t+\\sigma u'(X_{t})\\,\\mathrm{d}W_{t},\n$$\n我们得到\n$$\n\\mathrm{d}\\big(\\exp(-\\lambda t)u(X_{t})\\big)\n=\\exp(-\\lambda t)\\left[\\left(\\mu u'(X_{t})+\\frac{\\sigma^{2}}{2}u''(X_{t})-\\lambda u(X_{t})\\right)\\mathrm{d}t+\\sigma u'(X_{t})\\,\\mathrm{d}W_{t}\\right].\n$$\n如果 $u$ 满足微分方程\n$$\n\\mu u'(x)+\\frac{\\sigma^{2}}{2}u''(x)=\\lambda u(x)\\quad\\text{for }x<a,\n$$\n则漂移项消失，$\\exp(-\\lambda t)u(X_{t})$ 是一个局部鞅。通过在 $\\tau_{a}$ 处的局部化以及下文所述的有界性考虑，我们得到一个真鞅\n$$\n\\exp\\big(-\\lambda(t\\wedge\\tau_{a})\\big)u\\big(X_{t\\wedge\\tau_{a}}\\big).\n$$\n根据可选停止定理和强马尔可夫性，取期望可得\n$$\nu(x)=\\mathbb{E}_{x}\\left[\\exp\\big(-\\lambda(t\\wedge\\tau_{a})\\big)u\\big(X_{t\\wedge\\tau_{a}}\\big)\\right].\n$$\n令 $t\\to\\infty$，由单调收敛定理和控制收敛定理可得\n$$\nu(x)=\\mathbb{E}_{x}\\left[\\exp(-\\lambda\\tau_{a})u(X_{\\tau_{a}})\\mathbf{1}_{\\{\\tau_{a}<\\infty\\}}\\right]\n=\\mathbb{E}_{x}\\left[\\exp(-\\lambda\\tau_{a})\\right]u(a),\n$$\n其中我们在 $\\{\\tau_{a}<\\infty\\}$ 上使用了 $X_{\\tau_{a}}=a$。根据定义，$u(x)=\\mathbb{E}_{x}\\left[\\exp(-\\lambda\\tau_{a})\\right]$，因此我们必须有边界条件\n$$\nu(a)=1.\n$$\n\n为了完善该边值问题，我们指定当 $x\\to -\\infty$ 时的行为。直观上，从左侧很远的地方开始，到达时间 $\\tau_{a}$ 会非常大，指数项 $\\exp(-\\lambda\\tau_{a})$ 趋于 $0$，因此很自然地施加条件\n$$\n\\lim_{x\\to -\\infty}u(x)=0.\n$$\n这个条件也确保了在 $(-\\infty,a)$ 上的有界性以及该二阶线性常微分方程解的唯一性。因此，边值问题是\n$$\n\\frac{\\sigma^{2}}{2}u''(x)+\\mu u'(x)=\\lambda u(x)\\quad\\text{for }x<a,\\qquad u(a)=1,\\qquad \\lim_{x\\to -\\infty}u(x)=0.\n$$\n\n现在我们求解这个常系数线性常微分方程。寻找形如 $u(x)=\\exp(r x)$ 的解，这导出特征方程\n$$\n\\frac{\\sigma^{2}}{2}r^{2}+\\mu r-\\lambda=0.\n$$\n方程的根为\n$$\nr_{\\pm}=\\frac{-\\mu\\pm\\sqrt{\\mu^{2}+2\\lambda\\sigma^{2}}}{\\sigma^{2}}.\n$$\n因此，在 $(-\\infty,a)$ 上的通解为\n$$\nu(x)=C_{1}\\exp(r_{+}x)+C_{2}\\exp(r_{-}x).\n$$\n我们分析 $r_{\\pm}$ 的符号。因为 $\\sqrt{\\mu^{2}+2\\lambda\\sigma^{2}}\\geq|\\mu|$，所以我们有\n$$\nr_{+}=\\frac{-\\mu+\\sqrt{\\mu^{2}+2\\lambda\\sigma^{2}}}{\\sigma^{2}}\\geq 0,\\qquad\nr_{-}=\\frac{-\\mu-\\sqrt{\\mu^{2}+2\\lambda\\sigma^{2}}}{\\sigma^{2}}\\leq 0.\n$$\n施加条件 $\\lim_{x\\to -\\infty}u(x)=0$ 消除了当 $x\\to -\\infty$ 时发散的项。因为 $r_{-}<0$，所以当 $x\\to -\\infty$ 时 $\\exp(r_{-}x)\\to\\infty$，而 $\\exp(r_{+}x)\\to 0$。因此我们必须设 $C_{2}=0$，解简化为\n$$\nu(x)=C_{1}\\exp(r_{+}x).\n$$\n边界条件 $u(a)=1$ 给出 $C_{1}=\\exp(-r_{+}a)$，所以\n$$\nu(x)=\\exp\\big(r_{+}(x-a)\\big).\n$$\n在 $x=0$ 处求值，得到所需的拉普拉斯变换：\n$$\nu(0)=\\exp\\big(-r_{+}a\\big)=\\exp\\left(\\frac{\\mu-\\sqrt{\\mu^{2}+2\\lambda\\sigma^{2}}}{\\sigma^{2}}\\,a\\right).\n$$\n\n这就完成了从基于生成元的边值问题出发，并通过初等常微分方程方法求解的推导过程。作为一致性检验，当 $\\lambda=0$ 时我们得到\n$$\nu(0)=\\exp\\left(\\frac{\\mu-|\\mu|}{\\sigma^{2}}\\,a\\right),\n$$\n当 $\\mu\\geq 0$ 时（非负漂移下几乎必然向右到达）其值为 $1$，而当 $\\mu<0$ 时其值为 $\\exp\\left(\\frac{2\\mu a}{\\sigma^{2}}\\right)$，这正是带漂移的布朗运动向右到达的经典概率，从而证实了该表达式的正确性。", "answer": "$$\\boxed{\\exp\\!\\left(\\frac{\\mu-\\sqrt{\\mu^{2}+2\\lambda\\sigma^{2}}}{\\sigma^{2}}\\,a\\right)}$$"}, {"introduction": "特征函数 $\\phi_{X_t}(u)$ 包含了随机变量分布的全部信息，但我们如何从中提取出更直观的概率密度函数 (PDF) $p_{X_t}(x)$ 呢？本练习将带你从理论走向实践，通过数值方法实现傅里叶反演公式，从一个Ornstein-Uhlenbeck过程的特征函数中恢复其概率密度 [@problem_id:2970777]。这个过程不仅能让你掌握一项基本的计算技术，还将引导你分析数值计算中不可避免的截断误差与离散误差，这是所有定量工作中至关重要的一步。", "id": "2970777", "problem": "您的任务是：从一个一维Itô过程在固定时间的特征函数出发，恢复其概率密度函数，并分析此反演过程中固有的数值误差。考虑如下的Ornstein–Uhlenbeck随机微分方程（SDE）\n$$\ndX_t = \\kappa \\left(\\theta - X_t\\right)\\,dt + \\sigma\\, dW_t,\\quad X_0 = x_0,\n$$\n其中$W_t$是标准布朗运动，$\\kappa$、$\\theta$、$\\sigma$、$x_0$和$t$是实数参数，且$\\kappa \\gt 0$，$\\sigma \\gt 0$，$t \\gt 0$。\n\n$X_t$的特征函数定义为\n$$\n\\phi_{X_t}(u) = \\mathbb{E}\\left[e^{i u X_t}\\right],\n$$\n当密度$p_{X_t}(x)$存在时，可以通过傅里叶反演公式从$\\phi_{X_t}(u)$中恢复\n$$\np_{X_t}(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} e^{-i u x}\\,\\phi_{X_t}(u)\\,du.\n$$\n\n您必须从线性SDE的基本性质、Itô积分以及特征函数的定义出发：\n1. 严格地从第一性原理出发（不使用任何现成公式），推导上述定义的Ornstein–Uhlenbeck过程的$X_t$的分布和$\\phi_{X_t}(u)$。\n2. 设计一个数值傅里叶反演方案，通过在$\\pm U$处对积分进行对称截断，并使用步长均匀的复化梯形法则来近似$p_{X_t}(x)$：\n$$\n\\widehat{p}_{X_t}(x;U,\\Delta u) = \\frac{1}{2\\pi}\\sum_{k=-K}^{K} w_k\\, \\phi_{X_t}(u_k)\\, e^{-i u_k x}\\,\\Delta u,\n$$\n其中$u_k = k\\,\\Delta u$，$K = \\lfloor U/\\Delta u\\rfloor$，$w_k$是梯形权重，端点权重为$1/2$，内点权重为$1$。\n3. 通过区分误差来源，分析并量化近似误差$\\left|p_{X_t}(x) - \\widehat{p}_{X_t}(x;U,\\Delta u)\\right|$：\n   - 由有限$U$引起的截断误差，使用从$\\left|\\phi_{X_t}(u)\\right|$的衰减推导出的界限。\n   - 由有限$\\Delta u$引起的离散化误差，使用根据被积函数在$\\left[-U,U\\right]$上二阶导数的上确界得到的复化梯形法则的误差界限。\n\n您的算法必须：\n- 实现上述数值反演方案。\n- 使用为Ornstein–Uhlenbeck过程解析推导出的$p_{X_t}(x)$（从第1部分获得）作为参考，计算逐点绝对误差。\n- 对于下面的每个测试用例，在一组覆盖了分布主要质量的$x$值网格上计算最大绝对误差。使用网格\n$$\nx_j = m - 4\\sqrt{v} + j\\cdot \\delta_x,\\quad j=0,1,\\ldots,J,\n$$\n其中$m$和$v$是从第1部分确定的$X_t$的均值和方差，$J=200$，且$\\delta_x = \\frac{8\\sqrt{v}}{J}$。\n\n测试套件：\n- 用例1（一般正常路径）：$\\kappa=1.0$，$\\theta=0.0$，$x_0=1.0$，$\\sigma=1.0$，$t=1.0$，$U=30.0$，$\\Delta u=0.01$。\n- 用例2（截断误差主导）：$\\kappa=1.0$，$\\theta=0.0$，$x_0=1.0$，$\\sigma=1.0$，$t=1.0$，$U=5.0$，$\\Delta u=0.01$。\n- 用例3（离散化误差主导）：$\\kappa=1.0$，$\\theta=0.0$，$x_0=1.0$，$\\sigma=1.0$，$t=1.0$，$U=30.0$，$\\Delta u=0.5$。\n- 用例4（慢衰减边缘情况）：$\\kappa=1.5$，$\\theta=-0.5$，$x_0=2.0$，$\\sigma=0.5$，$t=0.1$，$U=30.0$，$\\Delta u=0.05$。\n\n输出规格：\n- 对每个用例，在指定的$x$网格上计算最大绝对误差。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[result1,result2,result3,result4]`）。\n- 每个结果都必须是一个浮点数，代表相应测试用例的最大绝对误差。\n\n本问题不涉及物理单位。角度（在复指数中隐式出现时）按照所使用的标准数学定义以弧度处理。", "solution": "经评估，用户提供的问题是有效的。它在科学上基于随机微分方程和数值分析理论，问题设定适定，提供了所有必要的参数和定义，且表述客观。该问题要求推导Ornstein-Uhlenbeck过程的性质并实现一种数值傅里叶反演方法，这在量化金融和物理学中是一项标准且有意义的任务。我们将继续提供完整解答。\n\n此问题分两部分解决：首先，对所需的解析表达式进行理论推导；其次，描述基于这些表达式的数值算法。\n\n### 第一部分：Ornstein-Uhlenbeck过程的解析解\n\nOrnstein-Uhlenbeck过程由以下随机微分方程（SDE）描述：\n$$\ndX_t = \\kappa \\left(\\theta - X_t\\right)\\,dt + \\sigma\\, dW_t, \\quad X_0 = x_0\n$$\n其中$\\kappa > 0$, $\\sigma > 0$, $t > 0$是实数参数，而$W_t$是标准维纳过程。这是一个线性SDE。我们可以通过定义一个辅助过程$Y_t = e^{\\kappa t} X_t$并应用Itô引理来求解。$Y_t$的微分是：\n$$\ndY_t = d(e^{\\kappa t} X_t) = (\\partial_t(e^{\\kappa t} X_t))\\,dt + (\\partial_x(e^{\\kappa t} X_t))\\,dX_t + \\frac{1}{2}(\\partial_{xx}(e^{\\kappa t} X_t))\\,(dX_t)^2\n$$\n偏导数为$\\partial_t(e^{\\kappa t} X_t) = \\kappa e^{\\kappa t} X_t$，$\\partial_x(e^{\\kappa t} X_t) = e^{\\kappa t}$，以及$\\partial_{xx}(e^{\\kappa t} X_t) = 0$。$dX_t$的二次变分为$(dX_t)^2 = \\sigma^2\\,dt$。将这些以及$dX_t$的表达式代入$dY_t$的公式中：\n$$\ndY_t = \\kappa e^{\\kappa t} X_t\\,dt + e^{\\kappa t} \\left( \\kappa(\\theta - X_t)\\,dt + \\sigma\\,dW_t \\right)\n$$\n$$\ndY_t = \\kappa e^{\\kappa t} X_t\\,dt + \\kappa \\theta e^{\\kappa t}\\,dt - \\kappa e^{\\kappa t} X_t\\,dt + \\sigma e^{\\kappa t}\\,dW_t\n$$\n包含$X_t$的项相互抵消，表达式简化为：\n$$\ndY_t = \\kappa \\theta e^{\\kappa t}\\,dt + \\sigma e^{\\kappa t}\\,dW_t\n$$\n从$s=0$到$s=t$进行积分：\n$$\nY_t - Y_0 = \\int_0^t \\kappa \\theta e^{\\kappa s}\\,ds + \\int_0^t \\sigma e^{\\kappa s}\\,dW_s\n$$\n代回$Y_t = e^{\\kappa t} X_t$和$Y_0 = e^0 X_0 = x_0$：\n$$\ne^{\\kappa t} X_t - x_0 = \\kappa \\theta \\left[ \\frac{1}{\\kappa} e^{\\kappa s} \\right]_0^t + \\sigma \\int_0^t e^{\\kappa s}\\,dW_s\n$$\n$$\ne^{\\kappa t} X_t = x_0 + \\theta (e^{\\kappa t} - 1) + \\sigma \\int_0^t e^{\\kappa s}\\,dW_s\n$$\n通过乘以$e^{-\\kappa t}$来求解$X_t$：\n$$\nX_t = x_0 e^{-\\kappa t} + \\theta (1 - e^{-\\kappa t}) + \\sigma e^{-\\kappa t} \\int_0^t e^{\\kappa s}\\,dW_s\n$$\n积分项可以重写为$\\sigma \\int_0^t e^{-\\kappa(t-s)}\\,dW_s$。$X_t$的解是一个确定性部分和一个具有确定性被积函数的Itô积分之和。确定性函数的Itô积分是一个均值为零的高斯随机变量。因此，$X_t$本身是一个正态分布的随机变量。\n\n$X_t$的均值（记为$m_t$）通过取期望得到。Itô积分的期望为零：\n$$\nm_t = \\mathbb{E}[X_t] = x_0 e^{-\\kappa t} + \\theta (1 - e^{-\\kappa t})\n$$\n$X_t$的方差（记为$v_t$）由Itô积分项决定，使用Itô等距性质 $\\mathbb{E}\\left[\\left(\\int_0^t f(s)\\,dW_s\\right)^2\\right] = \\int_0^t f(s)^2\\,ds$：\n$$\nv_t = \\text{Var}[X_t] = \\text{Var}\\left[\\sigma \\int_0^t e^{-\\kappa(t-s)}\\,dW_s\\right] = \\sigma^2 \\int_0^t \\left(e^{-\\kappa(t-s)}\\right)^2\\,ds\n$$\n$$\nv_t = \\sigma^2 \\int_0^t e^{-2\\kappa(t-s)}\\,ds = \\sigma^2 e^{-2\\kappa t} \\int_0^t e^{2\\kappa s}\\,ds = \\sigma^2 e^{-2\\kappa t} \\left[\\frac{e^{2\\kappa s}}{2\\kappa}\\right]_0^t\n$$\n$$\nv_t = \\sigma^2 e^{-2\\kappa t} \\left(\\frac{e^{2\\kappa t} - 1}{2\\kappa}\\right) = \\frac{\\sigma^2}{2\\kappa} (1 - e^{-2\\kappa t})\n$$\n因此，$X_t$的分布是高斯分布：$X_t \\sim \\mathcal{N}(m_t, v_t)$。其概率密度函数（PDF）$p_{X_t}(x)$是：\n$$\np_{X_t}(x) = \\frac{1}{\\sqrt{2\\pi v_t}} \\exp\\left(-\\frac{(x - m_t)^2}{2v_t}\\right)\n$$\n一个正态随机变量$Y \\sim \\mathcal{N}(\\mu, \\sigma^2)$的特征函数是$\\phi_Y(u) = \\exp(i u \\mu - \\frac{1}{2} u^2 \\sigma^2)$。将此应用于$X_t$，其特征函数$\\phi_{X_t}(u) = \\mathbb{E}[e^{i u X_t}]$为：\n$$\n\\phi_{X_t}(u) = \\exp\\left(i u m_t - \\frac{1}{2} u^2 v_t\\right) = \\exp\\left(i u \\left[x_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t})\\right] - \\frac{u^2 \\sigma^2}{4\\kappa} (1 - e^{-2\\kappa t})\\right)\n$$\n$p_{X_t}(x)$和$\\phi_{X_t}(u)$的这些解析形式是数值任务的基础。\n\n### 第二部分：数值反演方案与算法设计\n\nPDF可以通过傅里叶逆变换从特征函数中恢复：\n$$\np_{X_t}(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} e^{-i u x}\\,\\phi_{X_t}(u)\\,du\n$$\n为了数值近似该积分，我们执行两个步骤：\n1.  **截断**：将无限积分截断为有限的对称区间$[-U, U]$。如果$|\\phi_{X_t}(u)|$在$|u| \\to \\infty$时衰减足够快，则此步骤的误差很小。对于OU过程，$|\\phi_{X_t}(u)| = e^{-\\frac{1}{2}u^2 v_t}$，具有高斯衰减特性，这使得截断非常有效。\n2.  **离散化**：使用数值积分法则来近似截断后的积分$\\int_{-U}^{U}$。问题指定使用步长均匀的复化梯形法则。\n\n得到的数值近似值$\\widehat{p}_{X_t}(x; U, \\Delta u)$由下式给出：\n$$\n\\widehat{p}_{X_t}(x;U,\\Delta u) = \\frac{1}{2\\pi}\\sum_{k=-K}^{K} w_k\\, \\phi_{X_t}(u_k)\\, e^{-i u_k x}\\,\\Delta u\n$$\n其中$u_k = k\\,\\Delta u$，$K = \\lfloor U/\\Delta u\\rfloor$，权重$w_k$在$k = \\pm K$时为$1/2$，在$|k| < K$时为$1$。\n\n为每个测试用例实现的算法如下：\n1.  给定参数$(\\kappa, \\theta, x_0, \\sigma, t)$，计算解析的均值$m_t$和方差$v_t$。\n2.  在域$[m_t - 4\\sqrt{v_t}, m_t + 4\\sqrt{v_t}]$上定义空间网格$\\{x_j\\}_{j=0}^J$（$J=200$），该网格大约覆盖分布的8个标准差。\n3.  给定数值参数$(U, \\Delta u)$，定义频率网格$\\{u_k\\}_{k=-K}^K$，其中$K = \\lfloor U/\\Delta u\\rfloor$。\n4.  对于空间网格上的每个点$x_j$，使用梯形和计算近似的PDF $\\widehat{p}_{X_t}(x_j)$。\n    - 这涉及到在频率网格上计算$\\phi_{X_t}(u_k)$。\n    - 计算傅里叶核$e^{-i u_k x_j}$。\n    - 将各项相乘、加权、求和，然后乘以$\\Delta u / (2\\pi)$进行缩放。取结果的实部，因为真实的PDF是实值函数。\n5.  对于每个点$x_j$，使用均值为$m_t$、方差为$v_t$的高斯分布的解析公式计算精确的PDF $p_{X_t}(x_j)$。\n6.  在每个网格点$x_j$处计算绝对误差$|p_{X_t}(x_j) - \\widehat{p}_{X_t}(x_j)|$。\n7.  该测试用例的最终结果是整个网格$\\{x_j\\}$上这些绝对误差的最大值。\n\n为提高效率，此过程以向量化方式实现。所有$x_j$值的计算都是通过数组运算同时执行的，这避免了在Python代码中使用显式循环，并利用了底层`numpy`库的性能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of recovering the PDF of an Ornstein-Uhlenbeck process\n    from its characteristic function using numerical Fourier inversion and\n    calculating the maximum absolute error against the true PDF.\n    \"\"\"\n    # Define the test cases as per the problem statement.\n    # Each tuple is (kappa, theta, x0, sigma, t, U, delta_u)\n    test_cases = [\n        (1.0, 0.0, 1.0, 1.0, 1.0, 30.0, 0.01),\n        (1.0, 0.0, 1.0, 1.0, 1.0, 5.0, 0.01),\n        (1.0, 0.0, 1.0, 1.0, 1.0, 30.0, 0.5),\n        (1.5, -0.5, 2.0, 0.5, 0.1, 30.0, 0.05),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kappa, theta, x0, sigma, t, U, delta_u = case\n        \n        # 1. Calculate analytical mean (m_t) and variance (v_t) of X_t\n        e_neg_kt = np.exp(-kappa * t)\n        m_t = x0 * e_neg_kt + theta * (1 - e_neg_kt)\n        v_t = (sigma**2 / (2 * kappa)) * (1 - np.exp(-2 * kappa * t))\n        \n        # 2. Setup the grid for x where the PDF is evaluated.\n        # This grid spans 8 standard deviations around the mean.\n        J = 200\n        v_t_sqrt = np.sqrt(v_t)\n        delta_x = 8 * v_t_sqrt / J\n        x_grid = m_t - 4 * v_t_sqrt + np.arange(J + 1) * delta_x\n        \n        # 3. Setup the grid for the frequency domain (u) for numerical integration.\n        K = int(np.floor(U / delta_u))\n        u_grid = np.arange(-K, K + 1) * delta_u\n        \n        # 4. Perform the numerical Fourier inversion.\n        # This is done in a vectorized way for efficiency.\n        \n        # Calculate the characteristic function values on the u_grid.\n        # phi(u) = exp(i*u*m_t - 0.5*u^2*v_t)\n        phi_u_vals = np.exp(1j * u_grid * m_t - 0.5 * u_grid**2 * v_t)\n        \n        # Define the trapezoidal rule weights.\n        weights = np.ones_like(u_grid)\n        weights[0] = 0.5\n        weights[-1] = 0.5\n        \n        # Prepare for vectorized computation over x_grid.\n        # x_grid -> column vector, u_grid -> row vector\n        x_col = x_grid[:, np.newaxis]\n        u_row = u_grid[np.newaxis, :]\n        \n        # Compute the Fourier kernel exp(-i*u*x) for all combinations of u and x.\n        exp_inv_kernel = np.exp(-1j * x_col * u_row)\n        \n        # The integrand for each x is phi(u) * exp(-i*u*x).\n        # We broadcast phi_u_vals to match the shape of the kernel.\n        integrand = phi_u_vals[np.newaxis, :] * exp_inv_kernel\n        \n        # Apply trapezoidal weights to the integrand.\n        integrand_weighted = integrand * weights[np.newaxis, :]\n        \n        # Sum over the u-dimension (axis=1) and scale to get the integral approximation.\n        integral_sum = np.sum(integrand_weighted, axis=1)\n        p_hat_vals = np.real(integral_sum * delta_u / (2 * np.pi))\n        \n        # 5. Calculate the true PDF values on the x_grid.\n        # p(x) = (1/sqrt(2*pi*v_t)) * exp(-(x-m_t)^2 / (2*v_t))\n        p_true_vals = (1 / np.sqrt(2 * np.pi * v_t)) * np.exp(-(x_grid - m_t)**2 / (2 * v_t))\n        \n        # 6. Compute the maximum absolute error.\n        abs_errors = np.abs(p_true_vals - p_hat_vals)\n        max_error = np.max(abs_errors)\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "在掌握了从特征函数恢复密度的基本方法后，我们常常会遇到一个更具挑战性的实际问题：当分布具有“重尾”特性时，数值计算的稳定性。在金融和物理学的许多模型中，重尾分布十分常见，而直接计算它们的特征函数 $\\phi_{X_t}(u)$ 在频率 $|u|$ 较大时往往会因数值下溢 (underflow) 而失败。本练习将聚焦于这一难题，介绍一种“阻尼”正则化方法，以确保即便在特征函数的值变得极小的情况下，也能稳定地获取其对数幅度的精确信息 [@problem_id:2970741]。", "id": "2970741", "problem": "考虑线性随机微分方程 (SDE) $dX_t = -\\lambda X_t \\, dt + dL_t$，其确定性初始条件为 $X_0 = x_0 \\in \\mathbb{R}$，其中 $L_t$ 是一个对称 $\\alpha$-稳定Lévy过程，满足 $\\mathbb{E}\\left[e^{i u L_t}\\right] = \\exp\\!\\left(- \\eta \\, t \\, |u|^{\\alpha}\\right)$，参数为 $\\eta > 0$ 和 $\\alpha \\in (1,2]$。对于固定的时间 $t > 0$，$X_t$的特征函数 (CF) $\\phi_{X_t}(u) = \\mathbb{E}\\left[e^{i u X_t}\\right]$ 可以以闭式形式表示，并且当 $\\alpha < 2$ 时表现出重尾行为。由于当 $\\exp(-c |u|^{\\alpha})$（其中 $c > 0$）低于机器范围时，模 $|\\phi_{X_t}(u)|$ 会发生下溢，因此对大的 $|u|$ 直接进行数值计算 $\\phi_{X_t}(u)$ 可能会不稳定。\n\n您的任务是分析大 $|u|$ 情况下的数值稳定性，并实现一种基于阻尼的正则化方法，以提取稳定的对数模，而无需重构微小的复数值。仅使用定义和经过充分检验的事实。具体而言：\n\n1. 从线性SDE的精确温和解表示以及对称α-稳定过程的独立平稳增量特性出发，将 $\\phi_{X_t}(u)$ 表示为一个包含核函数 $e^{-\\lambda (t-s)}$ 的积分。\n\n2. 证明存在一个常数 $b = \\eta \\, \\dfrac{1 - e^{-\\alpha \\lambda t}}{\\alpha \\lambda} > 0$，使得\n$$\n\\phi_{X_t}(u) = \\exp\\!\\left( i \\, u \\, x_0 \\, e^{-\\lambda t} \\right) \\, \\exp\\!\\left( - b \\, |u|^{\\alpha} \\right).\n$$\n因此 $|\\phi_{X_t}(u)| = \\exp\\!\\left( - b \\, |u|^{\\alpha} \\right)$ 且 $\\arg \\phi_{X_t}(u) = u \\, x_0 \\, e^{-\\lambda t}$。\n\n3. 解释为什么当 $b \\, |u|^{\\alpha}$ 超过一个接近最小正规格化浮点数的自然对数的阈值时（在双精度下约为 $\\log(10^{-308}) \\approx -708$，因此关键量级约为 $708$），直接计算 $|\\phi_{X_t}(u)|$ 可能会下溢为零。\n\n4. 提出一个带有参数 $\\delta \\in (0,b)$ 的阻尼因子，例如，对于固定的 $\\rho \\in (0,1)$，取 $\\delta = \\rho \\, b$，以构建阻尼特征函数\n$$\n\\phi_{X_t}^{(\\delta)}(u) := e^{\\delta |u|^{\\alpha}} \\, \\phi_{X_t}(u).\n$$\n证明 $|\\phi_{X_t}^{(\\delta)}(u)| = \\exp\\!\\left( - (b-\\delta) \\, |u|^{\\alpha} \\right)$ 的下溢发生得更晚，并且真实的对数模可以精确地恢复为\n$$\n\\log |\\phi_{X_t}(u)| = \\log |\\phi_{X_t}^{(\\delta)}(u)| - \\delta \\, |u|^{\\alpha}.\n$$\n这提供了一种稳定的方法来报告 $\\log |\\phi_{X_t}(u)|$，即使 $|\\phi_{X_t}(u)|$ 本身发生下溢。\n\n实现一个程序，对下面的每个测试用例，计算：\n- 一个整数下溢指示符 $I \\in \\{0,1\\}$，定义为：如果 $|\\phi_{X_t}(u)|$ 的直接计算在双精度下下溢为零，则 $I=1$，否则 $I=0$。\n- 通过使用 $\\delta = \\rho \\, b$ 且固定 $\\rho = \\tfrac{1}{2}$ 的阻尼方法计算出的稳定化对数模 $L = \\log |\\phi_{X_t}(u)|$。\n\n您必须使用以下测试套件，它涵盖了典型情况、接近下溢情况、确定下溢情况以及一个非常重尾的边缘情况。在每种情况下，所有参数均以无单位形式给出：\n\n- 测试用例 1：$(\\lambda,\\eta,\\alpha,t,x_0,u) = (\\,0.7,\\,0.9,\\,1.6,\\,2.0,\\,1.0,\\,10.0\\,)$。\n- 测试用例 2：$(\\lambda,\\eta,\\alpha,t,x_0,u) = (\\,0.7,\\,0.9,\\,1.6,\\,2.0,\\,1.0,\\,70.0\\,)$。\n- 测试用例 3：$(\\lambda,\\eta,\\alpha,t,x_0,u) = (\\,0.7,\\,0.9,\\,1.6,\\,2.0,\\,1.0,\\,80.0\\,)$。\n- 测试用例 4：$(\\lambda,\\eta,\\alpha,t,x_0,u) = (\\,0.4,\\,1.2,\\,1.05,\\,3.0,\\,1.0,\\,5.0\\,)$。\n\n对于每个测试用例，设置 $\\rho = \\tfrac{1}{2}$ 并计算 $\\delta = \\rho \\, b$，其中 $b = \\eta \\, \\dfrac{1 - e^{-\\alpha \\lambda t}}{\\alpha \\lambda}$。使用这些来生成两个所要求的输出。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个扁平列表，该列表按顺序连接每个测试用例的两个结果。具体来说，该行必须是\n$[I_1, L_1, I_2, L_2, I_3, L_3, I_4, L_4]$\n的形式，其中 $I_k \\in \\{0,1\\}$ 且 $L_k \\in \\mathbb{R}$。不应打印任何额外文本。", "solution": "该问题被评估为有效，因为它科学上成立、适定且客观。它提出了一个随机微分方程分析和数值稳定性方面的标准问题，并提供了所有必要的信息。\n\n解决方案按要求分为四个部分呈现。\n\n### 第1部分：特征函数的推导\n\n给定的线性随机微分方程 (SDE) 为\n$$\ndX_t = -\\lambda X_t \\, dt + dL_t\n$$\n其确定性初始条件为 $X_0 = x_0$。这是一个由Lévy过程 $L_t$ 驱动的标准Ornstein-Uhlenbeck过程。\n\n该SDE的温和解可以通过使用积分因子 $e^{\\lambda t}$ 求得。将SDE乘以 $e^{\\lambda t}$ 得到：\n$$\ne^{\\lambda t} dX_t + \\lambda e^{\\lambda t} X_t dt = e^{\\lambda t} dL_t\n$$\n左侧是 $e^{\\lambda t} X_t$ 的微分，因此我们有 $d(e^{\\lambda t} X_t) = e^{\\lambda t} dL_t$。从 $s=0$ 到 $s=t$ 积分得到：\n$$\n\\int_0^t d(e^{\\lambda s} X_s) = \\int_0^t e^{\\lambda s} dL_s\n$$\n$$\ne^{\\lambda t} X_t - e^{\\lambda \\cdot 0} X_0 = \\int_0^t e^{\\lambda s} dL_s\n$$\n解出 $X_t$，我们得到温和解：\n$$\nX_t = X_0 e^{-\\lambda t} + \\int_0^t e^{-\\lambda(t-s)} dL_s\n$$\n$X_t$ 的特征函数 (CF) 定义为 $\\phi_{X_t}(u) = \\mathbb{E}\\left[e^{i u X_t}\\right]$。代入 $X_t$ 的表达式：\n$$\n\\phi_{X_t}(u) = \\mathbb{E}\\left[\\exp\\left(i u \\left(x_0 e^{-\\lambda t} + \\int_0^t e^{-\\lambda(t-s)} dL_s\\right)\\right)\\right]\n$$\n由于 $x_0$ 是确定性的，包含 $x_0$ 的项可以从期望中提取出来：\n$$\n\\phi_{X_t}(u) = \\exp\\left(i u x_0 e^{-\\lambda t}\\right) \\mathbb{E}\\left[\\exp\\left(i u \\int_0^t e^{-\\lambda(t-s)} dL_s\\right)\\right]\n$$\n剩余的期望是随机积分 $I_t = \\int_0^t e^{-\\lambda(t-s)} dL_s$ 的特征函数。对于具有特征指数 $\\Psi(v)$（由 $\\mathbb{E}[e^{ivL_t}] = e^{t\\Psi(v)}$ 定义）的一般Lévy过程 $L_t$，随机积分 $\\int_0^t g(s) dL_s$ 的特征函数由 $\\exp\\left(\\int_0^t \\Psi(u g(s)) ds\\right)$ 给出。\n\n在这个问题中，$L_t$ 是一个对称 $\\alpha$-稳定过程，其 $\\mathbb{E}[e^{iuL_t}] = \\exp(-\\eta t |u|^\\alpha)$。这意味着 $L_1$ 的特征指数是 $\\Psi(v) = -\\eta |v|^\\alpha$。我们的被积函数是 $g(s) = e^{-\\lambda(t-s)}$。因此，期望项为：\n$$\n\\mathbb{E}\\left[\\exp\\left(i u I_t\\right)\\right] = \\exp\\left( \\int_0^t \\Psi\\left(u e^{-\\lambda(t-s)}\\right) ds \\right) = \\exp\\left( \\int_0^t -\\eta \\left|u e^{-\\lambda(t-s)}\\right|^\\alpha ds \\right)\n$$\n简化被积函数：\n$$\n\\int_0^t -\\eta |u|^\\alpha \\left(e^{-\\lambda(t-s)}\\right)^\\alpha ds = -\\eta |u|^\\alpha \\int_0^t e^{-\\alpha\\lambda(t-s)} ds\n$$\n这样就完成了将 $\\phi_{X_t}(u)$ 用积分形式表示的过程。\n\n### 第2部分：特征函数的闭式表达式\n\n为了找到闭式表达式，我们计算在第1部分中推导出的积分：\n$$\n\\int_0^t e^{-\\alpha\\lambda(t-s)} ds\n$$\n我们将积分变量改为 $v = t-s$，这意味着 $dv = -ds$。积分上下限从 $s=0 \\rightarrow v=t$ 和 $s=t \\rightarrow v=0$ 变化。\n$$\n\\int_{t}^{0} e^{-\\alpha\\lambda v} (-dv) = \\int_0^t e^{-\\alpha\\lambda v} dv\n$$\n假设 $\\lambda \\neq 0$，该积分的计算结果为：\n$$\n\\left[ \\frac{e^{-\\alpha\\lambda v}}{-\\alpha\\lambda} \\right]_0^t = \\frac{e^{-\\alpha\\lambda t} - e^0}{-\\alpha\\lambda} = \\frac{1 - e^{-\\alpha\\lambda t}}{\\alpha\\lambda}\n$$\n（注意：如果 $\\lambda=0$，积分就简化为 $\\int_0^t 1 ds = t$，这与上述表达式在 $\\lambda \\to 0$ 时的极限一致。）\n\n将此结果代回特征函数的表达式中，我们得到：\n$$\n\\mathbb{E}\\left[\\exp\\left(i u I_t\\right)\\right] = \\exp\\left( -\\eta |u|^\\alpha \\frac{1 - e^{-\\alpha\\lambda t}}{\\alpha\\lambda} \\right)\n$$\n我们定义常数 $b$ 为：\n$$\nb = \\eta \\frac{1 - e^{-\\alpha\\lambda t}}{\\alpha\\lambda}\n$$\n由于 $\\eta > 0$，$\\alpha > 0$，$\\lambda > 0$（这是稳定OU过程的标准假设，且对所有测试用例都成立），以及 $t > 0$，我们有 $\\alpha\\lambda t > 0$，这意味着 $e^{-\\alpha\\lambda t} < 1$。因此，$1 - e^{-\\alpha\\lambda t} > 0$，所以 $b > 0$。\n\n完整的特征函数是：\n$$\n\\phi_{X_t}(u) = \\exp\\left(i u x_0 e^{-\\lambda t}\\right) \\exp\\left(-b |u|^\\alpha\\right)\n$$\n这与问题陈述中要求的形式相匹配。特征函数的模为：\n$$\n|\\phi_{X_t}(u)| = \\left|\\exp\\left(i u x_0 e^{-\\lambda t}\\right)\\right| \\left|\\exp\\left(-b |u|^\\alpha\\right)\\right| = 1 \\cdot \\exp\\left(-b |u|^\\alpha\\right) = \\exp\\left(-b |u|^\\alpha\\right)\n$$\n因为第一项是单位圆上的一个复数，而第二项是实数且为正。辐角（相位）是：\n$$\n\\arg \\phi_{X_t}(u) = \\arg\\left(\\exp\\left(i u x_0 e^{-\\lambda t}\\right)\\right) = u x_0 e^{-\\lambda t}\n$$\n\n### 第3部分：直接计算中的数值下溢\n\n模 $|\\phi_{X_t}(u)|$ 由 $\\exp(-b |u|^\\alpha)$ 给出。标准的双精度浮点数（IEEE 754）表示一个有限范围的数值。最小的正规格化数约为 $2.225 \\times 10^{-308}$。任何计算出的小于此值的数值都有被舍入为零的风险，这一事件称为下溢。\n\n为了找到下溢的阈值，我们可以取这个最小值的自然对数：$\\log(2.225 \\times 10^{-308}) \\approx -708.4$。因此，如果指数函数的指数小于这个阈值，结果很可能为零。\n当以下条件满足时，会发生下溢：\n$$\n-b |u|^\\alpha \\lesssim -708.4 \\quad \\iff \\quad b |u|^\\alpha \\gtrsim 708.4\n$$\n对于给定的一组参数 $(\\lambda, \\eta, \\alpha, t)$，常数 $b$ 是固定的。随着频率变量 $|u|$ 的量级增加，$b|u|^\\alpha$ 的值也随之增长。一旦它超过约 $708$ 的临界阈值，直接计算 $|\\phi_{X_t}(u)|$ 将得到零，导致其量级信息的完全丢失。\n\n### 第4部分：基于阻尼的正则化\n\n为了规避下溢问题，我们引入一种使用阻尼因子的正则化技术。我们为某个参数 $\\delta \\in (0, b)$ 定义一个阻尼特征函数 $\\phi_{X_t}^{(\\delta)}(u)$：\n$$\n\\phi_{X_t}^{(\\delta)}(u) := e^{\\delta |u|^{\\alpha}} \\, \\phi_{X_t}(u)\n$$\n代入 $\\phi_{X_t}(u)$ 的表达式：\n$$\n\\phi_{X_t}^{(\\delta)}(u) = e^{\\delta |u|^{\\alpha}} \\left( \\exp\\left(i u x_0 e^{-\\lambda t}\\right) \\exp\\left(-b |u|^\\alpha\\right) \\right)\n$$\n合并实数指数项得到：\n$$\n\\phi_{X_t}^{(\\delta)}(u) = \\exp\\left(i u x_0 e^{-\\lambda t}\\right) \\exp\\left(-(b-\\delta) |u|^\\alpha\\right)\n$$\n这个阻尼特征函数的模是：\n$$\n|\\phi_{X_t}^{(\\delta)}(u)| = \\exp\\left(-(b-\\delta) |u|^\\alpha\\right)\n$$\n由于 $\\delta \\in (0, b)$，指数的系数 $b-\\delta$ 是正的但小于 $b$。阻尼模的下溢条件现在是 $(b-\\delta)|u|^\\alpha \\gtrsim 708.4$。因为 $b-\\delta < b$，需要一个更大的 $|u|$ 值才能触发下溢，从而扩展了数值稳定计算的范围。\n\n关键的洞见是，即使 $|\\phi_{X_t}(u)|$ 发生下溢， $|\\phi_{X_t}^{(\\delta)}(u)|$ 仍然可能是一个可表示的浮点数。我们可以从阻尼版本中恢复原始特征函数的真实对数模。根据阻尼特征函数的定义，我们有：\n$$\n|\\phi_{X_t}^{(\\delta)}(u)| = e^{\\delta |u|^{\\alpha}} |\\phi_{X_t}(u)|\n$$\n对两边取自然对数：\n$$\n\\log|\\phi_{X_t}^{(\\delta)}(u)| = \\log\\left(e^{\\delta |u|^{\\alpha}} |\\phi_{X_t}(u)|\\right) = \\log\\left(e^{\\delta |u|^{\\alpha}}\\right) + \\log|\\phi_{X_t}(u)| = \\delta |u|^{\\alpha} + \\log|\\phi_{X_t}(u)|\n$$\n整理此方程可得到精确的恢复公式：\n$$\n\\log|\\phi_{X_t}(u)| = \\log|\\phi_{X_t}^{(\\delta)}(u)| - \\delta \\, |u|^{\\alpha}\n$$\n此过程允许稳定地计算对数模 $\\log|\\phi_{X_t}(u)|$。该值的计算方法是：首先计算阻尼模 $|\\phi_{X_t}^{(\\delta)}(u)|$，取其对数，然后减去已知的阻尼项 $\\delta|u|^\\alpha$。这避免了直接计算可能已下溢的 $|\\phi_{X_t}(u)|$。从代数上看，结果就是 $-b |u|^\\alpha$，但正是这个数值过程提供了稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes underflow indicator and stabilized logarithmic magnitude for the\n    characteristic function of an Ornstein-Uhlenbeck process driven by a\n    symmetric alpha-stable process.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (lambda, eta, alpha, t, x0, u)\n    test_cases = [\n        (0.7, 0.9, 1.6, 2.0, 1.0, 10.0),\n        (0.7, 0.9, 1.6, 2.0, 1.0, 70.0),\n        (0.7, 0.9, 1.6, 2.0, 1.0, 80.0),\n        (0.4, 1.2, 1.05, 3.0, 1.0, 5.0),\n    ]\n\n    results = []\n    \n    # Damping parameter rho\n    rho = 0.5\n\n    for case in test_cases:\n        lambda_val, eta, alpha, t, x0, u = case\n        \n        # Part 1: Calculate the constant b\n        # b = eta * (1 - e^(-alpha * lambda * t)) / (alpha * lambda)\n        # Using np.expm1 for better numerical stability with small arguments,\n        # although not strictly necessary for these test cases.\n        alpha_lambda_t = alpha * lambda_val * t\n        alpha_lambda = alpha * lambda_val\n        \n        if alpha_lambda == 0.0:\n            # Handle the case lambda = 0 by taking the limit\n            b = eta * t\n        else:\n            b = eta * (-np.expm1(-alpha_lambda_t)) / alpha_lambda\n\n        # Part 2: Calculate the exponent for the direct evaluation\n        u_abs_alpha = np.abs(u)**alpha\n        log_modulus_exponent = -b * u_abs_alpha\n\n        # Part 3: Direct evaluation and underflow check\n        # Calculate the modulus of the characteristic function directly\n        direct_modulus = np.exp(log_modulus_exponent)\n        \n        # Determine the underflow indicator I\n        # I=1 if direct evaluation underflows to zero, else I=0.\n        I = 1 if direct_modulus == 0.0 else 0\n\n        # Part 4: Stabilized calculation of the logarithmic magnitude L\n        # This implementation follows the damping method as described in the problem.\n        # Although L is algebraically equal to log_modulus_exponent, the point is\n        # to demonstrate the numerical procedure that avoids underflow.\n        \n        # Calculate the damping parameter delta\n        delta = rho * b\n        \n        # Calculate the modulus of the damped characteristic function\n        damped_log_modulus_exponent = -(b - delta) * u_abs_alpha\n        damped_modulus = np.exp(damped_log_modulus_exponent)\n        \n        # Check if the damped modulus itself underflows (it shouldn't for rho=0.5 and these cases)\n        if damped_modulus == 0.0:\n            # This would indicate a failure of the chosen damping parameter,\n            # but for the given problem, it provides the correct value.\n            # In such a case, the result is essentially -inf.\n            # We fall back to the direct exponent calculation.\n            L = log_modulus_exponent\n        else:\n            # Recover the true log modulus from the damped version\n            # L = log(|phi_damped|) - delta * |u|^alpha\n            L = np.log(damped_modulus) - delta * u_abs_alpha\n        \n        results.extend([I, L])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"}]}