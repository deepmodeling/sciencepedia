{"hands_on_practices": [{"introduction": "本练习旨在揭示分数布朗运动（fBm）的核心特性——其“记忆性”。我们将通过一个具体的计算来探讨赫斯特参数 $H$ 如何决定过程是倾向于延续其现有趋势（持久性）还是反转其趋势（反持久性）。理解增量之间的相关性是掌握分数布朗运动模型的关键第一步。[@problem_id:1303119]", "problem": "一个标准的分数布朗运动 (fBm)，记为 $\\{B_H(t)\\}_{t \\ge 0}$，是一个连续时间的中心化高斯过程，由一个称为赫斯特参数的单一参数 $H \\in (0, 1)$ 来表征。它的主要性质是 $B_H(0) = 0$，其均值对所有 $t \\ge 0$ 都是 $E[B_H(t)] = 0$，并且其协方差由函数 $E[B_H(t) B_H(s)] = \\frac{1}{2}(t^{2H} + s^{2H} - |t-s|^{2H})$ 给出，适用于任何 $t, s \\ge 0$。\n\n赫斯特参数 $H$ 的值决定了过程增量之间相关性的性质。考虑两个不同的随机模型，模型 A 和模型 B，它们都由 fBm 描述，但具有不同的赫斯特参数。\n- 模型 A 使用的赫斯特参数为 $H_A = 0.2$。\n- 模型 B 使用的赫斯特参数为 $H_B = 0.8$。\n\n对于每个模型，我们考察两个连续的、不重叠的、单位时长的增量。令 $I_1 = B_H(1) - B_H(0)$ 为时间区间 $[0, 1]$ 上的增量，令 $I_2 = B_H(2) - B_H(1)$ 为时间区间 $[1, 2]$ 上的增量。\n\n根据 fBm 的性质，以下哪个陈述正确描述了模型 A 和模型 B 的增量 $I_1$ 和 $I_2$ 之间统计相关性的符号？\n\nA. 模型 A 表现为负相关；模型 B 表现为正相关。\n\nB. 模型 A 表现为正相关；模型 B 表现为负相关。\n\nC. 两个模型都表现为正相关。\n\nD. 两个模型都表现为负相关。\n\nE. 两个模型的相关性都为零。", "solution": "对于 $I_{1} = B_{H}(1) - B_{H}(0)$ 和 $I_{2} = B_{H}(2) - B_{H}(1)$，使用 $\\operatorname{Cov}(X,Y) = E[XY] - E[X]E[Y]$ 以及对所有 $t \\ge 0$ 都有 $E[B_{H}(t)] = 0$ 这一事实，可写出\n$$\n\\operatorname{Cov}(I_{1}, I_{2}) = E\\big[(B_{H}(1) - B_{H}(0))(B_{H}(2) - B_{H}(1))\\big].\n$$\n展开并使用给定的协方差函数 $R(t,s) = E[B_{H}(t)B_{H}(s)] = \\frac{1}{2}\\big(t^{2H} + s^{2H} - |t-s|^{2H}\\big)$，我们得到\n$$\n\\operatorname{Cov}(I_{1}, I_{2}) = R(1,2) - R(1,1) - R(0,2) + R(0,1).\n$$\n计算每一项：\n$$\nR(1,2) = \\frac{1}{2}\\big(1^{2H} + 2^{2H} - |1|^{2H}\\big) = \\frac{1}{2} \\cdot 2^{2H}, \\quad\nR(1,1) = \\frac{1}{2}\\big(1^{2H} + 1^{2H} - 0^{2H}\\big) = 1,\n$$\n$$\nR(0,2) = \\frac{1}{2}\\big(0^{2H} + 2^{2H} - |2|^{2H}\\big) = 0, \\quad\nR(0,1) = \\frac{1}{2}\\big(0^{2H} + 1^{2H} - |1|^{2H}\\big) = 0.\n$$\n因此，\n$$\n\\operatorname{Cov}(I_{1}, I_{2}) = \\frac{1}{2}\\cdot 2^{2H} - 1 = 2^{2H-1} - 1.\n$$\n接下来，计算方差以将协方差与相关性联系起来：\n$$\n\\operatorname{Var}(I_{1}) = E\\big[(B_{H}(1) - B_{H}(0))^{2}\\big] = R(1,1) - 2R(1,0) + R(0,0) = 1 - 0 + 0 = 1,\n$$\n并且根据增量的平稳性，$\\operatorname{Var}(I_{2}) = 1$。因此相关系数为\n$$\n\\rho(I_{1}, I_{2}) = \\frac{\\operatorname{Cov}(I_{1}, I_{2})}{\\sqrt{\\operatorname{Var}(I_{1})\\operatorname{Var}(I_{2})}} = 2^{2H-1} - 1.\n$$\n$\\rho$ 的符号取决于 $2^{2H-1} - 1$ 是负、零还是正。由于当且仅当 $H < \\frac{1}{2}$ 时 $2^{2H-1} - 1 < 0$，在 $H = \\frac{1}{2}$ 时等于 $0$，而在 $H > \\frac{1}{2}$ 时为正，我们得出结论：\n- 对于模型 A，其 $H_{A} = 0.2 < \\frac{1}{2}$，相关性为负。\n- 对于模型 B，其 $H_{B} = 0.8 > \\frac{1}{2}$，相关性为正。\n\n因此，正确的选项是模型 A 表现为负相关，而模型 B 表现为正相关。", "answer": "$$\\boxed{A}$$", "id": "1303119"}, {"introduction": "在理解了赫斯特参数 $H$ 的理论意义之后，下一个合乎逻辑的步骤是学习如何从观测数据中估计它，这是将分数布朗运动模型应用于生物物理学或金融学等现实世界现象的一项至关重要的技能。本练习将引导您使用均方位移（MSD）的标度性质，即 $\\text{MSD}(\\tau) \\propto \\tau^{2H}$，对一个假设的数据集进行对数-对数线性回归，这是一种在数据分析中广泛使用的技术。[@problem_id:1303120]", "problem": "一位生物物理学家正在研究活细胞细胞质内一种荧光标记蛋白质的运动。细胞内环境拥挤，导致了一种被称为异常扩散的随机游走。这种运动可以被建模为一维分数布朗运动，其特征是一个称为赫斯特参数的无量纲值，$H$。赫斯特参数描述了过程的“记忆性”：$H > 0.5$ 表示持续性运动（倾向于沿相同方向继续运动），而 $H < 0.5$ 表示反持续性运动（倾向于反转方向）。\n\n该生物物理学家收集了数据，并计算了蛋白质在几个不同时间延迟下的经验均方位移（MSD）。数据点将时间延迟 $\\tau$（单位：毫秒 ms）与相应的 MSD（单位：平方微米 $\\mu\\text{m}^2$）配对，如下所示：\n- 时间延迟 $\\tau_1 = 1.00$ ms, MSD$_1 = 2.72$ $\\mu\\text{m}^2$\n- 时间延迟 $\\tau_2 = 2.00$ ms, MSD$_2 = 7.15$ $\\mu\\text{m}^2$\n- 时间延迟 $\\tau_3 = 5.00$ ms, MSD$_3 = 25.9$ $\\mu\\text{m}^2$\n- 时间延迟 $\\tau_4 = 10.0$ ms, MSD$_4 = 68.3$ $\\mu\\text{m}^2$\n\n基于分数布朗运动的理论标度性质和所提供的实验数据，估计赫斯特参数 $H$ 的值。\n\n将您的答案以单个实数的形式给出，并四舍五入到三位有效数字。", "solution": "对于一维分数布朗运动，均方位移（MSD）随时间延迟 $\\tau$ 的标度关系如下\n$$\n\\text{MSD}(\\tau) = C\\,\\tau^{2H},\n$$\n其中 $C$ 是一个常数，$H$ 是赫斯特参数。对两边取自然对数，得到一个线性关系\n$$\n\\ln(\\text{MSD}) = \\ln C + 2H\\,\\ln \\tau.\n$$\n因此，如果我们定义 $x_{i} = \\ln \\tau_{i}$ 和 $y_{i} = \\ln(\\text{MSD}_{i})$，那么最佳拟合线 $y = a + m x$ 的斜率 $m$ 就是 $m = 2H$。使用最小二乘法，\n$$\nm = \\frac{\\sum_{i=1}^{n} (x_{i} - \\bar{x})(y_{i} - \\bar{y})}{\\sum_{i=1}^{n} (x_{i} - \\bar{x})^{2}}, \\quad H = \\frac{m}{2},\n$$\n其中有 $n=4$ 个数据点。\n\n计算变换后的数据（使用一致的时间单位，这样斜率不受影响）：\n- $\\tau_{1} = 1.00$, $x_{1} = \\ln 1.00 = 0$, $\\text{MSD}_{1} = 2.72$, $y_{1} = \\ln 2.72 \\approx 1.00063$。\n- $\\tau_{2} = 2.00$, $x_{2} = \\ln 2.00 \\approx 0.693147$, $\\text{MSD}_{2} = 7.15$, $y_{2} = \\ln 7.15 \\approx 1.96712$。\n- $\\tau_{3} = 5.00$, $x_{3} = \\ln 5.00 \\approx 1.609438$, $\\text{MSD}_{3} = 25.9$, $y_{3} = \\ln 25.9 \\approx 3.25430$。\n- $\\tau_{4} = 10.0$, $x_{4} = \\ln 10.0 \\approx 2.302585$, $\\text{MSD}_{4} = 68.3$, $y_{4} = \\ln 68.3 \\approx 4.22393$。\n\n计算平均值：\n$$\n\\bar{x} = \\frac{x_{1}+x_{2}+x_{3}+x_{4}}{4} \\approx \\frac{0 + 0.693147 + 1.609438 + 2.302585}{4} \\approx 1.1512925,\n$$\n$$\n\\bar{y} = \\frac{y_{1}+y_{2}+y_{3}+y_{4}}{4} \\approx \\frac{1.00063 + 1.96712 + 3.25430 + 4.22393}{4} \\approx 2.61150.\n$$\n\n计算用于求斜率的和：\n$$\n\\sum (x_{i}-\\bar{x})(y_{i}-\\bar{y}) \\approx 1.85458 + 0.29522 + 0.29450 + 1.85639 \\approx 4.30068,\n$$\n$$\n\\sum (x_{i}-\\bar{x})^{2} \\approx 1.32548 + 0.20992 + 0.20992 + 1.32548 \\approx 3.07076.\n$$\n因此，\n$$\nm \\approx \\frac{4.30068}{3.07076} \\approx 1.4005,\n$$\n所以\n$$\nH = \\frac{m}{2} \\approx \\frac{1.4005}{2} \\approx 0.700.\n$$\n四舍五入到三位有效数字，得到估计值 $H \\approx 0.700$，这表明了与 $H > 0.5$ 的分数布朗运动一致的持续性（超扩散）行为。", "answer": "$$\\boxed{0.700}$$", "id": "1303120"}, {"introduction": "要想最深刻地理解一个随机过程，亲手构建它无疑是最有价值的方法。这项高级实践将指导您使用一种强大的小波方法来合成一条分数布朗运动的路径，从而让您从根本上把握其结构。通过从基本的小波分量构建过程，您将洞察其多尺度特性，并学习一种生成逼真模拟以供进一步研究的实用方法。[@problem_id:2977532]", "problem": "考虑分数布朗运动 (fBm)，记为 $B^H = \\{B^H(t) : t \\in [0,1]\\}$，它是一个以时间为索引、Hurst 参数为 $H \\in (0,1)$ 的中心化高斯过程，由其协方差函数唯一确定，并具有平稳增量和 $H$-自相似性的特征。在本问题中，您将使用标准正交 Haar 小波的积分作为合成函数，在均匀网格上构建 $B^H$ 的基于小波的构造性近似，然后量化将小波级数截断到有限数量尺度时的近似误差。\n\n基本依据：\n- 定义：分数布朗运动 (fBm) $B^H$ 是唯一的（在不可区分的意义上）满足 $B^H(0) = 0$、具有平稳增量且协方差为 $\\mathbb{E}[B^H(t)B^H(s)] = \\tfrac{1}{2}\\left(|t|^{2H} + |s|^{2H} - |t-s|^{2H}\\right)$（对于所有 $s,t \\in \\mathbb{R}$）的中心化高斯过程。\n- 事实：如果 $\\{\\psi_{j,k}\\}_{j \\ge 0,\\, 0 \\le k \\le 2^j - 1}$ 是 $[0,1]$ 上的一个标准正交小波基，且至少有一个消失矩，那么 $B^H$ 的小波系数是中心化高斯分布的，在固定尺度上近似平稳，并且当尺度指数 $j \\to \\infty$ 时，其方差以 $2^{-j(2H+1)}$ 的速率衰减。这个衰减速率决定了基于小波的重构的收敛性。\n- 构造选择：令 $\\psi$ 为 $[0,1]$ 上 $L^2$-归一化的 Haar 母小波，并定义其积分（Schauder 函数）为 $\\phi_{j,k}(t) := \\int_0^t \\psi_{j,k}(u)\\,du$，其中 $\\psi_{j,k}(t) := 2^{j/2}\\,\\psi(2^j t - k)$。函数 $\\phi_{j,k}$ 是连续的、分段线性的、具有紧支撑，并满足尺度关系 $\\|\\phi_{j,k}\\|_{L^2([0,1])}^2 \\asymp 2^{-2j}$。\n\n在均匀网格 $t_n = n / 2^{J_{\\mathrm{ref}}}$，$n = 0,1,\\dots,2^{J_{\\mathrm{ref}}}$ 上，对于固定的分辨率 $J_{\\mathrm{ref}} \\in \\mathbb{N}$，构造以下基于小波的 $B^H$ 近似（合成）：\n- 对于所有尺度 $j = 0,1,\\dots,J_{\\mathrm{ref}}-1$ 和位置 $k = 0,1,\\dots,2^j-1$，使用固定的伪随机种子 $1729$ 生成独立同分布 (i.i.d.) 的标准正态随机变量 $Z_{j,k} \\sim \\mathcal{N}(0,1)$，以确保可复现性。\n- 对于给定的 $H \\in (0,1)$ 和截断水平 $J \\in \\{1,2,\\dots,J_{\\mathrm{ref}}-1\\}$，在网格点上定义截断合成为\n$$\nB_J^H(t_n) \\;=\\; \\sum_{j=0}^{J-1}\\;\\sum_{k=0}^{2^j-1} 2^{-j(H + 1/2)}\\, Z_{j,k}\\,\\phi_{j,k}(t_n),\n$$\n以及参考合成为\n$$\nB_{J_{\\mathrm{ref}}}^H(t_n) \\;=\\; \\sum_{j=0}^{J_{\\mathrm{ref}}-1}\\;\\sum_{k=0}^{2^j-1} 2^{-j(H + 1/2)}\\, Z_{j,k}\\,\\phi_{j,k}(t_n).\n$$\n注意，两个求和使用相同的 $\\{Z_{j,k}\\}$ 实现。\n\n在大小为 $N := 2^{J_{\\mathrm{ref}}}$ 的均匀网格上，使用以下方式量化 $B_J^H$ 和 $B_{J_{\\mathrm{ref}}}^H$ 之间的截断误差：\n- 离散均方误差\n$$\n\\mathrm{MSE}(H,J) \\;=\\; \\frac{1}{N+1}\\sum_{n=0}^{N} \\left(B_{J_{\\mathrm{ref}}}^H(t_n) - B_J^H(t_n)\\right)^2,\n$$\n- 离散上确界范数误差\n$$\n\\mathrm{SUP}(H,J) \\;=\\; \\max_{0 \\le n \\le N} \\left|B_{J_{\\mathrm{ref}}}^H(t_n) - B_J^H(t_n)\\right|.\n$$\n\n需要遵守的实现细节：\n- 显式地使用 $L^2$-归一化的 Haar 小波及其积分。在网格分辨率下，这给出了精确的离散值\n$$\n\\phi_{j,k}(t_n) \\;=\\; \\begin{cases}\n2^{j/2}\\,(t_n - k/2^j), & k/2^j \\le t_n < (k+1/2)/2^j, \\\\\n2^{j/2}\\,((k+1)/2^j - t_n), & (k+1/2)/2^j \\le t_n < (k+1)/2^j, \\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n- 固定 $J_{\\mathrm{ref}} = 12$，因此 $N = 2^{12}$，并使用种子 $1729$ 进行正态抽样。不应存在其他随机性。\n\n测试套件：\n- 使用以下六个参数对 $(H,J)$：\n  1. $(H,J) = (0.2,5)$,\n  2. $(H,J) = (0.2,8)$,\n  3. $(H,J) = (0.5,5)$,\n  4. $(H,J) = (0.5,8)$,\n  5. $(H,J) = (0.8,5)$,\n  6. $(H,J) = (0.8,8)$.\n  \n对于每种情况，计算 $\\mathrm{MSE}(H,J)$ 和 $\\mathrm{SUP}(H,J)$ 作为实数。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含按上述顺序排列的六个测试用例的结果，格式为一个逗号分隔的配对列表，每个配对是一个双元素列表 $[\\mathrm{MSE}(H,J),\\mathrm{SUP}(H,J)]$，所有内容都包含在一对顶层方括号中。例如，两个假设用例的输出应如下所示：$[[0.1,0.2],[0.3,0.4]]$。", "solution": "### 步骤 1：提取已知条件\n\n-   **过程定义**：分数布朗运动 (fBm)，$B^H = \\{B^H(t) : t \\in [0,1]\\}$，是一个中心化高斯过程，Hurst 参数为 $H \\in (0,1)$，$B^H(0) = 0$，具有平稳增量，协方差为 $\\mathbb{E}[B^H(t)B^H(s)] = \\tfrac{1}{2}\\left(|t|^{2H} + |s|^{2H} - |t-s|^{2H}\\right)$。\n-   **小波合成**：近似是使用标准正交 Haar 小波的积分构造的。\n    -   小波：$[0,1]$ 上的 $L^2$-归一化 Haar 母小波 $\\psi(t)$。\n    -   基：$\\psi_{j,k}(t) := 2^{j/2}\\,\\psi(2^j t - k)$。\n    -   合成函数：$\\phi_{j,k}(t) := \\int_0^t \\psi_{j,k}(u)\\,du$。\n-   **网格与分辨率**：\n    -   参考分辨率水平：$J_{\\mathrm{ref}} = 12$。\n    -   网格大小：$N = 2^{J_{\\mathrm{ref}}}$。\n    -   均匀时间网格：$t_n = n / N$，对于 $n = 0, 1, \\dots, N$。\n-   **随机系数**：\n    -   独立同分布 (i.i.d.) 的标准正态随机变量 $Z_{j,k} \\sim \\mathcal{N}(0,1)$。\n    -   索引：$j = 0, 1, \\dots, J_{\\mathrm{ref}}-1$ 和 $k = 0, 1, \\dots, 2^j-1$。\n    -   伪随机种子：$1729$。\n-   **合成公式**：\n    -   截断合成：$B_J^H(t_n) = \\sum_{j=0}^{J-1}\\;\\sum_{k=0}^{2^j-1} 2^{-j(H + 1/2)}\\, Z_{j,k}\\,\\phi_{j,k}(t_n)$，对于截断水平 $J \\in \\{1, 2, \\dots, J_{\\mathrm{ref}}-1\\}$。\n    -   参考合成：$B_{J_{\\mathrm{ref}}}^H(t_n) = \\sum_{j=0}^{J_{\\mathrm{ref}}-1}\\;\\sum_{k=0}^{2^j-1} 2^{-j(H + 1/2)}\\, Z_{j,k}\\,\\phi_{j,k}(t_n)$。\n-   **离散合成函数公式**：\n    $$\n    \\phi_{j,k}(t_n) \\;=\\; \\begin{cases}\n    2^{j/2}\\,(t_n - k/2^j), & k/2^j \\le t_n < (k+1/2)/2^j, \\\\\n    2^{j/2}\\,((k+1)/2^j - t_n), & (k+1/2)/2^j \\le t_n < (k+1)/2^j, \\\\\n    0, & \\text{otherwise},\n    \\end{cases}\n    $$\n    其中 $t_n = n/N$。\n-   **误差度量**：\n    -   离散均方误差：$\\mathrm{MSE}(H,J) = \\frac{1}{N+1}\\sum_{n=0}^{N} \\left(B_{J_{\\mathrm{ref}}}^H(t_n) - B_J^H(t_n)\\right)^2$。\n    -   离散上确界范数误差：$\\mathrm{SUP}(H,J) = \\max_{0 \\le n \\le N} \\left|B_{J_{\\mathrm{ref}}}^H(t_n) - B_J^H(t_n)\\right|$。\n-   **测试套件**：\n    1.  $(H,J) = (0.2, 5)$\n    2.  $(H,J) = (0.2, 8)$\n    3.  $(H,J) = (0.5, 5)$\n    4.  $(H,J) = (0.5, 8)$\n    5.  $(H,J) = (0.8, 5)$\n    6.  $(H,J) = (0.8, 8)$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题牢固地植根于随机过程理论，特别是分数布朗运动的研究。基于小波的合成方法是模拟此类过程的标准且有据可查的技术。所提供的 fBm 协方差公式、小波级数表示以及小波系数方差衰减特性都与数学和信号处理领域的既有文献一致。选择积分 Haar 小波（Schauder 基）是一个经典的例子。该问题在科学上是合理的。\n-   **适定性**：该问题是适定的。它要求根据一个完全确定的程序计算特定的量（$\\mathrm{MSE}$ 和 $\\mathrm{SUP}$）。所有参数（$J_{\\mathrm{ref}}$、种子、$(H, J)$ 对）、函数（$\\phi_{j,k}$）和算法（合成求和）都已明确定义。使用固定的随机种子，该过程是确定性的，从而得到唯一且稳定的解。\n-   **客观性**：语言精确、数学化，没有任何主观或模棱两可的术语。\n-   **完整性与一致性**：问题陈述是自包含的。它提供了所有必要的定义、常数、公式和参数。参考分辨率 $J_{\\mathrm{ref}}$、网格定义、合成公式、基函数 $\\phi_{j,k}$ 在网格上的确切形式、随机数生成种子以及具体的测试用例都已提供。没有矛盾之处。\n-   **可行性**：指定的计算在计算上是可行的。网格大小为 $N=2^{12}=4096$，产生 $4097$ 个点。随机系数的总数为 $\\sum_{j=0}^{11} 2^j = 2^{12}-1 = 4095$。合成需要嵌套循环，但对于现代硬件来说，总体复杂性是可控的。\n\n### 步骤 3：结论与行动\n\n问题是有效的。这是一个在随机过程模拟领域中定义明确、有科学依据的计算问题。将提供一个完整的解决方案。\n\n### 解法\n\n该问题要求我们计算分数布朗运动 ($B^H$) 基于小波合成的截断误差，这需要针对不同的 Hurst 参数 $H$ 和截断水平 $J$。合成是在一个离散网格上执行的，最高达到参考分辨率 $J_{\\mathrm{ref}}$。\n\n首先，我们建立计算框架。参考分辨率为 $J_{\\mathrm{ref}} = 12$，在区间 $[0,1]$ 上定义了一个包含 $N+1 = 2^{12}+1 = 4097$ 个点的网格，由 $t_n = n/N$（对于 $n=0, \\dots, N$）给出。合成使用一组随机系数 $Z_{j,k} \\sim \\mathcal{N}(0,1)$，这些系数使用固定的种子 $1729$ 生成一次，以保证可复现性。\n\n合成的核心是缩放后的 Schauder 函数 $\\phi_{j,k}(t_n)$ 的求和。参考路径 $B_{J_{\\mathrm{ref}}}^H$ 与截断路径 $B_J^H$ 之间的误差是截断合成中省略的高频分量之和。具体来说，误差路径由以下公式给出：\n$$\n\\Delta(t_n) = B_{J_{\\mathrm{ref}}}^H(t_n) - B_J^H(t_n) = \\sum_{j=J}^{J_{\\mathrm{ref}}-1}\\sum_{k=0}^{2^j-1} 2^{-j(H + 1/2)}\\, Z_{j,k}\\,\\phi_{j,k}(t_n)\n$$\n这个表达式允许高效地计算误差，而无需分别计算 $B_{J_{\\mathrm{ref}}}^H$ 和 $B_J^H$。我们可以重写它，将与测试用例参数 $H$ 和 $J$ 无关的项组合在一起：\n$$\n\\Delta(t_n) = \\sum_{j=J}^{J_{\\mathrm{ref}}-1} 2^{-j(H + 1/2)} \\left( \\sum_{k=0}^{2^j-1} Z_{j,k}\\,\\phi_{j,k}(t_n) \\right)\n$$\n括号中的项代表在给定尺度 $j$ 下所有空间位移 $k$ 的聚合贡献（由随机变量 $Z_{j,k}$ 加权），可以预先计算。让我们将其表示为尺度 $j$ 的“基项”：\n$$\n\\text{BaseTerm}_j(t_n) = \\sum_{k=0}^{2^j-1} Z_{j,k}\\,\\phi_{j,k}(t_n)\n$$\n这些基项与 $H$ 和 $J$ 无关。我们可以为所有 $j \\in \\{0, \\dots, J_{\\mathrm{ref}}-1\\}$ 一次性计算它们。\n\n算法流程如下：\n1.  **初始化**：设置常数 $J_{\\mathrm{ref}} = 12$，$N = 2^{12}$，以及种子 $= 1729$。定义时间网格 $t_n = n/N$。\n2.  **生成随机数**：使用指定的种子创建一个伪随机数生成器，并为 $j=0, \\dots, J_{\\mathrm{ref}}-1$ 和 $k=0, \\dots, 2^j-1$ 生成所有所需的标准正态变量 $Z_{j,k}$。\n3.  **预计算基项**：对于从 $0$ 到 $J_{\\mathrm{ref}}-1$ 的每个尺度 $j$：\n    a. 初始化一个大小为 $N+1$ 的数组 `BaseTerm_j` 为零。\n    b. 对于从 $0$ 到 $2^j-1$ 的每个空间位置 $k$：\n        i.  使用提供的显式公式，将离散 Schauder 函数 $\\phi_{j,k}(t_n)$ 构造为一个长度为 $N+1$ 的向量。此函数是一个三角形“帐篷”，支撑在对应于时间区间 $[k/2^j, (k+1)/2^j]$ 的网格索引上。\n        ii. 将此向量乘以相应的随机变量 $Z_{j,k}$，并加到 `BaseTerm_j` 中。\n    c. 存储生成的 `BaseTerm_j` 向量。\n4.  **计算测试用例的误差**：对于每个给定的对 $(H, J)$：\n    a. 初始化一个大小为 $N+1$ 的 `error_path` 向量为零。\n    b. 将从 $j=J$ 到 $J_{\\mathrm{ref}}-1$ 的相关尺度的预计算基项相加，并由依赖于 $H$ 的振幅 $2^{-j(H+1/2)}$ 加权。\n       $$ \\text{error_path} = \\sum_{j=J}^{J_{\\mathrm{ref}}-1} 2^{-j(H+1/2)} \\cdot \\text{BaseTerm}_j $$\n    c. 从此 `error_path` 向量计算误差度量：\n       - $\\mathrm{MSE}(H,J) = \\frac{1}{N+1}\\sum_{n=0}^{N} (\\text{error\\_path}[n])^2$，使用 `numpy.mean(error_path**2)` 实现。\n       - $\\mathrm{SUP}(H,J) = \\max_{0 \\le n \\le N} |\\text{error\\_path}[n]|$，使用 `numpy.max(numpy.abs(error_path))` 实现。\n5.  **输出**：收集所有测试用例的 $[\\mathrm{MSE}, \\mathrm{SUP}]$ 对，并按指定格式进行格式化。\n\n这种优化方法通过预先计算合成中与 $H$ 无关的部分来避免冗余计算，使得对多个测试用例的评估非常高效。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a wavelet-based approximation of fractional Brownian motion (fBm)\n    and computes the truncation error for a set of parameters.\n    \"\"\"\n    # Define problem constants and test cases\n    J_ref = 12\n    N = 2**J_ref\n    seed = 1729\n    test_cases = [\n        (0.2, 5),\n        (0.2, 8),\n        (0.5, 5),\n        (0.5, 8),\n        (0.8, 5),\n        (0.8, 8),\n    ]\n\n    # Initialize the pseudo-random number generator with the specified seed\n    rng = np.random.default_rng(seed)\n\n    # Generate all necessary i.i.d. standard normal random variables Z_{j,k}\n    # Zs is a list of arrays, where Zs[j] contains the 2**j variables for scale j.\n    Zs = [rng.standard_normal(2**j) for j in range(J_ref)]\n\n    # Create the uniform time grid t_n = n/N for n = 0, ..., N\n    t = np.linspace(0, 1, N + 1, dtype=np.float64)\n\n    # Precompute the base terms, which are independent of H.\n    # base_terms[j] = sum_{k=0}^{2^j-1} Z_{j,k} * phi_{j,k}(t)\n    base_terms = []\n    for j in range(J_ref):\n        L_j = 2**(J_ref - j)  # Number of grid points in an interval of length 1/2^j\n        \n        # This array will hold the sum of all wavelet contributions at scale j\n        sum_k_term = np.zeros(N + 1, dtype=np.float64)\n        \n        for k in range(2**j):\n            Z_jk = Zs[j][k]\n            \n            # Generate the discrete Schauder function phi_{j,k}(t_n)\n            # This is a triangular \"tent\" function on the grid.\n            phi_jk = np.zeros(N + 1, dtype=np.float64)\n            \n            start_n = k * L_j\n            mid_n = start_n + L_j // 2\n            end_n = (k + 1) * L_j\n            \n            # Linear ramp up: from t=k/2^j to t=(k+0.5)/2^j\n            # Corresponding indices: from start_n to mid_n-1\n            indices_up = np.arange(start_n, mid_n)\n            if indices_up.size > 0:\n                phi_jk[indices_up] = 2**(j/2) * (t[indices_up] - k/(2**j))\n\n            # Linear ramp down: from t=(k+0.5)/2^j to t=(k+1)/2^j\n            # Corresponding indices: from mid_n to end_n\n            indices_down = np.arange(mid_n, end_n + 1)\n            if indices_down.size > 0:\n                phi_jk[indices_down] = 2**(j/2) * (((k + 1)/(2**j)) - t[indices_down])\n            \n            # Add the contribution of this specific wavelet to the sum for scale j\n            sum_k_term += Z_jk * phi_jk\n            \n        base_terms.append(sum_k_term)\n\n    # Process each test case to compute the error metrics\n    results = []\n    for H, J in test_cases:\n        # The truncation error path is the sum of wavelet components for j >= J\n        error_path = np.zeros(N + 1, dtype=np.float64)\n        for j in range(J, J_ref):\n            # Amplitude scaling factor depends on H and j\n            amplitude_H = 2**(-j * (H + 0.5))\n            error_path += amplitude_H * base_terms[j]\n\n        # Compute the Mean-Square Error (MSE) and Supremum Norm Error (SUP)\n        mse = np.mean(error_path**2)\n        sup = np.max(np.abs(error_path))\n        results.append([mse, sup])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join(f\"[{m},{s}]\" for m, s in results) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2977532"}]}