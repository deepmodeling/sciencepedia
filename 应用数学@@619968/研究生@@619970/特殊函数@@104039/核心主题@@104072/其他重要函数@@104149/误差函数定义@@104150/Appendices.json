{"hands_on_practices": [{"introduction": "本次练习将介绍一种强有力的技巧，用于简化包含像误差函数 $\\operatorname{erf}(x)$ 这样由积分定义的函数的积分。通过将 $\\operatorname{erf}(\\beta x)$ 的定义代入主积分，我们得到了一个二重积分。这里的关键洞察在于，通过策略性地交换积分顺序，一个看似棘手的问题可以转化为两个依次求解的、更简单的积分。这个练习 [@problem_id:782682] 有助于熟练掌握处理多重积分的技巧，这是高等物理和工程学中的一项基石技能。", "problem": "误差函数，记作 $\\operatorname{erf}(z)$，是一个由积分定义的复变特殊函数：\n$$ \\operatorname{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} dt $$\n此函数在概率论、统计学以及描述扩散过程的偏微分方程研究中应用广泛。\n\n一个涉及高斯函数的有用定积分是高斯积分：\n$$ \\int_0^\\infty e^{-k x^2} dx = \\frac{1}{2}\\sqrt{\\frac{\\pi}{k}} \\quad (k>0) $$\n考虑一个由幂函数、高斯函数和误差函数的乘积构成的定积分 $I$：\n$$ I = \\int_0^\\infty x e^{-\\alpha x^2} \\operatorname{erf}(\\beta x) dx $$\n其中 $\\alpha$ 和 $\\beta$ 为正实常数。\n\n请计算此积分 $I$，并用参数 $\\alpha$ 和 $\\beta$ 将结果表示为闭式。", "solution": "我们从定义出发\n$$\\operatorname{erf}(z)=\\frac{2}{\\sqrt\\pi}\\int_0^z e^{-t^2}\\,dt$$  \n于是\n$$I=\\int_0^\\infty x e^{-\\alpha x^2}\\operatorname{erf}(\\beta x)\\,dx\n=\\frac{2}{\\sqrt\\pi}\\int_0^\\infty x e^{-\\alpha x^2}\\Bigl(\\int_0^{\\beta x}e^{-t^2}dt\\Bigr)dx.$$  \n交换积分次序：对于 $x\\ge0$，有 $0\\le t\\le\\beta x\\iff t\\ge0,\\;x\\ge t/\\beta$。因此\n$$I=\\frac{2}{\\sqrt\\pi}\\int_{t=0}^\\infty\\int_{x=t/\\beta}^\\infty x e^{-\\alpha x^2}e^{-t^2}dx\\,dt.$$  \n计算内层积分，设 $a=t/\\beta$：\n$$\\int_a^\\infty x e^{-\\alpha x^2}dx\n=-\\frac{1}{2\\alpha}e^{-\\alpha x^2}\\Big|_{a}^{\\infty}\n=\\frac{1}{2\\alpha}e^{-\\alpha a^2}\n=\\frac{1}{2\\alpha}e^{-\\alpha t^2/\\beta^2}.$$  \n因此\n$$I=\\frac{2}{\\sqrt\\pi}\\cdot\\frac{1}{2\\alpha}\\int_0^\\infty e^{-t^2}e^{-\\alpha t^2/\\beta^2}dt\n=\\frac{1}{\\alpha\\sqrt\\pi}\\int_0^\\infty e^{-t^2\\frac{\\alpha+\\beta^2}{\\beta^2}}\\,dt.$$  \n利用 $\\int_0^\\infty e^{-c t^2}dt=\\frac12\\sqrt{\\frac\\pi c}$，并令 $c=(\\alpha+\\beta^2)/\\beta^2$，可得\n$$I\n=\\frac{1}{\\alpha\\sqrt\\pi}\\cdot\\frac12\\sqrt{\\frac{\\pi\\beta^2}{\\alpha+\\beta^2}}\n=\\frac{\\beta}{2\\alpha\\sqrt{\\alpha+\\beta^2}}\\,. $$", "answer": "$$\\boxed{\\frac{\\beta}{2\\alpha\\sqrt{\\alpha+\\beta^2}}}$$", "id": "782682"}, {"introduction": "我们的第二次练习将展示一种完全不同但同样优雅的分析方法，即积分符号下微分法，也被称为费曼技巧。我们不直接处理原积分，而是引入一个参数，并对整个积分就此参数求导。这个巧妙的步骤可以极大地简化被积函数，从而得到一个易于求解的积分，我们再将其积分回去，便可得到原问题的解。这个问题 [@problem_id:782549] 揭示了理论科学中经常需要的创造性思维，并为你的数学工具箱增添了一件利器。", "problem": "误差函数，记作 $\\operatorname{erf}(x)$，是一个非初等函数，它出现于概率论、统计学以及偏微分方程的求解中。它由以下积分定义：\n$$\n\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt\n$$\n误差函数是一个奇函数，且有 $\\operatorname{erf}(0) = 0$ 以及 $\\lim_{x\\to\\infty} \\operatorname{erf}(x) = 1$。前置因子 $\\frac{2}{\\sqrt{\\pi}}$ 是一个归一化常数，它确保了该极限值为 1。\n\n你的任务是计算以下定积分，该积分涉及一个高斯函数与误差函数的乘积。\n\n计算积分 $I$ 的值：\n$$\nI = \\int_0^\\infty e^{-x^2} \\operatorname{erf}(x) dx\n$$", "solution": "1. 定义辅助积分\n$$\nJ(a)=\\int_{0}^{\\infty}e^{-x^{2}}\\operatorname{erf}(a x)\\,dx.\n$$\n2. 在积分号下求导：\n$$\n\\frac{dJ}{da}\n=\\int_{0}^{\\infty}e^{-x^{2}}\\frac{d}{da}\\operatorname{erf}(a x)\\,dx\n=\\int_{0}^{\\infty}e^{-x^{2}}\\frac{2}{\\sqrt\\pi}\\,x\\,e^{-a^{2}x^{2}}\\,dx\n=\\frac{2}{\\sqrt\\pi}\\int_{0}^{\\infty}x\\,e^{-(1+a^{2})x^{2}}\\,dx.\n$$\n3. 计算高斯积分：\n$$\n\\int_{0}^{\\infty}x\\,e^{-\\beta x^{2}}\\,dx\n=\\frac{1}{2\\beta}\n\\quad\\Longrightarrow\\quad\n\\frac{dJ}{da}\n=\\frac{2}{\\sqrt\\pi}\\cdot\\frac{1}{2(1+a^{2})}\n=\\frac{1}{\\sqrt\\pi\\,(1+a^{2})}.\n$$\n4. 对 $a$ 积分：\n$$\nJ(a)\n=\\frac{1}{\\sqrt\\pi}\\arctan(a)+C.\n$$\n因为 $J(0)=0$，我们得到 $C=0$，所以\n$$\nJ(a)=\\frac{1}{\\sqrt\\pi}\\arctan(a).\n$$\n5. 所求积分为 $I=J(1)$：\n$$\nI\n=J(1)\n=\\frac{1}{\\sqrt\\pi}\\arctan(1)\n=\\frac{1}{\\sqrt\\pi}\\cdot\\frac{\\pi}{4}\n=\\frac{\\sqrt\\pi}{4}.\n$$", "answer": "$$\\boxed{\\frac{\\sqrt{\\pi}}{4}}$$", "id": "782549"}, {"introduction": "从解析解到实际计算，这最后一个练习将挑战你从误差函数的定义出发，实现一个计算它的数值算法。你将使用高斯求积法——一种高效的数值积分方法，并构建一个自适应方案以确保计算精度。这项练习 [@problem_id:2397742] 弥合了理论数学与计算科学之间的鸿沟，提供了算法设计和验证方面的实践经验，这些都是现代科学研究中不可或缺的技能。", "problem": "设计并实现一个完整、可运行的程序，该程序使用高斯求积法计算误差函数，并与可信的库实现进行验证。您的程序必须满足以下所有要求。\n\n1) 使用的基础。从标准域上权重函数的高斯求积法的核心定义以及经典多项式的正交性出发。具体而言，使用以下事实：Legendre 多项式 $P_n(x)$ 在 $[-1,1]$ 上关于权重 $w(x)=1$ 是正交的，并且高斯求积法在 $P_n(x)$ 的零点处选择节点，并配以相应的正权重，从而对最高 $2n-1$ 次的多项式实现精确积分。以此为起点，推导出一个在通用区间 $[a,b]$ 上近似定积分的规则，并通过划分区间来证明使用复合策略的合理性。在您的推导中应避免提供任何快捷积分公式；相反，只应依赖于 $P_n(x)$ 的正交性、线性变量替换的性质，以及一个经过充分检验的事实，即 $n$ 点高斯求积法在 $[-1,1]$ 上能精确积分任何最高为 $2n-1$ 次的多项式。\n\n2) 目标量。使用误差函数的定义\n$$\n\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-t^2}\\, dt,\n$$\n并通过高斯求积法计算该积分来进行数值计算。您的方法必须能处理任何实数 $x$，在 $x<0$ 时需正确设定积分方向。如果您能从积分定义出发证明误差函数 $\\operatorname{erf}(x)$ 的奇函数性质，即 $\\operatorname{erf}(-x)=-\\operatorname{erf}(x)$，则可以使用该性质。\n\n3) 算法要求。\n- 实现一个在 $[-1,1]$ 上的 $n$ 点 Gauss–Legendre 求积法则，然后通过从第一性原理推导出的线性变量替换将其映射到任意区间 $[a,b]$，并以复合方式应用于 $[a,b]$ 的子区间上。\n- 在子区间数量上使用自适应加密：从单个子区间开始，重复将子区间数量加倍，直到复合求积值的变化量在请求的绝对公差 $T_{\\mathrm{abs}}$ 加上按当前估计值缩放的相对公差 $T_{\\mathrm{rel}}$ 范围之内。两个公差都必须是您代码中用户指定的常量。\n- 通过为每个子区间选择一个合理大但固定的节点数来利用 $e^{-t^2}$ 的解析性，从而使用一个感知光滑度的规则规模。\n\n4) 与可信参考的比较。对于每个测试输入 $x$，计算三个量：高斯求积近似值 $\\widehat{\\operatorname{erf}}(x)$、来自标准库实现的参考值，以及定义为 $|\\widehat{\\operatorname{erf}}(x) - \\operatorname{erf}_{\\mathrm{ref}}(x)|$ 的绝对误差。您必须与至少一个来自科学计算库的可信函数进行比较。默认使用弧度；此计算不涉及任何物理单位。\n\n5) 测试套件。您的程序必须评估以下涵盖标称、边界和挑战性情况的输入集：\n- $x \\in \\{\\, 0,\\; 10^{-8},\\; 0.5,\\; 1.0,\\; -1.3,\\; 2.0,\\; 5.0 \\,\\}$。\n- 每个子区间使用 $n=16$ 个 Gauss–Legendre 节点。\n- 对于子区间数量的自适应加密，使用绝对公差 $T_{\\mathrm{abs}}=10^{-12}$ 和相对公差 $T_{\\mathrm{rel}}=10^{-12}$。\n\n6) 最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试输入 $x$，按顺序 $[\\widehat{\\operatorname{erf}}(x), \\operatorname{erf}_{\\mathrm{math}}(x), \\operatorname{erf}_{\\mathrm{scipy}}(x), E_{\\max}(x)]$ 输出一个包含四个浮点数的列表，其中 $\\operatorname{erf}_{\\mathrm{math}}$ 来自标准数学库，$\\operatorname{erf}_{\\mathrm{scipy}}$ 来自科学计算库，而 $E_{\\max}(x)$ 是您的近似值与两个库值之间的最大绝对差异。因此，最终行必须看起来像\n$[\\,[\\widehat{\\operatorname{erf}}(x_1), \\operatorname{erf}_{\\mathrm{math}}(x_1), \\operatorname{erf}_{\\mathrm{scipy}}(x_1), E_{\\max}(x_1)], \\ldots, [\\widehat{\\operatorname{erf}}(x_m), \\operatorname{erf}_{\\mathrm{math}}(x_m), \\operatorname{erf}_{\\mathrm{scipy}}(x_m), E_{\\max}(x_m)]\\,]$\n其前后不能有任何多余的文本。\n\n您的程序必须完全独立、具有确定性，并且不得需要任何用户输入、外部文件或网络访问。", "solution": "所述问题具有科学依据、问题明确且客观。它基于已确立的数值方法和数学定义，勾勒出了一项清晰的计算任务。要求使用自适应 Gauss-Legendre 求积方案计算误差函数是计算科学中的一个标准练习。所有参数和测试用例都已指定，推导和实现的要求明确且一致。我们注意到一个关于“弧度”的次要无关陈述，但它对问题的有效性无足轻重，将被忽略。因此，我们可以着手提供解决方案。\n\n目标是使用自定义实现的自适应高斯求积算法，为一组实数 $x$ 计算误差函数，其定义为\n$$\n\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-t^2}\\, dt\n$$\n结果将与可信的库函数进行验证。\n\n**1. Gauss-Legendre 求积法的基础**\n\n该方法的核心是用于近似在规范区间 $[-1, 1]$ 上定积分的 $n$ 点 Gauss-Legendre 求积法则。函数 $f(\\xi)$ 的积分由一个加权和来近似：\n$$\n\\int_{-1}^{1} f(\\xi) \\, d\\xi \\approx \\sum_{i=1}^{n} w_i f(\\xi_i)\n$$\n对于 Gauss-Legendre 求积法，节点 $\\xi_i$ 是 $n$ 次 Legendre 多项式 $P_n(\\xi)$ 的 $n$ 个不同实根，已知这些根位于开区间 $(-1, 1)$ 内。相应的权重 $w_i$ 均为正数，并且其选择使得该公式对于任何最高为 $2n-1$ 次的多项式都是精确的。这种高精度是 Legendre 多项式在 $[-1, 1]$ 上关于权重函数 $w(\\xi)=1$ 正交性的结果。我们在此不推导 $\\xi_i$ 和 $w_i$ 的值，因为这是一个标准结果；我们将按照常规做法，从一个可信的数值库源获取它们。\n\n**2. 任意积分区间 $[a,b]$ 的变换**\n\n为了将此规则应用于一般区间 $[a,b]$ 上的积分，我们必须执行一个线性变量替换，将 $\\xi \\in [-1, 1]$ 映射到 $t \\in [a,b]$。设此变换为 $t(\\xi) = c_1 \\xi + c_2$。我们需要 $t(-1)=a$ 和 $t(1)=b$，这为系数 $c_1$ 和 $c_2$ 提供了两个线性方程组：\n$$\n\\begin{cases}\na = -c_1 + c_2 \\\\\nb = c_1 + c_2\n\\end{cases}\n$$\n解此方程组得到 $c_1 = \\frac{b-a}{2}$ 和 $c_2 = \\frac{a+b}{2}$。因此，变换为：\n$$\nt(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}\n$$\n微分元也相应变换：$dt = \\frac{b-a}{2} d\\xi$。将此代入函数 $g(t)$ 的积分中，得到：\n$$\n\\int_{a}^{b} g(t) \\, dt = \\int_{-1}^{1} g\\left(\\frac{b-a}{2}\\xi + \\frac{a+b}{2}\\right) \\frac{b-a}{2} \\, d\\xi\n$$\n将 $n$ 点 Gauss-Legendre 求积法则应用于右侧的积分，我们得到一般区间 $[a,b]$ 的公式：\n$$\n\\int_{a}^{b} g(t) \\, dt \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i \\, g\\left(\\frac{b-a}{2}\\xi_i + \\frac{a+b}{2}\\right)\n$$\n此推导满足了从第一性原理构建通用规则的要求。\n\n**3. 复合求积与自适应加密**\n\n虽然单次应用 Gauss-Legendre 规则功能强大，但其精度取决于被积函数 $g(t)$ 在整个区间 $[a,b]$ 上能被单一的 $2n-1$ 次多项式近似的程度。对于长区间或行为多变的函数，更有效的方法是将区间 $[a,b]$ 划分成 $M$ 个更小的子区间，并对每个子区间应用求积法则。这就是复合求积法则。\n\n设区间 $[a,b]$ 被划分为 $M$ 个等宽的子区间，宽度为 $h = (b-a)/M$。第 $j$ 个子区间是 $[t_{j-1}, t_j]$，其中 $t_j = a + jh$ for $j \\in \\{1, \\dots, M\\}$。总积分是每个子区间上积分的总和：\n$$\n\\int_{a}^{b} g(t) \\, dt = \\sum_{j=1}^{M} \\int_{t_{j-1}}^{t_j} g(t) \\, dt \\approx \\sum_{j=1}^{M} \\frac{h}{2} \\sum_{i=1}^{n} w_i \\, g\\left(\\frac{h}{2}\\xi_i + \\frac{t_{j-1}+t_j}{2}\\right)\n$$\n问题要求使用一个自适应方案来确定子区间的数量 $M$。我们从少量子区间（例如 $M=1$）开始，计算积分估计值 $I_M$。然后我们将子区间的数量加倍到 $2M$，并计算新的估计值 $I_{2M}$。重复此过程，直到连续估计值之间的变化足够小。收敛准则指定为：\n$$\n|I_{2M} - I_M| \\le T_{\\mathrm{abs}} + T_{\\mathrm{rel}} |I_{2M}|\n$$\n其中 $T_{\\mathrm{abs}}$ 和 $T_{\\mathrm{rel}}$ 是绝对和相对公差，均设置为 $10^{-12}$。这确保了结果稳定在所要求的精度上。每个子区间的求积节点数 $n$ 固定为 $16$，这个选择非常适合光滑的解析被积函数 $e^{-t^2}$。\n\n**4. 应用于误差函数**\n\n目标量是 $\\operatorname{erf}(x)$。对于 $x > 0$，积分区间是 $[0,x]$。对于 $x=0$，积分显然为 $0$。对于 $x < 0$，积分上限小于下限。我们可以通过使用 $\\operatorname{erf}(x)$ 是奇函数的性质来处理这种情况，即 $\\operatorname{erf}(-x) = -\\operatorname{erf}(x)$。我们从积分定义来证明这一点。\n设 $x > 0$。则 $-x < 0$：\n$$\n\\operatorname{erf}(-x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{-x} e^{-t^2} \\, dt\n$$\n令 $u = -t$，则 $du = -dt$。积分限变为：$t=0 \\implies u=0$ 以及 $t=-x \\implies u=x$。\n$$\n\\operatorname{erf}(-x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-(-u)^2} (-du) = - \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-u^2} \\, du = -\\operatorname{erf}(x)\n$$\n该性质得证。因此，对于任何 $x<0$，我们可以计算 $\\operatorname{erf}(|x|)$ 并将结果取负。这样，计算问题就简化为对任何 $x \\neq 0$ 计算在 $[0, |x|]$ 上的积分。\n\n最终的算法如下：\n1.  对于给定的输入 $x$，处理 $x=0$ 的平凡情况。\n2.  确定 $x$ 的符号，并将积分区间设为 $[a,b] = [0, |x|]$。\n3.  获取 $n=16$ 个 Gauss-Legendre 节点 $\\xi_i$ 和权重 $w_i$。\n4.  应用上述自适应复合求积方案来近似 $I = \\int_{0}^{|x|} e^{-t^2} \\, dt$。\n5.  最终结果是 $\\widehat{\\operatorname{erf}}(x) = \\operatorname{sign}(x) \\cdot \\frac{2}{\\sqrt{\\pi}} I$。\n6.  然后将此结果与来自 `math.erf` 和 `scipy.special.erf` 的值进行比较，并计算最大绝对误差 $E_{\\max}$。\n\n问题描述中的无关指令“默认使用弧度”对于误差函数（其参数是无量纲的）是无意义的，因此被忽略。", "answer": "```python\nimport math\nimport numpy as np\nfrom scipy.special import erf as erf_scipy\nfrom scipy.special import roots_legendre\n\ndef compute_erf_quadrature(x, n, tol_abs, tol_rel):\n    \"\"\"\n    Computes the error function erf(x) using adaptive composite Gaussian quadrature.\n\n    Args:\n        x (float): The point at which to evaluate erf(x).\n        n (int): The number of Gauss-Legendre nodes per panel.\n        tol_abs (float): The absolute tolerance for convergence.\n        tol_rel (float): The relative tolerance for convergence.\n\n    Returns:\n        float: The numerical approximation of erf(x).\n    \"\"\"\n    if x == 0.0:\n        return 0.0\n\n    sign = np.sign(x)\n    b = abs(x)\n    a = 0.0\n\n    # Get Gauss-Legendre nodes and weights for the canonical interval [-1, 1]\n    xi, w = roots_legendre(n)\n\n    # Pre-calculate the integrand function\n    integrand = lambda t: np.exp(-t**2)\n\n    def compute_composite_integral(num_panels):\n        \"\"\"Helper to compute integral with a fixed number of panels.\"\"\"\n        h = (b - a) / num_panels\n        \n        # Vectorized computation of evaluation points for all panels\n        # panel_midpoints shape: (num_panels,)\n        panel_midpoints = a + h * (np.arange(num_panels) + 0.5)\n        \n        # t_eval_points shape: (n, num_panels)\n        # xi[:, np.newaxis] broadcasts over panel_midpoints\n        t_eval_points = panel_midpoints[np.newaxis, :] + (h/2) * xi[:, np.newaxis]\n        \n        # Evaluate integrand at all points\n        integrand_values = integrand(t_eval_points)\n        \n        # Apply weights and sum up contributions\n        # w[:, np.newaxis] broadcasts over integrand_values\n        integral_sum = np.sum(w[:, np.newaxis] * integrand_values)\n        \n        return (h / 2.0) * integral_sum\n\n    # Adaptive refinement loop\n    num_panels = 1\n    max_iterations = 20  # Safety break to prevent infinite loops\n\n    old_integral = compute_composite_integral(num_panels)\n\n    for _ in range(max_iterations):\n        num_panels *= 2\n        new_integral = compute_composite_integral(num_panels)\n        \n        # Check for convergence using the specified mixed tolerance\n        if abs(new_integral - old_integral) <= tol_abs + tol_rel * abs(new_integral):\n            final_integral = new_integral\n            break\n        \n        old_integral = new_integral\n    else:\n        # This part is executed if the loop finishes without a 'break'\n        raise RuntimeError(f\"Adaptive quadrature did not converge for x={x} within {max_iterations} iterations.\")\n\n    return sign * (2.0 / math.sqrt(math.pi)) * final_integral\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    test_cases = [0.0, 1e-8, 0.5, 1.0, -1.3, 2.0, 5.0]\n    n_nodes = 16\n    abs_tol = 1e-12\n    rel_tol = 1e-12\n\n    results = []\n    for x in test_cases:\n        # Compute the erf approximation using the implemented quadrature\n        erf_hat = compute_erf_quadrature(x, n_nodes, abs_tol, rel_tol)\n        \n        # Get reference values from standard libraries\n        ref_math = math.erf(x)\n        ref_scipy = erf_scipy(x)\n        \n        # Calculate the maximum absolute error against the two references\n        error_math = abs(erf_hat - ref_math)\n        error_scipy = abs(erf_hat - ref_scipy)\n        e_max = max(error_math, error_scipy)\n        \n        results.append([erf_hat, ref_math, ref_scipy, e_max])\n\n    # Format the output exactly as specified in the problem statement\n    # This creates a string representation of a list of lists of floats.\n    output_str_list = []\n    for r in results:\n        # Manually format each inner list to ensure no extra whitespace\n        inner_str = f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\"\n        output_str_list.append(inner_str)\n    \n    final_output = f\"[{','.join(output_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2397742"}]}