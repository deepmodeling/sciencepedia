{"hands_on_practices": [{"introduction": "数值相对论的核心在于在离散的网格上求解场方程，这需要将连续的微分算子转化为计算机可以处理的形式。本练习聚焦于一个基本的算子——协变拉普拉斯算子 $\\nabla^2 \\phi$，并要求你在存在非平凡空间度规的情况下，应用有限差分近似 [@problem_id:1001182]。掌握这种转化是将物理场在弯曲时空中的演化进行模拟，并理解几何如何影响离散化方程的第一步。", "problem": "在数值相对论中，研究弯曲时空背景下标量场的演化，通常需要将场方程在网格上离散化。这些方程中的一个基本算子是协变拉普拉斯算子。对于黎曼流形上度规为 $g_{ab}$ 的标量场 $\\phi$，协变拉普拉斯算子定义为 $\\nabla^2 \\phi = g^{ab} \\nabla_a \\nabla_b \\phi$，其中 $\\nabla_a$ 是与度规相容的协变导数。\n\n考虑一个线元为 $ds^2 = g_{xx}(x) (dx)^2$ 的一维空间切片。在该切片上，标量场 $\\phi(x)$ 的协变拉普拉斯算子可简化为以下紧凑形式：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\sqrt{g_{xx}}} \\frac{d}{dx} \\left(\\frac{1}{\\sqrt{g_{xx}}} \\frac{d\\phi}{dx}\\right)\n$$\n为了进行数值求解，可以定义一个均匀网格 $x_i = i h$（其中 $i$ 为整数，$h$ 为网格间距），并使用有限差分来近似该算子。通过在交错网格上计算导数构建的二阶精度中心差分格式，给出了在网格点 $x_i$ 处拉普拉斯算子的如下近似：\n$$\n(\\nabla^2 \\phi)_i \\approx \\frac{1}{\\sqrt{g_{xx,i}} h^2} \\left( \\frac{\\phi_{i+1} - \\phi_i}{\\sqrt{\\frac{1}{2}(g_{xx,i} + g_{xx,i+1})}} - \\frac{\\phi_i - \\phi_{i-1}}{\\sqrt{\\frac{1}{2}(g_{xx,i-1} + g_{xx,i})}} \\right)\n$$\n其中 $\\phi_i = \\phi(x_i)$ 且 $g_{xx,i} = g_{xx}(x_i)$。\n\n考虑一个空间，其度规分量为 $g_{xx}(x) = e^{2\\alpha x}$，标量场由 $\\phi(x) = \\beta \\sin(\\omega x)$ 给出，其中 $\\alpha, \\beta, \\omega$ 和 $h$ 是正实数参数。\n\n你的任务是推导在网格点 $x_1 = h$ 处协变拉普拉斯算子的有限差分近似 $(\\nabla^2 \\phi)_1$ 的闭式解析表达式。最终表达式应使用符号常数 $\\alpha, \\beta, \\omega$ 和 $h$ 表示。", "solution": "问题要求计算在网格点 $x_1 = h$ 处的协变拉普拉斯算子的数值近似 $(\\nabla^2 \\phi)_1$。给定的有限差分公式为：\n$$\n(\\nabla^2 \\phi)_i \\approx \\frac{1}{\\sqrt{g_{xx,i}} h^2} \\left( \\frac{\\phi_{i+1} - \\phi_i}{\\sqrt{\\frac{1}{2}(g_{xx,i} + g_{xx,i+1})}} - \\frac{\\phi_i - \\phi_{i-1}}{\\sqrt{\\frac{1}{2}(g_{xx,i-1} + g_{xx,i})}} \\right)\n$$\n我们需要对 $i=1$ 的情况计算此公式。这需要标量场 $\\phi$ 和度规分量 $g_{xx}$ 在网格点 $x_0 = 0 \\cdot h = 0$，$x_1 = 1 \\cdot h = h$ 和 $x_2 = 2 \\cdot h = 2h$ 处的值。\n\n首先，我们计算标量场 $\\phi(x) = \\beta \\sin(\\omega x)$ 所需的值：\n-   在 $x_0 = 0$ 处：$\\phi_0 = \\beta \\sin(\\omega \\cdot 0) = 0$。\n-   在 $x_1 = h$ 处：$\\phi_1 = \\beta \\sin(\\omega h)$。\n-   在 $x_2 = 2h$ 处：$\\phi_2 = \\beta \\sin(2\\omega h)$。\n\n接下来，我们计算度规分量 $g_{xx}(x) = e^{2\\alpha x}$ 所需的值：\n-   在 $x_0 = 0$ 处：$g_{xx,0} = e^{2\\alpha \\cdot 0} = e^0 = 1$。\n-   在 $x_1 = h$ 处：$g_{xx,1} = e^{2\\alpha h}$。\n-   在 $x_2 = 2h$ 处：$g_{xx,2} = e^{2\\alpha (2h)} = e^{4\\alpha h}$。\n\n现在，我们将这些值代入 $i=1$ 时的有限差分公式中：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{1}{\\sqrt{g_{xx,1}} h^2} \\left( \\frac{\\phi_2 - \\phi_1}{\\sqrt{\\frac{1}{2}(g_{xx,1} + g_{xx,2})}} - \\frac{\\phi_1 - \\phi_0}{\\sqrt{\\frac{1}{2}(g_{xx,0} + g_{xx,1})}} \\right)\n$$\n代入计算出的值：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{1}{\\sqrt{e^{2\\alpha h}} h^2} \\left( \\frac{\\beta \\sin(2\\omega h) - \\beta \\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(e^{2\\alpha h} + e^{4\\alpha h})}} - \\frac{\\beta \\sin(\\omega h) - 0}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} \\right)\n$$\n我们来逐项简化表达式。前置因子是 $\\frac{1}{e^{\\alpha h} h^2}$。我们可以从括号内的项中提出因子 $\\beta$。\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\beta}{e^{\\alpha h} h^2} \\left( \\frac{\\sin(2\\omega h) - \\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(e^{2\\alpha h} + e^{4\\alpha h})}} - \\frac{\\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} \\right)\n$$\n现在，简化括号内的分母。\n对于第一项的分母：$\\sqrt{\\frac{1}{2}(e^{2\\alpha h} + e^{4\\alpha h})} = \\sqrt{\\frac{1}{2}e^{2\\alpha h}(1 + e^{2\\alpha h})} = e^{\\alpha h} \\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}$。\n所以表达式变为：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\beta}{e^{\\alpha h} h^2} \\left( \\frac{\\sin(2\\omega h) - \\sin(\\omega h)}{e^{\\alpha h} \\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} - \\frac{\\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} \\right)\n$$\n我们可以提出因子 $\\frac{1}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} = \\frac{\\sqrt{2}}{\\sqrt{1 + e^{2\\alpha h}}}$。\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\beta}{e^{\\alpha h} h^2} \\frac{\\sqrt{2}}{\\sqrt{1 + e^{2\\alpha h}}} \\left( \\frac{\\sin(2\\omega h) - \\sin(\\omega h)}{e^{\\alpha h}} - \\sin(\\omega h) \\right)\n$$\n合并前置因子，得到最终的简化表达式：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\sqrt{2}\\beta}{e^{\\alpha h} h^2 \\sqrt{1 + e^{2\\alpha h}}} \\left( e^{-\\alpha h}(\\sin(2\\omega h) - \\sin(\\omega h)) - \\sin(\\omega h) \\right)\n$$", "answer": "$$\n\\boxed{\\frac{\\sqrt{2}\\beta}{e^{\\alpha h} h^2 \\sqrt{1 + e^{2\\alpha h}}} \\left( e^{-\\alpha h}(\\sin(2\\omega h) - \\sin(\\omega h)) - \\sin(\\omega h) \\right)}\n$$", "id": "1001182"}, {"introduction": "一旦我们将演化方程离散化，确保数值解的稳定性就变得至关重要，因为微小的误差可能会指数级增长并摧毁整个模拟。本练习通过分析简单的标量波方程，探讨了保证双曲型方程稳定性的关键判据——Courant-Friedrichs-Lewy (CFL) 条件 [@problem_id:1001246]。通过推导稳定性极限，你将具体理解时间步长 $\\Delta t$、空间网格间距 $\\Delta x$ 和物理传播速度之间的关系——这是一个支配所有含时数值模拟的核心概念。", "problem": "一维标量波动方程是数学物理中的一个基本模型，其形式为\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = v^2 \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中 $u(x, t)$ 是波的振幅，$v$ 是恒定的传播速度，$t$ 是时间，$x$ 是空间坐标。在数值相对论中，一个稳定的数值格式对于演化此类方程至关重要。\n\n考虑在一个均匀网格上的数值解，其空间步长为 $\\Delta x$，时间步长为 $\\Delta t$，其中 $u_j^n \\equiv u(j\\Delta x, n\\Delta t)$。该波动方程在空间上使用二阶精度的中心有限差分格式，在时间上使用二阶蛙跳格式进行离散化：\n$$\n\\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} = v^2 \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} \\right)\n$$\n为了分析此格式的稳定性，我们使用 Von Neumann 方法。我们考虑数值解的单一傅里叶模式：\n$$\nu_j^n = \\xi^n e^{i k j \\Delta x}\n$$\n其中 $k$ 是波数，$\\xi = \\xi(k)$ 是复放大因子。为了使数值解保持有界（即，为了使格式稳定），放大因子的模必须对所有可能的实数波数 $k$ 满足条件 $|\\xi| \\le 1$。\n\nCourant-Friedrichs-Lewy (CFL) 条件由此分析得出。它约束了时间步长、空间步长和波速之间的关系。该关系通常用库朗数 $\\mu = \\frac{v \\Delta t}{\\Delta x}$ 来表示。\n\n你的任务是确定此特定数值格式的稳定性极限。推导使该格式对所有波数都稳定的库朗数 $\\mu$ 的最大允许值。", "solution": "我们通过空间上的中心差分和时间上的蛙跳格式来离散化波动方程：\n$$\\frac{u_j^{n+1}-2u_j^n+u_j^{n-1}}{(\\Delta t)^2}\n= v^2\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}\\,. $$\n\n1.  代入傅里叶模式 $u_j^n=\\xi^n e^{ikj\\Delta x}$。那么\n$$\\frac{\\xi^{n+1}-2\\xi^n+\\xi^{n-1}}{(\\Delta t)^2}\n= v^2\\frac{e^{ik\\Delta x}-2+e^{-ik\\Delta x}}{(\\Delta x)^2}\\,\\xi^n.$$\n两边同除以 $\\xi^n$ 并乘以 $(\\Delta t)^2$：\n$$\\xi+\\xi^{-1}-2=\\mu^2\\,(e^{i k\\Delta x}-2+e^{-i k\\Delta x}),\\quad\n\\mu=\\frac{v\\Delta t}{\\Delta x}.$$\n\n2.  使用 $e^{i\\theta}+e^{-i\\theta}-2=-4\\sin^2(\\theta/2)$，其中 $\\theta=k\\Delta x$：\n$$\\xi+\\xi^{-1}-2=-4\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\n\\;\\Longrightarrow\\;\n\\cos(\\omega\\Delta t)=1-2\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr),$$\n其中 $\\xi=e^{\\pm i\\omega\\Delta t}$。\n\n3.  稳定性要求对于所有的 $k$，等式右侧的值必须在 $[-1,1]$ 区间内：\n$$-1\\le 1-2\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\\le1.$$\n最严格的约束是\n$$1-2\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\\ge -1\n\\;\\Longrightarrow\\;\n\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\\le1.$$\n因为对于所有实数 $k$，都有 $\\sin^2\\!(\\tfrac{k\\Delta x}{2})\\le1$，我们得到\n$$\\mu^2\\le1\\quad\\Longrightarrow\\quad \\mu\\le1.$$\n因此，当 $\\mu\\le1$ 时，该格式是稳定的。", "answer": "$$\\boxed{1}$$", "id": "1001246"}, {"introduction": "为了实现强场时空的长期稳定演化，现代数值相对论程序采用了如 BSSN 这样复杂的数学表述，它们与原始的 ADM 方程在数学上等价，但具有更优越的数值特性。这项高级实践通过要求你实现从 ADM 初始数据（$\\gamma_{ij}$，$K_{ij}$）到 BSSN 变量的转换，从而将理论与应用联系起来 [@problem_id:2420591]。这个编程练习将让你亲手体验现代模拟中的关键变量，以及计算这些变量所需的有限差分等数值技术。", "problem": "你需要在一个使用周期性边界条件的均匀三维笛卡尔网格上，实现、验证和测试一个从 Arnowitt–Deser–Misner (ADM) 初始数据到 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 变量的变换。ADM 初始数据由空间度规 $\\gamma_{ij}$ 和外曲率 $K_{ij}$ 组成。需要生成的 BSSN 变量为：共形因子 $\\phi$、共形度规 $\\tilde{\\gamma}_{ij}$、共形无迹外曲率 $A_{ij}$、平均曲率 $K$ 以及收缩的共形连接函数 $\\tilde{\\Gamma}^{i}$。\n\n出发点（来自 $3+1$ 分解和 BSSN 形式的基本定义与恒等式）：\n- 度规的共形分解为 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$，其中 $\\det(\\tilde{\\gamma}_{ij}) = 1$。由此可得 $\\det(\\gamma_{ij}) = e^{12 \\phi}$，因而 $\\phi = \\frac{1}{12} \\ln \\det(\\gamma_{ij})$。\n- 平均曲率是外曲率相对于 $\\gamma_{ij}$ 的迹：$K = \\gamma^{ij} K_{ij}$，其中 $\\gamma^{ij}$ 是 $\\gamma_{ij}$ 的逆矩阵。\n- $K_{ij}$ 的无迹部分是 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。共形无迹外曲率是 $A_{ij} = e^{-4 \\phi} S_{ij}$。\n- 在笛卡尔坐标系下，当 $\\det(\\tilde{\\gamma}_{ij}) = 1$ 时，收缩的共形连接函数满足 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$，其中 $\\tilde{\\gamma}^{ij}$ 是 $\\tilde{\\gamma}_{ij}$ 的逆矩阵。空间导数需采用数值近似计算。\n\n数值要求：\n- 使用一个包含 $N \\times N \\times N$ 个点的均匀笛卡尔网格，覆盖周期性区域 $[0, L] \\times [0, L] \\times [0, L]$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。网格点位于 $x_{n} = n \\Delta x$, $y_{m} = m \\Delta y$, $z_{p} = p \\Delta z$，其中整数 $n, m, p$ 的取值范围为 $\\{0, 1, \\dots, N-1\\}$。\n- 在所有三个方向上均使用周期性边界条件。\n- 使用二阶中心有限差分计算空间导数。对于任意标量或张量分量 $u$，其沿 $x$ 坐标的离散导数近似为 $\\partial_{x} u \\approx \\left(u(x+\\Delta x) - u(x-\\Delta x)\\right) / (2 \\Delta x)$，对 $y$ 和 $z$ 坐标也类似，并采用周期性环绕处理边界。\n\n实现任务：\n- 编写一个模块，在给定网格上的场 $\\gamma_{ij}$ 和 $K_{ij}$ 的情况下，根据上述定义在每个网格点上计算 $\\phi$、$\\tilde{\\gamma}_{ij}$、$A_{ij}$、$K$ 和 $\\tilde{\\Gamma}^{i}$。\n- 在以下三个测试案例上验证该实现。在每个案例中，ADM 数据均由解析式给出，你必须在网格上构建 $\\gamma_{ij}$ 和 $K_{ij}$，应用你的变换，并在 BSSN 量非平凡的情况下，将其与解析已知的 BSSN 量进行比较。\n\n测试套件（所有案例使用相同的网格参数 $N$ 和 $L$）：\n- 通用网格参数：$N = 32$， $L = 2\\pi$。\n\n- 案例 1（纯共形因子，平坦共形度规，外曲率为零）：\n  - 定义 $f(x) = a \\sin(k x)$，其中 $a = 0.1$，$k = 1$，仅依赖于 $x$。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 且 $K_{ij} = 0$。\n  - 解析 BSSN 参考值：$\\phi = f(x)$，$\\tilde{\\gamma}_{ij} = \\delta_{ij}$，$A_{ij} = 0$，$K = 0$，$\\tilde{\\Gamma}^{i} = 0$。\n\n- 案例 2（非平凡的单位行列式共形度规，共形因子为零，外曲率为零）：\n  - 定义 $h(x) = b \\cos(k x)$，其中 $b = 0.2$，$k = 2$，仅依赖于 $x$。\n  - 设置 $\\tilde{\\gamma}_{ij} = \\mathrm{diag}\\left(e^{h(x)}, e^{-h(x)}, 1\\right)$ 且 $\\gamma_{ij} = \\tilde{\\gamma}_{ij}$，其中 $K_{ij} = 0$。\n  - 解析 BSSN 参考值：$\\phi = 0$，$A_{ij} = 0$，$K = 0$。逆共形度规为 $\\tilde{\\gamma}^{ij} = \\mathrm{diag}\\left(e^{-h(x)}, e^{h(x)}, 1\\right)$。因此 $\\tilde{\\Gamma}^{x} = -\\partial_{x}\\tilde{\\gamma}^{xx} = e^{-h(x)} h'(x)$，其中 $h'(x) = - b k \\sin(k x)$，且 $\\tilde{\\Gamma}^{y} = 0$，$\\tilde{\\Gamma}^{z} = 0$。\n\n- 案例 3（非平凡共形因子、平坦共形度规，以及具有给定迹和无迹部分的外曲率）：\n  - 定义 $f(x) = a \\cos(k x)$，其中 $a = 0.05$，$k = 3$，仅依赖于 $x$。令常数 $K_{0} = 0.4$ 和 $s = 0.3$。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$，并定义一个常数无迹张量 $S_{ij} = \\mathrm{diag}(s, -s/2, -s/2)$（相对于 $\\delta_{ij}$ 无迹）。定义 $K_{ij} = \\frac{1}{3} \\gamma_{ij} K_{0} + e^{4 f(x)} S_{ij}$。\n  - 解析 BSSN 参考值：$\\phi = f(x)$，$\\tilde{\\gamma}_{ij} = \\delta_{ij}$，$K = K_{0}$，$A_{ij} = S_{ij}$，$\\tilde{\\Gamma}^{i} = 0$。\n\n误差评估与要求输出：\n- 对每个案例，计算：\n  - $\\phi$ 在所有网格点上的最大绝对误差：$\\max |\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{ref}}|$。\n  - $K$ 在所有网格点上的最大绝对误差：$\\max |K_{\\mathrm{num}} - K_{\\mathrm{ref}}|$。\n  - $A_{ij}$ 在所有网格点和所有分量上的最大绝对误差：$\\max |A^{\\mathrm{num}}_{ij} - A^{\\mathrm{ref}}_{ij}|$。\n  - $\\tilde{\\Gamma}^{i}$ 误差的逐点欧几里得范数的最大值：$\\max \\sqrt{(\\Delta \\tilde{\\Gamma}^{x})^{2} + (\\Delta \\tilde{\\Gamma}^{y})^{2} + (\\Delta \\tilde{\\Gamma}^{z})^{2}}$。\n- 你的程序应产生单行输出，按顺序包含三个案例的所有结果，格式为方括号括起来的逗号分隔列表：$[\\mathrm{case1\\_phi},\\mathrm{case1\\_K},\\mathrm{case1\\_A},\\mathrm{case1\\_\\tilde{\\Gamma}};\\mathrm{case2\\_phi},\\mathrm{case2\\_K},\\mathrm{case2\\_A},\\mathrm{case2\\_\\tilde{\\Gamma}};\\mathrm{case3\\_phi},\\mathrm{case3\\_K},\\mathrm{case3\\_A},\\mathrm{case3\\_\\tilde{\\Gamma}}]$。在实际输出字符串中，用逗号替换分号，从而得到一个包含 12 个浮点数的扁平列表。不应打印任何其他文本。", "solution": "该问题陈述已提交以供验证。给定的条件、定义和测试案例均被提取和分析，以确保其内部一致性和科学有效性。该问题涉及将爱因斯坦场方程的初始数据从 Arnowitt–Deser–Misner (ADM) 形式变换到 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 形式。所有的定义——度规的共形分解 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$、平均曲率的定义 $K = \\gamma^{ij} K_{ij}$、共形无迹外曲率 $A_{ij}$ 以及收缩的共形连接函数 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$——均为数值相对论领域的标准定义。所提供的测试案例经核实与这些定义一致。该问题是一个定义明确的计算物理任务，具有清晰、客观的规范和可验证的结果。因此，该问题被认定为有效。\n\n解决方案要求实现一个数值程序，在均匀笛卡尔网格上从 ADM 变量（$\\gamma_{ij}, K_{ij}$）计算 BSSN 变量（$\\phi, \\tilde{\\gamma}_{ij}, K, A_{ij}, \\tilde{\\Gamma}^{i}$）。程序流程如下。\n\n首先，建立一个均匀、周期性的三维笛卡尔网格。该网格有 $N \\times N \\times N$ 个点，其中 $N=32$，覆盖了区域 $[0, L] \\times [0, L] \\times [0, L]$，其中 $L=2\\pi$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。每个网格点 $(i,j,k)$ 处的坐标为 $(x_i, y_j, z_k)$。对于三个测试案例中的每一个，初始 ADM 张量场 $\\gamma_{ij}$ 和 $K_{ij}$ 根据其解析定义，在该网格上构造为数组。\n\n变换在每个网格点按以下计算顺序进行：\n\n1.  **共形因子 $\\phi$**：计算空间度规的行列式 $\\det(\\gamma_{ij})$。然后，共形因子由 $\\phi = \\frac{1}{12} \\ln(\\det(\\gamma_{ij}))$ 给出。此步骤分离了空间几何的体积部分。\n\n2.  **共形度规 $\\tilde{\\gamma}_{ij}$**：使用计算出的共形因子 $\\phi$，对物理度规 $\\gamma_{ij}$ 进行共形重缩放，以获得共形度规 $\\tilde{\\gamma}_{ij} = e^{-4\\phi} \\gamma_{ij}$。根据构造，该度规的行列式为单位一，即 $\\det(\\tilde{\\gamma}_{ij}) = 1$。\n\n3.  **平均曲率 $K$**：通过在每个网格点上对 $3 \\times 3$ 矩阵 $\\gamma_{ij}$ 求逆，计算物理空间度规的逆 $\\gamma^{ij}$。然后，通过将该逆度规与外曲率进行缩并来求得平均曲率：$K = \\gamma^{ij} K_{ij}$。这是对两个指标的求和，代表 $K_{ij}$ 的迹。\n\n4.  **共形无迹外曲率 $A_{ij}$**：首先，计算外曲率相对于物理度规的无迹部分，即 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。然后对此张量进行共形重缩放，得到 BSSN 变量 $A_{ij} = e^{-4\\phi} S_{ij}$。\n\n5.  **收缩的共形连接函数 $\\tilde{\\Gamma}^{i}$**：这是唯一需要数值微分的步骤。\n    a.  从 $\\tilde{\\gamma}_{ij}$ 计算共形度规的逆 $\\tilde{\\gamma}^{ij}$。\n    b.  使用带有周期性边界条件的二阶中心有限差分格式，计算 $\\tilde{\\gamma}^{ij}$ 各分量的空间导数 $\\partial_j$。对于一个场 $u(x,y,z)$ 和网格间距 $\\Delta x$，在网格点 $i$ 处关于 $x$ 的导数近似为 $\\partial_x u_i \\approx \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}$。区域的周期性意味着边界处的索引 $i+1$ 会环绕到起点，而 $i-1$ 会环绕到终点。\n    c.  然后通过对这些导数进行缩并来计算连接函数：$\\tilde{\\Gamma}^{i} = - \\sum_{j} \\partial_j \\tilde{\\gamma}^{ij}$。具体来说，对每个分量 $i \\in \\{x, y, z\\}$：\n    $$ \\tilde{\\Gamma}^x = -(\\partial_x \\tilde{\\gamma}^{xx} + \\partial_y \\tilde{\\gamma}^{xy} + \\partial_z \\tilde{\\gamma}^{xz}) $$\n    $$ \\tilde{\\Gamma}^y = -(\\partial_x \\tilde{\\gamma}^{yx} + \\partial_y \\tilde{\\gamma}^{yy} + \\partial_z \\tilde{\\gamma}^{yz}) $$\n    $$ \\tilde{\\Gamma}^z = -(\\partial_x \\tilde{\\gamma}^{zx} + \\partial_y \\tilde{\\gamma}^{zy} + \\partial_z \\tilde{\\gamma}^{zz}) $$\n    注意，由于逆度规是对称的（$\\tilde{\\gamma}^{ij} = \\tilde{\\gamma}^{ji}$），该表达式等价于逆共形度规张量的行（或列）的散度。\n\n最后，对于每个测试案例，将数值计算出的 BSSN 场与所提供的解析参考解进行比较。误差度量按规定计算：标量和张量场 $\\phi$、$K$ 和 $A_{ij}$ 的最大绝对误差，以及 $\\tilde{\\Gamma}^{i}$ 误差向量的逐点欧几里得范数的最大值。这些误差预期会很小，量级与二阶有限差分格式的截断误差 $O(\\Delta x^2)$ 相当。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted from the specified environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests the ADM to BSSN transformation for numerical relativity.\n    \"\"\"\n    N = 32\n    L = 2.0 * np.pi\n    dx = L / N\n    # We use np.mgrid to create coordinate arrays where the first axis corresponds to x,\n    # the second to y, and the third to z. This is unconventional but allows for\n    # straightforward indexing e.g., axis=0 for x-derivatives.\n    coords = np.mgrid[0:N, 0:N, 0:N].astype(float) * dx\n    x, y, z = coords[0], coords[1], coords[2]\n\n    def central_diff(field, axis, step):\n        \"\"\"Computes 2nd-order periodic central difference.\"\"\"\n        return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * step)\n\n    def adm_to_bssn(gamma, K_ij, dx, dy, dz):\n        \"\"\"\n        Performs the transformation from ADM to BSSN variables on the grid.\n        \n        Args:\n            gamma (np.ndarray): Physical metric, shape (3, 3, N, N, N).\n            K_ij (np.ndarray): Extrinsic curvature, shape (3, 3, N, N, N).\n            dx, dy, dz (float): Grid spacings.\n\n        Returns:\n            A tuple of BSSN variables: (phi, tilde_gamma, A_ij, K_trace, Gamma_i).\n        \"\"\"\n        # Transpose for np.linalg functions which operate on the last two axes\n        gamma_T = gamma.transpose(2, 3, 4, 0, 1)\n        \n        # 1. Conformal factor phi\n        gamma_det = np.linalg.det(gamma_T)\n        phi = (1.0 / 12.0) * np.log(gamma_det)\n\n        # 2. Conformal metric tilde_gamma_ij\n        # Use broadcasting: (N,N,N) * (3,3,N,N,N)\n        tilde_gamma = np.exp(-4.0 * phi) * gamma\n        \n        # 3. Mean curvature K\n        gamma_inv_T = np.linalg.inv(gamma_T)\n        gamma_inv = gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        K_trace = np.einsum('ij...,ij...->...', gamma_inv, K_ij)\n\n        # 4. Conformal trace-free extrinsic curvature A_ij\n        S_ij = K_ij - (1.0 / 3.0) * K_trace * gamma  # Broadcasting K_trace * gamma\n        A_ij = np.exp(-4.0 * phi) * S_ij\n        \n        # 5. Contracted conformal connection functions Gamma^i\n        tilde_gamma_T = tilde_gamma.transpose(2, 3, 4, 0, 1)\n        tilde_gamma_inv_T = np.linalg.inv(tilde_gamma_T)\n        tilde_gamma_inv = tilde_gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        \n        Gamma_i = np.zeros((3, N, N, N))\n        \n        # Sum over j: partial_j tilde_gamma^ij\n        # For i = 0 (x-component):\n        Gamma_i[0] = -(central_diff(tilde_gamma_inv[0, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[0, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[0, 2], 2, dz))\n        # For i = 1 (y-component):\n        Gamma_i[1] = -(central_diff(tilde_gamma_inv[1, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[1, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[1, 2], 2, dz))\n        # For i = 2 (z-component):\n        Gamma_i[2] = -(central_diff(tilde_gamma_inv[2, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[2, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[2, 2], 2, dz))\n        \n        return phi, tilde_gamma, A_ij, K_trace, Gamma_i\n\n    all_errors = []\n\n    # Test Case 1\n    a, k = 0.1, 1.0\n    f_x = a * np.sin(k * x)\n    \n    gamma_1 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_1[0, 0] = conf_factor\n    gamma_1[1, 1] = conf_factor\n    gamma_1[2, 2] = conf_factor\n    \n    K_ij_1 = np.zeros((3, 3, N, N, N))\n    \n    phi_num_1, tilde_gamma_num_1, A_ij_num_1, K_num_1, Gamma_i_num_1 = adm_to_bssn(gamma_1, K_ij_1, dx, dx, dx)\n    \n    phi_ref_1 = f_x\n    K_ref_1 = np.zeros_like(phi_ref_1)\n    A_ij_ref_1 = np.zeros_like(A_ij_num_1)\n    Gamma_i_ref_1 = np.zeros_like(Gamma_i_num_1)\n    \n    err_phi_1 = np.max(np.abs(phi_num_1 - phi_ref_1))\n    err_K_1 = np.max(np.abs(K_num_1 - K_ref_1))\n    err_A_1 = np.max(np.abs(A_ij_num_1 - A_ij_ref_1))\n    err_Gamma_1 = np.max(np.sqrt(np.sum((Gamma_i_num_1 - Gamma_i_ref_1)**2, axis=0)))\n    all_errors.extend([err_phi_1, err_K_1, err_A_1, err_Gamma_1])\n\n    # Test Case 2\n    b, k = 0.2, 2.0\n    h_x = b * np.cos(k * x)\n    \n    gamma_2 = np.zeros((3, 3, N, N, N))\n    gamma_2[0, 0] = np.exp(h_x)\n    gamma_2[1, 1] = np.exp(-h_x)\n    gamma_2[2, 2] = 1.0\n    \n    K_ij_2 = np.zeros((3, 3, N, N, N))\n\n    phi_num_2, _, A_ij_num_2, K_num_2, Gamma_i_num_2 = adm_to_bssn(gamma_2, K_ij_2, dx, dx, dx)\n\n    phi_ref_2 = np.zeros_like(phi_num_2)\n    K_ref_2 = np.zeros_like(K_num_2)\n    A_ij_ref_2 = np.zeros_like(A_ij_num_2)\n    \n    Gamma_i_ref_2 = np.zeros((3, N, N, N))\n    hp_x = -b * k * np.sin(k * x)\n    Gamma_i_ref_2[0] = np.exp(-h_x) * hp_x\n    \n    err_phi_2 = np.max(np.abs(phi_num_2 - phi_ref_2))\n    err_K_2 = np.max(np.abs(K_num_2 - K_ref_2))\n    err_A_2 = np.max(np.abs(A_ij_num_2 - A_ij_ref_2))\n    err_Gamma_2 = np.max(np.sqrt(np.sum((Gamma_i_num_2 - Gamma_i_ref_2)**2, axis=0)))\n    all_errors.extend([err_phi_2, err_K_2, err_A_2, err_Gamma_2])\n\n    # Test Case 3\n    a, k = 0.05, 3.0\n    K0, s = 0.4, 0.3\n    f_x = a * np.cos(k * x)\n    \n    gamma_3 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_3[0, 0] = conf_factor\n    gamma_3[1, 1] = conf_factor\n    gamma_3[2, 2] = conf_factor\n    \n    S_ij_const = np.zeros((3, 3))\n    S_ij_const[0, 0] = s\n    S_ij_const[1, 1] = -s / 2.0\n    S_ij_const[2, 2] = -s / 2.0\n    \n    K_ij_3 = (1.0 / 3.0) * K0 * gamma_3 + conf_factor * S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    \n    phi_num_3, _, A_ij_num_3, K_num_3, Gamma_i_num_3 = adm_to_bssn(gamma_3, K_ij_3, dx, dx, dx)\n\n    phi_ref_3 = f_x\n    K_ref_3 = np.full_like(K_num_3, K0)\n    A_ij_ref_3 = S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    Gamma_i_ref_3 = np.zeros_like(Gamma_i_num_3)\n    \n    err_phi_3 = np.max(np.abs(phi_num_3 - phi_ref_3))\n    err_K_3 = np.max(np.abs(K_num_3 - K_ref_3))\n    err_A_3 = np.max(np.abs(A_ij_num_3 - A_ij_ref_3))\n    err_Gamma_3 = np.max(np.sqrt(np.sum((Gamma_i_num_3 - Gamma_i_ref_3)**2, axis=0)))\n    all_errors.extend([err_phi_3, err_K_3, err_A_3, err_Gamma_3])\n\n    print(f\"[{','.join(map(str, all_errors))}]\")\n\nsolve()\n```", "id": "2420591"}]}