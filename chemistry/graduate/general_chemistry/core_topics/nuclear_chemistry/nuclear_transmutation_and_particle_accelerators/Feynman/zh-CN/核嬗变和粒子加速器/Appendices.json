{
    "hands_on_practices": [
        {
            "introduction": "在核物理实验中，一个核心目标是测量特定核反应的微观截面 ($\\sigma$)。这个练习将引导你完成一个典型的分析过程，即如何从宏观可测量的物理量——例如加速器束流强度 ($I$)、靶的 areal number density ($n_t$) 和产物生成率 ($R$)——推导出微观截面。此外，本练习强调了实验科学中的一个关键技能：如何通过误差传播来量化由测量不确定性导致的最终结果的不确定度。",
            "id": "2948326",
            "problem": "一个稳定的核素薄自支撑靶受到来自回旋加速器的单能质子束的辐照，以引发核嬗变。在薄靶极限下并忽略束流衰减，每个入射粒子的反应概率等于靶的面数密度与微观反应截面的乘积。加速器束流强度用法拉第杯测量。一台稳态在线伽马能谱仪显示反应产物的生成率是恒定的。\n\n已知：\n- 测得的产物生成率（假设其不确定度与其他来源相比可以忽略）：$R = 1.20 \\times 10^{5}\\ \\text{s}^{-1}$。\n- 束流强度（标准不确定度主要来自校准）：$I = 0.800\\ \\mu\\text{A}$，其相对标准不确定度为 $2.0 \\times 10^{-2}$。\n- 靶的面数密度（通过卢瑟福背散射谱法（Rutherford Backscattering Spectrometry, RBS）测量）：$n_{t} = 5.00 \\times 10^{17}\\ \\text{atoms}\\ \\text{cm}^{-2}$，其相对标准不确定度为 $4.0 \\times 10^{-2}$。\n- 入射粒子电荷大小：$q = e = 1.602\\,176\\,634 \\times 10^{-19}\\ \\text{C}$。\n- 定义：$1\\ \\text{barn} = 10^{-24}\\ \\text{cm}^{2}$ 且 $1\\ \\text{millibarn} = 10^{-3}\\ \\text{barn}$。\n\n假设：\n- 薄靶近似适用，且束流在靶中的衰减可以忽略。\n- 仅有 $I$ 和 $n_{t}$ 的不确定度不可忽略。\n- $I$ 和 $n_{t}$ 的不确定度不相关，且足够小，可进行一阶（线性）不确定度传递。\n\n任务：\n从关联反应率、束流强度、入射粒子电荷和面数密度的基本定义出发，推导得出微观截面 $\\sigma$ 的表达式，并使用标准一阶不确定度传递方法推导其由 $I$ 和 $n_{t}$ 引起的标准不确定度的表达式。然后，计算 $\\sigma$ 的标准不确定度的数值，并以毫靶（millibarn）为单位表示。将最终结果四舍五入至三位有效数字，并按要求以毫靶为单位报告（不要在最终的方框答案中包含单位）。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 产物生成率：$R = 1.20 \\times 10^{5}\\ \\text{s}^{-1}$。\n- 束流强度：$I = 0.800\\ \\mu\\text{A}$。\n- 束流强度的相对标准不确定度：$\\frac{u(I)}{I} = 2.0 \\times 10^{-2}$。\n- 靶的面数密度：$n_{t} = 5.00 \\times 10^{17}\\ \\text{atoms}\\ \\text{cm}^{-2}$。\n- 面数密度的相对标准不确定度：$\\frac{u(n_{t})}{n_{t}} = 4.0 \\times 10^{-2}$。\n- 入射粒子电荷大小（元电荷）：$q = e = 1.602\\,176\\,634 \\times 10^{-19}\\ \\text{C}$。\n- 定义：$1\\ \\text{barn} = 10^{-24}\\ \\text{cm}^{2}$，$1\\ \\text{millibarn} = 10^{-3}\\ \\text{barn}$。\n- 假设：薄靶近似；束流衰减可忽略；仅 $I$ 和 $n_{t}$ 的不确定度不可忽略；不确定度不相关且很小，允许一阶传递。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了一个标准的核反应实验。反应率、通量、靶密度和截面之间的关系是核物理学的基础。参数和实验装置（回旋加速器、法拉第杯、RBS、伽马能谱仪）都是符合实际的。问题提法严谨，提供了推导截面及其不确定度的唯一解所需的所有必要信息和明确假设。语言客观且定量。因此，该问题被视为有效。\n\n**步骤3：结论与行动**\n问题有效。将提供解答。\n\n**推导与计算**\n在薄靶极限下，核反应率 $R$ 由入射粒子通量 $\\Phi_{p}$、单位面积的靶核数量 $n_{t}$ 和微观反应截面 $\\sigma$ 的乘积给出。\n$$R = \\Phi_{p} n_{t} \\sigma$$\n入射粒子通量 $\\Phi_{p}$ 是单位时间内入射到靶上的粒子数。它与束流强度 $I$（单位时间内的总电荷）和单个入射粒子的电荷 $q$ 相关。\n$$\\Phi_{p} = \\frac{I}{q}$$\n将通量的表达式代入反应率方程，得到：\n$$R = \\left(\\frac{I}{q}\\right) n_{t} \\sigma$$\n根据这个基本关系，我们求解微观截面 $\\sigma$：\n$$\\sigma = \\frac{R q}{I n_{t}}$$\n为了确定 $\\sigma$ 的标准不确定度，记为 $u(\\sigma)$，我们使用不相关量的一阶不确定度传递公式。对于函数 $\\sigma(I, n_{t})$，其不确定度的平方由下式给出：\n$$u^{2}(\\sigma) \\approx \\left(\\frac{\\partial \\sigma}{\\partial I}\\right)^{2} u^{2}(I) + \\left(\\frac{\\partial \\sigma}{\\partial n_{t}}\\right)^{2} u^{2}(n_{t})$$\n所需的偏导数是：\n$$\\frac{\\partial \\sigma}{\\partial I} = \\frac{\\partial}{\\partial I} \\left(\\frac{R q}{I n_{t}}\\right) = -\\frac{R q}{I^{2} n_{t}} = -\\frac{1}{I} \\left(\\frac{R q}{I n_{t}}\\right) = -\\frac{\\sigma}{I}$$\n$$\\frac{\\partial \\sigma}{\\partial n_{t}} = \\frac{\\partial}{\\partial n_{t}} \\left(\\frac{R q}{I n_{t}}\\right) = -\\frac{R q}{I n_{t}^{2}} = -\\frac{1}{n_{t}} \\left(\\frac{R q}{I n_{t}}\\right) = -\\frac{\\sigma}{n_{t}}$$\n将这些代入不确定度传递公式，得到：\n$$u^{2}(\\sigma) \\approx \\left(-\\frac{\\sigma}{I}\\right)^{2} u^{2}(I) + \\left(-\\frac{\\sigma}{n_{t}}\\right)^{2} u^{2}(n_{t}) = \\sigma^{2} \\left(\\frac{u(I)}{I}\\right)^{2} + \\sigma^{2} \\left(\\frac{u(n_{t})}{n_{t}}\\right)^{2}$$\n两边除以 $\\sigma^{2}$，得到相对不确定度平方的表达式：\n$$\\left(\\frac{u(\\sigma)}{\\sigma}\\right)^{2} \\approx \\left(\\frac{u(I)}{I}\\right)^{2} + \\left(\\frac{u(n_{t})}{n_{t}}\\right)^{2}$$\n任务是求绝对标准不确定度 $u(\\sigma)$。首先，我们使用所提供的数据计算 $\\sigma$ 的值。\n束流强度为 $I = 0.800\\ \\mu\\text{A} = 0.800 \\times 10^{-6}\\ \\text{A} = 0.800 \\times 10^{-6}\\ \\text{C}\\ \\text{s}^{-1}$。\n$$\n\\sigma = \\frac{(1.20 \\times 10^{5}\\ \\text{s}^{-1})(1.602\\,176\\,634 \\times 10^{-19}\\ \\text{C})}{(0.800 \\times 10^{-6}\\ \\text{C}\\ \\text{s}^{-1})(5.00 \\times 10^{17}\\ \\text{atoms}\\ \\text{cm}^{-2})}\n$$\n$$\n\\sigma = \\frac{1.92261196 \\times 10^{-14}}{4.00 \\times 10^{11}}\\ \\text{cm}^{2} = 0.480653 \\times 10^{-25}\\ \\text{cm}^{2} = 4.80653 \\times 10^{-26}\\ \\text{cm}^{2}\n$$\n现在，我们使用给定的值计算相对不确定度的平方：\n$$\\left(\\frac{u(\\sigma)}{\\sigma}\\right)^{2} = (2.0 \\times 10^{-2})^{2} + (4.0 \\times 10^{-2})^{2} = 4.0 \\times 10^{-4} + 16.0 \\times 10^{-4} = 20.0 \\times 10^{-4} = 2.0 \\times 10^{-3}$$\n那么，绝对不确定度 $u(\\sigma)$ 是：\n$$u(\\sigma) = \\sigma \\sqrt{2.0 \\times 10^{-3}} = (4.80653 \\times 10^{-26}\\ \\text{cm}^{2}) \\sqrt{2.0 \\times 10^{-3}}$$\n$$u(\\sigma) \\approx (4.80653 \\times 10^{-26}\\ \\text{cm}^{2}) (0.04472136) \\approx 2.1498 \\times 10^{-27}\\ \\text{cm}^{2}$$\n题目要求答案以毫靶（$\\text{mb}$）为单位。我们使用给定的转换关系：\n$$1\\ \\text{millibarn} = 10^{-3}\\ \\text{barn} = 10^{-3} \\times (10^{-24}\\ \\text{cm}^{2}) = 10^{-27}\\ \\text{cm}^{2}$$\n因此，转换因子为 $1\\ \\text{mb} = 10^{-27}\\ \\text{cm}^{2}$。\n$$u(\\sigma) = \\frac{2.1498 \\times 10^{-27}\\ \\text{cm}^{2}}{10^{-27}\\ \\text{cm}^{2}/\\text{mb}} \\approx 2.1498\\ \\text{mb}$$\n将结果四舍五入到三位有效数字，我们得到：\n$$u(\\sigma) = 2.15\\ \\text{mb}$$\n这就是计算出的截面的标准不确定度。",
            "answer": "$$\\boxed{2.15}$$"
        },
        {
            "introduction": "带电粒子在到达并引起核嬗变之前，必须穿过靶材料，并在此过程中不断损失能量。理解并模拟这一能量损失过程对于实验设计至关重要，例如确定所需的粒子束初始能量或设计合适的靶厚度。本练习要求你通过数值积分实现著名的 Bethe 公式，来计算质子在铝靶中的连续慢化近似 (CSDA) 射程，从而将理论物理模型转化为一个具体的、可计算的预测。",
            "id": "2948349",
            "problem": "一个动能为 $E_0$ 的质子笔形束穿过一个均匀铝靶，根据阻止本领概念，它会将能量损失给靶中的电子。对于一个电荷为 $z e$、速率为 $v$ 的带电粒子，其平均电子质量阻止本领 $S_m(E)$（即每单位面密度的能量损失）在非相对论到中度相对论能量范围内，可用 Bethe 公式进行建模。该公式由带电粒子与靶电子之间受运动学和 Born 近似约束的二元库仑碰撞推导得出。你需要通过从第一性原理出发，对 $1/S(E)$ 进行数值积分，来计算质子在铝中的投影连续慢化近似（CSDA）射程 $R$，并将结果与受“离子在物质中的阻止和射程”（SRIM）启发的半经验预期值进行比较。\n\n基本原理和给定数据：\n- 铝的材料参数为：原子序数 $Z = 13$，摩尔质量 $A = 26.9815385\\,\\mathrm{g/mol}$，体密度 $\\rho = 2.70\\,\\mathrm{g/cm^3}$，以及平均激发能 $I = 166\\,\\mathrm{eV} = 1.66\\times 10^{-4}\\,\\mathrm{MeV}$。\n- 在电子阻止区，重带电粒子（此处为质子，$z=1$）的 Bethe 质量阻止本领为\n$$\nS_m(E) = K \\frac{z^2 Z}{A} \\frac{1}{\\beta^2} \\left[ \\frac{1}{2}\\ln\\!\\left(\\frac{2 m_e c^2 \\beta^2 \\gamma^2\\, T_{\\max}}{I^2}\\right) - \\beta^2 - \\frac{\\delta}{2} \\right],\n$$\n其中 $K = 0.307075\\,\\mathrm{MeV\\,cm^2/g}$，$m_e c^2 = 0.51099895\\,\\mathrm{MeV}$，$m_p c^2 = 938.2720813\\,\\mathrm{MeV}$，$z=1$，$\\gamma = 1 + E/(m_p c^2)$，$\\beta^2 = 1 - 1/\\gamma^2$，而单次碰撞中可转移给一个电子的最大动能为\n$$\nT_{\\max} = \\frac{2 m_e c^2 \\beta^2 \\gamma^2}{1 + 2\\gamma (m_e/m_p) + (m_e/m_p)^2}.\n$$\n在本任务所关注的能量范围内，密度效应修正可以忽略，因此设 $\\delta = 0$。对于指定的能量和材料，核阻止和辐射过程可以忽略不计。\n- CSDA 面射程 $R_m$（单位为 $\\mathrm{g/cm^2}$）满足\n$$\nR_m(E_0) = \\int_0^{E_0} \\frac{dE}{S_m(E)}.\n$$\n投影路径长度 $R$（单位为 $\\mathrm{cm}$）为 $R(E_0) = R_m(E_0)/\\rho$。\n\n为保证物理真实性和数值稳定性而进行的低能区修正：\n- Bethe 模型在低能区会失效，因为此时入射粒子的有效电荷和电荷交换过程会改变 $S_m(E)$。为保持科学真实性，当能量 $E  E_{\\mathrm{patch}}$（其中 $E_{\\mathrm{patch}} = 0.1\\,\\mathrm{MeV}$）时，使用一个匹配的低能替代模型。通过如下定义，在 $E_{\\mathrm{patch}}$ 处施加数值连续性：\n$$\nS_m^{\\mathrm{low}}(E) = S_m(E_{\\mathrm{patch}})\\,\\left(\\frac{E}{E_{\\mathrm{patch}}}\\right)^{1/2}, \\quad 0 \\le E \\le E_{\\mathrm{patch}}.\n$$\n- 使用此替代模型，面射程的低能区贡献具有以下闭合形式：\n$$\nR_m^{\\mathrm{low}}(E_0) =\n\\begin{cases}\n\\displaystyle \\frac{2 \\sqrt{E_{\\mathrm{patch}}\\, E_0}}{S_m(E_{\\mathrm{patch}})},  0 \\le E_0 \\le E_{\\mathrm{patch}},\\\\[8pt]\n\\displaystyle \\frac{2 E_{\\mathrm{patch}}}{S_m(E_{\\mathrm{patch}})},  E_0  E_{\\mathrm{patch}}.\n\\end{cases}\n$$\n- 对于 $E_0  E_{\\mathrm{patch}}$，通过数值积分计算剩余的面射程\n$$\nR_m^{\\mathrm{Bethe}}(E_0) = \\int_{E_{\\mathrm{patch}}}^{E_0} \\frac{dE}{S_m(E)},\n$$\n然后令 $R_m(E_0) = R_m^{\\mathrm{low}}(E_0) + R_m^{\\mathrm{Bethe}}(E_0)$。\n\n数值计算要求：\n- 对 $E \\in [E_{\\mathrm{patch}}, E_0]$ 上的积分，实现一个稳健的数值求积方法，使用足够精细的划分来控制在目标能量范围内的离散化误差。\n- 仅使用上述常数和关系式作为物理模型基础。不允许使用外部数据文件或访问网络。\n\n单位和格式要求：\n- 将最终的投影射程转换为毫米（mm），并以毫米为单位表示，每个值四舍五入到三位有效数字。\n- 本任务不使用角度。\n- 百分比（如有）必须以小数形式表示。\n\n测试套件与基于 SRIM 的预期值：\n- 针对以下入射质子能量（单位为 $\\mathrm{MeV}$）评估你的算法：$E_0 \\in \\{1.0,\\;3.0,\\;10.0,\\;20.0\\}$。\n- 为了进行比较，请使用以下受 SRIM 启发的、质子在相同能量下于铝中的 CSDA 面射程预期值（单位为 $\\mathrm{g/cm^2}$），这些值反映了该能量区间的半经验趋势：\n$$\nR_m^{\\mathrm{SRIM}}(1.0) = 6.5\\times 10^{-3},\\quad\nR_m^{\\mathrm{SRIM}}(3.0) = 1.8\\times 10^{-2},\\quad\nR_m^{\\mathrm{SRIM}}(10.0) = 1.4\\times 10^{-1},\\quad\nR_m^{\\mathrm{SRIM}}(20.0) = 3.3\\times 10^{-1}.\n$$\n- 对于每个能量，还需计算一个布尔值：如果相对偏差\n$$\n\\left| R_m(E_0) - R_m^{\\mathrm{SRIM}}(E_0) \\right| \\big/ R_m^{\\mathrm{SRIM}}(E_0)\n$$\n小于或等于 $0.35$，则为真（true），否则为假（false）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。第一个元素必须是一个包含四个投影射程（单位为 mm）的列表（按 $E_0$ 递增排序，每个值四舍五入到三位有效数字）。第二个元素必须是一个包含四个布尔值的列表（按相同的 $E_0$ 值排序），表示结果是否在指定的相对容差内与受 SRIM 启发的预期值一致。因此，最终输出必须是形如 `[[...],[...]]` 的单行字符串，表示一个包含两个列表的列表。",
            "solution": "问题陈述已经过验证，被认定是有效的。它在科学上基于粒子物理学原理，特别是带电粒子与物质的相互作用。该问题是适定的，提供了一套完整的常数、物理定律和明确的计算目标。所有参数均已指定，所需的计算（包括数值积分）也已明确定义。因此，解答该问题是合理的。\n\n这个问题的核心是计算质子在铝靶中的投影射程。这是通过在连续慢化近似（CSDA）下，对质子阻止本领的倒数相对于其动能进行积分来实现的。阻止本领，即每单位路径长度的平均能量损失，由 Bethe 公式建模。\n\n流程如下：\n\n1.  **物理模型设定**：我们首先定义物理系统。所有提供的铝材料参数（$Z=13$， $A=26.9815385\\,\\mathrm{g/mol}$， $\\rho=2.70\\,\\mathrm{g/cm^3}$， $I=1.66\\times 10^{-4}\\,\\mathrm{MeV}$）和质子参数（$z=1$， $m_p c^2 = 938.2720813\\,\\mathrm{MeV}$）都用一致的单位进行设定。基本常数 $K = 0.307075\\,\\mathrm{MeV\\,cm^2/g}$ 和 $m_e c^2 = 0.51099895\\,\\mathrm{MeV}$ 也被定义。\n\n2.  **阻止本领函数**：实现一个函数来计算给定质子动能 $E$ 下的质量阻止本领 $S_m(E)$。该函数严格遵守所提供的 Bethe 公式：\n    $$\n    S_m(E) = K \\frac{z^2 Z}{A} \\frac{1}{\\beta^2} \\left[ \\frac{1}{2}\\ln\\!\\left(\\frac{2 m_e c^2 \\beta^2 \\gamma^2\\, T_{\\max}}{I^2}\\right) - \\beta^2 \\right]\n    $$\n    此处，密度效应 $\\delta$ 取为 0。首先计算相对论项，即洛伦兹因子 $\\gamma = 1 + E/(m_p c^2)$ 和速度平方 $\\beta^2 = 1 - 1/\\gamma^2$。随后，使用其完整的相对论表达式计算单次碰撞中可转移给靶电子的最大动能 $T_{\\max}$：\n    $$\n    T_{\\max} = \\frac{2 m_e c^2 \\beta^2 \\gamma^2}{1 + 2\\gamma (m_e/m_p) + (m_e/m_p)^2}\n    $$\n    $Z/A$ 因子中的项 $A$ 被视为无量纲的质量数，其数值等于所提供的摩尔质量值。这种解释确保了量纲上的一致性，因为常数 $K$ 的单位是 $\\mathrm{MeV\\,cm^2/g}$。\n\n3.  **低能区处理**：众所周知，Bethe 公式在低能区不准确。问题指定了一种修正方案来解决这个问题。对于低于阈值 $E_{\\mathrm{patch}} = 0.1\\,\\mathrm{MeV}$ 的能量，阻止本领由一个替代函数 $S_m^{\\mathrm{low}}(E)$ 来近似。对于任何初始能量 $E_0  E_{\\mathrm{patch}}$，从能量区间 $[0, E_{\\mathrm{patch}}]$ 对总射程的贡献由解析表达式给出：\n    $$\n    R_m^{\\mathrm{low}} = \\frac{2 E_{\\mathrm{patch}}}{S_m(E_{\\mathrm{patch}})}\n    $$\n    这个值只需计算一次，并用于所有测试用例，因为所有指定的初始能量都超过了 $E_{\\mathrm{patch}}$。\n\n4.  **数值积分**：面射程的剩余部分，即从 $E_{\\mathrm{patch}}$ 到初始能量 $E_0$ 的部分，通过对 Bethe 阻止本领函数的倒数进行数值积分来计算：\n    $$\n    R_m^{\\mathrm{Bethe}}(E_0) = \\int_{E_{\\mathrm{patch}}}^{E_0} \\frac{dE}{S_m(E)}\n    $$\n    这个定积分使用一个稳健的自适应求积例程，具体来说是 `scipy.integrate.quad`，它能确保在整个积分域上的准确性。\n\n5.  **总射程与比较**：对于集合 $\\{1.0, 3.0, 10.0, 20.0\\}\\,\\mathrm{MeV}$ 中的每个初始能量 $E_0$，总面射程是低能贡献和高能贡献之和：$R_m(E_0) = R_m^{\\mathrm{low}} + R_m^{\\mathrm{Bethe}}(E_0)$。然后，将这个以 $\\mathrm{g/cm^2}$ 为单位的面射程转换为以毫米为单位的线性投影射程 $R(E_0)$：\n    $$\n    R(E_0)\\,\\mathrm{[mm]} = \\frac{R_m(E_0)\\,\\mathrm{[g/cm^2]}}{\\rho\\,\\mathrm{[g/cm^3]}} \\times 10\\,\\mathrm{[mm/cm]}\n    $$\n    最终的射程值格式化为三位有效数字。随后，将计算出的面射程 $R_m(E_0)$ 与提供的基于 SRIM 的半经验值 $R_m^{\\mathrm{SRIM}}(E_0)$ 进行比较。通过检查相对偏差是否在指定的 $35\\%$ 容差范围内来确定一个布尔结果：\n    $$\n    \\left| \\frac{R_m(E_0) - R_m^{\\mathrm{SRIM}}(E_0)}{R_m^{\\mathrm{SRIM}}(E_0)} \\right| \\le 0.35\n    $$\n    较大的容差是考虑到所提供的 Bethe 模型与更精炼的经验模型相比，其本身固有的近似性。\n\n6.  **最终输出**：将计算出的射程（单位为 mm）和布尔比较结果收集到两个独立的列表中。然后，按照问题要求，将这些列表格式化为单个输出字符串，表示一个包含两个列表的列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the proton range in aluminum using the Bethe formula and a low-energy patch,\n    and compares the results to SRIM-based expectations.\n    \"\"\"\n    # Fundamental constants and material parameters\n    K = 0.307075  # MeV cm^2/g\n    Z = 13.0  # Atomic number of Aluminum\n    A = 26.9815385  # Molar mass of Al; used as dimensionless mass number in formula\n    rho = 2.70  # Density of Aluminum in g/cm^3\n    I_MeV = 1.66e-4  # Mean excitation energy of Al in MeV\n    mec2 = 0.51099895  # Electron rest mass energy in MeV\n    mpc2 = 938.2720813  # Proton rest mass energy in MeV\n    z = 1.0  # Proton charge number\n    E_patch = 0.1  # Patching energy in MeV\n    delta = 0.0 # Density effect correction\n\n    # Test suite and SRIM expectations\n    test_energies_MeV = [1.0, 3.0, 10.0, 20.0]\n    r_srim_g_cm2 = {\n        1.0: 6.5e-3,\n        3.0: 1.8e-2,\n        10.0: 1.4e-1,\n        20.0: 3.3e-1\n    }\n\n    def s_m(E: float) - float:\n        \"\"\"\n        Calculates the mass stopping power S_m(E) in MeV cm^2/g using the Bethe formula.\n        \"\"\"\n        if E = 0:\n            return np.inf\n        \n        gamma = 1.0 + E / mpc2\n        beta2 = 1.0 - 1.0 / (gamma**2)\n        \n        if beta2 = 0:\n            return np.inf\n\n        me_over_mp = mec2 / mpc2\n        \n        # Maximum kinetic energy transfer T_max\n        T_max_num = 2.0 * mec2 * beta2 * gamma**2\n        T_max_den = 1.0 + 2.0 * gamma * me_over_mp + me_over_mp**2\n        T_max = T_max_num / T_max_den\n\n        # Logarithm argument in the Bethe formula\n        log_arg = T_max_num * T_max / (I_MeV**2)\n        if log_arg = 0:\n              return np.inf\n              \n        # Bracketed term in the Bethe formula\n        bracket_term = 0.5 * np.log(log_arg) - beta2 - delta / 2.0\n        \n        # Full mass stopping power formula\n        stopping_power = K * (z**2 * Z / A) * (1.0 / beta2) * bracket_term\n        return stopping_power\n\n    # Calculate the fixed low-energy contribution to the range\n    s_m_at_patch = s_m(E_patch)\n    r_m_low_contribution = (2.0 * E_patch) / s_m_at_patch\n\n    # Define the integrand for the high-energy part of the range calculation\n    def integrand(E: float) - float:\n        return 1.0 / s_m(E)\n\n    # Lists to store the results\n    ranges_mm = []\n    booleans = []\n\n    # Main calculation loop for each initial energy\n    for E0 in test_energies_MeV:\n        # Numerically integrate to find the high-energy part of the areal range\n        r_m_bethe, _ = integrate.quad(integrand, E_patch, E0)\n\n        # Total areal range (g/cm^2)\n        r_m_total = r_m_low_contribution + r_m_bethe\n\n        # Convert to projected linear range (cm), then to mm\n        r_cm = r_m_total / rho\n        r_mm = r_cm * 10.0\n        \n        # Format to three significant figures and store\n        ranges_mm.append(f\"{r_mm:.3g}\")\n\n        # Compare with SRIM-based expectation\n        r_m_srim = r_srim_g_cm2[E0]\n        relative_deviation = abs(r_m_total - r_srim) / r_m_srim\n        agrees = relative_deviation = 0.35\n        booleans.append(agrees)\n\n    # Format the final output string as per requirements\n    ranges_str = \",\".join(ranges_mm)\n    booleans_str = \",\".join(str(b).lower() for b in booleans)\n    print(f\"[[{ranges_str}],[{booleans_str}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "核嬗变的一个重要应用是生产具有医学价值的放射性同位素，这些同位素通常通过放射性核素发生器系统来提供。本练习模拟了一个典型的母体-子体发生器，其中寿命较长的母体核素衰变为所需但寿命较短的子体核素。你的任务是结合放射性衰变动力学（Bateman 方程）和优化算法，设计一个最佳的洗脱方案，以在给定的操作窗口内最大化可获取的子体产物总量，这充分体现了基础核物理原理在实际应用中的综合运用。",
            "id": "2948321",
            "problem": "设计并实现一个完整的、可运行的程序，该程序模拟一个由母体核素及其子体组成的双核素放射性核素发生器，并计算一个最优的离散洗脱方案，以在固定的操作窗口内最大化可立即获取的子体总活度。物理背景是：一个母体核素通过核嬗变衰变成一个放射性子体，分支比为1。在指定的洗脱时间，子体库存被瞬时且完全移除（并立即可用），而母体库存不受影响。您的程序必须从放射性衰变和常微分方程求解的第一性原理出发，必须在允许的洗脱时间网格上使用离散时间搜索，并且必须输出最优洗脱时间以及回收到的最大子体总活度。\n\n基本和建模假设：\n- 令 $N_p(t)$ 和 $N_d(t)$ 分别表示在时间 $t$ 的母体和子体核素的原子核数量。令 $A_p(t)=\\lambda_p N_p(t)$ 和 $A_d(t)=\\lambda_d N_d(t)$ 分别表示母体和子体的活度，其中 $\\lambda_p=\\ln 2 / T_{1/2,p}$ 和 $\\lambda_d=\\ln 2 / T_{1/2,d}$ 是衰变常数，$T_{1/2,p}$ 和 $T_{1/2,d}$ 是相应的半衰期。\n- 两次洗脱之间的控制方程是耦合线性常微分方程组\n$$\n\\frac{dN_p}{dt}=-\\lambda_p N_p,\\qquad \\frac{dN_d}{dt}=\\lambda_p N_p-\\lambda_d N_d.\n$$\n- 在每个洗脱时间 $\\tau$，子体被瞬时移除，由重置条件 $N_d(\\tau^+)=0$ 表示，而 $N_p(\\tau^+)=N_p(\\tau^-)$。\n- 在初始时间 $t=0$，发生器以指定的初始母体活度 $A_p(0)=A_{p0}$ 和 $N_d(0)=0$ 制备。\n\n您的任务：\n1) 仅从上述常微分方程和重置条件出发，推导在任意两个连续洗脱之间的区间 $(\\tau, t]$ 上（其中 $N_d(\\tau^+)=0$ 且 $N_p(t)$ 遵循其自然衰变）$N_d(t)$ 的闭式表达式。用 $A_{p0}$、$\\lambda_p$、$\\lambda_d$、自上次洗脱以来的经过时间 $s=t-\\tau$ 以及上次洗脱时间 $\\tau$ 来表示子体活度 $A_d(t)$。您的推导必须通过取适当极限，在极限情况 $\\lambda_d\\to \\lambda_p$ 下仍然有效。\n2) 定义待最大化的目标为在操作窗口 $[0,T]$ 内每次洗脱时获得的子体活度值之和。如果在时间 $0t_1t_2\\cdotst_k\\le T$ 进行洗脱，则回收的总活度是在每个 $t_i$ 重置前，使用任务1)中推导的表达式计算出的 $A_d(t_i)$ 在所有洗脱时间 $t_i$ 上的总和。\n3) 为便于计算，将洗脱时间限制在一个步长为 $\\Delta t$ 小时的均匀网格上，即对于整数 $m\\ge 1$ 且 $t_m\\le T$，有 $t_m=m\\,\\Delta t$。您最多可以执行 $K$ 次洗脱。在此网格上构建一个正确的离散优化问题，该问题产生一个最优的、非递减的、最多包含 $K$ 个元素的方案 $\\{t_{i}\\}$，以最大化回收的总活度。该模型必须考虑每次洗脱时 $N_d$ 的重置动态。\n4) 实现一个算法，通过探索可行方案，在网格上精确求解该离散优化问题。该算法的最坏情况时间复杂度应为网格点数和 $K$ 的多项式。返回最优洗脱时间及相应的最大子体总活度。所有时间必须以小时表示，四舍五入到两位小数。所有活度必须以兆贝克勒尔（MBq）表示，四舍五入到三位小数。不使用角度。不使用百分比。\n\n科学真实性约束：\n- 假设子体的洗脱效率为$100\\%$，且母体到子体的分支比为1。\n- 所有参数必须具有物理意义且数值上合理。在操作窗口期间，衰变是自发进行的，没有外部辐照。\n\n测试套件和要求的程序输出：\n- 您的程序必须计算以下测试用例的解（每个参数列表按 $[A_{p0}\\ \\text{(MBq)},\\ T_{1/2,p}\\ \\text{(h)},\\ T_{1/2,d}\\ \\text{(h)},\\ T\\ \\text{(h)},\\ \\Delta t\\ \\text{(h)},\\ K]$ 的顺序排列）：\n  - 用例 1：$[7400.0,\\ 66.0,\\ 6.0,\\ 24.0,\\ 0.5,\\ 3]$\n  - 用例 2：$[7400.0,\\ 66.0,\\ 6.0,\\ 24.0,\\ 0.5,\\ 0]$\n  - 用例 3：$[3700.0,\\ 66.0,\\ 6.0,\\ 8.0,\\ 0.25,\\ 2]$\n  - 用例 4：$[1000.0,\\ 12.0,\\ 10.0,\\ 30.0,\\ 1.0,\\ 4]$\n  - 用例 5：$[5000.0,\\ 120.0,\\ 1.0,\\ 12.0,\\ 0.25,\\ 5]$\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，输出一个包含两个元素的列表，其第一个元素是以小时为单位的最优洗脱时间列表（四舍五入到两位小数），第二个元素是以MBq为单位回收的最大子体总活度（四舍五入到三位小数）。例如，一个有效的整体输出格式为\n\"[[[t11,t12,...],total1],[[t21,t22,...],total2],...]\"\n且不含空格。",
            "solution": "在尝试给出解答之前，需对问题进行验证。\n\n**第一步：提取已知条件**\n-   **变量**：$N_p(t)$（母体核素原子核数）、$N_d(t)$（子体核素原子核数）、$A_p(t)$（母体活度）、$A_d(t)$（子体活度）。\n-   **常量与参数**：母体衰变常数 $\\lambda_p$、子体衰变常数 $\\lambda_d$、母体半衰期 $T_{1/2,p}$、子体半衰期 $T_{1/2,d}$、初始母体活度 $A_{p0}$、操作窗口 $[0, T]$、网格步长 $\\Delta t$、最大洗脱次数 $K$。\n-   **定义**：$A_p(t)=\\lambda_p N_p(t)$、 $A_d(t)=\\lambda_d N_d(t)$、 $\\lambda_p=\\ln(2) / T_{1/2,p}$、 $\\lambda_d=\\ln(2) / T_{1/2,d}$。\n-   **控制方程**：$\\frac{dN_p}{dt}=-\\lambda_p N_p$、 $\\frac{dN_d}{dt}=\\lambda_p N_p-\\lambda_d N_d$。\n-   **初始与重置条件**：$A_p(0)=A_{p0}$、 $N_d(0)=0$。在洗脱时间 $\\tau$，$N_d(\\tau^+)=0$ 且 $N_p(\\tau^+)=N_p(\\tau^-)$。\n-   **目标**：对洗脱方案 $\\{t_i\\}$（其中 $0  t_1  \\dots  t_k \\le T$ 且 $k \\le K$），最大化 $\\sum A_d(t_i)$。\n-   **约束**：洗脱时间必须位于网格 $t_m = m \\Delta t$ 上，其中 $m$ 为整数且 $m \\ge 1$。\n-   **假设**：$100\\%$ 洗脱效率，单位分支比。\n\n**第二步：使用提取的已知条件进行验证**\n-   **科学基础**：该问题很好地基于核物理原理，特别是针对放射性衰变链的 Bateman 方程。放射性核素发生器的场景是核医学中的一个标准应用，提供了现实的背景。模型及其参数在科学上是有效的。\n-   **良态性 (Well-Posedness)**：问题是良态的。它涉及求解标准的线性常微分方程，然后在一个有限的离散搜索空间上对一个明确定义的目标函数进行优化。解的存在性得到保证。\n-   **客观性**：问题使用精确、客观的数学语言陈述，没有主观或模糊的术语。\n\n**第三步：结论与行动**\n该问题在科学上是合理的、良态的且客观的。判定为**有效**。将提供解答。\n\n解答根据问题陈述中指定的四项任务进行展开。\n\n**任务1：推导子体活度表达式**\n我们必须推导在 $\\tau$ 时刻洗脱之后，区间 $(\\tau, t]$ 上的子体活度 $A_d(t)$ 的表达式。\n\n首先，求解母体核素的方程 $\\frac{dN_p}{dt} = -\\lambda_p N_p$。在初始条件 $N_p(0) = N_{p0}$ 下，解为 $N_p(t) = N_{p0} e^{-\\lambda_p t}$。母体的衰变不受洗脱过程的影响。\n\n接下来，我们求解子体核素的方程：\n$$ \\frac{dN_d}{dt} + \\lambda_d N_d = \\lambda_p N_p(t) = \\lambda_p N_{p0} e^{-\\lambda_p t} $$\n这是一个一阶线性常微分方程。我们使用积分因子法求解。积分因子是 $I(t) = e^{\\int \\lambda_d dt} = e^{\\lambda_d t}$。将方程乘以 $I(t)$ 得：\n$$ e^{\\lambda_d t} \\frac{dN_d}{dt} + \\lambda_d e^{\\lambda_d t} N_d = \\lambda_p N_{p0} e^{(\\lambda_d - \\lambda_p)t} $$\n左侧是一个乘积的导数，即 $\\frac{d}{dt}(N_d e^{\\lambda_d t})$。我们对两边从上次洗脱时间 $\\tau$ 到稍后时间 $t$ 进行积分：\n$$ \\int_{\\tau}^{t} \\frac{d}{dt'}(N_d(t') e^{\\lambda_d t'}) dt' = \\int_{\\tau}^{t} \\lambda_p N_{p0} e^{(\\lambda_d - \\lambda_p)t'} dt' $$\n$$ \\left[ N_d(t') e^{\\lambda_d t'} \\right]_{\\tau^+}^{t} = \\lambda_p N_{p0} \\left[ \\frac{e^{(\\lambda_d - \\lambda_p)t'}}{\\lambda_d - \\lambda_p} \\right]_{\\tau}^{t} \\quad (\\text{对于 } \\lambda_d \\neq \\lambda_p) $$\n应用积分上下限和重置条件 $N_d(\\tau^+) = 0$：\n$$ N_d(t) e^{\\lambda_d t} - 0 = \\frac{\\lambda_p N_{p0}}{\\lambda_d - \\lambda_p} \\left( e^{(\\lambda_d - \\lambda_p)t} - e^{(\\lambda_d - \\lambda_p)\\tau} \\right) $$\n解出 $N_d(t)$：\n$$ N_d(t) = \\frac{\\lambda_p N_{p0}}{\\lambda_d - \\lambda_p} \\left( e^{-\\lambda_p t} - e^{-\\lambda_d t} e^{\\lambda_d \\tau} e^{-\\lambda_p \\tau} \\right) = \\frac{\\lambda_p N_{p0}}{\\lambda_d - \\lambda_p} e^{-\\lambda_p \\tau} \\left( e^{-\\lambda_p(t-\\tau)} - e^{-\\lambda_d(t-\\tau)} \\right) $$\n为了用活度表示，我们使用 $A_d(t) = \\lambda_d N_d(t)$ 和 $A_{p0} = \\lambda_p N_{p0}$。令 $s = t - \\tau$ 为自上次洗脱以来经过的时间。\n$$ A_d(t) = \\frac{\\lambda_d}{\\lambda_d - \\lambda_p} A_{p0} e^{-\\lambda_p \\tau} \\left( e^{-\\lambda_p s} - e^{-\\lambda_d s} \\right) $$\n此表达式给出了时间 $t$ 的子体活度，以初始母体活度 $A_{p0}$、衰变常数、前一次洗脱时间 $\\tau$ 以及此后经过的时间 $s$ 来表示。\n\n对于 $\\lambda_d \\to \\lambda_p$ 的情况，我们取 $A_d(t)$ 表达式的极限。令 $\\lambda = \\lambda_p$。我们考察项 $\\frac{e^{-\\lambda s} - e^{-\\lambda_d s}}{\\lambda_d - \\lambda}$。其形式为 $\\frac{f(\\lambda) - f(\\lambda_d)}{\\lambda - \\lambda_d}$，在极限 $\\lambda_d \\to \\lambda$ 时，它变为 $-f'(\\lambda)$。这里，$f(x) = e^{-xs}$，所以 $f'(x) = -s e^{-xs}$。极限值为 $-(-s e^{-\\lambda s}) = s e^{-\\lambda s}$。\n将此结果代回 $A_d(t)$ 的表达式中，并取极限 $\\lambda_d \\to \\lambda_p$：\n$$ A_d(t) \\to \\lambda_p \\cdot A_{p0} e^{-\\lambda_p \\tau} \\cdot (s e^{-\\lambda_p s}) = \\lambda_p A_{p0} s e^{-\\lambda_p (\\tau+s)} = \\lambda_p A_{p0} (t-\\tau) e^{-\\lambda_p t} $$\n此表达式在 $\\lambda_d = \\lambda_p$ 时有效。\n\n**任务2：目标函数定义**\n目标是最大化回收的总子体活度。给定一个在时间 $0  t_1  t_2  \\dots  t_k \\le T$ 进行的 $k$ 次洗脱方案，回收的总活度 $J$ 是每次洗脱时立即可用的子体活度之和：\n$$ J(\\{t_i\\}_{i=1}^k) = \\sum_{i=1}^k A_d(t_i) $$\n其中 $A_d(t_i)$ 是在第 $i$ 次洗脱前一瞬间计算的。令 $t_0 = 0$。活度 $A_d(t_i)$ 依赖于前一次洗脱的时间 $t_{i-1}$，并使用任务1中的公式计算，其中 $\\tau = t_{i-1}$，$t = t_i$。\n\n**任务3：离散优化问题建模**\n洗脱时间被限制在一个离散的点网格 $t_m = m \\Delta t$ 上，其中整数 $m \\in \\{1, 2, \\dots, M\\}$，$M = \\lfloor T/\\Delta t \\rfloor$。我们必须选择一个最多包含 $K$ 个网格索引的有序集合 $\\{m_1, m_2, \\dots, m_j\\}$，其中 $j \\le K$ 且 $1 \\le m_1  m_2  \\dots  m_j \\le M$。\n令 $A(\\tau_{prev}, \\tau_{curr})$ 表示在上次洗脱于 $\\tau_{prev}$ 的条件下，在时间 $\\tau_{curr}$ 时的子体活度。这使用任务1的公式计算。优化问题是：\n$$ \\max_{\\{m_i\\}_{i=1}^j} \\left( A(0, m_1\\Delta t) + A(m_1\\Delta t, m_2\\Delta t) + \\dots + A(m_{j-1}\\Delta t, m_j\\Delta t) \\right) $$\n约束条件为 $j \\le K$ 和 $1 \\le m_1  m_2  \\dots  m_j \\le M$。\n该问题表现出最优子结构和重叠子问题的特性，使其适合使用动态规划来解决。\n\n**任务4：算法设计与实现**\n采用动态规划方法来精确求解这个离散优化问题。令 $dp[k][m]$ 为进行 $k$ 次洗脱，且第 $k$ 次洗脱恰好发生在网格时间 $t_m = m \\Delta t$ 时收集到的最大总活度。\n状态转移公式如下：为计算 $dp[k][m]$，我们考虑第 $(k-1)$ 次洗脱所有可能的时间 $t_j = j \\Delta t$，其中 $k-1 \\le j  m$。这样一个序列的总活度，是在 $t_j$ 结束的 $k-1$ 次洗脱的最优活度（即 $dp[k-1][j]$），加上在 $t_m$ 进行最后一次洗脱所获得的活度（即 $A(t_j, t_m)$）。\n递推关系为：\n$$ dp[k][m] = \\max_{k-1 \\le j  m} \\{ dp[k-1][j] + A(j\\Delta t, m\\Delta t) \\} $$\n其中 $k=1$ 的基本情况是：\n$$ dp[1][m] = A(0, m\\Delta t) $$\n网格点数为 $M = \\lfloor T/\\Delta t \\rfloor$。DP 表 `dp` 的维度是 $(K+1) \\times (M+1)$。使用第二个表 `path` 来存储每个状态 $(k, m)$ 的前驱索引 $j$，以便重构最优方案。\n算法流程如下：\n1.  计算衰变常数 $\\lambda_p$ 和 $\\lambda_d$。\n2.  初始化大小为 $(K+1) \\times (M+1)$ 的 `dp` 表，其值表示不存在有效方案（例如，负无穷大）。\n3.  计算基本情况：对于从 $1$ 到 $M$ 的 $m$，计算 $dp[1][m]$。\n4.  对 $k$ 从 $2$ 到 $K$ 进行迭代。对于每个 $k$，对 $m$ 从 $k$ 到 $M$ 进行迭代，并通过迭代所有有效的前一个洗脱索引 $j$ 来使用递推关系计算 $dp[k][m]$。\n5.  填满 DP 表后，通过搜索所有 $dp[k][m]$（其中 $k \\in \\{1, \\dots, K\\}$，$m \\in \\{k, \\dots, M\\}$）来找到全局最大活度。如果 $K=0$，结果是 $0$ 活度和空方案。\n6.  一旦找到最大值及其状态 $(k_{opt}, m_{opt})$，使用 `path` 表从 $path[k_{opt}][m_{opt}]$ 开始回溯，以重构最优洗脱时间序列。\n该算法的时间复杂度是 $O(K \\cdot M^2)$，按要求是 $M$ 和 $K$ 的多项式。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the radionuclide generator optimization problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # [A_p0 (MBq), T_1/2,p (h), T_1/2,d (h), T (h), Delta_t (h), K]\n        [7400.0, 66.0, 6.0, 24.0, 0.5, 3],\n        [7400.0, 66.0, 6.0, 24.0, 0.5, 0],\n        [3700.0, 66.0, 6.0, 8.0, 0.25, 2],\n        [1000.0, 12.0, 10.0, 30.0, 1.0, 4],\n        [5000.0, 120.0, 1.0, 12.0, 0.25, 5],\n    ]\n\n    results_str = []\n    \n    for case in test_cases:\n        A_p0, T_half_p, T_half_d, T_max, dt, K = case\n\n        # Handle trivial case K=0\n        if K == 0:\n            results_str.append('[[],0.000]')\n            continue\n\n        lambda_p = np.log(2) / T_half_p\n        lambda_d = np.log(2) / T_half_d\n\n        def get_daughter_activity(tau, t):\n            \"\"\"\n            Calculates the daughter activity Ad(t) given last elution at tau.\n            t: current time\n            tau: time of previous elution\n            \"\"\"\n            if t = tau:\n                return 0.0\n            \n            s = t - tau\n            \n            # Case for lambda_d approximately equal to lambda_p\n            if abs(lambda_d - lambda_p)  1e-9:\n                activity = lambda_p * A_p0 * s * np.exp(-lambda_p * t)\n            else:\n                factor = lambda_d / (lambda_d - lambda_p)\n                parent_decay_term = A_p0 * np.exp(-lambda_p * tau)\n                buildup_term = np.exp(-lambda_p * s) - np.exp(-lambda_d * s)\n                activity = factor * parent_decay_term * buildup_term\n            \n            return activity\n\n        M = int(T_max / dt)\n        if M == 0:\n            results_str.append('[[],0.000]')\n            continue\n\n        # DP table: dp[k][m] = max activity with k elutions, last one at time m*dt\n        # Path table: path[k][m] = index of previous elution for the optimal schedule\n        dp = np.full((K + 1, M + 1), -1.0)\n        path = np.full((K + 1, M + 1), -1, dtype=int)\n\n        # Base case: k=1 elution\n        for m in range(1, M + 1):\n            t_m = m * dt\n            dp[1][m] = get_daughter_activity(0, t_m)\n            path[1][m] = 0\n\n        # Fill DP table for k  1 elutions\n        for k in range(2, K + 1):\n            for m in range(k, M + 1):\n                t_m = m * dt\n                max_val = -1.0\n                best_j = -1\n                # Previous elution at time t_j = j*dt, j must be at least k-1\n                for j in range(k - 1, m):\n                    t_j = j * dt\n                    activity_gain = get_daughter_activity(t_j, t_m)\n                    current_total = dp[k - 1][j] + activity_gain\n                    if current_total  max_val:\n                        max_val = current_total\n                        best_j = j\n                \n                if best_j != -1:\n                    dp[k][m] = max_val\n                    path[k][m] = best_j\n\n        # Find the overall maximum activity for at most K elutions\n        max_activity = 0.0\n        best_k = 0\n        best_m = 0\n        \n        # The number of elutions can be from 1 to K\n        for k in range(1, K + 1):\n            for m in range(k, M + 1):\n                if dp[k][m]  max_activity:\n                    max_activity = dp[k][m]\n                    best_k = k\n                    best_m = m\n        \n        # Reconstruct the optimal schedule\n        schedule = []\n        if best_k  0:\n            curr_k, curr_m = best_k, best_m\n            while curr_k  0:\n                schedule.append(curr_m * dt)\n                # Next step of backtracking\n                prev_m = path[curr_k][curr_m]\n                curr_k -= 1\n                curr_m = prev_m\n            schedule.reverse()\n\n        # Format the output string for the current case\n        time_list_str = '[' + ','.join([f'{t:.2f}' for t in schedule]) + ']'\n        result_str = f'[{time_list_str},{max_activity:.3f}]'\n        results_str.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}