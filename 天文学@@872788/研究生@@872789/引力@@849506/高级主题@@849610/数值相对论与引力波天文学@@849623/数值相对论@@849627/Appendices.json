{"hands_on_practices": [{"introduction": "数值相对论通过在时间上逐步演化爱因斯坦方程来解决问题。这需要将广义相对论中复杂的二阶偏微分方程组转化为更易于处理的一阶双曲系统。这个实践练习 [@problem_id:1001074] 使用一个简化的 1+1 维波动方程，演示了这关键的第一步，阐明了如何通过引入辅助变量来为数值积分算法准备方程。", "problem": "在数值相对论的背景下，分析场的传播通常涉及将二阶波动方程改写为一阶系统。本问题研究在某个时空中的无质量标量场 $\\Phi(t,x)$ 的 1+1 维协变波动方程。该时空由坐标描述，具有恒定的直减率 $\\alpha$ 和恒定的移位 $\\beta$。其控制方程由下式给出：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial t^2} - 2\\beta \\frac{\\partial^2 \\Phi}{\\partial t \\partial x} + (\\beta^2 - \\alpha^2) \\frac{\\partial^2 \\Phi}{\\partial x^2} = 0\n$$\n其中 $\\alpha > 0$ 和 $\\beta$ 是实值常数。\n\n为了使用求解双曲型系统的方法来数值求解此方程，必须首先将其降阶为一个一阶偏微分方程组。一种标准方法是引入辅助变量。我们定义：\n- $Π(t,x) = \\frac{\\partial \\Phi}{\\partial t}$\n- $Ψ(t,x) = \\frac{\\partial \\Phi}{\\partial x}$\n\n系统的状态则可以由向量 $\\mathbf{u} = (Φ, Π, Ψ)^T$ 描述。该状态向量的演化方程可以写成矩阵形式：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + A(\\alpha, \\beta) \\frac{\\partial \\mathbf{u}}{\\partial x} = \\mathbf{S}(\\mathbf{u})\n$$\n其中 $A$ 是一个 $3 \\times 3$ 的矩阵，称为特征矩阵，它依赖于 $\\alpha$ 和 $\\beta$；$\\mathbf{S}$ 是一个源向量，它可能依赖于 $\\mathbf{u}$ 的分量。矩阵 $A$ 的特征值是系统的特征速度，它决定了信息如何传播。\n\n本题要求推导该系统所有非零特征速度的乘积。", "solution": "我们从二阶波动方程开始\n$$\n\\frac{\\partial^2\\Phi}{\\partial t^2}-2\\beta\\,\\frac{\\partial^2\\Phi}{\\partial t\\partial x}+(\\beta^2-\\alpha^2)\\,\\frac{\\partial^2\\Phi}{\\partial x^2}=0\\,.\n$$\n引入一阶变量\n$$\n\\Pi=\\frac{\\partial\\Phi}{\\partial t},\\qquad\n\\Psi=\\frac{\\partial\\Phi}{\\partial x}\\,.\n$$\n于是\n\\begin{align*}\n\\partial_t\\Phi=\\Pi,\\\\\n\\partial_t\\Pi=\\partial_t^2\\Phi\n=2\\beta\\,\\partial_t\\partial_x\\Phi-(\\beta^2-\\alpha^2)\\,\\partial_x^2\\Phi\n=2\\beta\\,\\partial_x\\Pi-(\\beta^2-\\alpha^2)\\,\\partial_x\\Psi,\\\\\n\\partial_t\\Psi=\\partial_x\\partial_t\\Phi=\\partial_x\\Pi.\n\\end{align*}\n记 $\\mathbf u=(\\Phi,\\Pi,\\Psi)^T$，该系统可以表示为：\n$$\n\\partial_t\\mathbf u+A\\,\\partial_x\\mathbf u\n=\\mathbf S,\\qquad\nA=\\begin{pmatrix}\n0  0  0 \\\\\n0  -2\\beta  \\beta^2-\\alpha^2 \\\\\n0  -1  0\n\\end{pmatrix},\\quad\n\\mathbf S=\\begin{pmatrix}\\Pi\\\\0\\\\0\\end{pmatrix}.\n$$\n特征速度是 $A$ 的特征值 $\\lambda$，可通过下式求得\n$$\n\\det(A-\\lambda I)\n=-\\lambda\\,\\det\\begin{pmatrix}-2\\beta-\\lambda  \\beta^2-\\alpha^2\\\\-1  -\\lambda\\end{pmatrix}\n=0\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda(\\lambda^2+2\\beta\\lambda+\\beta^2-\\alpha^2)=0.\n$$\n因此\n$$\n\\lambda_1=0,\\qquad\n\\lambda_{2,3}=-\\beta\\pm\\alpha.\n$$\n两个非零速度的乘积是\n$$\n(-\\beta+\\alpha)(-\\beta-\\alpha)=\\beta^2-\\alpha^2.\n$$", "answer": "$$\\boxed{\\beta^2-\\alpha^2}$$", "id": "1001074"}, {"introduction": "虽然 ADM 形式主义直接给出了爱因斯坦方程的 3+1 分解，但在长期模拟中它存在不稳定性。BSSN 形式主义通过引入新变量构建了一个更稳健的演化系统，因此将初始数据从 ADM 形式转换为 BSSN 变量是数值相对论学家的标准任务。这项动手编程练习 [@problem_id:2420591] 将指导你实现这一核心转换，内容涵盖共形分解到使用有限差分计算联络函数等各个方面。", "problem": "您需要在一个使用周期性边界条件的均匀三维笛卡尔网格上，实现、验证并测试一个将 Arnowitt–Deser–Misner (ADM) 初始数据转换为 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 变量的变换。ADM 初始数据由空间度规 $\\gamma_{ij}$ 和外在曲率 $K_{ij}$ 组成。需要生成的 BSSN 变量为共形因子 $\\phi$、共形度规 $\\tilde{\\gamma}_{ij}$、共形无迹外在曲率 $A_{ij}$、平均曲率 $K$ 以及收缩的共形联络函数 $\\tilde{\\Gamma}^{i}$。\n\n起点（来自 $3+1$ 分解和 BSSN 表述的基本定义和恒等式）：\n- 度规的共形分解为 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$，其中 $\\det(\\tilde{\\gamma}_{ij}) = 1$。由此可得 $\\det(\\gamma_{ij}) = e^{12 \\phi}$，因此 $\\phi = \\frac{1}{12} \\ln \\det(\\gamma_{ij})$。\n- 平均曲率是外在曲率关于 $\\gamma_{ij}$ 的迹：$K = \\gamma^{ij} K_{ij}$，其中 $\\gamma^{ij}$ 是 $\\gamma_{ij}$ 的逆矩阵。\n- $K_{ij}$ 的无迹部分为 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。共形无迹外在曲率为 $A_{ij} = e^{-4 \\phi} S_{ij}$。\n- 在笛卡尔坐标系下，当 $\\det(\\tilde{\\gamma}_{ij}) = 1$ 时，收缩的共形联络函数满足 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$，其中 $\\tilde{\\gamma}^{ij}$ 是 $\\tilde{\\gamma}_{ij}$ 的逆矩阵。空间导数需要进行数值近似。\n\n数值要求：\n- 使用一个包含 $N \\times N \\times N$ 个点的均匀笛卡尔网格，覆盖周期性区域 $[0, L] \\times [0, L] \\times [0, L]$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。网格点位于 $x_{n} = n \\Delta x$，$y_{m} = m \\Delta y$，$z_{p} = p \\Delta z$，其中整数 $n, m, p$ 在 $\\{0, 1, \\dots, N-1\\}$ 范围内。\n- 在所有三个方向上使用周期性边界条件。\n- 使用二阶中心有限差分计算空间导数。对于任意标量或张量分量 $u$，沿坐标 $x$ 的离散导数为 $\\partial_{x} u \\approx \\left(u(x+\\Delta x) - u(x-\\Delta x)\\right) / (2 \\Delta x)$，对 $y$ 和 $z$ 也类似，并采用周期性环绕处理。\n\n实现任务：\n- 编写一个模块，给定网格上的场 $\\gamma_{ij}$ 和 $K_{ij}$，根据上述定义在每个网格点上计算 $\\phi$、$\\tilde{\\gamma}_{ij}$、$A_{ij}$、$K$ 和 $\\tilde{\\Gamma}^{i}$。\n- 在以下三个测试用例上验证实现。在每个用例中，ADM 数据均以解析形式给出，您必须在网格上构建 $\\gamma_{ij}$ 和 $K_{ij}$，应用您的变换，并在 BSSN 量非平凡的情况下，将其与解析已知的 BSSN 量进行比较。\n\n测试套件（所有用例使用相同的网格参数 $N$ 和 $L$）：\n- 通用网格参数：$N = 32$, $L = 2\\pi$。\n\n- 用例 $1$（纯共形因子，平坦共形度规，外在曲率为零）：\n  - 定义 $f(x) = a \\sin(k x)$，其中 $a = 0.1$，$k = 1$，仅依赖于 $x$。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 且 $K_{ij} = 0$。\n  - 解析 BSSN 参考值：$\\phi = f(x)$、$\\tilde{\\gamma}_{ij} = \\delta_{ij}$、$A_{ij} = 0$、$K = 0$、$\\tilde{\\Gamma}^{i} = 0$。\n\n- 用例 $2$（非平凡单位行列式共形度规，共形因子为零，外在曲率为零）：\n  - 定义 $h(x) = b \\cos(k x)$，其中 $b = 0.2$，$k = 2$，仅依赖于 $x$。\n  - 设置 $\\tilde{\\gamma}_{ij} = \\mathrm{diag}\\left(e^{h(x)}, e^{-h(x)}, 1\\right)$ 且 $\\gamma_{ij} = \\tilde{\\gamma}_{ij}$，其中 $K_{ij} = 0$。\n  - 解析 BSSN 参考值：$\\phi = 0$、$A_{ij} = 0$、$K = 0$。逆共形度规为 $\\tilde{\\gamma}^{ij} = \\mathrm{diag}\\left(e^{-h(x)}, e^{h(x)}, 1\\right)$。因此 $\\tilde{\\Gamma}^{x} = -\\partial_{x}\\tilde{\\gamma}^{xx} = e^{-h(x)} h'(x)$，其中 $h'(x) = - b k \\sin(k x)$，且 $\\tilde{\\Gamma}^{y} = 0$，$\\tilde{\\Gamma}^{z} = 0$。\n\n- 用例 $3$（非平凡共形因子，平坦共形度规，以及具有指定迹和无迹部分的外在曲率）：\n  - 定义 $f(x) = a \\cos(k x)$，其中 $a = 0.05$，$k = 3$，仅依赖于 $x$。设 $K_{0} = 0.4$ 和 $s = 0.3$ 为常数。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 并定义一个常数无迹张量 $S_{ij} = \\mathrm{diag}(s, -s/2, -s/2)$（相对于 $\\delta_{ij}$ 是无迹的）。定义 $K_{ij} = \\frac{1}{3} \\gamma_{ij} K_{0} + e^{4 f(x)} S_{ij}$。\n  - 解析 BSSN 参考值：$\\phi = f(x)$、$\\tilde{\\gamma}_{ij} = \\delta_{ij}$、$K = K_{0}$、$A_{ij} = S_{ij}$、$\\tilde{\\Gamma}^{i} = 0$。\n\n误差评估和所需输出：\n- 对每个用例，计算：\n  - $\\phi$ 在所有网格点上的最大绝对误差：$\\max |\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{ref}}|$。\n  - $K$ 在所有网格点上的最大绝对误差：$\\max |K_{\\mathrm{num}} - K_{\\mathrm{ref}}|$。\n  - $A_{ij}$ 在所有网格点和分量上的最大绝对误差：$\\max |A^{\\mathrm{num}}_{ij} - A^{\\mathrm{ref}}_{ij}|$。\n  - $\\tilde{\\Gamma}^{i}$ 误差的逐点欧几里得范数的最大值：$\\max \\sqrt{(\\Delta \\tilde{\\Gamma}^{x})^{2} + (\\Delta \\tilde{\\Gamma}^{y})^{2} + (\\Delta \\tilde{\\Gamma}^{z})^{2}}$。\n- 您的程序应生成单行输出，其中包含三个用例的所有结果，按顺序排列，形式为方括号括起来的逗号分隔列表：$[\\mathrm{case1\\_phi},\\mathrm{case1\\_K},\\mathrm{case1\\_A},\\mathrm{case1\\_\\tilde{\\Gamma}};\\mathrm{case2\\_phi},\\mathrm{case2\\_K},\\mathrm{case2\\_A},\\mathrm{case2\\_\\tilde{\\Gamma}};\\mathrm{case3\\_phi},\\mathrm{case3\\_K},\\mathrm{case3\\_A},\\mathrm{case3\\_\\tilde{\\Gamma}}]$。在实际输出字符串中，用逗号替换分号，从而得到一个包含 $12$ 个浮点数的扁平列表。不应打印任何其他文本。", "solution": "问题陈述已提交以供验证。给定的条件、定义和测试用例被提取出来，并就其内部一致性和科学有效性进行了分析。该问题涉及将爱因斯坦场方程的初始数据从 Arnowitt–Deser–Misner (ADM) 表述转换为 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 表述。所有定义——度规的共形分解 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$、平均曲率 $K = \\gamma^{ij} K_{ij}$ 的定义、共形无迹外在曲率 $A_{ij}$ 以及收缩的共形联络函数 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$——在数值相对论领域都是标准定义。所提供的测试用例经核实与这些定义一致。该问题是一个定义明确的计算物理任务，具有清晰、客观的规范和可验证的结果。因此，该问题被认定为有效。\n\n解决方案要求实现一个数值程序，在均匀笛卡尔网格上从 ADM 变量（$\\gamma_{ij}, K_{ij}$）计算 BSSN 变量（$\\phi, \\tilde{\\gamma}_{ij}, K, A_{ij}, \\tilde{\\Gamma}^{i}$）。该过程如下。\n\n首先，建立一个均匀、周期性的三维笛卡尔网格。该网格有 $N \\times N \\times N$ 个点，其中 $N=32$，覆盖区域 $[0, L] \\times [0, L] \\times [0, L]$，其中 $L=2\\pi$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。每个网格点 $(i,j,k)$ 的坐标为 $(x_i, y_j, z_k)$。对于三个测试用例中的每一个，初始 ADM 张量场 $\\gamma_{ij}$ 和 $K_{ij}$ 都根据其解析定义在此网格上构建为数组。\n\n变换过程在每个网格点上按以下计算顺序进行：\n\n1.  **共形因子 $\\phi$**：计算空间度规的行列式 $\\det(\\gamma_{ij})$。然后通过 $\\phi = \\frac{1}{12} \\ln(\\det(\\gamma_{ij}))$ 得到共形因子。此步骤分离了空间几何的体积部分。\n\n2.  **共形度规 $\\tilde{\\gamma}_{ij}$**：使用计算出的共形因子 $\\phi$，对物理度规 $\\gamma_{ij}$ 进行共形重缩放，以获得共形度规 $\\tilde{\\gamma}_{ij} = e^{-4\\phi} \\gamma_{ij}$。根据构造，该度规的行列式为单位一，即 $\\det(\\tilde{\\gamma}_{ij}) = 1$。\n\n3.  **平均曲率 $K$**：通过在每个网格点上对 $3 \\times 3$ 矩阵 $\\gamma_{ij}$ 求逆，计算出物理空间度规的逆 $\\gamma^{ij}$。然后通过将逆度规与外在曲率进行缩并来求得平均曲率：$K = \\gamma^{ij} K_{ij}$。这是对两个指标的求和，代表 $K_{ij}$ 的迹。\n\n4.  **共形无迹外在曲率 $A_{ij}$**：首先，计算外在曲率相对于物理度规的无迹部分 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。然后对该张量进行共形重缩放，得到 BSSN 变量 $A_{ij} = e^{-4\\phi} S_{ij}$。\n\n5.  **收缩的共形联络函数 $\\tilde{\\Gamma}^{i}$**：这是唯一需要数值微分的步骤。\n    a.  从 $\\tilde{\\gamma}_{ij}$ 计算共形度规的逆 $\\tilde{\\gamma}^{ij}$。\n    b.  使用二阶中心有限差分格式和周期性边界条件，计算 $\\tilde{\\gamma}^{ij}$ 各分量的空间导数 $\\partial_j$。对于一个场 $u(x,y,z)$ 和网格间距 $\\Delta x$，在网格点 $i$ 处关于 $x$ 的导数近似为 $\\partial_x u_i \\approx \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}$。区域的周期性意味着边界处的索引 $i+1$ 环绕到开头，而 $i-1$ 环绕到末尾。\n    c.  然后通过对这些导数进行缩并来计算联络函数：$\\tilde{\\Gamma}^{i} = - \\sum_{j} \\partial_j \\tilde{\\gamma}^{ij}$。具体来说，对于每个分量 $i \\in \\{x, y, z\\}$：\n    $$ \\tilde{\\Gamma}^x = -(\\partial_x \\tilde{\\gamma}^{xx} + \\partial_y \\tilde{\\gamma}^{xy} + \\partial_z \\tilde{\\gamma}^{xz}) $$\n    $$ \\tilde{\\Gamma}^y = -(\\partial_x \\tilde{\\gamma}^{yx} + \\partial_y \\tilde{\\gamma}^{yy} + \\partial_z \\tilde{\\gamma}^{yz}) $$\n    $$ \\tilde{\\Gamma}^z = -(\\partial_x \\tilde{\\gamma}^{zx} + \\partial_y \\tilde{\\gamma}^{zy} + \\partial_z \\tilde{\\gamma}^{zz}) $$\n    注意，由于逆度规是对称的（$\\tilde{\\gamma}^{ij} = \\tilde{\\gamma}^{ji}$），该表达式等价于逆共形度规张量的行（或列）的散度。\n\n最后，对于每个测试用例，将数值计算出的 BSSN 场与其提供的解析参考解进行比较。误差度量按规定计算：标量和张量场 $\\phi$、$K$ 和 $A_{ij}$ 的最大绝对误差，以及 $\\tilde{\\Gamma}^{i}$ 的误差向量的逐点欧几里得范数的最大值。这些误差预计会很小，量级与二阶有限差分格式的截断误差 $O(\\Delta x^2)$ 相当。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted from the specified environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests the ADM to BSSN transformation for numerical relativity.\n    \"\"\"\n    N = 32\n    L = 2.0 * np.pi\n    dx = L / N\n    # We use np.mgrid to create coordinate arrays where the first axis corresponds to x,\n    # the second to y, and the third to z. This is unconventional but allows for\n    # straightforward indexing e.g., axis=0 for x-derivatives.\n    coords = np.mgrid[0:N, 0:N, 0:N].astype(float) * dx\n    x, y, z = coords[0], coords[1], coords[2]\n\n    def central_diff(field, axis, step):\n        \"\"\"Computes 2nd-order periodic central difference.\"\"\"\n        return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * step)\n\n    def adm_to_bssn(gamma, K_ij, dx, dy, dz):\n        \"\"\"\n        Performs the transformation from ADM to BSSN variables on the grid.\n        \n        Args:\n            gamma (np.ndarray): Physical metric, shape (3, 3, N, N, N).\n            K_ij (np.ndarray): Extrinsic curvature, shape (3, 3, N, N, N).\n            dx, dy, dz (float): Grid spacings.\n\n        Returns:\n            A tuple of BSSN variables: (phi, tilde_gamma, A_ij, K_trace, Gamma_i).\n        \"\"\"\n        # Transpose for np.linalg functions which operate on the last two axes\n        gamma_T = gamma.transpose(2, 3, 4, 0, 1)\n        \n        # 1. Conformal factor phi\n        gamma_det = np.linalg.det(gamma_T)\n        phi = (1.0 / 12.0) * np.log(gamma_det)\n\n        # 2. Conformal metric tilde_gamma_ij\n        # Use broadcasting: (N,N,N) * (3,3,N,N,N)\n        tilde_gamma = np.exp(-4.0 * phi) * gamma\n        \n        # 3. Mean curvature K\n        gamma_inv_T = np.linalg.inv(gamma_T)\n        gamma_inv = gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        K_trace = np.einsum('ij...,ij...-...', gamma_inv, K_ij)\n\n        # 4. Conformal trace-free extrinsic curvature A_ij\n        S_ij = K_ij - (1.0 / 3.0) * K_trace * gamma  # Broadcasting K_trace * gamma\n        A_ij = np.exp(-4.0 * phi) * S_ij\n        \n        # 5. Contracted conformal connection functions Gamma^i\n        tilde_gamma_T = tilde_gamma.transpose(2, 3, 4, 0, 1)\n        tilde_gamma_inv_T = np.linalg.inv(tilde_gamma_T)\n        tilde_gamma_inv = tilde_gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        \n        Gamma_i = np.zeros((3, N, N, N))\n        \n        # Sum over j: partial_j tilde_gamma^ij\n        # For i = 0 (x-component):\n        Gamma_i[0] = -(central_diff(tilde_gamma_inv[0, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[0, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[0, 2], 2, dz))\n        # For i = 1 (y-component):\n        Gamma_i[1] = -(central_diff(tilde_gamma_inv[1, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[1, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[1, 2], 2, dz))\n        # For i = 2 (z-component):\n        Gamma_i[2] = -(central_diff(tilde_gamma_inv[2, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[2, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[2, 2], 2, dz))\n        \n        return phi, tilde_gamma, A_ij, K_trace, Gamma_i\n\n    all_errors = []\n\n    # Test Case 1\n    a, k = 0.1, 1.0\n    f_x = a * np.sin(k * x)\n    \n    gamma_1 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_1[0, 0] = conf_factor\n    gamma_1[1, 1] = conf_factor\n    gamma_1[2, 2] = conf_factor\n    \n    K_ij_1 = np.zeros((3, 3, N, N, N))\n    \n    phi_num_1, tilde_gamma_num_1, A_ij_num_1, K_num_1, Gamma_i_num_1 = adm_to_bssn(gamma_1, K_ij_1, dx, dx, dx)\n    \n    phi_ref_1 = f_x\n    K_ref_1 = np.zeros_like(phi_ref_1)\n    A_ij_ref_1 = np.zeros_like(A_ij_num_1)\n    Gamma_i_ref_1 = np.zeros_like(Gamma_i_num_1)\n    \n    err_phi_1 = np.max(np.abs(phi_num_1 - phi_ref_1))\n    err_K_1 = np.max(np.abs(K_num_1 - K_ref_1))\n    err_A_1 = np.max(np.abs(A_ij_num_1 - A_ij_ref_1))\n    err_Gamma_1 = np.max(np.sqrt(np.sum((Gamma_i_num_1 - Gamma_i_ref_1)**2, axis=0)))\n    all_errors.extend([err_phi_1, err_K_1, err_A_1, err_Gamma_1])\n\n    # Test Case 2\n    b, k = 0.2, 2.0\n    h_x = b * np.cos(k * x)\n    \n    gamma_2 = np.zeros((3, 3, N, N, N))\n    gamma_2[0, 0] = np.exp(h_x)\n    gamma_2[1, 1] = np.exp(-h_x)\n    gamma_2[2, 2] = 1.0\n    \n    K_ij_2 = np.zeros((3, 3, N, N, N))\n\n    phi_num_2, _, A_ij_num_2, K_num_2, Gamma_i_num_2 = adm_to_bssn(gamma_2, K_ij_2, dx, dx, dx)\n\n    phi_ref_2 = np.zeros_like(phi_num_2)\n    K_ref_2 = np.zeros_like(K_num_2)\n    A_ij_ref_2 = np.zeros_like(A_ij_num_2)\n    \n    Gamma_i_ref_2 = np.zeros((3, N, N, N))\n    hp_x = -b * k * np.sin(k * x)\n    Gamma_i_ref_2[0] = np.exp(-h_x) * hp_x\n    \n    err_phi_2 = np.max(np.abs(phi_num_2 - phi_ref_2))\n    err_K_2 = np.max(np.abs(K_num_2 - K_ref_2))\n    err_A_2 = np.max(np.abs(A_ij_num_2 - A_ij_ref_2))\n    err_Gamma_2 = np.max(np.sqrt(np.sum((Gamma_i_num_2 - Gamma_i_ref_2)**2, axis=0)))\n    all_errors.extend([err_phi_2, err_K_2, err_A_2, err_Gamma_2])\n\n    # Test Case 3\n    a, k = 0.05, 3.0\n    K0, s = 0.4, 0.3\n    f_x = a * np.cos(k * x)\n    \n    gamma_3 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_3[0, 0] = conf_factor\n    gamma_3[1, 1] = conf_factor\n    gamma_3[2, 2] = conf_factor\n    \n    S_ij_const = np.zeros((3, 3))\n    S_ij_const[0, 0] = s\n    S_ij_const[1, 1] = -s / 2.0\n    S_ij_const[2, 2] = -s / 2.0\n    \n    K_ij_3 = (1.0 / 3.0) * K0 * gamma_3 + conf_factor * S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    \n    phi_num_3, _, A_ij_num_3, K_num_3, Gamma_i_num_3 = adm_to_bssn(gamma_3, K_ij_3, dx, dx, dx)\n\n    phi_ref_3 = f_x\n    K_ref_3 = np.full_like(K_num_3, K0)\n    A_ij_ref_3 = S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    Gamma_i_ref_3 = np.zeros_like(Gamma_i_num_3)\n    \n    err_phi_3 = np.max(np.abs(phi_num_3 - phi_ref_3))\n    err_K_3 = np.max(np.abs(K_num_3 - K_ref_3))\n    err_A_3 = np.max(np.abs(A_ij_num_3 - A_ij_ref_3))\n    err_Gamma_3 = np.max(np.sqrt(np.sum((Gamma_i_num_3 - Gamma_i_ref_3)**2, axis=0)))\n    all_errors.extend([err_phi_3, err_K_3, err_A_3, err_Gamma_3])\n\n    print(f\"[{','.join(map(str, all_errors))}]\")\n\nsolve()\n```", "id": "2420591"}, {"introduction": "编写完数值代码后，我们如何确定它是正确的？最基本的验证技术是收敛性测试，它检验当网格分辨率提高时，数值误差是否按预期速率减小。这个练习 [@problem_id:1814389] 提供了一个具体的例子，说明如何执行收敛性测试并计算收敛阶数，这是开发可靠科学软件的一项关键技能。", "problem": "一位物理学家正在对一个新的数值相对论代码进行收敛性测试。该代码求解爱因斯坦场方程来演化时空的初始构型。空间离散化格式的精度由其收敛阶 $p$ 来表征。对于一个 $p$ 阶的数值方法，离散误差 $E$ 预计与网格间距 $h$ 成如下比例关系：$E \\propto h^p$。\n\n为了测量 $p$，该物理学家使用系统性加密的网格分辨率运行了三次模拟。这三种分辨率分别是：间距为 $h_c$ 的粗网格，间距为 $h_m = h_c/r$ 的中等网格，以及间距为 $h_f = h_m/r$ 的细网格。常数 $r$ 被称为加密因子。在本测试中，使用的加密因子为 $r=2.0$。\n\n在设定的演化时间后，该物理学家在某个固定的时空点测量了一个特定的标量 $\\Phi$（由时空度规导出）的值。三次模拟得到以下数值：\n- 粗分辨率 ($\\Phi_c$): $2.4000$\n- 中分辨率 ($\\Phi_m$): $2.3568$\n- 细分辨率 ($\\Phi_f$): $2.3456$\n\n假设误差由离散化的主阶项主导，计算该数值代码的实测收敛阶 $p$。将最终答案四舍五入到三位有效数字。", "solution": "我们假设在网格间距为 $h$ 时，测量值的形式为 $\\Phi(h)=\\Phi^{*}+C h^{p}+o(h^{p})$，其中 $\\Phi^{*}$ 是精确值，$C$ 是一个常数，$p$ 是收敛阶。对于三个网格间距 $h_{c}$、$h_{m}=h_{c}/r$ 和 $h_{f}=h_{m}/r=h_{c}/r^{2}$，主阶项的差满足\n$$\n\\Phi_{c}-\\Phi_{m}=C\\left(h_{c}^{p}-h_{m}^{p}\\right)=C h_{c}^{p}\\left(1-r^{-p}\\right),\n$$\n$$\n\\Phi_{m}-\\Phi_{f}=C\\left(h_{m}^{p}-h_{f}^{p}\\right)=C h_{m}^{p}\\left(1-r^{-p}\\right)=C h_{c}^{p} r^{-p}\\left(1-r^{-p}\\right).\n$$\n因此，比值\n$$\nR=\\frac{\\Phi_{c}-\\Phi_{m}}{\\Phi_{m}-\\Phi_{f}}=r^{p},\n$$\n因此\n$$\np=\\frac{\\ln R}{\\ln r}=\\frac{\\ln\\left(\\left|\\frac{\\Phi_{c}-\\Phi_{m}}{\\Phi_{m}-\\Phi_{f}}\\right|\\right)}{\\ln r}.\n$$\n代入给定值，\n$$\n\\Phi_{c}-\\Phi_{m}=2.4000-2.3568=0.0432,\\quad \\Phi_{m}-\\Phi_{f}=2.3568-2.3456=0.0112,\n$$\n所以\n$$\nR=\\frac{0.0432}{0.0112}=\\frac{432}{112}=\\frac{27}{7}.\n$$\n当 $r=2$ 时，我们得到\n$$\np=\\frac{\\ln\\left(\\frac{27}{7}\\right)}{\\ln 2}\\approx 1.94753,\n$$\n四舍五入到三位有效数字后得到 $1.95$。", "answer": "$$\\boxed{1.95}$$", "id": "1814389"}]}