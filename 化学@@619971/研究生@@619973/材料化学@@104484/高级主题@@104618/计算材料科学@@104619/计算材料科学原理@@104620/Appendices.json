{"hands_on_practices": [{"introduction": "平面波基组是密度泛函理论计算中最常用的基组之一，其完备性由动能截断能 $E_{\\text{cut}}$ 控制。根据变分原理，随着基组的增大（即 $E_{\\text{cut}}$ 值的增加），计算得到的总能量会单调地收敛到基组完备极限。因此，在进行任何有意义的计算之前，我们必须进行收敛性测试，以确保所选的 $E_{\\text{cut}}$ 足够大，使总能量达到所需的精度。这项实践 [@problem_id:2475310] 将指导你实现一个系统化的收敛协议，这是所有基于平面波的DFT研究中不可或缺的第一步。", "problem": "要求您形式化、论证并实现一个收敛协议，用于在平面波赝势计算中选择平面波动能截断，目标精度为每个原子 $1$ meV。您的实现必须是一个完整的程序。\n\n设计起点。使用以下在计算材料科学中已广为确立的基本原理和事实：\n- Rayleigh–Ritz 变分原理表明，在截断基组中，基态总能随着基组尺寸的增加而单调不增。在平面波基组中，这意味着总能 $E$ 关于动能截断 $E_{\\text{cut}}$ 是单调不增的。\n- 对于模守恒赝势和超软赝势，每个原子的总能中的主要截断误差会随着平面波动能截断的增加，以幂律形式渐近衰减。与此相符的一个最小模型是\n$$\nE(E_{\\text{cut}}) \\;=\\; E_\\infty \\;+\\; A \\, E_{\\text{cut}}^{-p},\n$$\n其中 $E_\\infty$ 是收敛的单原子总能，$A>0$ 表征赝势的硬度，$p>0$ 是一个收敛指数，由赝波函数和赝势投影算符的光滑度决定。\n\n待实现的协议。使用上述原理，实现以下收敛协议：\n- 构建一个均匀的截断能网格\n$$\nE_{\\text{cut},k} \\;=\\; E_{\\text{cut},0} \\;+\\; k\\,\\Delta, \\quad k=0,1,\\dots,N,\n$$\n给定起始值 $E_{\\text{cut},0}$、增量 $\\Delta$ 和步数 $N$（因此共有 $N\\!+\\!1$ 个网格点）。\n- 对于每个 $k$，使用上述模型计算单原子总能 $E_k = E(E_{\\text{cut},k})$。\n- 定义连续变化的绝对值\n$$\n\\delta_k \\;=\\; \\lvert E_k - E_{k-1} \\rvert,\\quad k=1,2,\\dots,N.\n$$\n- 当且仅当以 $k^\\star$ 结尾的最后 $w$ 个连续变化满足以下条件时，在索引 $k^\\star$ 处宣布收敛\n$$\n\\delta_j \\le \\tau \\quad \\text{对于所有 } j = k^\\star-w+1,\\dots,k^\\star,\n$$\n窗口长度 $w=3$，容差 $\\tau = 0.001$ eV/原子（即 $1$ meV/原子）。\n- 选择满足该标准的最小 $k^\\star$，并报告相应的截断能 $E_{\\text{cut},k^\\star}$。如果在 $k=N$ 之前不存在这样的 $k^\\star$，则报告 $-1$。\n\n单位和数值要求。\n- 报告所有选定的截断能，单位为 $\\mathrm{eV}$，四舍五入到最接近的整数 $\\mathrm{eV}$。容差 $\\tau$ 为 $0.001$ $\\mathrm{eV}$/原子。\n- 此问题不涉及角度。不使用百分比。\n\n测试套件。您的程序必须评估以下五个测试用例。每个测试用例指定了 $(E_\\infty, A, p, E_{\\text{cut},0}, \\Delta, N)$：\n1. $( -10.0, \\; 100.0, \\; 2.0, \\; 200.0, \\; 50.0, \\; 13 )$\n2. $( -5.0, \\; 1000.0, \\; 1.8, \\; 200.0, \\; 50.0, \\; 13 )$\n3. $( -8.0, \\; 5000.0, \\; 1.2, \\; 200.0, \\; 50.0, \\; 13 )$\n4. $( -12.0, \\; 50.0, \\; 2.2, \\; 250.0, \\; 25.0, \\; 20 )$\n5. $( -7.0, \\; 15000.0, \\; 3.0, \\; 200.0, \\; 100.0, \\; 7 )$\n\n$N$ 的解释：有 $N\\!+\\!1$ 个网格点 $k=0,1,\\dots,N$，因此有 $N$ 个连续差值 $\\delta_k$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素是所选的截断能 $E_{\\text{cut},k^\\star}$，单位为 $\\mathrm{eV}$（四舍五入到最接近的整数），如果网格内未满足标准则为 $-1$，顺序与测试套件相同。例如，输出应如下所示\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。", "solution": "问题陈述经过了严格验证，被认为是科学上合理、表述清晰且完整的。它描述了一个确定计算相对于基组参数收敛性的标准数值程序，这是计算材料科学中的一项常见任务。因此，该问题是有效的，并将构建一个解决方案。\n\n该协议建立在使用平面波基组的量子力学计算的两项核心原则之上。首先，Rayleigh-Ritz 变分原理规定，计算出的基态总能 $E$ 是真实基态能量的一个上界，并且是基组尺寸的单调不增函数。在平面波基组中，基组尺寸由动能截断 $E_{\\text{cut}}$ 控制。因此，$E(E_{\\text{cut}})$ 必须是单调不增的。\n\n其次，对于此类计算中使用的典型赝势，单原子总能的截断误差随着截断能的增加呈现出幂律衰减。该问题为这种渐近行为提供了一个最小但标准的模型：\n$$\nE(E_{\\text{cut}}) \\;=\\; E_\\infty \\;+\\; A \\, E_{\\text{cut}}^{-p}\n$$\n此处，$E_\\infty$ 代表在无限大基组中无法达到但完全收敛的单原子总能。参数 $A > 0$ 取决于赝势的“硬度”（较大的 $A$ 意味着较慢的收敛），而指数 $p > 0$ 与赝波函数的光滑度有关。为了确认与变分原理的一致性，我们考察 $E$ 对 $E_{\\text{cut}}$ 的导数：\n$$\n\\frac{dE}{dE_{\\text{cut}}} \\;=\\; -p \\, A \\, E_{\\text{cut}}^{-(p+1)}\n$$\n鉴于 $p > 0$、 $A > 0$ 和 $E_{\\text{cut}} > 0$，可以得出 $dE/dE_{\\text{cut}} < 0$。因此，函数 $E(E_{\\text{cut}})$ 是严格递减的，这与变分原理所要求的单调不增性是一致的。\n\n指定的协议被实现为一个确定性算法。步骤如下：\n\n1.  **网格生成**：构建一个包含 $N+1$ 个截断能的均匀网格。对于从 $0$ 到 $N$ 的每个整数 $k$，截断能由下式给出：\n    $$\n    E_{\\text{cut},k} \\;=\\; E_{\\text{cut},0} \\;+\\; k\\,\\Delta\n    $$\n    每个测试用例都提供了参数 $E_{\\text{cut},0}$、$\\Delta$ 和 $N$。\n\n2.  **能量计算**：在网格的每个点上，使用提供的模型计算单原子总能 $E_k$：\n    $$\n    E_k \\;=\\; E(E_{\\text{cut},k}) \\;=\\; E_\\infty \\;+\\; A \\, (E_{\\text{cut},k})^{-p}\n    $$\n\n3.  **连续差值计算**：通过检查连续步骤之间能量变化的幅度来监控收敛。对于 $k=1, 2, \\dots, N$，我们定义连续差值 $\\delta_k$：\n    $$\n    \\delta_k \\;=\\; \\lvert E_k - E_{k-1} \\rvert\n    $$\n    由于 $E(E_{\\text{cut}})$ 是一个严格递减的函数，$E_k < E_{k-1}$，所以绝对值是多余的：\n    $$\n    \\delta_k \\;=\\; E_{k-1} - E_k\n    $$\n\n4.  **收敛标准的应用**：如果最近 $w$ 个能量差的“窗口”内的所有值都小于或等于指定的容差 $\\tau$，则在索引 $k^\\star$ 处宣布收敛。问题指定窗口大小 $w=3$，容差 $\\tau = 0.001$ eV/原子。算法必须在 $\\{w, w+1, \\dots, N\\}$ 范围内找到满足此条件的*最小*索引 $k^\\star$。形式上，我们寻求最小的 $k^\\star$ 使得：\n    $$\n    \\delta_j \\le \\tau \\quad \\text{对于所有 } j \\in \\{k^\\star-w+1,\\dots,k^\\star\\}\n    $$\n    对 $k^\\star$ 的搜索必须从第一个可能的索引 $k^\\star=w=3$ 开始，因为大小为 3 的窗口需要至少 3 个差值（$\\delta_1, \\delta_2, \\delta_3$）可用。\n\n5.  **输出确定**：如果找到了符合条件的 $k^\\star$，则报告相应的收敛截断能 $E_{\\text{cut},k^\\star}$，并四舍五入到最接近的整数。如果在从 $w$ 到 $N$ 的所有可能的 $k^\\star$ 的循环完成时仍未满足该标准，则表明在指定的截断能范围内未达到收敛。在这种情况下，报告值为 $-1$。\n\n因此，该实现将包含一个遍历测试用例的外层循环。对于每个用例，它将为 $E_{\\text{cut},k}$、$E_k$ 和 $\\delta_k$ 生成必要的数组。随后的一个从 $k^\\star=w$ 到 $N$ 的循环将在每一步检查收敛窗口。第一个满足标准的 $k^\\star$ 值将终止搜索，并计算和存储相应的 $E_{\\text{cut},k^\\star}$。如果此内层循环未成功完成，则存储 $-1$。最后，将收集到的结果格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the converged kinetic energy cutoff based on a given protocol\n    and a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E_inf, A, p, E_cut_0, Delta, N)\n    test_cases = [\n        (-10.0, 100.0, 2.0, 200.0, 50.0, 13),\n        (-5.0, 1000.0, 1.8, 200.0, 50.0, 13),\n        (-8.0, 5000.0, 1.2, 200.0, 50.0, 13),\n        (-12.0, 50.0, 2.2, 250.0, 25.0, 20),\n        (-7.0, 15000.0, 3.0, 200.0, 100.0, 7)\n    ]\n\n    # Convergence protocol parameters\n    w = 3         # Window length\n    tau = 0.001   # Tolerance in eV per atom\n\n    results = []\n    \n    for case in test_cases:\n        E_inf, A, p, E_cut_0, Delta, N = case\n\n        # 1. Construct a uniform grid of cutoffs\n        # The grid runs from k=0 to N, so there are N+1 points.\n        k_grid = np.arange(N + 1)\n        E_cut_k = E_cut_0 + k_grid * Delta\n\n        # 2. Compute the total energy per atom E_k for each cutoff\n        # E(E_cut) = E_inf + A * E_cut^(-p)\n        energies_k = E_inf + A * E_cut_k**(-p)\n\n        # 3. Define the absolute successive change delta_k\n        # This will be an array of N differences: E_0-E_1, E_1-E_2, ..., E_{N-1}-E_N\n        # Since E(E_cut) is a decreasing function, E_{k-1} > E_k, so abs is not needed.\n        deltas = energies_k[:-1] - energies_k[1:]\n\n        converged_cutoff_result = -1\n        # 4. Declare convergence at the minimal index k_star\n        # The first possible k_star is w=3, since we need w differences.\n        # The loop iterates through possible convergence points.\n        for k_star in range(w, N + 1):\n            # The differences to check are delta_{k_star-w+1}, ..., delta_{k_star}.\n            # In 0-based indexing for the 'deltas' array, this corresponds\n            # to indices from (k_star-w+1)-1 to k_star-1.\n            # So, indices from k_star-w to k_star-1.\n            window_indices_start = k_star - w\n            window_indices_end = k_star\n            \n            window = deltas[window_indices_start:window_indices_end]\n\n            # Check if all differences in the window are <= tau\n            if np.all(window <= tau):\n                # Convergence is met. Select the corresponding cutoff.\n                converged_cutoff_val = E_cut_0 + k_star * Delta\n                # Round to the nearest integer eV.\n                converged_cutoff_result = int(np.round(converged_cutoff_val))\n                # Break the loop as we need the minimal k_star.\n                break\n        \n        results.append(converged_cutoff_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2475310"}, {"introduction": "在确保了计算的数值收敛性之后，我们必须评估计算中所用物理近似的可靠性，其中最重要的就是赝势（pseudopotential, PSP）。一个高质量的赝势应该具有良好的“可移植性”，即在不同的化学环境（如不同的氧化态、配位数和压力）下都能准确地再现全电子计算的结果。这项实践 [@problem_id:2475337] 探索了三种标准的赝势验证测试，通过定量比较赝势与全电子计算在散射性质、局域键合刚度和宏观弹性性质上的差异，为你提供了一个评估赝势质量的框架，从而建立对模拟结果的信心。", "problem": "一位材料化学家需要验证某单一元素的保范赝势在不同氧化态、配位环境和压力下的可移植性。验证过程只得使用与第一性原理一致的诊断方法和数值上良定义的度量标准。请设计一个程序，该程序能计算基于基本散射和弹性定义的三项诊断指标，并为多个测试案例汇总计算结果。推导和算法必须且只能基于以下基础：密度泛函理论（DFT）的 Kohn–Sham 方程保证了价电子散射性质决定了成键和结构；保范条件意味着特定的径向积分相等，并由此引申出在参考通道中对数导数的近似相等；在不同配位环境中，平衡点附近的内聚能可以通过短程对势来近似；以及等温体弹模量由总能量在平衡体积处对体积的曲率定义。\n\n对于每个测试案例，您将获得模拟全电子和赝势计算结果的紧凑数据。您的任务是为每个案例计算三项度量指标：\n\n- 测试 A（跨氧化态的散射可移植性）：对于每个氧化态 $q \\in \\{0,+2,+4\\}$ 和角动量通道 $l \\in \\{0,1,2\\}$，在固定的匹配半径处的全电子对数导数被建模为关于电子能量 $E$（单位为 $\\mathrm{eV}$）的三次多项式：$D_{l}^{\\mathrm{AE}}(E;q) = c_{0}+c_{1}E+c_{2}E^{2}+c_{3}E^{3}$，赝势的 $D_{l}^{\\mathrm{PP}}(E;q)$ 也类似。在能量网格 $E \\in \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$（单位为 $\\mathrm{eV}$）上，计算最大绝对偏差\n$$\nM_{1}=\\max_{q,l,E} \\left|D_{l}^{\\mathrm{PP}}(E;q)-D_{l}^{\\mathrm{AE}}(E;q)\\right|.\n$$\n将 $M_{1}$ 报告为一个无量纲浮点数。\n\n- 测试 B（通过局域键刚度的配位可移植性）：对于八面体（$\\mathrm{CN}=6$）和四面体（$\\mathrm{CN}=4$）环境，近平衡键由 Morse 势 $V(r)=D_{e}\\left(1-e^{-a(r-r_{e})}\\right)^{2}-D_{e}$ 建模，其参数 $D_{e}$（单位为 $\\mathrm{eV}$）、$a$（单位为 $\\mathrm{\\AA}^{-1}$）和 $r_{e}$（单位为 $\\mathrm{\\AA}$）将分别为全电子参考和赝势提供。对每种环境下的两种模型计算其平衡点处的曲率 $k=\\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}}$，然后计算相对曲率误差 $\\varepsilon=\\left|k^{\\mathrm{PP}}-k^{\\mathrm{AE}}\\right|/k^{\\mathrm{AE}}$。通过取最大值来汇总两种环境的结果\n$$\nM_{2}=\\max\\{\\varepsilon_{\\mathrm{oct}},\\varepsilon_{\\mathrm{tet}}\\}.\n$$\n将 $M_{2}$ 报告为一个无量纲小数。\n\n- 测试 C（通过状态方程曲率的压力可移植性）：给定全电子参考和赝势在不同体积 $V$（单位为 $\\mathrm{\\AA}^{3}$）下的离散总能量 $E(V)$（单位为 $\\mathrm{eV}$），请确定平衡体积 $V^{\\star}$，并通过对能量最低的三个相邻点进行二次插值来估算二阶导数 $\\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}}$。根据体弹模量的热力学定义，\n$$\nB_{0} = V^{\\star} \\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}},\n$$\n计算 $B_{0}^{\\mathrm{AE}}$ 和 $B_{0}^{\\mathrm{PP}}$，使用转换因子 $1~\\mathrm{eV}/\\mathrm{\\AA}^{3} = 160.21766208~\\mathrm{GPa}$ 将单位从 $\\mathrm{eV}/\\mathrm{\\AA}^{3}$ 转换为 $\\mathrm{GPa}$，并报告以 $\\mathrm{GPa}$ 为单位的绝对差\n$$\nM_{3}=\\left|B_{0}^{\\mathrm{PP}}-B_{0}^{\\mathrm{AE}}\\right|\n$$\n\n您的程序必须为每个测试案例计算 $\\left[M_{1},M_{2},M_{3}\\right]$，并将这三个案例各自的结果向量汇总成一个单一列表。\n\n必须严格遵守所有指定的物理和数值单位：能量单位 $\\mathrm{eV}$，长度单位 $\\mathrm{\\AA}$，体积单位 $\\mathrm{\\AA}^{3}$，体弹模量单位 $\\mathrm{GPa}$。不涉及角度。所有报告的相对误差必须是小数（而非百分比）。\n\n测试套件。请精确使用以下数据。\n\n- 测试 A 的能量网格：$E \\in \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$，单位为 $\\mathrm{eV}$。\n\n- 对于所有测试案例，$D_{l}^{\\mathrm{AE}}(E;q)$ 的全电子对数导数系数 $c_{0},c_{1},c_{2},c_{3}$ 如下：\n\n  • 氧化态 $q=0$：\n    – $l=0$: $(0.2, -0.05, 0.01, -0.0005)$, \n    – $l=1$: $(0.1, 0.02, -0.005, 0.0002)$, \n    – $l=2$: $(-0.05, 0.03, 0.004, -0.0001)$.\n\n  • 氧化态 $q=+2$：\n    – $l=0$: $(0.25, -0.045, 0.011, -0.00052)$, \n    – $l=1$: $(0.12, 0.018, -0.0045, 0.00018)$, \n    – $l=2$: $(-0.04, 0.028, 0.0045, -0.000095)$.\n\n  • 氧化态 $q=+4$：\n    – $l=0$: $(0.3, -0.04, 0.012, -0.00054)$, \n    – $l=1$: $(0.14, 0.016, -0.004, 0.00016)$, \n    – $l=2$: $(-0.03, 0.026, 0.005, -0.00009)$.\n\n- 测试案例 $1$（良好的赝势）：\n\n  • 赝势多项式偏移量 $\\Delta c$，加到上述全电子系数上（即 $c^{\\mathrm{PP}}=c^{\\mathrm{AE}}+\\Delta c$）：\n  \n    – $q=0$: \n      $l=0$: $(0.002, -0.001, 0.0002, -0.00002)$, \n      $l=1$: $(-0.0015, 0.0005, -0.0003, 0.00001)$, \n      $l=2$: $(0.001, -0.0008, 0.0001, 0.0)$.\n      \n    – $q=+2$: \n      $l=0$: $(0.003, -0.0008, 0.0001, 0.0)$, \n      $l=1$: $(0.0, 0.0004, -0.0002, 0.00002)$, \n      $l=2$: $(0.0007, -0.0006, 0.0001, -0.00001)$.\n      \n    – $q=+4$: \n      $l=0$: $(0.004, -0.0005, 0.0002, 0.00002)$, \n      $l=1$: $(0.0005, 0.0003, -0.00015, 0.00002)$, \n      $l=2$: $(0.0008, -0.0005, 0.00012, -0.00002)$.\n  \n  • 分别对应八面体和四面体环境的 Morse 参数 $(D_{e},a,r_{e})$：\n  \n    – 全电子：八面体 $(1.50, 1.8, 2.00)$，四面体 $(1.20, 1.7, 2.10)$。\n    \n    – 赝势：八面体 $(1.49, 1.82, 2.01)$，四面体 $(1.18, 1.68, 2.11)$。\n  \n  • 测试 C 的体积（单位为 $\\mathrm{\\AA}^{3}$）：$[13, 14, 15, 16, 17, 18, 19]$。\n\n    – 全电子能量（单位为 $\\mathrm{eV}$）：$[-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225]$。\n    \n    – 赝势能量（单位为 $\\mathrm{eV}$）：$[-4.667138, -4.879939, -4.986128, -5.019981, -4.991551, -4.887212, -4.669016]$。\n\n- 测试案例 $2$（临界的赝势）：\n\n  • 赝势多项式偏移量 $\\Delta c$：\n  \n    – $q=0$: \n      $l=0$: $(0.01, -0.003, 0.0008, -0.00008)$, \n      $l=1$: $(-0.008, 0.002, -0.0009, 0.00005)$, \n      $l=2$: $(0.006, -0.002, 0.0005, 0.00002)$.\n      \n    – $q=+2$: \n      $l=0$: $(0.012, -0.0025, 0.0006, 0.00004)$, \n      $l=1$: $(0.005, 0.0015, -0.0007, 0.00006)$, \n      $l=2$: $(0.007, -0.002, 0.0006, -0.00002)$.\n      \n    – $q=+4$: \n      $l=0$: $(0.015, -0.002, 0.0007, 0.00005)$, \n      $l=1$: $(0.006, 0.001, -0.0006, 0.00005)$, \n      $l=2$: $(0.008, -0.0015, 0.0007, -0.00004)$.\n  \n  • Morse 参数：\n  \n    – 全电子：八面体 $(1.50, 1.8, 2.00)$，四面体 $(1.20, 1.7, 2.10)$。\n    \n    – 赝势：八面体 $(1.40, 1.75, 2.05)$，四面体 $(1.10, 1.60, 2.16)$。\n  \n  • 体积（单位为 $\\mathrm{\\AA}^{3}$）：$[13, 14, 15, 16, 17, 18, 19]$。\n\n    – 全电子能量（单位为 $\\mathrm{eV}$）：$[-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225]$。\n    \n    – 赝势能量（单位为 $\\mathrm{eV}$）：$[-4.471825, -4.7221685, -4.8452055, -4.89443675, -4.89416175, -4.8404805, -4.7002935]$。\n\n- 测试案例 $3$（较差的赝势）：\n\n  • 赝势多项式偏移量 $\\Delta c$：\n  \n    – $q=0$: \n      $l=0$: $(0.05, 0.01, 0.005, 0.0)$, \n      $l=1$: $(-0.04, 0.02, -0.003, 0.0005)$, \n      $l=2$: $(0.03, -0.015, 0.004, -0.0003)$.\n      \n    – $q=+2$: \n      $l=0$: $(0.06, 0.012, 0.006, 0.0002)$, \n      $l=1$: $(-0.035, 0.018, -0.0025, 0.0006)$, \n      $l=2$: $(0.032, -0.013, 0.0045, -0.00035)$.\n      \n    – $q=+4$: \n      $l=0$: $(0.07, 0.015, 0.007, 0.0003)$, \n      $l=1$: $(-0.03, 0.017, -0.002, 0.0007)$, \n      $l=2$: $(0.035, -0.012, 0.005, -0.0004)$.\n  \n  • Morse 参数：\n  \n    – 全电子：八面体 $(1.50, 1.8, 2.00)$，四面体 $(1.20, 1.7, 2.10)$。\n    \n    – 赝势：八面体 $(1.10, 1.5, 2.20)$，四面体 $(0.90, 1.4, 2.30)$。\n  \n  • 体积（单位为 $\\mathrm{\\AA}^{3}$）：$[13, 14, 15, 16, 17, 18, 19]$。\n\n    – 全电子能量（单位为 $\\mathrm{eV}$）：$[-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225]$。\n    \n    – 赝势能量（单位为 $\\mathrm{eV}$）：$[-3.976031, -4.317781, -4.367925, -4.463703, -4.49646725, -4.49621725, -4.456953]$。\n\n答案规格和输出格式：\n\n- 为三个测试案例中的每一个，计算如上定义的元组 $[M_{1},M_{2},M_{3}]$。\n\n- 您的程序应生成单行输出，其中包含这三个元组，形式为以逗号分隔的列表之列表，每个浮点数四舍五入到六位小数，并用方括号括起来。例如：$[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],[x_{31},x_{32},x_{33}]]$，其中每个 $x_{ij}$ 都是一个浮点数。\n\n- 不需要也不允许用户输入；所有数据均按给定值固定。\n\n解法必须从所述基础推导得出，且不得假定问题陈述中给出了超出这些定义的任何公式。实现时可使用通用数值方法，例如多项式求值、有限差分和二次插值。使用转换因子 $1~\\mathrm{eV}/\\mathrm{\\AA}^{3} = 160.21766208~\\mathrm{GPa}$ 以 $\\mathrm{GPa}$ 表示 $M_{3}$。角度单位不适用。最终的数值输出必须遵守指定的单位和舍入规则。", "solution": "问题陈述已根据要求准则进行解析和验证。\n\n**结论：** 问题是 **有效** 的。\n\n**理由：**\n1.  **科学依据**：该问题牢固地植根于计算材料科学的原理，特别是密度泛函理论（DFT）。用于赝势验证的诊断方法——比较散射波函数的对数导数、从势能面分析键刚度、以及从状态方程计算体弹模量——是该领域中标准的、具有物理意义且数值上良定义的过程。所提供的理论背景是准确的。\n2.  **良构性**：该问题在数学和计算上是良构的。它为三个测试案例中的每一个提供了所有必要的数据和常数。度量指标 $M_{1}$、$M_{2}$ 和 $M_{3}$ 的定义是明确的，并导向一个唯一的、可计算的结果。所需的数值方法（多项式求值、二次插值）是标准的。\n3.  **客观性和完备性**：该问题用客观、定量的语言陈述。所有参数、变量和条件都得到了明确定义。问题是自洽的，无需任何超出所提供范围的外部信息或假设。\n\n该问题没有科学谬误、矛盾或模糊之处。它代表了一项具体且不平凡的计算任务，该任务直接模拟了真实的科学工作流程。因此，有必要给出一个完整的解。\n\n**解法推导与算法设计**\n\n任务是为一个赝势的三个测试案例计算三项诊断度量指标——$M_{1}$、$M_{2}$ 和 $M_{3}$。解法通过独立处理每项度量指标的计算来构建。\n\n**度量指标 $M_{1}$：散射可移植性**\n该度量指标量化了全电子（AE）参考和赝势（PP）模型在不同氧化态 $q$ 和角动量通道 $l$ 下散射性质的差异。核心量是对数导数 $D_{l}(E;q)$，它被建模为关于能量 $E$ 的三次多项式：$D(E) = c_{0}+c_{1}E+c_{2}E^{2}+c_{3}E^{3}$。\n\n问题要求计算 $M_{1}=\\max_{q,l,E} \\left|D_{l}^{\\mathrm{PP}}(E;q)-D_{l}^{\\mathrm{AE}}(E;q)\\right|$。\n赝势多项式的系数由 $c^{\\mathrm{PP}} = c^{\\mathrm{AE}} + \\Delta c$ 给出。\n因此，其差值也是一个三次多项式，其系数是所提供的偏移量 $\\Delta c = (\\Delta c_{0}, \\Delta c_{1}, \\Delta c_{2}, \\Delta c_{3})$：\n$$\n\\Delta D_{l}(E;q) = D_{l}^{\\mathrm{PP}}(E;q) - D_{l}^{\\mathrm{AE}}(E;q) = \\Delta c_{0} + \\Delta c_{1}E + \\Delta c_{2}E^{2} + \\Delta c_{3}E^{3}\n$$\n计算 $M_1$ 的算法如下：\n1.  初始化一个变量 `max_deviation` 为 $0$。\n2.  定义能量网格 $E \\in \\{-5, -4, \\dots, 4, 5\\}$，单位为 $\\mathrm{eV}$。\n3.  遍历氧化态 $q \\in \\{0,+2,+4\\}$ 和角动量 $l \\in \\{0,1,2\\}$ 的每种组合。\n4.  对于每对 $(q, l)$，获取对应的 $\\Delta c$ 向量。\n5.  对能量网格中所有 $E$ 的值，计算多项式 $\\Delta D_{l}(E;q)$。\n6.  计算这些结果的最大绝对值，$\\max_{E} |\\Delta D_{l}(E;q)|$。\n7.  如果该值大于当前最大值，则更新 `max_deviation`。\n8.  `max_deviation` 的最终值就是度量指标 $M_1$。\n\n**度量指标 $M_{2}$：配位可移植性**\n该度量指标通过比较从 Morse 势模型 $V(r)=D_{e}\\left(1-e^{-a(r-r_{e})}\\right)^{2}-D_{e}$ 导出的键刚度，来评估赝势再现局域成键环境的能力。刚度是势在平衡键距 $r_e$ 处的曲率。\n\n曲率 $k$ 定义为 $k = \\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}}$。我们首先计算 Morse 势的导数：\n$$\n\\frac{dV}{dr} = D_{e} \\cdot 2\\left(1-e^{-a(r-r_{e})}\\right) \\cdot \\left(-e^{-a(r-r_{e})}\\right) \\cdot (-a) = 2aD_{e}\\left(e^{-a(r-r_{e})} - e^{-2a(r-r_{e})}\\right)\n$$\n$$\n\\frac{d^{2}V}{dr^{2}} = 2aD_{e}\\left(-a e^{-a(r-r_{e})} + 2a e^{-2a(r-r_{e})}\\right)\n$$\n在平衡距离 $r=r_{e}$ 处计算二阶导数：\n$$\nk = \\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}} = 2aD_{e}\\left(-a e^{0} + 2a e^{0}\\right) = 2aD_{e}(-a + 2a) = 2a^{2}D_{e}\n$$\n计算 $M_2$ 的算法如下：\n1.  对八面体环境，计算 AE 和 PP 曲率：\n    $k_{\\mathrm{oct}}^{\\mathrm{AE}} = 2 (a_{\\mathrm{oct}}^{\\mathrm{AE}})^2 D_{e, \\mathrm{oct}}^{\\mathrm{AE}}$\n    $k_{\\mathrm{oct}}^{\\mathrm{PP}} = 2 (a_{\\mathrm{oct}}^{\\mathrm{PP}})^2 D_{e, \\mathrm{oct}}^{\\mathrm{PP}}$\n2.  计算八面体情况下的相对误差：$\\varepsilon_{\\mathrm{oct}}=\\left|k_{\\mathrm{oct}}^{\\mathrm{PP}}-k_{\\mathrm{oct}}^{\\mathrm{AE}}\\right|/k_{\\mathrm{oct}}^{\\mathrm{AE}}$。\n3.  对四面体环境重复步骤1和2，以找到 $k_{\\mathrm{tet}}^{\\mathrm{AE}}$、$k_{\\mathrm{tet}}^{\\mathrm{PP}}$ 和 $\\varepsilon_{\\mathrm{tet}}$。\n4.  度量指标 $M_2$ 是两个相对误差中的最大值：$M_{2}=\\max\\{\\varepsilon_{\\mathrm{oct}},\\varepsilon_{\\mathrm{tet}}\\}$。\n\n**度量指标 $M_{3}$：压力可移植性**\n该度量指标比较了从状态方程（EOS）（即总能量 $E$ 作为体积 $V$ 的函数）导出的体弹模量 $B_0$，这是一种宏观弹性性质。其热力学定义为 $B_{0} = V^{\\star} \\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}}$，其中 $V^{\\star}$ 是平衡体积。\n\n该算法对以能量最低点为中心的三个点使用二次插值，将 EOS 曲线在局部建模为 $E(V) \\approx aV^2 + bV + c$。\n1.  对于一个给定的离散 $E(V)$ 数据集，找到对应于最低能量的索引 `i_min`。\n2.  选择三个点 $(V_{i}, E_{i})$，其中 $i \\in \\{\\text{i\\_min}-1, \\text{i\\_min}, \\text{i\\_min}+1\\}$。\n3.  用 $E(V) = aV^2 + bV + c$ 对这三个点进行二次多项式拟合。这可以通过解一个 $3 \\times 3$ 线性方程组或使用标准数值库函数来完成。系数 $a$ 和 $b$ 就足够了。\n4.  从拟合的抛物线可知，二阶导数是一个常数：$\\frac{d^{2}E}{dV^{2}} = 2a$。\n5.  平衡体积 $V^{\\star}$ 对应于抛物线的最小值点，该点出现在 $\\frac{dE}{dV} = 2aV + b = 0$ 处，所以 $V^{\\star} = -b/(2a)$。\n6.  然后计算出体弹模量（单位为 $\\mathrm{eV}/\\mathrm{\\AA}^{3}$）为 $B_{0} = V^{\\star} \\left(2a\\right) = \\left(-\\frac{b}{2a}\\right) \\left(2a\\right) = -b$。\n7.  对 AE 和 PP 数据集都执行此过程，以找到 $B_{0}^{\\mathrm{AE}}$ 和 $B_{0}^{\\mathrm{PP}}$。\n8.  最终度量指标 $M_3$ 是换算为吉帕斯卡（GPa）的绝对差：\n    $M_{3}=\\left|B_{0}^{\\mathrm{PP}}-B_{0}^{\\mathrm{AE}}\\right| \\times 160.21766208 \\text{ GPa}/(\\mathrm{eV}/\\mathrm{\\AA}^{3})$。\n\n这三种算法的组合为每个测试案例提供了所需的元组 $[M_1, M_2, M_3]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes three pseudopotential validation metrics (M1, M2, M3) for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Common All-Electron (AE) data for all test cases\n    # AE Log-derivative polynomial coefficients: c0, c1, c2, c3\n    c_ae_coeffs = {\n        0: {  # q=0\n            0: [0.2, -0.05, 0.01, -0.0005],  # l=0\n            1: [0.1, 0.02, -0.005, 0.0002],  # l=1\n            2: [-0.05, 0.03, 0.004, -0.0001],  # l=2\n        },\n        2: {  # q=+2\n            0: [0.25, -0.045, 0.011, -0.00052],  # l=0\n            1: [0.12, 0.018, -0.0045, 0.00018],  # l=1\n            2: [-0.04, 0.028, 0.0045, -0.000095],  # l=2\n        },\n        4: {  # q=+4\n            0: [0.3, -0.04, 0.012, -0.00054],  # l=0\n            1: [0.14, 0.016, -0.004, 0.00016],  # l=1\n            2: [-0.03, 0.026, 0.005, -0.00009],  # l=2\n        },\n    }\n    \n    # AE Morse parameters (De, a, re)\n    morse_ae = {\n        'oct': (1.50, 1.8, 2.00),\n        'tet': (1.20, 1.7, 2.10)\n    }\n\n    # AE E(V) data\n    volumes_eos = np.array([13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0])\n    energies_ae_eos = np.array([-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225])\n    \n    # Energy grid for Test A\n    energy_grid = np.arange(-5, 6, 1)\n\n    # Conversion factor for Test C\n    GPA_CONV_FACTOR = 160.21766208\n\n    # Test cases data\n    test_cases = [\n        # Test Case 1: good pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.002, -0.001, 0.0002, -0.00002], 1: [-0.0015, 0.0005, -0.0003, 0.00001], 2: [0.001, -0.0008, 0.0001, 0.0]},\n                2: {0: [0.003, -0.0008, 0.0001, 0.0], 1: [0.0, 0.0004, -0.0002, 0.00002], 2: [0.0007, -0.0006, 0.0001, -0.00001]},\n                4: {0: [0.004, -0.0005, 0.0002, 0.00002], 1: [0.0005, 0.0003, -0.00015, 0.00002], 2: [0.0008, -0.0005, 0.00012, -0.00002]},\n            },\n            \"morse_pp\": {'oct': (1.49, 1.82, 2.01), 'tet': (1.18, 1.68, 2.11)},\n            \"energies_pp_eos\": np.array([-4.667138, -4.879939, -4.986128, -5.019981, -4.991551, -4.887212, -4.669016]),\n        },\n        # Test Case 2: borderline pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.01, -0.003, 0.0008, -0.00008], 1: [-0.008, 0.002, -0.0009, 0.00005], 2: [0.006, -0.002, 0.0005, 0.00002]},\n                2: {0: [0.012, -0.0025, 0.0006, 0.00004], 1: [0.005, 0.0015, -0.0007, 0.00006], 2: [0.007, -0.002, 0.0006, -0.00002]},\n                4: {0: [0.015, -0.002, 0.0007, 0.00005], 1: [0.006, 0.001, -0.0006, 0.00005], 2: [0.008, -0.0015, 0.0007, -0.00004]},\n            },\n            \"morse_pp\": {'oct': (1.40, 1.75, 2.05), 'tet': (1.10, 1.60, 2.16)},\n            \"energies_pp_eos\": np.array([-4.471825, -4.7221685, -4.8452055, -4.89443675, -4.89416175, -4.8404805, -4.7002935]),\n        },\n        # Test Case 3: poor pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.05, 0.01, 0.005, 0.0], 1: [-0.04, 0.02, -0.003, 0.0005], 2: [0.03, -0.015, 0.004, -0.0003]},\n                2: {0: [0.06, 0.012, 0.006, 0.0002], 1: [-0.035, 0.018, -0.0025, 0.0006], 2: [0.032, -0.013, 0.0045, -0.00035]},\n                4: {0: [0.07, 0.015, 0.007, 0.0003], 1: [-0.03, 0.017, -0.002, 0.0007], 2: [0.035, -0.012, 0.005, -0.0004]},\n            },\n            \"morse_pp\": {'oct': (1.10, 1.5, 2.20), 'tet': (0.90, 1.4, 2.30)},\n            \"energies_pp_eos\": np.array([-3.976031, -4.317781, -4.367925, -4.463703, -4.49646725, -4.49621725, -4.456953]),\n        },\n    ]\n\n    # --- Calculation Functions ---\n\n    def calculate_m1(delta_c_data):\n        max_deviation = 0.0\n        for q in delta_c_data:\n            for l in delta_c_data[q]:\n                coeffs = delta_c_data[q][l]\n                # np.poly1d expects coefficients for highest power first\n                poly_diff = np.poly1d(coeffs[::-1])\n                deviations_on_grid = np.abs(poly_diff(energy_grid))\n                max_deviation = max(max_deviation, np.max(deviations_on_grid))\n        return max_deviation\n\n    def calculate_m2(morse_ae, morse_pp):\n        def get_curvature(params):\n            De, a, _ = params\n            return 2.0 * a**2 * De\n\n        k_ae_oct = get_curvature(morse_ae['oct'])\n        k_pp_oct = get_curvature(morse_pp['oct'])\n        eps_oct = abs(k_pp_oct - k_ae_oct) / k_ae_oct\n\n        k_ae_tet = get_curvature(morse_ae['tet'])\n        k_pp_tet = get_curvature(morse_pp['tet'])\n        eps_tet = abs(k_pp_tet - k_ae_tet) / k_ae_tet\n        \n        return max(eps_oct, eps_tet)\n\n    def get_bulk_modulus(volumes, energies):\n        if len(volumes) < 3:\n            raise ValueError(\"Need at least 3 points for quadratic interpolation.\")\n\n        i_min = np.argmin(energies)\n        \n        # Ensure we don't go out of bounds, though problem data is safe\n        if i_min == 0 or i_min == len(volumes) - 1:\n             raise ValueError(\"Minimum energy is at an endpoint, cannot form a 3-point stencil.\")\n\n        V_fit = volumes[i_min-1:i_min+2]\n        E_fit = energies[i_min-1:i_min+2]\n\n        # Fit E = aV^2 + bV + c\n        # a, b, c = np.polyfit(V_fit, E_fit, 2)\n        # B0 = V* * (d2E/dV2) = (-b/2a) * (2a) = -b\n        a, b, c = np.polyfit(V_fit, E_fit, 2)\n        \n        b0_ev_per_a3 = -b\n        return b0_ev_per_a3\n\n    def calculate_m3(volumes_eos, energies_ae_eos, energies_pp_eos):\n        b0_ae = get_bulk_modulus(volumes_eos, energies_ae_eos)\n        b0_pp = get_bulk_modulus(volumes_eos, energies_pp_eos)\n        \n        m3_gpa = abs(b0_pp - b0_ae) * GPA_CONV_FACTOR\n        return m3_gpa\n\n    # --- Main Loop ---\n    \n    all_results = []\n    for case in test_cases:\n        m1 = calculate_m1(case[\"delta_c\"])\n        m2 = calculate_m2(morse_ae, case[\"morse_pp\"])\n        m3 = calculate_m3(volumes_eos, energies_ae_eos, case[\"energies_pp_eos\"])\n        \n        all_results.append([m1, m2, m3])\n\n    # --- Format and Print Output ---\n    \n    formatted_results = []\n    for result_triplet in all_results:\n        m1, m2, m3 = result_triplet\n        formatted_triplet = f\"[{m1:.6f},{m2:.6f},{m3:.6f}]\"\n        formatted_results.append(formatted_triplet)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2475337"}, {"introduction": "当我们掌握了进行可靠计算的工具后，就可以从研究材料的静态性质转向探索动态过程，例如化学反应。理解反应速率和机理的关键在于识别和表征过渡态（transition state, TS），它是在势能面上连接反应物和产物的一阶鞍点。这项实践要求你严格应用过渡态的数学定义：它是一个梯度为零的驻点，其Hessian矩阵有且仅有一个负本征值（对应一个虚频），并且通过内禀反应坐标（intrinsic reaction coordinate, IRC）连接了正确的反应物和产物。通过亲手实现这些验证标准 [@problem_id:2475357]，你将对过渡态这一核心概念获得深刻的、操作层面的理解，这对于研究反应机理和动力学至关重要。", "problem": "您需要形式化并实现一套准则，仅使用势能面上的微积分第一性原理，来验证势能面上一个给定的原子构型是否为反应路径理论意义上的真正过渡态。该验证必须结合两个基本要求：(i) 通过黑塞指数（Hessian index）（单个不稳定模式对应于单个虚频）确定驻点的局部特性，以及 (ii) 通过质量加权坐标中的内禀反应坐标（intrinsic reaction coordinate）与正确的反应物和产物极小值点的动态连通性。所有坐标单位为埃（$\\mathrm{\\AA}$），所有能量单位为电子伏特（$\\mathrm{eV}$）。由于您的程序必须输出布尔值，因此在最终输出中不要报告任何单位。\n\n基本原理与定义：笛卡尔坐标 $\\mathbf{q} \\in \\mathbb{R}^n$ 上的势能面 $V(\\mathbf{q})$ 定义了力为 $-\\nabla V(\\mathbf{q})$。驻点满足 $\\nabla V(\\mathbf{q}_\\mathrm{s})=\\mathbf{0}$。在驻点处的黑塞矩阵（Hessian matrix）$H(\\mathbf{q})=\\nabla^2 V(\\mathbf{q})$ 对其性质进行分类：极小值点的黑塞矩阵所有特征值均为正，而一个指数为 $k$ 的鞍点（index-$k$ saddle）恰好有 $k$ 个负特征值（等价于在谐振子近似下有 $k$ 个虚谐振频率）。一个真正的过渡态（一阶鞍点）有且仅有一个负特征值，其余所有特征值均为严格正值。内禀反应坐标是从过渡态沿唯一的不稳定模式朝向相邻极小值点的质量加权坐标下的最速下降曲线。在本问题中，设所有质量均为单位1，因此笛卡尔坐标下的最速下降与质量加权最速下降一致。您可以通过沿 $-\\nabla V(\\mathbf{q})$ 的迭代步长来离散化内禀反应坐标，并使用线搜索（line-search）来确保 $V$ 的单调递减。\n\n任务：编写一个完整的程序，对下面的每个测试用例，判断给定的候选构型 $\\mathbf{q}_c$ 是否为连接两个指定极小值点的真正过渡态。您的决策必须仅基于从上述基本原理推导出的以下准则：\n\n- 驻点性 (Stationarity)：$\\lVert \\nabla V(\\mathbf{q}_c)\\rVert_2 \\le \\varepsilon_\\mathrm{grad}$。\n- 指数为1的黑塞矩阵 (Index-$1$ Hessian)：$H(\\mathbf{q}_c)$ 恰好有一个特征值小于 $-\\varepsilon_\\lambda$，所有其他特征值均大于 $\\varepsilon_\\lambda$，且没有特征值的绝对值小于等于 $\\varepsilon_\\lambda$。\n- 通过内禀反应坐标的连通性 (Connectivity by an intrinsic reaction coordinate)：令 $\\mathbf{v}_-$ 为 $H(\\mathbf{q}_c)$ 最负特征值对应的归一化特征向量。初始化两个点 $\\mathbf{q}_\\pm^{(0)}=\\mathbf{q}_c \\pm \\delta\\, \\mathbf{v}_-$。对于每个分支 $b\\in\\{+,-\\}$，迭代更新 $\\mathbf{q}_b^{(k+1)}=\\mathbf{q}_b^{(k)} - s_k \\nabla V(\\mathbf{q}_b^{(k)})$，并对 $s_k$ 进行回溯以强制满足 $V(\\mathbf{q}_b^{(k+1)}) < V(\\mathbf{q}_b^{(k)})$，直至收敛到满足 $\\lVert \\nabla V(\\mathbf{q}_b^{(*)})\\rVert_2 \\le \\varepsilon_\\mathrm{grad}$ 的驻点。每个收敛的终点都必须是一个极小值点（其黑塞矩阵的所有特征值均大于 $\\varepsilon_\\lambda$），并且必须在坐标容差 $\\varepsilon_\\mathrm{dist}$ 内与两个目标极小值点之一匹配（无序匹配，使用端点到目标点距离的最小和）。\n\n使用以下容差，您必须统一应用这些容差：$\\varepsilon_\\mathrm{grad}=10^{-6}\\ \\mathrm{eV}/\\mathrm{\\AA}$，$\\varepsilon_\\lambda=10^{-4}\\ \\mathrm{eV}/\\mathrm{\\AA}^2$，$\\varepsilon_\\mathrm{dist}=10^{-2}\\ \\mathrm{\\AA}$，小位移 $\\delta=10^{-3}\\ \\mathrm{\\AA}$，以及每个内禀反应坐标分支最多 $N_\\mathrm{iter}=2000$ 步的合理迭代次数上限。步长 $s_k$ 可以自由选择，但必须为正，并且在势能未能减小时应减小步长；您可以从 $s_0=10^{-1}$ 开始初始化，并根据需要通过减半进行回溯。本问题不使用角度，因此不需要角度单位。\n\n势函数：对于每个测试，势函数 $V(x,y)$ 都有明确定义。此处 $x$ 和 $y$ 表示 $\\mathbb{R}^2$ 中的两个笛卡尔自由度，模拟了材料化学背景下的简化二维反应坐标。\n\n- 双阱加谐振势 (Double-well plus harmonic): $V_1(x,y) = a\\,(x^2-b^2)^2 + c\\,y^2$.\n- 耦合双阱势 (Coupled double-well): $V_2(x,y) = a\\,(x^2-b^2)^2 + c\\,y^2 + d\\,x\\,y$.\n- 稳定的倒置二次势 (Stabilized inverted quadratic, higher-order saddle at the origin): $V_3(x,y) = \\alpha\\,x^4 + \\beta\\,y^4 - \\tfrac{1}{2}k_x x^2 - \\tfrac{1}{2}k_y y^2$.\n\n测试套件：对于每种情况，都给出了势函数类型和参数、候选点 $\\mathbf{q}_c=(x_c,y_c)$ 以及两个目标极小值点。您的程序必须评估上述准则，并为每种情况返回一个布尔值。\n\n- 情况 $1$（理想路径，正确的过渡态和连通性）：\n  - 势函数：$V_1$，参数为 $a=0.05$, $b=1.5$, $c=0.2$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n- 情况 $2$（极小值点被误分类为候选点，应无法通过指数为1的测试）：\n  - 势函数：$V_1$，参数为 $a=0.05$, $b=1.5$, $c=0.2$。\n  - 候选点：$\\mathbf{q}_c=(1.5,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n- 情况 $3$（具有两个不稳定模式的高阶鞍点，应无法通过指数为1的测试）：\n  - 势函数：$V_3$，参数为 $\\alpha=0.1$, $\\beta=0.1$, $k_x=0.6$, $k_y=0.5$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.0,0.0),(1.0,0.0)\\}$。\n\n- 情况 $4$（正确的指数为1的鞍点，但耦合路径连接到偏移的极小值点；目标点被故意设置不匹配以测试连通性验证）：\n  - 势函数：$V_2$，参数为 $a=0.05$, $b=1.5$, $c=0.2$, $d=0.3$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n- 情况 $5$（候选点处沿一个模式的曲率接近于零，应无法满足严格的指数为1的要求）：\n  - 势函数：$V_1$，参数为 $a=0.05$, $b=1.5$, $c=1.0\\times 10^{-8}$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n答案规格：所有情况的输出必须汇总到单行中，该行包含一个Python风格的布尔值列表，按情况1到5的顺序排列，不含空格，例如，`[True,False,...]`。您的程序必须是一个完整的、可运行的实现，它根据上述定义执行所有计算，并精确打印这一行。不允许用户输入，也不得使用外部文件。", "solution": "所述问题是有效的。这是一个适定（well-posed）的、有科学依据的计算任务，没有矛盾和歧义，并且不需要超出所提供信息以外的任何信息。该问题要求实现一个严谨的、基于第一性原理的算法，以验证一个候选原子构型是否为连接两个指定化学极小值点的真正过渡态。解决此问题需要综合多元微积分和反应动力学理论中的概念，并将其实现为一个精确的数值算法。\n\n验证过程由三个相继的准则组成，每个准则都必须满足。势能面 $V(\\mathbf{q})$ 上的一个候选构型 $\\mathbf{q}_c$ 是连接极小值点 $\\mathbf{q}_A$ 和 $\\mathbf{q}_B$ 的真正过渡态，当且仅当它满足以下条件。\n\n首先，候选点必须是势能面上的一个驻点。在驻点处，所有力都为零。系统受到的力由势的负梯度给出，即 $\\mathbf{F}(\\mathbf{q}) = -\\nabla V(\\mathbf{q})$。因此，驻点条件是 $\\nabla V(\\mathbf{q}_c) = \\mathbf{0}$。对于数值验证，我们将其放宽为基于容差的检查：梯度向量的欧几里得范数必须小于给定的阈值 $\\varepsilon_\\mathrm{grad}$。\n$$\n\\lVert \\nabla V(\\mathbf{q}_c) \\rVert_2 \\le \\varepsilon_\\mathrm{grad}\n$$\n在此问题中，$\\varepsilon_\\mathrm{grad} = 10^{-6}\\ \\mathrm{eV}/\\mathrm{\\AA}$。\n\n其次，该驻点必须是一阶鞍点，也称为过渡态。驻点 $\\mathbf{q}_s$ 处势能面的局部曲率由其黑塞矩阵描述，$H_{ij}(\\mathbf{q}_s) = \\frac{\\partial^2 V}{\\partial q_i \\partial q_j}\\rvert_{\\mathbf{q}_s}$。驻点的性质由该矩阵的特征值的符号决定。极小值点的所有特征值均为正，而指数为 $k$ 的鞍点恰好有 $k$ 个负特征值。一个真正的过渡态是指数为1的鞍点。此外，为避免与近乎平坦的势能区域（零模式）产生歧义，所有曲率都必须是显著的。这转化为条件：$\\mathbf{q}_c$ 处的黑塞矩阵必须有且仅有一个严格为负的特征值（小于 $-\\varepsilon_\\lambda$），而所有其他特征值必须严格为正（大于 $\\varepsilon_\\lambda$）。这种严格性确保了没有零或接近零的特征值。对于给定的 $\\mathbb{R}^2$ 中的问题，这意味着一个特征值 $\\lambda_1 < -\\varepsilon_\\lambda$ 而另一个特征值 $\\lambda_2 > \\varepsilon_\\lambda$，其中 $\\varepsilon_\\lambda = 10^{-4}\\ \\mathrm{eV}/\\mathrm{\\AA}^2$。\n\n第三，过渡态必须动态地连接指定的反应物和产物极小值点。这通过追踪内禀反应坐标（IRC）来验证。IRC 是从过渡态下降到相邻极小值点的最速下降路径。初始下降方向由与黑塞矩阵的唯一负特征值相关联的特征向量 $\\mathbf{v}_-$ 唯一确定。由于问题假设所有自由度的质量均为单位1，质量加权坐标系与笛卡尔坐标系相同，因此IRC路径就是最速下降路径。我们从过渡态开始沿正向和反向两个方向追踪此路径。过程如下：\n1.  确定与 $H(\\mathbf{q}_c)$ 的负特征值相对应的归一化特征向量 $\\mathbf{v}_-$。\n2.  通过将候选点 $\\mathbf{q}_c$ 沿 $\\mathbf{v}_-$ 方向微移一个很小的量 $\\delta$ 来初始化两条反应路径。IRC两个分支的起始点为 $\\mathbf{q}_\\pm^{(0)} = \\mathbf{q}_c \\pm \\delta \\mathbf{v}_-$，其中 $\\delta = 10^{-3}\\ \\mathrm{\\AA}$。\n3.  对每个分支执行梯度下降优化，以找到其连接的极小值点。每一步 $k$ 的更新规则是 $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - s_k \\nabla V(\\mathbf{q}^{(k)})$。步长 $s_k$ 通过回溯线搜索确定，从 $s_0 = 10^{-1}$ 开始，每次减半其值，直到满足条件 $V(\\mathbf{q}^{(k+1)}) < V(\\mathbf{q}^{(k)})$。这确保了沿路径的能量单调递减。\n4.  当达到一个点 $\\mathbf{q}^*$ 时，下降终止，该点满足驻点条件 $\\lVert \\nabla V(\\mathbf{q}^*) \\rVert_2 \\le \\varepsilon_\\mathrm{grad}$，并且总步数在最大值 $N_\\mathrm{iter} = 2000$ 之内。\n5.  收敛后，必须通过检查其黑塞矩阵 $H(\\mathbf{q}^*)$ 的所有特征值是否均为严格正值（即大于 $\\varepsilon_\\lambda$），来验证每个端点 $\\mathbf{q}^*$ 都是一个真正的极小值点。\n6.  最后，由两个收敛并验证过的极小值点组成的集合 $\\{\\mathbf{q}^*_+, \\mathbf{q}^*_-\\}$ 必须与目标极小值点集合 $\\{\\mathbf{q}_A, \\mathbf{q}_B\\}$ 匹配。该匹配是无序的，意味着我们检查每个端点是否在距离容差 $\\varepsilon_\\mathrm{dist} = 10^{-2}\\ \\mathrm{\\AA}$ 内与一个唯一的目标极小值点相对应。\n\n候选构型 $\\mathbf{q}_c$ 当且仅当它依次通过所有这三项检查时，才被确认为真正的过渡态。所提供的代码实现了这一完整算法，包括用于评估给定测试用例的指定势能函数的梯度和黑塞矩阵的解析表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import norm, eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the transition state verification for all test cases.\n    \"\"\"\n    \n    # Global constants from the problem statement\n    EPS_GRAD = 1e-6\n    EPS_LAMBDA = 1e-4\n    EPS_DIST = 1e-2\n    DELTA = 1e-3\n    N_ITER = 2000\n    S_INIT = 0.1\n\n    def get_potential_v1(params):\n        \"\"\"Factory for V1 potential, gradient, and Hessian.\"\"\"\n        a, b, c = params['a'], params['b'], params['c']\n        \n        def V(q):\n            x, y = q\n            return a * (x**2 - b**2)**2 + c * y**2\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * a * x * (x**2 - b**2), 2 * c * y])\n        \n        def HessV(q):\n            x, y = q\n            return np.array([[a * (12 * x**2 - 4 * b**2), 0.0], [0.0, 2 * c]])\n            \n        return V, gradV, HessV\n\n    def get_potential_v2(params):\n        \"\"\"Factory for V2 potential, gradient, and Hessian.\"\"\"\n        a, b, c, d = params['a'], params['b'], params['c'], params['d']\n        \n        def V(q):\n            x, y = q\n            return a * (x**2 - b**2)**2 + c * y**2 + d * x * y\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * a * x * (x**2 - b**2) + d * y, 2 * c * y + d * x])\n            \n        def HessV(q):\n            x, y = q\n            return np.array([[a * (12 * x**2 - 4 * b**2), d], [d, 2 * c]])\n            \n        return V, gradV, HessV\n\n    def get_potential_v3(params):\n        \"\"\"Factory for V3 potential, gradient, and Hessian.\"\"\"\n        alpha, beta, kx, ky = params['alpha'], params['beta'], params['k_x'], params['k_y']\n        \n        def V(q):\n            x, y = q\n            return alpha * x**4 + beta * y**4 - 0.5 * kx * x**2 - 0.5 * ky * y**2\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * alpha * x**3 - kx * x, 4 * beta * y**3 - ky * y])\n            \n        def HessV(q):\n            x, y = q\n            return np.array([[12 * alpha * x**2 - kx, 0.0], [0.0, 12 * beta * y**2 - ky]])\n            \n        return V, gradV, HessV\n\n    potential_factories = {\n        'V1': get_potential_v1,\n        'V2': get_potential_v2,\n        'V3': get_potential_v3,\n    }\n\n    def find_minimum(start_q, V, gradV, HessV):\n        \"\"\"\n        Performs gradient descent with backtracking to find a minimum.\n        Returns the coordinate of the minimum or None if convergence fails\n        or the converged point is not a minimum.\n        \"\"\"\n        q = np.copy(start_q)\n        v_current = V(q)\n\n        for _ in range(N_ITER):\n            grad = gradV(q)\n            \n            if norm(grad) < EPS_GRAD:\n                # Converged to a stationary point, now check if it's a minimum\n                hess = HessV(q)\n                eigenvals, _ = eigh(hess)\n                if np.all(eigenvals > EPS_LAMBDA):\n                    return q  # It's a valid minimum\n                else:\n                    return None  # Converged but not to a minimum\n\n            s = S_INIT\n            while True:\n                q_new = q - s * grad\n                if V(q_new) < v_current:\n                    q = q_new\n                    v_current = V(q)\n                    break\n                s /= 2.0\n                if s < 1e-15:  # Step size is too small, cannot proceed\n                    return None\n        return None # Failed to converge within N_ITER\n\n    def is_true_transition_state(case):\n        \"\"\"\n        Applies the three-part verification to determine if a candidate\n        is a true transition state.\n        \"\"\"\n        V, gradV, HessV = potential_factories[case['potential_type']](case['params'])\n        qc = np.array(case['candidate'])\n        targets = [np.array(t) for t in case['targets']]\n        \n        # 1. Stationarity Check\n        grad_qc = gradV(qc)\n        if norm(grad_qc) > EPS_GRAD:\n            return False\n\n        # 2. Hessian Index-1 Check\n        hess_qc = HessV(qc)\n        eigenvals, eigenvecs = eigh(hess_qc)\n\n        # Check for exactly one negative eigenvalue and the rest positive,\n        # with magnitudes outside the epsilon_lambda tolerance.\n        neg_count = np.sum(eigenvals < -EPS_LAMBDA)\n        pos_count = np.sum(eigenvals > EPS_LAMBDA)\n        if not (neg_count == 1 and (neg_count + pos_count) == len(eigenvals)):\n            return False\n            \n        # Get the eigenvector for the unique negative eigenvalue\n        neg_eig_idx = np.argmin(eigenvals)\n        v_neg = eigenvecs[:, neg_eig_idx]\n\n        # 3. Connectivity Check (IRC)\n        q_start_plus = qc + DELTA * v_neg\n        q_start_minus = qc - DELTA * v_neg\n\n        endpoint1 = find_minimum(q_start_plus, V, gradV, HessV)\n        endpoint2 = find_minimum(q_start_minus, V, gradV, HessV)\n        \n        if endpoint1 is None or endpoint2 is None:\n            return False\n\n        t1, t2 = targets\n        dist_11 = norm(endpoint1 - t1)\n        dist_12 = norm(endpoint1 - t2)\n        dist_21 = norm(endpoint2 - t1)\n        dist_22 = norm(endpoint2 - t2)\n\n        # Check for unordered matching of endpoints to targets\n        match_forward = dist_11 < EPS_DIST and dist_22 < EPS_DIST\n        match_reverse = dist_12 < EPS_DIST and dist_21 < EPS_DIST\n        \n        if not (match_forward or match_reverse):\n            return False\n            \n        return True\n\n    test_cases = [\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2},\n            'candidate': (1.5, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V3', 'params': {'alpha': 0.1, 'beta': 0.1, 'k_x': 0.6, 'k_y': 0.5},\n            'candidate': (0.0, 0.0), 'targets': [(-1.0, 0.0), (1.0, 0.0)]\n        },\n        {\n            'potential_type': 'V2', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2, 'd': 0.3},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 1.0e-8},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        }\n    ]\n    \n    results = [is_true_transition_state(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2475357"}]}