{"hands_on_practices": [{"introduction": "任何可靠的Rietveld精修都建立在精确的衍射数据之上。在实际操作中，原始数据常常会受到仪器系统误差的影响，主要是零点漂移和样品位移，这些误差会有系统地改变衍射峰的位置。本练习将引导你完成一个基本的校准流程，从第一性原理出发建立模型，来量化并校正这些误差，从而在进行全面精修之前确保数据的峰位准确性。[@problem_id:2517921]", "problem": "一台布拉格-布伦塔诺（Bragg–Brentano）准聚焦X射线衍射（XRD）仪存在两种导致峰位偏移的主要系统误差：加性零点漂移和样品沿衍射仪轴的位移。考虑使用具有已知预期峰位的晶体标准物质进行校准，然后在进行Rietveld精修之前，将估算出的仪器校正参数应用于一个独立的样品图谱。你的任务是，从第一性原理出发，推导出一个可线性化的关系，该关系能仅使用已知的仪器半径和校准物峰位来同时估算零点漂移和样品位移，然后使用这些估算值，通过求解相应的隐式方程以获得校正后的角度，从而校正一个样品的实测图谱。所有角度必须以“度”为单位进行处理和报告，样品位移必须以“毫米”为单位进行处理和报告。\n\n你可以假设的出发点：\n- 用于衍射的布拉格定律关联了晶面间距、波长和布拉格角。在布拉格-布伦塔诺几何构型中，衍射峰出现在两倍布拉格角的散射角处。\n- 在这种准聚焦几何构型中，一个微小的样品高度误差会通过一个确定性的光程差效应来改变衍射条件，该效应取决于布拉格角和衍射仪半径。\n- 零点漂移是一个加到实测 $2\\theta$ 上的加性角度偏移量，且与角度无关。\n\n不要使用任何未从这些原理推导出的“捷径”公式；相反，应从这些基础出发，构建适当的关系和估算流程。\n\n对于下方的每个测试案例，你将获得：\n- 衍射仪半径 $R$ (单位: 毫米)。\n- 预期校准物峰位 (真值)，单位为 $2\\theta$ 度。\n- 实测校准物峰位，单位为 $2\\theta$ 度。\n- 一组必须使用你估算的仪器参数进行校正的样品峰位 (观测值)，单位为 $2\\theta$ 度。\n\n对于每个测试案例，你的程序必须：\n1) 根据校准物衍射峰和 $R$，使用一个基于布拉格-布伦塔诺几何构型和小位移近似推导出的、具有物理依据的可线性化模型，估算零点漂移 $z$ (单位: 度) 和样品位移 $\\Delta h$ (单位: 毫米)。不要先验地假设任何一个参数已知。\n2) 应用估算的 $z$ 和 $\\Delta h$，通过使用数值稳定的不动点迭代或求根迭代求解相应的隐式校正方程，来校正每个给定的样品 $2\\theta$ 值，从而得到校正后的 $2\\theta$。在校正后的 $2\\theta$ 上使用 $\\varepsilon = 10^{-10}$ 度的收敛容差，每个峰最多迭代 $100$ 次。如果迭代在限制次数内未收敛，则返回最后一次的迭代值。\n3) 将所有输出报告为四舍五入到六位小数的实数。\n\n测试套件 (三个案例):\n- 案例 $1$:\n  - $R = 200.0$ 毫米\n  - 预期校准物 $2\\theta$ (度): $[28.44200, 47.30500, 56.11900]$\n  - 实测校准物 $2\\theta$ (度): $[28.40870, 47.27610, 56.09320]$\n  - 样品观测 $2\\theta$ (度): $[30.00000, 45.00000, 60.00000, 75.00000]$\n- 案例 $2$:\n  - $R = 217.5$ 毫米\n  - 预期校准物 $2\\theta$ (度): $[28.44200, 47.30500, 56.11900]$\n  - 实测校准物 $2\\theta$ (度): $[28.32200, 47.18500, 55.99900]$\n  - 样品观测 $2\\theta$ (度): $[25.00000, 40.00000, 55.00000, 70.00000]$\n- 案例 $3$:\n  - $R = 160.0$ 毫米\n  - 预期校准物 $2\\theta$ (度): $[28.44200, 47.30500, 56.11900]$\n  - 实测校准物 $2\\theta$ (度): $[28.58100, 47.43630, 56.24560]$\n  - 样品观测 $2\\theta$ (度): $[35.00000, 50.00000, 65.00000, 80.00000]$\n\n角度单位：度。长度单位：毫米。不得使用其他单位。将 $z$ 表示为以度为单位的实数，将 $\\Delta h$ 表示为以毫米为单位的实数。每个校正后的样品峰位必须表示为以度为单位的实数。\n\n最终输出格式：\n- 生成单行输出，包含一个由方括号括起来的逗号分隔列表。\n- 对于每个测试案例，列表必须按顺序连接：估算的零点漂移 $z$ (度)、估算的样品位移 $\\Delta h$ (毫米)，随后是该案例给出的、顺序完全一致的校正后样品 $2\\theta$ 值 (度)。\n- 所有数字必须四舍五入到六位小数。\n- 具体来说，对于三个案例，每个案例有四个样品峰，输出必须包含 $3 \\times (2 + 4) = 18$ 个数字，例如 $[z_1, \\Delta h_1, c_{1,1}, c_{1,2}, c_{1,3}, c_{1,4}, z_2, \\Delta h_2, c_{2,1}, c_{2,2}, c_{2,3}, c_{2,4}, z_3, \\Delta h_3, c_{3,1}, c_{3,2}, c_{3,3}, c_{3,4}]$，其中每个 $c_{i,j}$ 是一个以度为单位的校正后样品 $2\\theta$。", "solution": "该问题被验证为具有科学依据、提法明确，并且是应用物理学和数据分析领域中的一个客观任务。它要求推导并应用一个针对布拉格-布伦塔诺X射线衍射法中系统误差的模型。解决方案分两个阶段进行：首先，从校准数据中推导模型并估算仪器参数；其次，应用这些参数校正来自样品的测量数据。\n\n测量的散射角 $2\\theta_m$ 与真实的晶体学散射角 $2\\theta_c$ 之间的关系受多种系统误差的影响。问题指明了两种主要误差：仪器零点漂移 $z$ 和样品位移误差 $\\Delta h$。测量角度是真实角度与这些误差贡献的总和。\n\n零点漂移 $z$ 是一个加到所有测量值上的恒定角度偏移，其本身与角度无关。因此，它对测量角度的贡献就是 $+z$。\n\n当样品表面与测角仪的聚焦圆轴不完全重合时，就会产生样品位移误差。样品沿其表面法线（垂直于样品平面）的位移 $\\Delta h$ 会在测量的峰位中引入一个与角度相关的偏移。对布拉格-布伦塔诺准聚焦几何构型的几何分析表明，对于一个相对于测角仪半径 $R$ 的微小位移 $\\Delta h$，其引起的 $2\\theta$ 角度偏移（记为 $\\Delta(2\\theta)_{disp}$）由以下公式（以弧度为单位）给出：\n$$\n\\Delta(2\\theta)_{disp} \\approx -2\\frac{\\Delta h}{R}\\cos(\\theta_c)\n$$\n其中 $\\theta_c = 2\\theta_c / 2$ 是真实的布拉格角。负号表示正位移（样品过高，朝向X射线源/探测器）会使峰位向更低的 $2\\theta$ 值移动。为按要求使用“度”作为单位，我们转换此表达式：\n$$\n\\Delta(2\\theta)_{disp, deg} = \\left(-2\\frac{\\Delta h}{R}\\cos(\\theta_c)\\right) \\times \\frac{180}{\\pi} = -\\frac{360}{\\pi}\\frac{\\Delta h}{R}\\cos(\\theta_c)\n$$\n结合这两个误差项，测量角度和真实角度之间的关系为：\n$$\n2\\theta_m \\approx 2\\theta_c + z + \\Delta(2\\theta)_{disp, deg} = 2\\theta_c + z - \\frac{360}{\\pi}\\frac{\\Delta h}{R}\\cos(\\theta_c)\n$$\n为了估算未知参数 $z$ 和 $\\Delta h$，我们将此方程重排为适合回归的线性形式。使用提供的校准物数据，对于一组峰 $i=1, \\dots, N$，$2\\theta_{m,i}$ 和 $2\\theta_{c,i}$ 都是已知的：\n$$\n2\\theta_{m,i} - 2\\theta_{c,i} = z - \\left(\\frac{360}{\\pi R}\\Delta h\\right) \\cos(\\theta_{c,i})\n$$\n该方程具有 $Y_i = C + M X_i$ 的形式，它定义了一条直线。我们可以确定其中的变量和系数：\n- 因变量为 $Y_i = 2\\theta_{m,i} - 2\\theta_{c,i}$。\n- 自变量为 $X_i = \\cos(\\theta_{c,i}) = \\cos(2\\theta_{c,i}/2)$。\n- 截距为 $C = z$。\n- 斜率为 $M = -\\frac{360}{\\pi R}\\Delta h$。\n\n给定一组校准峰，可以通过对 $Y$ 与 $X$ 进行线性最小二乘拟合来确定 $z$ 和 $M$ 的值。仪器零点漂移 $z$ 直接由拟合的截距给出。样品位移 $\\Delta h$ 可以从斜率 $M$ 计算得出：\n$$\n\\Delta h = -M \\frac{\\pi R}{360}\n$$\n一旦参数 $z$ 和 $\\Delta h$ (通过 $M$) 被估算出，它们就可用于校正新样品的测量峰位 $2\\theta_{obs}$。对于这样的样品，真实的、校正后的位置 $2\\theta_{corr}$ 是未知的。它通过求解以下隐式方程找到：\n$$\n2\\theta_{obs} = 2\\theta_{corr} + z - \\frac{360}{\\pi}\\frac{\\Delta h}{R}\\cos(\\theta_{corr})\n$$\n代入 $M = -\\frac{360}{\\pi R}\\Delta h$，我们得到：\n$$\n2\\theta_{obs} = 2\\theta_{corr} + z + M \\cos(\\theta_{corr})\n$$\n重排以求解 $2\\theta_{corr}$ 可得：\n$$\n2\\theta_{corr} = 2\\theta_{obs} - z - M \\cos(\\frac{2\\theta_{corr}}{2})\n$$\n这个方程的形式为 $x = g(x)$，其中 $x = 2\\theta_{corr}$ 且 $g(x) = (2\\theta_{obs} - z) - M \\cos(x/2)$。它可以使用不动点迭代法进行数值求解。我们定义一个迭代序列：\n$$\nx_{k+1} = (2\\theta_{obs} - z) - M \\cos\\left(\\frac{\\pi}{180} \\frac{x_k}{2}\\right)\n$$\n一个合适的初始猜测值是 $x_0 = 2\\theta_{obs} - z$，这忽略了微小位移校正。重复迭代，直到连续值之间的变化 $|x_{k+1} - x_k|$ 小于指定的容差 $\\varepsilon = 10^{-10}$。收敛速度很快，因为其导数 $|g'(x)| = |(M \\pi / 360) \\sin(x/2)| = |(\\Delta h/R)\\sin(x/2)|$ 通常远小于1。如果在100次迭代内未达到收敛，则使用最后计算出的值。所有角度都必须以度为单位处理，在代入三角函数时需转换为弧度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for instrument correction parameters and applies them to sample data\n    for a series of test cases in X-ray diffraction analysis.\n    \"\"\"\n    # Test cases as provided in the problem description.\n    test_cases = [\n        {\n            \"R\": 200.0,\n            \"cal_true\": np.array([28.44200, 47.30500, 56.11900]),\n            \"cal_meas\": np.array([28.40870, 47.27610, 56.09320]),\n            \"sam_obs\": np.array([30.00000, 45.00000, 60.00000, 75.00000]),\n        },\n        {\n            \"R\": 217.5,\n            \"cal_true\": np.array([28.44200, 47.30500, 56.11900]),\n            \"cal_meas\": np.array([28.32200, 47.18500, 55.99900]),\n            \"sam_obs\": np.array([25.00000, 40.00000, 55.00000, 70.00000]),\n        },\n        {\n            \"R\": 160.0,\n            \"cal_true\": np.array([28.44200, 47.30500, 56.11900]),\n            \"cal_meas\": np.array([28.58100, 47.43630, 56.24560]),\n            \"sam_obs\": np.array([35.00000, 50.00000, 65.00000, 80.00000]),\n        }\n    ]\n\n    all_results = []\n    \n    # Define constants for the iterative correction\n    TOLERANCE = 1e-10\n    MAX_ITERATIONS = 100\n\n    for case in test_cases:\n        R = case[\"R\"]\n        cal_true_2theta = case[\"cal_true\"]\n        cal_meas_2theta = case[\"cal_meas\"]\n        sam_obs_2theta = case[\"sam_obs\"]\n\n        # Step 1: Estimate z and delta_h using linear regression.\n        # The model is: 2theta_meas = 2theta_true + z - (360/pi * delta_h/R) * cos(theta_true)\n        # We linearize this as: y = C + M*x\n        # where y = 2theta_meas - 2theta_true, x = cos(theta_true), C = z, M = -(360/pi * delta_h/R)\n        \n        y_cal = cal_meas_2theta - cal_true_2theta\n        theta_true_deg = cal_true_2theta / 2.0\n        x_cal = np.cos(np.deg2rad(theta_true_deg))\n\n        # Perform linear least-squares regression to find slope (M) and intercept (C).\n        # np.polyfit(x, y, 1) returns [slope, intercept].\n        slope, intercept = np.polyfit(x_cal, y_cal, 1)\n\n        # Estimate parameters z and delta_h from regression results.\n        z_est = intercept  # in degrees\n        # From M = -(360/pi * delta_h/R), we get delta_h = -M * (pi*R/360)\n        delta_h_est = -slope * (np.pi * R / 360.0)  # in mm\n\n        all_results.append(z_est)\n        all_results.append(delta_h_est)\n\n        # Step 2: Correct sample peak positions by solving the implicit equation.\n        # 2theta_corr = 2theta_obs - z + (360/pi * delta_h/R) * cos(theta_corr)\n        # Using the slope M: 2theta_corr = 2theta_obs - z - M * cos(theta_corr)\n        \n        corrected_peaks = []\n        for obs_peak in sam_obs_2theta:\n            # Fixed-point iteration: x_{k+1} = g(x_k)\n            # where x = 2theta_corr\n\n            # Initial guess for the corrected angle\n            x_corr = obs_peak - z_est\n            \n            constant_term = obs_peak - z_est\n            cosine_coeff = -slope\n            \n            for _ in range(MAX_ITERATIONS):\n                x_prev = x_corr\n                # The argument to cosine must be in radians. x_prev is 2*theta in degrees.\n                theta_corr_rad = np.deg2rad(x_prev / 2.0)\n                x_corr = constant_term + cosine_coeff * np.cos(theta_corr_rad)\n                \n                if np.abs(x_corr - x_prev) < TOLERANCE:\n                    break\n            \n            corrected_peaks.append(x_corr)\n        \n        all_results.extend(corrected_peaks)\n\n    # Format all numbers to six decimal places for the final output string.\n    formatted_results = [f\"{num:.6f}\" for num in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2517921"}, {"introduction": "除了衍射峰的位置，其峰形和宽度也携带了关于材料微观结构的丰富信息。本练习将深入探讨使用经典的Williamson-Hall方法的线型轮廓分析。通过对角度依赖的峰宽进行建模，你将学习如何解耦并量化两个关键的微观结构参数：平均晶粒尺寸 $D$ 和内部微观应变 $\\epsilon$，这些都是高级Rietveld分析中的核心输出参数。[@problem_id:2517814]", "problem": "您获得了一组立方纳米晶材料的粉末X射线衍射峰线形展宽数据，该数据是使用铜K-alpha辐射在实验室衍射仪上测得的。目标是采用类Rietveld方法，通过将峰宽分解为有限微晶尺寸和微觀應變的贡献，来提取体积加权微晶尺寸 $D$ 和均方根微觀應變 $\\epsilon$，并从一个统计上可靠的最小二乘模型中量化参数间的相关性。\n\n您必须使用的基本出发点：\n- Bragg定律：$2 d \\sin \\theta = \\lambda$，其中 $\\theta$ 是Bragg角，$\\lambda$ 是波长。\n- 对于运动学近似下的多晶粉末，扣除仪器展宽后，衍射峰的积分宽度（面积除以高度）可被建模为沿衍射矢量方向的尺寸展宽和应变展宽贡献之和。\n- 对于体积加权微晶尺寸，积分宽度的Scherrer型关系与 $1/\\cos \\theta$ 成正比。\n- 对于均方根微观应变（假定为各向同性），应变展宽积分宽度与 $\\tan \\theta$ 成比例变化。\n\n使用以下数据和常数：\n- 使用铜K-alpha波长 $\\lambda$，单位为纳米：$\\lambda = 0.15406$。\n- 使用适用于体积加权尺寸的形状因子 $K = 0.9$。\n- 下面提供的峰宽是扣除仪器展宽后的积分宽度，记为 $\\beta^\\star$，单位为 $2\\theta$ 弧度。角度以 $2\\theta$ 度数形式给出。在计算三角函数时，您必须使用以弧度为单位的 $\\theta$，其中 $\\theta$ 是将 $(2\\theta)/2$ 从度转换为弧度得到的值。\n- 您必须以纳米为单位报告 $D$，并以无量纲小数（而非百分比）报告 $\\epsilon$。\n\n测试集：\n对于每种情况，都提供了一组 $2\\theta$ 值（单位为度）和相应的扣除仪器展宽后的积分宽度 $\\beta^\\star$（单位为 $2\\theta$ 弧度）。\n\n- 情况A（宽角度覆盖，中等尺寸和应变）：\n  - $2\\theta$: $[40, 50, 70, 90, 110, 120]$\n  - $\\beta^\\star$: $[0.005028, 0.005638, 0.007124, 0.009159, 0.012226, 0.014476]$\n\n- 情况B（有限角度覆盖，预计参数相关性更强）：\n  - $2\\theta$: $[40, 50, 60]$\n  - $\\beta^\\star$: $[0.003919, 0.004416, 0.004979]$\n\n- 情况C（以尺寸展宽为主）：\n  - $2\\theta$: $[40, 50, 70, 90, 110, 120]$\n  - $\\beta^\\star$: $[0.005904, 0.006122, 0.006773, 0.007845, 0.009662, 0.011092]$\n\n- 情况D（以应变展宽为主）：\n  - $2\\theta$: $[40, 50, 70, 90, 110, 120]$\n  - $\\beta^\\star$: $[0.003788, 0.004814, 0.007172, 0.010197, 0.014526, 0.017598]$\n\n要求：\n1. 从基本关系出发，构建一个可线性化的模型。该模型将积分宽度分解为尺寸和应变分量，将其表示为 $\\theta$ 的函数，并适用于对两个参数进行最小二乘估计，这两个参数可映射到 $D$ 和 $\\epsilon$。\n2. 对线性化模型使用普通最小二乘法，根据每种情况的数据估计两个回归参数。根据这些参数，计算 $D$（单位为纳米）和 $\\epsilon$（无量纲）。\n3. 根据最小二乘设计矩阵和残差平方和，估计参数协方差矩阵。通过传递该协方差得到 $D$ 和 $\\epsilon$ 之间的协方差，并报告 $D$ 和 $\\epsilon$ 之间的相关系数 $r$，其定义为 $r = \\mathrm{cov}(D,\\epsilon)/\\sqrt{\\mathrm{var}(D)\\mathrm{var}(\\epsilon)}$。如果分母在数值上为零，则将 $r$ 设为 $0$。\n4. 对于任何三角函数求值，角度都必须转换为弧度。最终的 $D$ 必须以纳米表示，$\\epsilon$ 必须以小数表示。不要使用百分号。\n5. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每种情况的结果都是一个三元列表 $[D,\\epsilon,r]$，每个值都格式化为六位小数。例如：$[[D_A,\\epsilon_A,r_A],[D_B,\\epsilon_B,r_B],[D_C,\\epsilon_C,r_C],[D_D,\\epsilon_D,r_D]]$。\n\n您的任务：\n- 实现一个程序，将上述建模和估计算法应用于提供的测试集，并按规定格式打印单行聚合结果。", "solution": "所提出的问题是X射线线形分析的一个有效且适定的应用。它要求使用标准的Williamson-Hall方法，从粉末衍射数据中确定微晶尺寸和微观应变。所有提供的数据、常数和基本原理在科学上都是可靠且内部一致的。\n\n目标是通过对扣除仪器展宽后的衍射峰积分宽度 $\\beta^\\star$ 进行建模，来确定体积加权微晶尺寸 $D$ 和均方根微观应变 $\\epsilon$。总宽度假定为尺寸展宽贡献 $\\beta_D$ 和应变展宽贡献 $\\beta_\\epsilon$ 的线性加和：\n$$ \\beta^\\star = \\beta_D + \\beta_\\epsilon $$\n\n尺寸贡献由Scherrer方程描述，其中积分宽度与微晶尺寸和Bragg角 $\\theta$ 的余弦值成反比：\n$$ \\beta_D = \\frac{K \\lambda}{D \\cos\\theta} $$\n在此，$K$ 是无量纲Scherrer形状因子（给定为 $K=0.9$），$\\lambda$ 是X射线波长（给定为 $\\lambda=0.15406$ nm），$D$ 是以纳米为单位的体积加权微晶尺寸。宽度 $\\beta_D$ 以 $2\\theta$ 的弧度为单位表示。\n\n应变贡献基于Wilson关于各向同性应变的理论进行建模，其中宽度与Bragg角的正切成正比：\n$$ \\beta_\\epsilon = 4 \\epsilon \\tan\\theta $$\n在此，$\\epsilon$ 是无量纲均方根微观应变，$\\beta_\\epsilon$ 也以 $2\\theta$ 的弧度为单位。\n\n将这两个贡献结合起来，得到总宽度模型：\n$$ \\beta^\\star = \\frac{K \\lambda}{D \\cos\\theta} + 4 \\epsilon \\tan\\theta $$\n\n为了使用线性最小二乘法估计参数 $D$ 和 $\\epsilon$，将此方程两边乘以 $\\cos\\theta$，重排为Williamson-Hall形式：\n$$ \\beta^\\star \\cos\\theta = \\frac{K \\lambda}{D} + 4 \\epsilon \\sin\\theta $$\n\n对于每个衍射峰 $i$，该方程具有线性形式 $y_i = c + m x_i$，其中：\n- 因变量为 $y_i = \\beta^\\star_i \\cos\\theta_i$。\n- 自变量为 $x_i = \\sin\\theta_i$。\n- 截距为 $c = \\frac{K \\lambda}{D}$。\n- 斜率为 $m = 4 \\epsilon$。\n\n分析过程首先将给定的衍射角 $2\\theta$ 从度转换为弧度，并计算 $\\theta_i = (2\\theta_i)/2$。然后，为每个数据点 $(\\beta^\\star_i, \\theta_i)$ 计算对应的 $(x_i, y_i)$ 对。通过执行普通最小二乘（OLS）回归，找到斜率 $\\hat{m}$ 和截距 $\\hat{c}$ 的最优值。在矩阵表示法中，对于一个系统 $\\mathbf{y} = \\mathbf{Xp}$，其中 $\\mathbf{p} = [c, m]^T$ 是参数矢量，$\\mathbf{X}$ 是设计矩阵，OLS估计量由 $\\hat{\\mathbf{p}} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$ 给出。\n\n从估计出的参数 $\\hat{c}$ 和 $\\hat{m}$，可以导出物理量：\n$$ D = \\frac{K \\lambda}{\\hat{c}} \\quad \\text{and} \\quad \\epsilon = \\frac{\\hat{m}}{4} $$\n\n为了量化所确定的参数 $D$ 和 $\\epsilon$ 之间的统计相关性，我们首先计算回归参数的协方差矩阵 $\\mathrm{cov}(\\hat{\\mathbf{p}})$。它由下式给出：\n$$ \\mathrm{cov}(\\hat{\\mathbf{p}}) = \\hat{\\sigma}^2 (\\mathbf{X}^T\\mathbf{X})^{-1} $$\n其中 $\\hat{\\sigma}^2$ 是回归方差的无偏估计，由残差平方和（RSS）计算得出：\n$$ \\hat{\\sigma}^2 = \\frac{1}{N-k} \\mathrm{RSS} = \\frac{1}{N-2} \\sum_{i=1}^{N} (y_i - (\\hat{c} + \\hat{m}x_i))^2 $$\n在此，$N$ 是数据点的数量，$k=2$ 是线性模型中参数的数量。\n\n$D$ 和 $\\epsilon$ 之间的协方差是通过变换函数从 $\\hat{\\mathbf{p}} = [\\hat{c}, \\hat{m}]^T$ 传递协方差得到的。从 $(c, m)$ 到 $(D, \\epsilon)$ 变换的Jacobian矩阵 $\\mathbf{J}$ 为：\n$$ \\mathbf{J} = \\begin{pmatrix} \\frac{\\partial D}{\\partial c} & \\frac{\\partial D}{\\partial m} \\\\ \\frac{\\partial \\epsilon}{\\partial c} & \\frac{\\partial \\epsilon}{\\partial m} \\end{pmatrix} = \\begin{pmatrix} -\\frac{K\\lambda}{c^2} & 0 \\\\ 0 & \\frac{1}{4} \\end{pmatrix} $$\n那么 $(D, \\epsilon)$ 的协方差矩阵可近似为 $\\mathrm{cov}(D, \\epsilon) \\approx \\mathbf{J} \\, \\mathrm{cov}(\\hat{\\mathbf{p}}) \\, \\mathbf{J}^T$。\n\n最后，计算相关系数 $r(D, \\epsilon)$：\n$$ r(D, \\epsilon) = \\frac{\\mathrm{cov}(D, \\epsilon)}{\\sqrt{\\mathrm{var}(D)\\mathrm{var}(\\epsilon)}} $$\n此计算表明，导出的物理参数之间的相关性是回归参数之间相关性的负值，即 $r(D, \\epsilon) = -r(\\hat{c}, \\hat{m})$。对于在 $x_i$ 正值范围内进行的此类线性拟合，拟合斜率和截距之间的强负相关是典型现象，这导致了 $D$ 和 $\\epsilon$ 之间的强正相关。\n\n以下程序为提供的测试用例实现了这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for crystallite size (D), microstrain (epsilon), and their\n    correlation (r) from XRD peak broadening data using Williamson-Hall analysis.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    K = 0.9  # Scherrer shape factor\n    LAMBDA = 0.15406  # Wavelength in nanometers\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Broad angular coverage\n        (np.array([40.0, 50.0, 70.0, 90.0, 110.0, 120.0]),\n         np.array([0.005028, 0.005638, 0.007124, 0.009159, 0.012226, 0.014476])),\n        # Case B: Limited angular coverage\n        (np.array([40.0, 50.0, 60.0]),\n         np.array([0.003919, 0.004416, 0.004979])),\n        # Case C: Dominantly size broadening\n        (np.array([40.0, 50.0, 70.0, 90.0, 110.0, 120.0]),\n         np.array([0.005904, 0.006122, 0.006773, 0.007845, 0.009662, 0.011092])),\n        # Case D: Dominantly strain broadening\n        (np.array([40.0, 50.0, 70.0, 90.0, 110.0, 120.0]),\n         np.array([0.003788, 0.004814, 0.007172, 0.010197, 0.014526, 0.017598])),\n    ]\n\n    results = []\n    for case in test_cases:\n        two_theta_deg, beta_star = case\n        N = len(two_theta_deg)\n\n        # Convert 2*theta in degrees to theta in radians\n        theta_rad = np.deg2rad(two_theta_deg / 2)\n\n        # Construct variables for the Williamson-Hall plot: y = c + m*x\n        # x = sin(theta)\n        # y = beta_star * cos(theta)\n        x_wh = np.sin(theta_rad)\n        y_wh = beta_star * np.cos(theta_rad)\n\n        # Perform Ordinary Least Squares (OLS) regression\n        # Design matrix X for model y = p[0] + p[1]*x\n        X = np.vstack([np.ones(N), x_wh]).T\n        \n        # Calculate parameters p_hat = [c_hat, m_hat] using (X.T * X)^-1 * X.T * y\n        # Use np.linalg.solve for better numerical stability than direct inversion\n        try:\n            XTX = X.T @ X\n            XTy = X.T @ y_wh\n            p_hat = np.linalg.solve(XTX, XTy)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case, though unlikely with this data\n            results.append([0.0, 0.0, 0.0])\n            continue\n            \n        c_hat, m_hat = p_hat\n\n        # Calculate crystallite size (D) and microstrain (epsilon)\n        # c_hat = K * lambda / D  => D = K * lambda / c_hat\n        # m_hat = 4 * epsilon    => epsilon = m_hat / 4\n        D = 0.0\n        if c_hat > 0:\n            D = (K * LAMBDA) / c_hat\n        \n        epsilon = m_hat / 4.0\n\n        # Calculate the correlation coefficient between D and epsilon\n        r_De = 0.0\n        # Number of parameters in the model k=2\n        if N > 2:\n            # Calculate residual sum of squares (RSS)\n            residuals = y_wh - (c_hat + m_hat * x_wh)\n            RSS = np.sum(residuals**2)\n            \n            # Estimate of the regression variance sigma^2\n            sigma2_hat = RSS / (N - 2)\n\n            # Covariance matrix of the parameters [c, m]\n            try:\n                XTX_inv = np.linalg.inv(XTX)\n                cov_p = sigma2_hat * XTX_inv\n                \n                var_c = cov_p[0, 0]\n                var_m = cov_p[1, 1]\n                cov_cm = cov_p[0, 1]\n\n                # Denominator for correlation coefficient of (c, m)\n                denom_r_cm = np.sqrt(var_c * var_m)\n                \n                if denom_r_cm > 1e-15: # Avoid division by zero\n                    r_cm = cov_cm / denom_r_cm\n                    # Correlation of (D, epsilon) is -1 * correlation of (c, m)\n                    r_De = -r_cm\n                else:\n                    # Occurs if fit is perfect (RSS=0), so no statistical variance\n                    r_De = 0.0\n\n            except np.linalg.LinAlgError:\n                r_De = 0.0\n        else:\n            # Cannot estimate variance with N = k, correlation is undefined\n            r_De = 0.0\n\n        results.append([D, epsilon, r_De])\n\n    # Format output string\n    output_str = \"[\"\n    output_str += \",\".join(\n        f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results\n    )\n    output_str += \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "2517814"}, {"introduction": "Rietveld精修的一个主要应用是物相定量分析（QPA），但要获得准确的结果，仅仅拟合数据是不够的。诸如微吸收和择优取向（织构）等物理效应，如果模型不当，会引入显著的系统偏差。本练习将挑战你批判性地重新评估一个假设的QPA结果，从基本原理出发应用校正，以理解这些复杂现象如何影响最终计算出的物相分数。[@problem_id:2517872]", "problem": "给定一套来自 Rietveld 精修的物相定量结果，以及重新评估定量物相分析中两个常见系统性偏差来源（微吸收和择优取向）所需的物理参数。目标是在使用替代模型选择时，重新估算物相分数。此问题必须通过有关衍射强度和衰减的第一性原理进行推理来解决，不得依赖任何直接将报告的物相分数映射到校正后分数的现成公式。\n\n您必须假定以下基本基础：\n- 用于X射线衰减的 Beer–Lambert 定律，即强度在穿过路径长度为 $\\ell$ 的介质时，会按照 $I = I_0 \\exp(-\\mu \\ell)$ 的规律衰减，其中 $\\mu$ 是线性衰减系数。\n- 在 Rietveld 精修中，某一物相的精修标度因子，在主导阶上，与辐照体积中该物相的量所产生的衍射强度成正比。\n- 择优取向改变了微晶取向的分布，从而相对于随机粉末，通过一个乘法因子对某些布拉格峰进行加权。一个广泛用于量化这种与布拉格角相关的取向加权的标准唯象模型是 March–Dollase 函数。\n\n您将采用以下具有物理动机的简化强度模型：\n- 考虑一个由半径为 $R_k$（单位：微米）的近似球形微晶组成的物相 $k$。设其質量衰减系数为 $\\mu_{m,k}$（单位：cm$^2$ g$^{-1}$），密度为 $\\rho_k$（单位：g cm$^{-3}$）。则线性衰减系数为 $\\mu_k = \\mu_{m,k}\\,\\rho_k$（单位：cm$^{-1}$）。\n- 球体的微吸收透射因子 $T_k$ 定义为对穿过半径为 $R_k$ 的球体的所有射线路径上的 Beer–Lambert 衰减进行平均：\n$$\nT_k(x_k) = \\frac{1 - e^{-x_k}}{x_k}, \\quad \\text{with } x_k = 2 \\mu_k R_k^{(\\mathrm{cm})}, \\quad R_k^{(\\mathrm{cm})} = R_k^{(\\mu \\mathrm{m})} \\times 10^{-4}.\n$$\n- 物相 $k$ 的择优取向强度乘数可通过一个单一的有效 March–Dollase 因子来近似：\n$$\nP_k(r_k,\\theta_k) = \\left(r_k^2 \\cos^2 \\theta_k + r_k^{-1} \\sin^2 \\theta_k\\right)^{-3/2},\n$$\n其中 $r_k$ 是 March–Dollase 参数，$\\theta_k$ 是一个有效角，两者对于每个物相都是给定值；输入时 $\\theta_k$ 必须以度为单位，但在计算中需使用弧度。\n\n对于一个已发表的分析，其在忽略微吸收和择优取向的模型选择下报告了物相分数 $\\{w_{k}^{(\\mathrm{pub})}\\}_k$，您需要在使用替代模型选择的情况下重新估算这些分数。应当将 Rietveld 标度因子视为在忽略微吸收和择优取向时与已发表分数成正比。然后，通过第一性原理推导，阐明微吸收透射因子 $\\{T_k\\}$ 和择优取向乘数 $\\{P_k\\}$ 如何改变标度因子与实际物相分数之间的转换关系。实施此逻辑以计算指定模型选择下的校正分数。\n\n在输入参数中，角度必须解释为度，并在三角函数计算中转换为弧度。必须按规定使用物理单位：$\\mu_m$ 的单位是 cm$^2$ g$^{-1}$，$\\rho$ 的单位是 g cm$^{-3}$，$R$ 的单位是 $\\mu$m，$R$ 在内部计算时需转换为 cm。最终的物相分数是无量纲的，必须表示为小数。\n\n测试套件和要求的输出：\n- 对于每个测试用例，给定以下信息：\n  - 已发表的物相分数 $w^{(\\mathrm{pub})}$，以列表形式给出，其总和为1。\n  - 针对每个物相的数组，长度相同，包括 $\\mu_m$、$\\rho$、$R$（单位 $\\mu$m）、$r$ 和 $\\theta$（单位 度）。\n  - 一个模型选择标志，取值为集合 $\\{\\text{\"none\"}, \\text{\"microabsorption\"}, \\text{\"texture\"}, \\text{\"both\"}\\}$ 之一，指示在重新计算分数时应用哪些校正。\n- 您的程序必须为每个测试用例计算校正后的分数，并以浮点数列表的形式返回每个结果，每个浮点数四舍五入到6位小数，且列表元素之和在舍入误差范围内应为1。分数必须是小数（而不是百分比）。\n\n测试套件包含以下7个案例，所有案例都设定在固定波长的X射线辐射下，给定的 $\\mu_m$ 值在此条件下适用：\n- 案例1（健全性检查，三相样品S1，无校正）：\n  - $w^{(\\mathrm{pub})} = [0.5, 0.3, 0.2]$\n  - $\\mu_m = [260, 53, 48]$ cm$^2$ g$^{-1}$\n  - $\\rho = [5.24, 3.98, 2.65]$ g cm$^{-3}$\n  - $R = [10, 5, 3]$ $\\mu$m\n  - $r = [0.9, 1.1, 1.0]$\n  - $\\theta = [30, 45, 0]$ 度\n  - 模型选择：\"none\"\n- 案例2（相同样品S1，仅微吸收校正）：\n  - 参数同案例1\n  - 模型选择：\"microabsorption\"\n- 案例3（相同样品S1，仅择优取向校正）：\n  - 参数同案例1\n  - 模型选择：\"texture\"\n- 案例4（相同样品S1，两种校正均应用）：\n  - 参数同案例1\n  - 模型选择：\"both\"\n- 案例5（两相样品S2，微吸收可忽略，仅微吸收校正）：\n  - $w^{(\\mathrm{pub})} = [0.6, 0.4]$\n  - $\\mu_m = [50, 60]$ cm$^2$ g$^{-1}$\n  - $\\rho = [3.0, 3.0]$ g cm$^{-3}$\n  - $R = [1.0, 1.0]$ $\\mu$m\n  - $r = [2.0, 1.0]$\n  - $\\theta = [10, 0]$ 度\n  - 模型选择：\"microabsorption\"\n- 案例6（相同样品S2，仅强织构校正）：\n  - 参数同案例5\n  - 模型选择：\"texture\"\n- 案例7（两相样品S3，强微吸收对比，仅微吸收校正）：\n  - $w^{(\\mathrm{pub})} = [0.7, 0.3]$\n  - $\\mu_m = [300, 30]$ cm$^2$ g$^{-1}$\n  - $\\rho = [7.2, 2.5]$ g cm$^{-3}$\n  - $R = [15.0, 2.0]$ $\\mu$m\n  - $r = [1.0, 1.0]$\n  - $\\theta = [0, 0]$ 度\n  - 模型选择：\"microabsorption\"\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素是对应上述测试用例顺序的校正分数列表，每个分数都四舍五入到6位小数。例如，对于两个假设的案例，一个语法正确的输出应为 $[[0.1,0.9],[0.2,0.8]]$。输出行中不允许包含任何额外的文本或字符。", "solution": "所述问题是有效的。它在科学上基于X射线衍射和定量物相分析的原理，问题提法明确，并包含了获得唯一解所需的所有必要信息。所用的微吸收和择优取向简化模型是该领域的标准近似方法。我们将从第一性原理出发推导解决方案。\n\n目标是通过应用对最初被忽略的微吸收和择优取向进行校正，来重新估算定量物相分析的结果 $\\{w_k^{(\\mathrm{pub})}\\}_k$。这种重新估算的基础在于物相的真实重量分数 $w_k$ 与其对衍射图谱贡献的强度 $I_k$ 之间的关系。\n\n在粉末衍射实验中，从物相 $k$ 的一个衍射峰测得的强度 $I_k^{(\\mathrm{meas})}$ 与其真实重量分数 $w_k$ 成正比。然而，这种关系受到多种物理效应的调制，包括微吸收和择优取向（织构）。我们可以将其表示为：\n$$I_k^{(\\mathrm{meas})} \\propto w_k \\cdot T_k \\cdot P_k$$\n这里，$T_k$ 是物相 $k$ 的微吸收透射因子，$P_k$ 是择优取向（织构）因子。比例常数包含了仪器因素和物相的固有散射特性，这些因素在分析中对所有物相都是恒定的。\n\n问题指出，已发表的重量分数 $w_k^{(\\mathrm{pub})}$ 是从一个忽略了微吸收和择优取向的分析中获得的。这等同于假设所有物相的 $T_k = 1$ 和 $P_k = 1$。在这种假设下，测得的强度被认为与重量分数成正比：\n$$I_k^{(\\mathrm{meas})} \\propto w_k^{(\\mathrm{pub})}$$\n\n通过令这两个比例关系相等，我们建立了真实重量分数与已发表的、未校正的重量分数之间的核心关系：\n$$w_k^{(\\mathrm{pub})} \\propto w_k \\cdot T_k \\cdot P_k$$\n由此，我们可以解出真实重量分数 $w_k$，我们将其表示为 $w_k^{(\\mathrm{corr})}$ 以表示校正后的值。我们发现 $w_k^{(\\mathrm{corr})}$ 与已发表分数除以校正因子的结果成正比：\n$$w_k^{(\\mathrm{corr})} \\propto \\frac{w_k^{(\\mathrm{pub})}}{T_k \\cdot P_k}$$\n我们定义一个未归一化的校正重量分数 $w_k'$ 如下：\n$$w_k' = \\frac{w_k^{(\\mathrm{pub})}}{T_k \\cdot P_k}$$\n由于样品中所有重量分数的总和必须等于1，我们必须对这些值进行重新归一化：\n$$w_k^{(\\mathrm{corr})} = \\frac{w_k'}{\\sum_j w_j'} = \\frac{w_k^{(\\mathrm{pub})} / (T_k \\cdot P_k)}{\\sum_j \\left( w_j^{(\\mathrm{pub})} / (T_j \\cdot P_j) \\right)}$$\n这就是我们将要实现的最终方程。$T_k$ 和 $P_k$ 的值由 `modeling_choice` 标志决定。如果不应用某个校正，相应的因子保持为1。\n\n校正因子的具体模型已提供。\n\n对于微吸收，球形微晶的透射因子 $T_k$ 为：\n$$T_k(x_k) = \\frac{1 - e^{-x_k}}{x_k}$$\n其中无量纲参数 $x_k$ 由 $x_k = 2 \\mu_k R_k^{(\\mathrm{cm})}$ 给出。线性衰减系数 $\\mu_k$（单位 cm$^{-1}$）由给定的質量衰减系数 $\\mu_{m,k}$（单位 cm$^2$ g$^{-1}$）和密度 $\\rho_k$（单位 g cm$^{-3}$）计算得出，即 $\\mu_k = \\mu_{m,k} \\rho_k$。给定的微晶半径 $R_k$ 单位为微米（$\\mu$m），必须使用 $R_k^{(\\mathrm{cm})} = R_k^{(\\mu \\mathrm{m})} \\times 10^{-4}$ 将其转换为厘米（cm）。\n\n对于择优取向，强度乘数 $P_k$ 通过 March–Dollase 函数建模：\n$$P_k(r_k, \\theta_k) = \\left(r_k^2 \\cos^2 \\theta_k + r_k^{-1} \\sin^2 \\theta_k\\right)^{-3/2}$$\n此处，$r_k$ 是 March–Dollase 参数，$\\theta_k$ 是有效角。角度 $\\theta_k$ 以度为单位提供，在用于三角函数时必须通过 $\\theta_k^{(\\mathrm{rad})} = \\theta_k^{(\\mathrm{deg})} \\frac{\\pi}{180}$ 转换为弧度。$r_k=1$ 的值表示没有择优取向，此时对于任何角度 $\\theta_k$，结果均为 $P_k=1$。\n\n每个测试用例的算法如下：\n1.  对于混合物中的每个物相 $k$，将校正因子初始化为 $T_k \\leftarrow 1$ 和 $P_k \\leftarrow 1$。\n2.  根据 `modeling_choice`，计算必要的校正因子。\n    - 如果 `modeling_choice` 是 `\"microabsorption\"` 或 `\"both\"`，则使用提供的公式计算每个 $T_k$。需要特别注意 $x_k \\to 0$ 的情况，此时 $T_k$ 的极限为 $1$。\n    - 如果 `modeling_choice` 是 `\"texture\"` 或 `\"both\"`，则使用 March–Dollase 公式计算每个 $P_k$。\n3.  使用 $w_k' = w_k^{(\\mathrm{pub})} / (T_k \\cdot P_k)$ 计算每个物相的未归一化校正重量分数 $w_k'$。\n4.  将未归一化的分数求和：$W' = \\sum_j w_j'$。\n5.  计算最终的、归一化后的校正重量分数：$w_k^{(\\mathrm{corr})} = w_k' / W'$。\n6.  最终结果四舍五入到指定的6位小数精度。\n此程序严格应用了从第一性原理推导出的物理校正模型，以重新评估初始的定量分析。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Rietveld quantitative phase analysis correction problem\n    for a given suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (sanity, three-phase sample S1, no corrections)\n        {\n            \"w_pub\": [0.5, 0.3, 0.2],\n            \"mu_m\": [260, 53, 48],\n            \"rho\": [5.24, 3.98, 2.65],\n            \"R\": [10, 5, 3],\n            \"r\": [0.9, 1.1, 1.0],\n            \"theta\": [30, 45, 0],\n            \"choice\": \"none\",\n        },\n        # Case 2 (same S1, microabsorption only)\n        {\n            \"w_pub\": [0.5, 0.3, 0.2],\n            \"mu_m\": [260, 53, 48],\n            \"rho\": [5.24, 3.98, 2.65],\n            \"R\": [10, 5, 3],\n            \"r\": [0.9, 1.1, 1.0],\n            \"theta\": [30, 45, 0],\n            \"choice\": \"microabsorption\",\n        },\n        # Case 3 (same S1, preferred orientation only)\n        {\n            \"w_pub\": [0.5, 0.3, 0.2],\n            \"mu_m\": [260, 53, 48],\n            \"rho\": [5.24, 3.98, 2.65],\n            \"R\": [10, 5, 3],\n            \"r\": [0.9, 1.1, 1.0],\n            \"theta\": [30, 45, 0],\n            \"choice\": \"texture\",\n        },\n        # Case 4 (same S1, both corrections)\n        {\n            \"w_pub\": [0.5, 0.3, 0.2],\n            \"mu_m\": [260, 53, 48],\n            \"rho\": [5.24, 3.98, 2.65],\n            \"R\": [10, 5, 3],\n            \"r\": [0.9, 1.1, 1.0],\n            \"theta\": [30, 45, 0],\n            \"choice\": \"both\",\n        },\n        # Case 5 (two-phase sample S2, negligible microabsorption, microabsorption only)\n        {\n            \"w_pub\": [0.6, 0.4],\n            \"mu_m\": [50, 60],\n            \"rho\": [3.0, 3.0],\n            \"R\": [1.0, 1.0],\n            \"r\": [2.0, 1.0],\n            \"theta\": [10, 0],\n            \"choice\": \"microabsorption\",\n        },\n        # Case 6 (same S2, strong texture only)\n        {\n            \"w_pub\": [0.6, 0.4],\n            \"mu_m\": [50, 60],\n            \"rho\": [3.0, 3.0],\n            \"R\": [1.0, 1.0],\n            \"r\": [2.0, 1.0],\n            \"theta\": [10, 0],\n            \"choice\": \"texture\",\n        },\n        # Case 7 (two-phase sample S3, strong microabsorption contrast, microabsorption only)\n        {\n            \"w_pub\": [0.7, 0.3],\n            \"mu_m\": [300, 30],\n            \"rho\": [7.2, 2.5],\n            \"R\": [15.0, 2.0],\n            \"r\": [1.0, 1.0],\n            \"theta\": [0, 0],\n            \"choice\": \"microabsorption\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        w_pub = np.array(case[\"w_pub\"])\n        mu_m = np.array(case[\"mu_m\"])\n        rho = np.array(case[\"rho\"])\n        R_micron = np.array(case[\"R\"])\n        r = np.array(case[\"r\"])\n        theta_deg = np.array(case[\"theta\"])\n        choice = case[\"choice\"]\n        \n        num_phases = len(w_pub)\n        T_factors = np.ones(num_phases)\n        P_factors = np.ones(num_phases)\n\n        if choice in [\"microabsorption\", \"both\"]:\n            mu = mu_m * rho                  # Linear attenuation coefficient in cm^-1\n            R_cm = R_micron * 1e-4           # Radius in cm\n            x = 2 * mu * R_cm\n            \n            # Avoid division by zero for x_k=0, where lim T_k = 1.\n            # Using np.where to handle vectorization properly.\n            T_factors = np.where(x == 0, 1.0, (1.0 - np.exp(-x)) / x)\n\n        if choice in [\"texture\", \"both\"]:\n            theta_rad = np.deg2rad(theta_deg)\n            cos2_theta = np.cos(theta_rad)**2\n            sin2_theta = np.sin(theta_rad)**2\n            \n            # March-Dollase term\n            term = r**2 * cos2_theta + r**(-1) * sin2_theta\n            P_factors = term**(-1.5)\n\n        # Calculate un-normalized corrected weight fractions\n        w_prime = w_pub / (T_factors * P_factors)\n        \n        # Normalize to get final corrected weight fractions\n        w_corr = w_prime / np.sum(w_prime)\n        \n        # Round and format\n        rounded_w_corr = np.round(w_corr, 6).tolist()\n        results.append(rounded_w_corr)\n\n    # Print in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2517872"}]}