{"hands_on_practices": [{"introduction": "要掌握对复杂、无序材料的分析，我们首先需要理解最简单系统中的原子对分布函数（PDF）。这个练习将从第一性原理出发，为一个孤立的、具有固定键长的理想双原子分子推导其对分布函数 $G(r)$。通过这个基础练习 [@problem_id:161163]，你将巩固对傅里叶变换如何将一个明确的真实空间距离（键长）映射为 $G(r)$ 中一个尖锐特征的理解，为解读更复杂的实验数据打下坚实的理论基础。", "problem": "原子对分布函数 (PDF)，记为 $G(r)$，提供了关于材料中原子对之间距离分布的关键信息。它通过与实验上可测量的总散射结构因子 $S(Q)$ 的关系，经由傅里叶正弦变换定义如下：\n$$\nG(r) = \\frac{2}{\\pi} \\int_0^\\infty Q[S(Q)-1] \\sin(Qr) \\,dQ\n$$\n其中 $Q$ 是散射矢量的模长。\n\n对于一个由 $N$ 个原子组成的、其位置为 $\\{\\vec{r}_i\\}$ 的体系，结构因子 $S(Q)$ 定义为干涉函数的取向平均：\n$$\nS(Q) = \\frac{1}{N} \\sum_{j=1}^N \\sum_{k=1}^N \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_j-\\vec{r}_k)} \\rangle\n$$\n对于一对相距固定距离 $r_{jk} = |\\vec{r}_j - \\vec{r}_k|$ 的原子 $j$ 和 $k$，其取向平均（由 $\\langle \\dots \\rangle$ 表示）由 Debye 公式给出：\n$$\n\\langle e^{-i\\vec{Q}\\cdot\\vec{r}_{jk}} \\rangle = \\frac{\\sin(Qr_{jk})}{Qr_{jk}}\n$$\n\n考虑一个单一、孤立的同核双原子分子。由于该分子孤立于真空中，其平均原子数密度 $\\rho_0$ 可视为零。假设原子是点状的，且分子是刚性的，具有固定的原子间距 $r_0$（即理想的、无展宽的情况），请推导出其对分布函数 $G(r)$ 的表达式。您可能需要用到 Dirac δ 函数的积分表示： $\\int_0^\\infty \\cos(kx) \\,dk = \\pi \\delta(x)$。", "solution": "本题要求推导一个键长固定为 $r_0$ 的理想同核双原子分子的对分布函数 $G(r)$。我们将首先推导此体系的结构因子 $S(Q)$，然后进行傅里叶正弦变换。\n\n**第1步：推导结构因子 $S(Q)$**\n\n对于一个双原子分子，原子数为 $N=2$。设这两个原子分别标记为 1 和 2。结构因子的通用公式为：\n$$\nS(Q) = \\frac{1}{N} \\sum_{j=1}^2 \\sum_{k=1}^2 \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_j-\\vec{r}_k)} \\rangle\n$$\n我们可以将这个双重求和展开为四项：\n$$\nS(Q) = \\frac{1}{2} \\left[ \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_1-\\vec{r}_1)} \\rangle + \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_2-\\vec{r}_2)} \\rangle + \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_1-\\vec{r}_2)} \\rangle + \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_2-\\vec{r}_1)} \\rangle \\right]\n$$\n前两项（$j=k$ 时）是自散射项。矢量差为零，因此 $\\vec{r}_j - \\vec{r}_j = \\vec{0}$，且 $e^{-i\\vec{Q}\\cdot\\vec{0}} = e^0 = 1$。\n后两项（$j \\neq k$ 时）是相干散射项。原子间的距离固定为 $|\\vec{r}_1 - \\vec{r}_2| = |\\vec{r}_2 - \\vec{r}_1| = r_0$。我们对这两项应用 Debye 公式。\n$$\nS(Q) = \\frac{1}{2} \\left[ 1 + 1 + \\frac{\\sin(Q|\\vec{r}_1-\\vec{r}_2|)}{Q|\\vec{r}_1-\\vec{r}_2|} + \\frac{\\sin(Q|\\vec{r}_2-\\vec{r}_1|)}{Q|\\vec{r}_2-\\vec{r}_1|} \\right]\n$$\n$$\nS(Q) = \\frac{1}{2} \\left[ 2 + \\frac{\\sin(Qr_0)}{Qr_0} + \\frac{\\sin(Qr_0)}{Qr_0} \\right] = \\frac{1}{2} \\left[ 2 + 2\\frac{\\sin(Qr_0)}{Qr_0} \\right]\n$$\n这可简化为该双原子分子的结构因子：\n$$\nS(Q) = 1 + \\frac{\\sin(Qr_0)}{Qr_0}\n$$\n\n**第2步：计算约化散射函数 $Q[S(Q)-1]$**\n\n根据推导出的 $S(Q)$，我们可以求出 $G(r)$ 积分所需的项：\n$$\nS(Q) - 1 = \\frac{\\sin(Qr_0)}{Qr_0}\n$$\n$$\nQ[S(Q)-1] = Q \\left( \\frac{\\sin(Qr_0)}{Qr_0} \\right) = \\frac{\\sin(Qr_0)}{r_0}\n$$\n\n**第3步：计算傅里叶正弦变换以求得 $G(r)$**\n\n现在我们将此表达式代入 $G(r)$ 的定义中：\n$$\nG(r) = \\frac{2}{\\pi} \\int_0^\\infty Q[S(Q)-1] \\sin(Qr) \\,dQ = \\frac{2}{\\pi} \\int_0^\\infty \\frac{\\sin(Qr_0)}{r_0} \\sin(Qr) \\,dQ\n$$\n我们可以将常数 $1/r_0$ 从积分中提出：\n$$\nG(r) = \\frac{2}{\\pi r_0} \\int_0^\\infty \\sin(Qr_0) \\sin(Qr) \\,dQ\n$$\n为了计算该积分，我们使用三角函数的积化和差恒等式：$\\sin A \\sin B = \\frac{1}{2}[\\cos(A-B) - \\cos(A+B)]$。令 $A = Qr_0$ 且 $B = Qr$。\n$$\nG(r) = \\frac{2}{\\pi r_0} \\int_0^\\infty \\frac{1}{2}[\\cos(Q(r_0-r)) - \\cos(Q(r_0+r))] \\,dQ\n$$\n$$\nG(r) = \\frac{1}{\\pi r_0} \\left[ \\int_0^\\infty \\cos(Q(r-r_0)) \\,dQ - \\int_0^\\infty \\cos(Q(r+r_0)) \\,dQ \\right]\n$$\n注意到 $\\cos$ 是偶函数，因此 $\\cos(x) = \\cos(-x)$，这使得我们可以写出 $\\cos(Q(r_0-r)) = \\cos(Q(r-r_0))$。\n\n**第4步：使用 Dirac δ 函数的表示**\n\n题目给出了恒等式 $\\int_0^\\infty \\cos(kx) \\,dk = \\pi \\delta(x)$。将此应用于我们的两个积分：\n\\begin{enumerate}\n    \\item  $\\int_0^\\infty \\cos(Q(r-r_0)) \\,dQ = \\pi \\delta(r-r_0)$\n    \\item  $\\int_0^\\infty \\cos(Q(r+r_0)) \\,dQ = \\pi \\delta(r+r_0)$\n\\end{enumerate}\n将它们代回 $G(r)$ 的表达式中：\n$$\nG(r) = \\frac{1}{\\pi r_0} [\\pi \\delta(r-r_0) - \\pi \\delta(r+r_0)] = \\frac{1}{r_0} [\\delta(r-r_0) - \\delta(r+r_0)]\n$$\n由于 $r$ 代表物理距离，它必须为非负值（$r \\ge 0$）。键长 $r_0$ 是严格为正的（$r_0 > 0$）。因此，$r+r_0$ 这一项总是正数，绝不为零。这意味着对于所有物理上可能的 $r$ 值，$\\delta(r+r_0) = 0$。\n表达式简化为：\n$$\nG(r) = \\frac{\\delta(r-r_0)}{r_0}\n$$\n这就是一个同核双原子分子的理想、无展宽的对分布函数。它正确地表示了在 $r=r_0$ 处存在一个单一的原子间距。", "answer": "$$\n\\boxed{\\frac{\\delta(r-r_0)}{r_0}}\n$$", "id": "161163"}, {"introduction": "在真实的实验中，我们获取的总散射数据总是在一个有限的动量传递范围 $Q \\in [0, Q_{\\max}]$ 内。这个练习将我们从理想的无限范围傅里叶变换带入数据处理的现实挑战。通过一个计算实践 [@problem_id:2533221]，你将亲手探究在有限 $Q_{\\max}$ 处截断积分如何导致 $G(r)$ 中出现被称为“截断涟漪”的非物理振荡，并学习如何运用不同的“窗口函数”来抑制这些伪影，直观地理解分辨率与伪影抑制之间的权衡。", "problem": "给定一个对应于单原子间距 $R$ 的合成约化总散射函数 $F(Q)$。约化对分布函数 $G(r)$ 由以下正弦变换定义\n$$\nG(r) = \\frac{2}{\\pi} \\int_{0}^{Q_{\\max}} w(Q)\\,F(Q)\\,\\sin(Q r)\\,dQ,\n$$\n其中，$w(Q)$ 是一个窗函数（或锥削函数），用于抑制因有限截断 $Q_{\\max}$ 引起的截断涟漪。在本问题中，对于每个测试用例，您将在相同的 $Q_{\\max}$ 下使用三种不同的窗函数计算和比较 $G(r)$：\n- 矩形窗：对于 $0 \\le Q \\le Q_{\\max}$，$w_{\\mathrm{rect}}(Q) = 1$。\n- Lorch 窗：对于 $0 \\le Q \\le Q_{\\max}$，$w_{\\mathrm{Lorch}}(Q) = \\dfrac{\\sin\\!\\left(\\pi Q/Q_{\\max}\\right)}{\\pi Q/Q_{\\max}}$。\n- Hann 窗（升余弦）：对于 $0 \\le Q \\le Q_{\\max}$，$w_{\\mathrm{Hann}}(Q) = \\dfrac{1}{2}\\left[1+\\cos\\!\\left(\\pi Q/Q_{\\max}\\right)\\right]$。\n\n基本和建模假设：\n- 对于稀疏的、由相同散射体组成的系统中的单个原子间距 $R$，静态结构因子满足 $S(Q)-1 \\propto \\dfrac{\\sin(QR)}{Q R}$。约化总散射函数为 $F(Q) = Q\\,[S(Q)-1]$，在不考虑整体比例因子的情况下，为 $F(Q) = \\dfrac{\\sin(QR)}{R}$。请使用此模型作为 $F(Q)$。\n- 在 $Q$ 的均匀网格上，使用梯形法则进行数值积分。\n\n数值规格：\n- 在 $[0, Q_{\\max}]$ 上使用均匀 $Q$ 网格，步长为 $\\Delta Q = 0.01\\,\\text{\\AA}^{-1}$（包含两个端点）。\n- 在 $[0, 6.0]$ 上使用均匀 $r$ 网格计算 $G(r)$，步长为 $\\Delta r = 0.002\\,\\text{\\AA}$（包含两个端点）。\n- 在每个测试用例中，对三种窗函数使用相同的 $Q_{\\max}$。\n- 物理单位：$Q$ 的单位为 $\\text{\\AA}^{-1}$，$r$ 的单位为 $\\text{\\AA}$。报告所有 $r$ 值输出和所有宽度时，单位均为 $\\text{\\AA}$。振幅和比率为无单位量。\n\n对于每个测试用例和每种窗函数，从数值计算的 $G(r)$ 中计算以下四个定量指标：\n1. $R$ 附近的峰位：在区间 $[R-1.0\\,\\text{\\AA},\\,R+1.0\\,\\text{\\AA}]$ 内，$G(r)$ 达到其最大值时的 $r$ 值。\n2. 主峰的半峰全宽 (FWHM)：通过线性插值确定所识别峰周围的左右半高交叉点，并以 $\\text{\\AA}$ 为单位报告它们的差值。\n3. 峰值振幅：在 $[R-1.0\\,\\text{\\AA},\\,R+1.0\\,\\text{\\AA}]$ 区间内 $G(r)$ 的最大值。\n4. 最大旁瓣比：在 FWHM 区间之外（即对于 $r \\in [0,6.0]$，不包括左右半高交叉点之间的区域），$G(r)$ 的最大绝对值与峰值振幅之比。\n\n将所有报告的浮点数值四舍五入到小数点后六位。\n\n测试套件：\n计算以下参数集的结果（$R$ 的单位为 $\\text{\\AA}$，$Q_{\\max}$ 的单位为 $\\text{\\AA}^{-1}$）：\n- 测试 1（一般情况）：$R = 2.0$，$Q_{\\max} = 25.0$。\n- 测试 2（低 $Q_{\\max}$ 边界）：$R = 2.0$，$Q_{\\max} = 8.0$。\n- 测试 3（短距离）：$R = 1.0$，$Q_{\\max} = 25.0$。\n- 测试 4（高 $Q_{\\max}$）：$R = 2.0$，$Q_{\\max} = 40.0$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表组成的列表。每个内部列表对应一个按上述顺序列出的测试用例，并且必须按以下顺序包含十二个浮点数：\n$[$peak$_{\\mathrm{rect}}$, FWHM$_{\\mathrm{rect}}$, amp$_{\\mathrm{rect}}$, sidelobe$_{\\mathrm{rect}}$, peak$_{\\mathrm{Lorch}}$, FWHM$_{\\mathrm{Lorch}}$, amp$_{\\mathrm{Lorch}}$, sidelobe$_{\\mathrm{Lorch}}$, peak$_{\\mathrm{Hann}}$, FWHM$_{\\mathrm{Hann}}$, amp$_{\\mathrm{Hann}}$, sidelobe$_{\\mathrm{Hann}}]$,\n所有浮点数都四舍五入到小数点后六位。例如，打印的行应如下所示：\n[[v11,v12,...,v1,12],[v21,v22,...,v2,12],[v31,...,v3,12],[v41,...,v4,12]]\n\n$r$ 和 FWHM 的所有输出单位必须是 $\\text{\\AA}$，而振幅和比率是无量纲的。不应打印任何额外文本。", "solution": "所提出的问题是材料表征领域中一个适定的计算练习，特别是关于总散射和对分布函数 (PDF) 分析。它具有科学依据、内容完整，并且其参数在物理上是现实的。因此，该问题是有效的，并将提供一个解决方案。\n\n目标是根据约化总散射函数 $F(Q)$ 的模型计算约化对分布函数 $G(r)$，并量化三种不同窗函数对所得 $G(r)$ 峰形的影响。\n\n$G(r)$ 和 $F(Q)$ 之间的关系由正弦傅里叶变换给出：\n$$\nG(r) = \\frac{2}{\\pi} \\int_{0}^{Q_{\\max}} w(Q)\\,F(Q)\\,\\sin(Q r)\\,dQ\n$$\n在这里，$Q$ 是散射矢量的模，$r$ 是原子间距，$Q_{\\max}$ 是实验或计算数据范围的有限上限。函数 $w(Q)$ 是一个窗函数或锥削函数，用于减轻截断涟漪。截断涟漪是由积分在 $Q_{\\max}$ 处突然截断而在 $G(r)$ 中引起的伪振荡。\n\n该问题对一个仅包含单一、唯一原子间距 $R$ 的系统的散射进行建模。对于这样一个简化的系统，约化总散射函数 $F(Q) = Q[S(Q)-1]$（其中 $S(Q)$ 是静态结构因子）可以近似为：\n$$\nF(Q) = \\frac{\\sin(QR)}{R}\n$$\n该模型是针对单个原子对的 Debye 散射方程的缩放版本，并作为本次研究的一个有效的、解析上简单的函数。\n\n我们将比较三种标准窗函数：\n1.  **矩形窗**：$w_{\\mathrm{rect}}(Q) = 1$。这相当于不施加窗函数，通常会在 $G(r)$ 中产生最尖锐的中心峰，但也会产生最严重的截断涟漪。\n2.  **Lorch 窗**：$w_{\\mathrm{Lorch}}(Q) = \\dfrac{\\sin(\\pi Q/Q_{\\max})}{\\pi Q/Q_{\\max}}$。这是一个 sinc 函数，即矩形函数的傅里叶变换。应用它的目的是为了锐化实空间中的特征。\n3.  **Hann 窗**：$w_{\\mathrm{Hann}}(Q) = \\dfrac{1}{2}\\left[1+\\cos(\\pi Q/Q_{\\max})\\right]$。这种升余弦窗能提供出色的旁瓣抑制，但代价是主峰会略有展宽。\n\n我们不计算 $G(r)$ 的解析积分，而是规定使用基于梯形法则的数值方法。连续函数在均匀网格上被离散化。$Q$ 空间网格范围是 $[0, Q_{\\max}]$，步长为 $\\Delta Q = 0.01\\,\\text{\\AA}^{-1}$；$r$ 空间网格范围是 $[0, 6.0\\,\\text{\\AA}]$，步长为 $\\Delta r = 0.002\\,\\text{\\AA}$。\n\n对于 $r$ 网格上的每个点 $r_j$，$G(r_j)$ 的数值计算如下：\n$$\nG(r_j) \\approx \\frac{2}{\\pi} \\sum_{i=0}^{N-1} \\frac{y_i(r_j) + y_{i+1}(r_j)}{2} \\Delta Q\n$$\n其中 $y_i(r_j) = w(Q_i) F(Q_i) \\sin(Q_i r_j)$，$Q_i$ 是 $Q$ 网格上的点。为提高效率，此过程被向量化。$\\sin(Q_i r_j)$ 项通过计算 $Q$ 和 $r$ 向量的外积得到。然后，所有 $r_j$ 值的被积函数被表示为一个矩阵，并沿该矩阵的 $Q$ 轴应用梯形法则，从而在一次操作中计算出整个 $G(r)$ 曲线。\n\n对于每条计算出的 $G(r)$ 曲线，提取四个指标：\n1.  **峰位 ($r_{\\mathrm{peak}}$) 和振幅 ($A_{\\mathrm{peak}}$)**：在搜索区间 $[R-1.0\\,\\text{\\AA}, R+1.0\\,\\text{\\AA}]$ 内找到 $G(r)$ 最大值对应的 $r$ 值和 $G(r)$ 值。\n2.  **半峰全宽 (FWHM)**：峰在其最大振幅 50% 处的宽度。半高值为 $A_{\\mathrm{half}} = A_{\\mathrm{peak}} / 2$。算法从峰位向外搜索，找到在峰的左侧 ($r<r_{\\mathrm{peak}}$) 和右侧 ($r>r_{\\mathrm{peak}}$) 包夹 $A_{\\mathrm{half}}$ 交叉点的网格点。通过在这些包夹点之间进行线性插值来确定精确的交叉坐标 $r_{\\mathrm{left}}$ 和 $r_{\\mathrm{right}}$。然后计算 FWHM 为 $\\text{FWHM} = r_{\\mathrm{right}} - r_{\\mathrm{left}}$。\n3.  **最大旁瓣比**：该指标量化了相对于主峰的伪振荡的大小。其计算方法为：在 FWHM 区间之外（对于 $r \\in [0, r_{\\mathrm{left}}) \\cup (r_{\\mathrm{right}}, 6.0]$），$G(r)$ 的最大绝对值与峰值振幅 $A_{\\mathrm{peak}}$ 之比。\n\n整个过程封装在一个 Python 程序中。一个主函数遍历四个指定的测试用例。对于每个用例，它为三种窗函数计算 $G(r)$，然后调用一个子函数为每个结果曲线计算四个指标。最终结果被收集、四舍五入到小数点后六位，并格式化为所需的字符串表示形式。", "answer": "```python\nimport numpy as np\n\ndef calculate_all_metrics(G_r, r_grid, R):\n    \"\"\"\n    Calculates peak position, FWHM, peak amplitude, and sidelobe ratio for a G(r) curve.\n    \n    Args:\n        G_r (np.ndarray): The computed G(r) values.\n        r_grid (np.ndarray): The r-grid.\n        R (float): The ideal interatomic distance.\n\n    Returns:\n        list: A list containing [peak_pos, fwhm, peak_amp, sidelobe_ratio].\n    \"\"\"\n    # 1. Peak Position and Amplitude\n    search_mask = (r_grid >= R - 1.0)  (r_grid = R + 1.0)\n    \n    # Ensure search range is not empty\n    if not np.any(search_mask):\n        return [np.nan] * 4\n        \n    G_r_search = G_r[search_mask]\n    r_grid_search = r_grid[search_mask]\n    \n    if len(G_r_search) == 0:\n        return [np.nan] * 4\n\n    peak_idx_local = np.argmax(G_r_search)\n    peak_amp = G_r_search[peak_idx_local]\n    \n    # Convert local index back to global index\n    search_indices = np.where(search_mask)[0]\n    peak_idx_global = search_indices[peak_idx_local]\n    peak_pos = r_grid[peak_idx_global]\n\n    if peak_amp == 0:\n        return [peak_pos, 0.0, 0.0, 0.0]\n\n    # 2. FWHM\n    half_max = peak_amp / 2.0\n    \n    # Find left crossing\n    # Search backwards from peak\n    i = peak_idx_global\n    while i > 0 and G_r[i] >= half_max:\n        i -= 1\n    \n    # Linear interpolation for left crossing\n    if i == 0 and G_r[0] >= half_max:\n        r_left = r_grid[0]\n    else:\n        y1, y2 = G_r[i], G_r[i+1]\n        x1, x2 = r_grid[i], r_grid[i+1]\n        r_left = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1) if (y2 - y1) != 0 else (x1 + x2) / 2\n        \n    # Find right crossing\n    # Search forwards from peak\n    j = peak_idx_global\n    while j  len(r_grid) - 1 and G_r[j] >= half_max:\n        j += 1\n\n    # Linear interpolation for right crossing\n    if j == len(r_grid) - 1 and G_r[j] >= half_max:\n        r_right = r_grid[-1]\n    else:\n        y1, y2 = G_r[j-1], G_r[j]\n        x1, x2 = r_grid[j-1], r_grid[j]\n        r_right = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1) if (y2 - y1) != 0 else (x1 + x2) / 2\n        \n    fwhm = r_right - r_left\n\n    # 4. Maximum Sidelobe Ratio\n    sidelobe_mask = (r_grid  r_left) | (r_grid > r_right)\n    sidelobe_values = G_r[sidelobe_mask]\n    \n    if len(sidelobe_values) == 0:\n        max_sidelobe_abs = 0.0\n    else:\n        max_sidelobe_abs = np.max(np.abs(sidelobe_values))\n        \n    sidelobe_ratio = max_sidelobe_abs / peak_amp\n\n    return [peak_pos, fwhm, peak_amp, sidelobe_ratio]\n\ndef process_case(R, Q_max):\n    \"\"\"\n    Processes a single test case (R, Q_max) for all three window functions.\n    \n    Args:\n        R (float): Interatomic distance in Angstroms.\n        Q_max (float): Maximum scattering vector in Angstrom^-1.\n\n    Returns:\n        list: A flattened list of 12 metric values for the three windows.\n    \"\"\"\n    dQ = 0.01\n    dr = 0.002\n    \n    Q = np.arange(0, Q_max + dQ, dQ)\n    r = np.arange(0, 6.0 + dr, dr)\n    \n    F_Q = np.sin(Q * R) / R\n    \n    # Define window functions\n    w_rect = np.ones_like(Q)\n    w_lorch = np.sinc(Q / Q_max) # np.sinc(x) is sin(pi*x)/(pi*x)\n    w_hann = 0.5 * (1 + np.cos(np.pi * Q / Q_max))\n    \n    windows = {'rect': w_rect, 'lorch': w_lorch, 'hann': w_hann}\n    results = []\n    \n    # Vectorized calculation of G(r)\n    Qr_matrix = np.outer(Q, r)\n    sin_Qr = np.sin(Qr_matrix)\n\n    for w_name in ['rect', 'lorch', 'hann']:\n        w_Q = windows[w_name]\n        \n        # Integrand: w(Q) * F(Q) * sin(Qr)\n        integrand_matrix = (w_Q * F_Q)[:, np.newaxis] * sin_Qr\n        \n        # Trapezoidal rule integration along the Q-axis (axis=0)\n        integral_values = np.trapz(integrand_matrix, x=Q, axis=0)\n        \n        G_r = (2 / np.pi) * integral_values\n        \n        # Calculate metrics\n        metrics = calculate_all_metrics(G_r, r, R)\n        results.extend(metrics)\n        \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2.0, 25.0), # Test 1\n        (2.0, 8.0),  # Test 2\n        (1.0, 25.0), # Test 3\n        (2.0, 40.0)  # Test 4\n    ]\n\n    all_results = []\n    for R, Q_max in test_cases:\n        case_results = process_case(R, Q_max)\n        all_results.append(case_results)\n\n    # Format output string\n    row_strings = [f\"[{','.join(f'{v:.6f}' for v in row)}]\" for row in all_results]\n    final_output = f\"[{','.join(row_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2533221"}, {"introduction": "PDF分析不仅是从实验数据中提取结构信息，也包括构建原子模型并验证其与实验的符合程度。这个练习将视角转向“正向建模”：即从一个假设的真实空间结构模型（以 $g(r)$ 函数表示）出发，计算出它应该产生的散射信号 $S(Q)$。这项实践 [@problem_id:2533214] 模拟了材料建模的核心任务，通过编程实现从真实空间到倒易空间的转换，这对于理解如何对照实验数据来精确优化和验证原子尺度模型至关重要。", "problem": "给定一种单原子各向同性材料，其特征为数密度 $\\,\\rho_{0}\\,$ 和对分布函数 (PDF) $\\,g(r)\\,$，其中 $\\,r\\,$ 是对间距。总散射结构因子 $\\,S(Q)\\,$（其中散射矢量模长 $\\,Q\\,$ 的单位为 $\\mathrm{\\AA}^{-1}$）由第一性原理定义为总关联函数 $\\,h(r)=g(r)-1\\,$ 的三维傅里叶变换：\n$$\nS(Q) \\;=\\; 1 \\;+\\; \\rho_{0} \\int_{\\mathbb{R}^{3}} \\mathrm{d}^{3}\\mathbf{r}\\;\\, h(r)\\, e^{\\,i\\,\\mathbf{Q}\\cdot\\mathbf{r}}\\,,\n$$\n其中 $\\,\\mathbf{Q}\\,$ 是一个模长为 $\\,Q\\,$ 的矢量，$\\,r=\\lvert \\mathbf{r}\\rvert\\,$。对于各向同性系统，此式可简化为关于 $\\,r\\,$ 的一维积分，该积分必须从上述定义出发进行推导，不得预设任何简化公式。\n\n你的任务是：\n- 从给定的三维定义和各向同性假设出发，推导出一个关于 $\\,S(Q)\\,$ 的一维积分表达式。该表达式在数值上对于 $\\,Q \\ge 0\\,$（包括明确定义的 $\\,Q \\to 0\\,$ 极限）是易于处理的。\n- 实现一个数值算法，用于在 $\\,S(Q)\\,$ 的指定绝对容差范围内计算所得的一维积分。\n- 将你的实现应用于下面的测试套件，并按要求的格式输出结果。\n\n使用以下解析形式指定的 $\\,g(r)\\,$ 和参数：\n- 数密度：$\\,\\rho_{0} = 0.084\\;\\mathrm{\\AA}^{-3}\\,$。\n- 对分布函数：\n$$\ng(r) \\;=\\; 1 \\;+\\; A \\exp\\!\\Big(-\\frac{(r-r_{0})^{2}}{2\\sigma^{2}}\\Big) \\;-\\; C \\exp\\!\\Big(-\\frac{r^{2}}{2\\sigma_{c}^{2}}\\Big),\n$$\n参数为 $\\,A=1.4\\,$，$\\,r_{0}=2.75\\;\\mathrm{\\AA}\\,$，$\\,\\sigma=0.12\\;\\mathrm{\\AA}\\,$，$\\,C=0.2\\,$ 和 $\\,\\sigma_{c}=0.45\\;\\mathrm{\\AA}\\,$。此 $\\,g(r)\\,$ 函数是平滑的，当 $\\,r\\to \\infty\\,$ 时趋近于 $\\,1\\,$，并且对于单原子系统在物理上是合理的。\n\n数值要求与指南：\n- 所有距离 $\\,r\\,$ 的单位均为 $\\,\\mathrm{\\AA}\\,$，所有 $\\,Q\\,$ 值的单位均为 $\\,\\mathrm{\\AA}^{-1}\\,$。结构因子 $\\,S(Q)\\,$ 是无量纲的。\n- 对于每个测试用例，你必须确保 $\\,S(Q)\\,$ 的绝对误差最多为 $\\,\\varepsilon_{S} = 10^{-8}\\,$。\n- 你的数值计算必须是一维的，并且必须控制积分上限 $\\,r_{\\max}\\,$ 的截断，以确保在与积分前因子结合后，被忽略的尾部积分的贡献小于所要求的容差。你可以假设对于高斯因子 $\\,\\exp(-x^{2}/2)\\,$，其尾部积分满足 $\\,\\int_{k}^{\\infty} \\exp(-t^{2}/2)\\,\\mathrm{d}t \\le \\exp(-k^{2}/2)/k\\,$（对于 $\\,k0\\,$）。你可以选择一个足够大的倍数 $\\,k\\,$，使得尾部积分与 $\\,\\varepsilon_{S}\\,$ 相比可以忽略不计。请确保在你实现中明确记录所选的 $\\,r_{\\max}\\,$。\n- 角度单位：在你的推导中引入的任何角度依赖性都必须以弧度处理。\n- 对分布函数 (PDF) 必须理解为上文定义的实空间函数 $\\,g(r)\\,$。\n\n测试套件：\n- 对所有测试，使用上文指定的单一 $\\,g(r)\\,$ 和 $\\,\\rho_{0}\\,$。为以下四个 $\\,Q\\,$ 值（单位 $\\,\\mathrm{\\AA}^{-1}$）计算 $\\,S(Q)\\,$：$\\,Q \\in \\{0.0,\\;0.5,\\;4.0,\\;15.0\\}\\,$。\n- 对于 $\\,Q=0\\,$，你必须使用从你的推导中得到的正确极限形式，以避免数值奇异点。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含 $\\,S(Q)\\,$ 的四个结果，顺序与上述测试套件的 $\\,Q\\,$ 值相同，四舍五入到恰好 $\\,8\\,$ 位小数，并以逗号分隔的列表形式用方括号括起来。例如，包含四个结果的输出应看起来像 $\\,\\big[$$s_{1}$$,$$s_{2}$$,$$s_{3}$$,$$s_{4}$$\\big]\\,$，其中每个 $\\,s_{i}\\,$ 在小数点后都恰好有 $\\,8\\,$ 位数字。", "solution": "问题陈述已经过验证。它被认为是具有科学依据、内容自洽、逻辑一致且定义良好的。它代表了凝聚态物理学中的一个标准问题。我们继续进行推导和数值求解。\n\n任务是为一个单原子各向同性系统计算总散射结构因子 $S(Q)$。出发点是所给出的定义，即总关联函数 $h(r) = g(r) - 1$ 的三维傅里叶变换。\n$$S(Q) = 1 + \\rho_{0} \\int_{\\mathbb{R}^{3}} \\mathrm{d}^{3}\\mathbf{r}\\; h(r)\\, e^{i\\,\\mathbf{Q}\\cdot\\mathbf{r}}$$\n此处，$\\rho_{0}$ 是数密度，$\\mathbf{Q}$ 是模长为 $Q$ 的散射矢量，$\\mathbf{r}$ 是模长为 $r$ 的位置矢量。系统的各向同性意味着 $h(r)$ 仅依赖于标量距离 $r = |\\mathbf{r}|$。\n\n为了计算该积分，我们用球极坐标 $(r, \\theta, \\phi)$ 表示积分变量 $\\mathbf{r}$。体元为 $\\mathrm{d}^{3}\\mathbf{r} = r^2 \\sin\\theta \\,\\mathrm{d}r\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$。为简便起见，我们将坐标系对齐，使矢量 $\\mathbf{Q}$ 沿着 $z$ 轴。因此，$\\mathbf{Q} = (0, 0, Q)$。指数项中的点积变为 $\\mathbf{Q}\\cdot\\mathbf{r} = Q r \\cos\\theta$，其中 $\\theta$ 是极角。\n\n积分变为：\n$$ \\int_{\\mathbb{R}^{3}} \\mathrm{d}^{3}\\mathbf{r}\\; h(r)\\, e^{i\\,\\mathbf{Q}\\cdot\\mathbf{r}} = \\int_0^\\infty \\mathrm{d}r \\int_0^\\pi \\mathrm{d}\\theta \\int_0^{2\\pi} \\mathrm{d}\\phi\\; h(r)\\, e^{iQr\\cos\\theta}\\, r^2 \\sin\\theta $$\n被积函数与方位角 $\\phi$ 无关，因此对 $\\phi$ 的积分产生一个因子 $2\\pi$：\n$$ = 2\\pi \\int_0^\\infty \\mathrm{d}r\\; r^2 h(r) \\left( \\int_0^\\pi \\mathrm{d}\\theta\\; e^{iQr\\cos\\theta} \\sin\\theta \\right) $$\n我们通过变量替换来计算内层关于 $\\theta$ 的积分。令 $u = \\cos\\theta$，这意味着 $\\mathrm{d}u = -\\sin\\theta\\,\\mathrm{d}\\theta$。$u$ 的积分限从 $\\cos(0)=1$ 变为 $\\cos(\\pi)=-1$。\n$$ \\int_0^\\pi e^{iQr\\cos\\theta} \\sin\\theta\\,\\mathrm{d}\\theta = \\int_1^{-1} e^{iQru} (-\\mathrm{d}u) = \\int_{-1}^1 e^{iQru}\\,\\mathrm{d}u $$\n这个初等积分的计算结果为：\n$$ \\left[ \\frac{e^{iQru}}{iQr} \\right]_{-1}^1 = \\frac{e^{iQr} - e^{-iQr}}{iQr} $$\n使用欧拉恒等式 $\\sin(x) = (e^{ix} - e^{-ix})/(2i)$，上式可简化为：\n$$ \\frac{2i\\sin(Qr)}{iQr} = 2 \\frac{\\sin(Qr)}{Qr} $$\n该表达式在 $Q0$ 和 $r0$ 时有效。\n\n将此结果代回 $S(Q)$ 的表达式，我们得到其一维积分表示：\n$$ S(Q) = 1 + \\rho_{0} \\cdot 2\\pi \\int_0^\\infty r^2 h(r) \\left( 2 \\frac{\\sin(Qr)}{Qr} \\right) \\mathrm{d}r $$\n$$ S(Q) = 1 + 4\\pi\\rho_0 \\int_0^\\infty r^2 (g(r)-1) \\frac{\\sin(Qr)}{Qr} \\mathrm{d}r $$\n这个方程是各向同性系统的一个通用结果，通常以略有不同的形式被称为德拜散射方程。对于数值计算，此形式更优，因为它能正确处理 $Q \\to 0$ 的极限。\n\n对于 $Q=0$ 的特定情况，我们考察被积函数的极限。当 $Q \\to 0$ 时，函数 $\\frac{\\sin(Qr)}{Qr}$ 趋近于 $1$。$S(0)$ 的表达式变为：\n$$ S(0) = \\lim_{Q\\to 0} S(Q) = 1 + 4\\pi\\rho_0 \\int_0^\\infty r^2 (g(r)-1) \\mathrm{d}r $$\n这是一个众所周知的结果，它将零散射角下的结构因子与总关联函数的积分联系起来，而后者又与材料的等温压缩率相关。通过使用一个合适的 `sinc` 函数（其中 $\\text{sinc}(x) = \\sin(x)/x$ 且 $\\text{sinc}(0)=1$）来实现这个统一的公式，我们可以正确地计算所有 $Q \\ge 0$（包括 $Q=0$）情况下的 $S(Q)$，而无需在积分程序中使用特殊情况处理逻辑。\n\n对于数值实现，我们必须计算一个从 $r=0$ 到 $r=\\infty$ 的定积分。我们将使用一个有限的积分上限 $r_{\\max}$，并确保截断误差可以忽略不计。总关联函数由下式给出：\n$$ h(r) = g(r) - 1 = A \\exp\\left(-\\frac{(r-r_{0})^{2}}{2\\sigma^{2}}\\right) - C \\exp\\left(-\\frac{r^{2}}{2\\sigma_{c}^{2}}\\right) $$\n参数为 $A=1.4$， $r_{0}=2.75\\,\\mathrm{\\AA}$， $\\sigma=0.12\\,\\mathrm{\\AA}$， $C=0.2$ 和 $\\sigma_{c}=0.45\\,\\mathrm{\\AA}$。$h(r)$ 中的两项都是高斯函数，对于大的 $r$ 值会极快地衰减。第一项以 $r_0=2.75\\,\\mathrm{\\AA}$ 为中心，具有一个小的标准差 $\\sigma=0.12\\,\\mathrm{\\AA}$。对于距离 $r_0$ 几个 $\\sigma$ 远的 $r$ 值，$h(r)$ 函数及其与 $r$ 的幂的乘积将小到可以忽略。\n我们选择 $r_{\\max}$ 为 $5.0\\,\\mathrm{\\AA}$。在此距离上，第一个指数的参数约为 $-((5.0-2.75)/0.12)^2/2 \\approx -(18.75)^2/2 \\approx -176$，这使得 $\\exp(-176)$ 在计算上为零。相对于其宽度，第二项衰减得更快。因此，选择 $r_{\\max}=5.0\\,\\mathrm{\\AA}$ 足以确保截断误差比所要求的绝对误差容差 $\\varepsilon_S = 10^{-8}$ 小很多个数量级。\n\n该积分将使用 `scipy.integrate.quad` 函数进行计算，这是一个鲁棒的自适应求积程序。为了满足 $S(Q)$ 的目标精度，我们将积分本身的绝对误差容差设置为一个更严格的值，即 `epsabs`$=10^{-10}$。\n\n最终需要实现的表达式是：\n$$ S(Q) = 1 + \\int_0^{r_{\\max}} 4\\pi\\rho_0 r^2 h(r) \\frac{\\sin(Qr)}{Qr} \\mathrm{d}r $$\n函数 $\\frac{\\sin(Qr)}{Qr}$ 将使用 `numpy.sinc` 来实现，以鲁棒地处理 $Qr=0$ 的情况。`numpy.sinc(x)` 函数计算的是 $\\sin(\\pi x)/(\\pi x)$。因此，我们通过 `numpy.sinc(Qr/numpy.pi)` 来计算 $\\frac{\\sin(Qr)}{Qr}$。\n\n步骤如下：\n1.  定义常数 $\\rho_0, A, r_0, \\sigma, C, \\sigma_c$。\n2.  定义函数 $h(r)$。\n3.  定义被积函数 $I(r, Q) = 4\\pi\\rho_0 r^2 h(r) \\frac{\\sin(Qr)}{Qr}$。\n4.  对于每个给定的 $Q$ 值，使用 `scipy.integrate.quad` 计算 $S(Q) = 1 + \\int_0^{5.0} I(r, Q) \\mathrm{d}r$。\n5.  按规定格式化并打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Derives and calculates the total scattering structure factor S(Q)\n    for a monatomic isotropic material.\n    \"\"\"\n    \n    # Define physical constants and parameters for g(r)\n    # in units of Angstroms (Å) and inverse Angstroms (Å⁻¹).\n    RHO0 = 0.084    # Number density in Å⁻³\n    A = 1.4         # Amplitude of the first Gaussian peak\n    R0 = 2.75       # Position of the first peak in Å\n    SIGMA = 0.12    # Width of the first peak in Å\n    C = 0.2         # Amplitude of the compensatory Gaussian\n    SIGMAC = 0.45   # Width of the compensatory Gaussian in Å\n\n    # Numerical integration parameters.\n    # The upper integration limit r_max is chosen to be 5.0 Å.\n    # The function h(r) decays extremely rapidly due to its Gaussian nature.\n    # The dominant term is centered at r0=2.75 Å with sigma=0.12 Å.\n    # At r=5.0 Å, r is (5.0-2.75)/0.12 ≈ 18.75 standard deviations from the peak.\n    # The value of the Gaussian term is proportional to exp(-18.75²/2), which is\n    # computationally zero, ensuring the truncation error is negligible.\n    R_MAX = 5.0\n    \n    # Absolute tolerance for the numerical quadrature to ensure the final\n    # error on S(Q) is less than 10⁻⁸.\n    INTEGRATION_TOL = 1e-10\n\n    def h(r: float) -> float:\n        \"\"\"\n        Calculates the total correlation function, h(r) = g(r) - 1.\n        \n        Args:\n            r: The pair separation distance in Å.\n        \n        Returns:\n            The value of h(r).\n        \"\"\"\n        term1 = A * np.exp(-(r - R0)**2 / (2 * SIGMA**2))\n        term2 = C * np.exp(-r**2 / (2 * SIGMAC**2))\n        return term1 - term2\n\n    def integrand(r: float, Q: float) -> float:\n        \"\"\"\n        The integrand for calculating the integral part of S(Q).\n        This formulation is valid for all Q >= 0.\n        \n        Args:\n            r: The pair separation distance in Å.\n            Q: The magnitude of the scattering vector in Å⁻¹.\n        \n        Returns:\n            The value of the integrand at r for a given Q.\n        \"\"\"\n        # The form is 4*pi*rho0 * r^2 * h(r) * sin(Qr)/(Qr).\n        # We use np.sinc for robust evaluation at Qr -> 0.\n        # np.sinc(x) is defined as sin(pi*x)/(pi*x).\n        # So, to compute sin(Qr)/(Qr), we use np.sinc(Q*r/np.pi).\n        # The r^2 term naturally handles the r=0 case, making the integrand 0.\n        sinc_term = np.sinc(Q * r / np.pi)\n        \n        return 4 * np.pi * RHO0 * r**2 * h(r) * sinc_term\n\n    def calculate_s_q(Q: float) -> float:\n        \"\"\"\n        Calculates the structure factor S(Q) for a given Q value.\n        \n        Args:\n            Q: The magnitude of the scattering vector in Å⁻¹.\n            \n        Returns:\n            The calculated value of S(Q).\n        \"\"\"\n        integral_val, _ = integrate.quad(\n            integrand, a=0, b=R_MAX, args=(Q,), epsabs=INTEGRATION_TOL\n        )\n        return 1.0 + integral_val\n\n    # Test cases for Q in Å⁻¹ as specified in the problem statement.\n    test_cases = [0.0, 0.5, 4.0, 15.0]\n\n    results = []\n    for q_val in test_cases:\n        s_q_result = calculate_s_q(q_val)\n        results.append(s_q_result)\n    \n    # Format the final results to exactly 8 decimal places and print.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2533214"}]}