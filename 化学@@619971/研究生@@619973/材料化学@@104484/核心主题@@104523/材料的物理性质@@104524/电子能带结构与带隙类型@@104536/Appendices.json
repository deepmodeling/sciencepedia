{"hands_on_practices": [{"introduction": "我们从一个基础但极具启发性的解析练习开始。通过构建一个一维双原子链的紧束缚模型，您可以亲手推导出能带的形成与带隙的打开。这个练习不仅能加深您对布洛赫定理和哈密顿量矩阵构建的理解，还能让您直观地看到原子轨道相互作用是如何决定材料是导体还是绝缘体的 [@problem_id:2484916]。", "problem": "考虑一个一维双原子链，每个原胞包含两种原子A和B作为基元，其在位能分别为 $\\epsilon_{A}$ 和 $\\epsilon_{B}$。设晶格常数为 $a$（等效A位置之间的距离），并在每个原胞内将A原子置于位置 $x=0$ 处，B原子置于 $x=a/2$ 处。假设采用最近邻紧束缚模型描述，跃迁积分 $t$ 仅存在于不同类的近邻（A到B）之间，并忽略任何交叠积分和同一子晶格内的跃迁。使用布洛赫定理和紧束缚近似作为基本方法，在 $\\{A,B\\}$ 基下构建 $2\\times 2$ 的布洛赫哈密顿量，推导出双能带色散关系 $E_{\\pm}(k)$，并判断基本带隙是直接带隙还是间接带隙，将其表示为 $\\epsilon_{A}-\\epsilon_{B}$ 和 $t$ 的函数。清晰地指出价带顶和导带底出现的晶体动量。\n\n将你的最终答案表示为一个有序对，其中包含基本带隙 $E_{g}$ 的解析表达式以及此带隙出现的一个晶体动量 $k_{g}$（用 $a$ 表示），写作 $(E_{g},\\,k_{g})$。不需要进行数值计算或四舍五入。", "solution": "所述问题是有效的。这是一个来自固态物理学的、提法恰当、有科学依据且无矛盾或歧义的问题。下面是解题的推导过程。\n\n该体系是一个晶格常数为 $a$ 的一维双原子链。每个原胞（由整数 $n$ 索引）包含两个原子A和B。格点的位置由 $R_n = na$ 给出。A原子位于 $na$ 位置，B原子位于 $na + a/2$ 位置。在位能为 $\\epsilon_A$ 和 $\\epsilon_B$，不同原子间的最近邻跃迁积分为 $t$。我们忽略同一子晶格内的跃迁和交叠积分。\n\n我们使用紧束缚近似来构建解。晶体波函数 $\\Psi_k(x)$ 是由A、B原子的原子轨道形成的布洛赫和的线性组合。设 $|\\phi_{A,n}\\rangle$ 和 $|\\phi_{B,n}\\rangle$ 分别是第 $n$ 个原胞中A原子和B原子的原子轨道。相应的布洛赫基矢为：\n$$ |\\psi_{A,k}\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n} \\exp(ikna) |\\phi_{A,n}\\rangle $$\n$$ |\\psi_{B,k}\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n} \\exp(ikna) |\\phi_{B,n}\\rangle $$\n其中 $N$ 是原胞数，$k$ 是晶体动量。对于给定的 $k$，波函数可以写成 $\\Psi_k = c_A |\\psi_{A,k}\\rangle + c_B |\\psi_{B,k}\\rangle$。问题简化为求解此基下 $2 \\times 2$ 布洛赫哈密顿量 $H(k)$ 的本征值方程：\n$$ H(k) \\begin{pmatrix} c_A \\\\ c_B \\end{pmatrix} = E(k) \\begin{pmatrix} c_A \\\\ c_B \\end{pmatrix} $$\n$H(k)$ 的矩阵元为 $H_{ij}(k) = \\langle \\psi_{i,k} | H | \\psi_{j,k} \\rangle$，其中 $i, j \\in \\{A, B\\}$。\n\n对角元代表在位能，并会受任何同一子晶格内跃迁的修正。由于忽略了同一子晶格内的跃迁，因此它们就是简单的在位能。\n$H_{AA}(k) = \\langle \\psi_{A,k} | H | \\psi_{A,k} \\rangle = \\frac{1}{N} \\sum_{n,m} \\exp(ik(m-n)a) \\langle \\phi_{A,n} | H | \\phi_{A,m} \\rangle$。\n哈密顿算符 $H$ 仅将一个轨道与其自身（在位能）或其最近邻（跃迁）相联系。因此，$\\langle \\phi_{A,n} | H | \\phi_{A,m} \\rangle = \\epsilon_A \\delta_{nm}$。\n$$ H_{AA}(k) = \\frac{1}{N} \\sum_{n} \\exp(0) \\epsilon_A = \\epsilon_A $$\n类似地，\n$$ H_{BB}(k) = \\epsilon_B $$\n\n非对角元代表子晶格之間的跃迁。\n$H_{AB}(k) = \\langle \\psi_{A,k} | H | \\psi_{B,k} \\rangle = \\frac{1}{N} \\sum_{n,m} \\exp(ik(m-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,m} \\rangle$。\n在原胞 $n$ 中的A原子（位于 $na$ 位置）有两个B类型的最近邻：一个在同原胞 $n$ 中的B原子（位于 $na+a/2$ 位置），另一个在前一个原胞 $n-1$ 中的B原子（位于 $(n-1)a+a/2 = na-a/2$ 位置）。因此，对于给定的位于 $n$ 位置的A原子，跃迁项 $\\langle \\phi_{A,n} | H | \\phi_{B,m} \\rangle$ 仅在 $m=n$ 和 $m=n-1$ 时非零。在这两种情况下，其值均为跃迁积分 $t$。\n对 $m$ 的求和简化为两项：\n$$ H_{AB}(k) = \\frac{1}{N} \\sum_{n} \\left( \\exp(ik(n-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,n} \\rangle + \\exp(ik((n-1)-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,n-1} \\rangle \\right) $$\n$$ H_{AB}(k) = \\frac{1}{N} \\sum_{n} \\left( t + t\\exp(-ika) \\right) = t(1 + \\exp(-ika)) $$\n由于哈密顿量是厄米的，所以 $H_{BA}(k) = (H_{AB}(k))^*$。\n$$ H_{BA}(k) = t^*(1 + \\exp(ika)) $$\n假设跃迁积分 $t$ 是一个实数参数，则 $t^*=t$。\n$$ H_{BA}(k) = t(1 + \\exp(ika)) $$\n\n布洛赫哈密顿矩阵为：\n$$ H(k) = \\begin{pmatrix} \\epsilon_A & t(1+\\exp(-ika)) \\\\ t(1+\\exp(ika)) & \\epsilon_B \\end{pmatrix} $$\n为了求能量本征值 $E(k)$，我们求解久期方程 $\\det(H(k) - E I) = 0$：\n$$ (\\epsilon_A - E)(\\epsilon_B - E) - |t(1+\\exp(-ika))|^2 = 0 $$\n非对角项的平方为：\n$|t(1+\\exp(-ika))|^2 = t^2 (1+\\exp(-ika))(1+\\exp(ika)) = t^2(1 + \\exp(ika) + \\exp(-ika) + 1) = t^2(2 + 2\\cos(ka)) = 4t^2\\cos^2(ka/2)$。\n久期方程变为：\n$$ E^2 - (\\epsilon_A + \\epsilon_B)E + \\epsilon_A \\epsilon_B - 4t^2\\cos^2(ka/2) = 0 $$\n解此关于 $E$ 的二次方程，得到两个能带，$E_+(k)$（导带）和 $E_-(k)$（价带）：\n$$ E_{\\pm}(k) = \\frac{\\epsilon_A + \\epsilon_B \\pm \\sqrt{(\\epsilon_A + \\epsilon_B)^2 - 4(\\epsilon_A\\epsilon_B - 4t^2\\cos^2(ka/2))}}{2} $$\n$$ E_{\\pm}(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} \\pm \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)} $$\n\n为了确定基本带隙，我们必须找到价带顶 $E_{VBM}$ 和导带底 $E_{CBM}$。这些极值出现在 $dE/dk=0$ 的点，即第一布里渊区的高对称点（$k=0$ 和 $k=\\pm \\pi/a$）。\n色散关系的 $k$ 依赖性完全包含在 $\\cos^2(ka/2)$ 项中。\n价带为 $E_-(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)}$。为了使 $E_-(k)$ 最大化，我们必须最小化从常数平均能量中减去的正项。这意味着我们必须最小化平方根项，这又意味着最小化 $\\cos^2(ka/2)$。$\\cos^2(ka/2)$ 的最小值为 $0$，出现在第一布里渊区的边界，即 $k = \\pm \\pi/a$。\n因此，价带顶（VBM）位于 $k_{VBM} = \\pm \\pi/a$。\n$$ E_{VBM} = E_-(\\pm\\pi/a) = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2} = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}|\\epsilon_A - \\epsilon_B| = \\min(\\epsilon_A, \\epsilon_B) $$\n\n导带为 $E_+(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)}$。为了使 $E_+(k)$ 最小化，我们必须最小化加到常数平均能量上的正项。同样，这需要最小化 $\\cos^2(ka/2)$，这发生在 $k = \\pm \\pi/a$。\n因此，导带底（CBM）位于 $k_{CBM} = \\pm \\pi/a$。\n$$ E_{CBM} = E_+(\\pm\\pi/a) = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2} = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}|\\epsilon_A - \\epsilon_B| = \\max(\\epsilon_A, \\epsilon_B) $$\n\n由于价带顶和导带底都出现在相同的晶体动量（$k = \\pm \\pi/a$）处，所以基本带隙是直接带隙。此结论对任何非零的 $t$ 值和任何 $\\epsilon_A, \\epsilon_B$ 值都成立。\n\n基本带隙 $E_g$ 是导带底和价带顶之差：\n$$ E_g = E_{CBM} - E_{VBM} = \\max(\\epsilon_A, \\epsilon_B) - \\min(\\epsilon_A, \\epsilon_B) = |\\epsilon_A - \\epsilon_B| $$\n该直接带隙出现在晶体动量 $k_g = \\pm \\pi/a$ 处。问题要求给出一个这样的动量。我们选择 $k_g = \\pi/a$。\n\n最终答案是有序对 $(E_g, k_g)$。", "answer": "$$ \\boxed{ \\left( |\\epsilon_A - \\epsilon_B|, \\frac{\\pi}{a} \\right) } $$", "id": "2484916"}, {"introduction": "在获得能带结构 $E(\\mathbf{k})$ 后（无论是通过解析推导还是数值计算），下一步是从中提取关键的物理参数。本练习将指导您如何通过对能带极值点附近的色散关系进行二次拟合，来计算电子的有效质量张量 $\\mathbf{M}$ [@problem_id:2484981]。有效质量是描述载流子在晶体中运动惯性的核心概念，这个计算实践是连接能带论与半导体器件物理的重要一环。", "problem": "给定一个导带底附近的数值电子色散关系族，当波矢大小足够小时，它可以用一个各向异性抛物线能带模型来描述，并可以附加一个微弱的非抛物线修正。假定三维色散关系遵循以下基本关系：\n\n- 有效质量张量 $\\mathbf{M}$ 由能带边能量 $E(\\mathbf{k})$ 的曲率定义，其关系式为：\n$$\n\\left(\\mathbf{M}^{-1}\\right)_{ij} = \\frac{1}{\\hbar^2}\\,\\frac{\\partial^2 E}{\\partial k_i \\partial k_j}\\bigg|_{\\mathbf{k}=\\mathbf{0}},\n$$\n其中 $\\hbar$是约化普朗克常数，$i,j \\in \\{x,y,z\\}$，$\\mathbf{k}$ 是晶体动量，单位为逆长度。\n\n- 在最小值附近，色散关系可以展开为：\n$$\nE(\\mathbf{k}) \\approx E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4,\n$$\n其中 $E_0$ 是一个恒定的能量偏移，二次项包含了有效质量张量的信息，$\\beta \\ge 0$ 是一个小的非抛物线性系数。除非另有说明，所有能量必须以电子伏特 (electronvolts) 为单位，波矢以逆米 (inverse meters) 为单位，质量以千克 (kilograms) 为单位。\n\n沿给定对称方向集的主有效质量，应通过对一维截线 $E(t\\,\\hat{\\mathbf{u}})$ 进行二次拟合来获得，其中 $t$ 是沿单位方向 $\\hat{\\mathbf{u}}$ 的标量波数。如果在给定方向集上的质量在指定的相对容差内相等，则旋转不变性被视为有效。\n\n你的任务是编写一个完整的程序，对下面指定的每个测试用例执行以下操作：\n\n1. 对于每个为提取质量而提供的单位方向 $\\hat{\\mathbf{u}}$，在围绕 $t=0$ 对称分布的几个小的 $t$ 值处对 $E(t\\,\\hat{\\mathbf{u}})$ 进行采样。使用关于标量变量 $t$ 的最小二乘二次拟合（包括一个常数项）来估计该方向上的曲率。根据该曲率和上述基本定义，推导出相应的方向有效质量。沿 $\\hat{\\mathbf{u}}$ 的方向质量是通过将一维展开式 $E(t\\,\\hat{\\mathbf{u}}) \\approx E_0 + \\frac{\\hbar^2}{2\\,m_{\\hat{\\mathbf{u}}}} t^2$ 与从张量定义和曲率拟合中获得的主二次项相等来定义的。将每个得到的质量以电子静止质量 $m_{\\mathrm{e}}$ 的单位（无量纲比率）表示，并四舍五入到六位小数。\n\n2. 对每个测试用例，在适当时还需验证旋转不变性：计算沿附加验证方向的方向质量，并报告一个布尔值，指示所有这些质量在该测试用例指定的相对容差 $\\tau$ 内是否相等。使用以下标准：\n$$\n\\frac{\\max_i m_i - \\min_i m_i}{\\frac{1}{N}\\sum_{i=1}^N m_i} \\le \\tau,\n$$\n其中 $m_i$ 是沿验证方向的方向质量，$N$ 是验证方向的数量。\n\n3. 使用以下物理常数：\n- $\\hbar = 1.054\\,571\\,817\\times 10^{-34}\\,\\mathrm{J\\cdot s}$，\n- $m_{\\mathrm{e}} = 9.109\\,383\\,7015\\times 10^{-31}\\,\\mathrm{kg}$，\n- $1\\,\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}\\,\\mathrm{J}$，\n- $1\\,\\text{\\AA}^{-1} = 10^{10}\\,\\mathrm{m}^{-1}$。\n\n4. 单位与换算：\n- 所有内部计算的波矢必须以 $\\mathrm{m}^{-1}$ 为单位。\n- 色散模型返回的能量必须以 $\\mathrm{eV}$ 为单位。\n- 输出的质量必须报告为比率 $m_{\\hat{\\mathbf{u}}}/m_{\\mathrm{e}}$，并四舍五入到六位小数。\n- 下面任何旋转矩阵中出现的所有角度都以度为单位指定；若提供了数值矩阵，则直接使用这些数字。\n\n5. 估计曲率的拟合方案：\n- 对于每个方向 $\\hat{\\mathbf{u}}$ 和测试用例，使用提供的 $k$ 值大小（单位为 $\\text{\\AA}^{-1}$）及其负值，连同 $0$ 一起，构成 $\\mathrm{m}^{-1}$ 单位的样本集 $\\{t\\}$。也就是说，对于给定的列表 $[k_1,k_2,\\dots,k_M]$，使用 $\\{-k_M,\\dots,-k_1,0,k_1,\\dots,k_M\\}$（单位 $\\mathrm{m}^{-1}$）并在每个点上评估 $E(t\\,\\hat{\\mathbf{u}})$。\n- 对 $E$ 和 $t^2$ 执行带截距项的线性最小二乘回归，以提取在最小化 $E$ 的平方误差意义下的最佳拟合二次项系数。根据这个系数和上述定义，计算方向有效质量。\n\n6. 输出格式：\n你的程序应生成单行输出，其中包含所有测试用例结果的Python风格列表，顺序与下面给出的测试用例相同。每个测试用例的结果本身必须是一个包含四个元素的列表 $[m_1, m_2, m_3, R]$，其中 $m_1,m_2,m_3$ 是对应于该测试中用于质量提取的三个指定对称方向的三个方向有效质量（以$m_{\\mathrm{e}}$为单位），每个都四舍五入到六位小数，而 $R$ 是一个布尔值，指示是否在所述容差下对相关的验证方向集验证了旋转不变性。因此，最终的程序输出应为表示一个包含四个此类列表的列表的单行。\n\n测试套件：\n\n对于每个测试，色散关系由一个质量张量和可选的非抛物线性根据以下公式生成：\n$$\nE(\\mathbf{k}) = E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta\\,\\|\\mathbf{k}\\|^4,\n$$\n其中 $E(\\mathbf{k})$ 的单位是 $\\mathrm{eV}$，$\\mathbf{k}$ 的单位是 $\\mathrm{m}^{-1}$，$\\mathbf{M}$ 的单位是 $\\mathrm{kg}$，而 $\\beta$ 的单位是 $\\mathrm{eV\\cdot m^4}$。实验室坐标系中的质量张量构造为 $\\mathbf{M} = \\mathbf{R}\\,\\mathrm{diag}(m_x, m_y, m_z)\\,\\mathbf{R}^{\\mathsf{T}}$，其中 $m_x,m_y,m_z$ 以 $m_{\\mathrm{e}}$ 为单位指定，$\\mathbf{R}$ 是一个正交旋转矩阵。\n\n- 测试 1 (各向同性，严格抛物线):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.2, 0.2, 0.2)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{I}_3$。\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向： $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$。\n  - 用于旋转不变性验证的方向： $(1,0,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $\\frac{1}{\\sqrt{3}}(1,1,1)$, $(0.866025403784, 0.5, 0)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-6}$。\n  - $k$ 值大小 (与其负值和零一起使用)： $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n- 测试 2 (各向异性，轴对齐):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.2, 0.3, 1.0)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{I}_3$。\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向： $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$。\n  - 用于旋转不变性验证的方向：$(1,0,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $\\frac{1}{\\sqrt{3}}(1,1,1)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-6}$。\n  - $k$ 值大小： $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n- 测试 3 (各向同性，带弱非抛物线性):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.5, 0.5, 0.5)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{I}_3$。\n  - $\\beta = 5.0\\times 10^{-39}\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向： $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$。\n  - 验证方向： $(1,0,0)$, $(0,1,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $(0,0,1)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-3}$。\n  - $k$ 值大小： $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n- 测试 4 (各向异性，主轴旋转):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.15, 0.30, 0.80)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{R}_z(30^\\circ)\\,\\mathbf{R}_y(20^\\circ)$，其数值为\n    $$\n    \\mathbf{R} =\n    \\begin{pmatrix}\n    0.813797681349 & -0.500000000000 & 0.296198132726 \\\\\n    0.469846310393 & 0.866025403784 & 0.171010071663 \\\\\n    -0.342020143326 & 0.000000000000 & 0.939692620786\n    \\end{pmatrix}.\n    $$\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向 (选择为 $\\mathbf{R}$ 的列，并进行归一化)： $\\hat{\\mathbf{u}}_1=(0.813797681349, 0.469846310393, -0.342020143326)$, $\\hat{\\mathbf{u}}_2=(-0.5, 0.866025403784, 0)$, $\\hat{\\mathbf{u}}_3=(0.296198132726, 0.171010071663, 0.939692620786)$。\n  - 验证方向： $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0.813797681349, 0.469846310393, -0.342020143326)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-6}$。\n  - $k$ 值大小： $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n实现要求：\n\n- 完全按照上述规定实现色散模型。\n- 对每个测试用例，计算并输出列表 $[m_1, m_2, m_3, R]$，其中 $m_1,m_2,m_3$ 分别对应于该测试用例给定的三个对称方向，以 $m_{\\mathrm{e}}$ 为单位并四舍五入到六位小数，而 $R$ 是使用所述容差和验证方向对该情况进行旋转不变性检查的布尔结果。\n- 你的程序应生成单行输出，其中包含一个Python风格的列表的列表作为结果，例如，类似 $[[m_{1,1},m_{1,2},m_{1,3},R_1],[m_{2,1},m_{2,2},m_{2,3},R_2],\\dots]$。", "solution": "所提出的问题是固体物理学中一个定义明确的计算练习，具体涉及使用有效质量近似来表征能带极值点附近的电子能带结构。该问题在科学上是合理的，内部是一致的，并为其解决提供了所有必要的信息。因此，我将着手提供一个完整的解决方案。\n\n对于每个测试用例，求解方法包括三个主要步骤：首先，根据提供的参数构建能量色散模型；其次，通过模拟能量数据并进行二次最小二乘拟合来计算方向有效质量；第三，基于一组计算出的方向质量来评估旋转不变性。\n\n能量色散 $E$ 作为晶体动量波矢 $\\mathbf{k}$ 的函数，其基本物理模型由在能带最小值 $\\mathbf{k}=\\mathbf{0}$ 附近的展开给出：\n$$\nE(\\mathbf{k}) \\approx E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4\n$$\n此处，$E_0$ 是能带最小值的能量，$\\mathbf{M}$ 是有效质量张量，$\\hbar$ 是约化普朗克常数，$\\beta$ 是考虑非抛物线性的系数。问题指明能量单位为电子伏特 ($eV$)，波矢 $\\mathbf{k}$ 单位为逆米 ($m^{-1}$)，质量单位为千克 ($kg$)，$\\beta$ 单位为 $eV \\cdot m^4$。二次项 $\\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k}$ 的单位是焦耳 ($J$)。为保持一致性，该项必须通过除以基本电荷 $e$ 来转换为电子伏特，其以库仑为单位的数值等于从 $eV$ 到 $J$ 的转换因子。因此，用于计算的正确表述的色散关系是：\n$$\nE(\\mathbf{k}) [\\mathrm{eV}] = E_0 + \\frac{\\hbar^2}{2e}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4\n$$\n有效质量张量 $\\mathbf{M}$ 由其主质量 $(m_x, m_y, m_z)$（以电子静止质量 $m_{\\mathrm{e}}$ 为单位）和一个旋转矩阵 $\\mathbf{R}$ 构造而成，即 $\\mathbf{M} = \\mathbf{R}\\,\\mathrm{diag}(m_x m_{\\mathrm{e}}, m_y m_{\\mathrm{e}}, m_z m_{\\mathrm{e}})\\,\\mathbf{R}^{\\mathsf{T}}$。然后通过数值方法计算逆张量 $\\mathbf{M}^{-1}$。\n\n为了找到沿单位方向 $\\hat{\\mathbf{u}}$ 的方向有效质量 $m_{\\hat{\\mathbf{u}}}$，我们考虑一维色散 $E(t\\,\\hat{\\mathbf{u}})$，其中 $t$ 是沿 $\\hat{\\mathbf{u}}$ 的标量波数。这由近似式 $E(t\\,\\hat{\\mathbf{u}}) \\approx E_0 + \\frac{\\hbar^2}{2e\\,m_{\\hat{\\mathbf{u}}}} t^2$ 定义。我们通过将二次模型 $E_{fit}(t) = a_0 + a_2 t^2$ 拟合到一组采样数据点来估计 $t^2$ 项的系数。对于给定的幅值列表 $[k_1, k_2, \\dots, k_M]$，通过在 $t \\in \\{-k_M, \\dots, -k_1, 0, k_1, \\dots, k_M\\}$ 处计算 $E(t\\,\\hat{\\mathbf{u}})$ 来生成样本（将幅值从 $\\text{\\AA}^{-1}$ 转换为 $m^{-1}$ 之后）。拟合过程是对模型 $E = a_0 + a_2(t^2)$ 进行线性最小二乘回归，其中 $t^2$ 是自变量。得到的最佳拟合系数 $a_2$ 是 $\\frac{\\hbar^2}{2e\\,m_{\\hat{\\mathbf{u}}}}$ 的一个估计值。然后，以千克为单位的方向有效质量可提取为：\n$$\nm_{\\hat{\\mathbf{u}}} = \\frac{\\hbar^2}{2e\\,a_2}\n$$\n随后，通过除以电子静止质量，将该值表示为无量纲比率 $m_{\\hat{\\mathbf{u}}}/m_{\\mathrm{e}}$。\n\n对于每个测试用例，该过程首先应用于一组指定的三个“对称方向”，以获得所需的质量 $m_1$、$m_2$ 和 $m_3$。\n\n最后，对另一组“验证方向”评估旋转不变性。对一组 $N$ 个验证方向计算方向质量 $\\{m_i\\}$。如果在给定的容差 $\\tau$ 内满足以下条件，则认为材料是旋转不变的：\n$$\n\\frac{\\max_i m_i - \\min_i m_i}{\\frac{1}{N}\\sum_{i=1}^N m_i} \\le \\tau\n$$\n此检查得出一个布尔值 $R$。\n\n计算实现将封装这些步骤。一个用于能量色散模型的函数将接受 $\\mathbf{k}$ 和测试用例参数以返回 $E(\\mathbf{k})$。第二个函数将协调对给定方向 $\\hat{\\mathbf{u}}$ 的采样、拟合和方向质量提取。一个主程序将遍历提供的测试套件，为指定的质量提取和验证方向调用这些函数，并将为每个案例汇总最终结果 $[m_1, m_2, m_3, R]$。程序将使用提供的高精度物理常数并按规定处理所有单位换算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electronic dispersion problem for all test cases.\n    \"\"\"\n    \n    # Physical constants\n    HBAR = 1.054571817e-34    # J.s\n    M_E = 9.1093837015e-31     # kg\n    EV_TO_J = 1.602176634e-19  # J/eV\n    AA_INV_TO_M_INV = 1e10     # m^-1 / A^-1\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.2, 0.2, 0.2),\n            \"R\": np.identity(3),\n            \"beta\": 0.0,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)), (0.866025403784, 0.5, 0)],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.2, 0.3, 1.0),\n            \"R\": np.identity(3),\n            \"beta\": 0.0,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3))],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.5, 0.5, 0.5),\n            \"R\": np.identity(3),\n            \"beta\": 5.0e-39,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (0, 1, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (0, 0, 1)],\n            \"tau\": 1e-3,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.15, 0.30, 0.80),\n            \"R\": np.array([\n                [0.813797681349, -0.500000000000, 0.296198132726],\n                [0.469846310393, 0.866025403784, 0.171010071663],\n                [-0.342020143326, 0.000000000000, 0.939692620786]\n            ]),\n            \"beta\": 0.0,\n            \"mass_directions\": [(0.813797681349, 0.469846310393, -0.342020143326), (-0.5, 0.866025403784, 0), (0.296198132726, 0.171010071663, 0.939692620786)],\n            \"validation_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1), (0.813797681349, 0.469846310393, -0.342020143326)],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        }\n    ]\n\n    def dispersion_model(k_vec, E0, Minv, beta):\n        \"\"\"Calculates energy E(k) in eV.\"\"\"\n        # k_vec is a 3-element numpy array in m^-1\n        k_norm_sq = np.dot(k_vec, k_vec)\n        \n        # Quadratic term. k.T @ M_inv @ k\n        quad_term_J = 0.5 * (HBAR**2) * (k_vec @ Minv @ k_vec)\n        quad_term_eV = quad_term_J / EV_TO_J\n        \n        # Non-parabolic term\n        non_para_term_eV = beta * (k_norm_sq**2)\n        \n        return E0 + quad_term_eV + non_para_term_eV\n\n    def calculate_directional_mass(u_vec, E0, Minv, beta, k_magnitudes_aa):\n        \"\"\"Calculates directional mass along u_vec in units of m_e.\"\"\"\n        u_vec = np.array(u_vec)\n        u_vec = u_vec / np.linalg.norm(u_vec)\n\n        # Prepare sampling points t in m^-1\n        k_mags_m_inv = np.array(k_magnitudes_aa) * AA_INV_TO_M_INV\n        t_samples = np.concatenate([-k_mags_m_inv[::-1], [0], k_mags_m_inv])\n\n        # Sample energy values\n        E_samples = np.array([dispersion_model(t * u_vec, E0, Minv, beta) for t in t_samples])\n        \n        # Perform least-squares fit for E = a0 + a2*t^2\n        t_samples_sq = t_samples**2\n        A = np.vstack([np.ones(len(t_samples_sq)), t_samples_sq]).T\n        \n        # Solve for coefficients [a0, a2]\n        coeffs, _, _, _ = np.linalg.lstsq(A, E_samples, rcond=None)\n        a2 = coeffs[1]\n        \n        # Calculate mass from the quadratic coefficient a2\n        # a2 = (hbar^2) / (2 * e_charge * m_directional)\n        # m_directional is in kg\n        if a2 == 0:\n            return np.inf\n        mass_kg = (HBAR**2) / (2 * EV_TO_J * a2)\n        mass_me = mass_kg / M_E\n        \n        return mass_me\n\n    def check_rotational_invariance(masses, tolerance):\n        \"\"\"Checks if masses are equal within a relative tolerance.\"\"\"\n        if not masses or len(masses) < 2:\n            return True\n        mass_arr = np.array(masses)\n        max_m = np.max(mass_arr)\n        min_m = np.min(mass_arr)\n        avg_m = np.mean(mass_arr)\n        if avg_m == 0:\n            return max_m == min_m\n        \n        spread = (max_m - min_m) / avg_m\n        return spread <= tolerance\n\n    all_results = []\n    for case in test_cases:\n        # Construct inverse mass tensor M_inv\n        m_diag_kg = np.diag(case[\"principal_masses_me\"]) * M_E\n        R = case[\"R\"]\n        M = R @ m_diag_kg @ R.T\n        Minv = np.linalg.inv(M)\n        \n        # Calculate masses for the three main directions\n        mass_results_me = []\n        for u in case[\"mass_directions\"]:\n            mass = calculate_directional_mass(u, case[\"E0\"], Minv, case[\"beta\"], case[\"k_magnitudes_aa\"])\n            mass_results_me.append(mass)\n\n        # Perform rotational invariance validation\n        validation_masses = []\n        for v in case[\"validation_directions\"]:\n            mass = calculate_directional_mass(v, case[\"E0\"], Minv, case[\"beta\"], case[\"k_magnitudes_aa\"])\n            validation_masses.append(mass)\n            \n        is_invariant = check_rotational_invariance(validation_masses, case[\"tau\"])\n\n        # Format and append results\n        formatted_masses = [round(m, 6) for m in mass_results_me]\n        all_results.append(formatted_masses + [is_invariant])\n    \n    # Custom string formatting to match Python list literal style\n    # and ensure six decimal places for floats.\n    result_strs = []\n    for result in all_results:\n        m1_str = f\"{result[0]:.6f}\"\n        m2_str = f\"{result[1]:.6f}\"\n        m3_str = f\"{result[2]:.6f}\"\n        R_str = str(result[3])\n        result_strs.append(f\"[{m1_str}, {m2_str}, {m3_str}, {R_str}]\")\n\n    final_output_str = f\"[{','.join(result_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2484981"}, {"introduction": "最后的练习将能带理论与可测量的光学性质直接联系起来。您将学习如何使用费米黄金定则，根据给定的能带结构计算材料的光吸收谱，并应用“剪刀算符”（scissor operator）这一实用技术来修正密度泛函理论（DFT）中常见的带隙低估问题 [@problem_id:2484915]。这项实践模拟了计算材料科学中的一个典型工作流程，即从电子结构出发预测材料的光电响应。", "problem": "给定来自密度泛函理论 (DFT) 的、针对直接带隙半导体的离散单粒子能带结构，该结构在布里渊区 (BZ) 上进行了一维采样，同时还提供了$k$点权重和光学跃迁矩阵元的平方。您的任务是实现对导带的剪刀算符修正，并评估其对独立粒子光学吸收谱的影响。所有能量必须以电子伏特 ($\\mathrm{eV}$) 为单位处理，吸收值必须以任意单位 (无量纲) 报告，并四舍五入到六位小数。\n\n基本原理：\n- 零温独立粒子近似 (IPA)：光学带间吸收由从已占据的价带态到空的导带态的垂直跃迁驱动，并可通过费米黄金定则进行建模。吸收部分与跃迁概率在$k$点上的加权和成正比，该和乘以一个强制执行能量守恒的狄拉克δ函数。\n- 费米黄金定则 (独立粒子，直接跃迁)：\n$$\n\\alpha(E_\\gamma) \\propto \\sum_{k} w_k \\, \\lvert M(k) \\rvert^2 \\, \\delta\\!\\left(E_c(k) - E_v(k) - E_\\gamma \\right),\n$$\n其中 $E_\\gamma$ 是光子能量，$w_k$ 是 $k$ 点权重，$E_v(k)$ 和 $E_c(k)$ 是价带和导带能量，$\\lvert M(k) \\rvert^2$ 是动量 (或速度) 矩阵元的模平方。\n- 剪刀算符：将导带通过一个常数 $\\Delta$ 进行刚性上移，$E_c^{\\mathrm{sc}}(k) = E_c(k) + \\Delta$。\n- 数值展宽：用宽度为 $\\sigma$ 的归一化高斯函数替换狄拉克δ函数：\n$$\n\\delta_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right).\n$$\n- 离散 $k$ 空间近似：布里渊区上的积分被替换为在给定 $k$ 点 $\\{k_i\\}$ 上使用权重 $\\{w_i\\}$ 的加权和。\n\n从这些原理出发（而非使用快捷公式），通过应用剪刀算符和在离散 $k$ 点表示中使用高斯展宽的费米黄金定则，推导并实现对指定光子能量下吸收谱值的计算。假设温度为零，因此价带完全被占据，导带为空。\n\n使用数据（所有能量单位为 $\\mathrm{eV}$，权重无量纲）：\n- $k$ 点权重 $[w_0,w_1,w_2,w_3,w_4] = [\\,0.1,\\,0.2,\\,0.4,\\,0.2,\\,0.1\\,]$。\n- 价带能量 $[E_v(k_i)] = [\\,-0.10,\\,-0.02,\\,0.00,\\,-0.02,\\,-0.10\\,]$。\n- 导带能量 $[E_c(k_i)] = [\\,2.10,\\,1.95,\\,1.80,\\,1.95,\\,2.10\\,]$。\n- 光学矩阵元平方 $[\\lvert M(k_i) \\rvert^2] = [\\,0.5,\\,1.0,\\,2.0,\\,1.0,\\,0.5\\,]$。\n\n对于光子能量 $E_\\gamma$、剪刀位移 $\\Delta$ 和高斯宽度 $\\sigma$，将计算的吸收定义为：\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) \\propto \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta_\\sigma\\!\\left( \\left[E_c(k_i) + \\Delta\\right] - E_v(k_i) - E_\\gamma \\right).\n$$\n因为仅在不同的 $(\\Delta,\\sigma)$ 值之间比较相对趋势，您可以直接使用这个比例量（即，省略所有情况共有的任何预因子）。您的程序必须将此比例量 $\\alpha$ 计算为一个实数（无量纲），以任意单位表示。\n\n要实现和评估的测试套件：\n- 案例 $1$ (基准，无剪刀修正)：$\\Delta = 0.0$ $\\mathrm{eV}$，$\\sigma = 0.05$ $\\mathrm{eV}$，光子能量 $[\\,1.8,\\,2.0,\\,2.2\\,]$ $\\mathrm{eV}$。\n- 案例 $2$ (大剪刀位移，尖锐谱线)：$\\Delta = 0.5$ $\\mathrm{eV}$，$\\sigma = 0.01$ $\\mathrm{eV}$，光子能量 $[\\,1.8,\\,2.0,\\,2.2\\,]$ $\\mathrm{eV}$。\n- 案例 $3$ (中等剪刀位移，与案例1相同的展宽)：$\\Delta = 0.2$ $\\mathrm{eV}$，$\\sigma = 0.05$ $\\mathrm{eV}$，光子能量 $[\\,2.0,\\,2.2,\\,2.4\\,]$ $\\mathrm{eV}$。\n\n要求：\n- 在评估跃迁之前，将剪刀算符实现为刚性位移 $E_c(k) \\mapsto E_c(k) + \\Delta$。\n- 使用指定宽度 $\\sigma$ 的归一化高斯展宽 $\\delta_\\sigma(x)$。\n- 对于每个案例，计算所列出的每个光子能量下的吸收，并将每个结果四舍五入到六位小数。\n- 所有案例的输出必须汇总到单行中，格式完全如下：一个 Python 风格的列表的列表，其中每个内部列表按相同顺序包含该案例中各光子能量的结果。例如，输出必须看起来像 $[\\,[a_1,a_2,a_3],\\,[b_1,b_2,b_3],\\,[c_1,c_2,c_3]\\,]$，每个条目都是一个四舍五入到六位小数的浮点数。\n\n角度单位不适用。所有物理能量必须以 $\\mathrm{eV}$ 为单位处理和报告，吸收输出是无量纲的（任意单位）。您的程序必须是独立自足的，无需输入，并且仅打印所需的单行输出。不允许访问外部文件或网络。", "solution": "所提出的问题是固态物理学中一个定义明确的计算练习，具体涉及根据电子能带结构计算光学性质。它具有科学依据，逻辑一致，并提供了所有必要的参数和定义。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n主导固体中光吸收的基本原理是费米黄金定则。对于零温下的直接带间跃迁，此时价带完全被占据，导带为空，吸收系数 $\\alpha$ 作为光子能量 $E_\\gamma$ 的函数，与联合态密度成正比，并由跃迁概率加权。在独立粒子近似中，这表示为在第一布里渊区 (BZ) 上的积分：\n$$\n\\alpha(E_\\gamma) \\propto \\int_{\\text{BZ}} d^3k \\, \\lvert M(\\mathbf{k}) \\rvert^2 \\, \\delta(E_c(\\mathbf{k}) - E_v(\\mathbf{k}) - E_\\gamma)\n$$\n在这里，$E_c(\\mathbf{k})$ 和 $E_v(\\mathbf{k})$ 分别是导带和价带的能量色散关系。$\\lvert M(\\mathbf{k}) \\rvert^2$ 是光学跃迁矩阵元的平方，它量化了在给定晶体动量 $\\mathbf{k}$ 下发生跃迁的概率。狄拉克δ函数 $\\delta(E)$ 强制执行能量守恒原理，确保只有当光子能量 $E_\\gamma$ 精确匹配最终和初始电子态之间的能量差时，光子才被吸收。\n\n对于基于密度泛函理论 (DFT) 计算结果的数值计算，该计算在离散的 $k$ 点网格上提供能量，此积分近似为一个加权和：\n$$\n\\alpha(E_\\gamma) \\propto \\sum_{i} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta(E_c(k_i) - E_v(k_i) - E_\\gamma)\n$$\n其中，求和遍历BZ样本中的离散k点 $k_i$，$w_i$ 是相应的权重，且 $\\sum_i w_i = 1$。\n\n对于离散数值评估，狄拉克δ函数在数学上是有问题的。因此，标准做法是用一个展宽函数来替换它，以模拟有限寿命效应并获得连续谱。问题为此指定了一个归一化高斯函数：\n$$\n\\delta(x) \\rightarrow \\delta_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\n其中 $\\sigma$ 是展宽参数，对应于高斯函数的标准差。\n\n此外，众所周知，标准的DFT计算，特别是使用局域或半局域交换关联泛函的计算，会系统性地低估电子带隙。一种常见且简单的修正是应用“剪刀算符”，即对所有导带态施加一个刚性、均匀的能量位移 $\\Delta$：\n$$\nE_c(k_i) \\rightarrow E_c^{\\text{sc}}(k_i) = E_c(k_i) + \\Delta\n$$\n此过程在修正基本带隙的同时，保留了导带的形状。\n\n结合这些组成部分，我们得到问题陈述中指定的计算吸收谱的最终表达式。对于给定的光子能量 $E_\\gamma$、剪刀修正 $\\Delta$ 和展宽宽度 $\\sigma$，吸收计算如下：\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) = \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta_\\sigma( (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma )\n$$\n代入高斯函数 $\\delta_\\sigma$ 的定义，用于实现的精确公式为：\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) = \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{( (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma )^2}{2\\sigma^2}\\right)\n$$\n提供的代码将实现此公式，以评估三个指定测试案例的吸收。每个光子能量的计算涉及：\n$1$. 将剪刀位移 $\\Delta$ 应用于导带能量 $E_c(k_i)$。\n$2$. 对于每个 $k$ 点 $k_i$，计算高斯函数的跃迁能量差参数：$x_i = (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma$。\n$3$. 评估高斯函数 $\\delta_\\sigma(x_i)$。\n$4$. 用相应的k点权重 $w_i$ 和矩阵元平方 $\\lvert M(k_i) \\rvert^2$ 对每个高斯值进行加权。\n$5$. 将所有 $k$ 点的贡献相加，得到总吸收值。\n\n此过程将对每个测试案例中的每个指定光子能量重复进行，结果将按要求收集和格式化。该实现将使用 `numpy` 库进行高效的基于数组的计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optical absorption spectrum for a direct-gap semiconductor\n    using Fermi's golden rule with a scissor operator and Gaussian broadening.\n    \"\"\"\n\n    # Data from the problem statement\n    # k-point weights [w_0, w_1, w_2, w_3, w_4]\n    k_weights = np.array([0.1, 0.2, 0.4, 0.2, 0.1])\n    # Valence band energies [E_v(k_i)] in eV\n    Ev = np.array([-0.10, -0.02, 0.00, -0.02, -0.10])\n    # Conduction band energies [E_c(k_i)] in eV\n    Ec = np.array([2.10, 1.95, 1.80, 1.95, 2.10])\n    # Squared optical matrix elements [|M(k_i)|^2] in arbitrary units\n    M_sq = np.array([0.5, 1.0, 2.0, 1.0, 0.5])\n\n    # Test suite: (Delta, sigma, photon_energies)\n    test_cases = [\n        (0.0, 0.05, [1.8, 2.0, 2.2]),  # Case 1\n        (0.5, 0.01, [1.8, 2.0, 2.2]),  # Case 2\n        (0.2, 0.05, [2.0, 2.2, 2.4]),  # Case 3\n    ]\n\n    all_results = []\n\n    def calculate_absorption(delta, sigma, photon_energies):\n        \"\"\"\n        Calculates absorption for a set of parameters.\n\n        Args:\n            delta (float): Scissor operator shift in eV.\n            sigma (float): Gaussian broadening width in eV.\n            photon_energies (list of float): Photon energies to evaluate in eV.\n\n        Returns:\n            list of float: Calculated absorption values, rounded.\n        \"\"\"\n        results_for_case = []\n        if sigma <= 0:\n            # Avoid division by zero if sigma is not positive\n            return [0.0] * len(photon_energies)\n\n        # Apply scissor operator to the conduction band\n        Ec_scissored = Ec + delta\n\n        # Pre-calculate transition energies\n        transition_energies = Ec_scissored - Ev\n\n        # Pre-calculate the constant part of the Gaussian normalization\n        gaussian_norm = 1.0 / (sigma * np.sqrt(2 * np.pi))\n\n        for E_gamma in photon_energies:\n            # Calculate the argument of the exponential for all k-points\n            x = transition_energies - E_gamma\n            # Calculate the Gaussian broadening for all k-points\n            gaussian_values = gaussian_norm * np.exp(-(x**2) / (2 * sigma**2))\n\n            # Calculate the contribution of each k-point to the absorption\n            contributions = k_weights * M_sq * gaussian_values\n\n            # Sum contributions to get total absorption\n            total_absorption = np.sum(contributions)\n            results_for_case.append(round(total_absorption, 6))\n\n        return results_for_case\n\n    for delta, sigma, photon_energies in test_cases:\n        case_results = calculate_absorption(delta, sigma, photon_energies)\n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # The list comprehension and str.join create the inner lists '[r1,r2,r3]'.\n    # A second str.join combines them into the final output.\n    inner_lists = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(inner_lists)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2484915"}]}