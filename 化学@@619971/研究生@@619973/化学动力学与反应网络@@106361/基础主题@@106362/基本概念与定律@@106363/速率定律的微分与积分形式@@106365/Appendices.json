{"hands_on_practices": [{"introduction": "本练习旨在培养从微分速率定律推导积分速率定律的核心技能，并加深您对反应级数的概念理解。您将证明一个双分子反应 $A + B \\to P$ 在起始浓度相等的特殊条件下，其数学形式为何等同于一个更简单的二级反应 $2A \\to P$。这项实践强调了初始条件、化学计量和最终动力学形式之间的关键联系 [@problem_id:2638982]。", "problem": "在一个等温、混合良好的恒容间歇式反应器中，进行着一个不可逆的基元反应 $A + B \\to P$。该反应遵循质量作用定律。在时间 $t=0$ 时，各物种浓度满足 $C_{A}(0)=C_{B}(0)\\equiv C_{0}$ 且 $C_{P}(0)=0$。请仅使用间歇式反应器的微分物种衡算、化学计量关系以及基元反应的质量作用定律，推导出 $C_{A}(t)$ 的显式积分浓度-时间关系式。\n\n然后，解释为何在初始浓度相等的这一特殊情况下，所得到的积分浓度-时间关系式与基元二聚反应 $2A \\to P$（当其速率常数根据 A 的消耗速率定义时）所得到的关系式具有相同的函数形式。\n\n请将最终结果以一个关于 $1/C_{A}(t)$ 的显式方程形式给出，该方程用 $k$、$t$ 和 $C_{0}$ 表示。无需进行数值计算。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 反应器：等温、混合良好的恒容间歇式反应器。\n- 反应：$A + B \\to P$，不可逆基元反应。\n- 速率定律原则：遵循质量作用定律。\n- 初始条件：在时间 $t=0$ 时，浓度为 $C_{A}(0)=C_{B}(0)\\equiv C_{0}$ 且 $C_{P}(0)=0$。\n- 任务 1：仅使用微分物种衡算、化学计量关系和质量作用定律，推导 $C_{A}(t)$ 的显式积分浓度-时间关系式。\n- 任务 2：解释为何结果与基元二聚反应 $2A \\to P$ 的结果具有相同的函数形式。\n- 最终答案格式：一个关于 $1/C_{A}(t)$ 的显式方程，用 $k$、$t$ 和 $C_{0}$ 表示。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它涉及理想反应器中基元反应的化学动力学基本原理（质量作用定律、反应化学计量、物料衡算）。问题提法恰当，提供了推导唯一解所需的所有信息（$A + B \\to P$、基元反应、$C_A(0) = C_B(0) = C_0$）。语言客观、精确。该问题不违反任何无效标准；它是化学反应工程中的一个标准、可形式化的问题。\n\n**步骤 3：结论与行动**\n问题有效。将提供解答。\n\n推导过程如下。\n\n对于基元反应 $A + B \\to P$，质量作用定律指出反应速率 $r$ 由下式给出：\n$$ r = k C_A C_B $$\n其中 $k$ 是速率常数，$C_A$ 和 $C_B$ 分别是物种 A 和 B 的摩尔浓度。\n\n对于恒容间歇式反应器，反应物 A 的微分物种衡算为：\n$$ \\frac{dC_A}{dt} = \\nu_A r $$\n其中 $\\nu_A$ 是 A 的化学计量系数。对于反应 $A + B \\to P$，反应物 A 的化学计量系数为 $\\nu_A = -1$。因此，A 的浓度变化率为：\n$$ \\frac{dC_A}{dt} = -r = -k C_A C_B $$\n同样可以写出物种 B 的衡算式，其 $\\nu_B = -1$：\n$$ \\frac{dC_B}{dt} = -r = -k C_A C_B $$\n从这两个方程可以明显看出 $\\frac{dC_A}{dt} = \\frac{dC_B}{dt}$。对此关系式对时间进行积分，得到：\n$$ C_A(t) - C_A(0) = C_B(t) - C_B(0) $$\n题目指定了初始条件 $C_A(0) = C_B(0) \\equiv C_0$。将此代入上式可得：\n$$ C_A(t) - C_0 = C_B(t) - C_0 $$\n这可以简化为在所有时间 $t \\ge 0$ 内都有 $C_A(t) = C_B(t)$。这个化学计量约束是初始浓度相等和反应物之间 1:1 化学计量比的直接结果。\n\n利用这个关系，我们可以将 $C_B = C_A$ 代入物种 A 的微分速率方程中：\n$$ \\frac{dC_A}{dt} = -k C_A(t) C_A(t) = -k C_A^2(t) $$\n这是一个可分离变量的一阶常微分方程。我们重新整理各项以分离变量 $C_A$ 和 $t$：\n$$ \\frac{dC_A}{C_A^2} = -k dt $$\n为了求得积分形式，我们对等式两边进行积分。A 的浓度从时间 $t=0$ 时的初始值 $C_A(0) = C_0$ 变化到任意时间 $t$ 时的值 $C_A(t)$。\n$$ \\int_{C_0}^{C_A(t)} \\frac{1}{C_A^2} dC_A = \\int_0^t -k dt $$\n积分计算如下：\n$$ \\left[ -\\frac{1}{C_A} \\right]_{C_0}^{C_A(t)} = \\left[ -kt \\right]_0^t $$\n计算定积分在上下限处的值，得到：\n$$ \\left( -\\frac{1}{C_A(t)} \\right) - \\left( -\\frac{1}{C_0} \\right) = (-kt) - (-k \\cdot 0) $$\n$$ -\\frac{1}{C_A(t)} + \\frac{1}{C_0} = -kt $$\n按照要求，重新整理此方程以解出 $1/C_A(t)$，我们得到最终的积分速率定律：\n$$ \\frac{1}{C_A(t)} = \\frac{1}{C_0} + kt $$\n该方程描述了物种 A 的浓度随时间变化的函数关系。\n\n现在，我们必须解决问题的第二部分：解释其与二聚反应 $2A \\to P$ 在函数形式上的等价性。\n\n考虑基元反应 $2A \\to P$。问题陈述中指出，速率常数是根据 A 的消耗速率定义的。物种 A 的消耗速率为 $-\\frac{dC_A}{dt}$。根据该基元步骤的质量作用定律，消耗速率与反应物 A 的浓度乘以其化学计量系数（即 2）的幂成正比。\n$$ -\\frac{dC_A}{dt} = k C_A^2 $$\n这可以重写为：\n$$ \\frac{dC_A}{dt} = -k C_A^2 $$\n这个微分方程与我们在 $C_A(0) = C_B(0)$ 的特殊条件下为反应 $A + B \\to P$ 推导出的方程在数学上是完全相同的。\n\n对此等价性的解释如下。在反应 $A + B \\to P$ 中，速率由 A 分子和 B 分子之间的有效碰撞频率决定，该频率与它们的浓度乘积 $C_A C_B$ 成正比。特殊的初始条件 $C_A(0) = C_B(0)$ 和 1:1 的反应化学计量比确保了在整个反应过程中 $C_A(t)$ 始终等于 $C_B(t)$。因此，速率定律 $r = k C_A C_B$ 简化为 $r = k C_A C_A = k C_A^2$。$A+B$ 的反应速率实际上变得仅依赖于 A 浓度的平方。在二聚反应 $2A \\to P$ 的情况下，速率由两个 A 分子之间的有效碰撞频率决定，该频率内在地与 $C_A^2$ 成正比。因为两种反应情景都导出了相同的微分速率表达式 $\\frac{dC_A}{dt} = -k C_A^2$，并且都从初始浓度 $C_A(0)=C_0$ 开始，所以它们的积分浓度-时间关系式必然具有相同的函数形式。尽管潜在的化学事件不同（A 与 B 碰撞 vs. A 与 A 碰撞），但在指定的约束条件下，其动力学的数学描述是相同的。", "answer": "$$\\boxed{\\frac{1}{C_A(t)} = \\frac{1}{C_0} + kt}$$", "id": "2638982"}, {"introduction": "在基本积分技术的基础上，本问题将探索自催化反应的动力学，即产物加速其自身生成的过程。您将推导出著名的逻辑斯蒂增长方程（logistic growth equation），这是一个广泛应用于从化学到种群生物学等众多领域的模型。这项实践将增强您分析更复杂反应体系的能力，并理解简单的反应规则如何导致诸如自催化特有的S形曲线等复杂的非线性行为 [@problem_id:2638960]。", "problem": "一个恒容恒密度、良好混合的等温间歇反应器中含有物种 $A$ 和 $B$，它们正在进行自催化反应 $A + B \\to 2B$。反应速率由 $r = k\\,C_A\\,C_B$ 给出，其中 $k$ 是速率常数。设 $t=0$ 时的初始浓度为 $C_{A0}>0$ 和 $C_{B0}>0$，并假设 $0<C_{B0}<C_{A0}+C_{B0}$。用 $C_A(t)$ 和 $C_B(t)$ 表示浓度作为时间 $t$ 的函数。\n\n仅从间歇反应器中反应速率和组分衡算的定义以及反应的化学计量关系出发，完成以下任务：\n- 证明 $C_A(t)+C_B(t)$ 不随时间变化，并将此常数表示为 $C_T$。\n- 推导仅由化学计量关系和 $r=k\\,C_A\\,C_B$ 得出的关于 $C_B(t)$ 的常微分方程(ODE)。\n- 对该ODE进行积分，以获得用 $k$、$C_T$、$C_{B0}$ 和 $t$ 表示的 $C_B(t)$ 的显式闭式表达式。\n\n最后，使用你推导出的解，确定 $C_B(t)$ 首次达到值 $C_T/2$ 时的时间 $t_{1/2}$ 的精确符号表达式。将最终时间以秒表示。你的最终答案必须是仅用 $k$、$C_T$ 和 $C_{B0}$ 表示的单个闭式符号表达式。不要提供方程；只提供表达式。在你的最终方框答案中不要包含任何单位。", "solution": "首先对问题陈述进行验证。\n\n逐字提取给定条件：\n- 系统：一个恒容恒密度、良好混合的等温间歇反应器。\n- 反应：$A + B \\to 2B$。\n- 速率定律：$r = k\\,C_A\\,C_B$。\n- $t=0$ 时的初始浓度：$C_{A0}>0$ 和 $C_{B0}>0$。\n- 约束条件：$0<C_{B0}<C_{A0}+C_{B0}$。\n- 符号：$C_A(t)$、$C_B(t)$ 是浓度。\n- 任务：\n  1. 证明 $C_A(t)+C_B(t)$ 不随时间变化。\n  2. 推导关于 $C_B(t)$ 的常微分方程。\n  3. 对常微分方程积分，得到 $C_B(t)$ 的显式表达式。\n  4. 求出 $C_B(t) = C_T/2$ 时的时间 $t_{1/2}$。\n- 最终答案格式：一个仅用 $k$、$C_T$ 和 $C_{B0}$ 表示的关于 $t_{1/2}$ 的单个闭式符号表达式。\n\n验证结论：\n该问题有效。它以化学动力学原理为科学基础，具体描述了理想间歇反应器中的一个标准自催化反应。该问题提法规范，提供了清晰的反应方案、速率定律、初始条件以及一系列可导向唯一且有意义解的目标。所有术语都客观且定义精确。这是一个反应动力学专题下的标准、可形式化的问题，不存在所列出的缺陷。我们开始求解。\n\n对于反应 $A + B \\to 2B$，考虑到摩尔数的净变化，其化学计量系数为 $\\nu_A = -1$ 和 $\\nu_B = +1$。对于恒容间歇反应器，物种 $i$ 的物料衡算由 $\\frac{dC_i}{dt} = \\nu_i r$ 给出。\n\n首先，我们证明浓度之和 $C_A(t) + C_B(t)$ 的不变性。物种 $A$ 和 $B$ 的组分衡算方程为：\n$$\n\\frac{dC_A}{dt} = \\nu_A r = (-1) r = -k C_A C_B\n$$\n$$\n\\frac{dC_B}{dt} = \\nu_B r = (+1) r = k C_A C_B\n$$\n我们考察和 $C_A + C_B$ 对时间的导数：\n$$\n\\frac{d}{dt}(C_A + C_B) = \\frac{dC_A}{dt} + \\frac{dC_B}{dt} = (-k C_A C_B) + (k C_A C_B) = 0\n$$\n由于时间导数为零，和 $C_A(t) + C_B(t)$ 在所有时间 $t \\ge 0$ 内是一个常数。我们将此常数表示为 $C_T$。该常数由初始条件确定：\n$$\nC_T = C_A(t) + C_B(t) = C_A(0) + C_B(0) = C_{A0} + C_{B0}\n$$\n这完成了第一项任务。\n\n其次，我们推导关于 $C_B(t)$ 的常微分方程(ODE)。根据不变关系，我们将 $C_A(t)$ 用 $C_B(t)$ 和 $C_T$ 表示：\n$$\nC_A(t) = C_T - C_B(t)\n$$\n将此式代入 $C_B$ 的速率方程，得到所需的 ODE：\n$$\n\\frac{dC_B}{dt} = k C_A C_B = k (C_T - C_B) C_B\n$$\n这是关于物种 $B$ 浓度的逻辑斯蒂微分方程。这完成了第二项任务。\n\n第三，我们对该 ODE 进行积分，以求得 $C_B(t)$ 的显式表达式。该方程是可分离变量的：\n$$\n\\frac{dC_B}{C_B (C_T - C_B)} = k \\, dt\n$$\n为对左侧进行积分，我们使用部分分式分解：\n$$\n\\frac{1}{C_B (C_T - C_B)} = \\frac{X}{C_B} + \\frac{Y}{C_T - C_B}\n$$\n这得到 $1 = X(C_T - C_B) + Y C_B$。令 $C_B=0$ 得 $1 = X C_T$，所以 $X = \\frac{1}{C_T}$。令 $C_B=C_T$ 得 $1 = Y C_T$，所以 $Y = \\frac{1}{C_T}$。分解结果为：\n$$\n\\frac{1}{C_B (C_T - C_B)} = \\frac{1}{C_T} \\left( \\frac{1}{C_B} + \\frac{1}{C_T - C_B} \\right)\n$$\n我们现在对微分方程从初始状态 $(t=0, C_B=C_{B0})$ 积分到状态 $(t, C_B(t))$：\n$$\n\\int_{C_{B0}}^{C_B(t)} \\frac{1}{C_T} \\left( \\frac{1}{C'_B} + \\frac{1}{C_T - C'_B} \\right) dC'_B = \\int_{0}^{t} k \\, dt'\n$$\n积分得出：\n$$\n\\frac{1}{C_T} \\left[ \\ln(C'_B) - \\ln(C_T - C'_B) \\right]_{C_{B0}}^{C_B(t)} = k [t']_{0}^{t}\n$$\n请注意，由于 $C_B(t)$ 从 $C_{B0}$ 单调增加至 $C_T$，在有限时间内 $C_B$ 和 $C_T - C_B$ 均为正值，因此不需要绝对值符号。\n$$\n\\frac{1}{C_T} \\left[ \\ln\\left(\\frac{C_B(t)}{C_T - C_B(t)}\\right) - \\ln\\left(\\frac{C_{B0}}{C_T - C_{B0}}\\right) \\right] = kt\n$$\n$$\n\\ln\\left( \\frac{C_B(t) (C_T - C_{B0})}{C_{B0} (C_T - C_B(t))} \\right) = k C_T t\n$$\n对两边取指数，得到：\n$$\n\\frac{C_B(t) (C_T - C_{B0})}{C_{B0} (C_T - C_B(t))} = \\exp(k C_T t)\n$$\n現在我们求解 $C_B(t)$：\n$$\nC_B(t) (C_T - C_{B0}) = C_{B0} (C_T - C_B(t)) \\exp(k C_T t)\n$$\n$$\nC_B(t) (C_T - C_{B0}) = C_{B0} C_T \\exp(k C_T t) - C_B(t) C_{B0} \\exp(k C_T t)\n$$\n$$\nC_B(t) \\left[ (C_T - C_{B0}) + C_{B0} \\exp(k C_T t) \\right] = C_{B0} C_T \\exp(k C_T t)\n$$\n$$\nC_B(t) = \\frac{C_{B0} C_T \\exp(k C_T t)}{(C_T - C_{B0}) + C_{B0} \\exp(k C_T t)}\n$$\n将分子和分母同除以 $C_{B0} \\exp(k C_T t)$，可得到一个更标准的形式：\n$$\nC_B(t) = \\frac{C_T}{\\frac{C_T - C_{B0}}{C_{B0}} \\exp(-k C_T t) + 1} = \\frac{C_T}{1 + \\left(\\frac{C_T}{C_{B0}} - 1\\right)\\exp(-k C_T t)}\n$$\n这就是所要求的 $C_B(t)$ 的显式闭式表达式。这完成了第三项任务。\n\n最后，我们确定 $C_B(t_{1/2}) = \\frac{C_T}{2}$ 时的时间 $t_{1/2}$。我们将 $C_B(t)$ 的表达式设为该值：\n$$\n\\frac{C_T}{2} = \\frac{C_T}{1 + \\left(\\frac{C_T - C_{B0}}{C_{B0}}\\right)\\exp(-k C_T t_{1/2})}\n$$\n假设 $C_T \\neq 0$（由于 $C_{A0}>0, C_{B0}>0$，这一点是保证的），我们可以简化为：\n$$\n2 = 1 + \\left(\\frac{C_T - C_{B0}}{C_{B0}}\\right)\\exp(-k C_T t_{1/2})\n$$\n$$\n1 = \\left(\\frac{C_T - C_{B0}}{C_{B0}}\\right)\\exp(-k C_T t_{1/2})\n$$\n$$\n\\exp(-k C_T t_{1/2}) = \\frac{C_{B0}}{C_T - C_{B0}}\n$$\n对两边取自然对数：\n$$\n-k C_T t_{1/2} = \\ln\\left(\\frac{C_{B0}}{C_T - C_{B0}}\\right)\n$$\n利用属性 $\\ln(1/x) = -\\ln(x)$：\n$$\nk C_T t_{1/2} = \\ln\\left(\\frac{C_T - C_{B0}}{C_{B0}}\\right)\n$$\n解出 $t_{1/2}$：\n$$\nt_{1/2} = \\frac{1}{k C_T} \\ln\\left(\\frac{C_T - C_{B0}}{C_{B0}}\\right)\n$$\n为使 $t_{1/2}$ 是一个正的、物理上有意义的时间，对数的参数必须大于 $1$，这要求 $C_T - C_{B0} > C_{B0}$，即 $C_T > 2C_{B0}$。这意味着 $C_{A0} + C_{B0} > 2C_{B0}$，简化后为 $C_{A0} > C_{B0}$。问题要求的是 $C_B(t)$ *首次达到* $C_T/2$ 的时间，这意味着要存在一个有意义的正时间，初始条件必须满足 $C_{B0}  C_T/2$。在这一隐含的物理假设下，推导出的表达式是正确答案。提及的“以秒为单位”仅指明了时间的物理量纲，对符号推导没有影响。", "answer": "$$\n\\boxed{\\frac{1}{k C_T} \\ln\\left(\\frac{C_T - C_{B0}}{C_{B0}}\\right)}\n$$", "id": "2638960"}, {"introduction": "最后的这项实践旨在弥合理论模型与实验现实之间的鸿沟。在实际研究中，速率常数 $k$ 等参数并非已知，而必须从含有噪声的测量数据中进行估计。这个计算练习将指导您使用加权最小二乘法（WLS）将积分速率定律拟合到合成数据上，这是现代数据分析的基石。通过完成此任务，您将获得参数估计的动手经验，并掌握量化这些估计值不确定性的基本技能 [@problem_id:2660532]。", "problem": "给定物种$A$的浓度遵循常微分方程 $d[A]/dt = -k[A]$（初始条件为 $[A](0) = [A]_0$）的单步、不可逆、一级衰变反应的动态模型。在离散时间点上对浓度进行测量，这些测量值受到独立加性噪声的干扰。目标是通过在高斯噪声模型下使用加权最小二乘法（WLS）将积分速率方程与数据进行拟合，来估计参数矢量 $\\theta = ([A]_0, k)$，并计算该估计量的近似协方差矩阵。\n\n基本原理和假设：\n- 确定性动力学由一级过程的质量作用定律控制。测量模型为 $y_i = [A](t_i) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_i^2)$ 且对于不同的$i$是相互独立的。\n- 自变量是时间 $t$（单位：秒），可观测浓度 $[A]$ 的单位是摩尔/升。\n- 在所述假设下，最大似然估计量与WLS估计量一致，其中权重为 $w_i = 1/\\sigma_i^2$。\n\n您的程序必须为每个测试用例执行以下任务：\n1. 从基本速率定律和初始条件出发，推导 $[A](t)$ 作为 $[A]_0$ 和 $k$ 的函数表达式。\n2. 构建由已知方差 $\\sigma_i^2$ 的高斯噪声模型所隐含的WLS目标函数。通过最小化该目标函数来估计 $\\theta = ([A]_0, k)$，约束条件为 $[A]_0 > 0$ 和 $k > 0$。\n3. 使用与WLS公式一致的一阶（高斯-牛顿）近似，在最优解处计算近似协方差矩阵 $\\mathrm{Cov}(\\hat{\\theta})$。报告 $\\mathrm{Var}([A]_0)$、$\\mathrm{Var}(k)$ 和 $\\mathrm{Cov}([A]_0,k)$ 这几项。\n4. 实现一个数值稳定的求解器，该求解器能强制$[A]_0$和$k$为正值，并在构建近似时使用模型关于参数的解析正确的敏感度（雅可比矩阵）。\n5. 使用下方的精确测试套件，包括指定的伪随机种子来生成合成观测值 $y_i$，并使用给定的已知标准差 $\\sigma_i$ 来定义WLS权重。\n\n使用的物理和数值单位：\n- 报告 $[A]_0$ 的单位为 $\\mathrm{mol\\,L^{-1}}$，$k$ 的单位为 $\\mathrm{s^{-1}}$。方差和协方差必须使用相应的平方和混合单位。\n- 最终程序输出必须是不带单位符号的数值；但是，所有计算都必须使用规定的单位进行。\n\n测试套件（三个数据集）。对于每个数据集 $j \\in \\{1,2,3\\}$：\n- 使用 $y_i^{(j)} = [A]_0^{\\mathrm{true}(j)} \\exp(-k^{\\mathrm{true}(j)} t_i^{(j)}) + \\varepsilon_i^{(j)}$ 生成合成观测值，其中 $\\varepsilon_i^{(j)} \\sim \\mathcal{N}(0, (\\sigma_i^{(j)})^2)$，且相互独立。对每个数据集使用指定的种子初始化伪随机数生成器，以使生成的 $y_i^{(j)}$ 具有确定性和可复现性。\n\n数据集 $1$ （理想情况，同方差）：\n- 真实参数：$[A]_0^{\\mathrm{true}(1)} = 1.25\\,\\mathrm{mol\\,L^{-1}}$，$k^{\\mathrm{true}(1)} = 0.0075\\,\\mathrm{s^{-1}}$。\n- 时间点（单位：秒）：$t^{(1)} = (0, 50, 100, 150, 200, 250, 300)$。\n- 已知标准差（单位：$\\mathrm{mol\\,L^{-1}}$）：对于所有 $i$, $\\sigma_i^{(1)} \\equiv 0.02$。\n- 种子：$314159$。\n\n数据集 $2$ （噪声随时间增大的异方差情况）：\n- 真实参数：$[A]_0^{\\mathrm{true}(2)} = 0.8\\,\\mathrm{mol\\,L^{-1}}$，$k^{\\mathrm{true}(2)} = 0.01\\,\\mathrm{s^{-1}}$。\n- 时间点（单位：秒）：$t^{(2)} = (0, 40, 80, 120, 160, 200, 240, 280, 320)$。\n- 已知标准差（单位：$\\mathrm{mol\\,L^{-1}}$）：$\\sigma_i^{(2)} = 0.01 + 0.00005\\, t_i^{(2)}$。\n- 种子：$271828$。\n\n数据集 $3$ （在短时间窗口内关于$k$的信息较弱的边界情况）：\n- 真实参数：$[A]_0^{\\mathrm{true}(3)} = 1.0\\,\\mathrm{mol\\,L^{-1}}$，$k^{\\mathrm{true}(3)} = 0.001\\,\\mathrm{s^{-1}}$。\n- 时间点（单位：秒）：$t^{(3)} = (0, 5, 10, 15, 20, 25, 30)$。\n- 已知标准差（单位：$\\mathrm{mol\\,L^{-1}}$）：对于所有 $i$, $\\sigma_i^{(3)} \\equiv 0.005$。\n- 种子：$161803$。\n\n算法要求：\n- 使用带有WLS残差的非线性最小二乘求解器。向求解器提供模型关于 $[A]_0$ 和 $k$ 的解析雅可比矩阵。强制执行边界条件 $[A]_0 > 0$ 和 $k > 0$。\n- 在最优解处，使用与WLS权重和已知$\\sigma_i$的高斯假设一致的一阶信息近似来计算近似协方差矩阵。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个数据集的拼接结果，并严格按照\n$[$$\\hat{[A]}_0^{(1)}$, $\\hat{k}^{(1)}$, $\\mathrm{Var}^{(1)}([A]_0)$, $\\mathrm{Var}^{(1)}(k)$, $\\mathrm{Cov}^{(1)}([A]_0,k)$, $\\hat{[A]}_0^{(2)}$, $\\hat{k}^{(2)}$, $\\mathrm{Var}^{(2)}([A]_0)$, $\\mathrm{Var}^{(2)}(k)$, $\\mathrm{Cov}^{(2)}([A]_0,k)$, $\\hat{[A]}_0^{(3)}$, $\\hat{k}^{(3)}$, $\\mathrm{Var}^{(3)}([A]_0)$, $\\mathrm{Var}^{(3)}(k)$, $\\mathrm{Cov}^{(3)}([A]_0,k)$$]$的顺序排列，不含空格。\n- 每个数值必须四舍五入到小数点后恰好$6$位。\n- 不涉及角度。所有量均为实值浮点数。\n\n您的程序必须是完整且可直接运行的，无需任何外部输入，并且必须严格遵守指定的输出格式。唯一允许使用的库是Python标准库、NumPy和SciPy。", "solution": "所给出的问题是化学动力学中动态系统参数估计的一个标准练习。它具有科学依据，问题适定，并包含了获得确定性且可验证解所需的所有信息。因此，该问题被认为是有效的。\n\n解决方案主要分为四个步骤：\n1. 从控制微分方程推导解析模型。\n2. 构建用于参数估计的加权最小二乘（WLS）目标函数。\n3. 为优化算法推导解析雅可比矩阵。\n4. 构建参数协方差矩阵的近似公式。\n\n**1. 积分速率方程**\n\n问题始于一级不可逆衰变过程的基本速率定律：\n$$\n\\frac{d[A]}{dt} = -k[A]\n$$\n这是一个一阶线性常微分方程。我们使用分离变量法，并根据初始条件 $[A](t=0) = [A]_0$ 来求解。\n$$\n\\frac{d[A]}{[A]} = -k \\, dt\n$$\n对两边从初始状态 $([A]_0, 0)$ 积分到状态 $([A], t)$ 得到：\n$$\n\\int_{[A]_0}^{[A]} \\frac{1}{[A]'} \\, d[A]' = \\int_0^t -k \\, dt'\n$$\n$$\n\\ln([A]) - \\ln([A]_0) = -k(t - 0)\n$$\n$$\n\\ln\\left(\\frac{[A]}{[A]_0}\\right) = -kt\n$$\n对两边取指数，得到积分速率方程，这就是我们在时间 $t$ 时物种 $A$ 浓度的模型函数：\n$$\n[A](t) = [A]_0 e^{-kt}\n$$\n该函数我们记为 $f(t; \\theta)$，它依赖于参数矢量 $\\theta = ([A]_0, k)^T$。\n\n**2. 加权最小二乘（WLS）公式**\n\n在时间 $t_i$ 的测量值 $y_i$ 被建模为 $y_i = f(t_i; \\theta) + \\varepsilon_i$，其中误差项 $\\varepsilon_i$ 是独立且服从正态分布的，$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)$，具有已知方差 $\\sigma_i^2$。在这些假设下，$\\theta$ 的最大似然估计量是最小化加权残差平方和的那个估计量。这就是加权最小二乘（WLS）估计量。\n\nWLS目标函数 $S(\\theta)$ 由下式给出：\n$$\nS(\\theta) = \\sum_{i=1}^{N} \\left( \\frac{y_i - f(t_i; \\theta)}{\\sigma_i} \\right)^2 = \\sum_{i=1}^{N} \\left( \\frac{y_i - [A]_0 e^{-kt_i}}{\\sigma_i} \\right)^2\n$$\n其中 $N$ 是观测点的数量。我们寻求能最小化该函数并满足物理约束条件 $[A]_0 > 0$ 和 $k > 0$ 的参数值 $\\hat{\\theta} = (\\hat{[A]}_0, \\hat{k})^T$。\n\n**3. 非线性优化与解析雅可比矩阵**\n\n最小化 $S(\\theta)$ 是一个非线性最小二乘问题。我们采用一个数值求解器，具体是 `scipy.optimize.least_squares`，它非常适合该任务。通过提供残差向量关于参数的解析雅可比矩阵，可以大大提高求解器的效率和可靠性。\n\n求解器最小化一个向量函数的平方和。设该向量函数为 $\\mathbf{r}_w(\\theta)$，即加权残差向量，其第$i$个分量为：\n$$\nr_{w,i}(\\theta) = \\frac{f(t_i; \\theta) - y_i}{\\sigma_i} = \\frac{[A]_0 e^{-kt_i} - y_i}{\\sigma_i}\n$$\n雅可比矩阵 $J_w$ 是一个 $N \\times 2$ 的矩阵，其中 $(J_w)_{ij} = \\frac{\\partial r_{w,i}}{\\partial \\theta_j}$。这两列对应于关于 $[A]_0$ 和 $k$ 的偏导数。\n\n对于第一个参数 $[A]_0$：\n$$\n\\frac{\\partial r_{w,i}}{\\partial [A]_0} = \\frac{1}{\\sigma_i} \\frac{\\partial}{\\partial [A]_0} \\left( [A]_0 e^{-kt_i} - y_i \\right) = \\frac{e^{-kt_i}}{\\sigma_i}\n$$\n对于第二个参数 $k$：\n$$\n\\frac{\\partial r_{w,i}}{\\partial k} = \\frac{1}{\\sigma_i} \\frac{\\partial}{\\partial k} \\left( [A]_0 e^{-kt_i} - y_i \\right) = \\frac{[A]_0}{\\sigma_i} \\frac{\\partial}{\\partial k} \\left( e^{-kt_i} \\right) = \\frac{[A]_0}{\\sigma_i} \\left( -t_i e^{-kt_i} \\right) = -\\frac{[A]_0 t_i e^{-kt_i}}{\\sigma_i}\n$$\n这些偏导数表达式构成了提供给优化程序的雅可比矩阵的列。\n\n**4. 估计量的协方差矩阵**\n\n估计参数 $\\hat{\\theta}$ 的不确定性由其协方差矩阵 $\\mathrm{Cov}(\\hat{\\theta})$ 来表征。对于非线性最小二乘问题，一个常用且有效的近似方法源自高斯-牛顿法。该近似将协方差矩阵与费雪信息矩阵的逆联系起来，而费雪信息矩阵本身则通过在解 $\\hat{\\theta}$ 处计算的 $J_w^T J_w$ 来近似。\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\approx \\left( J_w(\\hat{\\theta})^T J_w(\\hat{\\theta}) \\right)^{-1}\n$$\n这个 $2 \\times 2$ 矩阵的对角线元素是估计量的方差，非对角线元素是它们之间的协方差：\n$$\n\\mathrm{Cov}(\\hat{\\theta}) = \\begin{pmatrix} \\mathrm{Var}(\\hat{[A]}_0)  \\mathrm{Cov}(\\hat{[A]}_0, \\hat{k}) \\\\ \\mathrm{Cov}(\\hat{[A]}_0, \\hat{k})  \\mathrm{Var}(\\hat{k}) \\end{pmatrix}\n$$\n`scipy.optimize.least_squares` 函数能方便地返回在最终参数估计值处计算的雅可比矩阵 $J_w$，从而可以直接计算该协方差矩阵。\n\n实现将精确地遵循这些推导过程。对于每个数据集，使用提供的真实参数和带种子的随机数生成器来生成合成数据，以确保可复现性。然后执行WLS优化以找到 $\\hat{[A]}_0$ 和 $\\hat{k}$，随后计算所需的方差和协方差项。", "answer": "```python\n# Final runnable Python code for the specified environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves for the parameters of a first-order decay model for three\n    different datasets using Weighted Least Squares and computes the\n    covariance matrix of the estimators.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Dataset 1\",\n            \"true_params\": [1.25, 0.0075], # [A0_true, k_true]\n            \"times\": np.array([0., 50., 100., 150., 200., 250., 300.]),\n            \"sigma\": lambda t: np.full_like(t, 0.02),\n            \"seed\": 314159\n        },\n        {\n            \"name\": \"Dataset 2\",\n            \"true_params\": [0.8, 0.01],\n            \"times\": np.array([0., 40., 80., 120., 160., 200., 240., 280., 320.]),\n            \"sigma\": lambda t: 0.01 + 0.00005 * t,\n            \"seed\": 271828\n        },\n        {\n            \"name\": \"Dataset 3\",\n            \"true_params\": [1.0, 0.001],\n            \"times\": np.array([0., 5., 10., 15., 20., 25., 30.]),\n            \"sigma\": lambda t: np.full_like(t, 0.005),\n            \"seed\": 161803\n        }\n    ]\n\n    # --- Model and Objective Function Definitions ---\n\n    def model(params, t_vals):\n        \"\"\"\n        Calculates concentration based on first-order decay model.\n        params: [A0, k]\n        \"\"\"\n        A0, k = params\n        return A0 * np.exp(-k * t_vals)\n\n    def residuals_wls(params, t_vals, y_obs, sigma_vals):\n        \"\"\"\n        Calculates weighted residuals for WLS fitting.\n        (model - y) / sigma\n        \"\"\"\n        return (model(params, t_vals) - y_obs) / sigma_vals\n\n    def jacobian_wls(params, t_vals, y_obs, sigma_vals):\n        \"\"\"\n        Calculates the analytical Jacobian of the weighted residuals.\n        \"\"\"\n        A0, k = params\n        jac = np.zeros((len(t_vals), 2))\n        exp_term = np.exp(-k * t_vals)\n        \n        # d(residual)/d(A0) = (1/sigma) * d(model)/d(A0)\n        jac[:, 0] = exp_term / sigma_vals\n        \n        # d(residual)/d(k) = (1/sigma) * d(model)/d(k)\n        jac[:, 1] = -A0 * t_vals * exp_term / sigma_vals\n        \n        return jac\n\n    all_results = []\n    \n    for case in test_cases:\n        A0_true, k_true = case[\"true_params\"]\n        t = case[\"times\"]\n        seed = case[\"seed\"]\n        sigma = case[\"sigma\"](t)\n        \n        # 1. Generate synthetic data\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, sigma)\n        y_obs = model([A0_true, k_true], t) + noise\n        \n        # 2. Perform nonlinear least-squares optimization\n        # Use true parameters as initial guess for robust convergence in this test setup\n        initial_guess = case[\"true_params\"]\n        # Enforce positivity constraints [A0  0, k  0]\n        bounds = ([1e-9, 1e-9], [np.inf, np.inf])\n        \n        lsq_result = least_squares(\n            residuals_wls,\n            x0=initial_guess,\n            jac=jacobian_wls,\n            bounds=bounds,\n            method='trf',\n            args=(t, y_obs, sigma)\n        )\n        \n        A0_est, k_est = lsq_result.x\n        \n        # 3. Compute the approximate covariance matrix\n        # Cov(theta) approx (J^T J)^-1, where J is Jacobian of weighted residuals\n        J = lsq_result.jac\n        try:\n            cov_matrix = np.linalg.inv(J.T @ J)\n            var_A0 = cov_matrix[0, 0]\n            var_k = cov_matrix[1, 1]\n            cov_A0_k = cov_matrix[0, 1]\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix is singular (e.g., poor data)\n            var_A0, var_k, cov_A0_k = (np.inf, np.inf, np.inf)\n\n        # 4. Store the results in the required order\n        all_results.extend([A0_est, k_est, var_A0, var_k, cov_A0_k])\n\n    # 5. Format and print the final output string\n    # E.g. [1.249123,0.007505,...]\n    output_str = \",\".join([f\"{val:.6f}\" for val in all_results])\n    print(f\"[{output_str}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2660532"}]}