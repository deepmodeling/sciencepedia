{"hands_on_practices": [{"introduction": "首先，我们将探索弛豫实验中热力学与可观测信号之间的基本联系。这个练习 [@problem_id:2669895] 将指导你推导温度跃变后吸光度变化的振幅。掌握这一计算至关重要，因为它揭示了信号的强度如何由反应焓 ($\\Delta H^\\circ$) 以及反应物和产物摩尔吸光系数的差异所决定，为分析T-jump数据提供了定量基础。", "problem": "考虑一个在理想溶液中，初始温度为 $T_0$ 的可逆基元异构化反应 $A \\rightleftharpoons B$，其平衡常数为 $K(T) \\equiv \\frac{c_B^{\\mathrm{eq}}}{c_A^{\\mathrm{eq}}}$。总分析浓度为 $c_T = c_A + c_B$，在固定探测波长下的光吸收度遵循比尔-朗伯定律 $A = \\ell\\left(\\varepsilon_A c_A + \\varepsilon_B c_B\\right)$，其中 $\\ell$ 是光程长度，$\\varepsilon_A, \\varepsilon_B$ 分别是 A 和 B 的摩尔吸光系数。在 $t=0$ 时，施加一个大小为 $\\Delta T$ 的瞬时温度跃升（temperature-jump），该过程相对于反应弛豫而言非常快，因此在 $t=0^+$ 时浓度保持不变，但速率常数（以及 $K$）变为其在 $T_0+\\Delta T$ 时的值。假设活度等于浓度，标准反应焓 $\\Delta H^\\circ$ 在温度跃升范围内不随温度变化，并且摩尔吸光系数在温度跃升范围内也不随温度变化。\n\n1) 仅从质量守恒、平衡常数的定义、比尔-朗伯定律和范特霍夫关系式 $\\frac{d\\ln K}{dT}=\\frac{\\Delta H^\\circ}{R\\,T^2}$（其中 $R$ 是普适气体常数）出发，推导吸收度弛豫的带符号振幅的表达式。该振幅定义为温度跃升后新旧平衡吸收度之差，其形式应为一个关于 A 的摩尔分数的灵敏度因子乘以 $t=0^+$ 时的瞬时平衡组成偏移。请用 $K(T_0)$ 和 $K(T_0+\\Delta T)$ 表示组成偏移，并用 $K(T_0)$、$\\Delta H^\\circ$、$T_0$ 和 $\\Delta T$ 表示 $K(T_0+\\Delta T)$，且不对 $\\ln K$ 进行线性化。\n\n2) 对以下参数数值计算振幅：$T_0 = 298.0\\ \\mathrm{K}$，$\\Delta T = 5.00\\ \\mathrm{K}$，$K(T_0)=3.00$，$\\Delta H^\\circ = +45.0\\times 10^3\\ \\mathrm{J\\,mol^{-1}}$，$R=8.314462618\\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}$，$c_T=1.50\\times 10^{-3}\\ \\mathrm{M}$，$\\ell=1.000\\ \\mathrm{cm}$，$\\varepsilon_A = 8.000\\times 10^3\\ \\mathrm{M^{-1}\\,cm^{-1}}$，以及 $\\varepsilon_B = 1.200\\times 10^4\\ \\mathrm{M^{-1}\\,cm^{-1}}$。以吸收度单位（无量纲）报告吸收度振幅的最终数值。将答案四舍五入至四位有效数字。", "solution": "首先验证问题的科学合理性、一致性和完整性。问题陈述描述了一个标准的温度跃升弛豫动力学实验。它基于化学动力学、热力学（范特霍夫方程）和光谱学（比尔-朗伯定律）的基本原理。所有必要的参数都已提供，并且所作的假设（理想溶液、在小温度范围内 $\\Delta H^\\circ$ 和摩尔吸光系数恒定）在这种情况下是物理上合理的和标准的。该问题提法恰当、客观且有科学依据。因此，该问题被认为是有效的，并将构建解答。\n\n第1部分：吸收度振幅表达式的推导\n\n溶液的总吸收度 $A$ 由比尔-朗伯定律给出：\n$$A = \\ell \\left( \\varepsilon_A c_A + \\varepsilon_B c_B \\right)$$\n其中 $\\ell$ 是光程长度，$\\varepsilon_i$ 是摩尔吸光系数，$c_i$ 是物种 $i \\in \\{A, B\\}$ 的浓度。\n质量守恒要求总浓度 $c_T = c_A + c_B$ 是恒定的。我们可以用物种 A 的摩尔分数 $x_A = \\frac{c_A}{c_T}$ 和总浓度 $c_T$ 来表示各个浓度。\n$$c_A = x_A c_T$$\n$$c_B = (1-x_A) c_T$$\n将这些代入比尔-朗伯定律，得到吸收度作为 $x_A$ 函数的表达式：\n$$A(x_A) = \\ell c_T \\left( \\varepsilon_A (x_A c_T) + \\varepsilon_B ((1-x_A) c_T) \\right)$$\n$$A(x_A) = \\ell c_T \\left( \\varepsilon_A x_A + \\varepsilon_B - \\varepsilon_B x_A \\right)$$\n$$A(x_A) = \\ell c_T \\left( (\\varepsilon_A - \\varepsilon_B) x_A + \\varepsilon_B \\right)$$\n吸收度弛豫的带符号振幅 $\\Delta A_{\\text{amp}}$ 定义为最终平衡吸收度（在温度 $T_f = T_0 + \\Delta T$ 时）与初始平衡吸收度（在温度 $T_0$ 时）之差。设 $x_{A,0}^{\\text{eq}}$ 和 $x_{A,f}^{\\text{eq}}$ 分别是 A 在 $T_0$ 和 $T_f$ 时的平衡摩尔分数。\n$$A_{\\text{old}}^{\\text{eq}} = A(x_{A,0}^{\\text{eq}}) = \\ell c_T \\left( (\\varepsilon_A - \\varepsilon_B) x_{A,0}^{\\text{eq}} + \\varepsilon_B \\right)$$\n$$A_{\\text{new}}^{\\text{eq}} = A(x_{A,f}^{\\text{eq}}) = \\ell c_T \\left( (\\varepsilon_A - \\varepsilon_B) x_{A,f}^{\\text{eq}} + \\varepsilon_B \\right)$$\n振幅是它们的差值：\n$$\\Delta A_{\\text{amp}} = A_{\\text{new}}^{\\text{eq}} - A_{\\text{old}}^{\\text{eq}} = \\ell c_T (\\varepsilon_A - \\varepsilon_B) \\left( x_{A,f}^{\\text{eq}} - x_{A,0}^{\\text{eq}} \\right)$$\n此表达式符合所要求的形式。关于 A 的摩尔分数的“灵敏度因子”是吸收度对 $x_A$ 的导数，即 $\\frac{\\partial A}{\\partial x_A} = \\ell c_T (\\varepsilon_A - \\varepsilon_B)$。“组成偏移”是平衡摩尔分数的变化量，$\\Delta x_A^{\\text{eq}} = x_{A,f}^{\\text{eq}} - x_{A,0}^{\\text{eq}}$。\n\n接下来，我们用平衡常数来表示组成偏移。平衡常数为 $K = \\frac{c_B^{\\text{eq}}}{c_A^{\\text{eq}}} = \\frac{x_B^{\\text{eq}}}{x_A^{\\text{eq}}} = \\frac{1-x_A^{\\text{eq}}}{x_A^{\\text{eq}}}$。\n求解 $x_A^{\\text{eq}}$ 可得 $K x_A^{\\text{eq}} = 1 - x_A^{\\text{eq}}$，整理后为 $(K+1)x_A^{\\text{eq}} = 1$，因此 $x_A^{\\text{eq}} = \\frac{1}{K+1}$。\n设 $K_0 = K(T_0)$ 和 $K_f = K(T_f) = K(T_0 + \\Delta T)$。摩尔分数为：\n$$x_{A,0}^{\\text{eq}} = \\frac{1}{K_0+1} \\quad \\text{和} \\quad x_{A,f}^{\\text{eq}} = \\frac{1}{K_f+1}$$\n因此，组成偏移为：\n$$\\Delta x_A^{\\text{eq}} = \\frac{1}{K_f+1} - \\frac{1}{K_0+1}$$\n\n最后，我们必须使用范特霍夫关系式 $\\frac{d\\ln K}{dT}=\\frac{\\Delta H^\\circ}{R\\,T^2}$ 将 $K_f$ 与 $K_0$ 联系起来。假设 $\\Delta H^\\circ$ 在此区间内为常数，对此方程从 $T_0$ 到 $T_f$ 进行积分：\n$$\\int_{K_0}^{K_f} d\\ln K = \\int_{T_0}^{T_f} \\frac{\\Delta H^\\circ}{R\\,T^2} dT$$\n$$\\ln K_f - \\ln K_0 = \\frac{\\Delta H^\\circ}{R} \\left[ -\\frac{1}{T} \\right]_{T_0}^{T_f}$$\n$$\\ln\\left(\\frac{K_f}{K_0}\\right) = \\frac{\\Delta H^\\circ}{R} \\left( -\\frac{1}{T_f} + \\frac{1}{T_0} \\right) = \\frac{\\Delta H^\\circ}{R} \\left( \\frac{T_f - T_0}{T_0 T_f} \\right)$$\n代入 $T_f = T_0 + \\Delta T$ 可得：\n$$\\ln\\left(\\frac{K_f}{K_0}\\right) = \\frac{\\Delta H^\\circ}{R} \\left( \\frac{\\Delta T}{T_0 (T_0 + \\Delta T)} \\right)$$\n对两边取指数，得到 $K_f$ 的表达式：\n$$K_f = K_0 \\exp\\left( \\frac{\\Delta H^\\circ}{R} \\frac{\\Delta T}{T_0 (T_0 + \\Delta T)} \\right)$$\n结合这些结果，吸收度振幅的最终表达式为：\n$$\\Delta A_{\\text{amp}} = \\ell c_T (\\varepsilon_A - \\varepsilon_B) \\left( \\frac{1}{K_f+1} - \\frac{1}{K_0+1} \\right)$$\n其中 $K_f$ 如上定义。推导至此完成。\n\n第2部分：数值计算\n\n给定以下参数：\n$T_0 = 298.0\\ \\mathrm{K}$\n$\\Delta T = 5.00\\ \\mathrm{K}$\n$K_0 = K(T_0) = 3.00$\n$\\Delta H^\\circ = 45.0 \\times 10^3\\ \\mathrm{J\\,mol^{-1}}$\n$R = 8.314462618\\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n$c_T = 1.50 \\times 10^{-3}\\ \\mathrm{M}$\n$\\ell = 1.000\\ \\mathrm{cm}$\n$\\varepsilon_A = 8.000 \\times 10^3\\ \\mathrm{M^{-1}\\,cm^{-1}}$\n$\\varepsilon_B = 1.200 \\times 10^4\\ \\mathrm{M^{-1}\\,cm^{-1}}$\n\n首先，计算新温度 $T_f$：\n$$T_f = T_0 + \\Delta T = 298.0\\ \\mathrm{K} + 5.00\\ \\mathrm{K} = 303.0\\ \\mathrm{K}$$\n接下来，计算 $K_f$ 的指数部分的参数：\n$$ \\frac{\\Delta H^\\circ}{R} \\frac{\\Delta T}{T_0 T_f} = \\frac{45.0 \\times 10^3\\ \\mathrm{J\\,mol^{-1}}}{8.314462618\\ \\mathrm{J\\,mol^{-1}\\,K^{-1}}} \\frac{5.00\\ \\mathrm{K}}{(298.0\\ \\mathrm{K})(303.0\\ \\mathrm{K})} \\approx 0.2996906 $$\n现在，计算新的平衡常数 $K_f$：\n$$K_f = (3.00) \\exp(0.2996906) \\approx (3.00)(1.34944) \\approx 4.04832$$\n接下来，计算 A 的初始和最终平衡摩尔分数：\n$$x_{A,0}^{\\text{eq}} = \\frac{1}{K_0+1} = \\frac{1}{3.00+1} = \\frac{1}{4} = 0.25$$\n$$x_{A,f}^{\\text{eq}} = \\frac{1}{K_f+1} = \\frac{1}{4.04832+1} = \\frac{1}{5.04832} \\approx 0.198085$$\n组成偏移为：\n$$\\Delta x_A^{\\text{eq}} = x_{A,f}^{\\text{eq}} - x_{A,0}^{\\text{eq}} \\approx 0.198085 - 0.25 = -0.051915$$\n现在，计算灵敏度因子：\n$$\\ell c_T (\\varepsilon_A - \\varepsilon_B) = (1.000\\ \\mathrm{cm})(1.50 \\times 10^{-3}\\ \\mathrm{M})(8.000 \\times 10^3 - 1.200 \\times 10^4)\\ \\mathrm{M^{-1}\\,cm^{-1}}$$\n$$ = (1.50 \\times 10^{-3})(-4.000 \\times 10^3) = -6.00$$\n最后，计算吸收度振幅：\n$$\\Delta A_{\\text{amp}} = (-6.00) \\times (-0.051915) \\approx 0.31149$$\n将结果四舍五入到四位有效数字，得到 $0.3115$。正号表示吸收度增加，这与一个吸热反应（$\\Delta H^\\circ > 0$）在温度升高时向 B 物种（其摩尔吸光系数更高，$\\varepsilon_B > \\varepsilon_A$）移动的趋势是一致的。", "answer": "$$\n\\boxed{0.3115}\n$$", "id": "2669895"}, {"introduction": "在理解了弛豫振幅的来源之后，我们现在转向一个实际问题：温度跃变是如何产生的？这个问题 [@problem_id:2669948] 深入探讨了实验装置，特别是一种利用电阻焦耳热的常用方法。通过应用能量守恒原理，你将计算出产生目标温升所需的电流，从而对T-jump系统的实验设计考量获得宝贵的见解。", "problem": "一台电阻温度跃变（T-jump）装置用于扰动水相微体积中一个快速可逆反应的平衡，以便监测其弛豫回平衡的过程。该装置通过样品中浸入的电阻路径施加一个矩形电流脉冲。假设在脉冲期间存在以下理想化条件：(i) 电流 $I$ 和电阻 $R$ 恒定；(ii) 所有以热量形式耗散的电能都均匀沉积在样品中；(iii) 向环境的热量损失可忽略不计；(iv) 在微小的温升范围内，溶液的比热容 $c_p$ 和密度 $\\rho$ 保持恒定；(v) 在脉冲期间没有发生相变或反应焓的贡献。\n\n样品是在初始温度下的水溶液，体积为 $V = 20.0 \\ \\mu\\mathrm{L}$，密度为 $\\rho = 1.00 \\ \\mathrm{g \\ mL^{-1}}$，比热容为 $c_p = 4.18 \\ \\mathrm{J \\ g^{-1} \\ K^{-1}}$。通过样品池的电流路径的有效电阻为 $R = 5.00 \\ \\Omega$。施加一个持续时间为 $\\Delta t = 5.00 \\ \\mu\\mathrm{s}$ 的矩形电流脉冲。目标温升为 $\\Delta T_{\\mathrm{target}} = 10.0 \\ \\mathrm{K}$。\n\n仅从能量守恒、焦耳热和宏观热容的定义出发，推导连接温升 $\\Delta T$ 与 $I$、$R$、$\\Delta t$、$m$ 和 $c_p$ 之间的关系式，然后确定在给定条件下实现目标温升 $\\Delta T_{\\mathrm{target}}$ 所需的电流幅值 $I$。将最终数值结果四舍五入至三位有效数字。以 A 为单位表示电流。", "solution": "所述问题经判定为有效。该问题在科学上是合理的，其基础是能量守恒、焦耳热和量热学的基本原理。问题提法明确，提供了推导唯一且有意义的解所需的所有数据和约束条件。问题客观且无歧义。因此，我们着手求解。\n\n控制此过程的主要原理是能量守恒。问题指明，所有以热量形式耗散的电能都均匀沉积在样品中，并且向环境的热量损失可以忽略不计。因此，电流脉冲提供的电能 $E_{\\mathrm{elec}}$ 必须等于引起样品温度升高的吸收热量 $Q$。\n$$E_{\\mathrm{elec}} = Q$$\n电能是电功率 $P$ 和脉冲持续时间 $\\Delta t$ 的乘积。根据焦耳热定律，对于流经恒定电阻 $R$ 的恒定电流 $I$，耗散的功率为：\n$$P = I^{2}R$$\n因此，在时间间隔 $\\Delta t$ 内耗散的总电能为：\n$$E_{\\mathrm{elec}} = P \\Delta t = I^{2}R \\Delta t$$\n样品吸收的热量由量热学原​​理描述。对于一个质量为 $m$、比热容 $c_p$ 在整个温度区间内恒定的样品，产生温度变化 $\\Delta T$ 所需的热量由下式给出：\n$$Q = m c_p \\Delta T$$\n通过令耗散的电能等于吸收的热量，我们得到问题所要求的关系式：\n$$I^{2}R \\Delta t = m c_p \\Delta T$$\n该方程将温升 $\\Delta T$ 与电流 $I$、电阻 $R$、脉冲持续时间 $\\Delta t$、样品质量 $m$ 和比热容 $c_p$ 联系起来。\n\n为了求解实现目标温升 $\\Delta T_{\\mathrm{target}}$ 所需的电流幅值 $I$，我们必须重新整理此表达式：\n$$I^{2} = \\frac{m c_p \\Delta T}{R \\Delta t}$$\n$$I = \\sqrt{\\frac{m c_p \\Delta T}{R \\Delta t}}$$\n溶液的质量 $m$ 没有直接给出。它必须根据给定的体积 $V$ 和密度 $\\rho$ 计算得出：\n$$m = \\rho V$$\n将此代入电流 $I$ 的方程中，可得到用于计算的完整表达式：\n$$I = \\sqrt{\\frac{\\rho V c_p \\Delta T}{R \\Delta t}}$$\n给定以下数值：\n-   样品体积 $V = 20.0 \\ \\mu\\mathrm{L}$\n-   密度 $\\rho = 1.00 \\ \\mathrm{g \\ mL^{-1}}$\n-   比热容 $c_p = 4.18 \\ \\mathrm{J \\ g^{-1} \\ K^{-1}}$\n-   电阻 $R = 5.00 \\ \\Omega$\n-   脉冲持续时间 $\\Delta t = 5.00 \\ \\mu\\mathrm{s}$\n-   目标温升 $\\Delta T = \\Delta T_{\\mathrm{target}} = 10.0 \\ \\mathrm{K}$\n\n必须使用一套一致的单位。我们将使用克（$\\mathrm{g}$）作为质量单位，秒（$\\mathrm{s}$）作为时间单位，焦耳（$\\mathrm{J}$）作为能量单位，开尔文（$\\mathrm{K}$）作为温度单位，欧姆（$\\Omega$）作为电阻单位进行计算。这些单位是兼容的，因为 $1 \\ \\mathrm{J} = 1 \\ \\mathrm{A}^{2} \\cdot \\Omega \\cdot \\mathrm{s}$。\n\n首先，我们计算水溶液的质量 $m$。我们必须将体积单位从微升（$\\mu\\mathrm{L}$）转换为毫升（$\\mathrm{mL}$），以与密度的单位保持一致。\n$$V = 20.0 \\ \\mu\\mathrm{L} = 20.0 \\times 10^{-3} \\ \\mathrm{mL} = 0.0200 \\ \\mathrm{mL}$$\n$$m = \\rho V = (1.00 \\ \\mathrm{g \\ mL^{-1}}) \\times (0.0200 \\ \\mathrm{mL}) = 0.0200 \\ \\mathrm{g}$$\n脉冲持续时间必须从微秒（$\\mu\\mathrm{s}$）转换为秒（$\\mathrm{s}$）：\n$$\\Delta t = 5.00 \\ \\mu\\mathrm{s} = 5.00 \\times 10^{-6} \\ \\mathrm{s}$$\n现在我们将所有数值代入 $I$ 的表达式中：\n$$I = \\sqrt{\\frac{(0.0200 \\ \\mathrm{g}) \\times (4.18 \\ \\mathrm{J \\ g^{-1} \\ K^{-1}}) \\times (10.0 \\ \\mathrm{K})}{(5.00 \\ \\Omega) \\times (5.00 \\times 10^{-6} \\ \\mathrm{s})}}$$\n让我们分别计算分子（所需热量）和分母。\n所需的热量为：\n$$Q = m c_p \\Delta T = (0.0200) \\times (4.18) \\times (10.0) \\ \\mathrm{J} = 0.836 \\ \\mathrm{J}$$\n分母中的项为：\n$$R \\Delta t = (5.00 \\ \\Omega) \\times (5.00 \\times 10^{-6} \\ \\mathrm{s}) = 25.0 \\times 10^{-6} \\ \\Omega \\cdot \\mathrm{s} = 2.50 \\times 10^{-5} \\ \\Omega \\cdot \\mathrm{s}$$\n那么电流的平方就是这两个量的比值：\n$$I^{2} = \\frac{0.836 \\ \\mathrm{J}}{2.50 \\times 10^{-5} \\ \\Omega \\cdot \\mathrm{s}} = 33440 \\ \\mathrm{A}^{2}$$\n取平方根即可得到电流的幅值：\n$$I = \\sqrt{33440} \\ \\mathrm{A} \\approx 182.86606 \\ \\mathrm{A}$$\n问题要求将最终数值结果四舍五入至三位有效数字。\n$$I \\approx 183 \\ \\mathrm{A}$$\n这是一个相当大的电流，这对于在导电介质中产生快速温升是预料之中的。", "answer": "$$\\boxed{183}$$", "id": "2669948"}, {"introduction": "任何动力学实验中，最后也最关键的一步是分析采集到的数据。这个基于编程的练习 [@problem_id:2669947] 旨在解决一个真实世界中的挑战：如何解释可能包含多个重叠动力学过程的、充满噪声的弛豫信号。你将实现并比较多种强大的统计方法——如AIC、BIC和交叉验证——来确定指数分量的正确数量，这是揭示潜在反应机理的核心任务。", "problem": "给定一个建模和模型选择任务，该任务基于温度跃迁 (T-jump) 扰动后的化学弛豫动力学。在平衡态附近受到一个微小扰动时，反应网络在其稳态附近的线性化表明，某个可观测量会以解耦的指数模式之和的形式进行弛豫。在时间 $t$ 发生的这种弛豫的数据集可以建模为\n$$\ny(t) = C + \\sum_{i=1}^{m} A_i \\exp\\!\\left(-\\frac{t}{\\tau_i}\\right) + \\varepsilon(t),\n$$\n其中，$m$ 是模型阶数（指数模式的数量），$A_i$ 是实数振幅，$\\tau_i \\gt 0$ 是以秒为单位的弛豫时间常数，$C$ 是恒定基线，$\\varepsilon(t)$ 是均值为零、方差为 $\\sigma^2$ 的独立同分布高斯噪声。\n\n您的任务是使用高斯噪声下的最大似然、赤池信息准则 (AIC)、贝叶斯信息准则 (BIC) 和 K 折交叉验证 (CV)，在单指数、双指数和三指数模型之间实现有原则的模型选择。您必须通过对每个候选阶数 $m \\in \\{1,2,3\\}$ 显式地拟合非线性最小二乘问题，并从第一性原理计算选择准则来完成此任务。\n\n在整个过程中，假设如下：\n- 噪声 $\\varepsilon(t)$ 是均值为零、恒定方差为 $\\sigma^2$（未知）的高斯噪声。\n- 高斯噪声下的最大似然估计等同于最小化残差平方和\n$$\n\\mathrm{RSS}_m = \\sum_{j=1}^{n} \\left[y_j - \\left(C + \\sum_{i=1}^{m} A_i \\exp\\!\\left(-\\frac{t_j}{\\tau_i}\\right)\\right)\\right]^2,\n$$\n其中 $(t_j, y_j)$ 是 $n$ 个测量数据点。\n- 对于模型阶数 $m$，拟合参数的数量为 $p_m = 2m + 1$（$m$ 个振幅、$m$ 个时间常数和偏移量 $C$）。为使用信息准则进行模型比较，采用标准的最小二乘代理来表示负对数似然：\n$$\n-2 \\log \\hat{L}_m = n \\log\\!\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + \\text{constant},\n$$\n这样，准则之间的差异就不会受到加法常数的影响。\n- 将模型 $m$ 的赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC) 定义为\n$$\n\\mathrm{AIC}_m = n \\log\\!\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + 2 p_m, \\qquad\n\\mathrm{BIC}_m = n \\log\\!\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + p_m \\log n.\n$$\n- 对于 K 折交叉验证，使用 $K = 5$ 折，使用等于 $42$ 的固定种子将 $n$ 个索引伪随机地划分为 $K$ 折，并将交叉验证的均方预测误差定义为在每个留出折上的均方误差在所有折上的平均值。在每一折中，仅在训练子集上拟合模型，并在验证子集上评估均方预测误差。\n- 选择规则：对于每个准则（AIC、BIC、CV），选择使该准则最小化的模型阶数 $m$。如果两个或多个模型的准则值与该准则的最小值之差在容差 $\\epsilon = 10^{-9}$ 以内，则选择较小的 $m$。\n\n为下面包含三个已知真实情况（时间单位为秒，信号单位为任意一致单位）的合成 T-jump 数据集的测试套件实现以上步骤。对于每个数据集，从 $t = 0$ 到 $t = T_{\\max}$（含边界）生成 $n$ 个均匀间隔的时间点，使用给定的真实参数模拟无噪声信号，并添加具有指定标准差 $\\sigma$ 的独立高斯噪声：\n- 数据集 1（真实情况为单指数）：$n = 200$，$T_{\\max} = 3.0$，$m^\\star = 1$，振幅 $[1.2]$，时间常数 $[0.5]$，偏移量 $C = 0.0$，噪声标准差 $\\sigma = 0.02$。\n- 数据集 2（真实情况为双指数）：$n = 300$，$T_{\\max} = 2.0$，$m^\\star = 2$，振幅 $[0.6, 0.4]$，时间常数 $[0.1, 1.0]$，偏移量 $C = 0.05$，噪声标准差 $\\sigma = 0.02$。\n- 数据集 3（真实情况为三指数）：$n = 400$，$T_{\\max} = 3.0$，$m^\\star = 3$，振幅 $[0.5, 0.3, 0.2]$，时间常数 $[0.02, 0.2, 2.0]$，偏移量 $C = -0.1$，噪声标准差 $\\sigma = 0.01$。\n\n所有表示时间的模拟量单位必须是秒。所有对数均为自然对数。如果出现任何角度，单位必须是弧度。输出中的任何量都不应写成百分比；如果出现任何比例，必须表示为小数或分数。\n\n最终输出规范：\n- 对于顺序为 $1,2,3$ 的每个数据集，根据上述定义的 AIC、BIC 和 $5$ 折 CV 计算所选的模型阶数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含 $9$ 个整数\n$$\n[\\text{AIC}_1,\\ \\text{BIC}_1,\\ \\text{CV}_1,\\ \\text{AIC}_2,\\ \\text{BIC}_2,\\ \\text{CV}_2,\\ \\text{AIC}_3,\\ \\text{BIC}_3,\\ \\text{CV}_3],\n$$\n例如，其中 $\\text{AIC}_2$ 是根据 AIC 为数据集 $2$ 选择的模型阶数。每个条目必须是整数 $1$、$2$ 或 $3$。", "solution": "该问题要求实现一个模型选择程序，以确定化学弛豫动力学模型中指数项的最佳数量。我们有三个候选模型，分别对应于 $m=1$、$m=2$ 和 $m=3$ 个指数衰减项之和，外加一个恒定偏移量。在时间 $t$ 观测到的信号 $y(t)$ 的模型为\n$$\ny(t) = C + \\sum_{i=1}^{m} A_i \\exp\\left(-\\frac{t}{\\tau_i}\\right) + \\varepsilon(t),\n$$\n其中，$C$ 是基线偏移量，$A_i$ 是振幅，$\\tau_i$ 是正的弛豫时间常数，$\\varepsilon(t)$ 代表均值为零的独立同分布高斯噪声。对于阶数为 $m$ 的模型，可估计的参数数量为 $p_m = 2m + 1$。\n\n主要任务是为每个模型阶数 $m \\in \\{1, 2, 3\\}$ 找到最优参数集 $\\{C, \\{A_i\\}_{i=1}^m, \\{\\tau_i\\}_{i=1}^m\\}$。高斯噪声下的最大似然原理要求通过最小化残差平方和 (RSS) 来找到这些参数：\n$$\n\\mathrm{RSS}_m = \\sum_{j=1}^{n} \\left[y_j - \\hat{y}_m(t_j)\\right]^2,\n$$\n其中 $\\{y_j\\}$ 是在时间 $\\{t_j\\}$ 观测到的 $n$ 个数据点，$\\hat{y}_m(t)$ 是阶数为 $m$ 的模型函数。这构成了一个非线性最小二乘优化问题。我们将通过 `scipy.optimize.curve_fit` 使用 Levenberg-Marquardt 算法来解决它。非线性拟合的成功在很大程度上取决于提供良好的初始参数猜测和具有物理动机的约束。我们将使用边界来强制执行约束 $\\tau_i > 0$。初始猜测将从数据的宏观特征中导出：基线 $C$ 根据长时间的信号估计，总振幅根据初始信号变化估计，时间常数 $\\tau_i$ 在测量时间窗口内呈对数分布。\n\n在为每个模型得到最小化的 $\\mathrm{RSS}_m$ 后，我们使用三种不同的准则进行模型选择。\n\n首先是赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC)。这些是信息论准则，旨在平衡拟合优度和模型复杂度。提供的公式如下：\n$$\n\\mathrm{AIC}_m = n \\log\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + 2 p_m\n$$\n$$\n\\mathrm{BIC}_m = n \\log\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + p_m \\log n\n$$\n与 AIC 相比，BIC 对额外参数施加了更强的惩罚，因为其惩罚项与数据点数量的对数 $\\log n$ 成比例。对于这两种准则，使准则值最小化的模型阶数 $m$ 被认为是最佳的。\n\n其次是 $K$ 折交叉验证 (CV)，其中 $K=5$。该方法可用于估计模型在未用于训练的数据上的预测性能。数据集被划分为 $K=5$ 个不相交的折。对于每一折，模型在其他 $K-1$ 折上进行训练，并在留出的那一折上计算其均方误差 (MSE)。一个模型的 CV 分数是这 $K$ 个折的 MSE 的平均值：\n$$\n\\mathrm{CV-MSE}_m = \\frac{1}{K} \\sum_{k=1}^{K} \\left( \\frac{1}{|S_k|} \\sum_{j \\in S_k} \\left[y_j - \\hat{y}_{m, -k}(t_j)\\right]^2 \\right)\n$$\n其中 $S_k$ 表示第 $k$ 折，$\\hat{y}_{m, -k}(t_j)$ 是在除第 $k$ 折之外的所有数据上训练的模型所做的预测。选择使这个平均预测误差最小化的模型阶数 $m$。为了确保可复现性，使用固定的随机种子 $42$ 进行分区。\n\n对所提供的三个数据集中的每一个，总体流程如下：\n1.  生成合成数据集：创建时间向量，使用给定参数计算真实信号，并添加具有指定标准差 $\\sigma$ 的高斯噪声。\n2.  对于每个模型阶数 $m \\in \\{1, 2, 3\\}$：\n    a. 将模型拟合到完整数据集以找到最佳拟合参数，然后计算 $\\mathrm{RSS}_m$。\n    b. 使用 $\\mathrm{RSS}_m$ 计算 $\\mathrm{AIC}_m$ 和 $\\mathrm{BIC}_m$。\n    c. 执行 $5$ 折交叉验证以计算 $\\mathrm{CV-MSE}_m$。\n3.  对于三个准则中的每一个，选择使相应分数最小化的模型阶数 $m$。如果多个模型的分数与最小值的差在容差 $\\epsilon = 10^{-9}$ 以内，则选择 $m$ 最小的那个。\n4.  最终输出是九个选定模型阶数的汇总（$3$ 个准则 $\\times$ $3$ 个数据集）。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements model selection for exponential decay models using AIC, BIC,\n    and K-fold cross-validation.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 200, \"T_max\": 3.0, \"m_true\": 1,\n            \"A_true\": [1.2], \"tau_true\": [0.5], \"C_true\": 0.0,\n            \"sigma\": 0.02, \"gen_seed\": 0\n        },\n        {\n            \"n\": 300, \"T_max\": 2.0, \"m_true\": 2,\n            \"A_true\": [0.6, 0.4], \"tau_true\": [0.1, 1.0], \"C_true\": 0.05,\n            \"sigma\": 0.02, \"gen_seed\": 1\n        },\n        {\n            \"n\": 400, \"T_max\": 3.0, \"m_true\": 3,\n            \"A_true\": [0.5, 0.3, 0.2], \"tau_true\": [0.02, 0.2, 2.0], \"C_true\": -0.1,\n            \"sigma\": 0.01, \"gen_seed\": 2\n        }\n    ]\n\n    def model_factory(m):\n        \"\"\"Creates a model function for a sum of m exponentials.\"\"\"\n        def model(t, *params):\n            C = params[0]\n            Amps = params[1:m+1]\n            Taus = params[m+1:2*m+1]\n            y = np.full_like(t, C, dtype=float)\n            for i in range(m):\n                y += Amps[i] * np.exp(-t / Taus[i])\n            return y\n        return model\n\n    def get_initial_params(m, t, y):\n        \"\"\"Generates initial parameter guesses for the optimizer.\"\"\"\n        C_guess = y[-1]\n        A_total_guess = y[0] - C_guess\n        A_guesses = [A_total_guess / m] * m\n        \n        t_max = t[-1]\n        t_step = t[1] - t[0] if len(t) > 1 else 0.01\n        if t_step = 0: t_step = 1e-4\n\n        if m == 1:\n            tau_guesses = [t_max / 3.0]\n        else:\n            # Distribute time constants logarithmically\n            tau_guesses = np.logspace(np.log10(t_step * 5), np.log10(t_max / 2), m).tolist()\n\n        return [C_guess] + A_guesses + tau_guesses\n\n    def get_bounds(m, t):\n        \"\"\"Generates parameter bounds for the optimizer.\"\"\"\n        t_max = t[-1]\n        lower_bounds = [-np.inf] + [-np.inf] * m + [1e-9] * m\n        upper_bounds = [np.inf] + [np.inf] * m + [t_max * 10] * m\n        return (lower_bounds, upper_bounds)\n\n    def select_best_model(scores, tolerance=1e-9):\n        \"\"\"Selects the best model order based on scores and a tie-breaking rule.\"\"\"\n        if not scores or all(s is None or np.isinf(s) for s in scores):\n            return -1  # Indicates failure for all models\n\n        valid_scores = [s for s in scores if s is not None and not np.isinf(s)]\n        if not valid_scores: return -1\n\n        min_score = min(valid_scores)\n        \n        candidate_ms = []\n        for i, score in enumerate(scores):\n            if score is not None and not np.isinf(score):\n                if score = min_score + tolerance:\n                    candidate_ms.append(i + 1)\n        \n        return min(candidate_ms) if candidate_ms else -1\n\n    all_results = []\n    \n    for case in test_cases:\n        n, T_max, m_true = case['n'], case['T_max'], case['m_true']\n        A_true, tau_true, C_true = case['A_true'], case['tau_true'], case['C_true']\n        sigma, gen_seed = case['sigma'], case['gen_seed']\n        \n        # --- Generate Data ---\n        t = np.linspace(0, T_max, n)\n        true_model_func = model_factory(m_true)\n        y_true = true_model_func(t, *([C_true] + A_true + tau_true))\n        rng_data = np.random.default_rng(gen_seed)\n        noise = rng_data.normal(loc=0.0, scale=sigma, size=n)\n        y_obs = y_true + noise\n\n        aic_scores, bic_scores, cv_scores = [], [], []\n\n        for m in [1, 2, 3]:\n            model_m = model_factory(m)\n            p0 = get_initial_params(m, t, y_obs)\n            bounds = get_bounds(m, t)\n            p_m = 2 * m + 1\n\n            # --- Full data fit for AIC/BIC ---\n            try:\n                popt, _ = curve_fit(model_m, t, y_obs, p0=p0, bounds=bounds, maxfev=10000, method='trf')\n                y_pred = model_m(t, *popt)\n                rss_m = np.sum((y_obs - y_pred)**2)\n                \n                if rss_m = 1e-12: # Avoid log(0) or instability\n                    aic_m = bic_m = np.inf\n                else:\n                    log_likelihood_term = n * np.log(rss_m / n)\n                    aic_m = log_likelihood_term + 2 * p_m\n                    bic_m = log_likelihood_term + p_m * np.log(n)\n            except (RuntimeError, ValueError):\n                aic_m = bic_m = np.inf\n            aic_scores.append(aic_m)\n            bic_scores.append(bic_m)\n\n            # --- 5-fold Cross-Validation ---\n            K = 5\n            rs_cv = np.random.RandomState(42)\n            indices = np.arange(n)\n            rs_cv.shuffle(indices)\n            folds = np.array_split(indices, K)\n            \n            fold_mses = []\n            fit_failed_in_cv = False\n            for val_idx in folds:\n                train_idx = np.setdiff1d(indices, val_idx, assume_unique=True)\n                \n                t_train, y_train = t[train_idx], y_obs[train_idx]\n                t_val, y_val = t[val_idx], y_obs[val_idx]\n\n                p0_cv = get_initial_params(m, t_train, y_train)\n                bounds_cv = get_bounds(m, t_train)\n\n                try:\n                    popt_cv, _ = curve_fit(model_m, t_train, y_train, p0=p0_cv, bounds=bounds_cv, maxfev=10000, method='trf')\n                    y_pred_val = model_m(t_val, *popt_cv)\n                    mse_k = np.mean((y_val - y_pred_val)**2)\n                    fold_mses.append(mse_k)\n                except (RuntimeError, ValueError):\n                    fit_failed_in_cv = True\n                    break\n            \n            cv_m = np.mean(fold_mses) if not fit_failed_in_cv else np.inf\n            cv_scores.append(cv_m)\n\n        # --- Select best model for this dataset ---\n        aic_choice = select_best_model(aic_scores)\n        bic_choice = select_best_model(bic_scores)\n        cv_choice = select_best_model(cv_scores)\n\n        all_results.extend([aic_choice, bic_choice, cv_choice])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2669947"}]}