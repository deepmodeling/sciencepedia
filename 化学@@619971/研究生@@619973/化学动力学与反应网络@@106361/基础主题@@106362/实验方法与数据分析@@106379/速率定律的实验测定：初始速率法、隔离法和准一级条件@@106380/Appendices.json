{"hands_on_practices": [{"introduction": "在收集任何数据之前，精心设计实验是至关重要的一步，这能确保我们最终能够回答我们的科学问题。本练习探讨了一个常见的陷阱——共线性，在这种情况下，糟糕的实验设计会使我们无法区分不同反应物的个体效应。通过本练习，您将学习如何使用线性代数来诊断这个问题，并理解正交设计（orthogonal design）如何提供一个强有力的解决方案，从而分离出反应级数 $α$ 和 $β$。[@problem_id:2642183]", "problem": "在一个等温、充分混合的间歇式反应器中，研究了物种 $A$ 和 $B$ 之间的一个均相、不可逆双分子反应。在转化率可忽略不计的初始瞬态阶段，观察到初始速率 $v_0$ 与初始浓度之间遵循幂律依赖关系，\n$$\nv_0 = k [A]_0^{\\alpha} [B]_0^{\\beta},\n$$\n其中 $k$ 是一个依赖于温度的速率系数，而 $\\alpha,\\beta$ 是有待通过实验确定的实值反应级数。为了从初始速率数据中估计 $\\alpha$ 和 $\\beta$，标准方法是使用不同的初始浓度 $\\{([A]_0^{(i)},[B]_0^{(i)})\\}_{i=1}^n$ 进行多次实验，并拟合通过取自然对数得到的对数线性模型：\n$$\n\\ln v_0^{(i)} = \\ln k + \\alpha \\ln [A]_0^{(i)} + \\beta \\ln [B]_0^{(i)} + \\varepsilon^{(i)},\n$$\n其中 $\\varepsilon^{(i)}$ 包含了实验误差。考虑到由于溶解度限制和使用了耦合的加料歧管，初始浓度被限制在一条曲线上，\n$$\n[B]_0^{(i)} = C \\left([A]_0^{(i)}\\right)^2 \\quad \\text{对所有实验 } i=1,\\dots,n,\n$$\n其中 $C>0$ 是一个固定的、已知的比例常数。你的目标是确定在该约束条件下，从收集到的初始速率数据中，速率方程的哪些方面是实验上可辨识的，并提出一种基于实验设计的补救措施，该措施利用初始速率法、隔离法或伪一级条件来恢复可辨识性。\n\n从初始速率法的定义和上述的对数线性化出发，分析在所述约束条件下，以 $\\ln [A]_0$ 和 $\\ln [B]_0$ 为预测变量的线性回归设计的结构。使用关于设计矩阵的线性代数论证，解释共线性是如何产生的，以及哪些参数组合变得不可辨识。然后，提出一种具体的补救措施，在 $\\ln [A]_0$ 和 $\\ln [B]_0$ 的空间中使用正交设计（例如，在编码后的对数浓度中采用两水平全因子设计，或采用通过中心化实现正交性的隔离法/伪一级方案），以恢复 $\\alpha$ 和 $\\beta$ 的可辨识性。描述这种设计如何消除设计矩阵中的共线性。\n\n你的最终答案必须是在受限设计 $[B]_0 = C [A]_0^2$ 下唯一保持可辨识的 $\\alpha$ 和 $\\beta$ 的线性组合，以仅包含 $\\alpha$ 和 $\\beta$ 的闭式解析表达式表示。最终答案中不要包含任何单位。如果需要进行任何数值近似，系统会告知您使用多少位有效数字；此处不需要进行数值近似。", "solution": "初始速率法假设，在间歇实验开始时的一个足够短的时间窗口内，浓度与其初始值相比没有发生显著变化。在此近似下，瞬时速率可以很好地由初始速率表示，\n$$\nv_0 = k [A]_0^{\\alpha} [B]_0^{\\beta},\n$$\n其中在固定温度下，所有实验的 $k$ 均为常数。取自然对数可得到一个以 $\\ln [A]_0$ 和 $\\ln [B]_0$ 为预测变量的线性回归模型，\n$$\n\\ln v_0 = \\ln k + \\alpha \\ln [A]_0 + \\beta \\ln [B]_0 + \\varepsilon,\n$$\n其中 $\\varepsilon$ 包含了测量噪声和任何残余模型偏差。\n\n让我们将 $n$ 次实验的模型写成矩阵形式。定义响应向量 $\\mathbf{y} \\in \\mathbb{R}^{n}$，其元素为 $y_i = \\ln v_0^{(i)}$；定义参数向量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^{3}$ 为\n$$\n\\boldsymbol{\\theta} = \\begin{pmatrix} \\ln k \\\\ \\alpha \\\\ \\beta \\end{pmatrix},\n$$\n并定义设计矩阵 $\\mathbf{X} \\in \\mathbb{R}^{n \\times 3}$，其列分别为截距项（全为1的列）、元素为 $x_{A,i} = \\ln [A]_0^{(i)}$ 的向量 $\\mathbf{x}_A$ 和元素为 $x_{B,i} = \\ln [B]_0^{(i)}$ 的向量 $\\mathbf{x}_B$。则\n$$\n\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}, \\quad \\mathbf{X} = \\begin{pmatrix} 1 & x_{A,1} & x_{B,1} \\\\ \\vdots & \\vdots & \\vdots \\\\ 1 & x_{A,n} & x_{B,n} \\end{pmatrix}.\n$$\n\n在对所有 $i$ 均成立的约束条件 $[B]_0^{(i)} = C \\left([A]_0^{(i)}\\right)^2$ 下，我们有\n$$\nx_{B,i} = \\ln [B]_0^{(i)} = \\ln C + 2 \\ln [A]_0^{(i)} = \\ln C + 2 x_{A,i}.\n$$\n因此，$\\mathbf{X}$ 的第三列是第一列和第二列的仿射组合。具体来说，\n$$\n\\mathbf{x}_B = (\\ln C)\\,\\mathbf{1} + 2\\,\\mathbf{x}_A,\n$$\n其中 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 表示截距列。因此，$\\mathbf{X}$ 的三列是线性相关的：$\\mathbf{X}$ 的列空间最多是二维的。这意味着 $\\mathbf{X}^{\\top}\\mathbf{X}$ 是奇异矩阵，并且 $(\\ln k,\\alpha,\\beta)$ 的普通最小二乘参数估计不是唯一的。这就是共线性的体现，它导致了单个参数 $\\alpha$ 和 $\\beta$ 的不可辨识性。\n\n为了确定哪些量是可辨识的，我们将约束条件代入标量形式的模型中：\n$$\n\\ln v_0^{(i)} = \\ln k + \\alpha \\ln [A]_0^{(i)} + \\beta\\big(\\ln C + 2 \\ln [A]_0^{(i)}\\big) + \\varepsilon^{(i)}.\n$$\n合并同类项可得\n$$\n\\ln v_0^{(i)} = \\big(\\ln k + \\beta \\ln C\\big) + \\big(\\alpha + 2\\beta\\big)\\,\\ln [A]_0^{(i)} + \\varepsilon^{(i)}.\n$$\n这表明，在约束条件下，所有数据最多只能解析出两个量：一个有效截距 $\\ln k_{\\text{eff}} = \\ln k + \\beta \\ln C$ 和一个单一的有效斜率\n$$\ns = \\alpha + 2\\beta.\n$$\n截距 $\\ln k_{\\text{eff}}$ 将 $\\ln k$ 和 $\\beta$ 混淆在一起，因此如果没有关于 $C$ 和其中一个级数的额外信息，就无法将 $k$ 与 $\\beta$ 分离开。更重要的是，对于级数本身而言，从沿着这条受限曲线的变化中唯一可辨识的 $\\alpha$ 和 $\\beta$ 的线性组合是斜率 $s = \\alpha + 2\\beta$。数据中没有信息可以单独分离出 $\\alpha$ 和 $\\beta$，因为 $\\ln [B]_0$ 的变化不独立于 $\\ln [A]_0$；它们对应的回归量是仿射相关的。\n\n一种补救措施是重新设计初始浓度组合，使得回归量 $\\ln [A]_0$ 和 $\\ln [B]_0$ 独立变化，并且理想情况下是正交的。在回归的意义上，可以通过对预测变量进行中心化，并选择实验点使得样本交叉乘积为零来实现正交性：\n$$\n\\sum_{i=1}^{n} \\big(\\ln [A]_0^{(i)} - \\overline{\\ln [A]_0}\\big)\\big(\\ln [B]_0^{(i)} - \\overline{\\ln [B]_0}\\big) = 0,\n$$\n这使得中心化的格拉姆矩阵的非对角线元素为零，并得到在斜率子空间中为块对角的 $\\mathbf{X}^{\\top}\\mathbf{X}$。一种具体的构建方法是在对数空间中进行两水平全因子设计：为 $A$ 选择两个水平，$\\ln [A]_0 \\in \\{-a,+a\\}$，为 $B$ 选择两个水平，$\\ln [B]_0 \\in \\{-b,+b\\}$，并对所有四种组合进行等重复次数的实验。这样，中心化的预测变量在 $\\{-a,+a\\}$ 和 $\\{-b,+b\\}$ 中取值，且均值为零，样本交叉乘积为\n$$\n\\sum \\big(\\ln [A]_0\\big)\\big(\\ln [B]_0\\big) = (+a)(+b) + (+a)(-b) + (-a)(+b) + (-a)(-b) = 0,\n$$\n因此该设计在斜率空间中是正交的，$\\alpha$ 和 $\\beta$ 都变得可辨识。另一种基于隔离法或伪一级条件的补救措施是执行两个实验区组：在区组1中，保持 $[B]_0$ 恒定并改变 $[A]_0$（隔离$A$），这可以从 $\\ln v_0$ 对 $\\ln [A]_0$ 的斜率中辨识出 $\\alpha$；在区组2中，保持 $[A]_0$ 恒定并改变 $[B]_0$（隔离$B$），这可以辨识出 $\\beta$。这两种方法都打破了 $\\ln [A]_0$ 和 $\\ln [B]_0$ 之间的仿射依赖关系，从而消除了共线性。\n\n总而言之，在受限设计 $[B]_0 = C [A]_0^2$ 下，反应级数的唯一可辨识线性组合是由下式给出的有效斜率 $s$：\n$$\ns = \\alpha + 2\\beta.\n$$\n这是在没有额外设计变更的情况下，能从沿着约束曲线的初始速率变化中估计出的唯一组合。", "answer": "$$\\boxed{\\alpha + 2\\beta}$$", "id": "2642183"}, {"introduction": "“初始速率”是一个核心的动力学量，但它必须从真实的、含有噪声的实验数据中估算出来。本实践将指导您使用一种稳健的数值方法——局部多项式回归（local polynomial regression），从离散的浓度-时间序列数据中估算初始速率 $r_0$。这个练习的关键部分不仅在于得到一个速率值，更在于量化其不确定性，这是严谨科学分析的基石。[@problem_id:2642177]", "problem": "给定在均匀时间间隔 $t_i = i \\,\\Delta t$（其中 $i \\in \\{0,1,\\dots,m-1\\}$）采集的反应物浓度 $[A](t)$ 的时间序列测量值。这些测量值带有一个独立的加性测量噪声，该噪声为零均值、标准差 $\\sigma$ 已知的高斯噪声。该体系在基元动力学下演化，该动力学为 $[A]$ 的一级反应或在准一级条件下通过隔离法实现的 $[A]$ 和 $[B]$ 的二级反应（即 $[B] \\gg [A]$，因此在采样窗口内 $[B]$ 可视为常数）。初始速率法将初始速率定义为 $r_0 = -\\left.\\dfrac{d[A]}{dt}\\right|_{t=0}$。\n\n设计并实现一个基于对前 $m$ 个样本的单边局部多项式回归（Savitzky–Golay 思想的一种边界形式）的方法，以估计初始斜率 $s_0 = \\left.\\dfrac{d[A]}{dt}\\right|_{t=0}$ 并报告初始速率 $r_0 = -s_0$。使用一个 $p$ 次多项式，通过普通最小二乘法拟合数据对 $\\{(t_i,[A]_i)\\}_{i=0}^{m-1}$，并通过线性最小二乘估计量传播已知的噪声水平 $\\sigma$，以量化由测量噪声引起的 $r_0$ 的标准不确定度。将 $r_0$ 及其标准不确定度以摩尔/秒 (M/s) 表示。将每个报告的数值四舍五入至六位有效数字。\n\n您可以假定的基础知识：反应速率的定义、隔离法和准一级条件的概念、独立同分布高斯噪声下的线性最小二乘估计量，以及线性估计量的标准不确定度传播。\n\n实现您的程序以处理以下测试套件。对于每个测试用例，根据指定的动力学定律生成合成数据，然后为保证可复现性，使用固定的种子添加高斯噪声。使用所提供的 $\\Delta t$、$m$、$p$ 和 $\\sigma$。对于准一级情况，二级速率常数 $k_2$ 和隔离的过量浓度 $[B]_0$ 定义了采样窗口内的有效一级常数 $k' = k_2 [B]_0$。\n\n所有物理量必须按给定的一致性单位处理。您的程序必须输出单行结果，格式为方括号内包含的逗号分隔列表，无空格。对于每个用例，输出两个浮点数：估计的初始速率 $r_0$（单位为 $\\mathrm{M/s}$）及其传播的标准不确定度（单位为 $\\mathrm{M/s}$），两者均四舍五入至六位有效数字。必须按所列顺序处理和输出用例。\n\n测试套件：\n- 用例 1 (一级衰减)：$[A]_0 = 0.010\\,\\mathrm{M}$，$k = 0.30\\,\\mathrm{s}^{-1}$，$\\Delta t = 0.05\\,\\mathrm{s}$，$m = 15$，$p = 3$，$\\sigma = 5.0 \\times 10^{-5}\\,\\mathrm{M}$。\n  数据模型：$[A](t) = [A]_0 \\exp(-k t)$。\n- 用例 2 (通过隔离法实现的准一级二级反应 $A + B \\to P$)：$[A]_0 = 0.005\\,\\mathrm{M}$，$[B]_0 = 0.20\\,\\mathrm{M}$，$k_2 = 2.0\\,\\mathrm{M}^{-1}\\mathrm{s}^{-1}$，$\\Delta t = 0.02\\,\\mathrm{s}$，$m = 20$，$p = 3$，$\\sigma = 2.0 \\times 10^{-5}\\,\\mathrm{M}$。在窗口内，$k' = k_2 [B]_0$，且 $[A](t) = [A]_0 \\exp(-k' t)$。\n- 用例 3 (小 $\\Delta t$ 和较高噪声的边缘情况)：$[A]_0 = 0.003\\,\\mathrm{M}$，$k = 1.5\\,\\mathrm{s}^{-1}$，$\\Delta t = 0.005\\,\\mathrm{s}$，$m = 8$，$p = 2$，$\\sigma = 1.0 \\times 10^{-4}\\,\\mathrm{M}$。\n  数据模型：$[A](t) = [A]_0 \\exp(-k t)$。\n\n数值数据生成：\n- 对于每个用例，构建 $t_i = i \\,\\Delta t$（其中 $i = 0,1,\\dots,m-1$），根据给定模型计算无噪声的 $[A](t_i)$，然后向每个样本添加均值为零、标准差为 $\\sigma$ 的独立高斯噪声，以获得 $[A]_i^{\\mathrm{obs}}$。\n- 使用固定的随机种子 $123456$ 以确保可复现性。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果：$[r_{0,1},u_{1},r_{0,2},u_{2},r_{0,3},u_{3}]$，其中 $r_{0,j}$ 是用例 $j$ 的估计初始速率（单位为 $\\mathrm{M/s}$），$u_j$ 是其传播的标准不确定度（单位为 $\\mathrm{M/s}$），每个值都四舍五入到六位有效数字。", "solution": "所提出的问题是化学动力学中一个适定且科学合理的应用于数值数据分析的练习。它要求从含噪声的时间序列数据中估计初始反应速率。这是实验化学中一个常见的基础任务。所提出的方法，即局部多项式回归，是用于此目的的标准且稳健的技术。我们将对其解法进行严格的推导。\n\n目标是确定反应的初始速率 $r_0$，定义为反应物浓度 $[A]$ 在时间 $t=0$ 时对时间导数的负值：\n$$\nr_0 = -\\left.\\frac{d[A]}{dt}\\right|_{t=0}\n$$\n给定在离散时间点 $t_i = i \\cdot \\Delta t$（$i \\in \\{0, 1, \\dots, m-1\\}$）上的一系列 $m$ 个浓度测量值 $[A]_i^{\\mathrm{obs}}$。这些测量值被均值为 $0$、标准差为 $\\sigma$ 的独立同分布 (i.i.d.) 加性高斯噪声所干扰。\n\n该方法的核心是在 $t=0$ 附近用一个 $p$ 次多项式来近似函数 $[A](t)$：\n$$\nP(t) = \\sum_{j=0}^{p} c_j t^j\n$$\n该多项式的导数为：\n$$\n\\frac{dP(t)}{dt} = \\sum_{j=1}^{p} j c_j t^{j-1}\n$$\n在 $t=0$ 处计算此导数，得到初始斜率 $s_0$：\n$$\ns_0 = \\left.\\frac{dP(t)}{dt}\\right|_{t=0} = c_1\n$$\n因此，初始速率与多项式拟合的一阶系数直接相关：$r_0 = -s_0 = -c_1$。我们的任务因此转变为估计系数 $c_1$ 及其相关的不确定度。\n\n系数 $\\boldsymbol{c} = [c_0, c_1, \\dots, c_p]^T$ 是通过使用普通最小二乘法 (OLS) 将多项式拟合到 $m$ 个观测数据点 $(t_i, [A]_i^{\\mathrm{obs}})$ 来确定的。这建立了一个形式为 $\\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{c} + \\boldsymbol{\\epsilon}$ 的线性模型，其中：\n- $\\boldsymbol{y}$ 是观测浓度 $[A]_i^{\\mathrm{obs}}$ 的 $m \\times 1$ 向量。\n- $\\boldsymbol{X}$ 是 $m \\times (p+1)$ 的设计矩阵，其元素为 $X_{ij} = t_i^j$，其中 $i \\in \\{0, \\dots, m-1\\}$ 且 $j \\in \\{0, \\dots, p\\}$。\n- $\\boldsymbol{c}$ 是上述多项式系数的 $(p+1) \\times 1$ 向量。\n- $\\boldsymbol{\\epsilon}$ 是未知测量误差的 $m \\times 1$ 向量。\n\n最小化残差平方和的 OLS 估计量 $\\hat{\\boldsymbol{c}}$ 由正规方程给出：\n$$\n\\hat{\\boldsymbol{c}} = (\\boldsymbol{X}^T \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{y}\n$$\n则估计的初始速率为 $\\hat{r}_0 = -\\hat{c}_1$，其中 $\\hat{c}_1$ 是向量 $\\hat{\\boldsymbol{c}}$ 的第二个分量（索引为 $1$）。\n\n为了量化此估计的不确定度，我们必须通过线性估计量传播测量噪声。观测值的协方差矩阵为 $\\mathrm{Cov}(\\boldsymbol{y}) = \\sigma^2 \\boldsymbol{I}$，其中 $\\boldsymbol{I}$ 是 $m \\times m$ 的单位矩阵，这反映了噪声是独立同分布且方差为 $\\sigma^2$ 的假设。估计系数向量 $\\hat{\\boldsymbol{c}}$ 的协方差矩阵则推导如下：\n$$\n\\mathrm{Cov}(\\hat{\\boldsymbol{c}}) = \\mathrm{Cov}((\\boldsymbol{X}^T \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{y}) = ((\\boldsymbol{X}^T \\boldsymbol{X})^{-1} \\boldsymbol{X}^T) \\mathrm{Cov}(\\boldsymbol{y}) ((\\boldsymbol{X}^T \\boldsymbol{X})^{-1} \\boldsymbol{X}^T)^T\n$$\n$$\n\\mathrm{Cov}(\\hat{\\boldsymbol{c}}) = (\\boldsymbol{X}^T \\boldsymbol{X})^{-1} \\boldsymbol{X}^T (\\sigma^2 \\boldsymbol{I}) \\boldsymbol{X} ((\\boldsymbol{X}^T \\boldsymbol{X})^{-1})^T = \\sigma^2 (\\boldsymbol{X}^T \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{X} (\\boldsymbol{X}^T \\boldsymbol{X})^{-1}\n$$\n这可以简化为：\n$$\n\\mathrm{Cov}(\\hat{\\boldsymbol{c}}) = \\sigma^2 (\\boldsymbol{X}^T \\boldsymbol{X})^{-1}\n$$\n估计量 $\\hat{c}_1$ 的方差是此协方差矩阵中对应于 $c_1$ 的对角元素。使用基于 $0$ 的索引，这是位于位置 $(1, 1)$ 的元素：\n$$\n\\mathrm{Var}(\\hat{c}_1) = \\sigma^2 [(\\boldsymbol{X}^T \\boldsymbol{X})^{-1}]_{11}\n$$\n估计的初始速率 $u(\\hat{r}_0)$ 的标准不确定度是 $\\hat{r}_0 = -\\hat{c}_1$ 方差的平方根。由于方差对符号变化不敏感，$\\mathrm{Var}(\\hat{r}_0) = \\mathrm{Var}(\\hat{c}_1)$。因此：\n$$\nu(\\hat{r}_0) = \\sqrt{\\mathrm{Var}(\\hat{c}_1)} = \\sigma \\sqrt{[(\\boldsymbol{X}^T \\boldsymbol{X})^{-1}]_{11}}\n$$\n此公式提供了一种基于已知的测量噪声 $\\sigma$ 和样本的时间点直接计算估计速率不确定度的方法。\n\n实现将通过对每个测试用例执行以下步骤来进行：\n1. 生成合成数据。对于给定用例，构建时间向量 $\\boldsymbol{t}$。根据指定的动力学模型（$[A](t) = [A]_0 \\exp(-kt)$ 或 $[A](t) = [A]_0 \\exp(-k't)$）计算真实浓度 $[A](t_i)$。从固定的随机种子生成高斯噪声并添加到数据中以确保可复现性。\n2. 基于时间向量 $\\boldsymbol{t}$ 和多项式次数 $p$ 构建设计矩阵 $\\boldsymbol{X}$。\n3. 求解 OLS 问题 $\\boldsymbol{X}\\boldsymbol{c} = \\boldsymbol{y}$ 以获得系数估计向量 $\\hat{\\boldsymbol{c}}$。\n4. 计算估计速率 $\\hat{r}_0 = -\\hat{c}_1$。\n5. 计算矩阵 $(\\boldsymbol{X}^T \\boldsymbol{X})^{-1}$ 并使用其 $(1,1)$ 元素来找到不确定度 $u(\\hat{r}_0)$。\n6. 报告 $\\hat{r}_0$ 和 $u(\\hat{r}_0)$ 的最终值，四舍五入至六位有效数字。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for initial reaction rates and their uncertainties from synthetic data\n    using one-sided local polynomial regression.\n    \"\"\"\n\n    def round_to_sig_figs(x, p):\n        \"\"\"\n        Rounds a number x to p significant figures.\n        \"\"\"\n        if x == 0:\n            return 0.0\n        # Calculate the position of the most significant digit.\n        magnitude = np.floor(np.log10(np.abs(x)))\n        # Determine the number of decimal places needed for rounding.\n        rounding_decimal = int(p - 1 - magnitude)\n        return np.round(x, rounding_decimal)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"A0\": 0.010, \"k\": 0.30, \"dt\": 0.05, \"m\": 15, \"p\": 3, \"sigma\": 5.0e-5,\n            \"k2\": None, \"B0\": None\n        },\n        {\n            \"name\": \"Case 2\",\n            \"A0\": 0.005, \"k\": None, \"dt\": 0.02, \"m\": 20, \"p\": 3, \"sigma\": 2.0e-5,\n            \"k2\": 2.0, \"B0\": 0.20\n        },\n        {\n            \"name\": \"Case 3\",\n            \"A0\": 0.003, \"k\": 1.5, \"dt\": 0.005, \"m\": 8, \"p\": 2, \"sigma\": 1.0e-4,\n            \"k2\": None, \"B0\": None\n        },\n    ]\n\n    # Global settings for reproducibility and output format\n    seed = 123456\n    rng = np.random.default_rng(seed)\n    num_sig_figs = 6\n    \n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        A0 = case['A0']\n        k = case['k']\n        dt = case['dt']\n        m = case['m']\n        p = case['p']\n        sigma = case['sigma']\n        k2 = case['k2']\n        B0 = case['B0']\n\n        # Determine the effective rate constant k_eff\n        if k is None:\n            # Pseudo-first-order case\n            k_eff = k2 * B0\n        else:\n            # First-order case\n            k_eff = k\n        \n        # Step 1: Generate synthetic noisy data\n        t = np.arange(m) * dt\n        A_true = A0 * np.exp(-k_eff * t)\n        noise = rng.normal(loc=0.0, scale=sigma, size=m)\n        A_obs = A_true + noise\n\n        # Step 2: Construct the design matrix for polynomial regression\n        # np.vander with increasing=True produces [1, t, t^2, ...], which is correct\n        X = np.vander(t, N=p + 1, increasing=True)\n        \n        # Step 3: Solve for polynomial coefficients using OLS\n        # np.linalg.lstsq solves the equation X*c = A_obs for c\n        c_hat, _, _, _ = np.linalg.lstsq(X, A_obs, rcond=None)\n        \n        # The estimated initial rate is -c_1\n        r0_est = -c_hat[1]\n        \n        # Step 4: Calculate the uncertainty of the initial rate\n        # Compute the inverse of the matrix (X^T * X)\n        XTX_inv = np.linalg.inv(X.T @ X)\n        \n        # The variance of c1 is sigma^2 times the (1,1) element of (X^T*X)^-1\n        # Using 0-based indexing for c1\n        var_c1 = sigma**2 * XTX_inv[1, 1]\n        \n        # The standard uncertainty is the square root of the variance\n        u_r0 = np.sqrt(var_c1)\n        \n        # Step 5: Round results to six significant figures\n        r0_rounded = round_to_sig_figs(r0_est, num_sig_figs)\n        u_r0_rounded = round_to_sig_figs(u_r0, num_sig_figs)\n\n        results.extend([r0_rounded, u_r0_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2642177"}, {"introduction": "当我们拥有一组初始速率数据后，常常会发现有多个看似合理的速率定律都能对其进行拟合。我们如何以一种客观、非随意的方式选择最佳模型呢？本练习介绍了赤池信息准则（Akaike Information Criterion, AIC），这是一种强大的统计工具，它在模型的拟合优度（goodness of fit）与复杂性（complexity）之间进行了权衡，让您能够定量地比较不同的候选模型，并选出证据支持最强的那个。[@problem_id:2642276]", "problem": "给定三个候选速率定律，用于在包括孤立法和准一级反应条件的双分子反应的初始速率数据建模。目标是使用赤池信息准则（AIC）比较这些候选模型，并报告优选模型及其支持证据的强度。\n\n基本原理：\n- 假设初始速率测量值是独立的，并带有加性的、同分布的、零均值且方差未知的高斯误差。在此假设下，残差的对数似然与负的残差平方和（RSS）成正比，参数的最大似然估计（MLE）对应于最小化RSS。\n- 对于一个有 $p$ 个拟合参数和最大化似然为 $\\hat{L}$ 的模型，赤池信息准则（AIC）为 $ \\mathrm{AIC} = 2p - 2 \\ln(\\hat{L}) $。对于方差未知的高斯误差，其方差由 $ \\widehat{\\sigma}^2 = \\mathrm{RSS}/N $ 估计（其中 $N$ 是数据点数），模型的AIC排名可以等价地通过 $ \\mathrm{AIC} = N \\ln(\\mathrm{RSS}/N) + 2p + C $ 获得，其中 $C$ 是一个与模型无关并在计算差值时会抵消的常数。\n\n候选速率定律（其中 $[\\cdot]$ 表示浓度）：\n- 模型 $\\mathcal{M}_1$（索引 $1$）：$ r = k_1 [A] $。参数：$p=1$ ($k_1$)。\n- 模型 $\\mathcal{M}_2$（索引 $2$）：$ r = k_2 [A][B] $。参数：$p=1$ ($k_2$)。\n- 模型 $\\mathcal{M}_3$（索引 $3$）：$ r = \\dfrac{k_3 [A][B]}{1 + K [B]} $。参数：$p=2$ ($k_3, K$)。\n\n所有速率常数和参数都约束为非负。浓度 $[A]$ 和 $[B]$ 的单位是 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$，初始速率 $r$ 的单位是 $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$。所要求的输出是无量纲的。\n\n参数估计要求：\n- 对每个模型，通过非线性最小二乘法在参数非负的约束下最小化 $ \\mathrm{RSS} = \\sum_{i=1}^{N} \\left( r_i^{\\mathrm{obs}} - r_i^{\\mathrm{model}} \\right)^2 $ 来拟合参数。\n\n模型比较要求：\n- 使用上述高斯误差公式计算每个候选模型的 $ \\mathrm{AIC} $。选择AIC值最小的模型作为最佳模型。如果出现AIC值在绝对容差 $10^{-12}$ 内持平的情况，则选择模型索引最小的那个。\n- 计算支持最佳模型相对于次佳模型（AIC第二小的模型）的证据比，公式为 $ \\exp\\!\\left( \\dfrac{\\mathrm{AIC}_{\\mathrm{second}} - \\mathrm{AIC}_{\\mathrm{best}}}{2} \\right) $。该比值是无单位的，并且大于或等于 $1$。如果AIC值持平，则该比值等于 $1$。\n\n测试套件：\n- 案例 #1（通用双反应物变化，具有小噪声的二级基线）。数据点 $( [A], [B], r )$：\n  - (0.02, 0.03, 0.0003)\n  - (0.02, 0.06, 0.000599)\n  - (0.02, 0.12, 0.001198)\n  - (0.05, 0.03, 0.000751)\n  - (0.05, 0.06, 0.0015)\n  - (0.05, 0.12, 0.002999)\n  - (0.10, 0.03, 0.001502)\n  - (0.10, 0.06, 0.003001)\n  - (0.10, 0.12, 0.006)\n- 案例 #2（在 $[B]$ 保持恒定且噪声较小的情况下，反应对 $[A]$ 呈准一级）。数据点 $( [A], [B], r )$：\n  - (0.02, 0.20, 0.000602)\n  - (0.05, 0.20, 0.001498)\n  - (0.10, 0.20, 0.003002)\n  - (0.20, 0.20, 0.005998)\n- 案例 #3（在 $[A]$ 孤立且噪声较小的情况下，对 $[B]$ 的饱和依赖性）。数据点 $( [A], [B], r )$：\n  - (0.10, 0.01, 0.000924925926)\n  - (0.10, 0.02, 0.001723637931)\n  - (0.10, 0.05, 0.003571428571)\n  - (0.10, 0.10, 0.005556055556)\n  - (0.10, 0.20, 0.007693307692)\n  - (0.10, 0.50, 0.0100015)\n\n您的任务：\n- 实现一个程序，对三个案例中的每一个，拟合所有三个模型，计算AIC值，按规定选择最佳模型，并计算支持最佳模型相对于次佳模型的证据比。\n- 对每个案例，报告一个数值对 $[m, e]$，其中 $m$ 是 $\\{1,2,3\\}$ 中的整数模型索引，$e$ 是四舍五入到小数点后恰好六位的证据比。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个结果，格式为无空格的、逗号分隔的列表的列表，例如 $[[m_1,e_1],[m_2,e_2],[m_3,e_3]]$。证据比必须打印为小数点后恰好六位。", "solution": "问题陈述经过验证，被认为是有效的。它在科学上基于化学动力学和统计模型选择的原理，问题定义良好，具有清晰客观的标准，并为可解的计算任务提供了完整的数据集和指令。其中没有矛盾、模糊之处或事实性错误。\n\n任务是针对三个不同的实验数据集，在三个候选速率定律中进行模型选择。选择基于赤池信息准则（AIC），这是一种比较统计模型的标准方法。对每个数据集的步骤如下：\n\n1.  **通过非线性最小二乘法进行参数估计**：对于三个模型 $\\mathcal{M}_1$、$\\mathcal{M}_2$ 和 $\\mathcal{M}_3$ 中的每一个，都必须通过最小化残差平方和（RSS）来估计其参数。目标函数为：\n    $$ \\mathrm{RSS}(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left( r_i^{\\mathrm{obs}} - r^{\\mathrm{model}}([A]_i, [B]_i; \\boldsymbol{\\theta}) \\right)^2 $$\n    其中 $r_i^{\\mathrm{obs}}$ 是第 $i$ 个数据点的观测初始速率，$r^{\\mathrm{model}}$ 是模型在给定浓度 $[A]_i$、$[B]_i$ 和参数集 $\\boldsymbol{\\theta}$ 下预测的速率，$N$ 是数据点的数量。参数 $\\boldsymbol{\\theta}$ 被约束为非负，这与其作为速率常数或平衡常数的物理意义相符。这个约束优化问题使用数值非线性最小二乘算法来解决。候选模型为：\n    -   模型 $\\mathcal{M}_1$：$r = k_1 [A]$，参数向量为 $\\boldsymbol{\\theta}_1 = (k_1)$，有 $p_1=1$ 个参数。\n    -   模型 $\\mathcal{M}_2$：$r = k_2 [A] [B]$，参数向量为 $\\boldsymbol{\\theta}_2 = (k_2)$，有 $p_2=1$ 个参数。\n    -   模型 $\\mathcal{M}_3$：$r = \\dfrac{k_3 [A][B]}{1 + K [B]}$，参数向量为 $\\boldsymbol{\\theta}_3 = (k_3, K)$，有 $p_3=2$ 个参数。\n\n2.  **AIC 计算**：在确定每个模型的最优参数 $\\hat{\\boldsymbol{\\theta}}$ 和相应的最小 $\\mathrm{RSS}_{\\min}$ 后，计算AIC。对于一个有 $p$ 个参数的模型，公式为：\n    $$ \\mathrm{AIC} = N \\ln\\left(\\frac{\\mathrm{RSS}_{\\min}}{N}\\right) + 2p $$\n    AIC在拟合优度（由 $\\mathrm{RSS}_{\\min}$ 表示）和模型复杂度（由 $p$ 表示）之间取得平衡。较低的AIC值表示模型更优。完美拟合（$\\mathrm{RSS}_{\\min} = 0$）将导致 $\\mathrm{AIC} = -\\infty$，使其明确地成为最佳模型。然而，由于实验噪声的存在，$\\mathrm{RSS}_{\\min}$ 预期会是一个小的正值。\n\n3.  **模型选择**：对于每个案例，根据三个模型的AIC值对其进行排序。AIC值最小的模型被选为最佳模型。在出现持平（定义为AIC值的绝对差小于 $10^{-12}$）的情况下，选择索引较小的模型（$1 < 2 < 3$）。设所选最佳模型的AIC为 $\\mathrm{AIC}_{\\text{best}}$。\n\n4.  **证据比计算**：最佳模型的证据强度由证据比 $E$ 来量化。该比率比较了最佳模型与次佳模型（具有次低AIC值的模型，$\\mathrm{AIC}_{\\text{second}}$）的似然。\n    $$ E = \\exp\\left( \\frac{\\mathrm{AIC}_{\\text{second}} - \\mathrm{AIC}_{\\text{best}}}{2} \\right) $$\n    如果最佳和次佳模型的AIC被认为持平（在 $10^{-12}$ 的容差范围内），则证据比 $E=1$。否则，$E > 1$，且值越大表示对最佳模型的支持越强。\n\n这整个过程独立地应用于三个测试案例中的每一个。每个案例的最终输出是一个数值对 $[m, e]$，其中 $m$ 是最佳模型的索引，$e$ 是计算出的证据比。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the model selection problem for three test cases in chemical kinetics.\n    For each case, it fits three candidate rate laws, calculates their AIC,\n    selects the best model, and computes the evidence ratio.\n    \"\"\"\n\n    # Define the three candidate model functions.\n    # Each function takes parameters and concentrations as input and returns the predicted rate.\n    def model1(params, A, B):\n        k1, = params\n        return k1 * A\n\n    def model2(params, A, B):\n        k2, = params\n        return k2 * A * B\n\n    def model3(params, A, B):\n        k3, K = params\n        # Denominator is 1 + K*B. With K>=0 and B>=0, it is always >= 1, so no risk of division by zero.\n        return (k3 * A * B) / (1.0 + K * B)\n\n    def process_case(data_points):\n        \"\"\"\n        Processes a single test case: fits models, calculates AICs, and determines the best model and evidence ratio.\n        \"\"\"\n        data = np.array(data_points)\n        A = data[:, 0]\n        B = data[:, 1]\n        r_obs = data[:, 2]\n        N = len(r_obs)\n\n        models_spec = [\n            {'name': 'M1', 'func': model1, 'p': 1, 'p0': [1.0], 'bounds': ([0], [np.inf]), 'id': 1},\n            {'name': 'M2', 'func': model2, 'p': 1, 'p0': [1.0], 'bounds': ([0], [np.inf]), 'id': 2},\n            {'name': 'M3', 'func': model3, 'p': 2, 'p0': [1.0, 1.0], 'bounds': ([0, 0], [np.inf, np.inf]), 'id': 3}\n        ]\n\n        results = []\n        for spec in models_spec:\n            # Define the residual function for the least squares optimizer.\n            def residuals(params, A, B, r_obs):\n                r_pred = spec['func'](params, A, B)\n                return r_obs - r_pred\n\n            # Perform non-linear least squares fitting with non-negativity constraints.\n            fit_result = least_squares(\n                residuals,\n                spec['p0'],\n                bounds=spec['bounds'],\n                args=(A, B, r_obs)\n            )\n\n            # RSS is 2 * cost, as least_squares minimizes 0.5 * sum(residuals^2).\n            rss = 2 * fit_result.cost\n            p = spec['p']\n            \n            # Calculate AIC. Handle the case of a perfect fit (RSS=0).\n            if rss <= 1e-30:  # Use a small threshold to handle floating point near-zero\n                aic = -np.inf\n            else:\n                aic = N * math.log(rss / N) + 2 * p\n            \n            results.append({'model_index': spec['id'], 'aic': aic})\n\n        # Sort results primarily by AIC, secondarily by model index for tie-breaking.\n        # Python's default sort is stable. Sorting by index then by AIC achieves the desired outcome.\n        results.sort(key=lambda x: x['model_index'])\n        results.sort(key=lambda x: x['aic'])\n\n        best_model = results[0]\n        second_best_model = results[1]\n\n        m = best_model['model_index']\n        aic_best = best_model['aic']\n        aic_second = second_best_model['aic']\n\n        # Calculate evidence ratio, checking for ties.\n        if abs(aic_second - aic_best) < 1e-12:\n            e = 1.0\n        else:\n            e = math.exp((aic_second - aic_best) / 2.0)\n            \n        return [m, e]\n\n    # Test suite data.\n    test_cases = [\n        # Case #1\n        [\n            (0.02, 0.03, 0.0003),\n            (0.02, 0.06, 0.000599),\n            (0.02, 0.12, 0.001198),\n            (0.05, 0.03, 0.000751),\n            (0.05, 0.06, 0.0015),\n            (0.05, 0.12, 0.002999),\n            (0.10, 0.03, 0.001502),\n            (0.10, 0.06, 0.003001),\n            (0.10, 0.12, 0.006)\n        ],\n        # Case #2\n        [\n            (0.02, 0.20, 0.000602),\n            (0.05, 0.20, 0.001498),\n            (0.10, 0.20, 0.003002),\n            (0.20, 0.20, 0.005998)\n        ],\n        # Case #3\n        [\n            (0.10, 0.01, 0.000924925926),\n            (0.10, 0.02, 0.001723637931),\n            (0.10, 0.05, 0.003571428571),\n            (0.10, 0.10, 0.005556055556),\n            (0.10, 0.20, 0.007693307692),\n            (0.10, 0.50, 0.0100015)\n        ]\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        result_pair = process_case(case_data)\n        all_results.append(result_pair)\n\n    # Format the final output string exactly as specified.\n    result_strings = [f\"[{m},{e:.6f}]\" for m, e in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2642276"}]}