{"hands_on_practices": [{"introduction": "RRKM 理论的核心在于精确计算分子的可及量子态数量。在谐振子近似下，我们可以使用 Beyer-Swinehart 算法来精确地对离散的振动能态进行计数。这项练习 [@problem_id:2672869] 旨在让您亲手实践这一基础的直接计数算法，为您后续评估态密度 $\\rho(E)$ 和态总和 $N(E)$ 建立关键的计算能力。", "problem": "考虑一个具有 $f$ 个振动自由度的非线性分子，这些自由度被建模为独立的量子谐振子 (HOs)。设爱因斯坦频率（以波数为单位）的集合为 $\\{\\nu_i\\}_{i=1}^{m}$，其中每个不同的频率 $\\nu_i$ 都有一个整数模式简并度 $g_i \\in \\mathbb{Z}_{\\ge 1}$。总的振动模式数为 $f = \\sum_{i=1}^{m} g_i$。一个振动量子态由非负整数 $\\{n_{i,a}\\}$ 指定，其中 $i \\in \\{1,\\dots,m\\}$ 且 $a \\in \\{1,\\dots,g_i\\}$，$n_{i,a}$ 是频率为 $\\nu_i$ 的 $g_i$ 重简并集中第 $a$ 个成员的量子数。\n\n在 Rice–Ramsperger–Kassel–Marcus (RRKM) 理论中，谐振子浴的微正则态总和 $N_{\\mathrm{HO}}(E)$ 是指总振动能量不超过给定能量 $E$ 的不同量子态的数量。使用波数单位，定义 $\\tilde{E} \\equiv E/(hc)$ 并以 $\\mathrm{cm}^{-1}$ 为单位测量所有能量。零点能为\n$$\n\\tilde{E}_0 = \\frac{1}{2} \\sum_{i=1}^{m} g_i \\nu_i,\n$$\n而高于零点能的激发能为 $\\tilde{E}_{\\mathrm{exc}} = \\tilde{E} - \\tilde{E}_0$。一个态 $\\{n_{i,a}\\}$ 的能量（以 $\\mathrm{cm}^{-1}$ 为单位）为\n$$\n\\tilde{E}(\\{n_{i,a}\\}) = \\sum_{i=1}^{m} \\sum_{a=1}^{g_i} \\left(n_{i,a} + \\frac{1}{2}\\right) \\nu_i.\n$$\n因此，总能量为 $\\tilde{E}$ 时的微正则态总和为\n$$\nN_{\\mathrm{HO}}(\\tilde{E}) = \\#\\left\\{ \\{n_{i,a}\\} \\in \\mathbb{Z}_{\\ge 0}^{f} \\,\\Big|\\, \\sum_{i=1}^{m} \\sum_{a=1}^{g_i} n_{i,a} \\nu_i \\le \\tilde{E} - \\tilde{E}_0 \\right\\}.\n$$\n\n您的任务是为 $N_{\\mathrm{HO}}(\\tilde{E})$ 构建一个离散态计数方案，该方案要考虑到零点能的平移和模式的简并性。为确保算法完全离散，引入一个能量箱宽度 $\\Delta \\varepsilon$（以 $\\mathrm{cm}^{-1}$ 为单位），并将每个频率 $\\nu_i$ 映射到一个整数箱权重 $w_i = \\mathrm{round}(\\nu_i / \\Delta \\varepsilon) \\in \\mathbb{Z}_{\\ge 1}$。设以箱为单位的激发能为\n$$\nS = \\left\\lfloor \\frac{\\tilde{E} - \\tilde{E}_0}{\\Delta \\varepsilon} \\right\\rfloor.\n$$\n然后将 $N_{\\mathrm{HO}}(\\tilde{E})$ 计算为以下不等式的非负整数解的数量：\n$$\n\\sum_{i=1}^{m} \\sum_{a=1}^{g_i} w_i \\, n_{i,a} \\le S,\n$$\n其中 $n_{i,a} \\in \\mathbb{Z}_{\\ge 0}$，并定义当 $\\tilde{E}  \\tilde{E}_0$ 时，$N_{\\mathrm{HO}}(\\tilde{E}) = 0$。当两个或更多不同的模式共享相同的频率时（即简并度 $g_i  1$），它们必须被视为可区分的振子，贡献组合上不同的量子数分配。\n\n您必须实现一个算法，该算法：\n- 根据 $\\{\\nu_i\\}$ 和 $\\{g_i\\}$ 计算 $\\tilde{E}_0$ 并适当地平移能量原点。\n- 使用 $\\Delta \\varepsilon$ 将频率和激发能离散化为整数箱权重和一个箱限 $S$。\n- 计数上述不等式的解的数量，从而产生离散的 $N_{\\mathrm{HO}}(\\tilde{E})$。\n\n所有能量必须以 $\\mathrm{cm}^{-1}$ 为单位进行处理和报告。输出必须是整数。\n\n请实现您的程序来评估以下测试套件。对于每种情况，输入包括不同频率的列表、匹配的简并度列表、总能量 $\\tilde{E}$（以 $\\mathrm{cm}^{-1}$ 为单位）以及箱宽度 $\\Delta \\varepsilon$（以 $\\mathrm{cm}^{-1}$ 为单位）。\n\n测试套件：\n- 情况 1：$\\{\\nu_i\\} = [1000, 1100, 1200]$，$\\{g_i\\} = [1, 1, 1]$，$\\tilde{E} = 3300$，$\\Delta \\varepsilon = 50$。\n- 情况 2：$\\{\\nu_i\\} = [500, 800]$，$\\{g_i\\} = [2, 1]$，$\\tilde{E} = 2000$，$\\Delta \\varepsilon = 50$。\n- 情况 3：$\\{\\nu_i\\} = [400, 600, 700]$，$\\{g_i\\} = [1, 1, 1]$，$\\tilde{E} = 849$，$\\Delta \\varepsilon = 1$。\n- 情况 4：$\\{\\nu_i\\} = [300]$，$\\{g_i\\} = [4]$，$\\tilde{E} = 1200$，$\\Delta \\varepsilon = 100$。\n- 情况 5：$\\{\\nu_i\\} = [200, 250, 400, 500]$，$\\{g_i\\} = [1, 2, 1, 1]$，$\\tilde{E} = 1800$，$\\Delta \\varepsilon = 50$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应测试用例计算出的整数 $N_{\\mathrm{HO}}(\\tilde{E})$。", "solution": "问题陈述已经过验证，被认为是科学上可靠、定义明确且完整的。它提出了一个基于 Rice–Ramsperger–Kassel–Marcus (RRKM) 理论的化学动力学中的标准计算任务，该任务针对一个独立的量子谐振子系统。该问题没有矛盾或含糊之处，并提供了解决它所需的所有必要数据。\n\n核心任务是计算由 $f$ 个可区分的谐振子组成的集合的微正则态总和 $N_{\\mathrm{HO}}(\\tilde{E})$。为了进行数值求解，该问题被离散化。我们给定一个由 $m$ 个不同振动频率组成的集合 $\\{\\nu_i\\}_{i=1}^{m}$（以 $\\mathrm{cm}^{-1}$ 为单位）及其对应的简并度 $\\{g_i\\}_{i=1}^{m}$。振子的总数为 $f = \\sum_{i=1}^{m} g_i$。\n\n首先，我们建立能量参考。总能量给定为 $\\tilde{E}$（以 $\\mathrm{cm}^{-1}$ 为单位）。系统的零点能 (ZPE) 由下式给出：\n$$\n\\tilde{E}_0 = \\frac{1}{2} \\sum_{i=1}^{m} g_i \\nu_i\n$$\n可用于振动激发的能量 $\\tilde{E}_{\\mathrm{exc}}$ 是总能量减去零点能：\n$$\n\\tilde{E}_{\\mathrm{exc}} = \\tilde{E} - \\tilde{E}_0\n$$\n如果 $\\tilde{E}  \\tilde{E}_0$，则不可能发生激发，态总和 $N_{\\mathrm{HO}}(\\tilde{E})$ 显然为 0。\n\n然后使用能量箱宽度 $\\Delta\\varepsilon$ 将问题离散化。每个频率 $\\nu_i$ 被映射到一个整数权重 $w_i$：\n$$\nw_i = \\mathrm{round}\\left(\\frac{\\nu_i}{\\Delta\\varepsilon}\\right)\n$$\n总的可用激发能被映射为整数个箱，即 $S$：\n$$\nS = \\left\\lfloor \\frac{\\tilde{E}_{\\mathrm{exc}}}{\\Delta\\varepsilon} \\right\\rfloor\n$$\n因此，问题被转化为一个组合任务：求解线性丢番图不等式的非负整数解 $\\{n_{k}\\}_{k=1}^{f}$ 的数量：\n$$\n\\sum_{k=1}^{f} W_k n_k \\le S\n$$\n其中 $\\{W_k\\}_{k=1}^{f}$ 是扩展的整数权重列表，包含了所有 $f$ 个可区分的振子。对于每个 $(\\nu_i, g_i)$ 对，权重 $w_i$ 在此列表中重复 $g_i$ 次。\n\n这个计数问题可以使用动态规划方法高效解决，该方法通常被称为 Beyer-Swinehart 直接计数算法。该算法迭代计算态密度 $\\rho(j)$，即系统总激发能恰好为 $j$ 个能量箱的方式数量。\n\n该算法流程如下：\n\n1.  初始化一个大小为 $S+1$ 的一维数组 `density`，用于存储 $j \\in \\{0, 1, \\dots, S\\}$ 的态密度 $\\rho(j)$。对于一个没有振子的系统，只有一个状态：能量为零的基态。因此，我们初始化 $\\rho(0) = 1$，对于所有 $j  0$，初始化 $\\rho(j) = 0$。\n\n2.  迭代地将 $f$ 个振子中的每一个添加到系统中。当添加一个权重为 $W$ 的振子时，态密度数组会更新。组合系统能量为 $j$ 的一个状态，可以通过取前一个系统能量为 $j'$ 的一个状态，并向新振子添加 $n$ 个量子来形成，使得 $j = j' + nW$。新的态密度 $\\rho_{\\text{new}}(j)$ 是旧系统态密度 $\\rho_{\\text{old}}(j')$ 在新振子所有可能贡献上的总和。这导出了递推关系：\n    $$\n    \\rho_{\\text{new}}(j) = \\sum_{n=0}^{\\lfloor j/W \\rfloor} \\rho_{\\text{old}}(j-nW)\n    $$\n    通过关系式 $\\rho_{\\text{new}}(j) = \\rho_{\\text{old}}(j) + \\rho_{\\text{new}}(j-W)$ 可以更高效地计算。这允许对 `density` 数组进行原地更新：对于给定的权重 $W$，我们从 $W$ 到 $S$ 迭代 $j$，并将 $\\rho(j)$ 更新为 $\\rho(j) \\leftarrow \\rho(j) + \\rho(j-W)$。\n\n3.  遍历所有 $f$ 个振子后，`density` 数组包含了整个系统在从 $0$ 到 $S$ 的每个能级上的最终态密度。\n\n4.  问题要求的是态总和 $N_{\\mathrm{HO}}(\\tilde{E})$，即能量*小于或等于*分箱能量 $S$ 的总态数。这是态密度数组的累积和：\n    $$\n    N_{\\mathrm{HO}}(\\tilde{E}) = \\sum_{j=0}^{S} \\rho(j)\n    $$\n\n为每个测试用例实现此过程以计算最终结果。所有涉及态密度的计算都使用任意精度整数以防止溢出，这是 Python `int` 类型的一个标准特性。", "answer": "```python\nimport numpy as np\n\ndef calculate_sum_of_states(freqs, degs, E_total, d_eps):\n    \"\"\"\n    Calculates the harmonic oscillator sum of states using a discrete direct-count algorithm.\n\n    Args:\n        freqs (list[float]): List of distinct vibrational frequencies in cm^-1.\n        degs (list[int]): List of degeneracies for each frequency.\n        E_total (float): Total vibrational energy in cm^-1.\n        d_eps (float): Energy bin width in cm^-1.\n\n    Returns:\n        int: The computed discrete sum of states N_HO(E).\n    \"\"\"\n    # Step 1: Calculate Zero-Point Energy (ZPE)\n    E_zpe = 0.5 * sum(g * v for v, g in zip(freqs, degs))\n\n    # Step 2: Calculate excitation energy\n    E_exc = E_total - E_zpe\n    \n    # If excitation energy is negative, no states are accessible above ZPE\n    if E_exc  0:\n        return 0\n\n    # Step 3: Discretize energies\n    S = int(np.floor(E_exc / d_eps))\n\n    # Create the expanded list of integer weights for all f oscillators\n    all_weights = []\n    for v, g in zip(freqs, degs):\n        w = int(round(v / d_eps))\n        # The problem statement implies w >= 1, which holds for test cases.\n        if w > 0:\n            all_weights.extend([w] * g)\n\n    # Step 4: Direct count using Beyer-Swinehart algorithm\n    # Initialize density of states array. Python integers have arbitrary precision.\n    density = [0] * (S + 1)\n    density[0] = 1 # There is one state at zero energy (ground state)\n\n    # Iteratively add each oscillator\n    for w in all_weights:\n        for j in range(w, S + 1):\n            density[j] += density[j - w]\n            \n    # Step 5: The sum of states N(E) is the cumulative sum of the density of states rho(j)\n    total_sum_of_states = sum(density)\n    \n    return total_sum_of_states\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'freqs': [1000, 1100, 1200], 'degs': [1, 1, 1], 'E_total': 3300, 'd_eps': 50},\n        # Case 2\n        {'freqs': [500, 800], 'degs': [2, 1], 'E_total': 2000, 'd_eps': 50},\n        # Case 3\n        {'freqs': [400, 600, 700], 'degs': [1, 1, 1], 'E_total': 849, 'd_eps': 1},\n        # Case 4\n        {'freqs': [300], 'degs': [4], 'E_total': 1200, 'd_eps': 100},\n        # Case 5\n        {'freqs': [200, 250, 400, 500], 'degs': [1, 2, 1, 1], 'E_total': 1800, 'd_eps': 50},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_sum_of_states(\n            case['freqs'],\n            case['degs'],\n            case['E_total'],\n            case['d_eps']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2672869"}, {"introduction": "虽然量子态计数是精确的，但经典近似在概念上提供了深刻的洞察，并且在能量较高时是有效的。本练习将态总和与其经典力学起源——系统的可及相空间体积——联系起来，并引入了反应路径简并度 $g^\\ddagger$ 这一关键的对称性因子。通过从第一性原理推导并实现过渡态态总和 $N^\\ddagger(E)$ 的经典公式 [@problem_id:2672895]，您将加深对经典与量子统计力学之间联系的理解及其在速率理论中的应用。", "problem": "给定反应物和过渡态（不包括过渡态的单个虚频模式）的谐振动频率集，以及过渡态区域的可用微正则能量。你的任务是在经典谐振子近似下，构建过渡态的微正则态和，记为 $N^\\ddagger(E)$。你的推导和算法必须仅基于以下基本定义：态数的微正则定义（经典相空间体积除以基本量子相空间单元），独立谐振模式的可分离性，以及频率单位之间的关系。未经这些基本原理证明，不得假设或使用任何预先推导的简化表达式。\n\n假设和数据约定：\n- 所有振动模式都是一维谐振子且可分离。\n- 过渡态振动频率不包括沿反应坐标的单个不稳定（虚频）模式；只提供实频模式。\n- 能量是相对于过渡态区域的经典阈值测量的，忽略了零点能偏移；即，可用能量 $E$ 是非负的，且是相对于经典鞍点测量的。\n- 频率输入以波数形式提供，单位为反厘米（$\\mathrm{cm^{-1}}$）。相应的线性频率（单位：赫兹）通过 $ \\nu = c \\, \\tilde{\\nu} $ 关联，其中 $ \\nu $ 的单位是 $ \\mathrm{s^{-1}} $，$ c $ 是光速，单位是 $ \\mathrm{cm \\ s^{-1}} $，$ \\tilde{\\nu} $ 是波数，单位是 $ \\mathrm{cm^{-1}} $。\n- 微正则可用能量 $E$ 以 $ \\mathrm{kJ \\ mol^{-1}} $ 为单位提供；你必须使用阿伏伽德罗常数将其转换为每个分子的焦耳数。\n\n使用的常数（指定为国际单位制单位）：\n- 普朗克常数：$ h = 6.62607015 \\times 10^{-34} \\ \\mathrm{J \\ s} $。\n- 光速：$ c = 2.99792458 \\times 10^{10} \\ \\mathrm{cm \\ s^{-1}} $。\n- 阿伏伽德罗常数：$ N_\\mathrm{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}} $。\n\n你必须使用的定义基础：\n- 微正则态和是总能量小于或等于 $ E $ 的不同量子态的总数，其计算方法是取能量面包围的经典相空间体积，然后除以 $ s $ 个可分离一维模式的基本量子单元体积 $ h^s $。你必须从此定义出发，利用谐振模式的可分离性以及相空间中能量约束区域的几何形状，来获得 $ N^\\ddagger(E) $ 关于过渡态振动频率和可用能量 $ E $ 的工作表达式。\n\n任务：\n1) 仅使用上述基本定义，为一组具有线性频率 $ \\{ \\nu_i^\\ddagger \\}_{i=1}^{s^\\ddagger} $ 的 $ s^\\ddagger $ 个过渡态谐振模式，在给定可用能量 $ E $（单位：焦耳/分子）和基本常数 $ h $ 和 $ c $ 的情况下，推导出一个可实现的 $ N^\\ddagger(E) $ 表达式。你的推导必须是通用的，并且独立于任何特定的测试用例值。\n2) 给定反应路径简并度 $ g^\\ddagger $（一个等于不可区分反应路径数量的正整数），确定它如何修正 Rice–Ramsperger–Kassel–Marcus (RRKM) 微正则速率表达式的分子项。具体来说，计算 $ g^\\ddagger \\, N^\\ddagger(E) $ 并解释 $ g^\\ddagger $ 是否除了对分子项进行乘法缩放外还影响其他任何部分。\n3) 实现一个程序，对每个测试用例，使用以下数据计算 $ N^\\ddagger(E) $ 和 $ g^\\ddagger \\, N^\\ddagger(E) $ 作为无量纲浮点数：\n   - 过渡态波数 $ \\tilde{\\nu}_i^\\ddagger $，单位 $ \\mathrm{cm^{-1}} $。\n   - 可用能量 $ E $，单位 $ \\mathrm{kJ \\ mol^{-1}} $，需转换为每个分子的焦耳数 $ \\mathrm{J} $。\n   - 反应路径简并度 $ g^\\ddagger $，一个正整数。\n   每个测试用例中也提供了反应物频率以反映典型的 RRKM 上下文，但在此你只需构建分子项；不要在此任务的任何计算中使用反应物频率。\n4) 以六位有效数字的实数形式表示输出。\n\n测试套件：\n为以下四个测试用例提供结果。在每个案例中，使用给定的反应物和过渡态波数（单位 $ \\mathrm{cm^{-1}} $）、可用能量（单位 $ \\mathrm{kJ \\ mol^{-1}} $）和简并度 $ g^\\ddagger $（无单位）：\n- 测试用例 1：\n  - 反应物：$ [300, 500, 700, 1000, 1200, 1400] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [400, 800, 1200, 1500] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 25.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 1 $。\n- 测试用例 2：\n  - 反应物：$ [250, 400, 600, 900, 1100] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [500, 900, 1100] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 50.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 2 $。\n- 测试用例 3：\n  - 反应物：$ [200, 350, 800] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [300, 450] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 0.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 5 $。\n- 测试用例 4：\n  - 反应物：$ [500, 750, 1000] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [1000] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 10.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 3 $。\n\n数值和单位要求：\n- 使用 $ E_\\mathrm{molecule} = \\dfrac{E_\\mathrm{kJ/mol} \\times 10^3}{N_\\mathrm{A}} $ 将能量 $ E $ 从 $ \\mathrm{kJ \\ mol^{-1}} $ 转换为每个分子的焦耳数。\n- 使用 $ c $（单位 $ \\mathrm{cm \\ s^{-1}} $）通过 $ \\nu_i^\\ddagger = c \\, \\tilde{\\nu}_i^\\ddagger $ 将波数 $ \\tilde{\\nu}_i^\\ddagger $ 转换为线性频率。\n- 输出是无量纲的态数，必须以四舍五入到六位有效数字的浮点数形式报告。\n- 本问题不涉及角度。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格的列表的列表形式的结果，其中每个内部列表为相应测试用例包含恰好两个浮点数 $ [N^\\ddagger(E), \\ g^\\ddagger N^\\ddagger(E)] $，顺序与上面列出的一致。例如：$ [[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]] $。", "solution": "该问题要求基于统计力学的基本原理，推导和计算过渡态的经典谐振子态和 $N^\\ddagger(E)$。对问题陈述的验证确认了其科学上的合理性、适定性，并包含了获得唯一解所需的所有信息。我们现在将进行形式化的推导和计算。\n\n分析分为两个部分。首先，给出了 $N^\\ddagger(E)$ 表达式的严格推导。其次，解释了反应路径简并度 $g^\\ddagger$ 的作用。最后，将这些原理应用于所提供的测试用例。\n\n**1. 态和 $N^\\ddagger(E)$ 的推导**\n\n问题要求推导从态和 $N(E)$ 的基本半经典定义开始，即能量小于或等于 $E$ 时系统可用的量子态数量。这可以通过可及经典相空间的体积 $\\mathcal{V}(E)$ 除以单个量子态的体积 $h^s$ 来近似，其中 $s$ 是自由度数。对于具有 $s^\\ddagger$ 个振动模式的过渡态，这表示为：\n$$\nN^\\ddagger(E) = \\frac{\\mathcal{V}(E)}{h^{s^\\ddagger}}\n$$\n此处，$\\mathcal{V}(E)$ 是相空间中的体积，由在总能量不超过 $E$ 的约束下对所有坐标 $q_i$ 和共轭动量 $p_i$ 的积分定义：\n$$\n\\mathcal{V}(E) = \\int_{H(q,p) \\le E} \\prod_{i=1}^{s^\\ddagger} dq_i dp_i\n$$\n该系统由 $s^\\ddagger$ 个可分离的一维谐振子组成。总经典哈密顿量 $H(q,p)$ 是各个振子能量的总和：\n$$\nH(q,p) = \\sum_{i=1}^{s^\\ddagger} E_i(q_i, p_i) = \\sum_{i=1}^{s^\\ddagger} \\left( \\frac{p_i^2}{2m_i} + \\frac{1}{2} k_i q_i^2 \\right)\n$$\n其中 $m_i$ 和 $k_i$ 分别是模式 $i$ 的有效质量和力常数。单个振子的能量可以用其振动频率 $\\nu_i = \\frac{1}{2\\pi}\\sqrt{k_i/m_i}$ 来表示。能量为 $E_i$ 的单个振子的相空间轨迹是一个椭圆。此椭圆所包围的面积，代表了能量*高达* $E_i$ 的单个振子的相空间体积，由 $A_i(E_i) = E_i / \\nu_i$ 给出。\n\n为了计算 $\\mathcal{V}(E)$ 的 $2s^\\ddagger$ 维积分，我们将每个模式 $i$ 的坐标从 $(q_i, p_i)$ 变换为能量-角度坐标 $(E_i, \\phi_i)$。一种这样的变换是 $q_i = \\sqrt{2E_i / k_i} \\sin\\phi_i$ 和 $p_i = \\sqrt{2m_i E_i} \\cos\\phi_i$。相空间面积微元 $dq_i dp_i$ 变换为 $dq_i dp_i = |J| dE_i d\\phi_i$，其中 $J$ 是变换的雅可比行列式。计算雅可比行列式得到 $|J| = 1/(2\\pi\\nu_i)$。对角度 $\\phi_i$ 从 $0$ 到 $2\\pi$ 积分，得到：\n$$\n\\int_0^{2\\pi} |J| d\\phi_i = \\int_0^{2\\pi} \\frac{1}{2\\pi\\nu_i} d\\phi_i = \\frac{1}{\\nu_i}\n$$\n因此，第 $i$ 个模式的体积元对其循环坐标积分后变为 $dE_i / \\nu_i$。总相空间体积积分现在是关于模式能量的积分：\n$$\n\\mathcal{V}(E) = \\int \\dots \\int_{\\sum E_i \\le E, E_i \\ge 0} \\prod_{i=1}^{s^\\ddagger} \\left( \\frac{dE_i}{\\nu_i^\\ddagger} \\right)\n$$\n提出常数项，得到：\n$$\n\\mathcal{V}(E) = \\left( \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger} \\right) \\int_{0 \\le E_1, \\dots, E_{s^\\ddagger}; \\sum E_i \\le E} dE_1 \\dots dE_{s^\\ddagger}\n$$\n剩下的积分代表一个标准的 $s^\\ddagger$ 维单纯形（一个 $s^\\ddagger$ 维超角锥体）的体积，其顶点在原点以及每个能量轴上的 $(E, 0, \\dots)$、$(0, E, \\dots)$ 等点。这样一个几何图形的体积是一个标准结果，由 $E^{s^\\ddagger} / s^\\ddagger!$ 给出。\n\n将此结果代回，总经典相空间体积为：\n$$\n\\mathcal{V}(E) = \\frac{E^{s^\\ddagger}}{s^\\ddagger!} \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger}\n$$\n最后，将 $\\mathcal{V}(E)$ 的这个表达式代入态和的定义中，我们得到过渡态经典谐振子态和所需的公式：\n$$\nN^\\ddagger(E) = \\frac{\\mathcal{V}(E)}{h^{s^\\ddagger}} = \\frac{1}{h^{s^\\ddagger}} \\frac{E^{s^\\ddagger}}{s^\\ddagger!} \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger} = \\frac{E^{s^\\ddagger}}{s^\\ddagger! \\prod_{i=1}^{s^\\ddagger} h\\nu_i^\\ddagger}\n$$\n该表达式在 $E \\ge 0$ 时有效。如果 $E=0$ 且 $s^\\ddagger > 0$，则态和 $N^\\ddagger(0)$ 为 $0$，因为连续相空间中的单个点体积为零。如果 $s^\\ddagger=0$，则乘积为空（值为 1），$0!=1$，且 $E^0=1$，得到 $N^\\ddagger(E)=1$，这正确地表示了一个没有内自由度的单态。\n\n**2. 反应路径简并度 $g^\\ddagger$ 的作用**\n\nRRKM 理论中的微正则速率常数 $k(E)$ 量化了从反应物态通过过渡态到产物态的通过速率。速率常数的完整表达式为：\n$$\nk(E) = g^\\ddagger \\frac{N^\\ddagger(E)}{h \\rho(E)}\n$$\n其中 $\\rho(E)$ 是反应物分子的态密度。因子 $g^\\ddagger$ 是反应路径简并度，是一个用于对称性校正的正整数。它表示反应可以进行的、不同的但物理上不可区分的方式的数量。例如，一个自由基从甲烷（$\\mathrm{CH_4}$）中夺取一个氢原子，可以在四个等效氢原子中的任何一个上发生，因此 $g^\\ddagger=4$。\n\n$g^\\ddagger$ 的作用是计算总通量。$N^\\ddagger(E)$ 项是*单个*过渡态结构的态和。如果存在多个这样的等效结构，则总通量是流经每个通道的通量之和。由于所有通道都是不可区分的，这等同于将通过一个通道的通量乘以通道数 $g^\\ddagger$。因此，$g^\\ddagger$ 充当 RRKM 表达式分子项的一个简单乘法缩放因子。它不改变 $N^\\ddagger(E)$ 本身的计算。需要计算的量是 $g^\\ddagger N^\\ddagger(E)$，它代表所有等效反应路径上的总态和。\n\n**3. 实现与计算**\n\n实现推导出的公式来解决测试用例。所需步骤如下：\n- 使用提供的常数：普朗克常数 $h = 6.62607015 \\times 10^{-34} \\ \\mathrm{J \\ s}$，光速 $c = 2.99792458 \\times 10^{10} \\ \\mathrm{cm \\ s^{-1}}$，以及阿伏伽德罗常数 $N_\\mathrm{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$。\n- 通过 $E_\\mathrm{J} = (E_{\\mathrm{kJ/mol}} \\times 1000) / N_\\mathrm{A}$ 将可用能量 $E$ 从 $\\mathrm{kJ \\ mol^{-1}}$ 转换为每个分子的焦耳数。\n- 通过 $\\nu_i^\\ddagger = c \\tilde{\\nu}_i^\\ddagger$ 将过渡态波数 $\\tilde{\\nu}_i^\\ddagger$ (单位 $\\mathrm{cm^{-1}}$) 转换为线性频率 $\\nu_i^\\ddagger$ (单位 $\\mathrm{s^{-1}}$)。\n- 应用推导出的 $N^\\ddagger(E)$ 公式，并按要求乘以 $g^\\ddagger$。最终结果以六位有效数字呈现。根据问题范围，此计算中不使用反应物频率。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Calculates the classical harmonic sum of states for the transition state N‡(E)\n    and the product with the reaction path degeneracy g‡N‡(E).\n    \"\"\"\n\n    # Fundamental Constants (SI units, except for c)\n    H_PLANCK = 6.62607015e-34  # J s\n    C_LIGHT = 2.99792458e10   # cm s^-1\n    N_AVOGADRO = 6.02214076e23 # mol^-1\n\n    # Test cases as provided in the problem statement.\n    # Format: (reactant_wavenumbers, ts_wavenumbers, energy_kj_mol, degeneracy)\n    # Reactant wavenumbers are included for context but not used in the calculation.\n    test_cases = [\n        ([300, 500, 700, 1000, 1200, 1400], [400, 800, 1200, 1500], 25.0, 1),\n        ([250, 400, 600, 900, 1100], [500, 900, 1100], 50.0, 2),\n        ([200, 350, 800], [300, 450], 0.0, 5),\n        ([500, 750, 1000], [1000], 10.0, 3),\n    ]\n\n    results = []\n\n    for _, ts_wavenumbers, E_kj_mol, g_ddagger in test_cases:\n        \n        # 1. Determine the number of transition state vibrational modes\n        s_ddagger = len(ts_wavenumbers)\n        \n        # 2. Convert energy from kJ/mol to J/molecule\n        E_joules = (E_kj_mol * 1000) / N_AVOGADRO\n        \n        # 3. Calculate N_ddagger(E) using the derived formula:\n        # N_ddagger(E) = E^s / (s! * product(h*nu_i))\n        \n        if s_ddagger > 0 and E_joules == 0.0:\n            # For E=0 and s>0, the classical phase space volume is zero.\n            N_ddagger = 0.0\n        elif s_ddagger == 0:\n            # Case with no vibrational modes: N(E) = 1 for E >= 0\n            N_ddagger = 1.0\n        else:\n            # Convert wavenumbers (cm^-1) to linear frequencies (s^-1)\n            # and compute the product of h*nu_i\n            # product(h*nu_i) = product(h*c*nu_tilde_i) = (h*c)^s * product(nu_tilde_i)\n            \n            # Using numpy for product calculation for conciseness\n            product_of_wavenumbers = np.prod(ts_wavenumbers)\n            \n            # h*c in J*cm\n            hc_const = H_PLANCK * C_LIGHT \n            \n            product_h_nu = (hc_const ** s_ddagger) * product_of_wavenumbers\n            \n            s_factorial = math.factorial(s_ddagger)\n            \n            numerator = E_joules ** s_ddagger\n            denominator = s_factorial * product_h_nu\n            \n            if denominator == 0:\n                # Should not happen with valid physical inputs\n                N_ddagger = float('inf') if numerator > 0 else 0.0\n            else:\n                N_ddagger = numerator / denominator\n\n        # 4. Calculate g_ddagger * N_ddagger(E)\n        g_N_ddagger = g_ddagger * N_ddagger\n        \n        results.append([N_ddagger, g_N_ddagger])\n\n    # Format the final output string according to the problem specification.\n    # Each value is formatted to 6 significant figures.\n    output_parts = []\n    for pair in results:\n        # Using .6g for 6 significant figures\n        formatted_pair = f\"[{pair[0]:.6g},{pair[1]:.6g}]\"\n        output_parts.append(formatted_pair)\n        \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2672895"}, {"introduction": "数值计算出的 RRKM 速率常数的准确性，在很大程度上取决于所选的计算参数，例如能量网格的间距。本练习建立在态计数方法之上，要求您计算完整的微正则速率常数 $k(E)$，并系统性地分析其结果如何随能量划分的粒度 $\\Delta E$ 而收敛。这项高级实践 [@problem_id:2672898] 将教会您如何确保计算结果的数值稳健性，这对于在计算动力学研究中获得可靠结论至关重要。", "problem": "你需要编写一个完整、可运行的程序，评估能量离散化粒度（表示为 $\\Delta E$）对微正则振动态密度 $\\rho(E)$ 和过渡态态总和 $N^\\ddagger(E)$ 的数值估计有何影响，然后利用此分析来检验 Rice–Ramsperger–Kassel–Marcus (RRKM) 微正则速率常数 $k(E)$ 的收敛性。你的实现必须基于下述的可分离量子谐振子的第一性原理，并且不得依赖任何 $\\rho(E)$ 或 $N^\\ddagger(E)$ 的闭合形式表达式。\n\n模型和所需计算的基本依据：\n- 考虑一个非线性分子，在反应物中有 $s$ 个独立的量子谐振动模式，在过渡态中有 $s^\\ddagger=s-1$ 个此类模式（在过渡态不包括反应坐标）。\n- 反应物的振动频率以逆厘米（$\\mathrm{cm^{-1}}$）为单位给出，记为 $\\tilde{\\nu}_i$，其中 $i=1,\\dots,s$。过渡态的振动频率以逆厘米为单位给出，记为 $\\tilde{\\nu}^\\ddagger_j$，其中 $j=1,\\dots,s^\\ddagger$。\n- 每个模式的振动能级是量子谐振子的能级；在此任务中，忽略零点能位移，并将可及能量视为 $h c \\tilde{\\nu}$ 的非负整数倍，其中 $h$ 是普朗克常数，$c$ 是光速。\n- 微正则振动态密度 $\\rho(E)$ 是在总能量为 $E$ 时单位能量的态数，你必须通过将能量离散化为宽度为 $\\Delta E$（单位为 $\\mathrm{cm^{-1}}$）的能量箱，统计落入每个箱中的构型数量，然后除以以焦耳为单位的箱宽，来对其进行数值近似。\n- 过渡态态总和 $N^\\ddagger(E)$ 是能量小于或等于 $E$ 的过渡态振动总态数，通过对各能量箱中的过渡态构型计数进行累积求和来获得。\n- 微正则速率常数 $k(E)$ 需要在 RRKM 框架内，以量纲一致的方式根据这些态数计算得出，并使用普朗克常数 $h$ 来设定时间尺度。仅可使用数值方法得到的 $\\rho(E)$ 和 $N^\\ddagger(\\cdot)$ 计算 $k(E)$，确保最终单位为 $\\mathrm{s^{-1}}$。\n- 请精确使用以下指定的物理常数：$h = 6.62607015\\times 10^{-34}\\,\\mathrm{J\\,s}$，$c = 2.99792458\\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$。将 $1\\,\\mathrm{cm^{-1}}$ 视为 $100\\,\\mathrm{m^{-1}}$。所有从 $\\mathrm{cm^{-1}}$ 到焦耳的内部转换必须使用 $E\\,[\\mathrm{J}] = h\\,c\\,\\tilde{\\nu}\\,[\\mathrm{m^{-1}}]$。\n\n离散数值模型要求：\n- 通过对模式进行离散卷积来实现可分离振动的态计数。\n- 设能量网格为 $E_k = k\\,\\Delta E$（单位为 $\\mathrm{cm^{-1}}$），其中 $k=0,1,\\dots,K$，并选择足够大的 $K$ 以覆盖最大相关能量。\n- 对于每个频率为 $\\tilde{\\nu}$ 的模式，允许的模式能量（忽略零点贡献）为 $n\\,\\tilde{\\nu}$，其中整数 $n\\ge 0$。将每个允许的 $n\\,\\tilde{\\nu}$ 映射到最近的能量箱索引 $k=\\mathrm{round}\\!\\left(\\dfrac{n\\,\\tilde{\\nu}}{\\Delta E}\\right)$，并增加该箱的棒谱计数。将所有模式的棒谱进行卷积，以获得直至所需最大能量的反应物态的箱式计数 $g(E_k)$ 和过渡态计数 $g^\\ddagger(E_k)$。\n- 在目标能量 $E$ 处，通过 $\\rho(E)\\approx g(E_k)/\\Delta E_{\\mathrm{J}}$ 来近似 $\\rho(E)$，其中 $\\Delta E_{\\mathrm{J}}=h\\,c\\,(100\\,\\Delta E)$ 是以焦耳为单位的箱宽，并使用最近的箱索引 $k=\\mathrm{round}(E/\\Delta E)$。\n- 通过对 $g^\\ddagger(E_k)$ 的箱进行累积求和来近似 $N^\\ddagger(E)$，同样对目标 $E$ 使用最近箱索引。\n- 引入一个经典势垒高度 $E_0$（单位为 $\\mathrm{cm^{-1}}$）。对于总能量为 $E$ 时的速率常数，使用可用的过渡态能量 $E-E_0$。对于 $EE_0$，将可及的过渡态态总和视为零。\n\n模型参数和测试套件：\n- 使用 $s=6$ 个反应物振动模式，频率（单位为 $\\mathrm{cm^{-1}}$）为：$[300,\\,400,\\,500,\\,700,\\,900,\\,1100]$。\n- 使用 $s^\\ddagger=5$ 个过渡态振动模式，频率（单位为 $\\mathrm{cm^{-1}}$）为：$[200,\\,350,\\,600,\\,800,\\,1000]$。\n- 使用势垒高度 $E_0=1500\\,\\mathrm{cm^{-1}}$。\n- 在以下能量（单位为 $\\mathrm{cm^{-1}}$）处评估 $k(E)$：$[1400,\\,1500,\\,3000,\\,5000]$。\n- 待使用的离散化粒度 $\\Delta E$（单位为 $\\mathrm{cm^{-1}}$）包括一个作为数值参考的最精细网格：选择 $\\Delta E_\\mathrm{ref}=12.5\\,\\mathrm{cm^{-1}}$，以及候选值 $\\Delta E\\in\\{200.0,\\,100.0,\\,50.0,\\,25.0,\\,12.5\\}$。\n- 需要实现和测试的收敛准则：对于给定的 $\\Delta E$，令 $k_{\\Delta E}(E)$ 表示计算出的速率，令 $k_{\\Delta E_\\mathrm{ref}}(E)$ 为最精细网格上的参考速率。将指定 $E$ 值上的最大相对偏差定义为\n$$\n\\varepsilon(\\Delta E)=\\max_{E\\ \\mathrm{in\\ test\\ set}}\n\\begin{cases}\n\\dfrac{\\left|k_{\\Delta E}(E)-k_{\\Delta E_\\mathrm{ref}}(E)\\right|}{k_{\\Delta E_\\mathrm{ref}}(E)},  k_{\\Delta E_\\mathrm{ref}}(E)0,\n\\\\[6pt]\n0,  k_{\\Delta E_\\mathrm{ref}}(E)=0\\ \\text{and}\\ k_{\\Delta E}(E)=0,\n\\\\[6pt]\n+\\infty,  k_{\\Delta E_\\mathrm{ref}}(E)=0\\ \\text{and}\\ k_{\\Delta E}(E)0.\n\\end{cases}\n$$\n如果 $\\varepsilon(\\Delta E)\\le \\tau$，则声明 $\\Delta E$ 在容差 $\\tau$ 下“已收敛”。\n- 需要评估并以布尔值报告的测试用例如下，为 $(\\Delta E,\\tau)$ 对：\n    1. $(200.0,\\,0.2)$\n    2. $(100.0,\\,0.1)$\n    3. $(50.0,\\,0.05)$\n    4. $(25.0,\\,0.05)$\n    5. $(25.0,\\,0.02)$\n    6. $(12.5,\\,0.02)$\n\n要求的输出和格式：\n- 你的程序必须计算每个 $\\Delta E$ 和每个指定能量 $E$ 对应的 $k(E)$（单位为 $\\mathrm{s^{-1}}$），然后针对 $\\Delta E_\\mathrm{ref}$ 基准评估每个测试用例的 $\\varepsilon(\\Delta E)$，最后为每个测试对 $(\\Delta E,\\tau)$ 返回一个布尔值，指示是否满足收敛准则。\n- 最终输出必须是一行，包含与给定顺序的六个测试用例相对应的布尔值列表，以逗号分隔的 Python 风格列表形式打印在一行上，例如 $[\\mathrm{True},\\mathrm{False},\\dots]$。\n- 不允许用户输入；所有参数均如上指定。程序必须是自包含的，并且仅使用提供的常数。所有中间计算必须遵守所述单位；最终的布尔值是无单位的。", "solution": "所提出的问题要求对 Rice–Ramsperger–Kassel–Marcus (RRKM) 微正则速率常数 $k(E)$ 相对于能量离散化网格尺寸 $\\Delta E$ 的收敛性进行数值研究。该问题定义明确，在统计力学和化学动力学原理上具有科学依据，并为获得唯一、可验证的解提供了所有必要的参数。我们将着手解决此问题。\n\n对于总能量为 $E$ 的分子，RRKM 速率常数的基本表达式为：\n$$\nk(E) = \\frac{N^\\ddagger(E - E_0)}{h \\rho(E)}\n$$\n这里，$h$ 是普朗克常数，$E_0$ 是反应的经典势垒高度，$\\rho(E)$ 是反应物分子在能量 $E$ 时的振动态密度，$N^\\ddagger(E - E_0)$ 是过渡态的可及振动总态数（态总和），其在势垒之上的可用能量为 $E - E_0$。\n\n我们的模型将分子视为反应物中 $s$ 个可分离量子谐振子的集合，以及过渡态中 $s^\\ddagger = s-1$ 个谐振子的集合。具有频率 $\\tilde{\\nu}$ 的单个谐振子的能量是量子化的，由 $\\epsilon_n = n h c \\tilde{\\nu}$ 给出，我们按照指示忽略了零点能。分子的总振动能是个别模式能量的总和：$E = \\sum_{i=1}^s n_i h c \\tilde{\\nu}_i$。\n\n问题的核心是数值计算 $\\rho(E)$ 和 $N^\\ddagger(E)$。禁止使用诸如 Beyer-Swinehart 算法或 Whitten-Rabinovitch 近似等公式进行直接解析计算。相反，我们必须使用基于离散卷积的直接计数方法，这是一种针对可分离系统的数值第一性原理方法。\n\n步骤如下：\n\n1.  **能量网格离散化**：我们定义一个具有均匀间距 $\\Delta E$（单位为 $\\mathrm{cm^{-1}}$）的离散能量网格。网格点 $k$ 处的能量为 $E_k = k \\Delta E$。此网格的最大能量 $E_\\mathrm{max}$ 必须选择得足够大，以容纳所有必需的计算，包括最高的评估能量和卷积效应。\n\n2.  **通过卷积进行态计数**：\n    *   对于每个频率为 $\\tilde{\\nu}_i$ 的独立振动模式 $i$，我们构建一个“棒谱”。这是一个表示能量网格的数组，我们在对应于允许能级的每个箱索引处放置一个计数 $1$。能量 $\\epsilon = n \\tilde{\\nu}_i$ 的箱索引 $k$ 由最近箱原则确定：$k = \\mathrm{round}(n \\tilde{\\nu}_i / \\Delta E)$。\n    *   反应物在每个能量箱 $k$ 中的总态数 $g(E_k)$ 是总能量 $E_k$ 可以分配给 $s$ 个模式的方式数。对于可分离模式，这在数学上等同于各个模式棒谱的离散卷积。我们从一个模式的谱开始，然后迭代地将其与其余模式的谱进行卷积。令 $g_i$ 为模式 $i$ 的棒谱。总“简并度”函数为 $g = g_1 * g_2 * \\dots * g_s$，其中 $*$ 表示卷积。结果必须截断至我们的能量网格大小。\n    *   对 $s^\\ddagger$ 个过渡态模式应用相同的过程，以获得它们的简并度函数 $g^\\ddagger(E_k)$。\n\n3.  **$\\rho(E)$ 和 $N^\\ddagger(E)$ 的计算**：\n    *   态密度 $\\rho(E)$ 是单位能量的态数。我们通过取相应箱的计数 $g(E_k)$（其中 $k=\\mathrm{round}(E/\\Delta E)$），并除以以焦耳为单位的箱宽 $\\Delta E_{\\mathrm{J}}$ 来近似它。转换公式为 $\\Delta E_{\\mathrm{J}} = h c (100 \\Delta E)$，其中 $\\Delta E$ 的单位是 $\\mathrm{cm^{-1}}$，因子 $100$ 将 $\\mathrm{cm^{-1}}$ 转换为 $\\mathrm{m^{-1}}$。\n    $$\n    \\rho(E) \\approx \\frac{g(\\mathrm{round}(E/\\Delta E))}{\\Delta E_{\\mathrm{J}}} = \\frac{g(\\mathrm{round}(E/\\Delta E))}{h c (100 \\Delta E)}\n    $$\n    *   态总和 $N^\\ddagger(E)$ 是能量小于或等于 $E$ 的总态数。这可以通过对过渡态简并度 $g^\\ddagger$ 的累积和来近似，直至对应于 $E$ 的箱。\n    $$\n    N^\\ddagger(E) \\approx \\sum_{j=0}^{\\mathrm{round}(E/\\Delta E)} g^\\ddagger(j)\n    $$\n\n4.  **速率常数 $k(E)$ 的计算**：我们将这些数值量代入 RRKM 表达式中。\n    $$\n    k(E) = \\frac{N^\\ddagger(E - E_0)}{h \\rho(E)} \\approx \\frac{\\left( \\sum_{j=0}^{\\mathrm{round}((E-E_0)/\\Delta E)} g^\\ddagger(j) \\right) \\cdot c \\cdot (100 \\Delta E)}{g(\\mathrm{round}(E/\\Delta E))}\n    $$\n    如果 $E  E_0$，可用能量 $E-E_0$ 为负，意味着没有可及的过渡态，因此 $N^\\ddagger(E-E_0) = 0$ 且 $k(E)=0$。当 $g(\\mathrm{round}(E/\\Delta E))$ 为零时，速率常数形式上是无限大的，尽管这在物理上是不现实的，并且对于所关注能量的多原子分子来说不太可能发生。\n\n5.  **收敛性分析**：最后一步是系统地评估一组递减的粒度大小 $\\Delta E = \\{200.0, 100.0, 50.0, 25.0, 12.5\\}\\,\\mathrm{cm^{-1}}$ 的速率常数。最精细网格 $\\Delta E_\\mathrm{ref} = 12.5\\,\\mathrm{cm^{-1}}$ 的结果作为基准。对于每个更粗的 $\\Delta E$，我们计算在指定测试能量 $E$ 上的最大相对偏差 $\\varepsilon(\\Delta E)$。\n    $$\n    \\varepsilon(\\Delta E) = \\max_{E \\in \\text{test set}} \\frac{|k_{\\Delta E}(E) - k_{\\Delta E_\\mathrm{ref}}(E)|}{|k_{\\Delta E_\\mathrm{ref}}(E)|}\n    $$\n    对于 $k_{\\Delta E_\\mathrm{ref}}(E) = 0$ 的情况需要特殊处理。然后，我们将 $\\varepsilon(\\Delta E)$ 与几个 $(\\Delta E, \\tau)$ 对的给定容差 $\\tau$ 进行比较，以确定是否满足收敛准则。整个过程将在一个程序中实现，以产生所需的布尔值输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RRKM convergence problem by numerically computing state densities\n    and sums of states, calculating rate constants, and testing convergence.\n    \"\"\"\n    # Physical Constants\n    H_PLANCK = 6.62607015e-34  # J*s\n    C_SPEED = 2.99792458e8  # m/s\n\n    # Model Parameters\n    NU_REACTANT_CM_INV = [300.0, 400.0, 500.0, 700.0, 900.0, 1100.0]  # cm^-1\n    NU_TS_CM_INV = [200.0, 350.0, 600.0, 800.0, 1000.0]  # cm^-1\n    E0_CM_INV = 1500.0  # cm^-1\n    \n    # Evaluation Parameters\n    EVAL_ENERGIES_CM_INV = [1400.0, 1500.0, 3000.0, 5000.0]\n    DELTA_E_CANDIDATES = [200.0, 100.0, 50.0, 25.0, 12.5]\n    DELTA_E_REF = 12.5\n    E_MAX_CM_INV = 6000.0  # Maximum energy for the grid\n\n    # Test Cases for convergence: (delta_e, tolerance)\n    test_cases = [\n        (200.0, 0.2),\n        (100.0, 0.1),\n        (50.0, 0.05),\n        (25.0, 0.05),\n        (25.0, 0.02),\n        (12.5, 0.02),\n    ]\n\n    def compute_state_counts(frequencies, delta_e, e_max):\n        \"\"\"\n        Computes the binned number of states g(E_k) via convolution.\n        \"\"\"\n        grid_size = int(np.ceil(e_max / delta_e)) + 1\n        \n        # Initialize total counts with the spectrum of the first mode\n        freq_iter = iter(frequencies)\n        try:\n            nu1 = next(freq_iter)\n        except StopIteration: # Handle empty frequency list\n            total_counts = np.zeros(grid_size)\n            total_counts[0] = 1.0\n            return total_counts\n\n        total_counts = np.zeros(grid_size)\n        n = 0\n        while True:\n            energy = n * nu1\n            if energy > e_max:\n                break\n            bin_index = int(np.round(energy / delta_e))\n            if bin_index  grid_size:\n                total_counts[bin_index] += 1\n            n += 1\n\n        # Convolve with remaining modes\n        for nu in freq_iter:\n            mode_counts = np.zeros(grid_size)\n            n = 0\n            while True:\n                energy = n * nu\n                if energy > e_max:\n                    break\n                bin_index = int(np.round(energy / delta_e))\n                if bin_index  grid_size:\n                    mode_counts[bin_index] += 1\n                n += 1\n            \n            total_counts = np.convolve(total_counts, mode_counts)[:grid_size]\n            \n        return total_counts\n\n    def compute_rate_constants(delta_e):\n        \"\"\"\n        Computes RRKM rate constant k(E) for all evaluation energies.\n        \"\"\"\n        g_reactant = compute_state_counts(NU_REACTANT_CM_INV, delta_e, E_MAX_CM_INV)\n        g_ts = compute_state_counts(NU_TS_CM_INV, delta_e, E_MAX_CM_INV)\n        n_ts_cumulative = np.cumsum(g_ts)\n        \n        rates = []\n        for e_cm_inv in EVAL_ENERGIES_CM_INV:\n            if e_cm_inv  E0_CM_INV:\n                rates.append(0.0)\n                continue\n\n            e_avail_cm_inv = e_cm_inv - E0_CM_INV\n\n            # Get reactant density of states term (proportional to g)\n            k_e_reactant = int(np.round(e_cm_inv / delta_e))\n            if k_e_reactant >= len(g_reactant) or g_reactant[k_e_reactant] == 0:\n                # Density of states is zero, rate is infinite (or undefined)\n                # Physically, for E > 0, density should be non-zero for polyatomics\n                rates.append(np.inf)\n                continue\n            \n            g_val = g_reactant[k_e_reactant]\n\n            # Get transition state sum of states\n            k_e_ts = int(np.round(e_avail_cm_inv / delta_e))\n            if k_e_ts  0:\n                 n_ts_val = 0.0\n            elif k_e_ts >= len(n_ts_cumulative):\n                 # Energy is beyond grid, use last available sum of states\n                 n_ts_val = n_ts_cumulative[-1]\n            else:\n                 n_ts_val = n_ts_cumulative[k_e_ts]\n\n            # Calculate rate constant\n            # k(E) = N_ts(E-E0) / (h * rho(E))\n            # rho(E) approx g(E) / (h*c*100*delta_E)\n            # k(E) approx (N_ts * c * 100 * delta_E) / g(E)\n            rate = (n_ts_val * C_SPEED * 100.0 * delta_e) / g_val\n            rates.append(rate)\n        \n        return np.array(rates)\n\n    # Calculate rate constants for all delta_e values\n    k_results = {}\n    for de in DELTA_E_CANDIDATES:\n        k_results[de] = compute_rate_constants(de)\n\n    # Perform convergence analysis\n    k_ref_rates = k_results[DELTA_E_REF]\n    final_booleans = []\n\n    for delta_e_test, tolerance in test_cases:\n        k_test_rates = k_results[delta_e_test]\n        \n        relative_errors = []\n        for k_test, k_ref in zip(k_test_rates, k_ref_rates):\n            if k_ref > 0:\n                rel_err = np.abs(k_test - k_ref) / k_ref\n            elif k_ref == 0 and k_test == 0:\n                rel_err = 0.0\n            else: # k_ref is 0 and k_test > 0\n                rel_err = np.inf\n            relative_errors.append(rel_err)\n        \n        max_rel_err = np.max(relative_errors)\n        is_converged = max_rel_err = tolerance\n        final_booleans.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_booleans))}]\")\n\nsolve()\n```", "id": "2672898"}]}