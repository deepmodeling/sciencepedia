{"hands_on_practices": [{"introduction": "本练习是一项基础的分析任务，旨在巩固对 Briggs-Haldane 准稳态近似（QSSA）的理解。通过从头推导米氏常数（$K_M$）的表达式，并将其与底物的热力学解离常数（$K_D$）进行比较，您将揭示 $K_M$ 不仅仅是酶-底物亲和力量度的原因。这项实践对于深刻理解酶动力学模型背后的核心假设至关重要 [@problem_id:2641264]。", "problem": "考虑在确定性、良好混合、等温条件下的基本酶促反应网络：\n$$\nE + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P,\n$$\n其中 $E$ 是游离酶，$S$ 是底物，$ES$ 是酶-底物复合物，$P$ 是产物。速率常数 $k_{1}$、$k_{-1}$ 和 $k_{2}$ 均为严格正值。令总酶浓度为 $E_{T}$，因此有 $E_{T} = [E] + [ES]$。对于结合步骤 $E + S \\rightleftharpoons ES$，定义平衡解离常数 $K_{D} \\equiv \\frac{k_{-1}}{k_{1}}$。\n\n一位实验者在固定的 $E_{T}$ 下，测量了初始反应速率 $v_{0} \\equiv \\left.\\frac{d[P]}{dt}\\right|_{t \\to 0^{+}}$ 作为初始底物浓度 $S_{0}$ 的函数，并将得到的 $v_{0}$ 对 $S_{0}$ 的数据拟合成以下形式的单底物双曲线：\n$$\nv_{0} = V \\,\\frac{S_{0}}{S_{0} + K_{M}^{\\mathrm{fit}}},\n$$\n其中 $V$ 和 $K_{M}^{\\mathrm{fit}}$ 是拟合参数。假设在初始速率测量的时间尺度上，$[ES]$ 的初始瞬态是可忽略的，因此 Briggs–Haldane 准稳态近似 (QSSA) 成立。\n\n从基本步骤的质量作用定律和对 $[ES]$ 的准稳态近似出发，推导 $v_{0}(S_{0})$ 的表达式，并由此用 $k_{1}$、$k_{-1}$ 和 $k_{2}$ 来表示 $K_{M}^{\\mathrm{fit}}$。利用此结果，确定乘性偏差因子 $B \\equiv \\frac{K_{M}^{\\mathrm{fit}}}{K_{D}}$ 的一个闭式表达式。该因子量化了当 $k_{2}$ 不可忽略时，所产生的与 $K_{D} = K_{M}^{\\mathrm{fit}}$ 的偏差。你的最终答案必须是这个关于 $B$ 的单一解析表达式。不要提供不等式或文字描述。不需要进行数值计算。", "solution": "所述问题是有效的。这是一个化学动力学中的经典练习，特别是 Michaelis-Menten 方程的 Briggs-Haldane 公式的推导。各项假设在科学上是合理的、内部一致的，并且足以推导出一个唯一且有意义的解。\n\n我们首先根据应用于反应网络 $E + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P$ 各基本步骤的质量作用定律，建立描述所涉及物种浓度随时间演化的常微分方程组。酶-底物复合物 $[ES]$ 和产物 $[P]$ 的浓度变化率由下式给出：\n$$\n\\frac{d[ES]}{dt} = k_{1}[E][S] - k_{-1}[ES] - k_{2}[ES]\n$$\n$$\n\\frac{d[P]}{dt} = k_{2}[ES]\n$$\n问题要求计算初始反应速率 $v_{0}$，其定义为时间 $t \\to 0^{+}$ 时的产物生成速率。在此初始阶段，底物浓度 $[S]$ 等于其初始值 $S_{0}$，因此我们有 $[S](t=0) = S_{0}$。因此，初始速率为 $v_{0} = \\left.\\frac{d[P]}{dt}\\right|_{t \\to 0^{+}} = k_{2}[ES]_{ss}$，其中 $[ES]_{ss}$ 是酶-底物复合物的准稳态浓度。\n\nBriggs-Haldane 分析的核心是准稳态近似 (QSSA)。该近似假设在一个非常短暂的初始瞬态期之后，中间复合物 $[ES]$ 的浓度大致保持恒定。在数学上，这表示为 $\\frac{d[ES]}{dt} \\approx 0$。将此应用于初始条件下的 $[ES]$ 速率方程，得到：\n$$\nk_{1}[E]_{0}[S]_{0} - (k_{-1} + k_{2})[ES]_{ss} = 0\n$$\n此处，$[E]_{0}$ 是达到稳态时游离酶的浓度。对于初始速率测量，我们使用 $[S]_{0} = S_{0}$。\n\n如问题所述，该体系还受总酶守恒的约束：$E_{T} = [E] + [ES]$。此关系在任何时候都成立。因此，我们可以将游离酶浓度表示为 $[E] = E_{T} - [ES]$。将此代入稳态方程，得到：\n$$\nk_{1}(E_{T} - [ES]_{ss})S_{0} - (k_{-1} + k_{2})[ES]_{ss} = 0\n$$\n我们的目标是解这个关于 $[ES]_{ss}$ 的代数方程。展开各项，我们得到：\n$$\nk_{1}E_{T}S_{0} - k_{1}[ES]_{ss}S_{0} - (k_{-1} + k_{2})[ES]_{ss} = 0\n$$\n合并含有 $[ES]_{ss}$ 的项：\n$$\nk_{1}E_{T}S_{0} = [ES]_{ss}(k_{1}S_{0} + k_{-1} + k_{2})\n$$\n解出 $[ES]_{ss}$：\n$$\n[ES]_{ss} = \\frac{k_{1}E_{T}S_{0}}{k_{-1} + k_{2} + k_{1}S_{0}}\n$$\n现在我们可以写出初始速率 $v_{0} = k_{2}[ES]_{ss}$ 的表达式：\n$$\nv_{0} = k_{2}\\left(\\frac{k_{1}E_{T}S_{0}}{k_{-1} + k_{2} + k_{1}S_{0}}\\right)\n$$\n为了使该表达式与问题中提供的标准双曲线形式一致，我们将分数部分的分子和分母同除以 $k_{1}$：\n$$\nv_{0} = k_{2}E_{T}\\left(\\frac{S_{0}}{\\frac{k_{-1} + k_{2}}{k_{1}} + S_{0}}\\right)\n$$\n这个推导出的 $v_{0}$ 作为 $S_{0}$ 函数的方程就是 Briggs-Haldane 方程。问题陈述实验数据被拟合成 $v_{0} = V \\,\\frac{S_{0}}{S_{0} + K_{M}^{\\mathrm{fit}}}$ 的形式。通过将此函数形式与我们推导的方程直接比较，我们可以用基本速率常数和总酶浓度来确定拟合参数：\n$$\nV = k_{2}E_{T}\n$$\n$$\nK_{M}^{\\mathrm{fit}} = \\frac{k_{-1} + k_{2}}{k_{1}}\n$$\n这个 $K_{M}^{\\mathrm{fit}}$ 的表达式是在 QSSA 下的广义米氏常数。\n\n问题要求计算乘性偏差因子 $B$，其定义为实验拟合的米氏常数 $K_{M}^{\\mathrm{fit}}$ 与平衡解离常数 $K_{D}$ 的比值。$K_{D}$ 的定义为 $K_{D} \\equiv \\frac{k_{-1}}{k_{1}}$。我们现在可以构建 $B$ 的表达式：\n$$\nB \\equiv \\frac{K_{M}^{\\mathrm{fit}}}{K_{D}} = \\frac{\\left(\\frac{k_{-1} + k_{2}}{k_{1}}\\right)}{\\left(\\frac{k_{-1}}{k_{1}}\\right)}\n$$\n由于速率常数 $k_{1}$ 和 $k_{-1}$ 均为严格正值，我们可以通过消去公因子 $k_{1}$ 来简化表达式：\n$$\nB = \\frac{k_{-1} + k_{2}}{k_{-1}}\n$$\n将此分数分成两项，得到最终的闭式表达式：\n$$\nB = \\frac{k_{-1}}{k_{-1}} + \\frac{k_{2}}{k_{-1}} = 1 + \\frac{k_2}{k_{-1}}\n$$\n此结果表明，实验测得的米氏常数 $K_{M}^{\\mathrm{fit}}$ 总是大于或等于真实的热力学解离常数 $K_{D}$，因为 $k_{2}$ 和 $k_{-1}$ 均为严格正值。由项 $\\frac{k_{2}}{k_{-1}}$ 量化的、与 1 的偏差，是催化步骤 ($k_{2}$) 相对于复合物解离速率 ($k_{-1}$) 不可忽略的直接结果。仅在 $k_{2} \\ll k_{-1}$ 的极限情况下，才能恢复 Michaelis-Menten 的快速平衡假设，即 $K_{M} = K_{D}$。", "answer": "$$\\boxed{1 + \\frac{k_{2}}{k_{-1}}}$$", "id": "2641264"}, {"introduction": "在理论推导的基础上，本练习将引导您进入计算领域，以验证准稳态近似的有效性。您将通过数值模拟，同时求解完整的质量作用动力学方程组和简化的米氏-孟顿方程，从而直观地比较两者的行为 [@problem_id:2641303]。这项实践不仅让您“看到”近似在何时成立，还能量化其引入的误差，从而对模型的准确性和局限性有更具体的认识。", "problem": "考虑经典的单底物酶促反应网络，该网络遵循质量作用定律：$E + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} C \\stackrel{k_2}{\\longrightarrow} E + P$，其中 $E$ 是游离酶，$S$ 是底物，$C$ 是酶-底物复合物，$P$ 是产物。假设系统混合均匀、体积恒定，初始条件为 $s(0) = s_0$、$e(0) = e_0$、$c(0) = 0$、$p(0) = 0$，其中小写符号表示浓度。浓度单位为 $\\mu\\mathrm{M}$，时间单位为 $\\mathrm{s}$，$k_1$ 的单位为 $\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1}$ 和 $k_2$ 的单位为 $\\mathrm{s}^{-1}$。假设 $s_0 \\gg e_0$ 且 $k_{-1} \\sim k_2$。\n\n您的任务是：\n- 根据质量作用定律和总酶守恒，推导出 $s(t)$ 和 $c(t)$ 的完整质量作用常微分方程 (ODEs)。\n- 使用 Briggs-Haldane 准稳态近似 (QSSA)，其中复合物 $c(t)$ 相对于 $s(t)$ 快速趋近于一个准稳态流形，推导出仅关于 $s(t)$ 的简化 ODE。\n- 对完整系统和 QSSA 简化系统在反应全程进行数值模拟，并量化两种模型之间底物浓度 $s(t)$ 的最大绝对误差。\n\n模拟协议规范：\n- 将反应时长定义为 QSSA 简化模型中底物浓度首次达到 $s_{\\mathrm{end}} = \\max(10^{-3}\\,s_0,\\;10^{-6}\\,\\mu\\mathrm{M})$ 的时间 $T_{\\mathrm{end}}$。将此 $T_{\\mathrm{end}}$ 用作完整模拟和简化模拟的终止时间。\n- 在由 $N=2000$ 个均匀间隔时间点组成的公共评估网格上，对两个模型从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 进行模拟。\n- 计算最大绝对误差为 $\\max_{t \\in [0,T_{\\mathrm{end}}]} |s_{\\mathrm{full}}(t) - s_{\\mathrm{QSSA}}(t)|$，以 $\\mu\\mathrm{M}$ 为单位，表示为一个四舍五入到六位小数的浮点数。\n\n测试套件：\n- 使用以下四组参数，每组都满足 $s_0 \\gg e_0$ 和 $k_{-1} \\sim k_2$：\n  1. 情况 A：$s_0 = 100\\,\\mu\\mathrm{M}$，$e_0 = 0.5\\,\\mu\\mathrm{M}$，$k_1 = 1.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1} = 1.0\\,\\mathrm{s}^{-1}$，$k_2 = 1.0\\,\\mathrm{s}^{-1}$。\n  2. 情况 B：$s_0 = 120\\,\\mu\\mathrm{M}$，$e_0 = 0.05\\,\\mu\\mathrm{M}$，$k_1 = 2.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1} = 1.6\\,\\mathrm{s}^{-1}$，$k_2 = 2.0\\,\\mathrm{s}^{-1}$。\n  3. 情况 C：$s_0 = 10\\,\\mu\\mathrm{M}$，$e_0 = 0.01\\,\\mu\\mathrm{M}$，$k_1 = 1.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1} = 5.0\\,\\mathrm{s}^{-1}$，$k_2 = 2.0\\,\\mathrm{s}^{-1}$。\n  4. 情况 D：$s_0 = 50\\,\\mu\\mathrm{M}$，$e_0 = 0.2\\,\\mu\\mathrm{M}$，$k_1 = 5.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，$k_{-1} = 5.0\\,\\mathrm{s}^{-1}$，$k_2 = 5.0\\,\\mathrm{s}^{-1}$。\n\n所需最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例（A, B, C, D）的结果，按顺序排列，格式为用方括号括起来的逗号分隔列表。\n- 每个条目必须是一个浮点数，表示以 $\\mu\\mathrm{M}$ 为单位的最大绝对误差，并四舍五入到六位小数。\n- 例如，输出格式为 $[x_A,x_B,x_C,x_D]$。\n\n重要说明：\n- 推导必须从质量作用定律和酶守恒 $e(t) + c(t) = e_0$ 开始，不能在问题陈述中假设任何预先推导出的 Michaelis-Menten 公式。\n- 所有物理量均使用上述指定单位表示。", "solution": "所提出的问题是化学动力学和数值分析中的一个标准、明确的练习，要求推导和比较两种常见的酶催化反应模型。该问题科学合理、内容独立、客观公正。因此，这是一个有效的问题，我们将为其提供完整的解答。\n\n任务是将酶-底物反应的完整动力学模型与其在 Briggs-Haldane 准稳态近似 (QSSA) 下的简化模型进行比较。比较将基于反应过程中底物浓度的最大绝对误差。\n\n**1. 完整常微分方程 (ODE) 系统的推导**\n\n反应机理如下：\n$$\nE + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} C \\stackrel{k_2}{\\longrightarrow} E + P\n$$\n其中 $E$ 表示游离酶，$S$ 表示底物，$C$ 表示酶-底物复合物，$P$ 表示产物。我们用小写字母 $e(t)$、$s(t)$、$c(t)$ 和 $p(t)$ 表示这些物质的浓度。\n\n通过将质量作用定律应用于该反应网络，我们可以写出底物 $S$ 和复合物 $C$ 浓度的随时间变化的方程：\n$$\n\\frac{ds}{dt} = -k_1 e(t) s(t) + k_{-1} c(t)\n$$\n$$\n\\frac{dc}{dt} = k_1 e(t) s(t) - k_{-1} c(t) - k_2 c(t) = k_1 e(t) s(t) - (k_{-1} + k_2) c(t)\n$$\n总酶浓度 $e_0$ 在整个反应过程中是恒定的，并分布在游离酶 $E$ 和复合物 $C$ 之间。这为我们提供了守恒定律：\n$$\ne(t) + c(t) = e_0\n$$\n根据该守恒定律，我们可以将游离酶浓度表示为 $e(t) = e_0 - c(t)$。通过将此表达式代入 $s(t)$ 和 $c(t)$ 的速率方程，我们得到了一个仅涉及状态变量 $s(t)$ 和 $c(t)$ 的封闭的二元 ODE 系统：\n$$\n\\frac{ds}{dt} = -k_1 (e_0 - c(t)) s(t) + k_{-1} c(t)\n$$\n$$\n\\frac{dc}{dt} = k_1 (e_0 - c(t)) s(t) - (k_{-1} + k_2) c(t)\n$$\n这两个方程，加上指定的初始条件 $s(0) = s_0$ 和 $c(0) = 0$，构成了系统的完整质量作用模型。\n\n**2. QSSA 简化 ODE 系统的推导**\n\nBriggs-Haldane 准稳态近似 (QSSA) 在初始底物浓度远大于总酶浓度的条件下（即 $s_0 \\gg e_0$）有效。该条件意味着与底物 $s(t)$ 的消耗速率相比，酶-底物复合物的浓度 $c(t)$ 会非常迅速地达到一个准稳态。我们可以通过假设复合物浓度的变化率近似为零来将其形式化：\n$$\n\\frac{dc}{dt} \\approx 0\n$$\n将此近似应用于 $c(t)$ 的速率方程：\n$$\nk_1 (e_0 - c(t)) s(t) - (k_{-1} + k_2) c(t) \\approx 0\n$$\n这个代数方程可以求解出复合物的准稳态浓度，记为 $c_{qss}$，作为当前底物浓度 $s(t)$ 的函数：\n$$\nk_1 e_0 s(t) - k_1 c_{qss}(t) s(t) = (k_{-1} + k_2) c_{qss}(t)\n$$\n$$\nk_1 e_0 s(t) = (k_1 s(t) + k_{-1} + k_2) c_{qss}(t)\n$$\n$$\nc_{qss}(t) = \\frac{k_1 e_0 s(t)}{k_1 s(t) + k_{-1} + k_2} = \\frac{e_0 s(t)}{s(t) + \\frac{k_{-1} + k_2}{k_1}}\n$$\n我们将米氏常数 $K_M$ 定义为 $K_M = \\frac{k_{-1} + k_2}{k_1}$。这可将 $c_{qss}$ 的表达式简化为：\n$$\nc_{qss}(t) = \\frac{e_0 s(t)}{s(t) + K_M}\n$$\n为了推导 $s(t)$ 的单个 ODE，我们分析整体的物料平衡。将 $s(t)$ 和 $c(t)$ 的速率方程相加可得：\n$$\n\\frac{d(s+c)}{dt} = \\frac{ds}{dt} + \\frac{dc}{dt} = \\left(-k_1 e s + k_{-1} c\\right) + \\left(k_1 e s - (k_{-1} + k_2) c\\right) = -k_2 c(t)\n$$\n在 QSSA 机制下，快变量 $c(t)$ 的浓度很小 ($c \\ll s$)，其时间导数与慢变量 $s(t)$ 的时间导数相比可以忽略不计。因此，我们可以近似为 $\\frac{d(s+c)}{dt} \\approx \\frac{ds}{dt}$。这得到：\n$$\n\\frac{ds}{dt} \\approx -k_2 c(t)\n$$\n将 $c_{qss}(t)$ 的表达式代入此方程，我们得到了著名的 Michaelis-Menten 速率方程，它代表了 QSSA 简化模型：\n$$\n\\frac{ds}{dt} = - \\frac{k_2 e_0 s(t)}{s(t) + K_M}\n$$\n这个单一的 ODE，加上初始条件 $s(0) = s_0$，提供了对底物动力学的简化描述。\n\n**3. 数值模拟与误差分析**\n\n任务的核心是数值化地量化由 QSSA 引入的误差。步骤如下：\n首先，对于每组参数，确定模拟的终止时间 $T_{\\mathrm{end}}$。这被定义为 QSSA 模型中的底物浓度首次达到阈值 $s_{\\mathrm{end}} = \\max(10^{-3}\\,s_0,\\;10^{-6}\\,\\mu\\mathrm{M})$ 的时间。通过对 QSSA ODE 进行数值积分，并使用事件检测机制在 $s(t)$ 穿过 $s_{\\mathrm{end}}$ 时停止积分来实现这一点。\n\n其次，在确定了 $T_{\\mathrm{end}}$ 之后，在区间 $[0, T_{\\mathrm{end}}]$ 上生成一个由 $N=2000$ 个均匀间隔时间点组成的公共评估网格。然后，在此网格上对完整系统（两个耦合的 ODE）和 QSSA 简化系统（一个 ODE）进行数值求解。采用高精度的自适应步长 Runge-Kutta 求解器，以确保数值积分误差与所测量的建模误差相比可以忽略不计。此过程产生两个离散解：$s_{\\mathrm{full}}(t_i)$ 和 $s_{\\mathrm{QSSA}}(t_i)$。\n\n最后，在评估网格中的所有时间点上计算两种模型预测的底物浓度之间的最大绝对误差：\n$$\n\\text{误差} = \\max_{i} |s_{\\mathrm{full}}(t_i) - s_{\\mathrm{QSSA}}(t_i)|\n$$\n对四个指定的测试用例中的每一个都执行此计算，最终误差四舍五入到六位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving, simulating, and comparing full and QSSA\n    models of enzyme kinetics for four test cases.\n    \"\"\"\n    \n    def calculate_error_for_case(s0, e0, k1, k_minus1, k2):\n        \"\"\"\n        Calculates the maximum absolute error between the full and QSSA models\n        for a single parameter set.\n        \"\"\"\n        # 1. Define constants and model equations\n        KM = (k_minus1 + k2) / k1\n        N = 2000\n\n        # Full mass-action model ODE system (for [s, c])\n        def full_model_rhs(t, y):\n            s, c = y\n            dsdt = -k1 * (e0 - c) * s + k_minus1 * c\n            dcdt = k1 * (e0 - c) * s - (k_minus1 + k2) * c\n            return [dsdt, dcdt]\n\n        # QSSA-reduced model ODE (for [s])\n        def qssa_model_rhs(t, y):\n            s = y[0]\n            dsdt = -(k2 * e0 * s) / (s + KM)\n            return [dsdt]\n\n        # 2. Determine the simulation end time T_end using the QSSA model\n        s_end = max(1e-3 * s0, 1e-6)\n        \n        # Event function to find when s(t) reaches s_end\n        def event_s_end(t, y):\n            return y[0] - s_end\n        \n        event_s_end.terminal = True\n        event_s_end.direction = -1  # Event triggers when s is decreasing through s_end\n        \n        # Use a large time span to ensure the reaction completes and the event is found\n        t_span_for_tend = [0, 1e9]\n        y0_qssa = [s0]\n        \n        qssa_sol_for_tend = solve_ivp(\n            qssa_model_rhs, t_span_for_tend, y0_qssa,\n            events=event_s_end,\n            method='RK45', rtol=1e-9, atol=1e-12\n        )\n        \n        if not qssa_sol_for_tend.t_events or not qssa_sol_for_tend.t_events[0]:\n            raise ValueError(f\"T_end could not be determined for case with s0={s0}. \"\n                             \"Reaction may be too slow or parameters are unusual.\")\n        \n        T_end = qssa_sol_for_tend.t_events[0][0]\n\n        # 3. Simulate both models on a common evaluation grid\n        t_eval = np.linspace(0, T_end, N)\n        t_span = [0, T_end]\n        \n        # Use high precision to minimize numerical error\n        solver_options = {'method': 'RK45', 'rtol': 1e-9, 'atol': 1e-12}\n\n        # Solve the full model\n        y0_full = [s0, 0]\n        sol_full = solve_ivp(\n            full_model_rhs, t_span, y0_full, t_eval=t_eval, **solver_options\n        )\n        s_full = sol_full.y[0]\n\n        # Solve the QSSA model\n        sol_qssa = solve_ivp(\n            qssa_model_rhs, t_span, y0_qssa, t_eval=t_eval, **solver_options\n        )\n        s_qssa = sol_qssa.y[0]\n        \n        # 4. Compute and return the maximum absolute error\n        max_abs_error = np.max(np.abs(s_full - s_qssa))\n        \n        return max_abs_error\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case A: s0, e0, k1, k-1, k2 (in uM, uM^-1 s^-1, s^-1)\n        (100.0, 0.5, 1.0, 1.0, 1.0),\n        # Case B\n        (120.0, 0.05, 2.0, 1.6, 2.0),\n        # Case C\n        (10.0, 0.01, 1.0, 5.0, 2.0),\n        # Case D\n        (50.0, 0.2, 5.0, 5.0, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_error_for_case(*case)\n        # Format to six decimal places as a string\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2641303"}, {"introduction": "本章的最终实践将理论模型应用于模拟真实实验数据的场景，这是定量生物学研究中的一项核心技能。您将从含有噪声的合成数据中估计动力学参数 $K_M$ 和 $V_{max}$，并比较现代非线性拟合方法与传统线性化方法的优劣 [@problem_id:2641311]。这个练习突显了在参数估计中采用正确统计方法的重要性，以避免获得有偏的结果。", "problem": "给定质量作用动力学下的规范单底物酶促反应网络：$E + S \\xrightleftharpoons[k_{-1}]{k_1} ES \\xrightarrow{k_{cat}} E + P$。假设酶-底物复合物 $ES$ 处于Briggs和Haldane意义上的准稳态（准稳态假设），并且总酶浓度 $E_T$ 是守恒的。在此基础上，推导初始速率 $v$ 作为底物浓度 $s$ 函数的速率定律，该定律需用两个集总参数表示，您必须从第一性原理出发定义和解释这两个参数。然后，使用推导出的速率定律作为生成模型，完成以下的数值实验和参数估计研究。\n\n您必须实现一个程序，该程序：\n- 根据给定的底物浓度 $s$，生成带有相对标准差为 $0.05$ 的乘性高斯噪声的合成初始速率数据 $v$（即，在每个 $s_i$ 处的噪声标准差是相应无噪声 $v_i$ 的 $0.05$ 倍）。\n- 使用以下方法估计您推导出的集总参数：\n  1. 在原始 $(s,v)$ 空间中进行非线性最小二乘法估计，其权重与所述噪声模型一致。\n  2. 从同速率定律自行推导出的三种基于线性化的方法：\n     - 基于对两个变量取倒数的方法（在文献中很常见，但您必须自行推导）。\n     - 基于 $v$ 和 $v/s$ 之间线性关系的方法（在文献中很常见，但您必须自行推导）。\n     - 基于 $s/v$ 和 $s$ 之间线性关系的方法（在文献中很常见，但您必须自行推导）。\n  对于每种线性方法，使用普通最小二乘法（OLS）拟合推导出的线性关系，然后进行反变换以获得原始集总参数的估计值。\n\n实验设计和噪声模型：\n- 对于下文的每个测试用例和每个重复数据集，使用该测试用例的真实集总参数值，根据推导的速率定律在指定的 $s_i$ 值处生成无噪声的 $v_i$。然后，通过 $v_i^{obs} = v_i \\cdot (1 + \\varepsilon_i)$ 生成观测值 $v_i^{obs}$，其中每个 $\\varepsilon_i$ 是来自均值为 $0$、标准差为 $0.05$ 的正态分布的独立样本。将 $0.05$ 视为一个无量纲的相对噪声水平。\n- 每个测试用例使用 $R = 300$ 次独立重复。\n- 使用固定的伪随机种子 $12345$ 以确保可复现性。\n\n估计细节和约束：\n- 在非线性最小二乘法程序中，将两个集总参数约束为严格正数。\n- 为非线性优化选择一个不使用真实参数值的合理初始化策略。\n- 对于所述噪声模型下的加权非线性最小二乘法，对残差的惩罚应与模型所隐含的方差的倒数成正比。\n\n偏差评估与输出：\n- 对于每种估计方法 $m$ 和每个参数 $\\theta \\in \\{K_M, V_{max}\\}$，计算各重复之间的相对偏差，公式为\n  $$\\text{bias}_{rel}(\\theta, m) = \\frac{1}{R}\\sum_{r=1}^R \\left(\\frac{\\widehat{\\theta}^{(r)}_m}{\\theta_{true}} - 1\\right)。$$\n  为每个测试用例报告以下内容：\n  1. $K_M$ 的非线性最小二乘法相对偏差（一个浮点数）。\n  2. $V_{max}$ 的非线性最小二乘法相对偏差（一个浮点数）。\n  3. 一个指示符，如果 $K_M$ 的非线性最小二乘法绝对相对偏差严格小于三种基于线性化的方法中每一种的绝对相对偏差，则为 $1$，否则为 $0$（一个整数）。\n  4. 一个指示符，如果 $V_{max}$ 的非线性最小二乘法绝对相对偏差严格小于三种基于线性化的方法中每一种的绝对相对偏差，则为 $1$，否则为 $0$（一个整数）。\n- 将所有报告的量表示为无量纲数（无物理单位）。\n- 将所有浮点输出四舍五入到 $6$ 位小数。\n\n测试套件：\n- 测试用例A（典型饱和范围）：\n  - 真实参数：$K_M = 50$，$V_{max} = 2.0$。\n  - 底物网格：$s \\in \\{1, 5, 10, 25, 50, 100, 250, 500\\}$。\n- 测试用例B（早期饱和，低$K_M$）：\n  - 真实参数：$K_M = 5$，$V_{max} = 1.5$。\n  - 底物网格：$s \\in \\{0.5, 1, 2, 5, 10, 20, 40, 80\\}$。\n- 测试用例C（近线性区域，相对于$s$的高$K_M$）：\n  - 真实参数：$K_M = 200$，$V_{max} = 3.0$。\n  - 底物网格：$s \\in \\{1, 5, 10, 25, 50, 100, 150, 200\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n  $$[\\text{A}_{KM}, \\text{A}_{V}, \\text{A}_{KMbetter}, \\text{A}_{Vbetter}, \\text{B}_{KM}, \\text{B}_{V}, \\text{B}_{KMbetter}, \\text{B}_{Vbetter}, \\text{C}_{KM}, \\text{C}_{V}, \\text{C}_{KMbetter}, \\text{C}_{Vbetter}],$$\n  其中 $\\text{X}_{KM}$ 和 $\\text{X}_{V}$ 是测试用例 $\\text{X} \\in \\{\\text{A},\\text{B},\\text{C}\\}$ 中 $K_M$ 和 $V_{max}$ 的四舍五入后的非线性最小二乘法相对偏差，而 $\\text{X}_{KMbetter}$ 和 $\\text{X}_{Vbetter}$ 是对应的指示符，为整数 $0$ 或 $1$。", "solution": "所提出的问题是化学动力学和参数估计中的一个标准练习。它具有科学依据，问题定义明确，并且不包含任何模糊或矛盾之处。我们将按要求进行完整的推导和数值求解。\n\n首先，我们必须从基本原理出发，推导指定酶促反应的速率定律。反应网络如下：\n$$E + S \\xrightleftharpoons[k_{-1}]{k_1} ES \\xrightarrow{k_{cat}} E + P$$\n在这里，$E$ 代表酶，$S$ 代表底物，$ES$ 代表酶-底物复合物，而 $P$ 代表产物。正向结合、逆向解离和催化步骤的速率常数分别为 $k_1$、$k_{-1}$ 和 $k_{cat}$。\n\n让我们用小写字母表示各物质的浓度：$e = [E]$、$s = [S]$、$c = [ES]$ 和 $p = [P]$。应用质量作用定律，我们写出控制浓度的常微分方程组：\n$$ \\frac{de}{dt} = -k_1 e \\cdot s + k_{-1} c + k_{cat} c $$\n$$ \\frac{ds}{dt} = -k_1 e \\cdot s + k_{-1} c $$\n$$ \\frac{dc}{dt} = k_1 e \\cdot s - (k_{-1} + k_{cat}) c $$\n$$ \\frac{dp}{dt} = k_{cat} c $$\n\n反应的初始速率，我们表示为 $v$，定义为产物生成的初始速率。\n$$ v = \\left. \\frac{dp}{dt} \\right|_{t=0} = k_{cat} c $$\n\n我们应用规定的两个关键假设。\n1.  **酶守恒**: 总酶浓度 $e_T$ 是恒定的。\n    $$ e_T = e + c \\implies e = e_T - c $$\n2.  **准稳态假设 (QSSA)**: 中间复合物 $c$ 的浓度变化比底物或产物的浓度变化慢得多，因此其变化率可以近似为零。这就是Briggs-Haldane假设。\n    $$ \\frac{dc}{dt} = k_1 e \\cdot s - (k_{-1} + k_{cat}) c \\approx 0 $$\n\n将酶守恒方程代入QSSA方程，得到：\n$$ k_1 (e_T - c) \\cdot s - (k_{-1} + k_{cat}) c = 0 $$\n我们现在求解稳态复合物浓度 $c$。\n$$ k_1 e_T s - k_1 c s = (k_{-1} + k_{cat}) c $$\n$$ k_1 e_T s = (k_1 s + k_{-1} + k_{cat}) c $$\n$$ c = \\frac{k_1 e_T s}{k_1 s + k_{-1} + k_{cat}} $$\n将分子和分母同时除以 $k_1$：\n$$ c = \\frac{e_T s}{s + \\frac{k_{-1} + k_{cat}}{k_1}} $$\n最后，我们将这个 $c$ 的表达式代入速率 $v$ 的方程中：\n$$ v = k_{cat}c = \\frac{k_{cat} e_T s}{s + \\frac{k_{-1} + k_{cat}}{k_1}} $$\n这个方程通常用两个集总参数来表示。结果是在Briggs-Haldane公式下的著名Michaelis-Menten速率定律：\n$$ v(s) = \\frac{V_{max} s}{K_M + s} $$\n集总参数从第一性原理的定义和解释如下：\n-   **最大速率 ($V_{max}$)**：我们定义 $V_{max} = k_{cat} e_T$。该参数表示反应的理论最大速率，在底物浓度 $s$ 趋于无穷大时趋近此值。在饱和底物浓度下，所有酶都以 $ES$ 形式存在（$c \\to e_T$），因此反应速率变为 $v \\to k_{cat} e_T = V_{max}$。\n-   **米氏常数 ($K_M$)**：我们定义 $K_M = \\frac{k_{-1} + k_{cat}}{k_1}$。该常数是反应速率为最大速率一半时的底物浓度，即 $v(K_M) = V_{max}/2$。它是在稳态条件下酶对其底物的有效亲和力的度量。较小的 $K_M$ 值意味着较高的有效亲和力。请注意，这与热力学解离常数 $K_d = k_{-1}/k_1$ 不同，除非催化步骤与解离相比非常缓慢（$k_{cat} \\ll k_{-1}$）。\n\n对于问题的数值部分，我们必须推导该速率定律的三种线性化形式。\n1.  **倒数形式（Lineweaver-Burk）**：对速率定律取倒数。\n    $$ \\frac{1}{v} = \\frac{K_M + s}{V_{max} s} = \\frac{K_M}{V_{max} s} + \\frac{s}{V_{max} s} \\implies \\frac{1}{v} = \\left(\\frac{K_M}{V_{max}}\\right)\\frac{1}{s} + \\frac{1}{V_{max}} $$\n    这是 $y = 1/v$ 和 $x = 1/s$ 之间的线性关系，斜率为 $m = K_M/V_{max}$，截距为 $c = 1/V_{max}$。\n2.  **$v$ 对 $v/s$ 形式（Eadie-Hofstee）**：重排速率定律。\n    $$ v(K_M + s) = V_{max} s \\implies vK_M + vs = V_{max} s $$\n    两边同时除以 $s$ 并重排：\n    $$ v\\frac{K_M}{s} + v = V_{max} \\implies v = -K_M \\left(\\frac{v}{s}\\right) + V_{max} $$\n    这是 $y = v$ 和 $x = v/s$ 之间的线性关系，斜率为 $m = -K_M$，截距为 $c = V_{max}$。\n3.  **$s/v$ 对 $s$ 形式（Hanes-Woolf）**：从倒数形式开始，两边乘以 $s$。\n    $$ s \\cdot \\frac{1}{v} = s \\cdot \\left(\\frac{K_M}{V_{max} s} + \\frac{1}{V_{max}}\\right) \\implies \\frac{s}{v} = \\frac{K_M}{V_{max}} + \\frac{s}{V_{max}}$$\n    重排后得到：\n    $$ \\frac{s}{v} = \\left(\\frac{1}{V_{max}}\\right)s + \\frac{K_M}{V_{max}} $$\n    这是 $y = s/v$ 和 $x = s$ 之间的线性关系，斜率为 $m = 1/V_{max}$，截距为 $c = K_M/V_{max}$。\n\n数值实验涉及生成带有乘性高斯噪声的合成数据：$v_i^{obs} = v_i^{true}(1 + \\varepsilon_i)$，其中 $\\varepsilon_i \\sim N(0, \\sigma_{rel}^2)$ 且 $\\sigma_{rel}=0.05$。因此，观测值 $v_i^{obs}$ 的方差为 $\\text{Var}(v_i^{obs}) = (v_i^{true})^2 \\sigma_{rel}^2$。在此模型下，参数估计的统计最优方法是加权非线性最小二乘法（WNLS），该方法最小化残差平方和，每个残差都由其方差的倒数加权。目标函数是 $\\sum_i w_i (v_i^{obs} - v(s_i))^2$，其中权重 $w_i = 1/\\text{Var}(v_i^{obs})$。在实践中，我们用观测值 $v_i^{obs}$ 来近似未知的真实速度 $v_i^{true}$ 以计算权重。这对应于向优化程序提供一个 `sigma` 数组，其中 $\\sigma_i = v_i^{obs} \\sigma_{rel}$。\n线性化方法转换了数据，这同样也扭曲了误差结构。在转换后的空间中应用假定误差方差恒定的普通最小二乘法（OLS）在统计上是不正确的，并且通常会导致有偏的参数估计。本模拟将量化这种偏差。\n\n程序将实现这四种估计方法，对每个测试用例运行 $R=300$ 次重复模拟，计算所有方法中每个参数估计的相对偏差，并报告WNLS方法及其与线性方法比较所需的指标。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the enzyme kinetics parameter estimation problem.\n    This function encapsulates the entire simulation study and result generation.\n    \"\"\"\n\n    def mm_model(s, km, vmax):\n        \"\"\"Michaelis-Menten kinetic model.\"\"\"\n        # Use np.divide for safe division and add epsilon for stability\n        return np.divide(vmax * s, km + s)\n\n    def run_simulation(km_true, vmax_true, s_values, R, rel_noise, rng):\n        \"\"\"\n        Runs the Monte Carlo simulation for a single test case.\n        \n        Args:\n            km_true (float): True value of KM.\n            vmax_true (float): True value of Vmax.\n            s_values (np.ndarray): Substrate concentrations.\n            R (int): Number of replicates.\n            rel_noise (float): Relative standard deviation of noise.\n            rng (np.random.Generator): A NumPy random number generator.\n            \n        Returns:\n            tuple: A tuple containing the WNLS relative biases for KM and Vmax,\n                   and the indicator variables for their performance.\n        \"\"\"\n        \n        estimates_store = {\n            'wnls': {'km': [], 'vmax': []},\n            'lb':   {'km': [], 'vmax': []},\n            'eh':   {'km': [], 'vmax': []},\n            'hw':   {'km': [], 'vmax': []}\n        }\n        \n        v_true = mm_model(s_values, km_true, vmax_true)\n        \n        for _ in range(R):\n            noise = rng.normal(loc=0, scale=rel_noise, size=s_values.shape)\n            v_obs = v_true * (1 + noise)\n            # Ensure velocities are positive; highly unlikely to be non-positive with σ=0.05\n            v_obs[v_obs <= 0] = 1e-9 \n\n            # --- Estimation methods ---\n            \n            # 1. Hanes-Woolf (for its own estimation and for WNLS initialization)\n            p0 = [np.median(s_values), np.max(v_obs)] # Robust fallback initial guess\n            try:\n                x_hw, y_hw = s_values, s_values / v_obs\n                valid_hw = np.isfinite(x_hw) & np.isfinite(y_hw)\n                if np.sum(valid_hw) >= 2:\n                    slope_hw, intercept_hw, _, _, _ = linregress(x_hw[valid_hw], y_hw[valid_hw])\n                    if slope_hw > 1e-9: # Vmax > 0\n                        vmax_hw_est = 1.0 / slope_hw\n                        km_hw_est = intercept_hw * vmax_hw_est\n                        if km_hw_est > 0:\n                            estimates_store['hw']['km'].append(km_hw_est)\n                            estimates_store['hw']['vmax'].append(vmax_hw_est)\n                            p0 = [km_hw_est, vmax_hw_est]\n            except (ValueError, ZeroDivisionError):\n                pass\n            \n            # 2. WNLS\n            try:\n                sigma = v_obs * rel_noise\n                popt_wnls, _ = curve_fit(\n                    mm_model, s_values, v_obs, p0=p0, sigma=sigma,\n                    absolute_sigma=True, bounds=(0, np.inf), maxfev=5000\n                )\n                estimates_store['wnls']['km'].append(popt_wnls[0])\n                estimates_store['wnls']['vmax'].append(popt_wnls[1])\n            except (RuntimeError, ValueError):\n                pass\n\n            # 3. Lineweaver-Burk\n            try:\n                with np.errstate(divide='ignore'):\n                    x_lb, y_lb = 1.0 / s_values, 1.0 / v_obs\n                valid_lb = np.isfinite(x_lb) & np.isfinite(y_lb)\n                if np.sum(valid_lb) >= 2:\n                    slope_lb, intercept_lb, _, _, _ = linregress(x_lb[valid_lb], y_lb[valid_lb])\n                    if intercept_lb > 1e-9 and slope_lb > 0: # Vmax > 0, Km > 0\n                        vmax_lb_est = 1.0 / intercept_lb\n                        km_lb_est = slope_lb * vmax_lb_est\n                        estimates_store['lb']['km'].append(km_lb_est)\n                        estimates_store['lb']['vmax'].append(vmax_lb_est)\n            except (ValueError, ZeroDivisionError):\n                pass\n\n            # 4. Eadie-Hofstee\n            try:\n                with np.errstate(divide='ignore'):\n                    x_eh, y_eh = v_obs / s_values, v_obs\n                valid_eh = np.isfinite(x_eh) & np.isfinite(y_eh)\n                if np.sum(valid_eh) >= 2:\n                    slope_eh, intercept_eh, _, _, _ = linregress(x_eh[valid_eh], y_eh[valid_eh])\n                    if slope_eh < 0 and intercept_eh > 0: # -Km < 0, Vmax > 0\n                        vmax_eh_est = intercept_eh\n                        km_eh_est = -slope_eh\n                        estimates_store['eh']['km'].append(km_eh_est)\n                        estimates_store['eh']['vmax'].append(vmax_eh_est)\n            except (ValueError, ZeroDivisionError):\n                pass\n\n        # --- Bias Calculation ---\n        biases = {}\n        for method in estimates_store:\n            # If a method failed on all replicates, its bias is effectively infinite\n            if len(estimates_store[method]['km']) == 0:\n                 biases[method] = {'km': np.inf, 'vmax': np.inf}\n            else:\n                mean_km = np.mean(estimates_store[method]['km'])\n                mean_vmax = np.mean(estimates_store[method]['vmax'])\n                biases[method] = {\n                    'km': mean_km / km_true - 1.0,\n                    'vmax': mean_vmax / vmax_true - 1.0\n                }\n        \n        # --- Indicator Calculation ---\n        abs_bias_wnls_km = abs(biases['wnls']['km'])\n        abs_bias_wnls_vmax = abs(biases['wnls']['vmax'])\n        \n        km_better = 1 if (abs_bias_wnls_km < abs(biases['lb']['km']) and\n                          abs_bias_wnls_km < abs(biases['eh']['km']) and\n                          abs_bias_wnls_km < abs(biases['hw']['km'])) else 0\n                          \n        vmax_better = 1 if (abs_bias_wnls_vmax < abs(biases['lb']['vmax']) and\n                            abs_bias_wnls_vmax < abs(biases['eh']['vmax']) and\n                            abs_bias_wnls_vmax < abs(biases['hw']['vmax'])) else 0\n                            \n        return (\n            biases['wnls']['km'],\n            biases['wnls']['vmax'],\n            km_better,\n            vmax_better\n        )\n\n    # --- Test suite definition ---\n    test_cases = {\n        'A': {'km': 50.0, 'vmax': 2.0, 's': np.array([1, 5, 10, 25, 50, 100, 250, 500], dtype=float)},\n        'B': {'km': 5.0,  'vmax': 1.5, 's': np.array([0.5, 1, 2, 5, 10, 20, 40, 80], dtype=float)},\n        'C': {'km': 200.0,'vmax': 3.0, 's': np.array([1, 5, 10, 25, 50, 100, 150, 200], dtype=float)}\n    }\n    \n    R = 300\n    rel_noise = 0.05\n    seed = 12345\n    rng = np.random.default_rng(seed)\n    \n    all_results = []\n    \n    for case_id in ['A', 'B', 'C']:\n        case_params = test_cases[case_id]\n        results = run_simulation(\n            case_params['km'],\n            case_params['vmax'],\n            case_params['s'],\n            R,\n            rel_noise,\n            rng\n        )\n        all_results.extend(results)\n    \n    # --- Final Output Formatting ---\n    results_formatted = []\n    for item in all_results:\n        if isinstance(item, float):\n            results_formatted.append(f\"{item:.6f}\")\n        else:\n            results_formatted.append(str(item))\n            \n    print(f\"[{','.join(results_formatted)}]\")\n\nsolve()\n```", "id": "2641311"}]}