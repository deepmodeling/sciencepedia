{"hands_on_practices": [{"introduction": "在酶动力学建模中，当平衡常数 $K_{\\mathrm{eq}}$ 很大时，一个常见的简化是假设反应是不可逆的，即设置反向最大速率 $V_r = 0$。这个实践练习将引导你使用霍尔丹关系（Haldane relationship）来严格审视这一假设的有效性。通过一个具体的计算，你将发现，只要 $K_{\\mathrm{eq}}$ 是有限的，热力学就要求 $V_r$ 必须是一个特定的非零值，从而揭示了忽略可逆性可能导致的模型内在矛盾。[@problem_id:2686032]", "problem": "一个单底物、单产物的酶催化反应是可逆的，并且在准稳态条件下遵循标准的可逆 Michaelis–Menten 动力学，同时满足微观可逆性（细致平衡）原则。宏观动力学参数包括正向和逆向最大速率 $V_f$ 和 $V_r$（其中对于总酶浓度 $E_T$，有 $V_f = k_{\\mathrm{cat},f} E_T$ 和 $V_r = k_{\\mathrm{cat},r} E_T$），以及底物和产物的米氏常数 $K_S$ 和 $K_P$。对于总化学转化 $S \\rightleftharpoons P$，其热力学平衡常数 (EC) $K_{\\mathrm{eq}}$ 是一个有限的大值。不应先验地假设“不可逆”近似。\n\n仅从以下两个原则出发：(i) 在热力学平衡时，对于满足 $P/S = K_{\\mathrm{eq}}$ 的浓度，净反应速率必须为零；(ii) 动力学机制是热力学一致的（微观可逆性），请确定对于此单-单机制，关联 $V_r/V_f$ 与 $K_{\\mathrm{eq}}$、$K_S$ 和 $K_P$ 的最严格的热力学约束条件。然后，使用 $K_S = 0.5\\,\\mathrm{mM}$、$K_P = 5\\,\\mathrm{mM}$ 和 $K_{\\mathrm{eq}} = 10^5$，评估对于大而有限的 $K_{\\mathrm{eq}}$，常用近似 $V_r \\approx 0$ 在热力学上是否可接受。如果坚持使用建模容差 $V_r/V_f \\le \\varepsilon$ 作为“证明” $V_r \\approx 0$ 合理性的标准，那么为避免与热力学矛盾，$\\varepsilon$ 的数值必须超过多少？\n\n选择下面最好的陈述。\n\nA. 不可接受。对于任何有限的 $K_{\\mathrm{eq}}$，热力学一致性强制要求一个严格为正的比率 $V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$。当 $K_S = 0.5\\,\\mathrm{mM}$、$K_P = 5\\,\\mathrm{mM}$ 且 $K_{\\mathrm{eq}} = 10^5$ 时，可得 $V_r/V_f = 10^{-4}$。因此 $V_r$ 不能被视为恒等于零；只有在 $K_{\\mathrm{eq}} \\to \\infty$（或 $K_P/K_S \\to 0$）的奇异极限下才允许 $V_r = 0$。任何容差都必须满足 $\\varepsilon \\ge 10^{-4}$。\n\nB. 可接受。由于 $K_{\\mathrm{eq}}$ 很大，因此 $V_r/V_f$ 不存在一个独立于浓度的热力学下界；只需满足 $P \\ll K_P$ 即可证明 $V_r = 0$ 是合理的。\n\nC. 可接受。热力学约束为 $V_r/V_f \\le K_{\\mathrm{eq}} (K_P/K_S)$；根据给定的数值，此上界为 $10^6$，因此逆向能力可以无损地设为零。\n\nD. 它仅取决于催化速率常数。如果 $k_{\\mathrm{cat},r} \\ll k_{\\mathrm{cat},f}$，那么 $V_r \\approx 0$ 在热力学上是可接受的，且与 $K_S$ 和 $K_P$ 无关。其约束界限为 $V_r/V_f \\le 1/K_{\\mathrm{eq}}$。", "solution": "问题陈述在科学上是合理的、提法恰当、客观，并且包含推导出唯一解所需的所有信息。所涉及的概念——可逆 Michaelis-Menten 动力学、微观可逆性以及 Haldane 关系式——是化学动力学和酶动力学中的基本原理。给定的数值在物理上是可信的。因此我们可以进行推导。\n\n该问题要求推导一个可逆的单底物、单产物酶促反应的动力学参数所受的热力学约束。给定的机制符合标准的可逆 Michaelis-Menten 动力学。对于反应 $S \\rightleftharpoons P$，在此条件下的速率定律 ($v$) 通常表示为：\n$$ v = \\frac{V_f \\frac{[S]}{K_S} - V_r \\frac{[P]}{K_P}}{1 + \\frac{[S]}{K_S} + \\frac{[P]}{K_P}} $$\n此处，$[S]$ 和 $[P]$ 分别是底物和产物的浓度。参数 $V_f$、$V_r$、$K_S$ 和 $K_P$ 分别是正向和逆向最大速率以及底物和产物的米氏常数。这些是宏观动力学参数。\n\n问题中陈述的第一个原则是，在热力学平衡时，净反应速率必须为零（$v=0$）。在平衡状态下，底物和产物的浓度（记为 $[S]_{\\mathrm{eq}}$ 和 $[P]_{\\mathrm{eq}}$）是恒定的。在速率方程中令 $v=0$ 可得：\n$$ V_f \\frac{[S]_{\\mathrm{eq}}}{K_S} - V_r \\frac{[P]_{\\mathrm{eq}}}{K_P} = 0 $$\n这必须成立，因为分母总是正的且有限。该方程可以重排为：\n$$ V_f \\frac{[S]_{\\mathrm{eq}}}{K_S} = V_r \\frac{[P]_{\\mathrm{eq}}}{K_P} $$\n$$ \\frac{V_f}{V_r} = \\frac{[P]_{\\mathrm{eq}}}{[S]_{\\mathrm{eq}}} \\frac{K_S}{K_P} $$\n\n援引的第二个原则是动力学机制必须是热力学一致的。这意味着平衡浓度的比值由总反应 $S \\rightleftharpoons P$ 的热力学平衡常数 $K_{\\mathrm{eq}}$ 给出：\n$$ K_{\\mathrm{eq}} = \\frac{[P]_{\\mathrm{eq}}}{[S]_{\\mathrm{eq}}} $$\n将此定义代入重排后的速率方程，得到此机制的 Haldane 关系式：\n$$ \\frac{V_f}{V_r} = K_{\\mathrm{eq}} \\frac{K_S}{K_P} $$\n这就是所需的关系式。它是一个等式，直接从第一性原理推导得出，因此代表了这些参数之间可能的最严格的热力学约束。它不是一个不等式；动力学参数不能取任意值，而是受到总反应热力学性质的严格约束。\n\n问题要求的是对比例 $V_r/V_f$ 的约束。我们重排 Haldane 关系式：\n$$ \\frac{V_r}{V_f} = \\frac{1}{K_{\\mathrm{eq}}} \\frac{K_P}{K_S} $$\n\n现在，我们必须使用提供的数值来计算这个比率：\n- $K_S = 0.5\\,\\mathrm{mM}$\n- $K_P = 5\\,\\mathrm{mM}$\n- $K_{\\mathrm{eq}} = 10^5$\n\n米氏常数的比率是一个无量纲的量：\n$$ \\frac{K_P}{K_S} = \\frac{5\\,\\mathrm{mM}}{0.5\\,\\mathrm{mM}} = 10 $$\n将此代入我们关于 $V_r/V_f$ 的表达式中：\n$$ \\frac{V_r}{V_f} = \\frac{10}{10^5} = 10^{-4} $$\n\n这个结果使我们能够评估 $V_r \\approx 0$ 这一近似。Haldane 关系式强制规定，对于任何有限且非零的 $K_{\\mathrm{eq}}$ 和 $K_P/K_S$，比率 $V_r/V_f$ 必须是一个特定的、非零的正值。在本例中，$V_r/V_f = 10^{-4}$。因此，将 $V_r$ 恒等地设为 $0$ 违反了热力学一致性。$V_r \\approx 0$ 这一近似仅在诸如 $K_{\\mathrm{eq}} \\to \\infty$ 的奇异极限下才严格有效。对于任何大而有限的 $K_{\\mathrm{eq}}$，$V_r$ 都必须为非零值。\n\n最后，我们考虑建模容差 $\\varepsilon$，如果 $V_r/V_f \\le \\varepsilon$，则近似 $V_r \\approx 0$ 被认为是可接受的。为了使模型在热力学上保持一致，选择的这个容差必须能够容纳由 Haldane 关系式决定的那个不可协商的值。在我们的案例中，这意味着所选的 $\\varepsilon$ 必须满足：\n$$ \\varepsilon \\ge \\frac{V_r}{V_f} = 10^{-4} $$\n对于给定的参数集，任何 $\\varepsilon < 10^{-4}$ 的建模选择都将代表一个热力学上不一致的模型。\n\n我们现在来评估每个选项。\n\nA. 不可接受。对于任何有限的 $K_{\\mathrm{eq}}$，热力学一致性强制要求一个严格为正的比率 $V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$。当 $K_S = 0.5\\,\\mathrm{mM}$、$K_P = 5\\,\\mathrm{mM}$ 且 $K_{\\mathrm{eq}} = 10^5$ 时，可得 $V_r/V_f = 10^{-4}$。因此 $V_r$ 不能被视为恒等于零；只有在 $K_{\\mathrm{eq}} \\to \\infty$（或 $K_P/K_S \\to 0$）的奇异极限下才允许 $V_r = 0$。任何容差都必须满足 $\\varepsilon \\ge 10^{-4}$。\n这个陈述正确地将 Haldane 关系式确定为 $V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$。$V_r/V_f = 10^{-4}$ 的计算是正确的。对于有限的 $K_{\\mathrm{eq}}$，$V_r$ 不能恒等于零的结论也是正确的。关于容差的条件 $\\varepsilon \\ge 10^{-4}$ 是我们分析的直接结果。这个陈述的每一部分都是准确的。\n**结论：正确**\n\nB. 可接受。由于 $K_{\\mathrm{eq}}$ 很大，因此 $V_r/V_f$ 不存在一个独立于浓度的热力学下界；只需满足 $P \\ll K_P$ 即可证明 $V_r = 0$ 是合理的。\n这个陈述有根本性的缺陷。Haldane 关系式为最大速率之比 $V_r/V_f$ 提供了一个精确值，而非一个界限。这个由 $K_{\\mathrm{eq}}$、$K_S$ 和 $K_P$ 决定的值，与操作浓度 $[S]$ 和 $[P]$ 无关。$[P] \\ll K_P$ 的条件使得逆向*速率项*（$V_r[P]/K_P$）变小，但它对参数 $V_r$ 本身的值没有影响，而这正是问题所关注的。\n**结论：不正确**\n\nC. 可接受。热力学约束为 $V_r/V_f \\le K_{\\mathrm{eq}} (K_P/K_S)$；根据给定的数值，此上界为 $10^6$，因此逆向能力可以无损地设为零。\n所提出的约束 $V_r/V_f \\le K_{\\mathrm{eq}} (K_P/K_S)$ 是不正确的。正确的关系是一个等式，$V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$，这是选项中给出的表达式的倒数，并且它不是一个不等式。这个选项颠倒了动力学常数和热力学常数之间的关系。基于这个错误前提的后续推理是无效的。\n**结论：不正确**\n\nD. 它仅取决于催化速率常数。如果 $k_{\\mathrm{cat},r} \\ll k_{\\mathrm{cat},f}$，那么 $V_r \\approx 0$ 在热力学上是可接受的，且与 $K_S$ 和 $K_P$ 无关。其约束界限为 $V_r/V_f \\le 1/K_{\\mathrm{eq}}$。\n这个陈述在多个方面都是不正确的。比率 $V_r/V_f$ 等于 $k_{\\mathrm{cat},r}/k_{\\mathrm{cat},f}$，但 Haldane 关系式表明这个比率并非与 $K_S$ 和 $K_P$ 无关。声称其可接受性“与 $K_S$ 和 $K_P$ 无关”是错误的。此外，所提出的界限 $V_r/V_f \\le 1/K_{\\mathrm{eq}}$ 是错误的；它省略了因子 $K_P/K_S$，并错误地将一个等式表示为不等式。\n**结论：不正确**\n\n基于从第一性原理的严格推导，只有选项 A 是正确的。", "answer": "$$\\boxed{A}$$", "id": "2686032"}, {"introduction": "既然我们已经认识到动力学参数必须严格遵守热力学约束，那么当实验测量的参数集（如 $V_f, V_r, K_s, K_p$）由于测量误差而未能满足霍尔丹关系时，我们该如何处理？本练习将介绍一种强大的计算方法，通过应用约束最小二乘法来解决此问题。你将学习如何系统地调整一组实验数据，以找到在统计学上最接近测量值且同时精确满足霍尔丹关系的一致的参数集。[@problem_id:2686027]", "problem": "现给定一个在准稳态近似 (QSSA) 下的可逆米氏酶促反应机制的宏观动力学参数测量值。设正向最大速率为 $V_f$，逆向最大速率为 $V_r$，底物米氏常数为 $K_s$，产物米氏常数为 $K_p$，热力学平衡常数为 $K_{\\mathrm{eq}}$。在微观可逆性和热力学一致性的条件下，这些参数之间必须满足一个 Haldane 型关系式。从可逆米氏动力学的定义、准稳态近似、热力学平衡时净通量为零的条件出发，并结合 $K_{\\mathrm{eq}}$ 是平衡活度之比的条件，推导出 $V_f$、$V_r$、$K_s$、$K_p$ 和 $K_{\\mathrm{eq}}$ 之间的等式约束。然后，仅使用加权最小二乘法和拉格朗日乘数法的第一性原理，建立一个参数估计问题，通过调整 $V_f$、$V_r$、$K_s$ 和 $K_p$ 来最佳拟合它们的测量均值，同时精确满足所推导的热力学约束。最后，基于对数空间中的线性误差传播，建立一种计算约束估计值的近似置信区间的方法。\n\n您必须在单个程序中实现以下内容：\n\n- 采用对数参数化 $z = (\\ln V_f,\\ \\ln V_r,\\ \\ln K_s,\\ \\ln K_p)^\\top$，以隐式处理正性约束。假设给定测量均值 $m = (m_{V_f},\\ m_{V_r},\\ m_{K_s},\\ m_{K_p})$ 及其标准差 $s = (s_{V_f},\\ s_{V_r},\\ s_{K_s},\\ s_{K_p})$。对每个分量，使用一阶误差传播将对数参数的方差近似为 $\\operatorname{Var}(\\ln X) \\approx (s_X/m_X)^2$。\n- 建立并求解对数空间中的加权最小二乘投影问题，该问题在对数空间中 Haldane 关系式所蕴含的单一线性等式约束下，最小化二次型。使用拉格朗日乘数法推导对数空间中约束估计值的闭式解，然后通过取指数将其转换回原始参数空间。\n- 通过从无约束协方差中投影掉约束方向，推导出对数空间中的约束协方差矩阵。然后，对每个原始参数，应用 delta 方法（即通过取指数变换对数空间中的正态区间）计算双侧置信区间。使用与指定置信水平相对应的标准正态分位数。\n\n物理单位：$V_f$ 和 $V_r$ 的单位解释为微摩尔/秒 ($\\mu\\mathrm{M}\\ \\mathrm{s}^{-1}$)，$K_s$ 和 $K_p$ 的单位解释为微摩尔 ($\\mu\\mathrm{M}$)。平衡常数 $K_{\\mathrm{eq}}$ 是无量纲的。您输出的 $V_f$ 和 $V_r$ 应理解为以 $\\mu\\mathrm{M}\\ \\mathrm{s}^{-1}$ 为单位，$K_s$ 和 $K_p$ 以 $\\mu\\mathrm{M}$ 为单位。置信区间必须以相同单位报告。使用 $0.95$ 的置信水平。\n\n测试套件：您的程序必须处理以下 $3$ 个测试用例。对于每个用例，输入为 $(m_{V_f}, m_{V_r}, m_{K_s}, m_{K_p}, s_{V_f}, s_{V_r}, s_{K_s}, s_{K_p}, K_{\\mathrm{eq}}, \\text{confidence})$。\n\n- 用例 $1$ (近乎一致的测量值)：$m_{V_f} = 100$, $m_{V_r} = 25$, $m_{K_s} = 50$, $m_{K_p} = 10$, $s_{V_f} = 5$, $s_{V_r} = 2$, $s_{K_s} = 5$, $s_{K_p} = 1$, $K_{\\mathrm{eq}} = 0.8$, confidence $= 0.95$。\n- 用例 $2$ (不一致的测量值，逆向速率高度精确)：$m_{V_f} = 120$, $m_{V_r} = 30$, $m_{K_s} = 40$, $m_{K_p} = 12$, $s_{V_f} = 6$, $s_{V_r} = 1$, $s_{K_s} = 2$, $s_{K_p} = 3$, $K_{\\mathrm{eq}} = 1.0$, confidence $= 0.95$。\n- 用例 $3$ (一个参数极其精确，其余参数带有噪声)：$m_{V_f} = 80$, $m_{V_r} = 20$, $m_{K_s} = 50$, $m_{K_p} = 25$, $s_{V_f} = 20$, $s_{V_r} = 20$, $s_{K_s} = 20$, $s_{K_p} = 0.1$, $K_{\\mathrm{eq}} = 1.8$, confidence $= 0.95$。\n\n最终输出格式要求：对于每个测试用例，输出一个列表，其中包含 $4$ 个约束估计值，随后是每个估计值的置信下限和上限，顺序为 $[V_f^\\star, V_r^\\star, K_s^\\star, K_p^\\star, \\mathrm{LCI}(V_f), \\mathrm{UCI}(V_f), \\mathrm{LCI}(V_r), \\mathrm{UCI}(V_r), \\mathrm{LCI}(K_s), \\mathrm{UCI}(K_s), \\mathrm{LCI}(K_p), \\mathrm{UCI}(K_p)]$. 您的程序应生成单行输出，其中包含所有用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素是单个用例的列表（例如：$[ [\\cdots], [\\cdots], [\\cdots] ]$）。\n\n所有计算必须在您的代码中实现。不允许用户输入；程序必须完整运行并打印所需的单行输出。", "solution": "该问题要求推导一个可逆酶促反应机制的热力学约束，将其应用于一个约束参数估计问题，并随后计算调整后参数的置信区间。该方法必须基于第一性原理。\n\n首先，我们推导指定酶促反应机制的 Haldane 关系式。可逆米氏机制由下式给出：\n$$\nE + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} ES \\underset{k_{-2}}{\\stackrel{k_2}{\\rightleftharpoons}} E + P\n$$\n其中 $E$ 是酶，$S$ 是底物，$P$ 是产物，$ES$ 是酶-底物复合物。微观速率常数为 $k_1, k_{-1}, k_2$ 和 $k_{-2}$。总酶浓度 $[E]_0$ 是恒定的，$[E]_0 = [E] + [ES]$。\n\n在准稳态近似 (QSSA) 下，中间复合物浓度的变化速率假定为零：\n$$\n\\frac{d[ES]}{dt} = k_1[E][S] + k_{-2}[E][P] - (k_{-1} + k_2)[ES] = 0\n$$\n代入 $[E] = [E]_0 - [ES]$ 并求解 $[ES]$ 得：\n$$\n[ES] = \\frac{(k_1[S] + k_{-2}[P])[E]_0}{k_1[S] + k_{-2}[P] + k_{-1} + k_2}\n$$\n净反应速率 $v$ 定义为产物的生成速率，即 $v = k_2[ES] - k_{-2}[E][P]$。代入 $[E]$ 和 $[ES]$ 的表达式，得到完整的速率方程：\n$$\nv = \\frac{(k_1 k_2 [S] - k_{-1} k_{-2} [P])[E]_0}{(k_{-1}+k_2) + k_1[S] + k_{-2}[P]}\n$$\n宏观动力学参数是在特定的极限条件下定义的。\n正向最大速率 $V_f$ 是当 $[S] \\to \\infty$ 且 $[P] = 0$ 时的速率。速率方程简化为 $v = \\frac{k_2 [E]_0 [S]}{(k_{-1}+k_2)/k_1 + [S]}$。由此，我们确定：\n$$\nV_f = k_2 [E]_0 \\quad \\text{and} \\quad K_s = \\frac{k_{-1}+k_2}{k_1}\n$$\n逆向最大速率 $V_r$ 是当 $[P] \\to \\infty$ 且 $[S] = 0$ 时速率的绝对值。速率方程变为 $v = \\frac{-k_{-1} [E]_0 [P]}{(k_{-1}+k_2)/k_{-2} + [P]}$，由此我们确定：\n$$\nV_r = k_{-1} [E]_0 \\quad \\text{and} \\quad K_p = \\frac{k_{-1}+k_2}{k_{-2}}\n$$\n在热力学平衡时，净速率 $v=0$。这意味着速率方程的分子必须为零：\n$$\nk_1 k_2 [S]_{eq} - k_{-1} k_{-2} [P]_{eq} = 0\n$$\n热力学平衡常数定义为 $K_{\\mathrm{eq}} = \\frac{[P]_{eq}}{[S]_{eq}}$。因此：\n$$\nK_{\\mathrm{eq}} = \\frac{k_1 k_2}{k_{-1} k_{-2}}\n$$\n现在我们用宏观参数来表示 $K_{\\mathrm{eq}}$。根据它们的定义，我们得到以下比率：\n$$\n\\frac{V_f}{V_r} = \\frac{k_2 [E]_0}{k_{-1} [E]_0} = \\frac{k_2}{k_{-1}}\n$$\n$$\n\\frac{K_p}{K_s} = \\frac{(k_{-1}+k_2)/k_{-2}}{(k_{-1}+k_2)/k_1} = \\frac{k_1}{k_{-2}}\n$$\n将这些代入 $K_{\\mathrm{eq}}$ 的表达式中，即可得到 Haldane 关系式：\n$$\nK_{\\mathrm{eq}} = \\left(\\frac{k_2}{k_{-1}}\\right) \\left(\\frac{k_1}{k_{-2}}\\right) = \\frac{V_f}{V_r} \\frac{K_p}{K_s}\n$$\n这个基本方程 $\\frac{V_f K_p}{V_r K_s} = K_{\\mathrm{eq}}$ 提供了所需的热力学约束。\n\n接下来，我们建立约束参数估计问题。为了处理动力学参数的正性，我们在对数空间中进行操作。设参数向量为 $p = (V_f, V_r, K_s, K_p)^\\top$。对数变换后的向量是 $z = (\\ln V_f, \\ln V_r, \\ln K_s, \\ln K_p)^\\top$。在此空间中，Haldane 关系式变为一个线性等式约束：\n$$\n\\ln V_f - \\ln V_r - \\ln K_s + \\ln K_p = \\ln K_{\\mathrm{eq}}\n$$\n这可以写成 $c^\\top z = d$，其中 $c = (1, -1, -1, 1)^\\top$ 且 $d = \\ln K_{\\mathrm{eq}}$。\n\n给定测量均值 $m = (m_{V_f}, m_{V_r}, m_{K_s}, m_{K_p})^\\top$ 和标准差 $s = (s_{V_f}, s_{V_r}, s_{K_s}, s_{K_p})^\\top$。初始的对数参数向量是 $z_0 = \\ln m$。通过一阶误差传播（delta 方法），对数变换后参数的方差为 $\\operatorname{Var}(\\ln X) \\approx (s_X/m_X)^2$。假设测量是独立的，则 $z_0$ 的初始协方差矩阵是对角阵：$\\Sigma = \\operatorname{diag}( (s_{V_f}/m_{V_f})^2, \\dots, (s_{K_p}/m_{K_p})^2 )$。问题是找到向量 $z^*$，使其在满足约束条件的情况下，最小化与 $z_0$ 的加权平方偏差和。这等同于最小化二次型：\n$$\nS(z) = (z - z_0)^\\top \\Sigma^{-1} (z - z_0)\n$$\n约束条件为 $c^\\top z = d$。我们使用一个拉格朗日乘数 $\\lambda$ 来求解此问题。拉格朗日函数为：\n$$\nL(z, \\lambda) = (z - z_0)^\\top \\Sigma^{-1} (z - z_0) - \\lambda (c^\\top z - d)\n$$\n将关于 $z$ 的梯度设为零，得到：\n$$\n\\nabla_z L = 2 \\Sigma^{-1} (z - z_0) - \\lambda c = 0 \\implies z = z_0 + \\frac{\\lambda}{2} \\Sigma c\n$$\n将此代入约束条件 $c^\\top z = d$：\n$$\nc^\\top (z_0 + \\frac{\\lambda}{2} \\Sigma c) = d \\implies c^\\top z_0 + \\frac{\\lambda}{2} c^\\top \\Sigma c = d\n$$\n求解拉格朗日乘数项：\n$$\n\\frac{\\lambda}{2} = \\frac{d - c^\\top z_0}{c^\\top \\Sigma c}\n$$\n将其代回 $z$ 的表达式，我们得到约束估计值 $z^*$：\n$$\nz^* = z_0 + \\Sigma c \\frac{d - c^\\top z_0}{c^\\top \\Sigma c} = z_0 - \\frac{c^\\top z_0 - d}{c^\\top \\Sigma c} \\Sigma c\n$$\n在原始空间中，调整后的参数为 $p^* = \\exp(z^*)$。\n\n最后，我们确定置信区间。约束估计值 $z^*$ 是初始估计值 $z_0$ 的线性函数：$z^* = A z_0 + b$，其中 $A = I - \\frac{\\Sigma c c^\\top}{c^\\top \\Sigma c}$。$z^*$ 的协方差矩阵为 $\\Sigma_{z^*} = A \\Sigma A^\\top$。\n$$\n\\Sigma_{z^*} = \\left(I - \\frac{\\Sigma c c^\\top}{c^\\top \\Sigma c}\\right) \\Sigma \\left(I - \\frac{c c^\\top \\Sigma}{c^\\top \\Sigma c}\\right) = \\Sigma - \\frac{\\Sigma c c^\\top \\Sigma}{c^\\top \\Sigma c}\n$$\n$\\Sigma_{z^*}$ 的对角元素，记为 $\\sigma^2_{z^*_i}$，是约束后对数参数估计值的方差。对数参数 $z^*_i$ 的双侧 $(1-\\alpha)$ 置信区间由下式给出：\n$$\n[ z^*_i - q_{1-\\alpha/2} \\sigma_{z^*_i}, \\quad z^*_i + q_{1-\\alpha/2} \\sigma_{z^*_i} ]\n$$\n其中 $q_{1-\\alpha/2}$ 是标准正态分布的相应分位数。对于 $0.95$ 的置信水平，$\\alpha=0.05$ 且 $q_{0.975} \\approx 1.95996$。通过对该区间取指数，我们得到原始参数 $p^*_i = \\exp(z^*_i)$ 的置信区间：\n$$\n[ p^*_i \\exp(-q_{1-\\alpha/2} \\sigma_{z^*_i}), \\quad p^*_i \\exp(q_{1-\\alpha/2} \\sigma_{z^*_i}) ]\n$$\n该过程提供了一个完整的、解析推导的方法，用于获取热力学一致的参数估计值及其相关的不确定性。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the constrained parameter estimation problem for a reversible enzyme\n    mechanism according to the Haldane relationship.\n    \"\"\"\n    test_cases = [\n        # Case 1 (near-consistent measurements)\n        (100.0, 25.0, 50.0, 10.0, 5.0, 2.0, 5.0, 1.0, 0.8, 0.95),\n        # Case 2 (inconsistent measurements, reverse velocity highly precise)\n        (120.0, 30.0, 40.0, 12.0, 6.0, 1.0, 2.0, 3.0, 1.0, 0.95),\n        # Case 3 (one parameter extremely precise, others noisy)\n        (80.0, 20.0, 50.0, 25.0, 20.0, 20.0, 20.0, 0.1, 1.8, 0.95),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mVf, mVr, mKs, mKp, sVf, sVr, sKs, sKp, K_eq, confidence = case\n\n        # Vector of measured means and standard deviations\n        m_vec = np.array([mVf, mVr, mKs, mKp])\n        s_vec = np.array([sVf, sVr, sKs, sKp])\n\n        # Step 1: Transform to log-space and determine initial covariance\n        # z0 is the vector of initial log-parameter estimates\n        z0 = np.log(m_vec)\n        \n        # Variances of log-parameters from first-order error propagation\n        # Var(ln(X)) approx (s_X / m_X)^2\n        variances = (s_vec / m_vec)**2\n        \n        # Sigma is the initial diagonal covariance matrix in log-space\n        Sigma = np.diag(variances)\n\n        # Step 2: Define the linear constraint in log-space\n        # The constraint is c.T @ z = d\n        # from ln(Vf) - ln(Vr) - ln(Ks) + ln(Kp) = ln(Keq)\n        c = np.array([1.0, -1.0, -1.0, 1.0])\n        d = np.log(K_eq)\n\n        # Step 3: Solve for the constrained estimates using the derived formula\n        # z_star = z0 - (c.T@z0 - d) / (c.T@Sigma@c) * (Sigma@c)\n        discrepancy = c @ z0 - d\n        c_Sigma_c = c @ Sigma @ c\n        \n        # The adjustment vector that enforces the constraint\n        adjustment = (discrepancy / c_Sigma_c) * (Sigma @ c)\n        \n        # z_star is the constrained log-parameter estimate vector\n        z_star = z0 - adjustment\n\n        # Transform constrained estimates back to the original parameter space\n        p_star = np.exp(z_star)\n\n        # Step 4: Calculate the constrained covariance matrix\n        # Sigma_z_star = Sigma - (Sigma @ c @ c.T @ Sigma) / (c.T @ Sigma @ c)\n        Sigma_c = Sigma @ c\n        # The numerator of the projection matrix is the outer product of (Sigma @ c)\n        proj_numerator = np.outer(Sigma_c, Sigma_c)\n        \n        # Sigma_z_star is the covariance matrix of the constrained estimates\n        Sigma_z_star = Sigma - proj_numerator / c_Sigma_c\n\n        # Step 5: Compute confidence intervals\n        # Variances of constrained log-parameters are the diagonal elements\n        var_z_star = np.diag(Sigma_z_star)\n        \n        # Ensure variances are non-negative due to potential floating point inaccuracies\n        std_z_star = np.sqrt(np.maximum(0, var_z_star))\n\n        # Get the standard normal quantile for the given confidence level\n        q = norm.ppf((1 + confidence) / 2)\n        \n        # Calculate margins of error in log-space\n        log_margins = q * std_z_star\n\n        # Confidence intervals in log-space\n        log_LCI = z_star - log_margins\n        log_UCI = z_star + log_margins\n\n        # Transform confidence intervals back to the original parameter space\n        LCI = np.exp(log_LCI)\n        UCI = np.exp(log_UCI)\n\n        # Step 6: Assemble the results for the current test case\n        case_result = [\n            p_star[0], p_star[1], p_star[2], p_star[3],\n            LCI[0], UCI[0],\n            LCI[1], UCI[1],\n            LCI[2], UCI[2],\n            LCI[3], UCI[3]\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string exactly as specified in the problem\n    case_strings = [f\"[{', '.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{', '.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2686027"}, {"introduction": "霍尔丹关系的重要性超越了单个酶，它是确保整个代谢网络模型热力学一致性的基石。在构建大规模网络模型时，我们必须确保所整合的多个酶的动力学参数不会产生逻辑上不可能的“永动机”式循环。本练习将带你从单个酶的层面上升到系统层面，学习如何利用每个酶的霍尔丹关系来检验一个完整的代谢循环路径是否违背热力学基本定律，这是代谢工程和系统生物学中模型验证的关键一步。[@problem_id:2686022]", "problem": "给定一组可逆的酶催化反应，这些反应在代谢物之间构成了化学计量循环。每个反应由单一酶催化，遵循针对单一底物和单一产物的可逆 Michaelis–Menten 机理。对于每个反应，提供了在一致单位下测量的四个宏观动力学参数：正向催化常数（转换数）和底物的正向 Michaelis 常数，以及逆向催化常数和产物的逆向 Michaelis 常数。将这些参数分别表示为 $k_{\\mathrm{cat},f}$（单位 $\\,\\mathrm{s}^{-1}$）、$K_{m,S}$（单位 $\\,\\mu\\mathrm{M}$）、$k_{\\mathrm{cat},r}$（单位 $\\,\\mathrm{s}^{-1}$）和 $K_{m,P}$（单位 $\\,\\mu\\mathrm{M}$）。假设所有 $K_m$ 值使用相同的浓度单位，以使这些参数的比率在量纲上一致，从而得到无量纲的平衡常数。\n\n从化学动力学和反应网络的基本原理出发，特别是 (i) 催化效率的定义，即在低浓度下速率对底物或产物浓度的初始斜率，(ii) 酶-底物和酶-产物复合物的质量作用动力学，以及 (iii) 封闭化学计量循环中详细平衡的热力学约束（净化学计量为零的循环，其总标准吉布斯自由能变为零），推导出将单个酶的宏观可逆参数所隐含的标准平衡常数与 $k_{\\mathrm{cat},f}$、$K_{m,S}$、$k_{\\mathrm{cat},r}$ 和 $K_{m,P}$ 联系起来的关系式。然后，利用该关系式构建一个算法，该算法对每个化学计量循环，计算沿循环给定反应方向的各反应隐含平衡常数的乘积，并返回一个布尔标记，指示该循环在指定容差范围内是否具有热力学一致性。将循环不一致性度量定义为该乘积的自然对数的绝对值。如果该度量小于或等于用户指定的容差 $\\tau$（无量纲，以自然对数为单位），则该循环被判定为一致。\n\n在一个程序中实现此推导和算法，以容差 $\\tau = 0.05$ 评估以下循环测试套件：\n\n- 循环 #1（串联的三个反应）：\n  - 反应 1：$(k_{\\mathrm{cat},f}, K_{m,S}, k_{\\mathrm{cat},r}, K_{m,P}) = (100, 100, 20, 50)$，单位为 $(\\mathrm{s}^{-1},\\,\\mu\\mathrm{M},\\,\\mathrm{s}^{-1},\\,\\mu\\mathrm{M})$。\n  - 反应 2：$(80, 100, 64, 40)$，单位同上。\n  - 反应 3：$(200, 100, 200, 80)$，单位同上。\n- 循环 #2（与循环 #1 相同，但有微小扰动以模拟实验噪声）：\n  - 反应 1：$(100, 100, 20, 50)$。\n  - 反应 2：$(80, 100, 64, 40)$。\n  - 反应 3：$(200, 100, 209.6, 80)$。\n- 循环 #3（引入了大的不一致性）：\n  - 反应 1：$(100, 100, 60, 50)$。\n  - 反应 2：$(80, 100, 64, 40)$。\n  - 反应 3：$(200, 100, 200, 80)$。\n- 循环 #4（使用极端但合理的常数以测试数值稳定性）：\n  - 反应 1：$(100, 10, 0.0001, 10)$。\n  - 反应 2：$(50, 10, 50000, 10)$。\n  - 反应 3：$(20, 10, 20000, 10)$。\n- 循环 #5（位于容差边界的临界情况）：\n  - 反应 1：$(100, 100, 20, 50)$。\n  - 反应 2：$(80, 100, 64 \\cdot e^{-0.05}, 40)$，即，逆向催化常数乘以 $e^{-\\tau}$。\n  - 反应 3：$(200, 100, 200, 80)$。\n\n所有 $K_m$ 值以 $\\,\\mu\\mathrm{M}$ 为单位，所有 $k_{\\mathrm{cat}}$ 值以 $\\,\\mathrm{s}^{-1}$ 为单位。每个反应的隐含标准平衡常数必须是无量纲的。程序的唯一输出应为一行，包含一个布尔值列表，每个循环一个，按从循环 #1 到循环 #5 的顺序排列，其中每个布尔值为真当且仅当循环不一致性度量小于或等于 $\\tau$。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：[True, True, False, True, True]）。\n\n不需要用户输入。程序必须硬编码上述测试套件和容差 $\\tau = 0.05$，并完全按照规定打印五个循环的布尔结果。", "solution": "所述问题在科学上是合理的、自洽的且表述清晰。它提出了一个化学动力学中的标准练习，要求应用基本原理来验证循环反应网络的动力学数据的热力学一致性。所有必要的数据和定义都已提供，没有歧义或矛盾。我们将进行形式推导和算法构建。\n\n问题的核心在于两个基本原理：单个可逆酶促反应的 Haldane 关系式，以及应用于化学计量循环的详细平衡定律。\n\n首先，我们必须推导出酶的宏观动力学参数与反应的标准平衡常数 $K_{eq}$ 之间的关系。问题指定了一个可逆的 Michaelis-Menten 机理，用于将单一底物 $S$ 转化为单一产物 $P$ 的反应：$S \\longleftrightarrow P$。该反应由总浓度为 $[E_T]$ 的酶催化，其净速率 $v$ 由可逆速率方程给出：\n$$\n\\frac{v}{[E_T]} = \\frac{k_{\\mathrm{cat},f} \\frac{[S]}{K_{m,S}} - k_{\\mathrm{cat},r} \\frac{[P]}{K_{m,P}}}{1 + \\frac{[S]}{K_{m,S}} + \\frac{[P]}{K_{m,P}}}\n$$\n其中 $k_{\\mathrm{cat},f}$ 和 $K_{m,S}$ 分别是底物 $S$ 的正向催化常数和 Michaelis 常数，而 $k_{\\mathrm{cat},r}$ 和 $K_{m,P}$ 则是产物 $P$ 相应的逆向参数。\n\n一个关键概念是催化效率，定义为反应速率对反应物浓度的初始斜率。对于正向反应（$S \\to P$），我们设 $[P]=0$ 并考察 $[S] \\to 0$ 时的极限：\n$$\nv_f = [E_T] \\frac{k_{\\mathrm{cat},f} [S] / K_{m,S}}{1 + [S] / K_{m,S}} \\approx [E_T] \\left( \\frac{k_{\\mathrm{cat},f}}{K_{m,S}} \\right) [S]\n$$\n项 $k_{\\mathrm{cat},f}/K_{m,S}$ 代表了游离酶将游离底物转化为产物的表观二级速率常数。同样，对于逆向反应（$P \\to S$），设 $[S]=0$ 并取 $[P] \\to 0$ 的极限，S 的生成速率为：\n$$\nv_r = [E_T] \\frac{k_{\\mathrm{cat},r} [P] / K_{m,P}}{1 + [P] / K_{m,P}} \\approx [E_T] \\left( \\frac{k_{\\mathrm{cat},r}}{K_{m,P}} \\right) [P]\n$$\n项 $k_{\\mathrm{cat},r}/K_{m,P}$ 是逆向反应的催化效率。\n\n在热力学平衡时，净反应速率 $v$ 必须为零。从完整的速率方程可知，此条件意味着分子必须为零：\n$$\nk_{\\mathrm{cat},f} \\frac{[S]_{eq}}{K_{m,S}} - k_{\\mathrm{cat},r} \\frac{[P]_{eq}}{K_{m,P}} = 0\n$$\n其中 $[S]_{eq}$ 和 $[P]_{eq}$ 是平衡浓度。反应的标准平衡常数定义为 $K_{eq} = [P]_{eq} / [S]_{eq}$。重新排列方程可得此关系：\n$$\nK_{eq} = \\frac{[P]_{eq}}{[S]_{eq}} = \\frac{k_{\\mathrm{cat},f} / K_{m,S}}{k_{\\mathrm{cat},r} / K_{m,P}} = \\frac{k_{\\mathrm{cat},f} \\cdot K_{m,P}}{k_{\\mathrm{cat},r} \\cdot K_{m,S}}\n$$\n这就是 Haldane 关系式。它提供了一种从纯动力学测量计算热力学平衡常数的方法。\n\n其次，我们将详细平衡原理应用于化学计量循环。对于任何闭合的反应环路，总的标准吉布斯自由能变化 $\\Delta G_{cycle}^\\circ$ 必须为零。这是因为吉布斯自由能是一个状态函数。对于由反应 $i=1, 2, ..., n$ 组成的循环，我们有：\n$$\n\\Delta G_{cycle}^\\circ = \\sum_{i=1}^{n} \\Delta G_{i}^\\circ = 0\n$$\n由于反应的标准吉布斯自由能变化与其平衡常数通过 $\\Delta G_{i}^\\circ = -RT \\ln K_{eq,i}$ 相关，该条件变为：\n$$\n-RT \\sum_{i=1}^{n} \\ln K_{eq,i} = -RT \\ln \\left( \\prod_{i=1}^{n} K_{eq,i} \\right) = 0\n$$\n这意味着，对于一个热力学一致的循环，沿循环方向的各反应平衡常数的乘积必须恰好为 1：\n$$\n\\prod_{i=1}^{n} K_{eq,i} = 1\n$$\n由于测量动力学参数时存在实验误差，该乘积很少会精确等于 $1$。问题定义了一个循环不一致性度量来量化此偏差。它由平衡常数乘积的自然对数的绝对值给出：\n$$\n\\text{Inconsistency Metric} = \\left| \\ln \\left( \\prod_{i=1}^{n} K_{eq,i} \\right) \\right| = \\left| \\sum_{i=1}^{n} \\ln K_{eq,i} \\right|\n$$\n使用对数求和在数值上更优，因为它避免了在乘以许多可能非常大或非常小的平衡常数时可能出现的上溢或下溢问题。\n\n验证一个循环的算法如下：\n$1$。对于给定循环中的每个反应 $i$，使用提供的参数（$k_{\\mathrm{cat},f,i}$、$K_{m,S,i}$、$k_{\\mathrm{cat},r,i}$、$K_{m,P,i}$），利用 Haldane 关系式计算其平衡常数的自然对数：\n$$\n\\ln K_{eq,i} = \\ln \\left( \\frac{k_{\\mathrm{cat},f,i} \\cdot K_{m,P,i}}{k_{\\mathrm{cat},r,i} \\cdot K_{m,S,i}} \\right)\n$$\n$2$。将循环中所有反应的这些对数值相加，得到 $\\sum_{i} \\ln K_{eq,i}$。\n$3$。取该总和的绝对值来计算不一致性度量。\n$4$。将该度量与指定的容差 $\\tau$ 进行比较。如果该度量小于或等于 $\\tau$，则该循环被视为一致。\n\n提供的 Python 程序实现了这一精确算法。它遍历每个指定的循环，计算每个循环的不一致性度量，并将其与容差 $\\tau = 0.05$ 进行比较，以生成最终的布尔一致性标志列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the thermodynamic consistency of enzyme-catalyzed reaction cycles.\n    \"\"\"\n    \n    # Define the tolerance for thermodynamic consistency in natural-log units.\n    tau = 0.05\n\n    # Define the test suite of cycles. Each cycle is a list of reactions,\n    # and each reaction is a tuple of kinetic parameters:\n    # (k_cat_f (s^-1), K_m_S (uM), k_cat_r (s^-1), K_m_P (uM))\n    test_cases = [\n        # Cycle #1: A perfectly consistent cycle.\n        [\n            (100.0, 100.0, 20.0, 50.0),\n            (80.0, 100.0, 64.0, 40.0),\n            (200.0, 100.0, 200.0, 80.0)\n        ],\n        # Cycle #2: A cycle with a small perturbation, still within tolerance.\n        [\n            (100.0, 100.0, 20.0, 50.0),\n            (80.0, 100.0, 64.0, 40.0),\n            (200.0, 100.0, 209.6, 80.0)\n        ],\n        # Cycle #3: A cycle with a large inconsistency.\n        [\n            (100.0, 100.0, 60.0, 50.0),\n            (80.0, 100.0, 64.0, 40.0),\n            (200.0, 100.0, 200.0, 80.0)\n        ],\n        # Cycle #4: A consistent cycle with extreme parameter values to test numerical stability.\n        [\n            (100.0, 10.0, 0.0001, 10.0),\n            (50.0, 10.0, 50000.0, 10.0),\n            (20.0, 10.0, 20000.0, 10.0)\n        ],\n        # Cycle #5: A cycle designed to lie exactly at the tolerance boundary.\n        [\n            (100.0, 100.0, 20.0, 50.0),\n            (80.0, 100.0, 64.0 * np.exp(-tau), 40.0),\n            (200.0, 100.0, 200.0, 80.0)\n        ]\n    ]\n\n    results = []\n    for cycle in test_cases:\n        # Use the sum of logarithms for numerical robustness.\n        # sum(ln(K_eq)) = ln(product(K_eq)).\n        sum_ln_K_eq = 0.0\n\n        for reaction_params in cycle:\n            k_cat_f, K_m_S, k_cat_r, K_m_P = reaction_params\n            \n            # The Haldane relationship provides the equilibrium constant K_eq.\n            # K_eq = (k_cat_f / K_m_S) / (k_cat_r / K_m_P)\n            # This is equivalent to: K_eq = (k_cat_f * K_m_P) / (k_cat_r * K_m_S)\n            \n            # All kinetic parameters must be positive. Division by zero or log of a non-positive\n            # number indicates an unphysical situation that makes the cycle inconsistent.\n            if k_cat_r = 0 or K_m_S = 0 or k_cat_f  0 or K_m_P  0:\n                sum_ln_K_eq = float('inf')\n                break\n\n            K_eq = (k_cat_f * K_m_P) / (k_cat_r * K_m_S)\n            \n            if K_eq = 0:\n                sum_ln_K_eq = float('inf')\n                break\n\n            sum_ln_K_eq += np.log(K_eq)\n        \n        # The inconsistency metric is the absolute value of the sum of the logs.\n        inconsistency_metric = abs(sum_ln_K_eq)\n        \n        # A cycle is consistent if the metric is less than or equal to the tolerance.\n        is_consistent = inconsistency_metric = tau\n        results.append(is_consistent)\n\n    # Format the final output as a single line: [True,False,...]\n    # The str() function for booleans produces the required 'True'/'False' capitalization.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2686022"}]}