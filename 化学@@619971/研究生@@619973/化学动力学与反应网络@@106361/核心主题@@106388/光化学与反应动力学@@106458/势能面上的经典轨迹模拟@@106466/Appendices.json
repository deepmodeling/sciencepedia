{"hands_on_practices": [{"introduction": "在进行任何经典轨迹模拟之前，一个最基本且至关重要的决定是选择合适的积分时间步长 $\\Delta t$。这个选择直接关系到数值积分的稳定性和准确性，进而影响整个模拟结果的可靠性。此练习将引导你通过一个具体的例子，即一个高频化学键的振动，来确定一个能确保积分稳定性的时间步长，从而掌握分子动力学模拟设置中的核心实践技能。[@problem_id:2632264]", "problem": "在一个基元反应的Born–Oppenheimer势能面（PES）上进行的经典分子动力学（MD）轨道模拟中，最快的振动自由度属于波数为 $\\tilde{\\nu} = 3500\\,\\mathrm{cm}^{-1}$ 的X–H键伸缩模式。这些轨道将使用速度-Verlet算法进行积分。为确保数值稳定性和对最快振荡的足够分辨率，要求最快谐振模式的每个积分步长的相位推进最多为 $\\pi/10$ 弧度。利用基于光速 $c = 2.99792458 \\times 10^{10}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}$ 的波数与频率之间的关系，确定一个满足此要求的合适时间步长 $\\Delta t$（单位为飞秒）。将最终数值答案四舍五入至 $3$ 位有效数字，并以飞秒表示。然后，简要讨论在每条轨道的总模拟物理时间固定的假设下，$\\Delta t$ 的这一选择如何影响通过PES上的MD轨道系综计算反应速率常数的计算成本。", "solution": "所给问题具有科学依据，提法恰当且客观。它提出了分子动力学模拟设置中所需的一项标准计算，并提供了所有必要的物理常数和约束条件。该问题是有效的。\n\n中心任务是确定满足系统中振动最快的模式的稳定性判据的最大积分时间步长 $\\Delta t$。像速度-Verlet算法这类数值积分方案的稳定性，关键取决于时间步长要远小于系统中最快运动的周期。\n\n首先，我们必须将给定的波数 $\\tilde{\\nu}$ 与模拟X–H键伸缩的谐振子的角频率 $\\omega$ 联系起来。波数 $\\tilde{\\nu}$ 是单位长度内的波的数目，单位通常是 $\\mathrm{cm}^{-1}$。频率 $\\nu$（单位为 $\\mathrm{s}^{-1}$ 或 Hz）通过光速 $c$ 与波数相关联：\n$$\n\\nu = c \\tilde{\\nu}\n$$\n角频率 $\\omega$（单位为弧度/秒）与频率 $\\nu$ 的关系为：\n$$\n\\omega = 2\\pi\\nu\n$$\n结合这两个关系式，我们直接用 $\\tilde{\\nu}$ 和 $c$ 来表示 $\\omega$：\n$$\n\\omega = 2\\pi c \\tilde{\\nu}\n$$\n问题对每个积分步长的相位推进 $\\Delta\\phi$ 施加了约束。对于谐振子，在时间间隔 $\\Delta t$ 内，相位推进为 $\\omega \\Delta t$。要求是这个相位推进不超过 $\\pi/10$ 弧度：\n$$\n\\Delta\\phi = \\omega \\Delta t \\le \\frac{\\pi}{10}\n$$\n为求得允许的最大时间步长，我们使用等式求解 $\\Delta t$：\n$$\n\\Delta t = \\frac{\\pi}{10\\omega}\n$$\n现在，将 $\\omega$ 的表达式代入给定参数中：\n$$\n\\Delta t = \\frac{\\pi}{10(2\\pi c \\tilde{\\nu})} = \\frac{1}{20 c \\tilde{\\nu}}\n$$\n这个方程给出了最大合适的步长。我们已知的值为：\n$\\tilde{\\nu} = 3500\\,\\mathrm{cm}^{-1}$\n$c = 2.99792458 \\times 10^{10}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}$\n\n将这些值代入 $\\Delta t$ 的表达式中：\n$$\n\\Delta t = \\frac{1}{20 \\times (2.99792458 \\times 10^{10}\\,\\mathrm{cm}\\,\\mathrm{s}^{-1}) \\times (3500\\,\\mathrm{cm}^{-1})}\n$$\n单位 $\\mathrm{cm}^{-1}$ 和 $\\mathrm{cm}$ 消去，结果的单位为秒 ($\\mathrm{s}$)。\n$$\n\\Delta t = \\frac{1}{20 \\times 3500 \\times 2.99792458 \\times 10^{10}}\\,\\mathrm{s}\n$$\n$$\n\\Delta t = \\frac{1}{70000 \\times 2.99792458 \\times 10^{10}}\\,\\mathrm{s}\n$$\n$$\n\\Delta t = \\frac{1}{2.098547206 \\times 10^{15}}\\,\\mathrm{s} \\approx 4.76520 \\times 10^{-16}\\,\\mathrm{s}\n$$\n问题要求答案以飞秒 ($\\mathrm{fs}$) 为单位，其中 $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$。我们转换结果：\n$$\n\\Delta t \\approx (4.76520 \\times 10^{-16}\\,\\mathrm{s}) \\times \\left(\\frac{1\\,\\mathrm{fs}}{10^{-15}\\,\\mathrm{s}}\\right) = 0.476520\\,\\mathrm{fs}\n$$\n四舍五入到 $3$ 位有效数字，我们得到 $\\Delta t = 0.477\\,\\mathrm{fs}$。\n\n关于问题的第二部分，选择如此小的 $\\Delta t$ 对计算成本有直接而显著的影响。模拟一个物理时间长度 $T_{\\text{total}}$ 所需的总积分步数 $N_{\\text{steps}}$ 由以下关系式给出：\n$$\nN_{\\text{steps}} = \\frac{T_{\\text{total}}}{\\Delta t}\n$$\n为了计算出统计上有意义的反应速率常数，必须模拟大量的轨道系综，每条轨道的物理时间 $T_{\\text{total}}$ 都必须足够长，以观察到反应事件。总计算成本与总的力计算次数成正比，而力计算次数又与 $N_{\\text{steps}}$ 成正比。如方程所示，$N_{\\text{steps}}$ 与 $\\Delta t$ 成反比。\n\n因此，一个小的 $\\Delta t$（例如由快速的X-H键振动决定的约 $0.5\\,\\mathrm{fs}$ 的值）迫使模拟需要执行大量的小步长来覆盖给定的物理时间。这极大地增加了计算成本。例如，如果时间步长大 $10$ 倍，模拟速度将大约快 $10$ 倍。然而，如此大的时间步长将无法分辨X–H伸缩振动，从而导致数值不稳定和非物理的动力学行为。在精度/稳定性与计算成本之间的这种权衡是分子动力学模拟中的一个根本性挑战，特别是对于包含像氢这样的轻原子的系统。", "answer": "$$\n\\boxed{0.477}\n$$", "id": "2632264"}, {"introduction": "在能够在势能面上稳定地传播轨迹之后，下一步是理解势能面本身的地形。势能面上的驻点——包括能量极小点（对应反应物和产物）和鞍点（对应过渡态）——是决定化学反应路径和速率的关键地貌特征。通过这个练习，你将亲手实现一个基于牛顿-拉夫逊方法的算法，来定位并表征这些驻点，从而将抽象的势能面概念转化为可计算和可分析的实体。[@problem_id:2632278]", "problem": "考虑一个由两次连续可微的标量势函数 $V(q_1,q_2)$ 定义的双自由度势能面（PES），其中 $q_1$ 和 $q_2$ 是无量纲的广义坐标。在势能面的经典轨线模拟中，$V$ 在驻点（$\\nabla V = \\mathbf{0}$ 的解）附近的局域结构通过过渡态（一个一阶鞍点）决定了反应瓶颈。你的任务是实现一个牛顿-拉夫逊驻点搜索算法，该算法使用 $V$ 的解析梯度和黑塞矩阵，然后通过计算在收敛点处黑塞矩阵的负特征值数量来验证驻点的指数。完全在数学术语下进行，无外部输入。\n\n使用的基本原理：从梯度的泰勒展开和驻点条件 $\\nabla V(\\mathbf{q}^\\star) = \\mathbf{0}$ 出发。不要假定任何预先推导的更新公式；通过在当前迭代点附近对 $\\nabla V$ 进行线性化，从第一性原理推导出牛顿-拉夫逊步长。由于驻点不一定是极小值点，因此应使用与收敛到驻点相符的步长控制方法（例如，通过减小梯度的范数）。\n\n实现以下要求：\n\n- 变量和算符：\n  - 令 $\\mathbf{q} = (q_1,q_2)^\\top$。\n  - 令 $\\mathbf{g}(\\mathbf{q}) = \\nabla V(\\mathbf{q}) \\in \\mathbb{R}^2$ 为梯度。\n  - 令 $\\mathbf{H}(\\mathbf{q}) = \\nabla^2 V(\\mathbf{q}) \\in \\mathbb{R}^{2 \\times 2}$ 为黑塞矩阵。\n  - 使用收敛容差 $\\varepsilon_{\\text{grad}} = 10^{-10}$（基于欧几里得范数 $\\|\\mathbf{g}(\\mathbf{q})\\|_2$），最大迭代次数 $N_{\\max} = 50$，以及在线搜索中当完整步长未能减小 $\\|\\mathbf{g}(\\mathbf{q})\\|_2$ 时使用的回溯因子 $\\beta = \\tfrac{1}{2}$。如果黑塞矩阵是病态或奇异的，则通过加上 $\\mu \\mathbf{I}$ 对其进行正则化，其中 $\\mu > 0$ 自适应选择，直到可以计算出步长。\n  - 将驻点指数确定为 $\\mathbf{H}(\\mathbf{q}^\\star)$ 的负特征值的整数计数，使用特征值阈值 $\\varepsilon_{\\lambda} = 10^{-8}$；也就是说，将满足 $\\lambda < -\\varepsilon_{\\lambda}$ 的特征值 $\\lambda$ 计为负值。\n- 单位：\n  - 坐标 $q_1,q_2$ 和能量 $V$ 均为无量纲。报告的能量单位与 $V$ 定义的任意能量单位相同。\n- 输出规范：\n  - 对于每个测试用例，返回一个列表 $[q_1^\\star, q_2^\\star, \\text{index}, V^\\star]$，其中 $q_1^\\star$ 和 $q_2^\\star$ 是收敛后的坐标，$\\text{index}$ 是一个整数，以及 $V^\\star = V(q_1^\\star,q_2^\\star)$。将 $q_1^\\star$、$q_2^\\star$ 和 $V^\\star$ 四舍五入到6位小数。\n  - 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表；例如，$[r_1,r_2,r_3,\\ldots]$，其中每个 $r_k$ 是按上述规定格式化的测试用例 $k$ 的列表。\n\n测试套件：\n\n为以下四个解析势函数实现牛顿-拉夫逊搜索。对于每个势函数，使用提供的梯度 $\\mathbf{g}$、黑塞矩阵 $\\mathbf{H}$ 和初始猜测值 $\\mathbf{q}^{(0)}$，并生成结果 $[q_1^\\star, q_2^\\star, \\text{index}, V^\\star]$。\n\n- 测试用例 1 (带耦合的非定二次型，一阶鞍点):\n  - $V_1(q_1,q_2) = \\tfrac{1}{2}\\left(2 q_1^2 - 1\\cdot q_2^2\\right) + 0.3\\, q_1 q_2$。\n  - $\\mathbf{g}_1(q_1,q_2) = \\begin{bmatrix} 2 q_1 + 0.3 q_2 \\\\ - q_2 + 0.3 q_1 \\end{bmatrix}$。\n  - $\\mathbf{H}_1(q_1,q_2) = \\begin{bmatrix} 2 & 0.3 \\\\ 0.3 & -1 \\end{bmatrix}$。\n  - 初始猜测值 $\\mathbf{q}^{(0)} = (1.0, 1.0)^\\top$。\n- 测试用例 2 (四次项约束下的极大值点，指数为2):\n  - $V_2(q_1,q_2) = -\\left(q_1^2 + 2 q_2^2\\right) + \\tfrac{1}{4}\\left(q_1^4 + q_2^4\\right)$。\n  - $\\mathbf{g}_2(q_1,q_2) = \\begin{bmatrix} -2 q_1 + q_1^3 \\\\ -4 q_2 + q_2^3 \\end{bmatrix}$。\n  - $\\mathbf{H}_2(q_1,q_2) = \\begin{bmatrix} -2 + 3 q_1^2 & 0 \\\\ 0 & -4 + 3 q_2^2 \\end{bmatrix}$。\n  - 初始猜测值 $\\mathbf{q}^{(0)} = (0.2, -0.1)^\\top$。\n- 测试用例 3 (沿 $q_1$ 的双阱与沿 $q_2$ 的谐振子交叉，原点处为一阶鞍点):\n  - $V_3(q_1,q_2) = \\left(q_1^2 - 1\\right)^2 + \\tfrac{1}{2} q_2^2$。\n  - $\\mathbf{g}_3(q_1,q_2) = \\begin{bmatrix} 4 q_1 \\left(q_1^2 - 1\\right) \\\\ q_2 \\end{bmatrix}$。\n  - $\\mathbf{H}_3(q_1,q_2) = \\begin{bmatrix} 12 q_1^2 - 4 & 0 \\\\ 0 & 1 \\end{bmatrix}$。\n  - 初始猜测值 $\\mathbf{q}^{(0)} = (0.3, 0.4)^\\top$。\n- 测试用例 4 (带耦合的正定二次型，零阶极小值点):\n  - $V_4(q_1,q_2) = \\tfrac{1}{2}\\left(q_1^2 + q_2^2\\right) + 0.1\\, q_1 q_2$。\n  - $\\mathbf{g}_4(q_1,q_2) = \\begin{bmatrix} q_1 + 0.1 q_2 \\\\ q_2 + 0.1 q_1 \\end{bmatrix}$。\n  - $\\mathbf{H}_4(q_1,q_2) = \\begin{bmatrix} 1 & 0.1 \\\\ 0.1 & 1 \\end{bmatrix}$。\n  - 初始猜测值 $\\mathbf{q}^{(0)} = (2.0, -1.0)^\\top$。\n\n算法要求：\n\n- 实现一个通过在当前迭代点附近对 $\\mathbf{g}(\\mathbf{q})$ 进行线性化推导出的牛顿-拉夫逊迭代，以计算试验步长。如果黑塞矩阵不可解或病态，则通过加上 $\\mu \\mathbf{I}$ 进行正则化，并根据需要增加 $\\mu$ 直到可以获得步长。\n- 对步长 $\\alpha \\in (0,1]$ 使用回溯法以确保 $\\|\\mathbf{g}(\\mathbf{q})\\|_2$ 减小；例如，如果 $\\|\\mathbf{g}(\\mathbf{q} + \\alpha \\mathbf{s})\\|_2 \\ge \\|\\mathbf{g}(\\mathbf{q})\\|_2$，则减小 $\\alpha \\leftarrow \\beta \\alpha$（其中 $\\beta = \\tfrac{1}{2}$），直至达到一个合理的最小步长。\n- 当 $\\|\\mathbf{g}(\\mathbf{q})\\|_2 \\le \\varepsilon_{\\text{grad}}$，或迭代次数达到 $N_{\\max}$，或步长变得过小无法取得进展时，停止迭代。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个Python风格的列表，该列表包含四个子列表，每个子列表对应一个测试用例，顺序为 $[q_1^\\star, q_2^\\star, \\text{index}, V^\\star]$，其中 $q_1^\\star$、$q_2^\\star$ 和 $V^\\star$ 四舍五入到6位小数，$\\text{index}$ 为整数。例如：$[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$。", "solution": "该问题要求实现牛顿-拉夫逊算法，以在二维势能面 $V(q_1, q_2)$ 上定位驻点，并根据其指数对这些点进行表征。此任务的基础在于数值优化和线性代数。\n\n势能函数 $V(\\mathbf{q})$ 的驻点（记为 $\\mathbf{q}^\\star$）是函数梯度为零的点。对于我们的二维系统，其坐标为 $\\mathbf{q} = (q_1, q_2)^\\top$，此条件表示为：\n$$\n\\mathbf{g}(\\mathbf{q}^\\star) = \\nabla V(\\mathbf{q}^\\star) = \\begin{bmatrix} \\frac{\\partial V}{\\partial q_1} \\\\ \\frac{\\partial V}{\\partial q_2} \\end{bmatrix}_{\\mathbf{q}=\\mathbf{q}^\\star} = \\mathbf{0}\n$$\n牛顿-拉夫逊法是求解非线性方程组根的迭代过程。在这里，我们用它来求解梯度向量的根，即 $\\mathbf{g}(\\mathbf{q}) = \\mathbf{0}$。\n\n推导过程始于梯度向量 $\\mathbf{g}(\\mathbf{q})$ 在当前迭代点 $\\mathbf{q}^{(k)}$ 附近的一阶泰勒展开。令 $\\Delta\\mathbf{q} = \\mathbf{q}^{(k+1)} - \\mathbf{q}^{(k)}$ 为到下一个迭代点的步长。新点 $\\mathbf{q}^{(k+1)}$ 处的梯度近似为：\n$$\n\\mathbf{g}(\\mathbf{q}^{(k+1)}) = \\mathbf{g}(\\mathbf{q}^{(k)} + \\Delta\\mathbf{q}) \\approx \\mathbf{g}(\\mathbf{q}^{(k)}) + \\mathbf{H}(\\mathbf{q}^{(k)}) \\Delta\\mathbf{q}\n$$\n其中 $\\mathbf{H}(\\mathbf{q}^{(k)})$ 是在 $\\mathbf{q}^{(k)}$ 处计算的由 $V$ 的二阶偏导数构成的黑塞矩阵：\n$$\n\\mathbf{H}(\\mathbf{q}) = \\nabla^2 V(\\mathbf{q}) = \\begin{bmatrix} \\frac{\\partial^2 V}{\\partial q_1^2} & \\frac{\\partial^2 V}{\\partial q_1 \\partial q_2} \\\\ \\frac{\\partial^2 V}{\\partial q_2 \\partial q_1} & \\frac{\\partial^2 V}{\\partial q_2^2} \\end{bmatrix}\n$$\n为了找到驻点，我们将下一个迭代点的梯度设为零，即 $\\mathbf{g}(\\mathbf{q}^{(k+1)}) = \\mathbf{0}$。这导出了关于未知步长 $\\Delta\\mathbf{q}$ 的以下线性系统：\n$$\n\\mathbf{g}(\\mathbf{q}^{(k)}) + \\mathbf{H}(\\mathbf{q}^{(k)}) \\Delta\\mathbf{q} = \\mathbf{0}\n$$\n重新整理以求解 $\\Delta\\mathbf{q}$（我们称之为牛顿步长 $\\mathbf{s}^{(k)}$），得到：\n$$\n\\mathbf{H}(\\mathbf{q}^{(k)}) \\mathbf{s}^{(k)} = -\\mathbf{g}(\\mathbf{q}^{(k)})\n$$\n因此，步长 $\\mathbf{s}^{(k)}$ 通过求解这个线性方程组得到。然后，下一个迭代点被提议为：\n$$\n\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} + \\mathbf{s}^{(k)}\n$$\n\n完整的算法如下：\n\n1.  **初始化**：从一个初始猜测值 $\\mathbf{q}^{(0)}$、收敛容差 $\\varepsilon_{\\text{grad}} = 10^{-10}$、最大迭代次数 $N_{\\max} = 50$ 和回溯因子 $\\beta = \\frac{1}{2}$ 开始。\n\n2.  **迭代**：对于 $k = 0, 1, 2, \\dots$，直到收敛或 $k = N_{\\max}$：\n    a.  **求值**：计算梯度向量 $\\mathbf{g}_k = \\mathbf{g}(\\mathbf{q}^{(k)})$ 和黑塞矩阵 $\\mathbf{H}_k = \\mathbf{H}(\\mathbf{q}^{(k)})$。\n    b.  **检查收敛性**：计算梯度的欧几里得范数 $\\|\\mathbf{g}_k\\|_2$。如果 $\\|\\mathbf{g}_k\\|_2 \\le \\varepsilon_{\\text{grad}}$，算法已收敛。驻点为 $\\mathbf{q}^\\star = \\mathbf{q}^{(k)}$。终止迭代。\n    c.  **计算搜索方向**：求解牛顿系统 $\\mathbf{H}_k \\mathbf{s}_k = -\\mathbf{g}_k$ 以获得搜索方向 $\\mathbf{s}_k$。\n        -   **正则化**：如果 $\\mathbf{H}_k$ 是奇异或病态的，该系统无法可靠求解。在此类情况下，通过加上一个小的单位矩阵倍数 $\\mu\\mathbf{I}$（其中 $\\mu > 0$）来对黑塞矩阵进行正则化。我们求解修正后的系统 $(\\mathbf{H}_k + \\mu\\mathbf{I}) \\mathbf{s}_k = -\\mathbf{g}_k$。$\\mu$ 的值是自适应选择的，从 $\\mu=0$ 开始，并（例如）以10为因子增加，直到矩阵变得可逆。\n    d.  **带回溯的线搜索**：完整的牛顿步长（$\\alpha=1$）可能不会导致梯度范数的减小，而梯度范数是我们衡量向驻点前进程度的指标。我们引入一个步长 $\\alpha_k \\in (0, 1]$，并按 $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} + \\alpha_k \\mathbf{s}_k$ 更新位置。我们从 $\\alpha_k=1$ 开始，检查是否满足条件 $\\|\\mathbf{g}(\\mathbf{q}^{(k)} + \\alpha_k \\mathbf{s}_k)\\|_2 < \\|\\mathbf{g}_k\\|_2$。如果不满足，我们通过回溯因子减小步长，$\\alpha_k \\leftarrow \\beta \\alpha_k$，并重复检查，直到满足条件或 $\\alpha_k$ 小于某个最小阈值，表明计算停滞。\n    e.  **更新**：设置下一个迭代点为 $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} + \\alpha_k \\mathbf{s}_k$。\n\n3.  **驻点分析**：在算法收敛到 $\\mathbf{q}^\\star$ 后，我们分析其性质。驻点的指数定义为在该点计算的黑塞矩阵 $\\mathbf{H}^\\star = \\mathbf{H}(\\mathbf{q}^\\star)$ 的负特征值的数量。\n    -   我们计算对称矩阵 $\\mathbf{H}^\\star$ 的特征值 $\\lambda_i$。\n    -   指数是严格为负的特征值的计数，同时考虑数值精度。如果一个特征值 $\\lambda_i < -\\varepsilon_{\\lambda}$（其中 $\\varepsilon_{\\lambda} = 10^{-8}$），我们将其计为负值。\n    -   指数为0对应于极小值点，指数为2（对于二维系统）对应于极大值点，指数为1对应于一阶鞍点，通常称为过渡态。\n\n4.  **最终输出**：对于每个测试用例，我们报告收敛后的坐标 $[q_1^\\star, q_2^\\star]$、驻点的整数指数以及该点的势能 $V^\\star = V(\\mathbf{q}^\\star)$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the stationary point search\n    for all test cases and prints the final results.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    EPS_GRAD = 1e-10\n    MAX_ITER = 50\n    BETA = 0.5\n    EPS_LAMBDA = 1e-8\n    MIN_ALPHA = 1e-12\n    MU_INIT = 1e-8\n    MU_FACTOR = 10.0\n    \n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            \"V\": lambda q: 0.5 * (2 * q[0]**2 - q[1]**2) + 0.3 * q[0] * q[1],\n            \"g\": lambda q: np.array([2 * q[0] + 0.3 * q[1], -q[1] + 0.3 * q[0]]),\n            \"H\": lambda q: np.array([[2.0, 0.3], [0.3, -1.0]]),\n            \"q0\": np.array([1.0, 1.0]),\n        },\n        {\n            \"V\": lambda q: -(q[0]**2 + 2 * q[1]**2) + 0.25 * (q[0]**4 + q[1]**4),\n            \"g\": lambda q: np.array([-2 * q[0] + q[0]**3, -4 * q[1] + q[1]**3]),\n            \"H\": lambda q: np.array([[-2 + 3 * q[0]**2, 0.0], [0.0, -4 + 3 * q[1]**2]]),\n            \"q0\": np.array([0.2, -0.1]),\n        },\n        {\n            \"V\": lambda q: (q[0]**2 - 1)**2 + 0.5 * q[1]**2,\n            \"g\": lambda q: np.array([4 * q[0] * (q[0]**2 - 1), q[1]]),\n            \"H\": lambda q: np.array([[12 * q[0]**2 - 4, 0.0], [0.0, 1.0]]),\n            \"q0\": np.array([0.3, 0.4]),\n        },\n        {\n            \"V\": lambda q: 0.5 * (q[0]**2 + q[1]**2) + 0.1 * q[0] * q[1],\n            \"g\": lambda q: np.array([q[0] + 0.1 * q[1], q[1] + 0.1 * q[0]]),\n            \"H\": lambda q: np.array([[1.0, 0.1], [0.1, 1.0]]),\n            \"q0\": np.array([2.0, -1.0]),\n        },\n    ]\n\n    def find_stationary_point(V, g, H, q0):\n        \"\"\"\n        Implements the Newton-Raphson algorithm with regularization and backtracking.\n        \"\"\"\n        q = np.copy(q0)\n        \n        for _ in range(MAX_ITER):\n            grad_k = g(q)\n            norm_grad_k = np.linalg.norm(grad_k)\n\n            if norm_grad_k < EPS_GRAD:\n                break\n            \n            H_k = H(q)\n            \n            # --- Solve for Newton step with regularization ---\n            mu = 0.0\n            step = None\n            while step is None:\n                try:\n                    H_reg = H_k + mu * np.identity(2)\n                    step = np.linalg.solve(H_reg, -grad_k)\n                except np.linalg.LinAlgError:\n                    if mu == 0.0:\n                        mu = MU_INIT\n                    else:\n                        mu *= MU_FACTOR\n                    if mu > 1e6:  # Failsafe\n                        return None # Could not find a suitable step\n            \n            # --- Backtracking line search ---\n            alpha = 1.0\n            while alpha > MIN_ALPHA:\n                q_trial = q + alpha * step\n                grad_trial = g(q_trial)\n                if np.linalg.norm(grad_trial) < norm_grad_k:\n                    break\n                alpha *= BETA\n            else: # If alpha became too small, stall\n                break\n            \n            q = q + alpha * step\n\n        # --- Post-convergence analysis ---\n        q_star = q\n        H_star = H(q_star)\n        \n        # Eigenvalues of the real symmetric Hessian\n        eigenvalues = np.linalg.eigvalsh(H_star)\n        \n        # Count negative eigenvalues to find the index\n        index = np.sum(eigenvalues < -EPS_LAMBDA)\n        \n        V_star = V(q_star)\n        \n        return [\n            round(q_star[0], 6), \n            round(q_star[1], 6), \n            int(index), \n            round(V_star, 6)\n        ]\n\n    results = []\n    for case in test_cases:\n        result = find_stationary_point(case[\"V\"], case[\"g\"], case[\"H\"], case[\"q0\"])\n        results.append(result)\n\n    # Format output according to specification\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2632278"}, {"introduction": "过渡态理论是化学动力学的基石，它假设凡是穿过位于过渡态的分割面的轨迹，都会直接形成产物而不再返回。本练习将让你通过运行真实的经典轨迹来检验这一关键的“无再交叉”假设。你将比较一个动态上正确的分割面和一个简单的几何分割面，通过计算轨迹的再交叉次数，亲身体会这一假设的有效性及其对反应速率计算的影响。[@problem_id:2632247]", "problem": "您将为一个两自由度的越垒反应哈密顿模型实现并比较两种构型空间划分面 (DS)，并通过统计在二次势能面 (PES) 上积分得到的经典轨道测试系综中的轨迹穿越次数，来评估动力学再穿越现象。这两种 DS 分别是：(i) 在鞍点处与不稳定模式正交的面，以及 (ii) 沿选定轴的恒定反应坐标的几何面。您必须从 Newton 定律和 Hamilton 运动方程出发推导出此算法。\n\n模型定义：\n- 考虑一个二维构型矢量 $\\mathbf{q} = (x,y)^{\\mathsf{T}}$ 和共轭动量 $\\mathbf{p} = (p_x,p_y)^{\\mathsf{T}}$，质量为单位质量，因此动能为 $T(\\mathbf{p}) = \\tfrac{1}{2}(p_x^2 + p_y^2)$。\n- 势能面是二次的，具有一个不稳定模式和一个稳定模式，通过将本征基旋转一个角度 $\\theta$ （以弧度为单位）来构建。设旋转矩阵为\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\phantom{-}\\cos\\theta\n\\end{pmatrix}.\n$$\n- 设在本征基中的 Hessian 矩阵为 $\\mathrm{diag}(-a, b)$，其中 $a>0, b>0$；则在实验室 $(x,y)$ 坐标系中的 Hessian 矩阵为\n$$\n\\mathbf{H} = \\mathbf{R}(\\theta)\\,\\mathrm{diag}(-a, b)\\,\\mathbf{R}(\\theta)^{\\mathsf{T}}.\n$$\n- 势能为 $V(\\mathbf{q}) = \\tfrac{1}{2}\\mathbf{q}^{\\mathsf{T}}\\mathbf{H}\\mathbf{q}$，根据构造，它在 $\\mathbf{q}=\\mathbf{0}$ 处有一个鞍点，且能垒能量为 0。\n\n运动方程与积分器：\n- Hamilton 方程为 $\\dot{\\mathbf{q}} = \\mathbf{p}$ 和 $\\dot{\\mathbf{p}} = -\\nabla V(\\mathbf{q}) = -\\mathbf{H}\\mathbf{q}$。\n- 使用固定时间步长 $\\Delta t$ 的 velocity-Verlet 算法对轨迹进行积分：\n  1. $\\mathbf{p}_{n+\\tfrac{1}{2}} = \\mathbf{p}_n - \\tfrac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_n$,\n  2. $\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t\\,\\mathbf{p}_{n+\\tfrac{1}{2}}$,\n  3. $\\mathbf{p}_{n+1} = \\mathbf{p}_{n+\\tfrac{1}{2}} - \\tfrac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_{n+1}$。\n\n待比较的划分面：\n- 定义将实验室坐标系坐标映射到本征基坐标的旋转为 $\\mathbf{c} = (u,v)^{\\mathsf{T}} = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{q}$，动量也做类似变换 $\\mathbf{\\pi} = (p_u,p_v)^{\\mathsf{T}} = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{p}$。\n- DS 1 (不稳定模式正交 DS)：水平集 $u=0$；仅计数满足 $p_u>0$ 的正向穿越。\n- DS 2 (恒定反应坐标的几何 DS)：水平集 $x=0$；仅计数满足 $p_x>0$ 的正向穿越。\n- 对于一个理想的无再穿越 DS，每条反应性轨道都应该只有一次正向穿越。将单条轨道的再穿越计数定义为 $\\max(0, N_+ - 1)$，其中 $N_+$ 是正向穿越的次数。一个系综的总再穿越是这些单轨道再穿越计数的总和。\n\n初始系综与能量：\n- 在本征基中设置初始条件。将初始不稳定坐标固定在 $u(0) = s_0 < 0$（反应物侧），并从均值为 0、标准差为 $\\sigma$ 的正态分布中抽取初始稳定坐标 $v(0)$。设置初始稳定动量 $p_v(0)=0$。\n- 通过求解 $p_u(0)>0$ 来强制总能量为微正则能量 $E>0$：\n$$\nE = \\tfrac{1}{2}\\left(p_u(0)^2 + p_v(0)^2\\right) + \\tfrac{1}{2}\\left(-a\\,u(0)^2 + b\\,v(0)^2\\right).\n$$\n如果对于一个抽样得到的 $v(0)$，方程右侧会使 $p_u(0)$ 成为虚数，则拒绝该 $v(0)$ 并重新抽样，直到可行。\n- 通过 $\\mathbf{q}(0) = \\mathbf{R}(\\theta)\\,(u(0),v(0))^{\\mathsf{T}}$ 和 $\\mathbf{p}(0) = \\mathbf{R}(\\theta)\\,(p_u(0),0)^{\\mathsf{T}}$ 将初始条件变换回实验室坐标系。\n\n轨道积分与穿越检测：\n- 对于每条轨道，积分至最大时间 $T_{\\max}$ 或直到不稳定坐标的绝对值大小超过截断值 $U_{\\mathrm{cut}}$（以避免数值溢出），以先到者为准。\n- 对于 DS 1，通过在检测时刻 $u$ 的符号从 $\\le 0$ 变为 $>0$ 且 $p_u>0$ 来检测正向穿越；对于 DS 2，类似地使用 $x$ 和 $p_x$。\n- 一个 DS 的总再穿越计数是该系综中所有轨道 $\\max(0,N_+ - 1)$ 值的总和，如上文所定义。\n\n数值单位：\n- 使用质量为单位的约化无量纲单位制。角度，包括 $\\theta$，必须以弧度为单位。再穿越计数是无量纲整数。\n\n测试套件、参数范围与输出格式：\n- 精确实现以下三个测试用例，以探测不同的几何排列：\n  1. 情况 A (对齐，边界): $a=2.0$, $b=1.0$, $\\theta=0.0$, $E=0.1$, $N=200$, $\\sigma=0.02$, $s_0=-0.05$, $\\Delta t=0.001$, $T_{\\max}=5.0$, $U_{\\mathrm{cut}}=20.0$。\n  2. 情况 B (中等旋转): $a=2.0$, $b=1.0$, $\\theta=\\pi/6$, $E=0.1$, $N=200$, $\\sigma=0.02$, $s_0=-0.05$, $\\Delta t=0.001$, $T_{\\max}=5.0$, $U_{\\mathrm{cut}}=20.0$。\n  3. 情况 C (强旋转): $a=2.0$, $b=1.0$, $\\theta=\\pi/3$, $E=0.1$, $N=200$, $\\sigma=0.02$, $s_0=-0.05$, $\\Delta t=0.001$, $T_{\\max}=5.0$, $U_{\\mathrm{cut}}=20.0$。\n- 您的程序必须：\n  - 使用固定的随机种子以使结果具有确定性。\n  - 为每种情况生成一个包含两个整数的列表 $[R_{\\mathrm{unstable}}, R_{\\mathrm{geo}}]$，这两个整数分别等于系综中 DS 1 和 DS 2 的总再穿越计数之和。\n  - 按顺序打印一行，其中包含这些按情况分类的列表的列表，不含任何额外文本。确切格式必须是： \n    - $[[R_{\\mathrm{unstable}}^{(A)}, R_{\\mathrm{geo}}^{(A)}],[R_{\\mathrm{unstable}}^{(B)}, R_{\\mathrm{geo}}^{(B)}],[R_{\\mathrm{unstable}}^{(C)}, R_{\\mathrm{geo}}^{(C)}]]$。", "solution": "所提出的问题是计算化学动力学中一个定义明确的练习。它在科学上是合理的，内容独立完备，并且在算法上进行了详细规定。它探讨了反应速率理论中的基本概念——划分面，这是化学动力学的一块基石。在动力学校正的划分面和一个朴素的几何划分面之间进行比较，是一个经典且富有启发性的演示。我将继续进行推导和算法设计。\n\n该系统由一个二维哈密顿量描述，用于一个单位质量 $m=1$ 的粒子在二次势能面 (PES) 上运动。系统的状态由相空间矢量 $(\\mathbf{q}, \\mathbf{p})$ 给出，其中 $\\mathbf{q} = (x,y)^{\\mathsf{T}}$ 是构型空间坐标，而 $\\mathbf{p} = (p_x,p_y)^{\\mathsf{T}}$ 是共轭动量。哈密顿量 $H(\\mathbf{q}, \\mathbf{p})$ 是动能和势能之和，$H = T(\\mathbf{p}) + V(\\mathbf{q})$。\n\n动能为 $T(\\mathbf{p}) = \\frac{1}{2m}\\mathbf{p}^{\\mathsf{T}}\\mathbf{p} = \\frac{1}{2}(p_x^2 + p_y^2)$，因为 $m=1$。\n势能是一个二次型 $V(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^{\\mathsf{T}}\\mathbf{H}\\mathbf{q}$，其中 $\\mathbf{H}$ 是在原点 $\\mathbf{q}=\\mathbf{0}$ 处求值的势能二阶导数 Hessian 矩阵。该 PES 在原点有一个鞍点。\n\nHessian 矩阵 $\\mathbf{H}$ 是由其在本征基中的对角形式构建的。设 Hessian 矩阵的本征矢量定义了一个坐标系 $(u,v)$。相应的本征值为 $-a$ 和 $b$，其中 $a>0$ 和 $b>0$。坐标 $u$ 对应于不稳定模式（鞍点处的反应坐标），而 $v$ 对应于稳定的横向模式。在此本征基中，Hessian 矩阵为 $\\mathbf{D} = \\mathrm{diag}(-a, b)$。\n\n实验室坐标系 $(x,y)$ 相对于本征基 $(u,v)$ 旋转了角度 $\\theta$。该变换由旋转矩阵 $\\mathbf{R}(\\theta)$ 给出：\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\n在本征基中表示的矢量 $\\mathbf{c} = (u,v)^{\\mathsf{T}}$，通过 $\\mathbf{q} = \\mathbf{R}(\\theta)\\mathbf{c}$ 变换到实验室坐标系。因此，实验室坐标系中的 Hessian 矩阵通过相似变换得到：\n$$\n\\mathbf{H} = \\mathbf{R}(\\theta)\\,\\mathbf{D}\\,\\mathbf{R}(\\theta)^{\\mathsf{T}}\n$$\n执行矩阵乘法得到：\n$$\n\\mathbf{H} = \\begin{pmatrix} b\\sin^2\\theta - a\\cos^2\\theta & -(a+b)\\sin\\theta\\cos\\theta \\\\ -(a+b)\\sin\\theta\\cos\\theta & b\\cos^2\\theta - a\\sin^2\\theta \\end{pmatrix}\n$$\n系统的动力学由 Hamilton 运动方程决定：\n$$\n\\dot{\\mathbf{q}} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p} \\quad (\\text{因为 } m=1)\n$$\n$$\n\\dot{\\mathbf{p}} = -\\frac{\\partial H}{\\partial \\mathbf{q}} = -\\nabla V(\\mathbf{q}) = -\\mathbf{H}\\mathbf{q}\n$$\n这些耦合的一阶常微分方程将使用指定的 velocity-Verlet 算法进行数值积分，这是一种适用于哈密顿系统的二阶、时间可逆且辛的算法。对于一个时间步长 $\\Delta t$，在时刻 $t_{n+1}$ 的状态 $(\\mathbf{q}_{n+1}, \\mathbf{p}_{n+1})$ 由在时刻 $t_n$ 的状态 $(\\mathbf{q}_n, \\mathbf{p}_n)$ 计算如下：\n$$\n\\mathbf{p}_{n+\\frac{1}{2}} = \\mathbf{p}_n - \\frac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_n\n$$\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t\\,\\mathbf{p}_{n+\\frac{1}{2}}\n$$\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+\\frac{1}{2}} - \\frac{1}{2}\\Delta t\\,\\mathbf{H}\\mathbf{q}_{n+1}\n$$\n模拟需要一个初始条件系综，该系综在固定总能量 $E > 0$ 下从微正则分布中生成。为了物理上的清晰性，我们在本征基中准备初始状态。轨道从势垒的反应物侧开始，即 $u(0) = s_0 < 0$。稳定模式中的初始位移 $v(0)$ 从高斯分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽样，以模拟浴模中的热涨落。稳定模式的初始动量设为零，$p_v(0) = 0$。沿不稳定模式的初始动量 $p_u(0)$ 由总能量守恒方程确定：\n$$\nE = T + V = \\frac{1}{2}(p_u(0)^2 + p_v(0)^2) + \\frac{1}{2}(-a u(0)^2 + b v(0)^2)\n$$\n求解 $p_u(0)^2$ 得出：\n$$\np_u(0)^2 = 2E - p_v(0)^2 + a u(0)^2 - b v(0)^2 = 2E + a s_0^2 - b v(0)^2\n$$\n为了得到物理上有意义的初始动量，$p_u(0)^2$ 必须为非负。如果抽样得到的 $v(0)$ 违反了此条件，则将其舍弃并抽取一个新值。我们选择正根 $p_u(0) = \\sqrt{p_u(0)^2}$，以使轨道朝向势垒发射。\n\n然后，本征基中的初始相空间矢量 $(\\mathbf{c}(0), \\mathbf{\\pi}(0))$，其中 $\\mathbf{c}(0) = (s_0, v(0))^{\\mathsf{T}}$ 和 $\\mathbf{\\pi}(0) = (p_u(0), 0)^{\\mathsf{T}}$，被变换回实验室坐标系以进行积分：\n$$\n\\mathbf{q}(0) = \\mathbf{R}(\\theta)\\mathbf{c}(0) \\quad \\text{和} \\quad \\mathbf{p}(0) = \\mathbf{R}(\\theta)\\mathbf{\\pi}(0)\n$$\n每条轨道都积分至最大时间 $T_{\\max}$，或者直到坐标 $u$ 超过一个截断值大小 $|u| > U_{\\mathrm{cut}}$，这表示粒子已远离相互作用区域。为了检查此条件，每一步都必须将实验室坐标系坐标变换回本征基：\n$$\n\\mathbf{c}(t) = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{q}(t) \\quad \\text{和} \\quad \\mathbf{\\pi}(t) = \\mathbf{R}(\\theta)^{\\mathsf{T}}\\mathbf{p}(t)\n$$\n这给出 $u(t) = q_x(t)\\cos\\theta + q_y(t)\\sin\\theta$ 和 $p_u(t) = p_x(t)\\cos\\theta + p_y(t)\\sin\\theta$。\n\n我们监测两种划分面 (DS) 的穿越情况。\n1.  **DS 1 (不稳定模式正交 DS)：** 由平面 $u=0$ 定义。对于二次势垒，这是理想的划分面，代表了真实的过渡态。如果 $u$ 从 $u_n \\le 0$ 过渡到 $u_{n+1} > 0$ 且相应的动量为正，$p_u(t_{n+1}) > 0$，则计为一次正向穿越。\n2.  **DS 2 (几何 DS)：** 由平面 $x=0$ 定义。这是一个基于实验室坐标系轴之一的朴素选择。如果 $x$ 从 $x_n \\le 0$ 过渡到 $x_{n+1} > 0$ 且相应的动量为正，$p_x(t_{n+1}) > 0$，则计为一次正向穿越。\n\n对于一个大小为 $N$ 的系综中的每条轨道，我们计算每个 DS 的正向穿越次数 $N_+$。一个完美的 DS 会被每条反应性轨道精确穿越一次。因此，单条轨道的再穿越次数为 $\\max(0, N_+ - 1)$。一个 DS 的总再穿越计数是整个系综中这些值的总和。\n\n算法流程如下：\n对于每个具有参数 $(a, b, \\theta, E, N, \\sigma, s_0, \\Delta t, T_{\\max}, U_{\\mathrm{cut}})$ 的测试用例：\n1.  初始化总再穿越计数器 $R_{\\mathrm{unstable}} \\to 0$ 和 $R_{\\mathrm{geo}} \\to 0$。构建 Hessian 矩阵 $\\mathbf{H}$ 和旋转矩阵 $\\mathbf{R}(\\theta)$。\n2.  对于 $N$ 条轨道中的每一条：\n    a. 生成实验室坐标系中的有效初始条件 $(\\mathbf{q}(0), \\mathbf{p}(0))$。\n    b. 初始化单轨道正向穿越计数器 $N_{+,u} \\to 0$ 和 $N_{+,x} \\to 0$。\n    c. 设置初始状态 $(\\mathbf{q}_0, \\mathbf{p}_0) = (\\mathbf{q}(0), \\mathbf{p}(0))$ 并确定用于检查的初始变量 $u_{-1}, x_{-1}$。\n    d. 使用 velocity-Verlet 算法积分运动方程，最多进行 $T_{\\max}/\\Delta t$步。在每一步 $n$ 中：\n        i. 计算 $(\\mathbf{q}_n, \\mathbf{p}_n)$。\n        ii. 变换到本征基得到 $u_n$ 和 $p_{u,n}$。\n        iii. 检查 DS 1 的正向穿越：如果 $u_{n-1} \\le 0$ 且 $u_n > 0$ 且 $p_{u,n} > 0$，则 $N_{+,u}$ 加一。\n        iv. 检查 DS 2 的正向穿越：如果 $x_{n-1} \\le 0$ 且 $x_n > 0$ 且 $p_{x,n} > 0$，则 $N_{+,x}$ 加一。\n        v. 检查终止条件 $|u_n| > U_{\\mathrm{cut}}$。如果为真，则中断积分循环。\n        vi. 更新 $u_{n-1} \\to u_n$，$x_{n-1} \\to x_n$。\n    e. 计算该轨道的再穿越次数： $\\Delta R_{\\mathrm{unstable}} = \\max(0, N_{+,u}-1)$ 和 $\\Delta R_{\\mathrm{geo}} = \\max(0, N_{+,x}-1)$。\n    f. 加到总数上： $R_{\\mathrm{unstable}} \\leftarrow R_{\\mathrm{unstable}} + \\Delta R_{\\mathrm{unstable}}$，$R_{\\mathrm{geo}} \\leftarrow R_{\\mathrm{geo}} + \\Delta R_{\\mathrm{geo}}$。\n3.  存储当前测试用例的配对 $[R_{\\mathrm{unstable}}, R_{\\mathrm{geo}}]$。\n在处理完所有情况后，按指定格式化收集的结果。必须使用固定的随机种子以保证可复现性。\n\n当 $\\theta=0$ 时，实验室坐标系和本征坐标系重合 ($x=u, y=v$)，因此 DS 1 和 DS 2 是相同的。我们预计两者的再穿越都极小且计数相同。随着 $\\theta$ 的增加，几何 DS ($x=0$) 与真实的过渡态 ($u=0$) 变得越来越不对齐，我们预计 $R_{\\mathrm{geo}}$ 会显著增加，而 $R_{\\mathrm{unstable}}$ 应保持在零附近，因为对于此势能面，它在动力学上是正确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares two dividing surfaces for a 2-DOF Hamiltonian model\n    of a barrier-crossing reaction by simulating ensembles of classical trajectories.\n    \"\"\"\n\n    test_cases = [\n        # Case A (aligned, boundary): a=2.0, b=1.0, theta=0.0, E=0.1, N=200, sigma=0.02, s_0=-0.05, dt=0.001, Tmax=5.0, Ucut=20.0.\n        (2.0, 1.0, 0.0, 0.1, 200, 0.02, -0.05, 0.001, 5.0, 20.0),\n        # Case B (moderate rotation): a=2.0, b=1.0, theta=pi/6, E=0.1, N=200, sigma=0.02, s_0=-0.05, dt=0.001, Tmax=5.0, Ucut=20.0.\n        (2.0, 1.0, np.pi/6, 0.1, 200, 0.02, -0.05, 0.001, 5.0, 20.0),\n        # Case C (strong rotation): a=2.0, b=1.0, theta=pi/3, E=0.1, N=200, sigma=0.02, s_0=-0.05, dt=0.001, Tmax=5.0, Ucut=20.0.\n        (2.0, 1.0, np.pi/3, 0.1, 200, 0.02, -0.05, 0.001, 5.0, 20.0),\n    ]\n\n    all_results = []\n    \n    # Use a fixed random seed for reproducibility.\n    # The problem does not specify a seed, so one is chosen here.\n    rng = np.random.default_rng(seed=42)\n\n    for case in test_cases:\n        a, b, theta, E, N, sigma, s0, dt, Tmax, Ucut = case\n\n        # Construct Hessian and Rotation matrices\n        c, s = np.cos(theta), np.sin(theta)\n        H = np.array([\n            [b * s**2 - a * c**2, -(a + b) * s * c],\n            [-(a + b) * s * c, b * c**2 - a * s**2]\n        ])\n        R = np.array([[c, -s], [s, c]])\n        RT = R.T\n\n        total_recross_unstable = 0\n        total_recross_geo = 0\n\n        for _ in range(N):\n            # Generate initial conditions for one trajectory\n            q0, p0 = generate_initial_conditions(rng, a, b, E, s0, sigma, R)\n\n            # Run the trajectory and count forward crossings\n            n_cross_unstable, n_cross_geo = run_trajectory(q0, p0, H, RT, dt, Tmax, Ucut)\n            \n            # Sum the recrossing counts\n            total_recross_unstable += max(0, n_cross_unstable - 1)\n            total_recross_geo += max(0, n_cross_geo - 1)\n\n        all_results.append([total_recross_unstable, total_recross_geo])\n\n    # Final print statement in the exact required format.\n    # repr() creates a string representation, and .replace removes spaces.\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef generate_initial_conditions(rng, a, b, E, s0, sigma, R):\n    \"\"\"\n    Generates initial phase space coordinates (q0, p0) for a single trajectory.\n    \"\"\"\n    while True:\n        v0 = rng.normal(loc=0.0, scale=sigma)\n        # pv(0) is 0 as per problem spec\n        # E = 1/2(pu^2 + pv^2) + 1/2(-a*u^2 + b*v^2)\n        pu0_sq = 2 * E + a * s0**2 - b * v0**2\n        if pu0_sq >= 0:\n            pu0 = np.sqrt(pu0_sq)\n            break\n    \n    # Initial conditions in eigenbasis\n    c0 = np.array([s0, v0])      # (u(0), v(0))\n    pi0 = np.array([pu0, 0.0])   # (pu(0), pv(0))\n\n    # Transform to laboratory frame\n    q0 = R @ c0\n    p0 = R @ pi0\n    \n    return q0, p0\n\ndef run_trajectory(q, p, H, RT, dt, Tmax, Ucut):\n    \"\"\"\n    Integrates a single trajectory and counts forward crossings for both DS.\n    \"\"\"\n    num_steps = int(Tmax / dt)\n    \n    n_cross_unstable = 0\n    n_cross_geo = 0\n    \n    # Get initial values for crossing check.\n    # Lab frame variables\n    x_prev = q[0]\n    # Eigenbasis variables\n    c_prev = RT @ q\n    u_prev = c_prev[0]\n    \n    for _ in range(num_steps):\n        # Velocity-Verlet Integration Step\n        p_half = p - 0.5 * dt * (H @ q)\n        q_next = q + dt * p_half\n        p_next = p_half - 0.5 * dt * (H @ q_next)\n        \n        # Update state\n        q, p = q_next, p_next\n        \n        # Current state variables for checks\n        x_curr = q[0]\n        px_curr = p[0]\n        \n        c_curr = RT @ q\n        pi_curr = RT @ p\n        u_curr = c_curr[0]\n        pu_curr = pi_curr[0]\n        \n        # DS 1 (unstable-mode orthogonal): u=0\n        if u_prev <= 0 and u_curr > 0 and pu_curr > 0:\n            n_cross_unstable += 1\n            \n        # DS 2 (geometric): x=0\n        if x_prev <= 0 and x_curr > 0 and px_curr > 0:\n            n_cross_geo += 1\n            \n        # Update previous state values for next iteration's checks\n        u_prev = u_curr\n        x_prev = x_curr\n        \n        # Check termination condition based on unstable coordinate magnitude\n        if abs(u_curr) > Ucut:\n            break\n            \n    return n_cross_unstable, n_cross_geo\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2632247"}]}