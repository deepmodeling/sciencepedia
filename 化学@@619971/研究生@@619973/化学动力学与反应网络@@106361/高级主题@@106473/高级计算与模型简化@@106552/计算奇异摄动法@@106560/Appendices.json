{"hands_on_practices": [{"introduction": "简化刚性系统的最直接方法是准稳态近似（Quasi-Steady-State Approximation, QSS），它对应于零阶慢流形。本练习将在此基础上更进一步，引导您通过解析推导一阶校正项。通过运用不变性条件这一基本原理，您将对计算奇异摄动（Computational Singular Perturbation, CSP）如何系统地改进基础QSS模型获得根本性的理解。[@problem_id:2634419]", "problem": "考虑一个双物种线性反应网络，该网络模拟了一个缓慢衰减的反应物和一个快速生成的中间体，以无量纲形式表示，并含有一个小的分离参数 $\\varepsilon \\in (0,1]$。令 $x(t)$ 表示慢变量（反应物），$y(t)$ 表示快变量（中间体）。其动力学由以下线性时不变系统给出：\n$$\n\\frac{dx}{dt} = -k_{s}x - k_{c}y, \n\\qquad\n\\varepsilon\\frac{dy}{dt} = k_{c}x - k_{f}y,\n$$\n其中参数 $k_{s}>0$、$k_{c}>0$ 和 $k_{f}>0$ 均为正数。该系统源于质量作用动力学，其中 $x$ 存在一个速率为 $k_{s}$ 的慢消耗通道，以及 $x$ 和 $y$ 之间存在一个由 $k_{c}$ 和 $k_{f}$ 表征的快交换过程。准稳态（QSS）近似对应于最低阶的慢不变流形 $y=h_{0}(x)$，它是通过将快速方程的右侧设为零得到的。\n\n使用与计算奇异摄动（CSP）一致的奇异摄动理论，通过在全动力学下强制施加不变性至 $\\varepsilon$ 的一阶，将慢不变流形构建为正则展开 $y=h(x;\\varepsilon)=h_{0}(x)+\\varepsilon h_{1}(x)+\\mathcal{O}(\\varepsilon^{2})$。从基本原理出发，即质量作用动力学和不变流形的链式法则，推导出决定 $h_{0}(x)$ 和 $h_{1}(x)$ 的条件，而不援引任何现成的公式。\n\n仅报告一阶校正项 $h_{1}(x)$ 关于 $x$、$k_{s}$、$k_{c}$ 和 $k_{f}$ 的闭合形式解析表达式。无需进行数值评估。最终答案必须是单一的解析表达式。不包含单位。", "solution": "此问题经判定有效。这是一个在化学动力学和奇异摄动理论领域内提法恰当、有科学依据的问题。所有必要的数据和条件均已提供，问题没有矛盾、歧义或事实性错误。因此，我们可以着手推导解答。\n\n描述慢变量 $x(t)$ 和快变量 $y(t)$ 动力学的常微分方程组如下：\n$$\n\\frac{dx}{dt} = f(x, y) = -k_{s}x - k_{c}y\n$$\n$$\n\\varepsilon \\frac{dy}{dt} = g(x, y) = k_{c}x - k_{f}y\n$$\n其中 $k_{s}$、$k_{c}$ 和 $k_{f}$ 是正常数率，$\\varepsilon$ 是一个小的正参数，$\\varepsilon \\ll 1$。\n\n我们寻求找到慢不变流形，它是相空间中的一条曲线 $y = h(x; \\varepsilon)$，任何从该流形上开始的轨迹在所有后续时间里都将保持在该流形上。这种不变性特性的数学表述是，流形上一点 $(x(t), y(t))$ 的时间演化必须在该点与流形相切。如果 $y(t) = h(x(t); \\varepsilon)$，那么根据链式法则，它们的时间导数必须满足以下关系：\n$$\n\\frac{dy}{dt} = \\frac{dh(x; \\varepsilon)}{dx} \\frac{dx}{dt}\n$$\n这就是基本的不变性条件。我们可以将给定系统动力学中 $\\frac{dx}{dt}$ 和 $\\frac{dy}{dt}$ 的表达式代入此条件。从第二个方程，我们得到 $\\frac{dy}{dt} = \\frac{1}{\\varepsilon} g(x,y)$，因此不变性条件变为：\n$$\n\\frac{1}{\\varepsilon} g(x, y) = \\frac{dh}{dx} f(x, y)\n$$\n将 $y = h(x; \\varepsilon)$ 代入该方程，得到不变流形 $h(x; \\varepsilon)$ 的定义性泛函微分方程：\n$$\nk_{c}x - k_{f}h(x; \\varepsilon) = \\varepsilon \\frac{dh(x; \\varepsilon)}{dx} (-k_{s}x - k_{c}h(x; \\varepsilon))\n$$\n问题要求此流形的一阶近似，我们将其表示为关于 $\\varepsilon$ 的正则摄动展开：\n$$\nh(x; \\varepsilon) = h_{0}(x) + \\varepsilon h_{1}(x) + \\mathcal{O}(\\varepsilon^{2})\n$$\n相应地，其关于 $x$ 的导数为：\n$$\n\\frac{dh(x; \\varepsilon)}{dx} = \\frac{dh_{0}(x)}{dx} + \\varepsilon \\frac{dh_{1}(x)}{dx} + \\mathcal{O}(\\varepsilon^{2})\n$$\n现在我们将这些展开式代入不变性方程：\n$$\nk_{c}x - k_{f}(h_{0} + \\varepsilon h_{1} + \\dots) = \\varepsilon \\left(\\frac{dh_{0}}{dx} + \\varepsilon \\frac{dh_{1}}{dx} + \\dots\\right) \\left(-k_{s}x - k_{c}(h_{0} + \\varepsilon h_{1} + \\dots)\\right)\n$$\n为了求解 $h_{0}(x)$ 和 $h_{1}(x)$，我们展开方程两边，并合并 $\\varepsilon$ 的同次幂项。\n\n左侧（LHS）展开为：\n$$\n\\text{LHS} = (k_{c}x - k_{f}h_{0}(x)) - \\varepsilon k_{f}h_{1}(x) + \\mathcal{O}(\\varepsilon^{2})\n$$\n右侧（RHS）展开为：\n$$\n\\text{RHS} = \\varepsilon \\left(\\frac{dh_{0}}{dx}\\right) (-k_{s}x - k_{c}h_{0}(x)) + \\mathcal{O}(\\varepsilon^{2})\n$$\n令LHS和RHS的表达式相等，我们得到：\n$$\n(k_{c}x - k_{f}h_{0}) - \\varepsilon k_{f}h_{1} + \\mathcal{O}(\\varepsilon^{2}) = \\varepsilon \\frac{dh_{0}}{dx}(-k_{s}x - k_{c}h_{0}) + \\mathcal{O}(\\varepsilon^{2})\n$$\n现在我们令 $\\varepsilon$ 的相应次幂的系数相等。\n\n在 $\\mathcal{O}(\\varepsilon^{0})$ 阶：\n不含 $\\varepsilon$ 的项必须相等。\n$$\nk_{c}x - k_{f}h_{0}(x) = 0\n$$\n求解 $h_{0}(x)$ 得到慢流形的零阶近似，即准稳态（QSS）近似：\n$$\nh_{0}(x) = \\frac{k_{c}}{k_{f}}x\n$$\n\n在 $\\mathcal{O}(\\varepsilon^{1})$ 阶：\n与 $\\varepsilon$ 成正比的项必须相等。\n$$\n-k_{f}h_{1}(x) = \\frac{dh_{0}}{dx}(-k_{s}x - k_{c}h_{0}(x))\n$$\n我们已经确定了 $h_{0}(x)$。现在我们可以求它的导数：\n$$\n\\frac{dh_{0}}{dx} = \\frac{d}{dx}\\left(\\frac{k_{c}}{k_{f}}x\\right) = \\frac{k_{c}}{k_{f}}\n$$\n将 $h_{0}(x)$ 和 $\\frac{dh_{0}}{dx}$ 的表达式代入 $\\mathcal{O}(\\varepsilon^{1})$ 阶方程：\n$$\n-k_{f}h_{1}(x) = \\left(\\frac{k_{c}}{k_{f}}\\right) \\left(-k_{s}x - k_{c}\\left(\\frac{k_{c}}{k_{f}}x\\right)\\right)\n$$\n我们可以将右侧的 $x$ 因子提出来：\n$$\n-k_{f}h_{1}(x) = \\left(\\frac{k_{c}}{k_{f}}\\right) \\left(-k_{s} - \\frac{k_{c}^{2}}{k_{f}}\\right) x\n$$\n$$\n-k_{f}h_{1}(x) = -\\frac{k_{c}}{k_{f}} \\left(k_{s} + \\frac{k_{c}^{2}}{k_{f}}\\right) x\n$$\n现在，我们通过除以 $-k_{f}$ 来求解 $h_{1}(x)$：\n$$\nh_{1}(x) = \\frac{k_{c}}{k_{f}^{2}} \\left(k_{s} + \\frac{k_{c}^{2}}{k_{f}}\\right) x\n$$\n为了以更紧凑的形式呈现，我们合并括号内的项：\n$$\nh_{1}(x) = \\frac{k_{c}}{k_{f}^{2}} \\left(\\frac{k_{s}k_{f} + k_{c}^{2}}{k_{f}}\\right) x\n$$\n$$\nh_{1}(x) = \\frac{k_{c}(k_{s}k_{f} + k_{c}^{2})}{k_{f}^{3}} x\n$$\n这就是慢不变流形的一阶校正项 $h_{1}(x)$ 的闭合形式解析表达式。完整的一阶流形是 $y = h_{0}(x) + \\varepsilon h_{1}(x)$。问题只要求 $h_{1}(x)$ 的表达式。", "answer": "$$\n\\boxed{\\frac{k_{c}(k_{s}k_{f} + k_{c}^{2})}{k_{f}^{3}} x}\n$$", "id": "2634419"}, {"introduction": "在我们简化一个模型之前，必须首先诊断其动态特性。这个计算实践专注于CSP方法中至关重要的第一步：识别化学网络中的快、慢模态。您将编写一个程序来分析系统的雅可比矩阵 $J$，将其特征值解释为时间尺度，将其特征向量解释为参与的物种，从而将线性代数的抽象概念与反应动力学的物理现实联系起来。[@problem_id:2634427]", "problem": "考虑一个可逆异构化网络的线性化质量作用模型，其中缓慢的相互转换导致了刚性。设化学物种为 $A$、$B$、$C$ 和 $D$，基元反应为\n- $A \\to B$，速率常数为 $k_{1f}$，\n- $B \\to A$，速率常数为 $k_{1r}$，\n- $B \\to C$，速率常数为 $k_{s}$，\n- $C \\to D$，速率常数为 $k_{2f}$，\n- $D \\to C$，速率常数为 $k_{2r}$。\n\n设物种浓度向量为 $x = [x_A, x_B, x_C, x_D]^\\top$。根据质量作用动力学，反应速率向量 $v(x)$ 的分量为 $v_1 = k_{1f} x_A$、$v_2 = k_{1r} x_B$、$v_3 = k_s x_B$、$v_4 = k_{2f} x_C$、$v_5 = k_{2r} x_D$。化学计量矩阵 $S$ 由与上述反应相对应的列给出：\n$$\nS = \\begin{bmatrix}\n-1 & +1 & 0 & 0 & 0 \\\\\n+1 & -1 & -1 & 0 & 0 \\\\\n0 & 0 & +1 & -1 & +1 \\\\\n0 & 0 & 0 & +1 & -1\n\\end{bmatrix}.\n$$\n控制常微分方程为 $dx/dt = S v(x)$。在任意状态 $x$ 下的雅可比矩阵 $J$ 定义为 $J = \\frac{\\partial}{\\partial x} (S v(x)) = S \\frac{\\partial v}{\\partial x}$。对于此单分子网络，$J$ 与 $x$ 无关，等于\n$$\nJ = \\begin{bmatrix}\n- k_{1f} & k_{1r} & 0 & 0 \\\\\nk_{1f} & - (k_{1r} + k_s) & 0 & 0 \\\\\n0 & k_s & - k_{2f} & k_{2r} \\\\\n0 & 0 & k_{2f} & - k_{2r}\n\\end{bmatrix}.\n$$\n在计算奇异摄动 (CSP) 框架中，快模态与雅可比矩阵 $J$ 的具有很大负实部的特征值 $\\lambda$ 相关联（由于速率常数的单位是 $\\mathrm{s}^{-1}$，其单位也是 $\\mathrm{s}^{-1}$），其对应的右特征向量揭示了哪些物种在这些模态中起主导作用。对于一个可逆反应对，一个快速平衡模态通常表现为一个特征向量，其主导分量位于该反应对中的物种上，并且这两个物种对应的分量符号相反。\n\n您的任务是编写一个完整的程序，该程序：\n1. 根据给定的速率常数 $k_{1f}$、$k_{1r}$、$k_s$、$k_{2f}$、$k_{2r}$（单位均为 $\\mathrm{s}^{-1}$）构建雅可比矩阵 $J$。\n2. 使用双精度浮点运算，数值计算 $J$ 的特征值和右特征向量。\n3. 按实部升序（负得更多的排在前面）对特征值 $\\lambda_i$ 进行排序。设排序后的特征对为 $\\{(\\lambda_i, r_i)\\}_{i=1}^4$，其中 $r_i$ 是对应的右特征向量。\n4. 通过检查特征向量的分量，识别哪些特征模态对应于反应对 $A \\leftrightarrow B$ 的快速平衡，哪些对应于反应对 $C \\leftrightarrow D$ 的快速平衡：\n   - 对于一对 $\\{u, v\\}$，将特征向量 $r_i$ 的参与度得分定义为\n     $$\n     \\sigma_{\\{u,v\\}}(i) = \\left(\\frac{r_{i,u}^2 + r_{i,v}^2}{\\sum_{j \\in \\{A,B,C,D\\}} r_{i,j}^2}\\right) \\cdot \\chi\\Big(r_{i,u}\\, r_{i,v}  0 \\Big),\n     $$\n     其中 $r_{i,j}$ 表示 $r_i$ 的第 $j$ 个分量（如果为复数则使用实部），$\\chi(\\cdot)$ 是指示函数，当其参数为真时为 $1$，否则为 $0$。直观地说，第一个因子衡量该模态在该反应对的两个物种上的集中程度，而指示函数则强制要求该对中两个分量的符号相反。\n   - 如果一个特征模态的实部满足 $-\\mathrm{Re}(\\lambda_i) \\ge \\gamma \\cdot \\min\\{-\\mathrm{Re}(\\lambda_j) : \\mathrm{Re}(\\lambda_j)  0\\}$，则该模态被判定为“快”模态，其中 $\\gamma>0$ 是用户指定的时间尺度分离因子，最小值取自所有严格为负的实部（忽略任何零特征值）。\n   - 对于每对反应（$A \\leftrightarrow B$ 和 $C \\leftrightarrow D$），在“快”特征模态中，选择使 $\\sigma_{\\{u,v\\}}(i)$ 最大化的索引 $i$。如果对于某个反应对，没有任何“快”特征模态具有严格为正的参与度得分，则为该反应对返回 $-1$。\n\n您必须将此程序应用于以下参数集测试套件（所有速率常数的单位均为 $\\mathrm{s}^{-1}$；列表条目为 $(k_{1f}, k_{1r}, k_s, k_{2f}, k_{2r}, \\gamma)$）：\n- 测试 1：$(10^3, 8 \\cdot 10^2, 10^{-1}, 1.2 \\cdot 10^3, 1.1 \\cdot 10^3, 10)$，\n- 测试 2：$(5 \\cdot 10^2, 7 \\cdot 10^2, 5 \\cdot 10^{-2}, 5, 6, 50)$，\n- 测试 3：$(50, 50, 10^{-1}, 2 \\cdot 10^{-1}, 3 \\cdot 10^{-1}, 10)$，\n- 测试 4：$(2 \\cdot 10^3, 1.5 \\cdot 10^3, 10^{-4}, 1.8 \\cdot 10^3, 2.2 \\cdot 10^3, 10)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于按顺序排列的每个测试用例，程序必须输出一个双元素列表 $[i_{AB}, i_{CD}]$，其中 $i_{AB}$ 是为 $A \\leftrightarrow B$ 识别出的快速平衡模态的索引（在排序后的特征值顺序 $i \\in \\{0,1,2,3\\}$ 中，$0$ 对应实部最负的特征值），如果没有符合条件的模态则为 $-1$；$i_{CD}$ 对于 $C \\leftrightarrow D$ 也类似。因此，最终输出是包含四个此类双元素列表的列表，例如：$[[i_{AB}^{(1)}, i_{CD}^{(1)}],[i_{AB}^{(2)}, i_{CD}^{(2)}],[i_{AB}^{(3)}, i_{CD}^{(3)}],[i_{AB}^{(4)}, i_{CD}^{(4)}]]$，其中每个 $i$ 都是整数。", "solution": "所提出的问题是将计算奇异摄动 (CSP) 理论应用于线性化学反应网络的一个有效且适定的练习。它要求对系统的雅可比矩阵进行数值分析，以识别和分类快速动态模态。该问题具有科学依据，采用了化学动力学和线性代数的标准原理。所有参数和步骤都得到了明确定义，从而可以得到唯一且可验证的解。我们将着手求解。\n\n问题的核心在于分析系统在某个状态附近的线性化动力学，这由雅可比矩阵 $\\mathbf{J}$ 控制。该系统描述了一个单分子反应网络，其控制常微分方程 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{S}\\mathbf{v}(\\mathbf{x})$ 对于浓度向量 $\\mathbf{x}$ 已经是线性的。因此，雅可比矩阵 $\\mathbf{J} = \\frac{\\partial(\\mathbf{S}\\mathbf{v})}{\\partial \\mathbf{x}}$ 是一个常数矩阵，它完全描述了系统在任何浓度分布下的动力学。给定的雅可比矩阵是：\n$$\n\\mathbf{J} = \\begin{bmatrix}\n-k_{1f}  k_{1r}  0  0 \\\\\nk_{1f}  -(k_{1r} + k_s)  0  0 \\\\\n0  k_s  -k_{2f}  k_{2r} \\\\\n0  0  k_{2f}  -k_{2r}\n\\end{bmatrix}\n$$\n$\\mathbf{J}$ 的特征值 $\\lambda_i$ 代表了系统基本运动模态的时间尺度的倒数。一个很大的负实部，$\\mathrm{Re}(\\lambda_i) \\ll 0$，对应一个特征时间尺度为 $\\tau_i = 1/|\\mathrm{Re}(\\lambda_i)|$ 的快速衰减模态。相应的右特征向量 $\\mathbf{r}_i$ 揭示了参与该模态的物种浓度的组合。对于两个物种（例如 $U$ 和 $V$）之间的快速平衡模态，其特征向量中对应于这些物种的分量 $r_{i,U}$ 和 $r_{i,V}$ 将占主导地位且符号相反，这表示它们之间存在快速、平衡的质量交换。\n\n指定的算法步骤如下。对于每组速率常数 $(k_{1f}, k_{1r}, k_s, k_{2f}, k_{2r})$ 和时间尺度分离因子 $\\gamma$：\n\n1.  **构建雅可比矩阵**：使用提供的速率常数构建 $4 \\times 4$ 矩阵 $\\mathbf{J}$。\n\n2.  **特征值分解**：数值计算 $\\mathbf{J}$ 的特征值 $\\{\\lambda_i\\}_{i=0}^3$ 及其对应的右特征向量 $\\{\\mathbf{r}_i\\}_{i=0}^3$。对于像 $\\mathbf{J}$ 这样的实矩阵，任何复数特征值都会成对出现，但通过分析其对角块的特征多项式可以确定，这个特定的 $\\mathbf{J}$ 的所有特征值都是实数且非正。因此，特征向量也可以选择为实数。\n\n3.  **排序特征对**：根据特征值的实部按升序对特征对 $(\\lambda_i, \\mathbf{r}_i)$ 进行排序：$\\mathrm{Re}(\\lambda_0) \\le \\mathrm{Re}(\\lambda_1) \\le \\mathrm{Re}(\\lambda_2) \\le \\mathrm{Re}(\\lambda_3)$。因此，索引 $i \\in \\{0, 1, 2, 3\\}$ 将模态从最快到最慢进行标记。由于总质量 $\\sum x_j$ 守恒，其中一个特征值 $\\lambda_3$ 将为零。\n\n4.  **识别快模态**：如果一个模态 $i$ 的衰减速率 $-\\mathrm{Re}(\\lambda_i)$ 显著大于系统中最慢的非零衰减速率，则该模态被归类为“快”模态。阈值由参数 $\\gamma$ 决定。首先，我们找到所有稳定模态中的最小衰减速率：\n    $$\n    R_{min} = \\min \\{-\\mathrm{Re}(\\lambda_j) : \\mathrm{Re}(\\lambda_j)  0\\}\n    $$\n    然后，如果 $-\\mathrm{Re}(\\lambda_i) \\ge \\gamma \\cdot R_{min}$，则模态 $i$ 被判定为快模态。我们将这些快模态的索引集合表示为 $I_{\\text{fast}}$。\n\n5.  **识别平衡模态**：对于每个感兴趣的反应对 $\\{A, B\\}$ 和 $\\{C, D\\}$，我们必须找到哪个快模态（如果有的话）与其平衡相对应。这通过使用指定的参与度得分 $\\sigma$ 来实现。对于一个通用对 $\\{u, v\\}$ 和一个特征向量 $\\mathbf{r}_i$，得分是：\n    $$\n    \\sigma_{\\{u,v\\}}(i) = \\left(\\frac{r_{i,u}^2 + r_{i,v}^2}{\\sum_{j \\in \\{A,B,C,D\\}} r_{i,j}^2}\\right) \\cdot \\chi(r_{i,u} \\cdot r_{i,v}  0)\n    $$\n    其中 $r_{i,j}$ 是特征向量 $\\mathbf{r}_i$ 的第 $j$ 个分量，$\\chi$ 是指示函数。物种索引为 $A \\to 0, B \\to 1, C \\to 2, D \\to 3$。\n    对于每个对 $\\{u,v\\}$，我们在快模态集合 $I_{\\text{fast}}$ 中搜索使该得分最大化的模态：\n    $$\n    i^*_{\\{u,v\\}} = \\underset{i \\in I_{\\text{fast}}}{\\mathrm{argmax}} \\, \\sigma_{\\{u,v\\}}(i)\n    $$\n    如果 $I_{\\text{fast}}$ 为空，或者如果最大得分为零（即，没有快模态对该反应对表现出所需的反符号结构），则报告索引为 $-1$。否则，报告得到的索引 $i^*_{\\{u,v\\}}$。对 $\\{A, B\\}$ 对（得到 $i_{AB}$）和 $\\{C, D\\}$ 对（得到 $i_{CD}$）都执行此过程。\n\n每个测试用例的最终输出是有序对 $[i_{AB}, i_{CD}]$。然后对所有提供的测试套件重复此整个过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational singular perturbation problem for a given set of test cases.\n    \"\"\"\n    # Test cases: (k1f, k1r, ks, k2f, k2r, gamma)\n    test_cases = [\n        (1e3, 8e2, 1e-1, 1.2e3, 1.1e3, 10),\n        (5e2, 7e2, 5e-2, 5, 6, 50),\n        (50, 50, 1e-1, 2e-1, 3e-1, 10),\n        (2e3, 1.5e3, 1e-4, 1.8e3, 2.2e3, 10),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = process_case(params)\n        results.append(result)\n\n    # Format the final output string as per requirements.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(params):\n    \"\"\"\n    Constructs the Jacobian, computes eigenpairs, and identifies fast equilibration modes.\n    \n    Args:\n        params (tuple): A tuple containing the rate constants (k1f, k1r, ks, k2f, k2r)\n                        and the timescale separation factor gamma.\n    \n    Returns:\n        list: A two-element list [i_ab, i_cd] containing the indices of the identified\n              fast modes for pairs A-B and C-D, or -1 if none is found.\n    \"\"\"\n    k1f, k1r, ks, k2f, k2r, gamma = params\n\n    # 1. Construct the Jacobian matrix J\n    J = np.array([\n        [-k1f, k1r, 0, 0],\n        [k1f, -(k1r + ks), 0, 0],\n        [0, ks, -k2f, k2r],\n        [0, 0, k2f, -k2r]\n    ])\n\n    # 2. Compute eigenvalues and right eigenvectors\n    eigvals, eigvecs = np.linalg.eig(J)\n\n    # Eigenvalues for real matrices can have small imaginary parts due to numerical error.\n    # The theory for this problem guarantees real eigenvalues, so we take the real part.\n    eigvals = np.real(eigvals)\n    eigvecs = np.real(eigvecs)\n\n    # 3. Sort eigenpairs by ascending real part of eigenvalues\n    sorted_indices = np.argsort(eigvals)\n    sorted_eigvals = eigvals[sorted_indices]\n    sorted_eigvecs = eigvecs[:, sorted_indices]\n\n    # 4. Identify fast modes\n    # Find minimum decay rate among stable (non-zero eigenvalue) modes\n    neg_eigvals = sorted_eigvals[~np.isclose(sorted_eigvals, 0)]\n    if len(neg_eigvals) == 0:\n        # No stable modes, this case should not happen for this problem\n        return [-1, -1]\n    \n    min_decay_rate = np.min(-neg_eigvals)\n    fast_threshold = gamma * min_decay_rate\n    \n    fast_indices = [i for i, val in enumerate(sorted_eigvals) \n                    if -val >= fast_threshold and not np.isclose(val, 0)]\n\n    # 5. Identify equilibration modes\n    i_ab, i_cd = -1, -1\n    max_score_ab, max_score_cd = 0.0, 0.0\n\n    # Species indices: A=0, B=1, C=2, D=3\n    species_map = {'A': 0, 'B': 1, 'C': 2, 'D': 3}\n    u_ab, v_ab = species_map['A'], species_map['B']\n    u_cd, v_cd = species_map['C'], species_map['D']\n\n    if not fast_indices:\n        return [-1, -1]\n\n    for i in fast_indices:\n        r = sorted_eigvecs[:, i]\n        norm_sq = np.sum(r**2)\n        if np.isclose(norm_sq, 0): continue\n\n        # Calculate participation score for A -> B\n        r_u_ab, r_v_ab = r[u_ab], r[v_ab]\n        if r_u_ab * r_v_ab  0:\n            score = (r_u_ab**2 + r_v_ab**2) / norm_sq\n            if score > max_score_ab:\n                max_score_ab = score\n                i_ab = i\n\n        # Calculate participation score for C -> D\n        r_u_cd, r_v_cd = r[u_cd], r[v_cd]\n        if r_u_cd * r_v_cd  0:\n            score = (r_u_cd**2 + r_v_cd**2) / norm_sq\n            if score > max_score_cd:\n                max_score_cd = score\n                i_cd = i\n                \n    return [i_ab, i_cd]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2634427"}, {"introduction": "理论与诊断最终将应用于实践。这项综合性练习将挑战您将CSP方法应用于一个非线性反应网络，这种情况更具现实化学世界的代表性。您将构建零阶（QSS）和一阶CSP降阶模型，进行模拟，并定量地衡量其精度的提升，从而为高阶CSP校正的强大功能和实用价值提供具体证明。[@problem_id:2634446]", "problem": "实现一个完整的程序，该程序针对一个指定的、具有清晰快慢结构的两物种非线性反应网络，构建零阶和一阶计算奇异摄动 (CSP) 慢流形，将动力学投影到这些流形上以获得降维后的一维动力学，并在一个慢时间尺度上将所得轨迹与完整的二维动力学进行定量比较。所有浓度和时间均为无量纲。程序必须仅使用执行环境中指定的 Python 标准库、NumPy 和 SciPy。\n\n该网络由两个物种定义，分别表示为 $x$（慢）和 $y$（快），其控制方程为\n$$\n\\frac{dx}{dt} = \\varepsilon f(x,y), \\quad \\frac{dy}{dt} = g(x,y),\n$$\n其中 $\\varepsilon$ 是一个小的正参数。函数 $f$ 和 $g$ 源于以下示意性网络的质量作用动力学：$x$ 的慢速流入和衰变，$x$ 和 $y$ 之间的快速可逆相互转换，以及 $y$ 的非线性二次消耗和线性衰变。具体而言，令\n$$\nf(x,y) = s - d x - k_f x + k_b y,\n$$\n$$\ng(x,y) = k_f x - k_b y - 2 k_2 y^2 - k_3 y,\n$$\n其中参数 $s, d, k_f, k_b, k_2, k_3 > 0$。这产生了一个形式为 $\\dot{x} = \\varepsilon f(x,y)$, $\\dot{y} = g(x,y)$ 的标准计算奇异摄动 (CSP) 设置。\n\n你的任务是：\n- 使用质量作用动力学的基础原理（速率表达式形式为 $k \\prod c_i^{\\nu_i}$，其中 $c_i$ 为浓度，$\\nu_i$ 为化学计量系数）以及慢流形的“不变性条件”来构建零阶和一阶 CSP 流形。零阶流形 $y = h_0(x)$ 由快变量的准稳态条件定义，\n$$\ng(x,h_0(x)) = 0.\n$$\n鉴于 $y$ 中的二次非线性，通过求解 $2 k_2 y^2 + (k_b+k_3) y - k_f x = 0$ 并选择非负根，来显式求解 $h_0(x)$，\n$$\nh_0(x) = \\frac{- (k_b + k_3) + \\sqrt{(k_b + k_3)^2 + 8 k_2 k_f x}}{4 k_2}.\n$$\n- 使用不变性条件推导一阶修正项 $h_1(x)$。不变性条件指出，沿着慢流形 $y=h(x,\\varepsilon)$，必须满足 $g(x,h(x,\\varepsilon)) = \\varepsilon h'(x,\\varepsilon) f(x,h(x,\\varepsilon))$。使用展开式 $h(x,\\varepsilon) = h_0(x) + \\varepsilon h_1(x) + \\mathcal{O}(\\varepsilon^2)$，并记 $g_y = \\partial g / \\partial y$ 和 $g_x = \\partial g / \\partial x$，$\\varepsilon^0$ 阶条件得出 $g(x,h_0(x))=0$，隐式微分得到 $h_0'(x) = - g_x(x,h_0(x)) / g_y(x,h_0(x))$。$\\varepsilon^1$ 阶条件得出\n$$\ng_y(x,h_0(x)) h_1(x) = h_0'(x) f(x,h_0(x)),\n$$\n因此\n$$\nh_1(x) = \\frac{h_0'(x) f(x,h_0(x))}{g_y(x,h_0(x))}.\n$$\n对于此网络，计算 $g_x(x,y) = k_f$ 和 $g_y(x,y) = -k_b - k_3 - 4 k_2 y$，因此 $h_0'(x) = \\frac{k_f}{k_b + k_3 + 4 k_2 h_0(x)}$，然后 $h_1(x)$ 可由上述公式得出。\n\n- 通过将流形近似代入慢变量方程，定义降维后的一维慢动力学：\n  - 零阶 CSP 降维动力学：$\\frac{dx}{dt} = \\varepsilon f(x, h_0(x))$，其中 $y(t) = h_0(x(t))$。\n  - 一阶 CSP 降维动力学：$\\frac{dx}{dt} = \\varepsilon f(x, h_0(x) + \\varepsilon h_1(x))$，其中 $y(t) = h_0(x(t)) + \\varepsilon h_1(x(t))$。\n\n- 对于下面测试套件中给出的每组参数，执行以下数值实验：\n  1. 从指定的初始条件 $(x(0),y(0))$ 在时间区间 $[0, T]$（其中 $T = 1/\\varepsilon$）上对完整的二维系统进行积分。\n  2. 在相同的时间区间上对零阶降维一维系统进行积分，其初始值 $x(0)$ 与完整系统的初始 $x(0)$ 相同，并根据流形关系 $y=h_0(x(t))$ 重构 $y(t)$。\n  3. 在相同的时间区间上对一阶降维一维系统进行积分，其初始值 $x(0)$ 与完整系统的初始 $x(0)$ 相同，并根据 $y=h_0(x(t))+\\varepsilon h_1(x(t))$ 重构 $y(t)$。\n  4. 在一个覆盖 $[0,T]$ 的公共时间网格上，计算每个降维轨迹与完整轨迹之间浓度误差的欧几里得范数的时间最大值，\n  $$\n  e_0 = \\max_{t \\in [0,T]} \\left\\| \\begin{bmatrix} x_{\\text{red},0}(t) - x_{\\text{full}}(t) \\\\ y_{\\text{red},0}(t) - y_{\\text{full}}(t) \\end{bmatrix} \\right\\|_2, \\quad\n  e_1 = \\max_{t \\in [0,T]} \\left\\| \\begin{bmatrix} x_{\\text{red},1}(t) - x_{\\text{full}}(t) \\\\ y_{\\text{red},1}(t) - y_{\\text{full}}(t) \\end{bmatrix} \\right\\|_2.\n  $$\n  5. 对于每个测试用例，报告三元组 $[e_0, e_1, \\text{improved}]$，其中 $\\text{improved}$ 是一个布尔值，当且仅当 $e_1  e_0$ 时为真。\n\n测试套件：\n- 案例 1：$\\varepsilon = 0.02, k_f = 5.0, k_b = 1.0, k_2 = 2.0, k_3 = 0.5, s = 1.0, d = 0.1$，初始条件 $(x(0),y(0)) = (0.5, 0.05)$。\n- 案例 2：$\\varepsilon = 0.005, k_f = 6.0, k_b = 1.0, k_2 = 4.0, k_3 = 0.2, s = 0.8, d = 0.05$，初始条件 $(x(0),y(0)) = (0.3, 0.9)$。\n- 案例 3：$\\varepsilon = 0.02, k_f = 3.0, k_b = 1.0, k_2 = 0.1, k_3 = 0.4, s = 0.5, d = 0.05$，初始条件 $(x(0),y(0)) = (0.4, 0.1)$。\n- 案例 4：$\\varepsilon = 0.10, k_f = 4.0, k_b = 1.2, k_2 = 1.5, k_3 = 0.6, s = 1.2, d = 0.2$，初始条件 $(x(0),y(0)) = (0.6, 0.2)$。\n\n数值要求：\n- 对完整的二维系统使用适用于刚性动力学的隐式刚性求解器（例如，后向微分公式），对降维系统使用任何合适的精确积分器。在 $[0,T]$ 上使用至少包含 $200$ 个点的均匀时间网格进行误差评估。\n- 所有计算都是无量纲的；不需要物理单位。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有测试用例的结果。结果为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身又是 $[e_0, e_1, \\text{improved}]$ 形式的列表。例如，包含两个用例的输出应如下所示：$[[0.1,0.05,True],[0.2,0.18,True]]$。", "solution": "我们从一个标准快慢形式的两物种系统开始，\n$$\n\\frac{dx}{dt} = \\varepsilon f(x,y), \\quad \\frac{dy}{dt} = g(x,y),\n$$\n其中 $\\varepsilon$ 是一个小的正数，因此 $x$ 在慢时间尺度上演化，而 $y$ 快速弛豫。函数 $f$ 和 $g$ 源于质量作用动力学，这是一个基础原理，它规定反应速率的形式为 $k \\prod c_i^{\\nu_i}$，其中 $k$ 是速率常数，$c_i$ 是物种浓度，$\\nu_i$ 是化学计量指数。所选网络产生\n$$\nf(x,y) = s - d x - k_f x + k_b y,\n$$\n$$\ng(x,y) = k_f x - k_b y - 2 k_2 y^2 - k_3 y,\n$$\n其中速率参数 $s, d, k_f, k_b, k_2, k_3$ 均为正数。\n\n计算奇异摄动 (CSP) 方法使用关于 $\\varepsilon$ 的渐近展开，来逼近快动力学达到平衡所在的慢不变流形。对于一个流形 $y=h(x,\\varepsilon)$，其不变性条件是：在流形上的点评估的向量场与该流形的图像相切：\n$$\n\\frac{dy}{dt} = \\frac{d}{dt} h(x,\\varepsilon) = \\frac{\\partial h}{\\partial x}(x,\\varepsilon) \\frac{dx}{dt},\n$$\n并且由于在流形上 $\\frac{dx}{dt} = \\varepsilon f(x,h(x,\\varepsilon))$ 以及 $\\frac{dy}{dt} = g(x,h(x,\\varepsilon))$，不变性条件变为\n$$\ng(x,h(x,\\varepsilon)) = \\varepsilon h'(x,\\varepsilon) f(x,h(x,\\varepsilon)).\n$$\n我们寻求一个渐近展开 $h(x,\\varepsilon) = h_0(x) + \\varepsilon h_1(x) + \\mathcal{O}(\\varepsilon^2)$，并将其代入不变性条件。将左侧展开至 $\\varepsilon$ 阶可得\n$$\ng(x,h_0(x) + \\varepsilon h_1(x)) = g(x,h_0(x)) + \\varepsilon g_y(x,h_0(x)) h_1(x) + \\mathcal{O}(\\varepsilon^2),\n$$\n其中 $g_y = \\partial g / \\partial y$。右侧展开至 $\\varepsilon$ 阶为\n$$\n\\varepsilon h'(x,\\varepsilon) f(x,h(x,\\varepsilon)) = \\varepsilon h_0'(x) f(x,h_0(x)) + \\mathcal{O}(\\varepsilon^2).\n$$\n令 $\\varepsilon$ 的同阶项相等，可得：\n- $\\mathcal{O}(\\varepsilon^0)$ 阶：$g(x,h_0(x)) = 0$，这定义了零阶慢流形 $h_0$，即快动力学的准稳态。\n- $\\mathcal{O}(\\varepsilon^1)$ 阶：$g_y(x,h_0(x)) h_1(x) = h_0'(x) f(x,h_0(x))$，一旦 $h_0$ 已知且可微，该式便决定了一阶修正项 $h_1(x)$。\n\n对于给定的特定 $g(x,y)$，即 $g(x,y) = k_f x - k_b y - 2 k_2 y^2 - k_3 y$，零阶流形求解\n$$\n2 k_2 y^2 + (k_b + k_3) y - k_f x = 0,\n$$\n可得\n$$\nh_0(x) = \\frac{- (k_b + k_3) + \\sqrt{(k_b + k_3)^2 + 8 k_2 k_f x}}{4 k_2},\n$$\n此处选择非负根。对恒等式 $g(x,h_0(x)) \\equiv 0$ 关于 $x$ 求导，得到\n$$\ng_x(x,h_0(x)) + g_y(x,h_0(x)) h_0'(x) = 0 \\quad \\Rightarrow \\quad h_0'(x) = -\\frac{g_x(x,h_0(x))}{g_y(x,h_0(x))},\n$$\n此处 $g_x(x,y) = k_f$ 且 $g_y(x,y) = -k_b - k_3 - 4 k_2 y$，因此\n$$\nh_0'(x) = \\frac{k_f}{k_b + k_3 + 4 k_2 h_0(x)}.\n$$\n然后，一阶修正项可从 $\\mathcal{O}(\\varepsilon^1)$ 阶条件得出：\n$$\nh_1(x) = \\frac{h_0'(x) f(x,h_0(x))}{g_y(x,h_0(x))}.\n$$\n\n为评估这些流形在一个慢时间尺度上再现完整动力学的保真度，定义 $T = 1/\\varepsilon$。我们比较：\n- 完整轨迹 $(x_{\\text{full}}(t), y_{\\text{full}}(t))$，通过求解从给定初始条件 $(x(0),y(0))$ 在 $t \\in [0,T]$ 上的二维系统得到。\n- 零阶降维轨迹 $(x_{\\text{red},0}(t), y_{\\text{red},0}(t))$，通过求解 $\\dot{x} = \\varepsilon f(x,h_0(x))$ 得到，其初始值 $x(0)$ 与完整系统的初始 $x(0)$ 匹配，且 $y_{\\text{red},0}(t) = h_0(x_{\\text{red},0}(t))$。\n- 一阶降维轨迹 $(x_{\\text{red},1}(t), y_{\\text{red},1}(t))$，通过求解 $\\dot{x} = \\varepsilon f(x,h_0(x)+\\varepsilon h_1(x))$ 得到，其初始值 $x(0)$ 与完整系统的初始 $x(0)$ 匹配，且 $y_{\\text{red},1}(t) = h_0(x_{\\text{red},1}(t)) + \\varepsilon h_1(x_{\\text{red},1}(t))$。\n\n在 $[0,T]$ 内的均匀时间网格上，我们计算该区间上欧几里得浓度误差的最大值，\n$$\ne_0 = \\max_{t \\in [0,T]} \\left\\| \\begin{bmatrix} x_{\\text{red},0}(t) - x_{\\text{full}}(t) \\\\ y_{\\text{red},0}(t) - y_{\\text{full}}(t) \\end{bmatrix} \\right\\|_2, \\quad\ne_1 = \\max_{t \\in [0,T]} \\left\\| \\begin{bmatrix} x_{\\text{red},1}(t) - x_{\\text{full}}(t) \\\\ y_{\\text{red},1}(t) - y_{\\text{full}}(t) \\end{bmatrix} \\right\\|_2.\n$$\n然后我们为每个用例输出 $[e_0, e_1, \\text{improved}]$，其中当 $e_1  e_0$ 时，$\\text{improved}$ 为真。\n\n算法设计：\n- 通过二次公式显式地构建 $h_0(x)$ 以满足 $g(x,h_0(x))=0$。\n- 使用已知偏导数，通过隐式微分将 $h_0'(x)$ 计算为 $h_0'(x) = - g_x / g_y$。\n- 通过 $h_1(x) = h_0'(x) f(x,h_0(x)) / g_y(x,h_0(x))$ 计算 $h_1(x)$。\n- 使用刚性求解器（如后向微分公式）对完整的二维系统进行积分，以处理快速弛豫的 $y$ 动力学。\n- 对零阶和一阶近似的一维降维动力学进行积分。根据相应的流形关系，沿每个降维轨迹重构 $y$。\n- 在 $[0,T]$ 的均匀时间网格上，评估每个降维轨迹相对于完整轨迹的最大欧几里得误差。\n- 按规定格式组合并打印结果。\n\n提供的测试套件包含四组参数集，用于探究不同方面：一个典型的刚性案例，一个具有更强非线性的更极端刚性案例，一个二次非线性较小的近线性快速动力学案例，以及一个具有较大 $\\varepsilon$ 的临界案例。布尔指示符揭示了在每种情况下，一阶 CSP 流形是否比零阶流形改进了近似效果。\n\n所有量都是无量纲的，因此不涉及物理单位。最终输出为单行，包含一个类似 Python 的列表的列表，每个子列表对应一个测试用例，其中包含两个浮点误差和一个布尔值，如前所述。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef make_params(eps, kf, kb, k2, k3, s, d, x0, y0):\n    return {\n        \"eps\": float(eps),\n        \"kf\": float(kf),\n        \"kb\": float(kb),\n        \"k2\": float(k2),\n        \"k3\": float(k3),\n        \"s\": float(s),\n        \"d\": float(d),\n        \"x0\": float(x0),\n        \"y0\": float(y0),\n    }\n\ndef f_slow(x, y, p):\n    return p[\"s\"] - p[\"d\"] * x - p[\"kf\"] * x + p[\"kb\"] * y\n\ndef g_fast(x, y, p):\n    return p[\"kf\"] * x - p[\"kb\"] * y - 2.0 * p[\"k2\"] * y * y - p[\"k3\"] * y\n\ndef h0(x, p):\n    # Solve 2*k2*y^2 + (kb+k3)*y - kf*x = 0 for nonnegative y\n    a = 2.0 * p[\"k2\"]\n    b = p[\"kb\"] + p[\"k3\"]\n    disc = b * b + 8.0 * p[\"k2\"] * p[\"kf\"] * x\n    # Numerical safety: ensure nonnegative discriminant\n    disc = max(disc, 0.0)\n    y = (-b + np.sqrt(disc)) / (2.0 * a)\n    return y\n\ndef g_x(p):\n    return p[\"kf\"]\n\ndef g_y_at(x, y, p):\n    return -p[\"kb\"] - p[\"k3\"] - 4.0 * p[\"k2\"] * y\n\ndef h0_prime(x, p):\n    y = h0(x, p)\n    gy = g_y_at(x, y, p)\n    # h0' = -g_x / g_y\n    return -g_x(p) / gy\n\ndef h1(x, p):\n    y0 = h0(x, p)\n    gy = g_y_at(x, y0, p)\n    h0p = h0_prime(x, p)\n    f0 = f_slow(x, y0, p)\n    return (h0p * f0) / gy\n\ndef full_system_rhs(t, z, p):\n    x, y = z\n    dxdt = p[\"eps\"] * f_slow(x, y, p)\n    dydt = g_fast(x, y, p)\n    return [dxdt, dydt]\n\ndef reduced_zero_rhs(t, x, p):\n    # dx/dt = eps * f(x, h0(x))\n    return p[\"eps\"] * f_slow(x, h0(x, p), p)\n\ndef reduced_first_rhs(t, x, p):\n    # dx/dt = eps * f(x, h0(x) + eps * h1(x))\n    y_approx = h0(x, p) + p[\"eps\"] * h1(x, p)\n    return p[\"eps\"] * f_slow(x, y_approx, p)\n\ndef integrate_full(p, T, t_eval):\n    z0 = [p[\"x0\"], p[\"y0\"]]\n    sol = solve_ivp(\n        fun=lambda t, z: full_system_rhs(t, z, p),\n        t_span=(0.0, T),\n        y0=z0,\n        method=\"BDF\",\n        t_eval=t_eval,\n        rtol=1e-10,\n        atol=1e-12,\n    )\n    if not sol.success:\n        raise RuntimeError(\"Full system integration failed: \" + sol.message)\n    return sol.t, sol.y[0, :], sol.y[1, :]\n\ndef integrate_reduced(rhs, p, T, t_eval):\n    x0 = p[\"x0\"]\n    sol = solve_ivp(\n        fun=lambda t, x: rhs(t, x, p),\n        t_span=(0.0, T),\n        y0=[x0],\n        method=\"BDF\",\n        t_eval=t_eval,\n        rtol=1e-12,\n        atol=1e-14,\n    )\n    if not sol.success:\n        raise RuntimeError(\"Reduced system integration failed: \" + sol.message)\n    return sol.t, sol.y[0, :]\n\ndef max_traj_error(xr, yr, xf, yf):\n    # Compute max over time of Euclidean norm error between reduced and full trajectories\n    dx = xr - xf\n    dy = yr - yf\n    errs = np.sqrt(dx * dx + dy * dy)\n    return float(np.max(errs))\n\ndef run_case(p):\n    # Define slow timescale horizon\n    T = 1.0 / p[\"eps\"]\n    # Time grid for error evaluation\n    n_points = 401  # dense enough while efficient\n    t_eval = np.linspace(0.0, T, n_points)\n\n    # Integrate full system\n    t_full, x_full, y_full = integrate_full(p, T, t_eval)\n\n    # Integrate zero-order reduced system and reconstruct y\n    t0, x0 = integrate_reduced(reduced_zero_rhs, p, T, t_eval)\n    y0 = np.array([h0(x, p) for x in x0])\n\n    # Integrate first-order reduced system and reconstruct y\n    t1, x1 = integrate_reduced(reduced_first_rhs, p, T, t_eval)\n    y1 = np.array([h0(x, p) + p[\"eps\"] * h1(x, p) for x in x1])\n\n    # Compute errors (ensure time grids align)\n    assert np.allclose(t_full, t0) and np.allclose(t_full, t1)\n    e0 = max_traj_error(x0, y0, x_full, y_full)\n    e1 = max_traj_error(x1, y1, x_full, y_full)\n    improved = e1  e0\n    return [e0, e1, improved]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        make_params(eps=0.02, kf=5.0, kb=1.0, k2=2.0, k3=0.5, s=1.0, d=0.1, x0=0.5, y0=0.05),\n        make_params(eps=0.005, kf=6.0, kb=1.0, k2=4.0, k3=0.2, s=0.8, d=0.05, x0=0.3, y0=0.9),\n        make_params(eps=0.02, kf=3.0, kb=1.0, k2=0.1, k3=0.4, s=0.5, d=0.05, x0=0.4, y0=0.1),\n        make_params(eps=0.10, kf=4.0, kb=1.2, k2=1.5, k3=0.6, s=1.2, d=0.2, x0=0.6, y0=0.2),\n    ]\n\n    results = []\n    for p in test_cases:\n        res = run_case(p)\n        # Convert floats to a reasonable precision for stable output\n        e0, e1, improved = res\n        e0_out = float(np.float64(e0))\n        e1_out = float(np.float64(e1))\n        results.append([e0_out, e1_out, improved])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans are represented as True/False without quotes.\n    def elem_to_str(elem):\n        if isinstance(elem, bool):\n            return \"True\" if elem else \"False\"\n        if isinstance(elem, float):\n            # Format with repr to avoid scientific notation ambiguity while keeping precision\n            return repr(elem)\n        if isinstance(elem, int):\n            return str(elem)\n        if isinstance(elem, list):\n            return \"[\" + \",\".join(elem_to_str(e) for e in elem) + \"]\"\n        return str(elem)\n\n    print(\"[\" + \",\".join(elem_to_str(r) for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2634446"}]}