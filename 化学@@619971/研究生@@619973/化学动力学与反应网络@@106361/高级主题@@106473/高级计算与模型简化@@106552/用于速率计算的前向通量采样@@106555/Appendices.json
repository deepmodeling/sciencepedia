{"hands_on_practices": [{"introduction": "任何前向通量取样 (Forward Flux Sampling, FFS) 计算的第一步都是确定初始通量 $\\Phi_{A,0}$，即轨迹离开初始状态 $A$ 并首次穿过第一个界面 $\\lambda_0$ 的速率。本练习提供了一个具体实践，要求你为一个简单的生灭过程实现这一关键计算。通过使用随机模拟算法 (Stochastic Simulation Algorithm, SSA)，你将以编程方式应用 FFS 的重注入协议，并学习如何收集估计这一基础量所需的统计数据 [@problem_id:2645590]。", "problem": "设计一个程序，该程序使用随机模拟算法（SSA）来模拟一维生灭化学反应网络，并估算其在前向通量采样（FFS）中的首次穿越通量。从状态盆 $A$ 到第一个界面 $\\lambda_{0}$ 的首次穿越通量（记为 $\\Phi_{A,0}$）定义为，在每次成功首次到达 $\\lambda_{0}$ 或未到达便返回 $A$ 后都将系统在 $A$ 中重新启动的重注入协议下，单位 SSA 时间内首次到达 $\\lambda_{0}$ 次数的长时间极限。您必须使用此协议，为 $\\Phi_{A,0}$ 实现一个统计上正确的估计器。\n\n使用以下化学动力学模型，该模型包含单一物种 $X$，其拷贝数为 $n \\in \\{0,1,2,\\dots\\}$：\n- 生成反应：$\\varnothing \\rightarrow X$，速率常数为 $k_{\\text{b}}$（单位：$\\text{s}^{-1}$），倾向性为 $a_{1}(n) = k_{\\text{b}}$。\n- 消亡反应：$X \\rightarrow \\varnothing$，速率常数为 $k_{\\text{d}}$（单位：$\\text{s}^{-1}$），倾向性为 $a_{2}(n) = k_{\\text{d}} \\, n$。\n\n通过随机模拟算法（SSA）（Gillespie 算法）模拟该连续时间马尔可夫链。在状态 $n$，总倾向性为 $a_{0}(n) = a_{1}(n) + a_{2}(n) = k_{\\text{b}} + k_{\\text{d}} \\, n$。SSA 的等待时间增量是一个速率为 $a_{0}(n)$ 的指数随机变量，而反应通道的选择概率与各自的倾向性成正比。\n\n定义序参量 $\\lambda(n) = n$。对于给定的整数阈值 $n_{A} \\geq 0$，定义状态盆 $A = \\{ n \\,:\\, n \\leq n_{A} \\}$；对于给定的整数 $n_{0} > n_{A}$，定义第一个界面 $\\lambda_{0} = \\{ n \\,:\\, n \\geq n_{0} \\}$。从 $A$ 中开始，运行 SSA 并追踪轨迹离开 $A$ 时开始的出射。对于每次出射，当轨迹到达 $\\lambda_{0}$（计为一次首次到达）或返回到 $A$ （计为零次）时，停止该次出射。无论结果如何，都根据无约束过程限制在 $A$ 内的稳态分布，将系统重注入到 $A$ 中，并继续 SSA。累积所有步骤中推进的总 SSA 时间。通量的估计器为\n$$\n\\widehat{\\Phi}_{A,0} \\;=\\; \\frac{N_{\\text{hits}}}{T_{\\text{sim}}},\n$$\n其中 $N_{\\text{hits}}$ 是观测到的首次到达 $\\lambda_{0}$ 的次数，$T_{\\text{sim}}$ 是模拟的总 SSA 时间。对于每种情况，以 $\\text{s}^{-1}$ 为单位表示数值答案，并四舍五入到六位有效数字。\n\n对于指定的生灭过程，当 $k_{\\text{d}} > 0$ 时，在 $\\{0,1,2,\\dots\\}$ 上存在稳态分布，该分布是均值为 $\\mu = k_{\\text{b}}/k_{\\text{d}}$ 的泊松分布。因此，限制在 $A$ 内的重注入分布是截断至 $\\{0,1,\\dots,n_{A}\\}$ 的泊松分布，其在该集合上的概率与 $\\mu^{n}/n!$ 成正比。您的程序必须从此截断分布中对重注入状态进行采样。\n\n实现要求：\n- 针对每种情况，完全按照上述定义模拟 SSA，总模拟时间为 $T_{\\text{sim}}$，并在每次出射结束后使用重注入协议。\n- 仅当一次出射在返回到 $n \\leq n_{A}$ 之前到达任意 $n \\in \\{ n_{0}, n_{0}+1, \\dots \\}$ 时，才计为一次首次到达 $\\lambda_{0}$。\n- 在所有步骤中连续累积 SSA 时间，包括在 $A$ 内部和出射过程中的时间。\n- 按照每个测试用例的指定，使用固定的随机数生成器种子，以确保确定性的输出。\n\n测试套件：\n提供以下四种情况的结果。在每种情况下，报告估计通量 $\\widehat{\\Phi}_{A,0}$，单位为 $\\text{s}^{-1}$，并四舍五入到六位有效数字。\n\n- 情况 1（典型路径，中等通量）：\n  - $k_{\\text{b}} = 1.0\\ \\text{s}^{-1}$，$k_{\\text{d}} = 0.5\\ \\text{s}^{-1}$，$n_{A} = 1$，$n_{0} = 4$，$T_{\\text{sim}} = 4000.0\\ \\text{s}$，种子 $= 12345$。\n- 情况 2（稀有事件机制，在有限时间内可能计数为零）：\n  - $k_{\\text{b}} = 0.2\\ \\text{s}^{-1}$，$k_{\\text{d}} = 1.0\\ \\text{s}^{-1}$，$n_{A} = 1$，$n_{0} = 5$，$T_{\\text{sim}} = 20000.0\\ \\text{s}$，种子 $= 67890$。\n- 情况 3（边界情况 $n_{0} = n_{A}+1$，此时离开 $A$ 即为首次到达）：\n  - $k_{\\text{b}} = 3.0\\ \\text{s}^{-1}$，$k_{\\text{d}} = 1.0\\ \\text{s}^{-1}$，$n_{A} = 2$，$n_{0} = 3$，$T_{\\text{sim}} = 3000.0\\ \\text{s}$，种子 $= 24680$。\n- 情况 4（单个分子的消亡率高于生成率但均值大于1，中等势垒）：\n  - $k_{\\text{b}} = 5.0\\ \\text{s}^{-1}$，$k_{\\text{d}} = 4.0\\ \\text{s}^{-1}$，$n_{A} = 1$，$n_{0} = 3$，$T_{\\text{sim}} = 6000.0\\ \\text{s}$，种子 $= 13579$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表内容为上述各情况的结果，按顺序排列，每个值都四舍五入到六位有效数字，单位 $\\text{s}^{-1}$ 被隐式省略，例如：`[0.123456,0,0.042,0.9]`。", "solution": "问题陈述经过严格验证，被认为是**有效的**。\n\n它是**有科学依据的**，描述了一个通过经典的随机模拟算法（SSA）模拟的标准一维生灭过程。首次穿越通量的概念及其使用带重注入的暴力模拟进行估计，是用于稀有事件模拟的前向通量采样（FFS）方法论的一个基本组成部分。使用截断泊松分布进行重注入与该过程已知的稳态性质是一致的。\n\n该问题是**适定**的。它为每种情况提供了所有必要的参数（$k_{\\text{b}}$、$k_{\\text{d}}$、$n_A$、$n_0$、$T_{\\text{sim}}$）、初始条件（通过重注入协议）和一个确定性元素（固定的随机数生成器种子），从而确保了唯一且可复现的计算结果。\n\n该问题是**客观**和完整的，其定义和要求没有歧义。所有术语都在化学动力学和随机过程的背景下进行了正式定义。提供的测试用例是合乎逻辑的，涵盖了不同的物理机制，包括一个边界情况（$n_0 = n_A+1$）和一个稀有事件场景，使该问题成为对实现正确性的有效测试。\n\n因此，可以构建一个合理的解决方案。\n\n任务是为一个生灭过程估计首次穿越通量 $\\widehat{\\Phi}_{A,0} = N_{\\text{hits}}/T_{\\text{sim}}$。这需要实现一个遵循前向通量采样定义的特定协议的随机模拟。该模拟将基于 Gillespie 随机模拟算法（SSA）。\n\n算法的核心是一个状态转换循环，该循环一直运行直到累积的总模拟时间达到 $T_{\\text{sim}}$。系统由物种 $X$ 的拷贝数 $n$ 来表征。状态空间被划分为一个状态盆区域 $A = \\{n \\mid n \\leq n_A\\}$、一个由第一个界面定义的目标区域 $\\lambda_0 = \\{n \\mid n \\geq n_0\\}$，以及一个中间区域 $\\{n \\mid n_A < n < n_0\\}$。\n\n模拟逻辑如下：\n\n1.  **初始化**：模拟在时间 $t=0$ 开始，初始到达次数为零（$N_{\\text{hits}}=0$）。初始状态 $n$ 不是一个固定值，而是从一个特定的概率分布中抽样得出，以确保过程从一个与重注入协议一致的稳态开始。该分布是无约束生灭过程的稳态分布，即一个均值为 $\\mu = k_{\\text{b}}/k_{\\text{d}}$ 的泊松分布，并截断到状态盆 $A$。\n\n2.  **重注入分布采样**：为了从 $\\{0, 1, \\dots, n_A\\}$ 上的截断泊松分布中采样一个状态，我们首先为每个状态 $i \\in A$ 计算未归一化的权重 $w_i = \\mu^i/i!$。将这些权重归一化以获得概率 $p_i$。然后构建累积分布函数（CDF）。通过抽取一个均匀随机数 $u \\in [0, 1)$ 并找到第一个大于或等于 $u$ 的 CDF 值所对应的状态 $j$ 来进行采样（逆变换采样）。\n\n3.  **主模拟循环**：只要当前模拟时间 $t$ 小于 $T_{\\text{sim}}$，循环就继续进行。\n    a.  **SSA 步骤**：在给定状态 $n$ 下，总倾向性为 $a_0(n) = k_{\\text{b}} + k_{\\text{d}}n$。从速率为 $a_0(n)$ 的指数分布中抽取一个时间步长 $\\Delta t$。总时间向前推进，$t \\leftarrow t + \\Delta t$。如果新时间超过 $T_{\\text{sim}}$，循环终止，以避免计算超出指定模拟窗口的事件。根据各个倾向性（$k_{\\text{b}}$ 和 $k_{\\text{d}}n$）成比例的概率选择一个反应（生成，$n \\to n+1$；或消亡，$n \\to n-1$）。\n    b.  **FFS 状态逻辑**：模拟逻辑取决于系统之前是在状态盆 $A$ 内部，还是处于离开盆的“出射”状态。\n        i. 如果系统离开状态盆（从 $n_{\\text{old}} \\le n_A$ 跃迁到 $n_{\\text{new}} > n_A$），一次出射开始。\n        ii. 当轨迹到达界面 $\\lambda_{0}$（$n \\ge n_0$）或返回状态盆 $A$（$n \\le n_A$）时，出射结束。\n        iii. 如果出射以到达 $\\lambda_0$ 结束，计数器 $N_{\\text{hits}}$ 增加1。\n        iv. 在任何出射终止（到达或返回）后，系统状态 $n$ 会立即通过根据步骤2中描述的截断泊松分布将其重注入到状态盆 $A$ 中来重置。然后模拟从这个新状态继续进行。这种重注入是瞬时的状态重置，不推进模拟时间。\n\n4.  **最终计算**：模拟循环结束后，通量估计值通过将记录的总到达次数除以总模拟时间来计算，即 $\\widehat{\\Phi}_{A,0} = N_{\\text{hits}} / T_{\\text{sim}}$。每个测试用例的结果都四舍五入到六位有效数字。", "answer": "```python\nimport numpy as np\nfrom scipy.special import factorial\n\ndef estimate_flux(k_b, k_d, n_A, n_0, T_sim, seed):\n    \"\"\"\n    Estimates the first-crossing flux using SSA and an FFS-style reinjection protocol.\n\n    Args:\n        k_b (float): Birth rate constant.\n        k_d (float): Death rate constant.\n        n_A (int): Threshold for basin A.\n        n_0 (int): Threshold for the first interface.\n        T_sim (float): Total simulation time.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The estimated flux Phi_{A,0}.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    n_hits = 0\n    t_current = 0.0\n\n    # 1. Pre-calculate the reinjection distribution (truncated Poisson)\n    # The unconstrained stationary distribution is Poisson with mean mu.\n    mu = k_b / k_d\n    \n    # Weights for states n = 0, 1, ..., n_A\n    states_A = np.arange(n_A + 1)\n    # Using gammaln for log-factorials is more stable, but for small n_A, direct factorial is fine.\n    # SciPy's factorial handles arrays.\n    weights = np.power(mu, states_A) / factorial(states_A)\n    \n    # Handle the case where all weights are zero (e.g., mu=0, n_A > 0)\n    if np.sum(weights) == 0:\n        # If mu=0, the only state with non-zero weight is n=0.\n        if mu == 0:\n            weights[0] = 1.0\n        else: # Should not happen with positive kb, kd.\n            raise ValueError(\"Could not compute a valid reinjection distribution.\")\n\n    probabilities = weights / np.sum(weights)\n    cdf = np.cumsum(probabilities)\n\n    def reinject():\n        \"\"\"Samples a new state from the truncated Poisson distribution in basin A.\"\"\"\n        u = rng.random()\n        # Find the first index where the cumulative probability is >= u\n        new_n = np.searchsorted(cdf, u, side='left')\n        return new_n\n\n    # 2. Initialization\n    n = reinject()\n    in_excursion = False # True if n > n_A\n\n    # 3. Main simulation loop\n    while t_current < T_sim:\n        a_birth = k_b\n        # Death propensity is 0 if n=0, preventing n from becoming negative.\n        a_death = k_d * n if n > 0 else 0.0\n        a_total = a_birth + a_death\n\n        if a_total == 0:\n            # System is in an absorbing state, time advances to infinity.\n            # This happens if k_b=0 and n=0. Not expected in test cases.\n            break\n\n        # Generate time step from exponential distribution\n        dt = -np.log(rng.random()) / a_total\n        \n        t_next = t_current + dt\n        if t_next > T_sim:\n            # This step would cross the T_sim boundary, so we end the simulation here.\n            break\n        \n        t_current = t_next\n        n_old = n\n\n        # Choose reaction\n        if rng.random() * a_total < a_birth:\n            n += 1 # Birth\n        else:\n            n -= 1 # Death\n\n        # 4. FFS Logic: check for excursion start, hit, or return\n        was_in_excursion = in_excursion\n        \n        if not was_in_excursion: # System was in basin A (n_old <= n_A)\n            if n > n_A: # Trajectory has just left A, starting an excursion\n                in_excursion = True\n                # Check for an immediate hit (e.g., when n_0 = n_A + 1)\n                if n >= n_0:\n                    n_hits += 1\n                    n = reinject()\n                    in_excursion = False\n        else: # System was in an excursion (n_old > n_A)\n            if n >= n_0: # Excursion hits the target interface\n                n_hits += 1\n                n = reinject()\n                in_excursion = False\n            elif n <= n_A: # Excursion returns to the basin\n                n = reinject()\n                in_excursion = False\n            # else: n_A < n < n_0, excursion continues\n\n    # 5. Final calculation\n    if T_sim <= 0:\n        return 0.0\n    \n    flux_estimate = n_hits / T_sim\n    return flux_estimate\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (k_b, k_d, n_A, n_0, T_sim, seed)\n        (1.0, 0.5, 1, 4, 4000.0, 12345),\n        (0.2, 1.0, 1, 5, 20000.0, 67890),\n        (3.0, 1.0, 2, 3, 3000.0, 24680),\n        (5.0, 4.0, 1, 3, 6000.0, 13579),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_b, k_d, n_A, n_0, T_sim, seed = case\n        flux = estimate_flux(k_b, k_d, n_A, n_0, T_sim, seed)\n        # Format to 6 significant digits using 'g' format specifier\n        results.append(f\"{flux:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2645590"}, {"introduction": "FFS 速率常数 $k_{AB}$ 是一个由初始通量和一系列条件概率计算得出的复合量。为了评估最终结果的可靠性，我们必须理解每个阶段的统计误差是如何传播的。本练习将引导你使用 delta 方法，从第一性原理出发推导 $\\ln \\hat{k}_{AB}$ 的方差，这是对复杂、多阶段估计进行误差分析的一项基本技术 [@problem_id:2645555]。", "problem": "考虑一个随机反应网络中从稳定状态集 $A$ 到不相交状态集 $B$ 的稀有事件转变，该过程由一个序参量 $\\lambda$ 和一系列界面 $\\lambda_{0} &lt; \\lambda_{1} &lt; \\cdots &lt; \\lambda_{n}$ 监控，其中 $A = \\{\\lambda &lt; \\lambda_{0}\\}$ 且 $B = \\{\\lambda \\ge \\lambda_{n}\\}$。在前向通量采样 (FFS) 方法中，速率常数 $k_{AB}$ 表示为 $k_{AB} = \\Phi_{A,0}\\prod_{i=0}^{n-1} p_{i}$，其中 $\\Phi_{A,0}$ 是离开 $A$ 并穿过 $\\lambda_{0}$ 的轨迹的稳态通量，而 $p_{i}$ 是从 $\\lambda_{i}$ 出发的轨迹在返回 $A$ 之前到达 $\\lambda_{i+1}$ 的条件概率。假设你进行了一次 FFS 计算，得到了 $i \\in \\{0,\\dots,n-1\\}$ 的无偏点估计量 $\\hat{\\Phi}_{A,0}$ 和 $\\hat{p}_{i}$，以及相应的估计抽样方差 $\\widehat{\\mathrm{Var}}(\\hat{\\Phi}_{A,0})$ 和 $\\widehat{\\mathrm{Var}}(\\hat{p}_{i})$。假设满足以下条件：(i) 根据中心极限定理 (CLT)，估计量 $\\hat{\\Phi}_{A,0}, \\hat{p}_{0}, \\dots, \\hat{p}_{n-1}$ 是渐近联合正态的；(ii) 它们对于其目标值 $\\Phi_{A,0}, p_{0}, \\dots, p_{n-1}$ 是渐近无偏的；(iii) 它们在各个界面之间是渐近独立的，并且与通量估计量无关。令 $\\hat{k}_{AB} \\equiv \\hat{\\Phi}_{A,0} \\prod_{i=0}^{n-1} \\hat{p}_{i}$。\n\n从这些假设和多元一阶delta方法的第一性原理出发（不引用任何现成的简化公式），通过在对数尺度上进行运算然后变换回来，推导 $k_{AB}$ 的一个渐近 $(1-\\alpha)$ 置信区间。陈述你为使变换合法化而采用的任何正则性条件。作为最终答案，请报告 $\\ln \\hat{k}_{AB}$ 的渐近标准误的闭式表达式，该表达式用置入估计方差 $\\widehat{\\mathrm{Var}}(\\hat{\\Phi}_{A,0})$ 和 $\\widehat{\\mathrm{Var}}(\\hat{p}_{i})$ 以及点估计量 $\\hat{\\Phi}_{A,0}$ 和 $\\hat{p}_{i}$ 表示。最终答案必须是单一的闭式解析表达式。不要进行任何数值计算，也不要四舍五入。最终答案不需要物理单位，因为对数是无量纲的。", "solution": "审阅问题陈述后，确认其有效。这是一个在计算化学物理（特别是前向通量采样方法）中应用统计分析的适定问题。所有的假设和定义在科学上都是合理的，内部一致，并且足以进行所要求的推导。我们从第一性原理出发解决这个问题。\n\n从状态 $A$ 到状态 $B$ 的转变速率常数，记为 $k_{AB}$，由以下乘积形式给出：\n$$ k_{AB} = \\Phi_{A,0} \\prod_{i=0}^{n-1} p_{i} $$\n给定了这些参数的一组估计量：通量 $\\Phi_{A,0}$ 的估计量 $\\hat{\\Phi}_{A,0}$，以及条件概率 $p_i$ 的估计量 $\\hat{p}_i$（对于 $i \\in \\{0, \\dots, n-1\\}$）。速率常数的估计量是置入估计量：\n$$ \\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=0}^{n-1} \\hat{p}_{i} $$\n为推导置信区间，我们按照指示在对数尺度上进行运算。令 $h$ 为将参数映射到速率常数对数的函数：\n$$ \\ln(k_{AB}) = \\ln\\left(\\Phi_{A,0} \\prod_{i=0}^{n-1} p_{i}\\right) = \\ln(\\Phi_{A,0}) + \\sum_{i=0}^{n-1} \\ln(p_i) $$\n让我们将参数向量定义为 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\dots, \\theta_n)^T$，其中 $\\theta_0 = \\Phi_{A,0}$ 且对于 $i \\in \\{1, \\dots, n\\}$ 有 $\\theta_i = p_{i-1}$。相应的估计量向量是 $\\hat{\\boldsymbol{\\theta}} = (\\hat{\\Phi}_{A,0}, \\hat{p}_0, \\dots, \\hat{p}_{n-1})^T$。总共有 $n+1$ 个参数。我们感兴趣的函数是 $h(\\boldsymbol{\\theta}) = \\ln(\\theta_0) + \\sum_{i=1}^{n} \\ln(\\theta_i)$。\n\n该问题要求使用多元一阶delta方法。该方法为随机向量的函数的均值和方差提供了一个近似值。给定一个均值为 $\\boldsymbol{\\theta}$、协方差矩阵为 $\\boldsymbol{\\Sigma}_{\\hat{\\boldsymbol{\\theta}}}$ 的渐近正态随机向量 $\\hat{\\boldsymbol{\\theta}}$，以及一个在 $\\boldsymbol{\\theta}$ 处连续可微的函数 $h(\\boldsymbol{\\theta})$，随机变量 $h(\\hat{\\boldsymbol{\\theta}})$ 是渐近正态的，其均值为 $h(\\boldsymbol{\\theta})$，方差由下式给出：\n$$ \\mathrm{Var}(h(\\hat{\\boldsymbol{\\theta}})) \\approx [\\nabla h(\\boldsymbol{\\theta})]^T \\boldsymbol{\\Sigma}_{\\hat{\\boldsymbol{\\theta}}} [\\nabla h(\\boldsymbol{\\theta})] $$\n其中 $\\nabla h(\\boldsymbol{\\theta})$ 是 $h$ 在真实参数值 $\\boldsymbol{\\theta}$ 处计算的梯度向量。\n\n首先，我们计算 $h(\\boldsymbol{\\theta}) = \\ln(\\Phi_{A,0}) + \\sum_{i=0}^{n-1} \\ln(p_i)$ 的梯度。梯度的分量是关于每个参数的偏导数：\n$$ \\frac{\\partial h}{\\partial \\Phi_{A,0}} = \\frac{1}{\\Phi_{A,0}} $$\n$$ \\frac{\\partial h}{\\partial p_j} = \\frac{1}{p_j} \\quad \\text{for } j \\in \\{0, \\dots, n-1\\} $$\n因此，梯度向量为：\n$$ \\nabla h(\\boldsymbol{\\theta}) = \\begin{pmatrix} \\frac{1}{\\Phi_{A,0}} \\\\ \\frac{1}{p_0} \\\\ \\vdots \\\\ \\frac{1}{p_{n-1}} \\end{pmatrix} $$\n\n接下来，我们构建估计量的协方差矩阵 $\\boldsymbol{\\Sigma}_{\\hat{\\boldsymbol{\\theta}}} = \\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}})$。问题陈述了一个关键假设，即估计量 $\\hat{\\Phi}_{A,0}, \\hat{p}_0, \\dots, \\hat{p}_{n-1}$ 是渐近独立的。这意味着它们的协方差为零，协方差矩阵是对角矩阵：\n$$ \\boldsymbol{\\Sigma}_{\\hat{\\boldsymbol{\\theta}}} = \\begin{pmatrix} \\mathrm{Var}(\\hat{\\Phi}_{A,0}) & 0 & \\cdots & 0 \\\\ 0 & \\mathrm{Var}(\\hat{p}_0) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & \\mathrm{Var}(\\hat{p}_{n-1}) \\end{pmatrix} $$\n\n现在我们将梯度和协方差矩阵代入 $\\ln(\\hat{k}_{AB}) = h(\\hat{\\boldsymbol{\\theta}})$ 方差的delta方法公式中：\n$$ \\mathrm{Var}(\\ln \\hat{k}_{AB}) \\approx \\begin{pmatrix} \\frac{1}{\\Phi_{A,0}} & \\frac{1}{p_0} & \\cdots & \\frac{1}{p_{n-1}} \\end{pmatrix} \\begin{pmatrix} \\mathrm{Var}(\\hat{\\Phi}_{A,0}) & 0 & \\cdots & 0 \\\\ 0 & \\mathrm{Var}(\\hat{p}_0) & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & \\mathrm{Var}(\\hat{p}_{n-1}) \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\Phi_{A,0}} \\\\ \\frac{1}{p_0} \\\\ \\vdots \\\\ \\frac{1}{p_{n-1}} \\end{pmatrix} $$\n进行矩阵乘法得到：\n$$ \\mathrm{Var}(\\ln \\hat{k}_{AB}) \\approx \\frac{1}{\\Phi_{A,0}^2} \\mathrm{Var}(\\hat{\\Phi}_{A,0}) + \\frac{1}{p_0^2} \\mathrm{Var}(\\hat{p}_0) + \\cdots + \\frac{1}{p_{n-1}^2} \\mathrm{Var}(\\hat{p}_{n-1}) $$\n这可以写成紧凑形式：\n$$ \\mathrm{Var}(\\ln \\hat{k}_{AB}) \\approx \\frac{\\mathrm{Var}(\\hat{\\Phi}_{A,0})}{\\Phi_{A,0}^2} + \\sum_{i=0}^{n-1} \\frac{\\mathrm{Var}(\\hat{p}_i)}{p_i^2} $$\n项 $\\frac{\\mathrm{Var}(X)}{E[X]^2}$ 是变异系数（相对误差）的平方。乘积对数的方差近似为其独立分量的变异系数平方和。\n\n为了获得标准误的实用公式，我们使用置入原则。我们用样本估计量替换未知的真实参数 ($\\Phi_{A,0}$, $p_i$) 及其真实方差 ($\\mathrm{Var}(\\hat{\\Phi}_{A,0})$, $\\mathrm{Var}(\\hat{p}_i)$)。估计方差，记为 $\\widehat{\\mathrm{Var}}(\\ln \\hat{k}_{AB})$，是：\n$$ \\widehat{\\mathrm{Var}}(\\ln \\hat{k}_{AB}) = \\frac{\\widehat{\\mathrm{Var}}(\\hat{\\Phi}_{A,0})}{\\hat{\\Phi}_{A,0}^2} + \\sum_{i=0}^{n-1} \\frac{\\widehat{\\mathrm{Var}}(\\hat{p}_i)}{\\hat{p}_i^2} $$\n$\\ln \\hat{k}_{AB}$ 的渐近标准误，记为 $\\mathrm{SE}(\\ln \\hat{k}_{AB})$，是此估计方差的平方根。\n\ndelta方法有效性的正则性条件是，函数 $h$ 必须在真实参数向量 $\\boldsymbol{\\theta}$ 的邻域内连续可微。我们的函数是 $h(\\boldsymbol{\\theta}) = \\ln(\\Phi_{A,0}) + \\sum_{i=0}^{n-1} \\ln(p_i)$。其偏导数 $\\frac{1}{\\Phi_{A,0}}$ 和 $\\frac{1}{p_i}$ 是连续的，前提是对于所有 $i$ 都有 $\\Phi_{A,0} > 0$ 和 $p_i > 0$。这些条件对于转变的发生是物理上必需的；零通量或穿过界面的零概率意味着总速率常数 $k_{AB}$ 为零，这是一个不涉及稀有事件的平凡情况。因此，我们假设这些参数是严格为正的。\n\n有了标准误，就可以基于 $\\ln(\\hat{k}_{AB})$ 的渐近正态性，为 $\\ln(k_{AB})$ 构建一个渐近 $(1-\\alpha)$ 置信区间：\n$$ \\ln(\\hat{k}_{AB}) \\pm z_{1-\\alpha/2} \\mathrm{SE}(\\ln \\hat{k}_{AB}) $$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的上 $(1-\\alpha/2)$ 分位数。对该区间的端点取指数，即可得到 $k_{AB}$ 的置信区间。\n\n最终要求解的量是 $\\ln \\hat{k}_{AB}$ 的渐近标准误的闭式表达式。这是上面推导的置入估计方差的平方根。\n$$ \\mathrm{SE}(\\ln \\hat{k}_{AB}) = \\sqrt{\\frac{\\widehat{\\mathrm{Var}}(\\hat{\\Phi}_{A,0})}{\\hat{\\Phi}_{A,0}^2} + \\sum_{i=0}^{n-1} \\frac{\\widehat{\\mathrm{Var}}(\\hat{p}_i)}{\\hat{p}_i^2}} $$\n此表达式为最终答案。", "answer": "$$ \\boxed{\\sqrt{\\frac{\\widehat{\\mathrm{Var}}(\\hat{\\Phi}_{A,0})}{\\hat{\\Phi}_{A,0}^2} + \\sum_{i=0}^{n-1} \\frac{\\widehat{\\mathrm{Var}}(\\hat{p}_i)}{\\hat{p}_i^2}}} $$", "id": "2645555"}, {"introduction": "FFS 模拟虽然功能强大，但计算成本可能很高，因此优化资源利用对于实际应用至关重要。这个高级练习挑战你设计一个自适应取样方案，该方案能智能地将模拟试验分配给最需要它们的界面。通过解决一个在固定计算预算下最小化速率估计总方差的优化问题，你将推导出一个能显著提高 FFS 方法效率的反馈控制律 [@problem_id:2645571]。", "problem": "您正在设计一个用于前向通量采样（Forward Flux Sampling, FFS）的自适应采样器，以估计反应网络中从集合$A$到集合$B$的稀有事件率。该速率的FFS估计量是估计的初始通量与跨越$M$个界面的逐级条件概率的乘积，即$\\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=1}^{M} \\hat{p}_i$，其中$\\hat{p}_i$是使用在界面$i$处的$n_i$次独立伯努利试验来估计的。为了决定在何处增加试验次数，请关注界面$\\{1,\\dots,M\\}$的贡献，并在该控制步骤中将初始通量项视为固定值。\n\n您的目标是形式化一个反馈控制律，该控制律在对$\\ln \\hat{k}_{AB}$的方差有较高估计贡献的界面上增加试验次数，并推导出一个遵循成本预算的显式更新规则。您必须基于以下基础进行推导：\n\n- FFS分解 $\\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=1}^{M} \\hat{p}_i$。\n- 对于具有$n_i$次试验和真实成功概率$p_i \\in (0,1)$的二项式估计量$\\hat{p}_i$，其方差为 $\\mathrm{Var}(\\hat{p}_i) = \\dfrac{p_i (1 - p_i)}{n_i}$。\n- Delta方法：对于一个平滑函数$g$，在大$n_i$的情况下，$\\mathrm{Var}(g(\\hat{p}_i)) \\approx \\left(g'(p_i)\\right)^2 \\mathrm{Var}(\\hat{p}_i)$。\n- 为了控制设计的目的，在各界面间采用独立性近似。\n\n任务：\n\n1) 从$\\hat{k}_{AB}$的分解和Delta方法出发，推导界面$i$对$\\ln \\hat{k}_{AB}$方差的贡献的近似表达式（用$n_i$和$p_i$表示），并由此得到$\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$跨界面的可加近似。\n\n2) 假设在界面$i$执行一次试验产生一个正成本$c_i$，您当前的分配为$(n_1,\\dots,n_M)$，当前成本预算为$B = \\sum_{i=1}^{M} c_i n_i$。您收到了一个额外的待分配预算$B^{+} > 0$。建立并求解优化问题，在新的分配$(n_1^{\\star},\\dots,n_M^{\\star})$上最小化近似的$\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$，同时满足线性预算约束$\\sum_{i=1}^{M} c_i n_i^{\\star} = B + B^{+}$。将$n_i^{\\star}$用界面概率$p_i$、成本$c_i$和总预算$B + B^{+}$显式地表达出来。\n\n3) 提出一个反馈控制更新，它使用一个步长$\\beta \\in (0,1]$将当前分配与最优目标相混合：\n$$\nn_i^{\\mathrm{new}} \\;=\\; (1 - \\beta)\\, n_i \\;+\\; \\beta\\, n_i^{\\star}.\n$$\n使用您在任务2中得到的$n_i^{\\star}$表达式，提供$n_i^{\\mathrm{new}}$关于$p_i$、$c_i$、$n_i$、$B$、$B^{+}$和$\\beta$的显式闭式解。解释为什么此更新会优先增加那些对$\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$有较高估计贡献的界面上的试验次数。\n\n4) 实现一个程序，为下面描述的每个测试用例计算$n_i^{\\mathrm{new}}$。在每个用例中，为了模拟和测试的目的，您可以假设控制律中使用的估计成功概率$\\hat{p}_i$等于给定的$p_i$。该程序必须：\n\n- 对每个用例，接收向量$(p_1,\\dots,p_M)$、$(c_1,\\dots,c_M)$、$(n_1,\\dots,n_M)$以及标量$B^{+}$和$\\beta$作为输入。\n- 计算$B = \\sum_{i=1}^{M} c_i n_i$和$B_{\\mathrm{tot}} = B + B^{+}$。\n- 使用$p_i$和$c_i$计算任务2中的目标$n_i^{\\star}$。\n- 计算任务3中的$n_i^{\\mathrm{new}}$。\n- 为每个测试用例返回向量$(n_1^{\\mathrm{new}},\\dots,n_M^{\\mathrm{new}})$。\n\n数值输出必须四舍五入到恰好$6$位小数，并视为无单位的实数。\n\n测试套件：\n\n- 用例1：$M = 3$, $p = (0.2, 0.5, 0.8)$, $c = (1.0, 1.0, 1.0)$, $n = (100.0, 100.0, 100.0)$, $B^{+} = 90.0$, $\\beta = 1.0$。\n- 用例2：$M = 3$, $p = (0.05, 0.4, 0.7)$, $c = (1.0, 2.0, 1.0)$, $n = (10.0, 10.0, 10.0)$, $B^{+} = 90.0$, $\\beta = 1.0$。\n- 用例3：$M = 4$, $p = (0.9, 0.95, 0.6, 0.3)$, $c = (1.0, 1.0, 1.0, 1.0)$, $n = (50.0, 50.0, 50.0, 50.0)$, $B^{+} = 40.0$, $\\beta = 0.5$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的各用例结果列表，每个用例结果本身又是逗号分隔的浮点数列表，全部包含在方括号中。具体来说，要求的格式是：\n$$\n\\text{print: } [[n_{1,1}^{\\mathrm{new}},\\dots,n_{1,M_1}^{\\mathrm{new}}],[n_{2,1}^{\\mathrm{new}},\\dots,n_{2,M_2}^{\\mathrm{new}}],[n_{3,1}^{\\mathrm{new}},\\dots,n_{3,M_3}^{\\mathrm{new}}]]\n$$\n不含任何额外的空格或文本。例如，两个用例的有效输出形式为`[[1.000000,2.000000],[3.000000,4.000000]]`。", "solution": "我们从前向通量采样（FFS）分解 $\\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=1}^{M} \\hat{p}_i$ 开始。取自然对数可得\n$$\n\\ln \\hat{k}_{AB} \\;=\\; \\ln \\hat{\\Phi}_{A,0} \\;+\\; \\sum_{i=1}^{M} \\ln \\hat{p}_i.\n$$\n在初始通量和界面概率估计量之间，以及各界面估计量之间相互独立的近似下，$\\ln \\hat{k}_{AB}$的方差近似地具有可加性：\n$$\n\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right) \\;\\approx\\; \\mathrm{Var}\\!\\left(\\ln \\hat{\\Phi}_{A,0}\\right) \\;+\\; \\sum_{i=1}^{M} \\mathrm{Var}\\!\\left(\\ln \\hat{p}_i\\right).\n$$\n为了控制界面上的试验次数，我们将$\\mathrm{Var}\\!\\left(\\ln \\hat{\\Phi}_{A,0}\\right)$视为固定值，并专注于跨界面的总和。\n\n任务1：对于每个界面$i$，估计量$\\hat{p}_i$是一个具有$n_i$次试验和成功概率$p_i \\in (0,1)$的二项比例。因此\n$$\n\\mathrm{Var}(\\hat{p}_i) \\;=\\; \\frac{p_i (1 - p_i)}{n_i}.\n$$\n应用Delta方法，设$g(x) = \\ln x$，其导数为$g'(x) = \\dfrac{1}{x}$，\n$$\n\\mathrm{Var}\\!\\left(\\ln \\hat{p}_i\\right) \\;\\approx\\; \\left(g'(p_i)\\right)^2 \\mathrm{Var}(\\hat{p}_i) \\;=\\; \\frac{1}{p_i^2} \\cdot \\frac{p_i (1 - p_i)}{n_i} \\;=\\; \\frac{1 - p_i}{n_i p_i}.\n$$\n因此，各界面对总方差的贡献是可加的，形式如下\n$$\n\\sum_{i=1}^{M} \\mathrm{Var}\\!\\left(\\ln \\hat{p}_i\\right) \\;\\approx\\; \\sum_{i=1}^{M} \\frac{1 - p_i}{n_i p_i}.\n$$\n我们将来自界面$i$的贡献确定为\n$$\nv_i(n_i, p_i) \\;=\\; \\frac{1 - p_i}{n_i p_i} \\;=\\; \\frac{a_i}{n_i}, \\quad \\text{其中 } a_i \\;=\\; \\frac{1 - p_i}{p_i}.\n$$\n\n任务2：假设在界面$i$的一次试验成本为$c_i > 0$，当前分配为$(n_1,\\dots,n_M)$，预算为$B = \\sum_{i=1}^{M} c_i n_i$，并且我们获得了一个额外的预算$B^{+} > 0$。设新预算为\n$$\nB_{\\mathrm{tot}} \\;=\\; B \\;+\\; B^{+} \\;=\\; \\sum_{i=1}^{M} c_i n_i^{\\star}.\n$$\n我们寻求$(n_1^{\\star},\\dots,n_M^{\\star})$以最小化近似方差\n$$\n\\min_{n_1^{\\star},\\dots,n_M^{\\star} > 0} \\;\\; \\sum_{i=1}^{M} \\frac{a_i}{n_i^{\\star}} \\quad \\text{约束条件为} \\quad \\sum_{i=1}^{M} c_i n_i^{\\star} \\;=\\; B_{\\mathrm{tot}}.\n$$\n构造拉格朗日函数\n$$\n\\mathcal{L}(\\{n_i^{\\star}\\}, \\lambda) \\;=\\; \\sum_{i=1}^{M} \\frac{a_i}{n_i^{\\star}} \\;+\\; \\lambda \\left(\\sum_{i=1}^{M} c_i n_i^{\\star} - B_{\\mathrm{tot}}\\right).\n$$\n对$n_i^{\\star}$求驻点可得\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial n_i^{\\star}} \\;=\\; - \\frac{a_i}{(n_i^{\\star})^2} \\;+\\; \\lambda c_i \\;=\\; 0\n\\;\\;\\Rightarrow\\;\\; n_i^{\\star} \\;=\\; \\sqrt{\\frac{a_i}{\\lambda c_i}}.\n$$\n代入约束条件可得\n$$\n\\sum_{i=1}^{M} c_i n_i^{\\star} \\;=\\; \\sum_{i=1}^{M} c_i \\sqrt{\\frac{a_i}{\\lambda c_i}} \\;=\\; \\frac{1}{\\sqrt{\\lambda}} \\sum_{i=1}^{M} \\sqrt{a_i c_i} \\;=\\; B_{\\mathrm{tot}},\n$$\n所以\n$$\n\\sqrt{\\lambda} \\;=\\; \\frac{1}{B_{\\mathrm{tot}}} \\sum_{j=1}^{M} \\sqrt{a_j c_j}.\n$$\n代回可得，\n$$\nn_i^{\\star} \\;=\\; \\frac{B_{\\mathrm{tot}}}{\\sum_{j=1}^{M} \\sqrt{a_j c_j}} \\;\\sqrt{\\frac{a_i}{c_i}}\n\\;=\\; \\frac{B + B^{+}}{\\sum_{j=1}^{M} \\sqrt{\\dfrac{1 - p_j}{p_j} c_j}} \\;\\sqrt{\\frac{1 - p_i}{p_i c_i}}.\n$$\n这种分配在$\\dfrac{1 - p_i}{p_i}$较大（即$p_i$较小）以及$c_i$较小的地方增加$n_i^{\\star}$，这反映了方差减小与成本之间的最优权衡。\n\n任务3：一个自然的反馈控制律使用步长$\\beta \\in (0,1]$将当前分配与目标分配相混合：\n$$\nn_i^{\\mathrm{new}} \\;=\\; (1 - \\beta)\\, n_i \\;+\\; \\beta\\, n_i^{\\star},\n$$\n即，\n$\nn_i^{\\mathrm{new}} \\;=\\; (1 - \\beta)\\, n_i \\;+\\; \\beta \\;\\dfrac{B + B^{+}}{\\sum_{j=1}^{M} \\sqrt{\\dfrac{1 - p_j}{p_j} c_j}} \\;\\sqrt{\\dfrac{1 - p_i}{p_i c_i}}.\n$\n因为$n_i^{\\star}$与$\\sqrt{\\dfrac{1 - p_i}{p_i c_i}}$成比例，所以对$\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$（由$a_i / n_i$量化）有较高估计贡献的界面会获得更多的分配。平方根形式源于线性预算约束下的凸优化问题，这等效于一个具有边际效益递减的连续背包问题。此更新优先增加那些具有大$a_i$和小$c_i$的界面上的$n_i$，而步长$\\beta$则控制了响应性与稳定性之间的平衡。\n\n实现算法：\n\n- 给定$(p_i)$、$(c_i)$、$(n_i)$，计算$B = \\sum_{i=1}^{M} c_i n_i$和$B_{\\mathrm{tot}} = B + B^{+}$。\n- 对所有$i$计算$a_i = \\dfrac{1 - p_i}{p_i}$以及$S = \\sum_{j=1}^{M} \\sqrt{a_j c_j}$。\n- 如果$S > 0$，则设置$n_i^{\\star} = \\dfrac{B_{\\mathrm{tot}}}{S} \\sqrt{\\dfrac{a_i}{c_i}}$；否则，作为一个退化情况的备用方案（在所提供的测试中不会发生），将$B^{+}$均匀地分配到计数中：$\\Delta n_i = \\dfrac{B^{+}}{\\sum_{j=1}^{M} c_j}$ 并且 $n_i^{\\star} = n_i + \\Delta n_i$。\n- 更新$n_i^{\\mathrm{new}} = (1 - \\beta) n_i + \\beta n_i^{\\star}$，然后四舍五入到$6$位小数。\n\n所要求的程序将此过程应用于三个指定的测试用例，并以指定的单行格式输出向量$(n_i^{\\mathrm{new}})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_updated_counts(p, c, n, delta_budget, beta):\n    p = np.asarray(p, dtype=float)\n    c = np.asarray(c, dtype=float)\n    n = np.asarray(n, dtype=float)\n\n    # Current and total budgets\n    B_old = float(np.dot(c, n))\n    B_total = B_old + float(delta_budget)\n\n    # a_i = (1 - p_i)/p_i\n    # Ensure p in (0,1) to avoid division by zero; assume inputs valid per problem statement.\n    a = (1.0 - p) / p\n\n    # S = sum sqrt(a_i * c_i)\n    # Interfaces with p_i == 1 have a_i == 0 and contribute zero to S.\n    ac = a * c\n    # Guard against tiny negative due to roundoff\n    ac = np.where(ac < 0.0, 0.0, ac)\n    sqrt_ac = np.sqrt(ac)\n    S = float(np.sum(sqrt_ac))\n\n    if S > 0.0:\n        # n_i^* = (B_total / S) * sqrt(a_i / c_i)\n        # Note: sqrt(a_i / c_i) = sqrt(a_i * 1/c_i)\n        # Handle c_i > 0 as per problem statement.\n        sqrt_a_over_c = np.sqrt(a / c)\n        n_star = (B_total / S) * sqrt_a_over_c\n    else:\n        # Degenerate fallback (not triggered by provided tests):\n        # Distribute delta_budget evenly in counts so that sum c_i * Δn_i = delta_budget.\n        denom = float(np.sum(c))\n        if denom == 0.0:\n            n_star = n.copy()\n        else:\n            delta_n_each = delta_budget / denom\n            n_star = n + delta_n_each\n\n    # Feedback update\n    n_new = (1.0 - beta) * n + beta * n_star\n\n    # Round to 6 decimals as required\n    n_new = np.round(n_new.astype(float), 6)\n\n    return n_new.tolist()\n\ndef format_list_no_spaces(list_of_lists):\n    # Custom formatter to avoid spaces and enforce 6-decimal floats\n    # Assumes list_of_lists is a list of lists of floats\n    outer_parts = []\n    for inner in list_of_lists:\n        inner_parts = []\n        for x in inner:\n            inner_parts.append(f\"{float(x):.6f}\")\n        outer_parts.append(\"[\" + \",\".join(inner_parts) + \"]\")\n    return \"[\" + \",\".join(outer_parts) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: M=3, p=(0.2,0.5,0.8), c=(1.0,1.0,1.0), n=(100.0,100.0,100.0), B+=90.0, beta=1.0\n    case1 = {\n        \"p\": [0.2, 0.5, 0.8],\n        \"c\": [1.0, 1.0, 1.0],\n        \"n\": [100.0, 100.0, 100.0],\n        \"delta_budget\": 90.0,\n        \"beta\": 1.0\n    }\n    # Case 2: M=3, p=(0.05,0.4,0.7), c=(1.0,2.0,1.0), n=(10.0,10.0,10.0), B+=90.0, beta=1.0\n    case2 = {\n        \"p\": [0.05, 0.4, 0.7],\n        \"c\": [1.0, 2.0, 1.0],\n        \"n\": [10.0, 10.0, 10.0],\n        \"delta_budget\": 90.0,\n        \"beta\": 1.0\n    }\n    # Case 3: M=4, p=(0.9,0.95,0.6,0.3), c=(1.0,1.0,1.0,1.0), n=(50.0,50.0,50.0,50.0), B+=40.0, beta=0.5\n    case3 = {\n        \"p\": [0.9, 0.95, 0.6, 0.3],\n        \"c\": [1.0, 1.0, 1.0, 1.0],\n        \"n\": [50.0, 50.0, 50.0, 50.0],\n        \"delta_budget\": 40.0,\n        \"beta\": 0.5\n    }\n\n    test_cases = [case1, case2, case3]\n\n    results = []\n    for case in test_cases:\n        updated = compute_updated_counts(\n            p=case[\"p\"],\n            c=case[\"c\"],\n            n=case[\"n\"],\n            delta_budget=case[\"delta_budget\"],\n            beta=case[\"beta\"]\n        )\n        results.append(updated)\n\n    # Final print statement in the exact required format: no spaces\n    print(format_list_no_spaces(results))\n\nsolve()\n```", "id": "2645571"}]}