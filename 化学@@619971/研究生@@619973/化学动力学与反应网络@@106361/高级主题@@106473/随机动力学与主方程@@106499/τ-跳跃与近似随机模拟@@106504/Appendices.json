{"hands_on_practices": [{"introduction": "τ-leaping 方法的核心在于“跳跃条件”（leap condition），它确保了在每一步时间 $τ$ 内反应倾向性函数的变化足够小。Cao-Gillespie-Petzold (CGP) 准则提供了一种严谨的方式来选择 $τ$，以平衡计算效率和模拟精度。本练习将引导你直接应用这一关键准则，通过计算一个可逆异构化反应的最大允许步长，从而掌握 τ-leaping 算法的核心实现细节。[@problem_id:2695002]", "problem": "考虑一个由可逆异构化反应 $A \\xrightleftharpoons[k_2]{k_1} B$ 组成的混合均匀的等温反应网络。该系统在化学主方程 (CME) 框架下被建模为连续时间马尔可夫链，分子数为 $(X_A,X_B)$。倾向函数遵循单分子反应的基元质量作用动力学。对于 $A \\to B$ 和 $B \\to A$，化学计量变化向量分别为 $(-1,+1)$ 和 $(+1,-1)$。在当前状态下，分子数为 $(x_A,x_B)=(400,100)$。速率常数为 $k_1=0.08\\,\\mathrm{s}^{-1}$ 和 $k_2=0.12\\,\\mathrm{s}^{-1}$。您将使用泊松 $\\tau$-跳跃法，并遵循 Cao–Gillespie–Petzold (CGP) 准则选择跳跃步长 $\\tau$ 以对物种强制施加跳跃条件，其中物种相关因子 $g_i$ 适用于单分子反应。取用户指定的容差为 $\\epsilon=0.03$。\n\n从 CME 框架下的倾向函数定义以及 $\\tau$-跳跃法中反应激发次数的泊松特征出发，推导在每个物种上强制施加 CGP 跳跃条件所需的表达式，并计算在给定状态和参数下的最大允许步长 $\\tau$。您的最终答案以秒为单位表示，并四舍五入至四位有效数字。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 反应网络：可逆异构化反应 $A \\xrightleftharpoons[k_2]{k_1} B$。\n- 模型：化学主方程 (CME) 框架下的连续时间马尔可夫链。\n- 状态变量：分子数 $(X_A, X_B)$。\n- 倾向函数：单分子反应的基元质量作用动力学。\n- 化学计量变化向量：正向反应 $A \\to B$ 为 $\\nu_1 = (-1, +1)$，逆向反应 $B \\to A$ 为 $\\nu_2 = (+1, -1)$。\n- 当前状态：$(x_A, x_B) = (400, 100)$ 分子。\n- 速率常数：$k_1 = 0.08\\,\\mathrm{s}^{-1}$ 和 $k_2 = 0.12\\,\\mathrm{s}^{-1}$。\n- 算法：泊松 $\\tau$-跳跃法。\n- 步长选择：Cao–Gillespie–Petzold (CGP) 准则。\n- 跳跃条件强制执行：对物种施加，使用适用于单分子反应的物种相关因子 $g_i$。\n- 容差：$\\epsilon = 0.03$。\n- 目标：推导表达式并计算最大允许步长 $\\tau$。\n- 最终答案格式：四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，是 $\\tau$-跳跃算法在随机化学动力学中的一个标准应用。该问题是良定的，因为计算唯一解所需的所有必要参数、初始条件和方法论约束均已提供。语言客观、精确。该问题没有违反任何基本原理，不基于错误的假设，也不是不完整或矛盾的。在其指定的领域内，这是一个可形式化且相关的问题。因此，该问题被认定为有效。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解答。\n\n**求解推导**\n\n目标是使用 Cao-Gillespie-Petzold (CGP) 准则，为给定反应系统的泊松 $\\tau$-跳跃模拟确定最大允许时间步长 $\\tau$。\n\n该系统包含两个物种，$A$ 和 $B$，以及两个单分子反应：\n$R_1: A \\xrightarrow{k_1} B$\n$R_2: B \\xrightarrow{k_2} A$\n\n系统的状态由分子布居数向量 $\\mathbf{x} = (x_A, x_B)$ 描述。根据质量作用动力学，这两个反应的倾向函数为：\n$a_1(\\mathbf{x}) = k_1 x_A$\n$a_2(\\mathbf{x}) = k_2 x_B$\n\n在给定状态 $\\mathbf{x} = (400, 100)$ 和速率常数 $k_1=0.08\\,\\mathrm{s}^{-1}$ 及 $k_2=0.12\\,\\mathrm{s}^{-1}$ 的条件下，倾向函数为：\n$a_1 = (0.08\\,\\mathrm{s}^{-1}) \\times 400 = 32\\,\\mathrm{s}^{-1}$\n$a_2 = (0.12\\,\\mathrm{s}^{-1}) \\times 100 = 12\\,\\mathrm{s}^{-1}$\n\n$\\tau$-跳跃算法通过假设倾向函数在时间间隔 $\\tau$ 内保持不变来近似系统的演化。在此区间内，每个反应 $j$ 的发生次数 $K_j$ 是一个泊松随机变量 $K_j \\sim \\mathcal{P}(a_j \\tau)$。选择 $\\tau$ 的 CGP 准则确保了在跳跃期间任何物种布居数的期望变化不会显著改变系统的倾向函数。这是通过限制每个物种布居数的相对变化来强制执行的。\n\n最大允许步长 $\\tau$ 是为每个物种 $i$ 计算出的步长中的最小值：\n$$ \\tau = \\min_{i \\in \\{A, B\\}} \\tau_i $$\n每个物种 $i$ 的步长 $\\tau_i$ 由限制布居数变化的均值和方差所导出的公式确定：\n$$ \\tau_i = \\min\\left( \\frac{N_{C,i}}{|\\mu_i(\\mathbf{x})|}, \\frac{N_{C,i}^2}{\\sigma_i^2(\\mathbf{x})} \\right) $$\n这里，$\\mu_i(\\mathbf{x})$ 是物种 $i$ 的瞬时期望变化率（漂移），而 $\\sigma_i^2(\\mathbf{x})$ 是变化率的瞬时方差。它们的定义如下：\n$$ \\mu_i(\\mathbf{x}) = \\sum_{j=1}^{M} \\nu_{ij} a_j(\\mathbf{x}) $$\n$$ \\sigma_i^2(\\mathbf{x}) = \\sum_{j=1}^{M} \\nu_{ij}^2 a_j(\\mathbf{x}) $$\n其中 $\\nu_{ij}$ 是物种 $i$ 在反应 $j$ 中的化学计量系数。\n\n$N_{C,i}$ 项是物种 $i$ 的控制界限，定义为：\n$$ N_{C,i} = \\max\\left(\\frac{\\epsilon}{g_i} x_i, 1\\right) $$\n因子 $g_i$ 是网络中任何反应相对于物种 $i$ 的最高反应级数。对于该系统，物种 $A$ 是一级反应 ($R_1$) 的反应物，物种 $B$ 是一级反应 ($R_2$) 的反应物。因此，$g_A = 1$ 且 $g_B = 1$。\n\n对于物种 $(A, B)$，化学计量向量为 $\\nu_1 = (-1, 1)$ 和 $\\nu_2 = (1, -1)$。我们来计算每个物种的 $\\mu_i$ 和 $\\sigma_i^2$。\n\n对于物种 A：\n$\\mu_A(\\mathbf{x}) = \\nu_{A1} a_1 + \\nu_{A2} a_2 = (-1)(32) + (1)(12) = -20\\,\\mathrm{s}^{-1}$\n$\\sigma_A^2(\\mathbf{x}) = \\nu_{A1}^2 a_1 + \\nu_{A2}^2 a_2 = (-1)^2(32) + (1)^2(12) = 32 + 12 = 44\\,\\mathrm{s}^{-1}$\n\n对于物种 B：\n$\\mu_B(\\mathbf{x}) = \\nu_{B1} a_1 + \\nu_{B2} a_2 = (1)(32) + (-1)(12) = 20\\,\\mathrm{s}^{-1}$\n$\\sigma_B^2(\\mathbf{x}) = \\nu_{B1}^2 a_1 + \\nu_{B2}^2 a_2 = (1)^2(32) + (-1)^2(12) = 32 + 12 = 44\\,\\mathrm{s}^{-1}$\n\n接下来，我们使用 $\\epsilon = 0.03$ 计算控制界限 $N_{C,i}$。\n\n对于物种 A：\n$N_{C,A} = \\max\\left(\\frac{0.03}{1} \\times 400, 1\\right) = \\max(12, 1) = 12$\n\n对于物种 B：\n$N_{C,B} = \\max\\left(\\frac{0.03}{1} \\times 100, 1\\right) = \\max(3, 1) = 3$\n\n现在，我们为每个物种计算候选步长 $\\tau_i$。\n\n对于物种 A：\n$\\tau_A = \\min\\left( \\frac{N_{C,A}}{|\\mu_A(\\mathbf{x})|}, \\frac{N_{C,A}^2}{\\sigma_A^2(\\mathbf{x})} \\right) = \\min\\left( \\frac{12}{20}, \\frac{12^2}{44} \\right) = \\min\\left( 0.6, \\frac{144}{44} \\right)$\n$\\frac{144}{44} = \\frac{36}{11} \\approx 3.2727...$\n$\\tau_A = \\min(0.6, 3.2727...) = 0.6\\,\\mathrm{s}$\n\n对于物种 B：\n$\\tau_B = \\min\\left( \\frac{N_{C,B}}{|\\mu_B(\\mathbf{x})|}, \\frac{N_{C,B}^2}{\\sigma_B^2(\\mathbf{x})} \\right) = \\min\\left( \\frac{3}{20}, \\frac{3^2}{44} \\right) = \\min\\left( 0.15, \\frac{9}{44} \\right)$\n$\\frac{9}{44} \\approx 0.2045...$\n$\\tau_B = \\min(0.15, 0.2045...) = 0.15\\,\\mathrm{s}$\n\n最大允许跳跃步长 $\\tau$ 是各物种步长的最小值：\n$\\tau = \\min(\\tau_A, \\tau_B) = \\min(0.6\\,\\mathrm{s}, 0.15\\,\\mathrm{s}) = 0.15\\,\\mathrm{s}$\n\n问题要求将结果四舍五入到四位有效数字。精确值为 $0.15$。表示为四位有效数字即为 $0.1500$。", "answer": "$$\\boxed{0.1500}$$", "id": "2695002"}, {"introduction": "选择一个合适的 $τ$ 至关重要，但即使使用了 CGP 这样的高级准则，过大的步长仍可能引发数值不稳定的问题，导致模拟结果出现非物理性的振荡。本练习通过分析一个简单的单分子衰变过程，来深入探讨显式 τ-leaping 方法的内在局限性。通过推导其离散时间方差的动态，你将揭示为何过大的 $τ$ 会破坏模拟的定性行为，并确定保证模拟稳定性的步长上限。[@problem_id:2694968]", "problem": "考虑一个单物种、单分子衰变反应网络，其反应为 $R_{1}: X \\to \\varnothing$，倾向函数为 $a_{1}(x)=k\\,x$，其中 $k>0$ 是一个常数速率，$x \\in \\mathbb{N}$ 是当前的分子数。系统确定性地初始化为 $X(0)=x_0 \\in \\mathbb{N}$。您将比较由精确的化学主方程 (CME) 产生的方差动态与由显式 $\\tau$-跳跃近似产生的方差动态，然后确定一个能防止离散时间方差轨迹发生振荡的步长约束。\n\n仅使用单分子衰变的基本概率性质、每个分子存活的稀疏化解释、显式 $\\tau$-跳跃的定义，以及全期望定律和全方差定律（不使用任何其他特定公式），完成以下任务。\n\n- 推导出精确的 CME 方差 $\\operatorname{Var}_{\\mathrm{CME}}[X(t)]$，作为 $t\\ge 0$、$k$ 和 $x_{0}$ 的函数。\n- 将具有固定步长 $\\tau>0$ 的显式 $\\tau$-跳跃建模为 $X_{n+1}=X_{n}-K_{n}$，其中，在以 $X_{n}$ 为条件的情况下，增量 $K_{n}$ 是一个参数为 $k\\,\\tau\\,X_{n}$ 的泊松随机变量。从定义出发，推导出离散时间方差 $\\operatorname{Var}[X_{n}]$ 在 $t_{n}=n\\,\\tau$ 时的闭式表达式，用 $n\\in\\mathbb{N}$、$k$、$\\tau$ 和 $x_{0}$ 表示。\n- 通过分析得到的离散时间方差，确定最大步长 $\\tau_{\\max}$，使得对于任何满足 $0<\\tau<\\tau_{\\max}$ 的 $\\tau$，显式 $\\tau$-跳跃的方差轨迹不会表现出步间振荡，并且在最多一个峰值后，当 $n\\to\\infty$ 时衰减到 $0$。\n\n以 $k$ 的闭式表达式给出 $\\tau_{\\max}$ 的最终答案。如果 $k$ 的单位是 $\\mathrm{s}^{-1}$，则以秒为单位表示 $\\tau_{\\max}$。在最终的方框表达式中不要包含单位。", "solution": "我们考虑单分子衰变反应 $R_{1}: X \\to \\varnothing$，其倾向函数为 $a_{1}(x)=k\\,x$。初始条件为 $X(0)=x_0 \\in \\mathbb{N}$。\n\n首先，我们分析精确的化学主方程 (CME) 解。在速率为 $k$ 的纯衰变过程中，每个独立的分子存活到时间 $t$ 的概率为 $p(t)=\\exp(-k t)$。这源于在 CME 框架下，衰变等待时间服从指数分布，且不同分子间的衰变事件是相互独立的。因此，$X(t)$ 可以表示为 $x_{0}$ 个独立的伯努利随机变量之和，每个变量表示在时间 $t$ 存活，其成功概率为 $p(t)=\\exp(-k t)$。因此，\n$$\nX(t)\\sim \\mathrm{Binomial}\\!\\left(x_{0},\\,\\exp(-k t)\\right).\n$$\n由此可得，在化学主方程 (CME) 下，精确的均值和方差为\n$$\n\\mathbb{E}[X(t)]=x_{0}\\,\\exp(-k t),\n\\qquad\n\\operatorname{Var}_{\\mathrm{CME}}[X(t)]=x_{0}\\,\\exp(-k t)\\,\\bigl(1-\\exp(-k t)\\bigr).\n$$\n\n接下来，我们推导显式 $\\tau$-跳跃下的方差动态。令 $t_{n}=n\\,\\tau$ 且 $X_{n}=X(t_{n})$。在显式 $\\tau$-跳跃中，在区间 $[t_{n},t_{n+1})$ 内，倾向函数被冻结在其于 $t_{n}$ 处的值，因此反应发生次数 $K_{n}$ 被条件地建模为\n$$\nK_{n}\\,|\\,X_{n}\\;\\sim\\;\\mathrm{Poisson}\\!\\bigl(k\\,\\tau\\,X_{n}\\bigr).\n$$\n状态更新为\n$$\nX_{n+1}=X_{n}-K_{n}.\n$$\n我们使用全期望定律计算均值的递推关系：\n$$\n\\mathbb{E}[X_{n+1}\\,|\\,X_{n}]=X_{n}-\\mathbb{E}[K_{n}\\,|\\,X_{n}]=X_{n}-k\\,\\tau\\,X_{n}=(1-k\\,\\tau)\\,X_{n}.\n$$\n取期望可得\n$$\nm_{n+1}=\\mathbb{E}[X_{n+1}]=(1-k\\,\\tau)\\,\\mathbb{E}[X_{n}]=(1-k\\,\\tau)\\,m_{n},\n$$\n其中 $m_{0}=x_{0}$。因此，\n$$\nm_{n}=x_{0}\\,(1-k\\,\\tau)^{n}.\n$$\n\n现在我们通过全方差定律推导方差的递推关系：\n$$\n\\operatorname{Var}[X_{n+1}]=\\mathbb{E}\\!\\left[\\operatorname{Var}(X_{n+1}\\,|\\,X_{n})\\right]+\\operatorname{Var}\\!\\left(\\mathbb{E}[X_{n+1}\\,|\\,X_{n}]\\right).\n$$\n给定 $X_{n}$，我们有 $\\operatorname{Var}(X_{n+1}\\,|\\,X_{n})=\\operatorname{Var}(K_{n}\\,|\\,X_{n})=k\\,\\tau\\,X_{n}$ 且 $\\mathbb{E}[X_{n+1}\\,|\\,X_{n}]=(1-k\\,\\tau)\\,X_{n}$。因此，\n$$\nv_{n+1}=\\operatorname{Var}[X_{n+1}]=\\mathbb{E}[k\\,\\tau\\,X_{n}]+\\operatorname{Var}\\!\\bigl((1-k\\,\\tau)\\,X_{n}\\bigr)\n= k\\,\\tau\\,m_{n}+(1-k\\,\\tau)^{2}\\,v_{n},\n$$\n其中 $v_{0}=\\operatorname{Var}[X_{0}]=0$。这是一个具有已知均值 $m_{n}$ 的一阶线性非齐次递推关系。\n\n令 $r:=1-k\\,\\tau$。则 $m_{n}=x_{0}\\,r^{n}$ 且\n$$\nv_{n+1}=r^{2}\\,v_{n}+k\\,\\tau\\,x_{0}\\,r^{n}.\n$$\n我们用待定系数法求解此递推关系。寻求一个形式为 $v_{n}^{(p)}=B\\,r^{n}$ 的特解。代入得，\n$$\nB\\,r^{n+1}=r^{2}\\,(B\\,r^{n})+k\\,\\tau\\,x_{0}\\,r^{n}\\;\\;\\Longrightarrow\\;\\;B\\,r=B\\,r^{2}+k\\,\\tau\\,x_{0}.\n$$\n整理得，\n$$\nB\\,(r-r^{2})=k\\,\\tau\\,x_{0}\\;\\;\\Longrightarrow\\;\\;B\\,r\\,(1-r)=k\\,\\tau\\,x_{0}.\n$$\n使用 $1-r=1-(1-k\\,\\tau)=k\\,\\tau$，我们得到 $B\\,r\\,k\\,\\tau=k\\,\\tau\\,x_{0}$，因此 $B\\,r=x_{0}$ 且 $B=x_{0}/r$。因此，一个特解是\n$$\nv_{n}^{(p)}=\\frac{x_{0}}{r}\\,r^{n}=x_{0}\\,r^{n-1}.\n$$\n齐次解为 $v_{n}^{(h)}=A\\,r^{2n}$，其中 $A$ 是一个常数。施加 $v_{0}=0$ 的条件可得\n$$\n0=v_{0}=A\\,r^{0}+x_{0}\\,r^{-1}\\;\\;\\Longrightarrow\\;\\;A=-x_{0}\\,r^{-1}.\n$$\n因此，\n$$\nv_{n}=v_{n}^{(h)}+v_{n}^{(p)}=-x_{0}\\,r^{-1}\\,r^{2n}+x_{0}\\,r^{n-1}\n= x_{0}\\,r^{n-1}\\,\\bigl(1-r^{n}\\bigr).\n$$\n\n这个闭式表达式显示了显式 $\\tau$-跳跃如何近似 CME 方差。为了与精确的 CME 结果进行比较，回想一下 $\\operatorname{Var}_{\\mathrm{CME}}[X(t)]=x_{0}\\,\\exp(-k t)\\,\\bigl(1-\\exp(-k t)\\bigr)$。设 $t_{n}=n\\,\\tau$ 且 $r=1-k\\,\\tau$，我们观察到逐点收敛\n$$\n\\lim_{\\tau\\to 0}\\,r^{n}=\\lim_{\\tau\\to 0}(1-k\\,\\tau)^{t_{n}/\\tau}=\\exp(-k t_{n}),\n\\qquad\n\\lim_{\\tau\\to 0}\\,r^{n-1}=\\exp(-k t_{n}),\n$$\n因此\n$$\n\\lim_{\\tau\\to 0} v_{n}=x_{0}\\,\\exp(-k t_{n})\\,\\bigl(1-\\exp(-k t_{n})\\bigr)=\\operatorname{Var}_{\\mathrm{CME}}[X(t_{n})],\n$$\n如预期。\n\n我们现在确定一个 $\\tau$ 的范围，以保证离散轨迹 $\\{v_{n}\\}_{n\\ge 0}$ 的方差非振荡衰减。显式因子 $r=1-k\\,\\tau$ 控制着动态行为：\n\n- 如果 $|r|<1$（即 $0<k\\,\\tau<2$），则当 $n\\to\\infty$ 时 $r^{n}\\to 0$，这确保了一阶矩的稳定性（衰减到 $0$），并且根据上述公式，也确保了方差的稳定性。\n- 如果 $r<0$（即 $k\\,\\tau>1$），则 $r^{n}$ 的符号随 $n$ 交替变化，这会在离散动态中引发步间振荡。特别地，因子 $r^{n-1}\\,(1-r^{n})$ 的符号和大小会交替变化，导致振荡行为，并且对于足够大的 $\\tau$，线性化矩递推甚至会预测出 $v_{n}$ 的瞬时负值，这标志着显式泊松 $\\tau$-跳跃对于此衰变过程的定性保真度失效。\n- 如果 $0<r<1$（即 $0<k\\,\\tau<1$），则 $r^{n}$ 是非负的，并且严格递减至 $0$。表达式 $v_{n}=x_{0}\\,r^{n-1}\\,(1-r^{n})$ 对所有 $n$ 都是非负的，最多呈现一个峰值，然后当 $n\\to\\infty$ 时单调衰减到 $0$，没有步间振荡。\n\n因此，保证非振荡衰减的最大步长可以通过强制 $0<r<1$ 来获得，即\n$$\n0<1-k\\,\\tau<1\\;\\;\\Longleftrightarrow\\;\\;0<\\tau<\\frac{1}{k}.\n$$\n因此，精确的上界是\n$$\n\\tau_{\\max}=\\frac{1}{k}.\n$$\n这一选择确保了由显式 $\\tau$-跳跃产生的离散时间方差轨迹不会振荡，并且在最多一个峰值后衰减到 $0$，这与 $\\tau\\to 0$ 时精确 CME 的行为在定性上是一致的。", "answer": "$$\\boxed{\\frac{1}{k}}$$", "id": "2694968"}, {"introduction": "τ-leaping 方法面临的另一个主要挑战是准确捕捉边界事件，例如物种数量降为零的“灭绝”事件，而该算法可能会直接“跳过”这些关键点。这个高级实践旨在解决这一问题，你将实现一种混合模拟方法，它将 τ-leaping 的速度与精确随机模拟算法 (SSA) 在边界附近的准确性相结合。通过这个练习，你将学会构建一个强大的模拟器，用于估算像平均灭绝时间这样的重要随机过程指标。[@problem_id:2695011]", "problem": "您必须编写一个完整、可运行的程序，使用两种方法来估计一个连续时间生灭过程到零点（灭绝时间）的平均首达时间：一种是基于随机模拟算法（SSA）的精确方法，另一种是基于增加了事件检测方法的近似$\\tau$跳跃方法。该系统是一个具有个体出生和死亡的单物种反应网络，受化学主方程控制。两个反应是出生和死亡，在状态 $x$ 下的倾向函数分别为 $a_{\\text{birth}}(x) = \\lambda x$ 和 $a_{\\text{death}}(x) = \\mu x$，其中 $\\lambda \\ge 0$ 且 $\\mu \\ge 0$。初始个体数为 $x(0) = x_0 \\in \\{0,1,2,\\dots\\}$。到零点的首达时间是满足 $x(t) = 0$ 的第一个时间 $t \\ge 0$。本问题中所有时间值都必须以秒为单位。\n\n所需方法如下：\n- 精确随机模拟算法 (SSA)：通过基于总倾向 $a_0(x) = a_{\\text{birth}}(x) + a_{\\text{death}}(x)$ 迭代抽取服从指数分布的事件间隔时间，并根据其相对倾向选择反应通道，来模拟样本路径，直到过程达到状态 0。记录每个轨迹的首达时间，并对指定数量的轨迹求样本均值。\n- 带事件检测的$\\tau$跳跃：通过用参数为 $a_{\\text{birth}}(x)\\tau$ 和 $a_{\\text{death}}(x)\\tau$ 的独立泊松随机变量来近似每次跳跃中各反应的发生次数，以固定的时间增量 $\\tau$ 推进。如果一个提议的跳跃会导致状态变为非正值，则不接受该跳跃。相反，从当前状态切换到精确的SSA微观模拟，并精确地继续直到灭绝；记录在此事件检测阶段找到的精确灭绝时间。否则，接受跳跃并继续。重复此过程直到灭绝并记录首达时间。对相同数量的轨迹求样本均值。\n\n请基于以下基本原理和事实实现您的程序：\n- 具有质量作用动力学的化学主方程定义了每个反应通道 $j$ 的倾向函数 $a_j(x)$，其中 $a_{\\text{birth}}(x)=\\lambda x$ 和 $a_{\\text{death}}(x)=\\mu x$。\n- 在精确SSA下，当处于状态 $x$ 时，到下一个反应的等待时间服从速率为 $a_0(x) = \\sum_j a_j(x)$ 的指数分布，且下一个反应通道以概率 $a_j(x)/a_0(x)$ 被选择。\n- 在$\\tau$跳跃近似下，对于大小为 $\\tau$ 的一次跳跃，反应次数被建模为独立的泊松随机变量，其均值 $a_j(x)\\tau$ 是根据跳跃开始时的状态计算的。\n\n实现这两个估计量，并通过报告两个估计的平均首达时间之间的绝对差来在多个测试用例中比较它们。所有随机变量必须使用可复现的伪随机数生成器生成。对于从0开始索引为 $i$ 的每个测试用例，分别为$\\tau$跳跃和SSA方法使用以种子 $s_{\\tau}+i$ 和 $s_{\\text{SSA}}+i$ 初始化的两个独立随机数生成器，其中 $s_{\\tau} = 12345$ 且 $s_{\\text{SSA}} = 67890$。对于每个测试用例，在每种方法下精确模拟 $M$ 个独立轨迹，并计算每种方法的样本平均首达时间。您的程序必须为每个测试用例输出这两个样本均值之间的绝对差，以秒为单位的浮点数表示。\n\n使用以下测试套件，它涵盖了边界情况、纯死亡情况、亚临界生灭情况和近临界情况：\n- 测试 $0$ (边界): $(\\lambda, \\mu, x_0, \\tau, M) = (0.3, 0.7, 0, 0.2, 1000)$。\n- 测试 $1$ (纯死亡): $(\\lambda, \\mu, x_0, \\tau, M) = (0.0, 1.0, 20, 0.05, 1000)$。\n- 测试 $2$ (亚临界): $(\\lambda, \\mu, x_0, \\tau, M) = (0.2, 0.5, 30, 0.1, 1000)$。\n- 测试 $3$ (近临界): $(\\lambda, \\mu, x_0, \\tau, M) = (0.4, 0.5, 10, 0.05, 1000)$。\n\n所有速率的单位均为 $\\text{s}^{-1}$，所有时间必须以秒报告。对于测试 $0$，首达时间恒为 $0$ 秒。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个浮点数按测试顺序精确四舍五入到小数点后六位。例如，输出应类似于“[0.000000,0.012345,0.001234,0.056789]”。", "solution": "我们从质量作用动力学下均匀混合系统的化学主方程开始。对于状态为 $x \\in \\{0,1,2,\\dots\\}$ 的单物种线性生灭过程，两个反应通道及其倾向函数为 $a_{\\text{birth}}(x) = \\lambda x$ 和 $a_{\\text{death}}(x) = \\mu x$，其中 $\\lambda \\ge 0$ 和 $\\mu \\ge 0$ 是以 $\\text{s}^{-1}$ 为单位的个体速率。化学主方程意味着，在当前状态 $x$ 的条件下，精确动力学下到下一个反应的等待时间服从速率为 $a_0(x) = a_{\\text{birth}}(x) + a_{\\text{death}}(x)$ 的指数分布，且下一个反应是出生的概率为 $a_{\\text{birth}}(x)/a_0(x)$，是死亡的概率为 $a_{\\text{death}}(x)/a_0(x)$。这是精确随机模拟算法（SSA）（也称为 Gillespie 直接法）的基本依据。我们模拟路径直到达到吸收态 $x=0$；累积的时间即为到零点的首达时间（FPT）。\n\n$\\tau$跳跃近似基于一个假设，即在长度为 $\\tau$ 的小时间间隔内，倾向函数大致保持不变。它将在一次跳跃中反应通道 $j$ 的发生次数建模为均值为 $a_j(x)\\tau$ 的泊松随机变量，其中 $x$ 是跳跃开始时的状态。对于我们处于状态 $x$ 的双通道系统，我们抽取独立的 $K_{\\text{birth}} \\sim \\text{Poisson}(a_{\\text{birth}}(x)\\tau)$ 和 $K_{\\text{death}} \\sim \\text{Poisson}(a_{\\text{death}}(x)\\tau)$，并提出新状态 $x' = x + K_{\\text{birth}} - K_{\\text{death}}$。这种近似可能偶尔会提出非物理的负值。为了稳健地处理首达检测，我们采用一种事件检测策略：如果提议的跳跃将使系统达到或低于零，我们不接受该跳跃。相反，我们从当前状态切换到精确SSA，并继续直到过程精确到达零。在SSA微观模拟期间累积的时间加上已流逝的$\\tau$跳跃时间，得出的灭绝时间对于向吸收集的终端趋近是精确的，而早期的演化仍然由$\\tau$跳跃近似。\n\n精确SSA的算法设计：\n1. 初始化 $t \\leftarrow 0$ 和 $x \\leftarrow x_0$。如果 $x_0 = 0$，返回 $0$。\n2. 当 $x > 0$ 时，计算 $a_{\\text{birth}}(x) = \\lambda x$，$a_{\\text{death}}(x) = \\mu x$ 和 $a_0(x) = a_{\\text{birth}}(x) + a_{\\text{death}}(x)$。\n3. 抽取 $\\Delta t \\sim \\text{Exponential}(1/a_0(x))$; 抽取 $u \\sim \\text{Uniform}(0,1)$。\n4. 如果 $u < a_{\\text{birth}}(x)/a_0(x)$，设置 $x \\leftarrow x + 1$，否则设置 $x \\leftarrow x - 1$。更新 $t \\leftarrow t + \\Delta t$。\n5. 当 $x=0$ 时，返回 $t$ 作为FPT。\n\n带事件检测的$\\tau$跳跃的算法设计：\n1. 初始化 $t \\leftarrow 0$ 和 $x \\leftarrow x_0$。如果 $x_0 = 0$，返回 $0$。\n2. 当 $x > 0$ 时：\n   a. 计算 $a_{\\text{birth}}(x) = \\lambda x$ 和 $a_{\\text{death}}(x) = \\mu x$。\n   b. 抽取 $K_{\\text{birth}} \\sim \\text{Poisson}(a_{\\text{birth}}(x)\\tau)$ 和 $K_{\\text{death}} \\sim \\text{Poisson}(a_{\\text{death}}(x)\\tau)$。\n   c. 形成暂定新状态 $x' = x + K_{\\text{birth}} - K_{\\text{death}}$。\n   d. 如果 $x' > 0$，接受跳跃：设置 $x \\leftarrow x'$，$t \\leftarrow t + \\tau$，并继续。\n   e. 如果 $x' \\le 0$，拒绝跳跃并从当前状态 $x$ 切换到精确SSA，不改变 $t$。运行SSA直到 $x=0$，累积精确的时间增量。返回包含SSA微观模拟时间的灭绝时间 $t$。\n此事件检测保证了每当跳跃指示可能穿越边界时，向吸收边界的最终趋近都是精确模拟的。\n\n统计估计与可复现性：\n- 对于每个测试用例，为SSA和带事件检测的$\\tau$跳跃执行 $M$ 次独立轨迹，计算每种方法的样本平均FPT，并报告这些均值之间的绝对差。\n- 为了可复现性，对于测试索引 $i \\in \\{0,1,2,3\\}$，分别为$\\tau$跳跃和SSA方法使用以种子 $s_{\\tau} + i$ 和 $s_{\\text{SSA}} + i$ 初始化的独立伪随机数生成器，其中 $s_{\\tau} = 12345$ 且 $s_{\\text{SSA}} = 67890$。\n\n单位与输出：\n- 所有速率 $\\lambda$ 和 $\\mu$ 的单位都是 $\\text{s}^{-1}$，所有时间的单位都是秒。\n- 程序必须输出单行，其中包含一个有四个浮点数的列表，每个浮点数是对应测试的两个估计平均FPT之间的绝对差（以秒为单位），四舍五入到小数点后六位，用方括号括起来并用逗号分隔。\n\n测试套件规格：\n- 测试 $0$: $(\\lambda, \\mu, x_0, \\tau, M) = (0.3, 0.7, 0, 0.2, 1000)$; 预期的FPT恒为 $0$ 秒。\n- 测试 $1$: $(\\lambda, \\mu, x_0, \\tau, M) = (0.0, 1.0, 20, 0.05, 1000)$; 纯死亡，有限的预期FPT。\n- 测试 $2$: $(\\lambda, \\mu, x_0, \\tau, M) = (0.2, 0.5, 30, 0.1, 1000)$; 亚临界生灭，有限的预期FPT。\n- 测试 $3$: $(\\lambda, \\mu, x_0, \\tau, M) = (0.4, 0.5, 10, 0.05, 1000)$; 近临界，有限的预期FPT但方差比亚临界大。\n\n基本原理：\n- 在化学主方程的假设下，SSA是精确的。\n- $\\tau$跳跃近似通过在每次跳跃中冻结倾向函数引入误差，但事件检测校正通过在跳跃将导致系统达到或低于零时切换到精确SSA，从而消除了主要的边界穿越误差。这产生了一个实用且准确的平均FPT估计量，特别是当 $\\tau$ 相对于总倾向的倒数较小且状态不太接近零时。跨测试套件的比较突显了在边界情况（零时刻灭绝）、单调纯死亡过程以及不同刚度程度的亚临界区域中的准确性。\n\n最终的程序必须精确实现上述算法，遵守指定的种子和样本大小，并以确切的格式打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ssa_first_passage_time(lmbda, mu, x0, rng):\n    \"\"\"\n    Exact SSA for first-passage time to zero in a linear birth-death process.\n    Rates: birth: lmbda * x, death: mu * x\n    Returns time to hit zero (in seconds).\n    \"\"\"\n    if x0 <= 0:\n        return 0.0\n    t = 0.0\n    x = int(x0)\n    while x > 0:\n        a_birth = lmbda * x\n        a_death = mu * x\n        a0 = a_birth + a_death\n        if a0 <= 0.0:\n            # Trapped away from zero; treat as infinite (should not occur in provided tests)\n            return float('inf')\n        dt = rng.exponential(1.0 / a0)\n        t += dt\n        if rng.random() < (a_birth / a0):\n            x += 1\n        else:\n            x -= 1\n    return t\n\ndef tau_leap_event_detection_fpt(lmbda, mu, x0, tau, rng):\n    \"\"\"\n    Tau-leaping with event detection for first-passage time to zero.\n    Leaps of fixed size tau. If a leap would cross zero (x + K_birth - K_death <= 0),\n    switch to exact SSA from the current state to compute the extinction time exactly.\n    \"\"\"\n    if x0 <= 0:\n        return 0.0\n    t = 0.0\n    x = int(x0)\n    while x > 0:\n        a_birth = lmbda * x\n        a_death = mu * x\n        a0 = a_birth + a_death\n        if a0 <= 0.0:\n            # No events possible; treat as infinite (should not occur in provided tests)\n            return float('inf')\n        # Draw Poisson counts for this leap\n        k_birth = rng.poisson(a_birth * tau)\n        k_death = rng.poisson(a_death * tau)\n        x_new = x + k_birth - k_death\n        if x_new > 0:\n            # Accept leap\n            x = x_new\n            t += tau\n        else:\n            # Event detection: switch to exact SSA to hit zero\n            while x > 0:\n                a_birth = lmbda * x\n                a_death = mu * x\n                a0 = a_birth + a_death\n                dt = rng.exponential(1.0 / a0)\n                t += dt\n                if rng.random() < (a_birth / a0):\n                    x += 1\n                else:\n                    x -= 1\n            # Now extinct; return time\n            return t\n    return t\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test: (lambda, mu, x0, tau, M)\n    test_cases = [\n        (0.3, 0.7, 0, 0.2, 1000),   # Test 0: boundary x0=0\n        (0.0, 1.0, 20, 0.05, 1000), # Test 1: pure death\n        (0.2, 0.5, 30, 0.1, 1000),  # Test 2: subcritical\n        (0.4, 0.5, 10, 0.05, 1000), # Test 3: near-critical\n    ]\n\n    # Base seeds for reproducibility\n    seed_tau_base = 12345\n    seed_ssa_base = 67890\n\n    results = []\n    for idx, (lmbda, mu, x0, tau, M) in enumerate(test_cases):\n        rng_tau = np.random.default_rng(seed_tau_base + idx)\n        rng_ssa = np.random.default_rng(seed_ssa_base + idx)\n\n        # Run tau-leaping with event detection\n        times_tau = []\n        for _ in range(M):\n            t = tau_leap_event_detection_fpt(lmbda, mu, x0, tau, rng_tau)\n            times_tau.append(t)\n        mean_tau = float(np.mean(times_tau)) if len(times_tau) > 0 else 0.0\n\n        # Run exact SSA\n        times_ssa = []\n        for _ in range(M):\n            t = ssa_first_passage_time(lmbda, mu, x0, rng_ssa)\n            times_ssa.append(t)\n        mean_ssa = float(np.mean(times_ssa)) if len(times_ssa) > 0 else 0.0\n\n        diff = abs(mean_tau - mean_ssa)\n        results.append(diff)\n\n    # Final print statement in the exact required format: 6 digits after decimal point.\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nsolve()\n```", "id": "2695011"}]}