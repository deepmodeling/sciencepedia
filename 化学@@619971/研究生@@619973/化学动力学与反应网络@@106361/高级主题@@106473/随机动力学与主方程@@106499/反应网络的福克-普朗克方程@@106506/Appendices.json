{"hands_on_practices": [{"introduction": "掌握福克-普朗克方程的关键第一步是理解其作为离散化学主方程连续近似的起源。本实践将引导您对一个单物种的生灭过程完成这一基本推导。通过直接从反应倾向性计算漂移 ($A(x)$) 和扩散 ($B(x)$) 系数，您将在离散的随机跳跃和系统演化的连续描述之间建立起直观而严谨的联系。[@problem_id:2685719]", "problem": "考虑一个充分混合的单物种单分子生灭反应网络，其分子数为 $n \\in \\{0,1,2,\\dots\\}$，处于体积（系统大小）为 $\\Omega$ 的系统中，包含反应 $X \\to X+1$ 和 $X \\to X-1$。其随机动力学由化学主方程 (CME) 控制，其中生成反应的倾向函数为 $a_b(n)=k_b \\Omega$，消失反应的倾向函数为 $a_d(n)=k_d n$，此处 $k_b > 0$ 和 $k_d > 0$ 为恒定速率参数。定义浓度变量 $x=n/\\Omega$ 以及 $x$ 在大系统极限 $\\Omega \\to \\infty$ 下的概率密度 $P(x,t)$。\n\n从 CME 和系统大小展开（其合理性在于 $x$ 的跳跃步长 $1/\\Omega$ 很小）出发，推导至 $1/\\Omega$ 的领头阶，得到 $P(x,t)$ 在 Itô 约定下的 Fokker-Planck 方程 (FPE)，其典范形式为\n$$\n\\frac{\\partial}{\\partial t}P(x,t) \\;=\\; -\\frac{\\partial}{\\partial x}\\!\\left[A(x)\\,P(x,t)\\right] \\;+\\; \\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2}\\!\\left[B(x)\\,P(x,t)\\right].\n$$\n请确定漂移系数 $A(x)$ 和扩散系数 $B(x)$ 作为 $x$, $k_b$, $k_d$ 和 $\\Omega$ 的显式函数，并保留至 $1/\\Omega$ 的领头非平凡阶。请将最终答案表示为一个以 $A(x)$ 和 $B(x)$ 为元素的行矩阵。", "solution": "该问题陈述具有科学依据，内容自洽且良定。它描述了随机化学动力学中的一个标准生灭过程，并要求在大系统尺寸极限下推导其相应的 Fokker-Planck 方程 (FPE)，这是一个标准且有效的方法。下面我们进行推导。\n\n该单物种反应网络的随机动力学由化学主方程 (CME) 描述，该方程给出了在时间 $t$ 有 $n$ 个分子的概率 $P(n,t)$。反应包括生成反应（状态变化 $n \\to n+1$，倾向函数 $a_b(n) = k_b \\Omega$）和消失反应（状态变化 $n \\to n-1$，倾向函数 $a_d(n) = k_d n$）。CME 是一个微分差分方程，描述了状态 $n$ 概率的增益和损失：\n$$\n\\frac{d P(n,t)}{dt} = \\left[ a_b(n-1)P(n-1,t) + a_d(n+1)P(n+1,t) \\right] - \\left[ a_b(n) + a_d(n) \\right] P(n,t).\n$$\n代入给定的倾向函数，我们得到：\n$$\n\\frac{d P(n,t)}{dt} = k_b \\Omega P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b \\Omega + k_d n)P(n,t).\n$$\n在大系统尺寸极限 $\\Omega \\to \\infty$ 下，离散的分子数 $n$ 可以用一个连续变量来近似。我们定义浓度 $x = n/\\Omega$。概率分布 $P(n,t)$ 与概率密度函数 $P(x,t)$ 相关，满足 $P(n,t) \\approx P(x,t) \\Delta x = P(x,t)/\\Omega$。$n$ 的大小为 $\\pm 1$ 的离散跳跃对应于 $x$ 的大小为 $\\Delta x = \\pm 1/\\Omega$ 的微小跳跃。这使得主方程的连续近似成为可能，该近似可通过 Kramers-Moyal 展开在形式上得到。将此展开截断到二阶的结果就是 Fokker-Planck 方程。\n\n给出的 FPE 的典范形式为：\n$$\n\\frac{\\partial}{\\partial t}P(x,t) \\;=\\; -\\frac{\\partial}{\\partial x}\\!\\left[A(x)\\,P(x,t)\\right] \\;+\\; \\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2}\\!\\left[B(x)\\,P(x,t)\\right].\n$$\n漂移系数 $A(x)$ 和扩散系数 $B(x)$ 分别是该过程的一阶和二阶跳跃矩。第 $k$ 阶跳跃矩 $\\alpha_k(x)$ 定义为 $(\\Delta x)^k$ 的平均变化率：\n$$\n\\alpha_k(x) = \\sum_{\\text{reactions } j} (\\Delta x_j)^k \\times W_j(x),\n$$\n其中 $\\Delta x_j$ 是反应 $j$ 引起的浓度变化，而 $W_j(x)$ 是其速率（倾向函数），表示为 $x$ 的函数。漂移和扩散系数则为 $A(x) = \\alpha_1(x)$ 和 $B(x) = \\alpha_2(x)$。这个公式对应于 Itô 约定。\n\n我们现在为给定系统计算这些矩。\n两个反应是：\n1. 生成反应：$X \\to X+1$。$n$ 的变化为 $+1$，因此 $\\Delta x = +1/\\Omega$。速率为 $W_b(x) = a_b(\\Omega x) = k_b \\Omega$。\n2. 消失反应：$X \\to X-1$。$n$ 的变化为 $-1$，因此 $\\Delta x = -1/\\Omega$。速率为 $W_d(x) = a_d(\\Omega x) = k_d (\\Omega x)$。\n\n漂移系数 $A(x)$ 是一阶跳跃矩 $\\alpha_1(x)$：\n$$\nA(x) = \\alpha_1(x) = \\left(+\\frac{1}{\\Omega}\\right) W_b(x) + \\left(-\\frac{1}{\\Omega}\\right) W_d(x)\n$$\n$$\nA(x) = \\frac{1}{\\Omega} (k_b \\Omega) - \\frac{1}{\\Omega} (k_d \\Omega x) = k_b - k_d x.\n$$\n该项决定了浓度的确定性演化，并且是 $\\Omega^0$ 阶的。它与宏观速率方程 $\\frac{dx}{dt} = k_b - k_d x$ 相同。\n\n扩散系数 $B(x)$ 是二阶跳跃矩 $\\alpha_2(x)$：\n$$\nB(x) = \\alpha_2(x) = \\left(+\\frac{1}{\\Omega}\\right)^2 W_b(x) + \\left(-\\frac{1}{\\Omega}\\right)^2 W_d(x)\n$$\n$$\nB(x) = \\frac{1}{\\Omega^2} (k_b \\Omega) + \\frac{1}{\\Omega^2} (k_d \\Omega x) = \\frac{k_b}{\\Omega} + \\frac{k_d x}{\\Omega} = \\frac{k_b + k_d x}{\\Omega}.\n$$\n该项量化了围绕确定性路径的随机涨落的大小，并且是 $\\Omega^{-1}$ 阶的。\n\nKramers-Moyal 展开是一个无穷级数。FPE 是通过截断该级数得到的近似。第 $k$ 项包含第 $k$ 阶跳跃矩 $\\alpha_k(x)$。对于本系统，可以证明 $\\alpha_k(x)$ 是 $\\Omega^{1-k}$ 阶的。对于 $k > 2$，这些矩是 $\\Omega^{-2}$ 阶或更小的。因此，忽略 $k > 2$ 的项是关于 $1/\\Omega$ 幂次的一个系统性近似。得到的 FPE，连同上面计算出的漂移系数 $A(x)$ 和扩散系数 $B(x)$，代表了该随机过程的领头阶连续描述。\n\n确定的系数为：\n漂移：$A(x) = k_b - k_d x$。\n扩散：$B(x) = \\frac{k_b + k_d x}{\\Omega}$。\n这些是在指定的 Itô 约定下 FPE 的系数。", "answer": "$$\n\\boxed{\\begin{pmatrix} k_b - k_d x & \\frac{k_b + k_d x}{\\Omega} \\end{pmatrix}}\n$$", "id": "2685719"}, {"introduction": "除了推导本身，福克-普朗克框架的力量在于其在分析随机系统中的应用。本练习介绍线性噪声近似 (Linear Noise Approximation, LNA)，这是一个用于研究稳定稳态附近涨落的强大分析工具。您将把 LNA 应用于一个双物种网络，并求解得到的李雅普诺夫方程 (Lyapunov equation) 以找到稳态协方差矩阵，从而为内在噪声的大小和相关性提供具体的定量预测。[@problem_id:2685713]", "problem": "考虑一个线性反应网络，其包含两个物种 $A$ 和 $B$ 以及四个基元反应\n- $R_1$: $\\varnothing \\to A$，宏观速率常数为 $\\kappa_1$，\n- $R_2$: $A \\to \\varnothing$，宏观速率常数为 $\\kappa_2$，\n- $R_3$: $A \\to B$，宏观速率常数为 $\\kappa_3$，\n- $R_4$: $B \\to \\varnothing$，宏观速率常数为 $\\kappa_4$，\n该反应在充分混合的体积中发生，系统尺寸参数为 $\\Omega > 0$。令 $\\phi=(\\phi_A,\\phi_B)^\\top$ 表示浓度向量，令 $S$ 表示化学计量矩阵（其整数元素对应于每个反应事件的分子数变化）。假设为质量作用动力学，因此宏观倾向向量为 $\\alpha(\\phi)=(\\kappa_1,\\kappa_2 \\phi_A,\\kappa_3 \\phi_A,\\kappa_4 \\phi_B)^\\top$。\n\n从化学主方程（CME）出发，使用 van Kampen 系统尺寸展开至领先的非平凡阶（线性噪声近似，LNA），推导控制浓度围绕确定性不动点 $\\phi^\\star$ 涨落的线性 Fokker-Planck 方程，确定确定性漂移 $f(\\phi)=S\\,\\alpha(\\phi)$ 的漂移雅可比矩阵（生成元）$K=\\partial f/\\partial \\phi|_{\\phi^\\star}$，并获得浓度涨落的稳态协方差矩阵 $\\Sigma$ 所满足的封闭矩阵方程。然后，对于上述网络，计算唯一的确定性不动点 $\\phi^\\star$，在 $\\phi^\\star$ 处计算稳态协方差方程中的矩阵，并求解该方程以获得物种 $B$ 浓度的稳态方差，即 $\\Sigma$ 的元素 $\\sigma_{BB}$。\n\n将 $\\sigma_{BB}$ 的最终结果表示为关于 $\\kappa_1,\\kappa_2,\\kappa_3,\\kappa_4$ 和 $\\Omega$ 的单个封闭形式表达式。不要代入数值。最终答案无需单位。", "solution": "本问题旨在使用线性噪声近似（LNA）推导给定线性反应网络中物种 $B$ 浓度的稳态方差。\n\n首先，对问题陈述进行验证。\n**已知条件：**\n- 物种：$A$、 $B$。\n- 反应：\n  - $R_1$: $\\varnothing \\to A$，速率常数 $\\kappa_1$。\n  - $R_2$: $A \\to \\varnothing$，速率常数 $\\kappa_2$。\n  - $R_3$: $A \\to B$，速率常数 $\\kappa_3$。\n  - $R_4$: $B \\to \\varnothing$，速率常数 $\\kappa_4$。\n- 系统尺寸参数：$\\Omega > 0$。\n- 浓度向量：$\\phi = (\\phi_A, \\phi_B)^\\top$。\n- 化学计量矩阵：$S$。\n- 宏观倾向向量：$\\alpha(\\phi) = (\\kappa_1, \\kappa_2 \\phi_A, \\kappa_3 \\phi_A, \\kappa_4 \\phi_B)^\\top$。\n\n**验证：**\n该问题具有科学依据，植根于随机化学动力学的标准理论。该问题是适定的，提供了所有必要信息和明确的目标。语言精确客观。所描述的系统是该领域的标准模型。因此，该问题被认为是有效的，并将构建解答。\n\n**推导：**\n分析的基础是化学主方程（CME）。van Kampen 系统尺寸展开为 CME 提供了一种系统的近似方法。对于一个分子数为 $n(t)$ 的系统，我们假设 $n(t) = \\Omega\\phi(t) + \\sqrt{\\Omega}\\xi(t)$，其中 $\\phi(t)$ 是确定性的宏观浓度向量，$\\xi(t)$ 是涨落。展开至领先阶，得到 $\\phi(t)$ 的确定性速率方程；展开至次一阶，得到涨落 $\\xi(t)$ 概率分布的线性 Fokker-Planck 方程。\n\n浓度向量为 $X(t) = n(t)/\\Omega = \\phi(t) + \\Omega^{-1/2}\\xi(t)$。浓度的涨落为 $\\eta(t) = X(t) - \\phi(t) = \\Omega^{-1/2}\\xi(t)$。浓度涨落的稳态协方差矩阵，我们记为 $\\Sigma = \\langle \\eta \\eta^\\top \\rangle$，满足连续时间代数 Lyapunov 方程：\n$$K \\Sigma + \\Sigma K^\\top + \\Omega^{-1}D = 0$$\n其中：\n1.  $K$ 是确定性漂移的雅可比矩阵，在稳态下求值：$K = \\left. \\frac{\\partial f}{\\partial \\phi} \\right|_{\\phi^\\star}$。漂移为 $f(\\phi) = S\\alpha(\\phi)$。\n2.  $D$ 是扩散矩阵，由 $D = S \\text{diag}(\\alpha(\\phi^\\star)) S^\\top$ 给出。\n\n现在我们为指定的反应网络计算这些矩阵。\n\n**1. 确定性系统动力学与不动点：**\n化学计量矩阵 $S$ 将四个反应的速率映射为物种 $A$ 和 $B$ 浓度的变化。$S$ 的列对应于反应 $R_1, R_2, R_3, R_4$，行对应于物种 $A, B$：\n$$S = \\begin{pmatrix} 1 & -1 & -1 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix}$$\n确定性速率方程为 $\\frac{d\\phi}{dt} = f(\\phi) = S\\alpha(\\phi)$：\n$$f(\\phi) = \\begin{pmatrix} 1 & -1 & -1 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} \\kappa_1 \\\\ \\kappa_2 \\phi_A \\\\ \\kappa_3 \\phi_A \\\\ \\kappa_4 \\phi_B \\end{pmatrix} = \\begin{pmatrix} \\kappa_1 - (\\kappa_2 + \\kappa_3) \\phi_A \\\\ \\kappa_3 \\phi_A - \\kappa_4 \\phi_B \\end{pmatrix}$$\n通过设 $f(\\phi^\\star) = 0$ 来求得唯一的确定性不动点 $\\phi^\\star = (\\phi_A^\\star, \\phi_B^\\star)^\\top$：\n$$\\kappa_1 - (\\kappa_2 + \\kappa_3) \\phi_A^\\star = 0 \\implies \\phi_A^\\star = \\frac{\\kappa_1}{\\kappa_2 + \\kappa_3}$$\n$$\\kappa_3 \\phi_A^\\star - \\kappa_4 \\phi_B^\\star = 0 \\implies \\phi_B^\\star = \\frac{\\kappa_3}{\\kappa_4}\\phi_A^\\star = \\frac{\\kappa_1 \\kappa_3}{\\kappa_4 (\\kappa_2 + \\kappa_3)}$$\n\n**2. 漂移雅可比矩阵 $K$：**\n雅可比矩阵 $K$ 是 $f(\\phi)$ 的偏导数矩阵，在 $\\phi^\\star$ 处求值。\n$$K = \\left. \\frac{\\partial f}{\\partial \\phi} \\right|_{\\phi^\\star} = \\begin{pmatrix} \\frac{\\partial f_A}{\\partial \\phi_A} & \\frac{\\partial f_A}{\\partial \\phi_B} \\\\ \\frac{\\partial f_B}{\\partial \\phi_A} & \\frac{\\partial f_B}{\\partial \\phi_B} \\end{pmatrix}_{\\phi=\\phi^\\star} = \\begin{pmatrix} -(\\kappa_2 + \\kappa_3) & 0 \\\\ \\kappa_3 & -\\kappa_4 \\end{pmatrix}$$\n由于系统是线性的，雅可比矩阵是常数，不依赖于 $\\phi$。\n\n**3. 扩散矩阵 $D$：**\n首先，我们在不动点 $\\phi^\\star$ 处计算倾向向量 $\\alpha(\\phi)$：\n$$\\alpha(\\phi^\\star) = \\left( \\kappa_1, \\; \\kappa_2 \\frac{\\kappa_1}{\\kappa_2 + \\kappa_3}, \\; \\kappa_3 \\frac{\\kappa_1}{\\kappa_2 + \\kappa_3}, \\; \\kappa_4 \\frac{\\kappa_1 \\kappa_3}{\\kappa_4 (\\kappa_2 + \\kappa_3)} \\right)^\\top$$\n$$\\alpha(\\phi^\\star) = \\left( \\kappa_1, \\; \\frac{\\kappa_1 \\kappa_2}{\\kappa_2 + \\kappa_3}, \\; \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3}, \\; \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} \\right)^\\top$$\n然后，扩散矩阵 $D= S \\text{diag}(\\alpha(\\phi^\\star)) S^\\top$ 为：\n$$D = S \\begin{pmatrix} \\alpha_1(\\phi^\\star) & 0 & 0 & 0 \\\\ 0 & \\alpha_2(\\phi^\\star) & 0 & 0 \\\\ 0 & 0 & \\alpha_3(\\phi^\\star) & 0 \\\\ 0 & 0 & 0 & \\alpha_4(\\phi^\\star) \\end{pmatrix} S^\\top = \\begin{pmatrix} \\alpha_1^\\star+\\alpha_2^\\star+\\alpha_3^\\star & -\\alpha_3^\\star \\\\ -\\alpha_3^\\star & \\alpha_3^\\star+\\alpha_4^\\star \\end{pmatrix}$$\n代入数值：\n$$D_{AA} = \\kappa_1 + \\frac{\\kappa_1 \\kappa_2}{\\kappa_2 + \\kappa_3} + \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} = \\kappa_1 + \\frac{\\kappa_1(\\kappa_2+\\kappa_3)}{\\kappa_2+\\kappa_3} = 2\\kappa_1$$\n$$D_{BB} = \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} + \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} = \\frac{2\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3}$$\n$$D_{AB} = D_{BA} = -\\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3}$$\n所以扩散矩阵为：\n$$D = \\begin{pmatrix} 2\\kappa_1 & - \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} \\\\ - \\frac{\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} & \\frac{2\\kappa_1 \\kappa_3}{\\kappa_2 + \\kappa_3} \\end{pmatrix}$$\n\n**4. 求解 Lyapunov 方程：**\n设协方差矩阵为 $\\Sigma = \\begin{pmatrix} \\sigma_{AA} & \\sigma_{AB} \\\\ \\sigma_{AB} & \\sigma_{BB} \\end{pmatrix}$。方程 $K \\Sigma + \\Sigma K^\\top + \\Omega^{-1}D = 0$ 产生一个包含三个独立线性代数方程的方程组，用于求解 $\\Sigma$ 的三个未知元素。\n$$ \\begin{pmatrix} -(\\kappa_2 + \\kappa_3) & 0 \\\\ \\kappa_3 & -\\kappa_4 \\end{pmatrix} \\begin{pmatrix} \\sigma_{AA} & \\sigma_{AB} \\\\ \\sigma_{AB} & \\sigma_{BB} \\end{pmatrix} + \\begin{pmatrix} \\sigma_{AA} & \\sigma_{AB} \\\\ \\sigma_{AB} & \\sigma_{BB} \\end{pmatrix} \\begin{pmatrix} -(\\kappa_2 + \\kappa_3) & \\kappa_3 \\\\ 0 & -\\kappa_4 \\end{pmatrix} = -\\Omega^{-1} D $$\n矩阵的 $(1,1)$ 元素给出：\n$$-2(\\kappa_2+\\kappa_3)\\sigma_{AA} = -\\Omega^{-1} D_{AA} = -\\Omega^{-1}(2\\kappa_1) \\implies \\sigma_{AA} = \\frac{\\kappa_1}{\\Omega(\\kappa_2+\\kappa_3)}$$\n矩阵的 $(1,2)$ 元素给出：\n$$\\kappa_3 \\sigma_{AA} - (\\kappa_2+\\kappa_3+\\kappa_4)\\sigma_{AB} = -\\Omega^{-1}D_{AB} = \\Omega^{-1}\\frac{\\kappa_1\\kappa_3}{\\kappa_2+\\kappa_3}$$\n代入 $\\sigma_{AA}$ 的结果：\n$$\\kappa_3 \\left( \\frac{\\kappa_1}{\\Omega(\\kappa_2+\\kappa_3)} \\right) - (\\kappa_2+\\kappa_3+\\kappa_4)\\sigma_{AB} = \\frac{\\kappa_1\\kappa_3}{\\Omega(\\kappa_2+\\kappa_3)}$$\n这可以简化为 $-(\\kappa_2+\\kappa_3+\\kappa_4)\\sigma_{AB} = 0$，这意味着 $\\sigma_{AB} = 0$，因为所有速率常数都是正的。\n\n最后，矩阵的 $(2,2)$ 元素给出：\n$$2(\\kappa_3\\sigma_{AB} - \\kappa_4\\sigma_{BB}) = -\\Omega^{-1}D_{BB} = -\\Omega^{-1}\\frac{2\\kappa_1\\kappa_3}{\\kappa_2+\\kappa_3}$$\n代入 $\\sigma_{AB}=0$：\n$$-2\\kappa_4\\sigma_{BB} = -\\frac{2\\kappa_1\\kappa_3}{\\Omega(\\kappa_2+\\kappa_3)}$$\n求解 $\\sigma_{BB}$，即物种 $B$ 浓度的稳态方差：\n$$\\sigma_{BB} = \\frac{\\kappa_1\\kappa_3}{\\Omega\\kappa_4(\\kappa_2+\\kappa_3)}$$\n此结果等价于 $\\phi_B^\\star/\\Omega$，这与以下事实相符：一个由零级反应引发并通过一级步骤传播的线性反应链，在稳态时会导致每个物种的分子数呈泊松分布。", "answer": "$$\\boxed{\\frac{\\kappa_1 \\kappa_3}{\\Omega \\kappa_4 (\\kappa_2 + \\kappa_3)}}$$", "id": "2685713"}, {"introduction": "最后的这项实践将带您从解析计算走向计算研究，处理一个可以检验福克-普朗克近似有效性的非线性双稳态系统。您将实现精确的随机模拟算法 (Stochastic Simulation Algorithm, SSA)，并将其结果与化学朗之万方程 (Chemical Langevin Equation, CLE)——福克-普朗克方程的模拟对应物——进行比较。通过分析随机切换等复杂现象，本练习展示了连续近似在实际建模场景中的实用能力与局限性。[@problem_id:2685607]", "problem": "考虑单物种的 Schlögl 反应网络，这是一个典型的双稳态化学系统，在一个体积为 $\\Omega$ 的充分混合反应器中遵循质量作用动力学，其包含以下反应：\n- 反应 $\\mathcal{R}_1$：$A + 2X \\rightarrow 3X$，\n- 反应 $\\mathcal{R}_2$：$3X \\rightarrow 2X + A$，\n- 反应 $\\mathcal{R}_3$：$B \\rightarrow X$，\n- 反应 $\\mathcal{R}_4$：$X \\rightarrow B$。\n\n物种 $A$ 和 $B$ 是大型外部物种池，其浓度分别维持在恒定的 $a_0$ 和 $b_0$。动态物种 $X$ 的分子数为 $n(t) \\in \\mathbb{N}_0$。宏观速率常数为 $k_1$、$k_2$、$k_3$、$k_4$（均为正值）。$n(t)$ 的化学计量增量为 $\\nu_1 = +1, \\nu_2 = -1, \\nu_3 = +1, \\nu_4 = -1$。根据从浓度到分子的质量作用标度变换，对于 $n \\in \\mathbb{R}_{\\ge 0}$，相应的倾向函数由充分混合反应器中质量作用的核心定义确定：\n- $a_1(n) = k_1 a_0 \\, \\dfrac{n(n-1)}{\\Omega}$，\n- $a_2(n) = k_2 \\, \\dfrac{n(n-1)(n-2)}{\\Omega^2}$，\n- $a_3(n) = k_3 b_0 \\, \\Omega$，\n- $a_4(n) = k_4 \\, n$。\n\n当其多项式形式对于给定的实数 $n \\ge 0$ 产生负数时，所有倾向函数的值都应被截断为零。$n(t)$ 的精确介观动力学由化学主方程（CME）所支配的连续时间、离散状态的马尔可夫跳跃过程给出。从 CME 出发，通过截断至二阶的 Kramers–Moyal 展开，可以得到一个扩散近似，从而导出 Fokker–Planck 方程和与之等价的化学朗之万方程（CLE）。\n\n你的任务如下。\n1) 从 CME 和 Kramers–Moyal 展开出发，推导描述分子数 $n(t)$ 的概率密度 $p(n,t)$ 的一维 Fokker–Planck 方程，并用倾向函数 $a_j(n)$ 和化学计量增量 $\\nu_j$ 明确表示出漂移项 $\\mu(n)$ 和扩散系数 $\\sigma^2(n)$。然后，由此确定 $n(t)$ 对应的 Itô 形式的 CLE。\n2) 证明，在大体积极限下，浓度 $x(t) = n(t)/\\Omega$ 存在一个确定性的平均场极限 $\\dot{x} = f(x)$，并用参数 $k_1$、$k_2$、$k_3$、$k_4$、$a_0$、$b_0$ 写出该网络的 $f(x)$。解释为何在适当的参数选择下，得到的三次多项式 $f(x)$ 可以有三个实根，这意味着存在两个由一个不稳定不动点分隔的稳定不动点（双峰性）。\n3) 在有限时间域 $[0,T]$ 上，为 $n(t)$ 实现三种模拟器：\n   - 精确的随机模拟算法（SSA），\n   - 通过使用固定步长 $\\Delta t$ 的 Euler–Maruyama 方法积分 CLE 实现的全扩散近似，\n   - 一个简单的混合方法：在每个固定时间步长 $\\tau$，通过高斯增量（均值为 $a_j(n)\\tau$，方差为 $a_j(n)\\tau$ 的正态分布）处理具有大瞬时倾向的反应，并通过均值为 $a_j(n)\\tau$ 的泊松增量处理具有小瞬时倾向的反应，所有增量根据化学计量关系加性组合。根据用户选择的阈值速率 $r_{\\mathrm{thresh}}$ 精确定义划分规则，并在每次更新后通过反射法强制 $n(t) \\ge 0$。\n4) 按如下方式定义模态边界。令 $x^\\star_{\\mathrm{mid}}$ 为确定性漂移项 $f(x)$ 的中间实根，并设置 $n_{\\mathrm{thr}} = \\lfloor \\Omega \\, x^\\star_{\\mathrm{mid}} \\rfloor$。对于任何轨迹 $n(t)$，将 $n(t) < n_{\\mathrm{thr}}$ 的总时间定义为在低模态的驻留时间，将 $n(t) \\ge n_{\\mathrm{thr}}$ 的总时间定义为在高模态的驻留时间。对每个模拟器，计算在 $[0,T]$ 时间内每个模态所占的时间分数。以 SSA 的分数值为参考，量化 CLE 和混合方法在每个模态下的绝对误差。\n5) 使用具体的、科学上标准的参数集\n   - $k_1 = 5.0$，\n   - $k_2 = 1.0$，\n   - $k_3 = 1.0$，\n   - $k_4 = 5.99$，\n   - $a_0 = 1.0$，\n   - $b_0 = 1.0$，\n   和初始分子数 $n(0) = \\lfloor 0.1 \\, \\Omega \\rfloor$，为以下测试套件运行你的三种模拟器，每个测试都有其自己的 $(\\Omega, T, \\Delta t, \\tau, r_{\\mathrm{thresh}})$:\n   - 测试 $1$：$\\Omega = 200$，$T = 10.0$，$\\Delta t = 10^{-3}$，$\\tau = 10^{-3}$，$r_{\\mathrm{thresh}} = 50.0$。\n   - 测试 $2$（更离散，噪声更强）：$\\Omega = 50$，$T = 10.0$，$\\Delta t = 10^{-3}$，$\\tau = 10^{-3}$，$r_{\\mathrm{thresh}} = 20.0$。\n   - 测试 $3$（体积更大，更接近扩散极限）：$\\Omega = 400$，$T = 10.0$，$\\Delta t = 10^{-3}$，$\\tau = 10^{-3}$，$r_{\\mathrm{thresh}} = 80.0$。\n6) 对每个测试，报告四个数字：CLE 在低模态驻留时间分数上的绝对误差、CLE 在高模态驻留时间分数上的绝对误差、混合方法在低模态驻留时间分数上的绝对误差，以及混合方法在高模态驻留时间分数上的绝对误差。在每个测试案例中，均以 SSA 为参考。\n\n最终输出格式要求：\n- 你的程序应产生单行输出，包含所有三个测试连接起来的结果。结果为一个由方括号括起来的逗号分隔的浮点数列表，顺序为\n  $[\\mathrm{err}^{\\mathrm{CLE}}_{\\mathrm{low},1}, \\mathrm{err}^{\\mathrm{CLE}}_{\\mathrm{up},1}, \\mathrm{err}^{\\mathrm{HYB}}_{\\mathrm{low},1}, \\mathrm{err}^{\\mathrm{HYB}}_{\\mathrm{up},1}, \\mathrm{err}^{\\mathrm{CLE}}_{\\mathrm{low},2}, \\mathrm{err}^{\\mathrm{CLE}}_{\\mathrm{up},2}, \\mathrm{err}^{\\mathrm{HYB}}_{\\mathrm{low},2}, \\mathrm{err}^{\\mathrm{HYB}}_{\\mathrm{up},2}, \\mathrm{err}^{\\mathrm{CLE}}_{\\mathrm{low},3}, \\mathrm{err}^{\\mathrm{CLE}}_{\\mathrm{up},3}, \\mathrm{err}^{\\mathrm{HYB}}_{\\mathrm{low},3}, \\mathrm{err}^{\\mathrm{HYB}}_{\\mathrm{up},3}]$。\n- 所有数字都是 $[0,1]$ 区间内的无量纲分数，并且必须打印为十进制浮点值。\n- 不应打印任何其他文本。", "solution": "该问题是随机化学动力学领域一个全面且科学严谨的练习，特别关注 Schlögl 反应网络的建模与仿真，该网络是研究双稳态的典范系统。问题陈述经验证是完整、一致且适定的。它要求理论推导和数值实现，这些都是该领域的标准流程。我现在将开始进行解答。\n\n**第1部分：Fokker-Planck 方程和化学朗之万方程的推导**\n\n物种 $X$ 的分子数 $n(t)$ 的动力学由化学主方程（CME）决定，这是一个连续时间、离散状态的表述：\n$$\n\\frac{\\partial P(n, t)}{\\partial t} = \\sum_{j=1}^{4} \\left[ a_j(n - \\nu_j) P(n - \\nu_j, t) - a_j(n) P(n, t) \\right]\n$$\n此处，$P(n, t)$ 是在时间 $t$ 观测到 $n$ 个分子的概率，$a_j(n)$ 是反应倾向，$\\nu_j$ 是反应 $j$ 中 $X$ 分子数的化学计量变化。\n\nFokker-Planck 方程（FPE）是 CME 的一个连续近似，通过截断至二阶的 Kramers-Moyal 展开推导得出。概率密度 $p(n,t)$ 的展开式为：\n$$\n\\frac{\\partial p(n, t)}{\\partial t} = \\sum_{k=1}^{\\infty} \\frac{(-1)^k}{k!} \\frac{\\partial^k}{\\partial n^k} \\left[ M_k(n) p(n, t) \\right]\n$$\n跳跃矩 $M_k(n)$ 定义为 $M_k(n) = \\sum_{j=1}^{4} \\nu_j^k a_j(n)$。将级数在 $k=2$ 处截断，得到 FPE：\n$$\n\\frac{\\partial p(n, t)}{\\partial t} = -\\frac{\\partial}{\\partial n} \\left[ M_1(n) p(n, t) \\right] + \\frac{1}{2} \\frac{\\partial^2}{\\partial n^2} \\left[ M_2(n) p(n, t) \\right]\n$$\n该方程通过漂移系数 $\\mu(n) = M_1(n)$ 和扩散系数 $\\sigma^2(n) = M_2(n)$ 描述了概率密度 $p(n,t)$ 的演化。\n\n对于 Schlögl 网络，化学计量增量为 $\\nu_1 = +1, \\nu_2 = -1, \\nu_3 = +1, \\nu_4 = -1$。\n漂移系数是第一跳跃矩：\n$$\n\\mu(n) = M_1(n) = \\sum_{j=1}^{4} \\nu_j a_j(n) = (+1)a_1(n) + (-1)a_2(n) + (+1)a_3(n) + (-1)a_4(n)\n$$\n代入给定的倾向函数：\n$$\n\\mu(n) = k_1 a_0 \\frac{n(n-1)}{\\Omega} - k_2 \\frac{n(n-1)(n-2)}{\\Omega^2} + k_3 b_0 \\Omega - k_4 n\n$$\n扩散系数是第二跳跃矩：\n$$\n\\sigma^2(n) = M_2(n) = \\sum_{j=1}^{4} \\nu_j^2 a_j(n) = (+1)^2 a_1(n) + (-1)^2 a_2(n) + (+1)^2 a_3(n) + (-1)^2 a_4(n) = \\sum_{j=1}^{4} a_j(n)\n$$\n代入倾向函数：\n$$\n\\sigma^2(n) = k_1 a_0 \\frac{n(n-1)}{\\Omega} + k_2 \\frac{n(n-1)(n-2)}{\\Omega^2} + k_3 b_0 \\Omega + k_4 n\n$$\n与此 FPE 在数学上等价的随机微分方程（SDE）是 Itô 形式的化学朗之万方程（CLE）：\n$$\ndn(t) = \\mu(n(t)) dt + \\sigma(n(t)) dW(t)\n$$\n其中 $dW(t)$ 表示标准维纳过程的增量。该方程为轨迹 $n(t)$ 提供了一个连续状态、连续时间的近似。\n\n**第2部分：确定性平均场极限和双稳态**\n\n为了找到确定性极限，我们考虑浓度 $x(t) = n(t)/\\Omega$，并研究系统在大体积极限 $\\Omega \\to \\infty$ 下的行为。在此极限下，大数定律表明随机过程收敛于由一个常微分方程（ODE）控制的确定性轨迹。该 ODE 由 CLE 的漂移项经由体积缩放得到：\n$$\n\\dot{x}(t) = \\lim_{\\Omega \\to \\infty} \\frac{\\mu(\\Omega x)}{\\Omega}\n$$\n我们将 $n = \\Omega x$ 代入倾向函数并取极限。对于大的 $\\Omega$，$n(n-1) \\approx n^2 = (\\Omega x)^2$ 且 $n(n-1)(n-2) \\approx n^3 = (\\Omega x)^3$。\n$$\n\\dot{x} = \\lim_{\\Omega \\to \\infty} \\frac{1}{\\Omega} \\left[ k_1 a_0 \\frac{(\\Omega x)^2}{\\Omega} - k_2 \\frac{(\\Omega x)^3}{\\Omega^2} + k_3 b_0 \\Omega - k_4 (\\Omega x) \\right]\n$$\n$$\n\\dot{x} = k_1 a_0 x^2 - k_2 x^3 + k_3 b_0 - k_4 x\n$$\n整理后得到宏观速率方程 $\\dot{x} = f(x)$：\n$$\nf(x) = -k_2 x^3 + k_1 a_0 x^2 - k_4 x + k_3 b_0\n$$\n系统的不动点是三次多项式 $f(x)=0$ 的非负实根。一个三次多项式可以有一个或三个实根。当参数值的选择使得存在三个不同的实根时，比如 $x_1^* < x_2^* < x_3^*$，系统表现出双稳态。\n这些不动点的稳定性由导数 $f'(x^*)$ 的符号决定。由于首项系数 $-k_2$ 为负，当 $x \\to \\infty$ 时 $f(x) \\to -\\infty$。又因为所有参数都是正的，所以 $f(0) = k_3 b_0 > 0$。要存在三个正根，函数必须有一个在 x 轴上方的局部最大值和一个在 x 轴下方的局部最小值。这意味着在根处的导数符号模式为：$f'(x_1^*) < 0$（稳定）、$f'(x_2^*) > 0$（不稳定）和 $f'(x_3^*) < 0$（稳定）。因此，该系统拥有两个由一个不稳定不动点分隔的稳定稳态，这是双稳态的定义性特征。\n\n**第3-6部分：模拟器实现与分析**\n\n该问题要求实现三种仿真算法：精确的随机模拟算法（SSA）、近似的化学朗之万方程（CLE）以及一种指定的混合方法。近似方法的性能将根据系统在两个定义的模态中度过的时间分数与精确的 SSA 进行比较来评估。这些模态由一个阈值 $n_{\\mathrm{thr}} = \\lfloor \\Omega x^\\star_{\\mathrm{mid}} \\rfloor$ 分隔，其中 $x^\\star_{\\mathrm{mid}}$ 是确定性速率方程 $f(x)=0$ 的中间（不稳定）根。\n\n对于给定的参数 $k_1 = 5.0, k_2 = 1.0, k_3 = 1.0, k_4 = 5.99, a_0 = 1.0, b_0 = 1.0$，速率方程为 $f(x) = -x^3 + 5.0 x^2 - 5.99 x + 1.0 = 0$。通过数值计算，该多项式的根近似为 $0.1989, 1.8082, 2.9929$。中间根为 $x^\\star_{\\mathrm{mid}} \\approx 1.8082$。该值将用于根据每个测试案例的体积 $\\Omega$ 计算 $n_{\\mathrm{thr}}$。\n\n实现将按以下步骤进行：\n- **倾向函数**：对于 SSA，倾向是为整数 $n$ 计算的。对于 CLE 和混合方法，$n$ 是一个实数，当其多项式形式变为负数时，倾向被截断为零，例如 $a_1(n) \\propto \\max(0, n(n-1))$。\n- **SSA**：使用 Gillespie 直接法生成精确的随机轨迹。它是一种事件驱动算法，其中时间步长是随机变量。\n- **CLE**：使用 Euler-Maruyama 格式以固定时间步长 $\\Delta t$ 对 CLE 进行积分。在 $n=0$ 处实现一个反射边界，即 $n_{new} = |n_{old} + \\text{increment}|$。\n- **混合方法**：在每个固定的时间步长 $\\tau$，每个反应的发生次数根据其反应倾向是低于还是高于阈值 $r_{\\mathrm{thresh}}$，分别从泊松分布或正态分布中抽取。$n$ 的总变化量是这些发生次数按化学计量加权的和。同样应用反射边界。\n- **分析**：对于每个轨迹，计算在低模态（$n < n_{\\mathrm{thr}}$）和高模态（$n \\ge n_{\\mathrm{thr}}$）的驻留时间分数。然后计算 CLE 和混合方法相对于 SSA 分数的绝对误差。\n\n最终代码将对指定的三个测试案例执行这些步骤，并按要求格式打印出所得的十二个误差指标。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Schlögl network problem.\n    It runs three simulations (SSA, CLE, Hybrid) for three test cases,\n    calculates residence time fractions, and computes the errors\n    of the approximate methods against the exact SSA.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    params = {\n        'k1': 5.0, 'k2': 1.0, 'k3': 1.0, 'k4': 5.99,\n        'a0': 1.0, 'b0': 1.0\n    }\n\n    # --- Deterministic Analysis: Find middle root for mode boundary ---\n    # f(x) = -k2*x^3 + k1*a0*x^2 - k4*x + k3*b0 = 0\n    coeffs = [-params['k2'], params['k1'] * params['a0'], -params['k4'], params['k3'] * params['b0']]\n    roots = np.roots(coeffs)\n    roots.sort()\n    x_mid_star = roots[1]\n\n    # --- Test Cases ---\n    test_cases = [\n        {'Omega': 200.0, 'T': 10.0, 'dt': 1e-3, 'tau': 1e-3, 'r_thresh': 50.0},\n        {'Omega': 50.0, 'T': 10.0, 'dt': 1e-3, 'tau': 1e-3, 'r_thresh': 20.0},\n        {'Omega': 400.0, 'T': 10.0, 'dt': 1e-3, 'tau': 1e-3, 'r_thresh': 80.0},\n    ]\n\n    # Use separate random number generators for reproducibility and independence\n    # Seeds are chosen arbitrarily but fixed.\n    rng_seeds = [(10, 11, 12), (20, 21, 22), (30, 31, 32)]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        Omega = case['Omega']\n        T = case['T']\n        dt_cle = case['dt']\n        tau_hybrid = case['tau']\n        r_thresh = case['r_thresh']\n\n        n_thr = int(np.floor(Omega * x_mid_star))\n        n0 = int(np.floor(0.1 * Omega))\n\n        ssa_seed, cle_seed, hybrid_seed = rng_seeds[i]\n\n        # --- Propensity functions ---\n        stoichiometry = np.array([1, -1, 1, -1], dtype=np.float64)\n\n        def propensities_ssa(n, p, O):\n            if n < 0: return np.zeros(4)\n            a = np.zeros(4)\n            a[0] = p['k1'] * p['a0'] * n * (n - 1) / O if n >= 2 else 0\n            a[1] = p['k2'] * n * (n - 1) * (n - 2) / (O**2) if n >= 3 else 0\n            a[2] = p['k3'] * p['b0'] * O\n            a[3] = p['k4'] * n if n >= 1 else 0\n            return a\n\n        def propensities_continuous(n, p, O):\n            n = max(n, 0.0)\n            a = np.zeros(4)\n            a[0] = p['k1'] * p['a0'] * n * max(0.0, n - 1.0) / O\n            a[1] = p['k2'] * n * max(0.0, n - 1.0) * max(0.0, n - 2.0) / (O**2)\n            a[2] = p['k3'] * p['b0'] * O\n            a[3] = p['k4'] * n\n            return a\n\n        # --- Simulators ---\n\n        def ssa_simulator(p, O, n_initial, T_final, seed):\n            rng = np.random.default_rng(seed)\n            t = 0.0\n            n = float(n_initial)\n            history = [(t, n)]\n            while t < T_final:\n                props = propensities_ssa(n, p, O)\n                a0_total = np.sum(props)\n                if a0_total <= 1e-10:\n                    t = T_final\n                    history.append((t, n))\n                    break\n                \n                dt_reaction = rng.exponential(1.0 / a0_total)\n                \n                r2 = rng.random()\n                \n                reaction_idx = np.searchsorted(np.cumsum(props), r2 * a0_total)\n                \n                t += dt_reaction\n                if t > T_final:\n                    history.append((T_final, n))\n                    break\n\n                n += stoichiometry[reaction_idx]\n                history.append((t, n))\n            return history\n\n        def cle_simulator(p, O, n_initial, T_final, dt, seed):\n            rng = np.random.default_rng(seed)\n            t = 0.0\n            n = float(n_initial)\n            num_steps = int(T_final / dt)\n            history = [n] * (num_steps + 1)\n            \n            for i in range(num_steps):\n                props = propensities_continuous(n, p, O)\n                mu = np.dot(stoichiometry, props)\n                sigma2 = np.sum(props)\n                \n                if sigma2 < 0: sigma2 = 0\n\n                dW = rng.normal(0.0, np.sqrt(dt))\n                n_new = n + mu * dt + np.sqrt(sigma2) * dW\n                \n                n = abs(n_new) # Reflection boundary\n                history[i+1] = n\n            \n            times = np.linspace(0, T_final, num_steps + 1)\n            return list(zip(times, history))\n\n        def hybrid_simulator(p, O, n_initial, T_final, tau, r_thr, seed):\n            rng = np.random.default_rng(seed)\n            t = 0.0\n            n = float(n_initial)\n            num_steps = int(T_final / tau)\n            history = [n] * (num_steps + 1)\n            \n            for i in range(num_steps):\n                props = propensities_continuous(n, p, O)\n                delta_n = 0.0\n                \n                for j in range(4):\n                    a_j = props[j]\n                    if a_j >= r_thr:\n                        mean = a_j * tau\n                        # Gaussian approximation for number of events\n                        num_events = rng.normal(mean, np.sqrt(mean))\n                    else:\n                        # Poisson for number of events\n                        lam = a_j * tau\n                        if lam > 0:\n                            num_events = rng.poisson(lam)\n                        else:\n                            num_events = 0\n                    \n                    delta_n += stoichiometry[j] * num_events\n                    \n                n_new = n + delta_n\n                n = abs(n_new) # Reflection boundary\n                history[i+1] = n\n\n            times = np.linspace(0, T_final, num_steps + 1)\n            return list(zip(times, history))\n\n        # --- Residence Time Analysis ---\n        def calculate_residence_fractions(trajectory, T_final, n_threshold):\n            time_low = 0.0\n            time_up = 0.0\n            \n            for i in range(len(trajectory) - 1):\n                t_start, n_val = trajectory[i]\n                t_end = trajectory[i+1][0]\n                duration = t_end - t_start\n                \n                if n_val < n_threshold:\n                    time_low += duration\n                else:\n                    time_up += duration\n            \n            # The trajectory might not end exactly at T_final, but the total duration of intervals is T_final\n            total_time = time_low + time_up\n            if total_time == 0: return 0.0, 0.0\n            return time_low / total_time, time_up / total_time\n\n        # --- Run simulations and compute errors ---\n        traj_ssa = ssa_simulator(params, Omega, n0, T, ssa_seed)\n        traj_cle = cle_simulator(params, Omega, n0, T, dt_cle, cle_seed)\n        traj_hybrid = hybrid_simulator(params, Omega, n0, T, tau_hybrid, r_thresh, hybrid_seed)\n\n        frac_ssa = calculate_residence_fractions(traj_ssa, T, n_thr)\n        frac_cle = calculate_residence_fractions(traj_cle, T, n_thr)\n        frac_hybrid = calculate_residence_fractions(traj_hybrid, T, n_thr)\n\n        err_cle_low = abs(frac_cle[0] - frac_ssa[0])\n        err_cle_up = abs(frac_cle[1] - frac_ssa[1])\n        err_hyb_low = abs(frac_hybrid[0] - frac_ssa[0])\n        err_hyb_up = abs(frac_hybrid[1] - frac_ssa[1])\n\n        results.extend([err_cle_low, err_cle_up, err_hyb_low, err_hyb_up])\n\n    # --- Final Output ---\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2685607"}]}