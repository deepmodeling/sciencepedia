{"hands_on_practices": [{"introduction": "在编写复杂的模拟代码之前，从根本上理解积分算法的机制至关重要。本练习将引导您使用速度Verlet算法，在一个简单的势能面上进行手动、分步的计算来传播一个粒子。通过这个过程，您将加深对位置、速度和加速度更新规则的理解，并为更复杂的模拟打下坚实的基础。[@problem_id:1477589]", "problem": "一个质量为 $m = 1.67 \\times 10^{-27}$ kg 的单个粒子被用于模拟一个化学过程。该粒子的运动被限制在一个二维势能面（PES）上，该势能面由函数 $V(x,y) = \\frac{1}{2}k(x^2 + \\alpha y^2)$ 描述。势能的参数为 $k = 100.0$ J/m$^2$ 和一个无量纲各向异性因子 $\\alpha = 4.0$。\n\n在时间 $t=0$ 时，粒子位于位置 $(x_0, y_0) = (1.0 \\times 10^{-11} \\text{ m}, 0 \\text{ m})$，其初始速度为 $(v_{x,0}, v_{y,0}) = (0 \\text{ m/s}, 500.0 \\text{ m/s})$。\n\n为了模拟粒子的轨迹，采用了时间步长为 $\\Delta t = 1.0 \\times 10^{-15}$ s 的速度Verlet算法。你的任务是进行两个完整时间步长的模拟。\n\n计算在时间 $t = 2\\Delta t$ 时粒子的总能量（动能加势能）。以焦耳（J）为单位表示你的最终答案，并四舍五入到四位有效数字。", "solution": "势能为 $V(x,y) = \\frac{1}{2}k(x^{2} + \\alpha y^{2})$。力为 $F_{x} = -\\frac{\\partial V}{\\partial x} = -kx$ 和 $F_{y} = -\\frac{\\partial V}{\\partial y} = -k\\alpha y$。根据牛顿第二定律，加速度为\n$$\na_{x} = \\frac{F_{x}}{m} = -\\frac{k}{m}x, \\quad a_{y} = \\frac{F_{y}}{m} = -\\frac{k\\alpha}{m}y.\n$$\n给定 $m = 1.67 \\times 10^{-27}$，$k = 1.00 \\times 10^{2}$，$\\alpha = 4.0$，$\\Delta t = 1.00 \\times 10^{-15}$，初始条件 $(x_{0},y_{0}) = (1.00 \\times 10^{-11}, 0)$ 和 $(v_{x,0}, v_{y,0}) = (0, 5.00 \\times 10^{2})$，定义\n$$\n\\omega_{x}^{2} = \\frac{k}{m} = 5.98802395209581 \\times 10^{28}, \\quad \\omega_{y}^{2} = \\frac{k\\alpha}{m} = 2.395209580838324 \\times 10^{29}.\n$$\nVelocity Verlet 更新公式为：\n$$\nx_{n+1} = x_{n} + v_{x,n}\\Delta t + \\frac{1}{2}a_{x,n}\\Delta t^{2}, \\quad\ny_{n+1} = y_{n} + v_{y,n}\\Delta t + \\frac{1}{2}a_{y,n}\\Delta t^{2},\n$$\n$$\na_{x,n} = -\\omega_{x}^{2}x_{n}, \\quad a_{y,n} = -\\omega_{y}^{2}y_{n},\n$$\n$$\nv_{x,n+1} = v_{x,n} + \\frac{1}{2}(a_{x,n} + a_{x,n+1})\\Delta t, \\quad\nv_{y,n+1} = v_{y,n} + \\frac{1}{2}(a_{y,n} + a_{y,n+1})\\Delta t.\n$$\n第0步到第1步：\n$$\na_{x,0} = -\\omega_{x}^{2}x_{0} = -5.98802395209581 \\times 10^{17}, \\quad a_{y,0} = 0,\n$$\n$$\nx_{1} = x_{0} + \\frac{1}{2}a_{x,0}\\Delta t^{2} = 1.000000000000000 \\times 10^{-11} - 2.994011976047905 \\times 10^{-13} = 9.700598802395209 \\times 10^{-12},\n$$\n$$\ny_{1} = y_{0} + v_{y,0}\\Delta t = 0 + 5.00 \\times 10^{2} \\times 1.00 \\times 10^{-15} = 5.000000000000000 \\times 10^{-13},\n$$\n$$\na_{x,1} = -\\omega_{x}^{2}x_{1} = -5.808741797841444 \\times 10^{17}, \\quad\na_{y,1} = -\\omega_{y}^{2}y_{1} = -1.197604790419162 \\times 10^{17},\n$$\n$$\nv_{x,1} = 0 + \\frac{1}{2}(a_{x,0}+a_{x,1})\\Delta t = \\frac{1}{2}(-1.1796765759937255 \\times 10^{18}) \\times 10^{-15} = -5.898382879968627 \\times 10^{2},\n$$\n$$\nv_{y,1} = 5.00 \\times 10^{2} + \\frac{1}{2}(0 + a_{y,1})\\Delta t = 5.00 \\times 10^{2} - 5.98802395209581 \\times 10^{1} = 4.401197604790419 \\times 10^{2}.\n$$\n第1步到第2步：\n$$\nx_{2} = x_{1} + v_{x,1}\\Delta t + \\frac{1}{2}a_{x,1}\\Delta t^{2} = 9.700598802395209 \\times 10^{-12} - 5.898382879968627 \\times 10^{-13} - 2.904370898920722 \\times 10^{-13} = 8.820323424506274 \\times 10^{-12},\n$$\n$$\ny_{2} = y_{1} + v_{y,1}\\Delta t + \\frac{1}{2}a_{y,1}\\Delta t^{2} = 5.000000000000000 \\times 10^{-13} + 4.401197604790419 \\times 10^{-13} - 5.988023952095810 \\times 10^{-14} = 8.802395209580838 \\times 10^{-13},\n$$\n$$\na_{x,2} = -\\omega_{x}^{2}x_{2} = -5.281630793117531 \\times 10^{17}, \\quad\na_{y,2} = -\\omega_{y}^{2}y_{2} = -2.108358134031339 \\times 10^{17},\n$$\n$$\nv_{x,2} = v_{x,1} + \\frac{1}{2}(a_{x,1}+a_{x,2})\\Delta t = -5.898382879968627 \\times 10^{2} + \\frac{1}{2}(-1.1090372590958975 \\times 10^{18}) \\times 10^{-15} = -1.1443569175448115 \\times 10^{3},\n$$\n$$\nv_{y,2} = v_{y,1} + \\frac{1}{2}(a_{y,1}+a_{y,2})\\Delta t = 4.401197604790419 \\times 10^{2} + \\frac{1}{2}(-3.305962924450501 \\times 10^{17}) \\times 10^{-15} = 2.748216142565168 \\times 10^{2}.\n$$\n在 $t = 2\\Delta t$ 时的能量：\n$$\nK_{2} = \\frac{1}{2}m\\left(v_{x,2}^{2} + v_{y,2}^{2}\\right) = \\frac{1}{2}(1.67 \\times 10^{-27})\\left(1.3095527547326625 \\times 10^{6} + 7.552691966255693 \\times 10^{4}\\right) = 1.1565415281200083 \\times 10^{-21},\n$$\n对于势能，当 $x_{2}^{2} = 7.779810531292338 \\times 10^{-23}$ 且 $y_{2}^{2} = 7.748216142565169 \\times 10^{-25}$ 时，\n$$\nV_{2} = \\frac{1}{2}k\\left(x_{2}^{2} + \\alpha y_{2}^{2}\\right) = 50\\left(7.779810531292338 \\times 10^{-23} + 4 \\times 7.748216142565169 \\times 10^{-25}\\right) = 4.0448695884974726 \\times 10^{-21}.\n$$\n因此，\n$$\nE_{2} = K_{2} + V_{2} = 5.201411116617481 \\times 10^{-21} \\text{ J}.\n$$\n四舍五入到四位有效数字，在 $t = 2\\Delta t$ 时的总能量为 $5.201 \\times 10^{-21}$ J。", "answer": "$$\\boxed{5.201 \\times 10^{-21}}$$", "id": "1477589"}, {"introduction": "一个成功的模拟严重依赖于选择一个稳定的积分步长 $\\Delta t$。步长过大会导致轨迹出现非物理性的爆炸性行为，从而使模拟失效。本练习将从算法实现转向理论分析，引导您通过稳定性分析，推导出在谐振子势中速度Verlet算法所允许的最大时间步长，这是理解数值积分器稳定性的基石。[@problem_id:2629491]", "problem": "在势能面上的经典轨道模拟中，积分时间步长决定了数值运动是否保持物理意义和有界性。考虑一个质量为 $m$ 的经典粒子在一维谐振子势能面 $V(x) = \\tfrac{1}{2} m \\omega^{2} x^{2}$ 上运动，其中 $\\omega$ 是由势能面在极小值附近的局部曲率定义的角频率。其精确动力学遵循牛顿第二定律 $m \\, \\ddot{x}(t) = - \\frac{dV}{dx} = - m \\omega^{2} x(t)$。假设该轨道使用固定时间步长 $\\Delta t$ 的速度Verlet格式进行积分。速度Verlet方法通过以下方式更新位置和速度：\n$$\nx_{n+1} = x_{n} + v_{n} \\, \\Delta t + \\tfrac{1}{2} a_{n} \\, \\Delta t^{2}, \\quad a_{n} = - \\omega^{2} x_{n}, \\quad a_{n+1} = - \\omega^{2} x_{n+1}, \\quad v_{n+1} = v_{n} + \\tfrac{1}{2} \\left(a_{n} + a_{n+1}\\right) \\Delta t,\n$$\n其中 $x_{n} \\equiv x(n \\Delta t)$ 且 $v_{n} \\equiv v(n \\Delta t)$。从牛顿第二定律和这个标准积分器出发，通过推导仅关于 $x_{n}$ 的齐次递推关系、确定放大因子，并施加所有数值轨道对于所有 $n$ 和任意初始条件都保持有界的条件，来分析离散动力学的线性稳定性。据此，推导出一个以 $\\omega$ 表示的闭式解析表达式，即确保数值运动有界的最大时间步长 $\\Delta t_{\\max}$。将最终答案表示为关于 $\\omega$ 的解析表达式。无需四舍五入。", "solution": "目标是确定使得一维谐振子的速度Verlet积分保持稳定的最大时间步长 $\\Delta t_{\\max}$。稳定性要求数值轨道对于所有时间步 $n$ 和任意初始条件都保持有界。该系统由势能 $V(x) = \\frac{1}{2} m \\omega^{2} x^{2}$ 描述，运动方程为 $m\\ddot{x} = -m\\omega^2 x$，由此可得加速度为 $a(x) = -\\omega^2 x$。\n\n速度Verlet算法为离散时间步 $t_n = n \\Delta t$ 时的位置 $x_n$ 和速度 $v_n$ 提供了以下更新规则：\n$$x_{n+1} = x_{n} + v_{n} \\Delta t + \\frac{1}{2} a_{n} \\Delta t^{2} \\quad (1)$$\n$$v_{n+1} = v_{n} + \\frac{1}{2} (a_{n} + a_{n+1}) \\Delta t \\quad (2)$$\n代入谐振子的特定加速度 $a_n = -\\omega^2 x_n$ 和 $a_{n+1} = -\\omega^2 x_{n+1}$，方程变为：\n$$x_{n+1} = x_{n} + v_{n} \\Delta t - \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2} \\quad (1)$$\n$$v_{n+1} = v_{n} - \\frac{1}{2} \\omega^2 (x_{n} + x_{n+1}) \\Delta t \\quad (2)$$\n为了分析位置坐标 $x_n$ 的稳定性，我们必须推导一个只涉及位置的递推关系。我们可以消去速度项。从方程 $(1)$，我们可以表示出 $v_n$：\n$$v_{n} \\Delta t = x_{n+1} - x_{n} + \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2}$$\n$$v_{n} = \\frac{x_{n+1} - x_{n}}{\\Delta t} + \\frac{1}{2} \\omega^2 x_{n} \\Delta t \\quad (3)$$\n这个关系对任何步 $n$ 都必须成立。通过将下标从 $n$ 移到 $n-1$，我们可以写出 $v_{n-1}$ 的表达式：\n$$v_{n-1} = \\frac{x_{n} - x_{n-1}}{\\Delta t} + \\frac{1}{2} \\omega^2 x_{n-1} \\Delta t \\quad (4)$$\n我们也可以将方程 $(2)$ 中的下标从 $n$ 移到 $n-1$，以关联 $v_n$ 和 $v_{n-1}$：\n$$v_{n} = v_{n-1} - \\frac{1}{2} \\omega^2 (x_{n-1} + x_{n}) \\Delta t \\quad (5)$$\n现在，我们将表达式 $(3)$ 和 $(4)$ 代入 $(5)$：\n$$\\frac{x_{n+1} - x_{n}}{\\Delta t} + \\frac{1}{2} \\omega^2 x_{n} \\Delta t = \\left( \\frac{x_{n} - x_{n-1}}{\\Delta t} + \\frac{1}{2} \\omega^2 x_{n-1} \\Delta t \\right) - \\frac{1}{2} \\omega^2 (x_{n-1} + x_{n}) \\Delta t$$\n为了简化，我们将整个方程乘以 $\\Delta t$：\n$$x_{n+1} - x_{n} + \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2} = (x_{n} - x_{n-1}) + \\frac{1}{2} \\omega^2 x_{n-1} \\Delta t^{2} - \\frac{1}{2} \\omega^2 (x_{n-1} + x_{n}) \\Delta t^{2}$$\n展开右侧的最后一项：\n$$x_{n+1} - x_{n} + \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2} = x_{n} - x_{n-1} + \\frac{1}{2} \\omega^2 x_{n-1} \\Delta t^{2} - \\frac{1}{2} \\omega^2 x_{n-1} \\Delta t^{2} - \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2}$$\n包含 $\\frac{1}{2}\\omega^2 x_{n-1} \\Delta t^{2}$ 的项相互抵消。我们得到：\n$$x_{n+1} - x_{n} + \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2} = x_{n} - x_{n-1} - \\frac{1}{2} \\omega^2 x_{n} \\Delta t^{2}$$\n重新整理各项，将 $x_{n+1}$、$x_n$ 和 $x_{n-1}$ 分组：\n$$x_{n+1} = 2x_{n} - x_{n-1} - \\omega^2 x_{n} \\Delta t^{2}$$\n$$x_{n+1} - (2 - \\omega^2 \\Delta t^{2})x_{n} + x_{n-1} = 0$$\n这就是 $x_n$ 的齐次线性递推关系。为了找到有界解的条件，我们考察其特征方程。我们假设解的形式为 $x_n = \\lambda^n$，其中 $\\lambda$ 是一个放大因子。将此代入递推关系得到：\n$$\\lambda^{n+1} - (2 - \\omega^2 \\Delta t^{2})\\lambda^{n} + \\lambda^{n-1} = 0$$\n两边同除以 $\\lambda^{n-1}$ (对于 $\\lambda \\neq 0$)，得到特征方程：\n$$\\lambda^2 - (2 - \\omega^2 \\Delta t^{2})\\lambda + 1 = 0$$\n为了使解 $x_n$ 对所有 $n$ 都保持有界，这个二次方程的根 $\\lambda$ 的模必须小于或等于1，即 $|\\lambda| \\le 1$。如果存在一个根的模 $|\\lambda| > 1$，解将呈指数增长并且是不稳定的。如果存在模为 $|\\lambda| = 1$ 的重根，解会随 $n$ 线性增长，这也是一个无界、不稳定的轨道。\n二次方程 $\\lambda^2 - C\\lambda + 1 = 0$ 的根由 $\\lambda = \\frac{C \\pm \\sqrt{C^2 - 4}}{2}$ 给出，其中 $C = 2 - \\omega^2 \\Delta t^2$。\n根的乘积为 $\\lambda_1 \\lambda_2 = 1$。如果根是实数且不相等（即 $C^2 > 4$），则必有一个根的模大于1。这会导致不稳定性。\n对于有界的振荡解，根必须是一对模为1的共轭复数。这在判别式为负时发生：\n$$C^2 - 4 < 0 \\implies C^2 < 4 \\implies |C| < 2$$\n代回 $C$ 的表达式：\n$$|2 - \\omega^2 \\Delta t^2| < 2$$\n这个不等式等价于以下两个不等式组成的系统：\n$$1) \\quad 2 - \\omega^2 \\Delta t^2 < 2 \\implies -\\omega^2 \\Delta t^2 < 0 \\implies \\omega^2 \\Delta t^2 > 0$$\n对于 $\\omega > 0$ 和 $\\Delta t > 0$，这个条件总是成立的。\n$$2) \\quad 2 - \\omega^2 \\Delta t^2 > -2 \\implies 4 > \\omega^2 \\Delta t^2$$\n由于 $\\omega > 0$ 且 $\\Delta t > 0$，我们可以对两边取平方根：\n$$\\omega \\Delta t < 2$$\n$$\\Delta t < \\frac{2}{\\omega}$$\n因此，稳定性判据是 $\\Delta t < 2/\\omega$。$\\omega \\Delta t = 2$ 的情况对应于 $C=-2$，这会得到一个重根 $\\lambda = -1$，从而导致线性增长和不稳定性。因此，对于任意初始条件下的有界运动，需要严格不等式。标记稳定区域边界的最大时间步长是稳定时间步长集合的上确界。\n这个值是 $\\Delta t_{\\max} = \\frac{2}{\\omega}$。", "answer": "$$\n\\boxed{\\frac{2}{\\omega}}\n$$", "id": "2629491"}, {"introduction": "真实的化学系统通常包含在截然不同时间尺度上发生的运动，例如快速的键振动和缓慢的构象变化，使用单一的小时间步长进行积分会非常低效。本练习介绍了一种高级技术——可逆参考系统传播算法（RESPA）——来高效处理此类系统。您将推导并实现这种多时间步长积分器，学习如何划分作用力，并探索基于物理直觉的划分方案对维持计算准确性和稳定性的关键作用。[@problem_id:2629512]", "problem": "考虑在一个一维势能面上进行经典轨道计算，该计算在约化单位下进行，其中质量 $m = 1$，时间单位为 $\\tau$，能量单位为 $\\varepsilon$。目标是设计并论证一种可逆参考系传播子算法 (RESPA)，它是一种用于势 $V(q)$ 上力分量可分离为快慢两部分的系统的多步长时间积分器，并提出相应地拆分 $V(q)$ 的策略。\n\n从 Hamilton 方程出发，通过将总力 $F(q)$ 分解为一个源于快势 $V_{\\mathrm{f}}(q)$ 的快分量 $F_{\\mathrm{f}}(q)$ 和一个源于慢势 $V_{\\mathrm{s}}(q)$ 的慢分量 $F_{\\mathrm{s}}(q)$，推导出一个时间可逆且辛的多步长方案，使得 $V(q) = V_{\\mathrm{f}}(q) + V_{\\mathrm{s}}(q)$ 且 $F(q) = F_{\\mathrm{f}}(q) + F_{\\mathrm{s}}(q)$。您的推导必须仅基于基本定律和核心定义（Hamilton 方程、牛顿第二定律、时间可逆性和辛性），且不得假定任何已有的多步长公式。根据 $V(q)$ 的结构及其曲率，使用具有物理意义的标准来论证该拆分策略，并解释当快力在比慢力更小的时间步长上求解时，为何您的方案是稳定且准确的。\n\n将您推导的算法实现为一个完整的程序。您的程序必须：\n- 使用约化无量纲单位。报告的每个数字都必须是无量纲的。\n- 计算符号相对能量漂移，其定义为 $\\Delta E_{\\mathrm{rel}} = \\dfrac{E(T) - E(0)}{E(0)}$，其中 $E(t) = \\dfrac{p(t)^2}{2 m} + V(q(t))$。\n- 使用标准的单步长时间速度Verlet积分器作为比较的基准。\n- 对于多步长方法，使用一个外部（慢）时间步长 $h$，并对快力使用 $M$ 个内部子步，子步大小为 $h/M$。\n\n拆分 $V(q)$ 的策略：为以下测试势提出并实现一种基于曲率和物理的拆分方法。具体来说，将高曲率（刚性）的谐波贡献视为快分量，将更平滑的非谐波贡献视为慢分量。在所有测试案例中，总势均为 $V(q) = \\dfrac{1}{2} k_{\\mathrm{f}} q^2 + \\lambda q^4$；您必须实现两种不同的拆分方式，以展示良好选择和不佳选择的后果：\n- 良好拆分：$V_{\\mathrm{f}}(q) = \\dfrac{1}{2} k_{\\mathrm{f}} q^2$ 和 $V_{\\mathrm{s}}(q) = \\lambda q^4$。\n- 不佳拆分：$V_{\\mathrm{f}}(q) = \\lambda q^4$ 和 $V_{\\mathrm{s}}(q) = \\dfrac{1}{2} k_{\\mathrm{f}} q^2$。\n\n测试套件。使用以下四个测试案例。对于每个案例，在 $q(0) = 1$ 和 $p(0) = 0$ 处初始化，使用指定的参数积分至最终时间 $T$，并报告 $\\Delta E_{\\mathrm{rel}}$：\n- 案例 1（多步长，良好拆分）： $k_{\\mathrm{f}} = 1000$，$\\lambda = 1$，外步长 $h = 0.05$，$M = 10$，总时间 $T = 20$。\n- 案例 2（多步长，不佳拆分）： $k_{\\mathrm{f}} = 1000$，$\\lambda = 1$，外步长 $h = 0.05$，$M = 10$，总时间 $T = 20$。\n- 案例 3（单步长基准，速度 Verlet）： $k_{\\mathrm{f}} = 1000$，$\\lambda = 1$，单步长 $\\Delta t = 0.005$，总时间 $T = 20$。\n- 案例 4（多步长，非常刚性的快模式，良好拆分）： $k_{\\mathrm{f}} = 5000$，$\\lambda = 1$，外步长 $h = 0.05$，$M = 25$，总时间 $T = 20$。\n\n您的实现必须使用 $E(q,p) = \\dfrac{p^2}{2} + \\dfrac{1}{2} k_{\\mathrm{f}} q^2 + \\lambda q^4$ 来计算能量，这与所选的拆分方式一致。不使用角度，因此不需要角度单位。所有输出都是无量纲实数。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按上述案例的顺序排列，并四舍五入到六位小数（例如，\"[$x_1, x_2, x_3, x_4]$\"）。\n\n您的程序必须是完全自包含的，不需要用户输入或外部文件。它必须同时实现单步长时间速度Verlet积分器和您推导的多步长 RESPA 积分器，以计算测试套件的指定指标。唯一可接受的输出是包含指定格式的四个浮点数列表的单行。", "solution": "经典分子动力学的基础是 Hamilton 运动方程的数值积分。对于一个具有哈密顿量 $H(q,p)$ 的一维系统，其中 $q$ 是广义坐标，$p$ 是共轭动量，这些方程是：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p}\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q}\n$$\n哈密顿量是动能 $T(p)$ 和势能 $V(q)$ 的和。在指定的约化单位中，质量 $m=1$，因此 $H(q,p) = T(p) + V(q) = \\frac{p^2}{2} + V(q)$。Hamilton 方程变为：\n$$\n\\dot{q} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial V}{\\partial q} = F(q)\n$$\n其中 $F(q)$ 是力。\n\n系统状态 $(q,p)$ 的时间演化可以形式上用 Liouville 算符 $iL = \\{ \\cdot, H \\}$ 描述，其中 $\\{ \\cdot, \\cdot \\}$ 是 Poisson 括号。时间 $t$ 时的状态由 $(q(t), p(t)) = e^{iLt} (q(0), p(0))$ 给出，其中 $e^{iLt}$ 是时间演化传播子。几何积分器，如速度 Verlet 算法，是通过分解 Liouville 算符并使用 Trotter-Suzuki 分解来推导的。总 Liouville 算符可以分解为动能部分和势能部分：$iL = iL_T + iL_V$。在时间步长 $\\delta t$ 内，各个传播子的作用是：\n- $e^{iL_T \\delta t}$：在恒定动量下传播位置（一次“漂移”）。$q(t+\\delta t) = q(t) + p(t)\\delta t$，其中 $p$ 不变。\n- $e^{iL_V \\delta t}$：在恒定位置下传播动量（一次“踢动”）。$p(t+\\delta t) = p(t) + F(q(t))\\delta t$，其中 $q$ 不变。\n\n标准的二阶精确且时间可逆的速度 Verlet 算法是通过对单个时间步长 $h$ 的传播子进行对称 Strang 分解推导出来的：\n$$\ne^{iLh} \\approx e^{iL_V h/2} e^{iL_T h} e^{iL_V h/2}\n$$\n这个算符序列转化为以下步骤：\n1. 对动量施加半个时间步长的踢动：$p(t+h/2) = p(t) + F(q(t)) \\frac{h}{2}$。\n2. 使用更新后的动量对位置施加一个完整时间步长的漂移：$q(t+h) = q(t) + p(t+h/2) h$。\n3. 使用新位置上的力对动量施加最后的半个时间步长的踢动：$p(t+h) = p(t+h/2) + F(q(t+h)) \\frac{h}{2}$。\n该算法是辛性的且时间可逆的，这是因为它是由分解后的哈密顿量的精确传播子对称组合而成的。\n\n对于具有时间尺度分离的系统，力 $F(q)$ 可以分解为一个快速变化的分量 $F_{\\mathrm{f}}(q)$ 和一个缓慢变化的分量 $F_{\\mathrm{s}}(q)$，其中 $F(q) = F_{\\mathrm{f}}(q) + F_{\\mathrm{s}}(q)$。这种分解源于势能的相应分解：$V(q) = V_{\\mathrm{f}}(q) + V_{\\mathrm{s}}(q)$。Liouville 算符随后被分解为三部分：$iL = iL_T + iL_{\\mathrm{f}} + iL_{\\mathrm{s}}$。参考系传播子算法 (RESPA) 是一种通过应用进一步的 Trotter 分解推导出的多步长方法。我们将慢力视为最外层算符，将其对称地分解在剩余“快”子系统（包括动能运动和快力）的传播子两侧。对于一个大时间步长 $h$，传播子是：\n$$\nU(h) \\approx e^{iL_{\\mathrm{s}} h/2} \\left[ e^{(iL_T + iL_{\\mathrm{f}})h} \\right] e^{iL_{\\mathrm{s}} h/2}\n$$\n中心部分 $U_{\\mathrm{fast}}(h) = e^{(iL_T + iL_{\\mathrm{f}})h}$ 传播一个由哈密顿量 $H_{\\mathrm{fast}} = T(p) + V_{\\mathrm{f}}(q)$ 控制的参考系统。由于该系统仍包含高频运动，其在时间 $h$ 内的演化必须用更小的时间步长进行积分。我们将区间 $h$ 分为 $M$ 个大小为 $\\delta t = h/M$ 的子区间。快子系统的传播子随后近似为 $M$ 个短步长传播子的序列：\n$$\nU_{\\mathrm{fast}}(h) = \\left( e^{(iL_T + iL_{\\mathrm{f}})\\delta t} \\right)^M\n$$\n每个小步长传播子 $U_{\\mathrm{fast}}(\\delta t)$ 本身也使用类似于速度 Verlet 的对称 Strang 分解来构建：\n$$\ne^{(iL_T + iL_{\\mathrm{f}})\\delta t} \\approx e^{iL_{\\mathrm{f}} \\delta t/2} e^{iL_T \\delta t} e^{iL_{\\mathrm{f}} \\delta t/2}\n$$\n结合这些元素便得到完整的 RESPA 传播子。单个步长 $h$ 的算法实现如下：\n1. 对慢力施加半个时间步长的踢动：$p \\leftarrow p + F_{\\mathrm{s}}(q) \\frac{h}{2}$。\n2. 对 $i=1, ..., M$ 执行内循环：\n    a. 对快力施加半个子步的踢动：$p \\leftarrow p + F_{\\mathrm{f}}(q) \\frac{\\delta t}{2}$。\n    b. 施加一个完整子步的漂移：$q \\leftarrow q + p \\cdot \\delta t$。\n    c. 再次对快力施加半个子步的踢动：$p \\leftarrow p + F_{\\mathrm{f}}(q) \\frac{\\delta t}{2}$。\n3. 对慢力施加最后的半个时间步长的踢动：$p \\leftarrow p + F_{\\mathrm{s}}(q) \\frac{h}{2}$。\n从构造上看，该算法是时间可逆且辛的，因为它是辛映射的对称组合。只要最小时间步长 $\\delta t$ 足以分辨最高频率的运动（来自 $F_{\\mathrm{f}}$），并且最大时间步长 $h$ 足以分辨由慢力 $F_{\\mathrm{s}}$ 引起的运动，该算法就是准确和稳定的。\n\n势的拆分策略至关重要。“快”力是指在短距离内变化显著的力，这意味着高频运动。这与势能面的曲率在数量上相关。对于我们的一维势 $V(q)$，局部“刚度”由其二阶导数 $V''(q)$ 给出。较大的 $V''(q)$ 值对应于必须用小时间步长积分的高频模式。\n测试势为 $V(q) = \\frac{1}{2} k_{\\mathrm{f}} q^2 + \\lambda q^4$。其二阶导数是：\n$$\nV''(q) = k_{\\mathrm{f}} + 12 \\lambda q^2\n$$\n- **良好拆分**：$V_{\\mathrm{f}}(q) = \\frac{1}{2} k_{\\mathrm{f}} q^2$ 和 $V_{\\mathrm{s}}(q) = \\lambda q^4$。此处，$V''_{\\mathrm{f}}(q) = k_{\\mathrm{f}}$ 且 $V''_{\\mathrm{s}}(q) = 12 \\lambda q^2$。鉴于在所考虑的运动振幅（从 $q=1$ 开始）下，参数 $k_{\\mathrm{f}}$（例如 $1000$ 或 $5000$）远大于 $12 \\lambda q^2$，谐波项贡献了主导的高频分量。将此刚性项分配给快势 $V_{\\mathrm{f}}$ 是物理上正确的选择。将更平滑的非谐波项分配给慢势 $V_{\\mathrm{s}}$ 也是正确的。\n- **不佳拆分**：$V_{\\mathrm{f}}(q) = \\lambda q^4$ 和 $V_{\\mathrm{s}}(q) = \\frac{1}{2} k_{\\mathrm{f}} q^2$。这个选择颠倒了逻辑。势的最刚性分量被分配给了慢力 $F_{\\mathrm{s}}(q) = -k_{\\mathrm{f}} q$，而该力仅用大时间步长 $h$ 进行更新。这是一个灾难性的错误，因为高频振荡将完全无法被解析，从而导致巨大的积分误差和数值不稳定性。多步长方法的目的也因此失效。\n\n下面的程序实现了这些积分器和拆分策略，用于计算指定测试案例的符号相对能量漂移 $\\Delta E_{\\mathrm{rel}} = (E(T) - E(0))/E(0)$。结果将展示正确配置的 RESPA 方法相比于错误配置的方法具有更优越的能量守恒性，并与标准的单步长时间速度 Verlet 积分器进行基准比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a RESPA multiple-timestep integrator\n    against a standard velocity Verlet integrator for a 1D anharmonic oscillator.\n    \"\"\"\n\n    # --- Potential and Force Definitions ---\n    # The mass m is 1 in reduced units.\n\n    def get_total_potential(kf, lam):\n        \"\"\"Returns the total potential energy function V(q).\"\"\"\n        def V(q):\n            return 0.5 * kf * q**2 + lam * q**4\n        return V\n\n    def get_total_force(kf, lam):\n        \"\"\"Returns the total force function F(q) = -dV/dq.\"\"\"\n        def F(q):\n            return -kf * q - 4.0 * lam * q**3\n        return F\n\n    # Functions for the \"good\" potential splitting\n    def get_fast_force_good(kf, lam):\n        \"\"\"Returns the fast force for the good split.\"\"\"\n        def F_fast(q):\n            return -kf * q\n        return F_fast\n\n    def get_slow_force_good(kf, lam):\n        \"\"\"Returns the slow force for the good split.\"\"\"\n        def F_slow(q):\n            return -4.0 * lam * q**3\n        return F_slow\n\n    # Functions for the \"poor\" potential splitting\n    def get_fast_force_poor(kf, lam):\n        \"\"\"Returns the fast force for the poor split.\"\"\"\n        def F_fast(q):\n            return -4.0 * lam * q**3\n        return F_fast\n\n    def get_slow_force_poor(kf, lam):\n        \"\"\"Returns the slow force for the poor split.\"\"\"\n        def F_slow(q):\n            return -kf * q\n        return F_slow\n\n    # --- Integrator Implementations ---\n\n    def velocity_verlet(q0, p0, dt, num_steps, force_func):\n        \"\"\"\n        Standard single-timestep velocity Verlet integrator.\n        \"\"\"\n        q, p = float(q0), float(p0)\n        \n        # This implementation follows the standard velocity Verlet form.\n        # It requires one force evaluation per step in a leapfrog scheme, but\n        # is written here with two for clarity of a single step's logic.\n        for _ in range(num_steps):\n            p_half = p + force_func(q) * dt / 2.0\n            q_new = q + p_half * dt\n            p = p_half + force_func(q_new) * dt / 2.0\n            q = q_new\n            \n        return q, p\n\n    def respa_integrator(q0, p0, h, M, num_outer_steps, F_fast_func, F_slow_func):\n        \"\"\"\n        RESPA multiple-timestep integrator based on symmetric Trotter splitting.\n        \"\"\"\n        q, p = float(q0), float(p0)\n        dt_fast = h / float(M)\n\n        for _ in range(num_outer_steps):\n            # 1. First half-kick with the slow force\n            p += F_slow_func(q) * h / 2.0\n\n            # 2. Inner loop: M steps with the fast force and kinetic term\n            for _ in range(M):\n                # Velocity Verlet for the fast subsystem for a timestep dt_fast\n                p += F_fast_func(q) * dt_fast / 2.0\n                q += p * dt_fast\n                p += F_fast_func(q) * dt_fast / 2.0\n\n            # 3. Second half-kick with the slow force\n            p += F_slow_func(q) * h / 2.0\n            \n        return q, p\n\n    # --- Test Suite Execution ---\n\n    test_cases = [\n        {'type': 'respa', 'split': 'good', 'kf': 1000.0, 'lam': 1.0, 'h': 0.05, 'M': 10, 'T': 20.0},\n        {'type': 'respa', 'split': 'poor', 'kf': 1000.0, 'lam': 1.0, 'h': 0.05, 'M': 10, 'T': 20.0},\n        {'type': 'verlet', 'split': None, 'kf': 1000.0, 'lam': 1.0, 'dt': 0.005, 'T': 20.0},\n        {'type': 'respa', 'split': 'good', 'kf': 5000.0, 'lam': 1.0, 'h': 0.05, 'M': 25, 'T': 20.0}\n    ]\n\n    results = []\n    q0, p0 = 1.0, 0.0\n\n    for case in test_cases:\n        kf, lam, T = case['kf'], case['lam'], case['T']\n        \n        potential_func = get_total_potential(kf, lam)\n        E0 = potential_func(q0)  # p0 is 0, so initial energy is just potential energy\n\n        if case['type'] == 'respa':\n            h, M = case['h'], case['M']\n            num_outer_steps = int(round(T / h))\n            \n            if case['split'] == 'good':\n                F_fast = get_fast_force_good(kf, lam)\n                F_slow = get_slow_force_good(kf, lam)\n            else: # poor split\n                F_fast = get_fast_force_poor(kf, lam)\n                F_slow = get_slow_force_poor(kf, lam)\n            \n            q_final, p_final = respa_integrator(q0, p0, h, M, num_outer_steps, F_fast, F_slow)\n        \n        else: # verlet\n            dt = case['dt']\n            num_steps = int(round(T / dt))\n            F_total = get_total_force(kf, lam)\n            \n            q_final, p_final = velocity_verlet(q0, p0, dt, num_steps, F_total)\n\n        E_final = 0.5 * p_final**2 + potential_func(q_final)\n        \n        if abs(E0) < 1e-9:\n             # Handle case where initial energy is zero to avoid division by zero\n            delta_E_rel = E_final - E0\n        else:\n            delta_E_rel = (E_final - E0) / E0\n        \n        results.append(delta_E_rel)\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2629512"}]}