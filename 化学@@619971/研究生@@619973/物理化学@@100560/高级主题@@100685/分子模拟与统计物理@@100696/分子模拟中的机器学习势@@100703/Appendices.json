{"hands_on_practices": [{"introduction": "将物理对称性直接构建到机器学习模型中，对于其预测的准确性和泛化能力至关重要。本练习旨在探讨旋转等变性，这是任何可靠的原子间势都必须满足的基本性质，即力矢量必须与分子几何结构以相同的方式旋转。通过手动计算和比较旋转前后的力，你将具体地理解这一核心物理约束。[@problem_id:2648608]", "problem": "考虑一个三原子体系，其原子位置在固定实验室坐标系中为 $\\mathbf{r}_1$、$\\mathbf{r}_2$ 和 $\\mathbf{r}_3$。三维空间中的旋转由特殊正交群 $\\mathrm{SO}(3)$ 中的一个元素表示，刚性旋转对位置的作用为 $\\mathbf{r}_i \\mapsto \\mathbf{R}\\,\\mathbf{r}_i$，其中 $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ 且 $\\det \\mathbf{R} = 1$。在遵守特殊欧几里得群 $\\mathrm{SE}(3)$ 对称性的机器学习原子间势中，标量特征是旋转不变的，而矢量和高阶张量特征在旋转 $\\mathbf{R}$ 下等变地变换。力是通过标量能量对原子位置的负梯度得到的，因此，如果能量是旋转不变的，力在旋转下必须像矢量一样变换。\n\n设原子位置（单位一致但任意）为\n$\\mathbf{r}_1 = (0,\\,0,\\,0)$、$\\mathbf{r}_2 = (1,\\,0,\\,0)$ 和 $\\mathbf{r}_3 = (0,\\,1,\\,0)$。考虑旋转矩阵\n$$\n\\mathbf{R} \\;=\\;\n\\begin{pmatrix}\n0 & -1 & 0 \\\\\n1 & \\;\\,0 & 0 \\\\\n0 & \\;\\,0 & 1\n\\end{pmatrix},\n$$\n该矩阵将矢量绕 z 轴旋转 $90$ 度。为每个无序对 $(i,j)$ 定义以下成对特征：\n- 标量不变特征 $g^{(0)}_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n- 矢量等变特征 $\\mathbf{g}^{(1)}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。\n\n假设一个能量模型，该模型仅依赖于由这些特征构建的标量不变量，即相同谐振对项的和，\n$$\nE(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) \\;=\\; \\frac{k}{2}\\,\\sum_{1 \\le i < j \\le 3} \\Big(\\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_0\\Big)^2,\n$$\n其中劲度系数 $k > 0$，平衡长度 $d_0 = 1$。作用在原子 $i$ 上的力定义为 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$。\n\n任务：\n1. 仅使用上述定义和旋转的性质，确定 $\\mathbf{g}^{(1)}_{ij}$ 在 $\\mathbf{r}_i \\mapsto \\mathbf{R}\\mathbf{r}_i$ 变换下的变换方式，并为给定的构型和 $\\mathbf{R}$ 计算显式的变换后矢量特征 $\\mathbf{R}\\,\\mathbf{g}^{(1)}_{23}$。\n2. 从 $E$ 的定义和链式法则出发，推导单个原子对的 $\\mathbf{F}_i$，然后计算给定构型下的总力 $\\mathbf{F}_1$、$\\mathbf{F}_2$ 和 $\\mathbf{F}_3$。\n3. 对计算出的力应用旋转 $\\mathbf{R}$，得到旋转后的力 $\\mathbf{F}'_i = \\mathbf{R}\\,\\mathbf{F}_i$。\n4. 通过从旋转后的位置 $\\mathbf{r}'_i = \\mathbf{R}\\,\\mathbf{r}_i$ 重新计算力，独立地验证它们与步骤 3 中得到的 $\\mathbf{F}'_i$ 一致。\n将由旋转后的力按顺序 $\\big(F'_{1x}, F'_{1y}, F'_{1z}, F'_{2x}, F'_{2y}, F'_{2z}, F'_{3x}, F'_{3y}, F'_{3z}\\big)$ 组成的 9 分量行向量作为最终答案。最终方框内的答案不包含单位。如果选择化简根式，请保留精确形式；不需要四舍五入。", "solution": "问题陈述已经过验证，被认为是具有科学依据、适定的、客观且完整的。这是将矢量微积分和线性代数应用于分子建模物理原理的一个标准练习。我将开始解答。\n\n该问题要求系统地证明从旋转不变势能函数推导出的力的旋转等变性。将按顺序完成这四个任务。\n\n任务 1：$\\mathbf{g}^{(1)}_{ij}$ 的变换及 $\\mathbf{R}\\,\\mathbf{g}^{(1)}_{23}$ 的计算。\n\n矢量特征定义为 $\\mathbf{g}^{(1)}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。在旋转 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 下，原子位置变换为 $\\mathbf{r}_i \\mapsto \\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_i$。因此，变换后的特征 $\\mathbf{g'}^{(1)}_{ij}$ 为：\n$$\n\\mathbf{g'}^{(1)}_{ij} = \\mathbf{r}'_i - \\mathbf{r}'_j = \\mathbf{R}\\mathbf{r}_i - \\mathbf{R}\\mathbf{r}_j = \\mathbf{R}(\\mathbf{r}_i - \\mathbf{r}_j) = \\mathbf{R}\\mathbf{g}^{(1)}_{ij}\n$$\n这证明了 $\\mathbf{g}^{(1)}_{ij}$ 在旋转下作为矢量是等变变换的。\n\n对于给定的构型，$\\mathbf{r}_2 = (1, 0, 0)^{\\top}$ 且 $\\mathbf{r}_3 = (0, 1, 0)^{\\top}$。矢量特征 $\\mathbf{g}^{(1)}_{23}$ 是：\n$$\n\\mathbf{g}^{(1)}_{23} = \\mathbf{r}_2 - \\mathbf{r}_3 = (1, 0, 0)^{\\top} - (0, 1, 0)^{\\top} = (1, -1, 0)^{\\top}\n$$\n变换后的矢量特征是 $\\mathbf{R}\\mathbf{g}^{(1)}_{23}$。使用给定的旋转矩阵 $\\mathbf{R}$：\n$$\n\\mathbf{R}\\mathbf{g}^{(1)}_{23} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (0)(1) + (-1)(-1) + (0)(0) \\\\ (1)(1) + (0)(-1) + (0)(0) \\\\ (0)(1) + (0)(-1) + (1)(0) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n\n任务 2：力 $\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3$ 的推导与计算。\n\n能量 $E$ 由 $E = \\frac{k}{2} \\sum_{1 \\le i < j \\le 3} (\\|\\mathbf{r}_{ij}\\| - d_0)^2$ 给出，其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。作用在原子 $l$ 上的力是 $\\mathbf{F}_l = -\\nabla_{\\mathbf{r}_l} E$。\n$$\n\\mathbf{F}_l = -\\nabla_{\\mathbf{r}_l} \\left[ \\frac{k}{2} \\sum_{i<j} (\\|\\mathbf{r}_{ij}\\| - d_0)^2 \\right] = -\\frac{k}{2} \\sum_{i<j} \\nabla_{\\mathbf{r}_l} (\\|\\mathbf{r}_{ij}\\| - d_0)^2\n$$\n梯度 $\\nabla_{\\mathbf{r}_l}$ 仅对包含 $\\mathbf{r}_l$ 的项（即原子对 $(l,j)$ 或 $(i,l)$）非零。这可以写成对 $j \\neq l$ 的求和。\n$$\n\\mathbf{F}_l = -\\sum_{j \\neq l} \\nabla_{\\mathbf{r}_l} \\left[ \\frac{k}{2} (\\|\\mathbf{r}_{lj}\\| - d_0)^2 \\right]\n$$\n使用链式法则 $\\nabla_{\\mathbf{x}} f(\\|\\mathbf{x}\\|) = f'(\\|\\mathbf{x}\\|) \\frac{\\mathbf{x}}{\\|\\mathbf{x}\\|}$，并注意到 $\\nabla_{\\mathbf{r}_l} \\|\\mathbf{r}_l - \\mathbf{r}_j\\| = \\frac{\\mathbf{r}_l - \\mathbf{r}_j}{\\|\\mathbf{r}_l - \\mathbf{r}_j\\|} = \\hat{\\mathbf{r}}_{lj}$，我们得到：\n$$\n\\nabla_{\\mathbf{r}_l} \\left[ \\frac{k}{2} (\\|\\mathbf{r}_{lj}\\| - d_0)^2 \\right] = \\frac{k}{2} \\cdot 2(\\|\\mathbf{r}_{lj}\\| - d_0) \\cdot \\hat{\\mathbf{r}}_{lj} = k (\\|\\mathbf{r}_{lj}\\| - d_0) \\hat{\\mathbf{r}}_{lj}\n$$\n因此，作用在原子 $l$ 上的总力为：\n$$\n\\mathbf{F}_l = -\\sum_{j \\neq l} k (\\|\\mathbf{r}_{lj}\\| - d_0) \\frac{\\mathbf{r}_{lj}}{\\|\\mathbf{r}_{lj}\\|}\n$$\n给定的位置是 $\\mathbf{r}_1 = (0,0,0)^{\\top}$、$\\mathbf{r}_2 = (1,0,0)^{\\top}$、$\\mathbf{r}_3 = (0,1,0)^{\\top}$ 且 $d_0 = 1$。原子间距离为：\n$$\nr_{12} = \\|\\mathbf{r}_1 - \\mathbf{r}_2\\| = \\|(-1, 0, 0)\\| = 1 \\\\\nr_{13} = \\|\\mathbf{r}_1 - \\mathbf{r}_3\\| = \\|(0, -1, 0)\\| = 1 \\\\\nr_{23} = \\|\\mathbf{r}_2 - \\mathbf{r}_3\\| = \\|(1, -1, 0)\\| = \\sqrt{1^2 + (-1)^2} = \\sqrt{2}\n$$\n现在我们计算力：\n对原子 1：\n$$\n\\mathbf{F}_1 = -k(r_{12}-d_0)\\hat{\\mathbf{r}}_{12} -k(r_{13}-d_0)\\hat{\\mathbf{r}}_{13} = -k(1-1)\\hat{\\mathbf{r}}_{12} -k(1-1)\\hat{\\mathbf{r}}_{13} = \\mathbf{0}\n$$\n对原子 2：\n$$\n\\mathbf{F}_2 = -k(r_{21}-d_0)\\hat{\\mathbf{r}}_{21} -k(r_{23}-d_0)\\hat{\\mathbf{r}}_{23} = -k(1-1)\\hat{\\mathbf{r}}_{21} -k(\\sqrt{2}-1)\\frac{\\mathbf{r}_{23}}{r_{23}} = -k(\\sqrt{2}-1)\\frac{(1, -1, 0)^{\\top}}{\\sqrt{2}} = k(1-\\frac{\\sqrt{2}}{2})(-1, 1, 0)^{\\top}\n$$\n对原子 3：\n$$\n\\mathbf{F}_3 = -k(r_{31}-d_0)\\hat{\\mathbf{r}}_{31} -k(r_{32}-d_0)\\hat{\\mathbf{r}}_{32} = -k(1-1)\\hat{\\mathbf{r}}_{31} -k(\\sqrt{2}-1)\\frac{\\mathbf{r}_{32}}{r_{32}} = -k(\\sqrt{2}-1)\\frac{(-1, 1, 0)^{\\top}}{\\sqrt{2}} = k(1-\\frac{\\sqrt{2}}{2})(1, -1, 0)^{\\top}\n$$\n对于孤立系统，总力 $\\mathbf{F}_1 + \\mathbf{F}_2 + \\mathbf{F}_3 = \\mathbf{0}$，符合要求。\n\n任务 3：对力应用旋转 $\\mathbf{R}$。\n\n我们计算旋转后的力 $\\mathbf{F}'_i = \\mathbf{R}\\mathbf{F}_i$。令 $C = k(1-\\frac{\\sqrt{2}}{2})$。\n$$\n\\mathbf{F}'_1 = \\mathbf{R}\\mathbf{F}_1 = \\mathbf{R}\\mathbf{0} = \\mathbf{0}\n$$\n$$\n\\mathbf{F}_2 = C(-1, 1, 0)^{\\top} \\implies \\mathbf{F}'_2 = \\mathbf{R}\\begin{pmatrix} -C \\\\ C \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} -C \\\\ C \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -C \\\\ -C \\\\ 0 \\end{pmatrix} = C(-1, -1, 0)^{\\top}\n$$\n$$\n\\mathbf{F}_3 = C(1, -1, 0)^{\\top} \\implies \\mathbf{F}'_3 = \\mathbf{R}\\begin{pmatrix} C \\\\ -C \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} C \\\\ -C \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} C \\\\ C \\\\ 0 \\end{pmatrix} = C(1, 1, 0)^{\\top}\n$$\n所以，旋转后的力为 $\\mathbf{F}'_1 = (0,0,0)^{\\top}$、$\\mathbf{F}'_2 = k(1-\\frac{\\sqrt{2}}{2})(-1, -1, 0)^{\\top}$ 和 $\\mathbf{F}'_3 = k(1-\\frac{\\sqrt{2}}{2})(1, 1, 0)^{\\top}$。\n\n任务 4：通过从旋转后的位置重新计算力进行验证。\n\n首先，我们计算旋转后的位置 $\\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_i$：\n$$\n\\mathbf{r}'_1 = \\mathbf{R}\\mathbf{r}_1 = (0,0,0)^{\\top} \\\\\n\\mathbf{r}'_2 = \\mathbf{R}\\mathbf{r}_2 = \\mathbf{R}(1,0,0)^{\\top} = (0,1,0)^{\\top} \\\\\n\\mathbf{r}'_3 = \\mathbf{R}\\mathbf{r}_3 = \\mathbf{R}(0,1,0)^{\\top} = (-1,0,0)^{\\top}\n$$\n新的距离 $r'_{ij}$ 是：\n$$\nr'_{12} = \\|\\mathbf{r}'_1 - \\mathbf{r}'_2\\| = \\|(0, -1, 0)\\| = 1 \\\\\nr'_{13} = \\|\\mathbf{r}'_1 - \\mathbf{r}'_3\\| = \\|(1, 0, 0)\\| = 1 \\\\\nr'_{23} = \\|\\mathbf{r}'_2 - \\mathbf{r}'_3\\| = \\|(1, 1, 0)\\| = \\sqrt{2}\n$$\n距离在旋转下是不变的，正如所预期的。我们现在计算这个新构型中的力 $\\mathbf{F}^{\\mathrm{new}}_i$：\n$$\n\\mathbf{F}^{\\mathrm{new}}_1 = -k(r'_{12}-d_0)\\hat{\\mathbf{r}}'_{12} -k(r'_{13}-d_0)\\hat{\\mathbf{r}}'_{13} = \\mathbf{0}\n$$\n这与 $\\mathbf{F}'_1$ 一致。\n$$\n\\mathbf{F}^{\\mathrm{new}}_2 = -k(r'_{21}-d_0)\\hat{\\mathbf{r}}'_{21} -k(r'_{23}-d_0)\\hat{\\mathbf{r}}'_{23} = -k(\\sqrt{2}-1)\\frac{\\mathbf{r}'_{23}}{r'_{23}} = -k(\\sqrt{2}-1)\\frac{(1, 1, 0)^{\\top}}{\\sqrt{2}} = k(1-\\frac{\\sqrt{2}}{2})(-1, -1, 0)^{\\top}\n$$\n使用 $C=k(1-\\frac{\\sqrt{2}}{2})$，我们有 $\\mathbf{F}^{\\mathrm{new}}_2 = -C(1,1,0)^{\\top} = C(-1,-1,0)^{\\top}$。这与 $\\mathbf{F}'_2$ 一致。\n$$\n\\mathbf{F}^{\\mathrm{new}}_3 = -k(r'_{31}-d_0)\\hat{\\mathbf{r}}'_{31} -k(r'_{32}-d_0)\\hat{\\mathbf{r}}'_{32} = -k(\\sqrt{2}-1)\\frac{\\mathbf{r}'_{32}}{r'_{32}} = -k(\\sqrt{2}-1)\\frac{(-1, -1, 0)^{\\top}}{\\sqrt{2}} = k(1-\\frac{\\sqrt{2}}{2})(1, 1, 0)^{\\top}\n$$\n这是 $C(1,1,0)^{\\top}$，与 $\\mathbf{F}'_3$ 一致。\n验证成功：从旋转后的坐标计算得到的力，与将原始坐标下计算出的力进行旋转后得到的结果一致。这证实了力矢量的旋转等变性。\n\n最终答案是由旋转后的力 $\\mathbf{F}'_1, \\mathbf{F}'_2, \\mathbf{F}'_3$ 的分量构成的 9 分量行向量。这些分量是：\n$$\n\\mathbf{F}'_1 = (0, 0, 0) \\\\\n\\mathbf{F}'_2 = k \\left( \\frac{\\sqrt{2}}{2}-1, \\frac{\\sqrt{2}}{2}-1, 0 \\right) \\\\\n\\mathbf{F}'_3 = k \\left( 1-\\frac{\\sqrt{2}}{2}, 1-\\frac{\\sqrt{2}}{2}, 0 \\right)\n$$\n将这些组合成一个单一的行向量，即可得到最终结果。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & 0 & 0 & k\\left(\\frac{\\sqrt{2}}{2}-1\\right) & k\\left(\\frac{\\sqrt{2}}{2}-1\\right) & 0 & k\\left(1-\\frac{\\sqrt{2}}{2}\\right) & k\\left(1-\\frac{\\sqrt{2}}{2}\\right) & 0 \\end{pmatrix}}\n$$", "id": "2648608"}, {"introduction": "相比于总能量，通过电子结构计算获得的力数据通常更为丰富，因此机器学习势函数常常基于力进行训练。本实践将指导你通过对含噪声的力数据进行数值积分，来构建一个物理上自洽的一维势能面，这一原则被称为构建保守场。这个编程练习将展示如何保证 $F = - \\nabla E$ 这一基本关系得到满足，并量化最终模型的精度。[@problem_id:2648595]", "problem": "您的任务是以科学原理为基础，根据带噪声的力标签构建一维机器学习势能模型，并在固定的评估网格上量化能量预测误差。其基本原理是，在一维空间中，一个力场是保守的，等价于存在一个标量能量函数，其负梯度等于该力。具体而言，对于位置 $x$、力 $F(x)$ 和能量 $E(x)$，其定义关系为 $F(x) = - \\frac{dE(x)}{dx}$，能量差满足 $E(x) - E(x_{0}) = - \\int_{x_{0}}^{x} F(u)\\,du$。所有量均为无量纲。您的程序必须是完全确定性的，并且不应读取任何输入。\n\n您的程序必须为每个指定的测试用例实现以下内容：\n- 基准能量和力。精确能量为双势阱形式 $E_{\\mathrm{true}}(x) = a\\,\\big(x^{2} - b^{2}\\big)^{2} + c\\,x$，精确力为 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -4\\,a\\,x\\,(x^{2}-b^{2}) - c$，其中 $a$、$b$ 和 $c$ 是给定参数。\n- 训练点采样。必须通过以下两种方案之一，在区间 $\\left[-L, L\\right]$ 内选择一组包含 $N$ 个训练位置的集合 $\\{x_{i}\\}_{i=1}^{N}$：\n  - 均匀采样：$x_{i}$ 在 $\\left[-L,L\\right]$ 内等距分布。\n  - 非均匀采样（三次扭曲）：定义 $u_{i}$ 在 $\\left[-1,1\\right]$ 内等距分布，并设置 $x_{i} = L\\,\\mathrm{sign}(u_{i})\\,|u_{i}|^{3}$。\n- 带噪声的力标签。对于每个 $x_{i}$，计算 $F_{\\mathrm{true}}(x_{i})$ 并添加标准差为 $\\sigma$ 的独立高斯噪声，以获得 $F_{\\mathrm{noisy}}(x_{i})$。使用固定的伪随机生成器种子 $2025$，以确保噪声在不同运行和用例中是可复现的。\n- 保守三次样条拟合。通过最小化标准的平滑样条目标函数，将三次平滑样条 $\\mathcal{S}_{F}(x)$ 拟合到数据 $\\{(x_{i}, F_{\\mathrm{noisy}}(x_{i}))\\}_{i=1}^{N}$，其中平滑因子 $s$ 设为 $s = \\sigma^{2}\\,N$。然后，通过保守积分，使用拟合的 $\\mathcal{S}_{F}(x)$ 来定义能量预测器：\n  - 固定参考位置 $x_{\\mathrm{ref}} = 0$。\n  - 将预测能量定义为 $\\widehat{E}(x) = E_{\\mathrm{true}}(x_{\\mathrm{ref}}) - \\int_{x_{\\mathrm{ref}}}^{x} \\mathcal{S}_{F}(u)\\,du$。此选择通过锚定在 $x_{\\mathrm{ref}}$ 来确保模型是一个保守场，并消除了任意的能量常数。\n- 误差评估。在一个包含 $M=501$ 个点的均匀评估网格（区间为 $\\left[-L,L\\right]$）上，计算能量的均方根误差：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{j=1}^{M}\\Big(\\widehat{E}(x^{\\mathrm{eval}}_{j}) - E_{\\mathrm{true}}(x^{\\mathrm{eval}}_{j})\\Big)^{2}}.\n$$\n所有能量和力均为无量纲。\n\n为以下测试套件实现上述过程（每个用例指定 $(a,b,c,L,N,\\sigma,\\text{sampling})$）：\n- 用例 1: $(a=\\!1.0,\\,b=\\!1.0,\\,c=\\!0.1,\\,L=\\!2.0,\\,N=\\!51,\\,\\sigma=\\!0.1,\\,\\text{均匀采样})$。\n- 用例 2: $(a=\\!0.5,\\,b=\\!1.2,\\,c=\\!0.0,\\,L=\\!2.0,\\,N=\\!41,\\,\\sigma=\\!0.01,\\,\\text{均匀采样})$。\n- 用例 3: $(a=\\!1.0,\\,b=\\!0.8,\\,c=\\!0.0,\\,L=\\!1.6,\\,N=\\!31,\\,\\sigma=\\!0.3,\\,\\text{均匀采样})$。\n- 用例 4: $(a=\\!1.0,\\,b=\\!1.0,\\,c=\\!0.2,\\,L=\\!2.0,\\,N=\\!7,\\,\\sigma=\\!0.05,\\,\\text{均匀采样})$。\n- 用例 5: $(a=\\!0.8,\\,b=\\!1.0,\\,c=\\!0.0,\\,L=\\!2.0,\\,N=\\!51,\\,\\sigma=\\!0.1,\\,\\text{非均匀采样})$。\n\n您的程序应按上述顺序计算每个用例的能量 $\\mathrm{RMSE}$，并输出单行结果，该结果为一个用方括号括起来的逗号分隔列表。输出列表中的每个数字必须是十进制表示，并精确到小数点后六位。例如，一个包含三个用例的输出必须如下所示：$[\\text{0.123456},\\text{0.234567},\\text{0.345678}]$。由于该问题完全使用无量纲量，因此不需要进行物理单位转换。不使用角度。不使用百分比；所有数字均以小数形式报告。", "solution": "所提出的问题是计算物理学中一个明确定义的练习，具体涉及从模拟的力数据构建机器学习势能模型。该问题具有科学依据、内部一致，并要求应用标准的、可验证的数值方法。因此，该问题被认定为有效。解决方案如下。\n\n核心原理是，对于一维保守系统，在位置 $x$ 处的力 $F(x)$ 是势能 $E(x)$ 的负导数，表达式为 $F(x) = -\\frac{dE(x)}{dx}$。因此，两点 $x_0$ 和 $x$ 之间的能量差可以通过对力进行积分得到：\n$$\nE(x) - E(x_0) = -\\int_{x_0}^{x} F(u) \\, du\n$$\n任务是从一组有限的、带噪声的力测量值中重建函数 $E(x)$。\n\n首先，我们定义基准模型。真实势能由一个带有线性倾斜的双势阱函数给出：\n$$\nE_{\\mathrm{true}}(x) = a(x^2 - b^2)^2 + cx\n$$\n相应的真实力是其负导数：\n$$\nF_{\\mathrm{true}}(x) = -4ax(x^2 - b^2) - c\n$$\n其中 $a$、$b$ 和 $c$ 是指定参数。\n\n其次，我们生成训练数据。在区间 $[-L, L]$ 内采样一组 $N$ 个训练位置 $\\{x_i\\}_{i=1}^N$。指定了两种不同的采样方案：\n1.  **均匀采样**：点 $x_i$ 在 $[-L, L]$ 上等距分布。\n2.  **非均匀采样**：通过三次扭曲函数 $x_i = L \\cdot \\mathrm{sign}(u_i) \\cdot |u_i|^3$ 生成点，其中 $u_i$ 在 $[-1, 1]$ 内均匀分布。该方案将点集中在定义域的中心附近。\n\n对于每个训练位置 $x_i$，通过向真实力添加独立同分布的高斯噪声来创建带噪声的力标签：\n$$\nF_{\\mathrm{noisy}}(x_i) = F_{\\mathrm{true}}(x_i) + \\epsilon_i, \\quad \\text{其中} \\quad \\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)\n$$\n为确保可复现性，伪随机数生成器使用固定的种子值 $2025$ 进行初始化。\n\n第三，我们构建机器学习模型。使用三次平滑样条（记为 $\\mathcal{S}_F(x)$）对带噪声的力数据 $\\{(x_i, F_{\\mathrm{noisy}}(x_i))\\}_{i=1}^N$ 进行拟合。这是一种非参数回归方法，旨在找到一个能够逼近数据的平滑函数。平滑度由参数 $s$ 控制，根据问题规范，该参数设置为 $s = \\sigma^2 N$。这个选择是一个常见的启发式方法，它将平滑度与噪声方差和数据点数量联系起来。\n\n第四，我们从拟合的力样条 $\\mathcal{S}_F(x)$ 推导出预测的势能 $\\widehat{E}(x)$。为确保模型代表一个保守场，我们通过直接积分获得 $\\widehat{E}(x)$。积分的任意常数通过将预测能量锚定在参考点 $x_{\\mathrm{ref}}=0$ 的真实能量上来固定。这得出了预测能量的表达式：\n$$\n\\widehat{E}(x) = E_{\\mathrm{true}}(x_{\\mathrm{ref}}) - \\int_{x_{\\mathrm{ref}}}^{x} \\mathcal{S}_F(u) \\, du = E_{\\mathrm{true}}(0) - \\int_{0}^{x} \\mathcal{S}_F(u) \\, du\n$$\n此处，$E_{\\mathrm{true}}(0) = a(0^2 - b^2)^2 + c \\cdot 0 = ab^4$。此过程通过构造保证了学习到的势能与学习到的力场是一致的。\n\n最后，我们评估学习到的势能 $\\widehat{E}(x)$ 的准确性。误差通过相对于真实势能 $E_{\\mathrm{true}}(x)$ 的均方根误差（RMSE）进行量化。该误差是在区间 $[-L, L]$ 内一个密集的、包含 $M=501$ 个点的均匀评估网格 $\\{x_j^{\\mathrm{eval}}\\}_{j=1}^M$ 上计算的：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{j=1}^{M} \\left( \\widehat{E}(x_j^{\\mathrm{eval}}) - E_{\\mathrm{true}}(x_j^{\\mathrm{eval}}) \\right)^2}\n$$\n对问题描述中指定的五个测试用例中的每一个，都将实现并执行这整个过程。得到的 RMSE 值提供了在不同势能形状、数据密度、噪声水平和采样策略条件下模型性能的定量度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import UnivariateSpline\nfrom typing import List, Tuple, Union\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the calculation of RMSE for each case and prints the final result.\n    \"\"\"\n\n    # Test cases as specified in the problem statement.\n    # Each case is a tuple: (a, b, c, L, N, sigma, sampling_scheme)\n    test_cases = [\n        # Case 1: (a=1.0, b=1.0, c=0.1, L=2.0, N=51, sigma=0.1, 'uniform')\n        (1.0, 1.0, 0.1, 2.0, 51, 0.1, 'uniform'),\n        # Case 2: (a=0.5, b=1.2, c=0.0, L=2.0, N=41, sigma=0.01, 'uniform')\n        (0.5, 1.2, 0.0, 2.0, 41, 0.01, 'uniform'),\n        # Case 3: (a=1.0, b=0.8, c=0.0, L=1.6, N=31, sigma=0.3, 'uniform')\n        (1.0, 0.8, 0.0, 1.6, 31, 0.3, 'uniform'),\n        # Case 4: (a=1.0, b=1.0, c=0.2, L=2.0, N=7, sigma=0.05, 'uniform')\n        (1.0, 1.0, 0.2, 2.0, 7, 0.05, 'uniform'),\n        # Case 5: (a=0.8, b=1.0, c=0.0, L=2.0, N=51, sigma=0.1, 'nonuniform')\n        (0.8, 1.0, 0.0, 2.0, 51, 0.1, 'nonuniform'),\n    ]\n\n    # Initialize a single pseudo-random number generator for reproducibility across all cases.\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for case in test_cases:\n        rmse = compute_rmse_for_case(case, rng)\n        results.append(rmse)\n\n    # Format the output as a comma-separated list of numbers with 6 decimal places,\n    # enclosed in square brackets.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\n\ndef compute_rmse_for_case(case_params: Tuple, rng: np.random.Generator) -> float:\n    \"\"\"\n    Computes the energy RMSE for a single test case.\n\n    Args:\n        case_params: A tuple containing the parameters for the case (a, b, c, L, N, sigma, sampling).\n        rng: The numpy random number generator instance.\n\n    Returns:\n        The calculated root-mean-squared error for the energy.\n    \"\"\"\n    a, b, c, L, N, sigma, sampling = case_params\n\n    # 1. Define ground-truth energy and force functions.\n    def e_true(x: Union[float, np.ndarray]) -> Union[float, np.ndarray]:\n        return a * (x**2 - b**2)**2 + c * x\n\n    def f_true(x: Union[float, np.ndarray]) -> Union[float, np.ndarray]:\n        return -4 * a * x * (x**2 - b**2) - c\n\n    # 2. Generate training points.\n    if sampling == 'uniform':\n        x_train = np.linspace(-L, L, N)\n    elif sampling == 'nonuniform':\n        u = np.linspace(-1.0, 1.0, N)\n        x_train = L * np.sign(u) * np.abs(u)**3\n    else:\n        raise ValueError(\"Invalid sampling scheme specified.\")\n\n    # 3. Generate noisy force labels.\n    f_train_true = f_true(x_train)\n    noise = rng.normal(loc=0.0, scale=sigma, size=N)\n    f_train_noisy = f_train_true + noise\n\n    # Ensure data is sorted by x for spline fitting, which is a requirement for UnivariateSpline.\n    # While linspace and the specified nonuniform transform produce sorted output, this is robust.\n    sort_indices = np.argsort(x_train)\n    x_train_sorted = x_train[sort_indices]\n    f_train_noisy_sorted = f_train_noisy[sort_indices]\n\n    # 4. Fit a conservative model: cubic spline for force.\n    # The smoothing factor 's' is specified as N * sigma^2.\n    smoothing_factor = N * sigma**2\n    force_spline = UnivariateSpline(x_train_sorted, f_train_noisy_sorted, s=smoothing_factor)\n\n    # 5. Construct the predicted energy by integrating the force spline.\n    # The integration constant is set by matching the true energy at x_ref=0.\n    x_ref = 0.0\n    e_ref = e_true(x_ref)\n\n    # The integral of the spline needs to be computed for each evaluation point.\n    # We create a vectorized function for this purpose.\n    @np.vectorize\n    def predict_energy(x: float) -> float:\n        integral_part = force_spline.integral(x_ref, x)\n        return e_ref - integral_part\n\n    # 6. Evaluate the error on a fixed evaluation grid.\n    M = 501\n    x_eval = np.linspace(-L, L, M)\n    \n    e_eval_true = e_true(x_eval)\n    e_eval_predicted = predict_energy(x_eval)\n\n    # 7. Compute the Root-Mean-Squared Error (RMSE).\n    rmse = np.sqrt(np.mean((e_eval_predicted - e_eval_true)**2))\n    \n    return rmse\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2648595"}, {"introduction": "一个训练好的机器学习势函数，只有当它能够产生稳定且准确的分子动力学模拟时才具有实用价值。这项动手练习涉及一个关键的验证测试：通过在微正则系综（NVE）中监测能量守恒情况，来确定最大稳定积分时间步长。通过亲手实现一个模拟并分析能量漂移，你将学习到在将机器学习势用于正式科学研究之前，如何确保其数值可靠性的标准流程。[@problem_id:2648626]", "problem": "给定一个用于经典分子动力学的配对机器学习（ML）势能模型，该模型在粒子数、体积和能量（NVE）恒定的微正则系综中使用。您的任务是实现一个程序，通过运行简短的 NVE 轨迹并测量总能量的最大分数漂移，来确定一个数值稳定的积分时间步长。系统在约化（无量纲）单位中定义，因此质量、长度和能量都是无量纲的，且等于单位尺度；因此，漂移度量是无量纲的，不需要物理单位。\n\n基本原理：\n- 牛顿第二定律：对于每个粒子索引 $i$，其质量为 $m_i$，位置向量为 $\\mathbf{r}_i(t)$，速度为 $\\mathbf{v}_i(t)$，力为 $\\mathbf{F}_i(\\mathbf{r})$，其运动方程为 $m_i \\, \\frac{d^2 \\mathbf{r}_i}{dt^2} = \\mathbf{F}_i(\\mathbf{r})$ 和 $\\mathbf{F}_i(\\mathbf{r}) = - \\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$，其中 $U(\\mathbf{r})$ 是势能函数。\n- 在理想的微正则轨迹中能量守恒：总能量 $E_{\\mathrm{tot}}(t) = K(t) + U(t)$ 保持恒定，其中动能为 $K(t) = \\sum_i \\frac{1}{2} m_i \\lVert \\mathbf{v}_i(t) \\rVert^2$。数值积分中的任何非零漂移都是离散化误差。\n\nML 势能模型：\n- 三个粒子，索引为 $i \\in \\{1,2,3\\}$，位于三维空间中。总势能是所有唯一粒子对的总和，\n$$\nU(\\mathbf{r}) \\;=\\; \\sum_{1 \\le i &lt; j \\le 3} \\; \\sum_{k=1}^{3} \\; w_k \\, \\phi_k(r_{ij}) \\, s(r_{ij}),\n$$\n其中 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$，配对特征是带有平滑余弦截断的高斯径向基函数，\n$$\n\\phi_k(r) \\;=\\; \\exp\\!\\left(-\\beta_k \\, (r - \\mu_k)^2\\right), \\quad s(r) \\;=\\; \\begin{cases}\n\\dfrac{1}{2}\\left[\\cos\\!\\left(\\dfrac{\\pi r}{r_c}\\right) + 1\\right], & r &lt; r_c,\\\\\n0, & r \\ge r_c.\n\\end{cases}\n$$\n参数如下：\n- 权重 $w_1 = 0.8$, $w_2 = -0.3$, $w_3 = 0.2$。\n- 中心 $\\mu_1 = 1.0$, $\\mu_2 = 2.0$, $\\mu_3 = 3.0$。\n- 宽度参数 $\\beta_1 = 4.0$, $\\beta_2 = 1.0$, $\\beta_3 = 0.5$。\n- 截断半径 $r_c = 3.5$。\n\n力：\n- 对于 $r < r_c$，使用 $s'(r) = -\\dfrac{\\pi}{2 r_c} \\sin\\!\\left(\\dfrac{\\pi r}{r_c}\\right)$，对于 $r \\ge r_c$，则 $s'(r) = 0$。\n- 对于每个粒子对和基函数索引 $k$，计算 $\\dfrac{d \\phi_k}{dr} = -2 \\beta_k (r - \\mu_k)\\, \\phi_k(r)$。能量贡献的配对径向导数为\n$$\n\\frac{dU_{ij}}{dr} \\;=\\; \\sum_{k=1}^{3} w_k \\left( \\frac{d\\phi_k}{dr}(r_{ij}) \\, s(r_{ij}) \\;+\\; \\phi_k(r_{ij}) \\, s'(r_{ij}) \\right).\n$$\n来自粒子对 $(i,j)$ 施加在粒子 $i$ 上的力是\n$$\n\\mathbf{F}_{i \\leftarrow j} \\;=\\; - \\frac{dU_{ij}}{dr} \\, \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}},\n$$\n而 $\\mathbf{F}_j$ 受到大小相等、方向相反的力，以保证动量守恒。粒子 $i$ 上的总力是所有 $j \\ne i$ 的力之和。\n\n积分方案：\n- 使用源自牛顿第二定律的速度 Verlet 积分器：\n  - 给定当前位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(t)/m$，使用时间步长 $\\Delta t$ 的更新过程如下\n  $$\n  \\mathbf{v}\\!\\left(t + \\frac{\\Delta t}{2}\\right) = \\mathbf{v}(t) + \\frac{\\Delta t}{2} \\, \\mathbf{a}(t),\n  $$\n  $$\n  \\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\Delta t \\, \\mathbf{v}\\!\\left(t + \\frac{\\Delta t}{2}\\right),\n  $$\n  $$\n  \\mathbf{a}(t + \\Delta t) = \\frac{\\mathbf{F}(\\mathbf{r}(t + \\Delta t))}{m},\n  $$\n  $$\n  \\mathbf{v}(t + \\Delta t) = \\mathbf{v}\\!\\left(t + \\frac{\\Delta t}{2}\\right) + \\frac{\\Delta t}{2} \\, \\mathbf{a}(t + \\Delta t).\n  $$\n- 所有粒子的质量均为 $m_i = 1$。\n\n初始条件：\n- 在三维空间中有 $N = 3$ 个粒子。\n- 初始位置：\n  - 粒子 1：$(0.0, 0.0, 0.0)$,\n  - 粒子 2：$(1.2, 0.0, 0.0)$,\n  - 粒子 3：$(0.6, 1.0, 0.0)$。\n- 初始速度（净动量为零）：\n  - 粒子 1：$(0.0, 0.0, 0.0)$,\n  - 粒子 2：$(0.0, 0.05, 0.0)$,\n  - 粒子 3：$(0.0, -0.05, 0.0)$。\n\n能量漂移度量和稳定性判据：\n- 对于给定的时间步长 $\\Delta t$，运行一个包含 $T$ 步的轨迹，并记录在步数索引 $n \\in \\{0,1,\\dots,T\\}$ 处的总能量 $E_{\\mathrm{tot}}(n)$。\n- 定义 $E_0 = E_{\\mathrm{tot}}(0)$ 以及轨迹上的无量纲最大分数漂移\n$$\nD(\\Delta t) \\;=\\; \\max_{0 \\le n \\le T} \\frac{\\left| E_{\\mathrm{tot}}(n) - E_0 \\right|}{\\max\\left( \\left| E_0 \\right|, \\epsilon \\right)},\n$$\n其中有一个小的正数 $\\epsilon = 10^{-12}$ 以避免在 $E_0 = 0$ 时出现除以零的错误。\n- 如果 $D(\\Delta t) \\le \\tau$（其中 $\\tau = 10^{-3}$），则该时间步长被分类为稳定。\n\n说明：\n- 完全按照上述定义实现 ML 势能及其力。\n- 在约化单位下为 NVE 轨迹实现速度 Verlet 积分器。\n- 对于下面测试套件中的每个时间步长，计算 $D(\\Delta t)$ 并根据给定容差确定其是否稳定。\n- 如果在轨迹运行期间，位置、速度、力或能量中出现任何非有限值（非实数），则终止该轨迹，并将 $D(\\Delta t)$ 设置为一个大的哨兵值 $10^{6}$，并将其分类为不稳定。\n- 确定测试套件中稳定的最大时间步长。如果没有一个稳定，则该元素返回 $-1$。\n\n测试套件：\n- 使用 $T = 1000$ 步。\n- 候选时间步长 $\\Delta t \\in \\{0.001, 0.005, 0.010, 0.020, 0.050, 0.100\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 该列表必须按照与测试套件相同的顺序包含 $6$ 个最大分数漂移 $D(\\Delta t)$，然后是其中最大的稳定时间步长值（如果没有稳定的，则为 $-1$）。例如，打印的字符串应具有 $[d_1,d_2,d_3,d_4,d_5,d_6,d_{\\mathrm{stable}}]$ 的形式，其中每个 $d_i$ 是一个浮点数，$d_{\\mathrm{stable}}$ 是所选时间步长的浮点数值或 $-1$。", "solution": "问题陈述已经过评估并被认定有效。这是一个在计算物理化学领域中提法恰当、有科学依据的问题，没有矛盾、歧义和事实错误。任务是实现一个分子动力学模拟，以评估针对自定义机器学习势能的不同积分时间步长的数值稳定性。我们将采用严谨、基于原理的解决方案。\n\n该解决方案需要实现几个关键组件：针对给定机器学习模型的势能和力计算、用于在时间上演化系统的速度 Verlet 积分算法，以及通过分析总能量守恒来确定积分稳定性的方法。\n\n**1. 系统和势能模型**\n\n该系统由三维空间中的 $N=3$ 个粒子组成，在一个约化单位体系中，所有粒子的质量都设置为单位 1 ($m_i=1$)。总势能 $U(\\mathbf{r})$ 定义为所有唯一粒子对 $(i,j)$ 之间的配对相互作用之和：\n$$\nU(\\mathbf{r}) \\;=\\; \\sum_{1 \\le i < j \\le 3} U_{ij}(r_{ij})\n$$\n其中 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ 是粒子 $i$ 和 $j$ 之间的距离。单个粒子对的相互作用势 $U_{ij}$ 被描述为由平滑截断函数调制的多个加权高斯函数的和：\n$$\nU_{ij}(r_{ij}) \\;=\\; \\sum_{k=1}^{3} \\; w_k \\, \\phi_k(r_{ij}) \\, s(r_{ij})\n$$\n其组成部分是高斯径向基函数，\n$$\n\\phi_k(r) \\;=\\; \\exp\\!\\left(-\\beta_k \\, (r - \\mu_k)^2\\right)\n$$\n以及余弦截断函数，\n$$\ns(r) \\;=\\; \\begin{cases}\n\\dfrac{1}{2}\\left[\\cos\\!\\left(\\dfrac{\\pi r}{r_c}\\right) + 1\\right], & r < r_c, \\\\\n0, & r \\ge r_c.\n\\end{cases}\n$$\n提供的参数是权重 $\\{w_k\\}$、中心 $\\{\\mu_k\\}$、宽度参数 $\\{\\beta_k\\}$ 和截断半径 $r_c$。这些参数完全定义了势能面。\n\n**2. 力的计算**\n\n作用在粒子 $i$ 上的力 $\\mathbf{F}_i$ 是总势能相对于其位置向量 $\\mathbf{r}_i$ 的负梯度：\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} \\sum_{1 \\le k < l \\le 3} U_{kl}(r_{kl})\n$$\n梯度算子 $\\nabla_{\\mathbf{r}_i}$ 仅影响求和中依赖于 $\\mathbf{r}_i$ 的项。这些是所有 $j \\ne i$ 的 $U_{ij}$ 项。通过应用链式法则，作用在粒子 $i$ 上的力可以表示为配对力之和：\n$$\n\\mathbf{F}_i = \\sum_{j \\ne i} \\mathbf{F}_{i \\leftarrow j}\n$$\n其中 $\\mathbf{F}_{i \\leftarrow j}$ 是由于与粒子 $j$ 相互作用而施加在粒子 $i$ 上的力。该力的计算方式如下：\n$$\n\\mathbf{F}_{i \\leftarrow j} = -\\nabla_{\\mathbf{r}_i} U_{ij}(r_{ij}) = -\\frac{dU_{ij}}{dr_{ij}} \\nabla_{\\mathbf{r}_i} r_{ij}\n$$\n标量距离 $r_{ij}$ 的梯度是指向从 $j$ 到 $i$ 的单位向量：\n$$\n\\nabla_{\\mathbf{r}_i} r_{ij} = \\nabla_{\\mathbf{r}_i} \\sqrt{(\\mathbf{r}_i - \\mathbf{r}_j)\\cdot(\\mathbf{r}_i - \\mathbf{r}_j)} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}}\n$$\n这导出了问题陈述中提供的配对力表达式：\n$$\n\\mathbf{F}_{i \\leftarrow j} = - \\frac{dU_{ij}}{dr_{ij}} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}}\n$$\n根据牛顿第三定律，粒子 $i$ 施加在粒子 $j$ 上的力是 $\\mathbf{F}_{j \\leftarrow i} = -\\mathbf{F}_{i \\leftarrow j}$。这个特性对于总动量守恒至关重要，在实现中通过计算一次每个配对力并将其以相反的符号应用于两个相互作用的粒子来利用这一特性。\n\n对势 $U_{ij}(r)$ 的定义应用乘法法则，可以找到其径向导数 $\\frac{dU_{ij}}{dr}$：\n$$\n\\frac{dU_{ij}}{dr} = \\frac{d}{dr} \\left( s(r) \\sum_{k=1}^3 w_k \\phi_k(r) \\right) = s'(r) \\left( \\sum_{k=1}^3 w_k \\phi_k(r) \\right) + s(r) \\left( \\sum_{k=1}^3 w_k \\frac{d\\phi_k}{dr}(r) \\right)\n$$\n这可以重排成问题陈述中给出的形式：\n$$\n\\frac{dU_{ij}}{dr} = \\sum_{k=1}^{3} w_k \\left( \\frac{d\\phi_k}{dr}(r_{ij}) \\, s(r_{ij}) + \\phi_k(r_{ij}) \\, s'(r_{ij}) \\right)\n$$\n所需的导数是：\n$$\n\\frac{d \\phi_k}{dr}(r) = -2 \\beta_k (r - \\mu_k)\\, \\phi_k(r) \\quad \\text{和} \\quad s'(r) = -\\frac{\\pi}{2 r_c} \\sin\\!\\left(\\frac{\\pi r}{r_c}\\right) \\quad \\text{对于 } r < r_c.\n$$\n对于 $r \\ge r_c$，两个导数都为零。\n\n**3. 数值积分方案**\n\n粒子的运动方程 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 使用速度 Verlet 算法进行数值积分。这是一个时间可逆的辛积分器，对于固定的时间步长 $\\Delta t$ 具有出色的长期能量守恒特性。给定系统在时间 $t$ 的状态——位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{r}(t))/m$——在时间 $t+\\Delta t$ 的状态通过以下步骤计算：\n1. 计算半步速度： $\\mathbf{v}(t + \\frac{\\Delta t}{2}) = \\mathbf{v}(t) + \\frac{\\Delta t}{2} \\mathbf{a}(t)$。\n2. 将位置更新到完整步： $\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\Delta t \\, \\mathbf{v}(t + \\frac{\\Delta t}{2})$。\n3. 使用新位置计算力 $\\mathbf{F}(\\mathbf{r}(t + \\Delta t))$。\n4. 计算新步的加速度： $\\mathbf{a}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))/m$。\n5. 将速度更新到完整步： $\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t + \\frac{\\Delta t}{2}) + \\frac{\\Delta t}{2} \\mathbf{a}(t + \\Delta t)$。\n\n对于每个候选时间步长 $\\Delta t$，此过程重复 $T=1000$ 步。\n\n**4. 能量守恒与稳定性分析**\n\n在理想的微正则（NVE）系综模拟中，总能量 $E_{\\mathrm{tot}} = K + U$ 必须守恒。动能 $K$ 由 $K(t) = \\sum_i \\frac{1}{2} m_i \\lVert \\mathbf{v}_i(t) \\rVert^2$ 给出，势能 $U$ 由上述模型计算。数值积分会引入离散化误差，导致计算出的总能量随时间漂移。这种漂移的幅度是积分精度和稳定性的直接度量。\n\n我们使用在 $T$ 步轨迹上的最大分数能量漂移 $D(\\Delta t)$ 来量化稳定性：\n$$\nD(\\Delta t) = \\max_{0 \\le n \\le T} \\frac{\\left| E_{\\mathrm{tot}}(n) - E_0 \\right|}{\\max\\left( \\left| E_0 \\right|, \\epsilon \\right)}\n$$\n其中 $E_{\\mathrm{tot}}(n)$ 是在第 $n$ 步的总能量，$E_0$ 是初始总能量，$\\epsilon = 10^{-12}$ 是一个用于防止除以零的小常数。如果时间步长 $\\Delta t$ 的漂移 $D(\\Delta t)$ 不超过预定义的容差 $\\tau = 10^{-3}$，则认为该时间步长是稳定的。\n\n最终任务是为测试套件中的每个 $\\Delta t$ 计算 $D(\\Delta t)$，并找出满足稳定性判据的最大 $\\Delta t$ 值。如果模拟变得数值不稳定，表现为位置、速度或能量中出现非有限数（例如 `NaN` 或 `inf`），则终止轨迹，并将其漂移值赋为一个大的哨兵值 $10^6$。如果没有一个测试的时间步长是稳定的，则最大稳定步长的结果为 $-1$。\n\n实现将包含一个主循环，遍历所有候选时间步长。对于每个时间步长，从指定的初始条件开始运行模拟，在每个积分步骤中跟踪总能量。然后计算并记录最大分数漂移。最后，报告收集到的漂移值和最大的稳定时间步长。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics stability problem.\n    \"\"\"\n    \n    # --- System Parameters ---\n    # ML potential parameters\n    W = np.array([0.8, -0.3, 0.2])\n    MU = np.array([1.0, 2.0, 3.0])\n    BETA = np.array([4.0, 1.0, 0.5])\n    R_CUT = 3.5\n    R_CUT_SQ = R_CUT ** 2\n\n    # Particle properties\n    N_PARTICLES = 3\n    MASSES = np.ones(N_PARTICLES)\n\n    # Initial conditions\n    R0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.2, 0.0, 0.0],\n        [0.6, 1.0, 0.0]\n    ])\n    V0 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.0, 0.05, 0.0],\n        [0.0, -0.05, 0.0]\n    ])\n\n    # Simulation parameters\n    T_STEPS = 1000\n    DT_CANDIDATES = [0.001, 0.005, 0.010, 0.020, 0.050, 0.100]\n    \n    # Stability criterion\n    DRIFT_TOLERANCE_TAU = 1e-3\n    EPSILON = 1e-12\n    SENTINEL_DRIFT = 1e6\n\n    def calculate_potential_and_forces(positions):\n        \"\"\"\n        Calculates the total potential energy and forces for all particles.\n        \"\"\"\n        potential_energy = 0.0\n        forces = np.zeros_like(positions)\n\n        for i in range(N_PARTICLES):\n            for j in range(i + 1, N_PARTICLES):\n                r_vec = positions[i] - positions[j]\n                r_sq = np.dot(r_vec, r_vec)\n\n                if r_sq >= R_CUT_SQ:\n                    continue\n\n                r = np.sqrt(r_sq)\n                \n                # Calculate phi_k and their derivatives\n                r_minus_mu = r - MU\n                phi_k = np.exp(-BETA * r_minus_mu**2)\n                d_phi_k_dr = -2.0 * BETA * r_minus_mu * phi_k\n\n                # Calculate s(r) and its derivative\n                arg_cos = np.pi * r / R_CUT\n                s_r = 0.5 * (np.cos(arg_cos) + 1.0)\n                s_prime_r = -0.5 * (np.pi / R_CUT) * np.sin(arg_cos)\n\n                # Calculate pair potential U_ij and its derivative dU_ij/dr\n                sum_w_phi = np.dot(W, phi_k)\n                sum_w_dphi = np.dot(W, d_phi_k_dr)\n\n                U_ij = sum_w_phi * s_r\n                dU_ij_dr = sum_w_dphi * s_r + sum_w_phi * s_prime_r\n                \n                potential_energy += U_ij\n\n                # Calculate pairwise force F_i_from_j = - (dU/dr) * (r_vec / r)\n                force_magnitude = -dU_ij_dr / r\n                force_vec = force_magnitude * r_vec\n\n                forces[i] += force_vec\n                forces[j] -= force_vec\n        \n        return potential_energy, forces\n\n    def run_simulation(dt):\n        \"\"\"\n        Runs an NVE simulation for a given time step dt and computes the energy drift.\n        \"\"\"\n        r = R0.copy()\n        v = V0.copy()\n\n        # Initial energy and forces\n        U0, F0 = calculate_potential_and_forces(r)\n        if not np.all(np.isfinite(U0)) or not np.all(np.isfinite(F0)):\n            return SENTINEL_DRIFT\n\n        K0 = 0.5 * np.sum(MASSES[:, np.newaxis] * v**2)\n        E0 = K0 + U0\n\n        a = F0 / MASSES[:, np.newaxis]\n        \n        max_abs_drift = 0.0\n\n        for _ in range(T_STEPS):\n            # Velocity Verlet steps\n            v_half = v + 0.5 * dt * a\n            r += dt * v_half\n            \n            U, F = calculate_potential_and_forces(r)\n            \n            if not np.all(np.isfinite(U)) or not np.all(np.isfinite(F)):\n                return SENTINEL_DRIFT\n\n            a = F / MASSES[:, np.newaxis]\n            v = v_half + 0.5 * dt * a\n        \n            # Energy calculation for drift\n            K = 0.5 * np.sum(MASSES[:, np.newaxis] * v**2)\n            E_n = K + U\n            \n            current_drift = abs(E_n - E0)\n            if current_drift > max_abs_drift:\n                max_abs_drift = current_drift\n        \n        denominator = max(abs(E0), EPSILON)\n        max_fractional_drift = max_abs_drift / denominator\n\n        return max_fractional_drift\n\n    # Main logic\n    drifts = []\n    for dt in DT_CANDIDATES:\n        drift = run_simulation(dt)\n        drifts.append(drift)\n\n    largest_stable_dt = -1.0\n    for i in range(len(DT_CANDIDATES) - 1, -1, -1):\n        if drifts[i] = DRIFT_TOLERANCE_TAU:\n            largest_stable_dt = DT_CANDIDATES[i]\n            break\n\n    results = drifts + [largest_stable_dt]\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2648626"}]}