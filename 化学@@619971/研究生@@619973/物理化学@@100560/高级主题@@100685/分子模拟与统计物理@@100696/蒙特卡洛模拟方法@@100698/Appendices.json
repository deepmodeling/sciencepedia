{"hands_on_practices": [{"introduction": "在模拟复杂的分子系统之前，我们必须掌握蒙特卡洛方法的基础：利用随机抽样来估计积分。这个基础练习将通过一个简单的一维积分，帮助我们建立关于样本数量与估计统计误差之间关系的直观理解。通过这个练习，你将亲手验证蒙特卡洛模拟的一个核心原则：估计的精度是通过增加计算量换来的，其标准误差随样本量$N$的增加而以$N^{-1/2}$的速率减小。[@problem_id:2653261]", "problem": "在平衡统计力学中，可观测量的构型平均可以表示为关于一个目标概率密度函数 (PDF) 的期望。考虑在构型空间 $\\Omega=[0,1]$ 上定义的可观测量 $f(x)=x^{2}$，并假设目标概率密度函数 $\\pi(x)$ 在 $\\Omega$ 上是均匀的，即对于 $x \\in [0,1]$ 有 $\\pi(x)=1$。您希望使用基于从 $\\pi(x)$ 进行独立抽样的普通蒙特卡罗 (MC) 方法来估计积分 $I=\\int_{0}^{1} f(x)\\,dx$。\n\n任务：\n1. 使用从 $[0,1]$ 上的均匀分布中抽取的独立同分布样本 $X_{1},\\dots,X_{N}$，为 $I$ 构建普通蒙特卡罗估计量，并给出其用 $N$ 表示的标准误差。\n2. 仅使用独立性下的期望和方差的第一性原理，确定所需的最小整数样本量 $N$，以使估计量的标准误差严格小于 $10^{-3}$。\n\n最终答案只提供最小整数 $N$（无量纲）。最终答案中不应出现任何推导过程。最终答案必须是单个数字。如果需要取整，请报告满足要求的最小整数（不要对此整数应用有效数字规则）。", "solution": "该问题要求根据指定的精度，确定蒙特卡罗估计的最小样本量。我们首先正式定义问题的各个组成部分。\n\n待估计的积分是 $I = \\int_{0}^{1} f(x) \\, dx$，其中可观测量函数为 $f(x) = x^{2}$，定义在构型空间 $\\Omega = [0,1]$ 上。目标概率密度函数在此区间上是均匀的，即对于 $x \\in [0,1]$ 有 $\\pi(x) = 1$。因此，积分 $I$ 等价于 $f(X)$ 的期望，其中 $X$ 是从均匀分布 $U(0,1)$ 中抽取的随机变量。\n$$\nI = \\int_{0}^{1} x^{2} \\cdot \\pi(x) \\, dx = \\mathbb{E}_{\\pi}[f(X)] = \\mathbb{E}[X^{2}]\n$$\n这就确立了第一性原理：积分即期望。\n\n$I$ 的普通蒙特卡罗估计量（我们记为 $\\hat{I}_{N}$）是通过对从分布 $\\pi(x)$ 中抽取的 $N$ 个独立同分布 (i.i.d.) 样本 $X_{1}, \\dots, X_{N}$ 计算可观测量 $f(x)$ 的样本均值来构建的。\n$$\n\\hat{I}_{N} = \\frac{1}{N} \\sum_{i=1}^{N} f(X_{i}) = \\frac{1}{N} \\sum_{i=1}^{N} X_{i}^{2}\n$$\n这就是任务第一部分的估计量。\n\n第一个任务的第二部分是确定该估计量的标准误差 $\\text{SE}(\\hat{I}_{N})$。标准误差是估计量方差的平方根，即 $\\text{SE}(\\hat{I}_{N}) = \\sqrt{\\text{Var}(\\hat{I}_{N})}$。由于样本是独立同分布的，样本均值的方差等于可观测量的总体方差除以样本量 $N$。\n$$\n\\text{Var}(\\hat{I}_{N}) = \\text{Var}\\left(\\frac{1}{N} \\sum_{i=1}^{N} X_{i}^{2}\\right) = \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\text{Var}(X_{i}^{2}) = \\frac{N \\cdot \\text{Var}(X^{2})}{N^{2}} = \\frac{\\text{Var}(X^{2})}{N}\n$$\n此处，$\\text{Var}(X^{2})$ 是可观测量 $f(X) = X^{2}$ 的方差。随机变量 $Y$ 的方差由 $\\text{Var}(Y) = \\mathbb{E}[Y^{2}] - (\\mathbb{E}[Y])^{2}$ 给出。将此公式应用于我们的可观测量 $X^{2}$：\n$$\n\\text{Var}(X^{2}) = \\mathbb{E}\\left[(X^{2})^{2}\\right] - \\left(\\mathbb{E}[X^{2}]\\right)^{2} = \\mathbb{E}[X^{4}] - \\left(\\mathbb{E}[X^{2}]\\right)^{2}\n$$\n为继续计算，我们必须计算均匀分布 $U(0,1)$ 的必要矩。一个随机变量 $X \\sim U(0,1)$ 的 k 阶矩为：\n$$\n\\mathbb{E}[X^{k}] = \\int_{0}^{1} x^{k} \\pi(x) \\, dx = \\int_{0}^{1} x^{k} \\, dx = \\left[ \\frac{x^{k+1}}{k+1} \\right]_{0}^{1} = \\frac{1}{k+1}\n$$\n我们需要二阶矩和四阶矩：\n$$\n\\mathbb{E}[X^{2}] = \\frac{1}{2+1} = \\frac{1}{3}\n$$\n$$\n\\mathbb{E}[X^{4}] = \\frac{1}{4+1} = \\frac{1}{5}\n$$\n将这些结果代回可观测量的方差表达式中：\n$$\n\\text{Var}(X^{2}) = \\frac{1}{5} - \\left(\\frac{1}{3}\\right)^{2} = \\frac{1}{5} - \\frac{1}{9} = \\frac{9 - 5}{45} = \\frac{4}{45}\n$$\n有了这个结果，估计量 $\\hat{I}_{N}$ 的标准误差为：\n$$\n\\text{SE}(\\hat{I}_{N}) = \\sqrt{\\frac{\\text{Var}(X^{2})}{N}} = \\sqrt{\\frac{4/45}{N}} = \\frac{2}{\\sqrt{45N}}\n$$\n这就完成了第一个任务的推导。\n\n第二个任务是找到最小整数样本量 $N$，使得标准误差严格小于 $10^{-3}$。我们建立以下不等式：\n$$\n\\text{SE}(\\hat{I}_{N}) < 10^{-3}\n$$\n$$\n\\frac{2}{\\sqrt{45N}} < 10^{-3}\n$$\n我们现在解这个关于 $N$ 的不等式。\n$$\n\\sqrt{45N} > \\frac{2}{10^{-3}} = 2 \\times 10^{3} = 2000\n$$\n将两边平方，得到：\n$$\n45N > (2000)^{2} = 4 \\times 10^{6}\n$$\n$$\nN > \\frac{4 \\times 10^{6}}{45}\n$$\n为了确定 $N$ 的限值，我们计算该分数值：\n$$\n\\frac{4000000}{45} = \\frac{800000}{9} = 88888.888\\dots = 88888.\\overline{8}\n$$\n因此条件是 $N > 88888.\\overline{8}$。由于样本量 $N$ 必须是整数，满足此严格不等式的最小整数值是大于 $88888.\\overline{8}$ 的最小整数。\n$$\nN_{\\min} = 88889\n$$\n这就是所需的最小样本量。", "answer": "$$\\boxed{88889}$$", "id": "2653261"}, {"introduction": "Metropolis算法是一种强大的工具，它使我们能够从像玻尔兹曼分布这样复杂的概率分布中进行抽样，而这通常无法直接完成。本练习旨在探讨该算法实现中的一个微妙但至关重要的方面。通过分析一个看似“错误”的接受准则，你将对算法如何巧妙地维持细致平衡条件（detailed balance）获得更深刻的理解，尤其是在处理能量降低的移动时。[@problem_id:2458844]", "problem": "在一个温度为 $T$、Boltzmann 常数为 $k_B$ 的分子体系的正则系综蒙特卡洛抽样中，关于构型 $\\mathbf{x}$ 的目标分布是 $\\pi(\\mathbf{x}) \\propto \\exp(-\\beta E(\\mathbf{x}))$，其中 $\\beta = 1/(k_B T)$。考虑一个带有对称提议核的 Metropolis 型采样器，它通过随机位移从当前构型 $\\mathbf{x}$ 生成一个试验构型 $\\mathbf{x}'$。该代码计算能量变化 $\\Delta E = E(\\mathbf{x}') - E(\\mathbf{x})$，然后设定一个接受概率 $P_{\\mathrm{acc}} = \\exp(-\\Delta E/(k_B T))$。它从 $u \\sim \\mathrm{Uniform}(0,1)$ 中抽取一个随机数 $u$，如果 $u < P_{\\mathrm{acc}}$ 则接受该移动；否则拒绝该移动。该代码从未显式地计算 $\\min(1, \\exp(-\\Delta E/(k_B T)))$。\n\n对于在对称提议下从正则分布中抽样，以下哪种说法最能描述这种实现所带来的影响？\n\nA. 抽样仍然是正确的：所实现的规则产生的实际接受概率等于 $\\min(1, \\exp(-\\Delta E/(k_B T)))$，因此细致平衡条件成立，平稳分布是 Boltzmann 分布。\n\nB. 抽样是有偏的：能量下降的移动以大于1的概率被接受，这违反了概率公理，并导致对低能态的过采样，超出了 Boltzmann 定律。\n\nC. 对于能量下降的移动，细致平衡被违反，但平稳分布仍然是 Boltzmann 分布，因为从长远来看，低能态占主导地位。\n\nD. 该实现仅在所有提议的移动都满足 $\\Delta E \\ge 0$ 时才正确，而对于物理体系来说情况并非如此，因此它通常是无效的。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 系综：温度为 $T$ 的正则系综。\n- Boltzmann 常数：$k_B$。\n- 关于构型 $\\mathbf{x}$ 的目标概率分布：$\\pi(\\mathbf{x}) \\propto \\exp(-\\beta E(\\mathbf{x}))$。\n- 逆温度：$\\beta = 1/(k_B T)$。\n- 采样器：带有对称提议核的 Metropolis 型采样器。\n- 从当前构型 $\\mathbf{x}$ 生成一个试验构型 $\\mathbf{x}'$。\n- 能量变化：$\\Delta E = E(\\mathbf{x}') - E(\\mathbf{x})$。\n- 计算一个量：$P_{\\mathrm{acc}} = \\exp(-\\Delta E/(k_B T))$。\n- 从区间 $(0,1)$ 上的均匀分布中抽取一个随机数 $u$，即 $u \\sim \\mathrm{Uniform}(0,1)$。\n- 接受准则：如果 $u < P_{\\mathrm{acc}}$，则接受该移动。\n- 实现说明：代码没有使用显式的 $\\min$ 函数，即它避免了计算 $\\min(1, \\exp(-\\Delta E/(k_B T)))$。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题描述了 Metropolis 算法，这是用于正则系综抽样的统计力学模拟的基石。所有概念——Boltzmann 分布、细致平衡、提议和接受步骤——都是标准概念，并在计算物理学和计算化学中有严格的定义。该设定在科学上是合理的。\n-   **适定性**：该问题描述了一个算法的特定实现，并要求对其行为进行分析。描述明确无歧义，并提供了确定抽样过程影响所需的所有必要信息。可以推导出一个唯一的、合乎逻辑的结论。\n-   **客观性**：该问题以精确、客观的语言陈述，不含任何主观或推测性元素。\n\n**步骤3：结论和行动**\n问题陈述是有效的。它就一个计算算法提出了一个清晰、自洽且科学上合理的问题。可以进行严格的分析。我将继续进行解答。\n\nMetropolis 算法的核心是细致平衡条件，它确保由采样器生成的马尔可夫链将目标分布 $\\pi(\\mathbf{x})$ 作为其平稳分布。对于对称提议核，即从 $\\mathbf{x}$ 提议移动到 $\\mathbf{x}'$ 的概率与从 $\\mathbf{x}'$ 提议移动到 $\\mathbf{x}$ 的概率相同，细致平衡条件简化为：\n$$ \\pi(\\mathbf{x}) A(\\mathbf{x} \\to \\mathbf{x}') = \\pi(\\mathbf{x}') A(\\mathbf{x}' \\to \\mathbf{x}) $$\n其中 $A(\\mathbf{x} \\to \\mathbf{x}')$ 是接受一个从 $\\mathbf{x}$ 到 $\\mathbf{x}'$ 的提议移动的概率。\n\nMetropolis 对接受概率的选择满足此条件：\n$$ A_{\\text{Metropolis}}(\\mathbf{x} \\to \\mathbf{x}') = \\min\\left(1, \\frac{\\pi(\\mathbf{x}')}{\\pi(\\mathbf{x})}\\right) $$\n鉴于 $\\pi(\\mathbf{x}) \\propto \\exp(-\\beta E(\\mathbf{x}))$ 且 $\\beta = 1/(k_B T)$，概率之比为：\n$$ \\frac{\\pi(\\mathbf{x}')}{\\pi(\\mathbf{x})} = \\frac{\\exp(-\\beta E(\\mathbf{x}'))}{\\exp(-\\beta E(\\mathbf{x}))} = \\exp(-\\beta(E(\\mathbf{x}') - E(\\mathbf{x}))) = \\exp(-\\beta \\Delta E) $$\n因此，正确的接受概率是：\n$$ A_{\\text{Metropolis}}(\\mathbf{x} \\to \\mathbf{x}') = \\min(1, \\exp(-\\beta \\Delta E)) $$\n\n现在我们必须分析所述的实现。该代码计算一个值 $P_{\\mathrm{acc}} = \\exp(-\\beta \\Delta E)$，并在一个随机数 $u \\sim \\mathrm{Uniform}(0,1)$ 满足条件 $u < P_{\\mathrm{acc}}$ 时接受该移动。实际的接受概率，我们称之为 $A_{\\text{impl}}$，是满足该条件的概率：\n$$ A_{\\text{impl}} = \\mathrm{Prob}(u < P_{\\mathrm{acc}}) $$\n我们必须对所有可能的 $\\Delta E$ 值分析这个概率。\n\n**情况1：能量上升或等能的移动 ($\\Delta E \\ge 0$)**\n在这种情况下，由于 $\\beta=1/(k_B T) > 0$，指数的参数是非正的：$-\\beta \\Delta E \\le 0$。\n因此，计算出的值 $P_{\\mathrm{acc}}$ 为：\n$$ P_{\\mathrm{acc}} = \\exp(-\\beta \\Delta E) \\le 1 $$\n接受条件是 $u < P_{\\mathrm{acc}}$。由于 $u$ 是从 $(0,1)$ 上的均匀分布中抽取的，而 $P_{\\mathrm{acc}}$ 是一个介于 $0$ 和 $1$ 之间（含边界）的值，因此该事件发生的概率就是 $P_{\\mathrm{acc}}$。\n$$ A_{\\text{impl}} = \\mathrm{Prob}(u < P_{\\mathrm{acc}}) = P_{\\mathrm{acc}} = \\exp(-\\beta \\Delta E) $$\n对于 $\\Delta E \\ge 0$，正确的 Metropolis 概率是 $\\min(1, \\exp(-\\beta \\Delta E)) = \\exp(-\\beta \\Delta E)$。\n因此，在这种情况下，$A_{\\text{impl}} = A_{\\text{Metropolis}}$。该实现是正确的。\n\n**情况2：能量下降的移动 ($\\Delta E < 0$)**\n在这种情况下，指数的参数是严格为正的：$-\\beta \\Delta E > 0$。\n因此，计算出的值 $P_{\\mathrm{acc}}$ 为：\n$$ P_{\\mathrm{acc}} = \\exp(-\\beta \\Delta E) > 1 $$\n接受条件是 $u < P_{\\mathrm{acc}}$。随机数 $u$ 是从区间 $(0,1)$ 中抽取的，这意味着 $u$ 总是小于 $1$。由于 $P_{\\mathrm{acc}}$ 是一个大于 $1$ 的数，因此不等式 $u < P_{\\mathrm{acc}}$ **总是**成立的。\n一个必然发生的事件的概率是 $1$。\n$$ A_{\\text{impl}} = \\mathrm{Prob}(u < P_{\\mathrm{acc}}) = 1 $$\n对于 $\\Delta E < 0$，正确的 Metropolis 概率是 $\\min(1, \\exp(-\\beta \\Delta E))$。由于 $\\exp(-\\beta \\Delta E) > 1$，该表达式的计算结果为 $1$。\n因此，在这种情况下，$A_{\\text{impl}} = A_{\\text{Metropolis}}$ 也成立。该实现是正确的。\n\n在两种可能的情况下，由所实现的代码产生的有效接受概率都完全等同于标准的 Metropolis 接受概率。将一个来自 $\\mathrm{Uniform}(0,1)$ 的随机数与值 $\\exp(-\\beta \\Delta E)$ 进行比较，隐式且正确地执行了 `min(1, ...)` 操作。因此，该实现是正确的，细致平衡条件得到满足，采样器将正确地从正则 (Boltzmann) 分布中生成构型。\n\n现在，我们来评估给出的选项。\n\n**A. 抽样仍然是正确的：所实现的规则产生的实际接受概率等于 $\\min(1, \\exp(-\\Delta E/(k_B T)))$，因此细致平衡条件成立，平稳分布是 Boltzmann 分布。**\n这个陈述是我们推导过程的精确总结。*实际*接受概率确实是 $\\min(1, \\exp(-\\beta \\Delta E))$，细致平衡成立，并且抽样是正确的。\n结论：**正确**。\n\n**B. 抽样是有偏的：能量下降的移动以大于1的概率被接受，这违反了概率公理，并导致对低能态的过采样，超出了 Boltzmann 定律。**\n这是一个有缺陷的解释。对于能量下降的移动，量 $P_{\\mathrm{acc}} = \\exp(-\\beta \\Delta E)$ 可能大于1，但这个量本身不是接受概率。接受概率是 $\\mathrm{Prob}(u < P_{\\mathrm{acc}})$，它不能超过1。如前所示，对于能量下降的移动，这个概率恰好为1，这是一个有效的概率，并且是 Metropolis 算法的正确概率。没有违反任何概率公理。\n结论：**不正确**。\n\n**C. 对于能量下降的移动，细致平衡被违反，但平稳分布仍然是 Boltzmann 分布，因为从长远来看，低能态占主导地位。**\n我们的分析表明，对于所有移动，包括能量下降的移动，细致平衡都得到满足。该陈述的前提是错误的。如果细致平衡被违反，就无法保证平稳分布是所期望的 Boltzmann 分布。其推理在多个层面上都是错误的。\n结论：**不正确**。\n\n**D. 该实现仅在所有提议的移动都满足 $\\Delta E \\ge 0$ 时才正确，而对于物理体系来说情况并非如此，因此它通常是无效的。**\n这是错误的。我们的分析明确地表明，该实现对于能量下降的移动（$\\Delta E < 0$）也是正确的，在这种情况下它正确地得出了为1的接受概率。该方法对所有可能的能量变化都有效。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2458844"}, {"introduction": "许多实际的物理化学问题涉及到具有约束条件的系统，例如吸附在表面上的分子，这类系统最好用非笛卡尔坐标来描述。这个高级练习将Metropolis算法推广到更通用的Metropolis-Hastings框架，以处理这类复杂情况。你将为一个在球面上运动的粒子实现一个蒙特卡洛（MC）模拟，并直面雅可比（Jacobian）校正在确保对正确概率分布进行抽样时所起的关键作用。[@problem_id:2458841]", "problem": "一个粒子被约束在三维欧几里得空间中半径为 $R$ 的球面上运动。该球面由球坐标 $(\\theta,\\phi)$ 参数化，其中 $\\theta \\in [0,\\pi]$ 是极角，$\\phi \\in [0,2\\pi)$ 是方位角。粒子的平衡（目标）分布相对于球面上的表面积测度是均匀的。通过将独立的零均值增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 加到 $(\\theta,\\phi)$ 上，在角度空间中构建一个提议，然后通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta$ 以及将 $\\phi$ 进行模 $2\\pi$ 环绕，将扰动后的角度映射回其规范范围。提议增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 服从具有指定标准差的高斯分布。由此产生的马尔可夫链必须使均匀的表面积分布保持不变。当核在角坐标中指定时，$(\\theta,\\phi)$ 和表面积之间的变量变换会产生一个雅可比行列式，该行列式会影响表面上的提议密度。\n\n您的任务是：\n\n- 仅使用第一性原理，确定从角坐标 $(\\theta,\\phi)$ 到半径为 $R$ 的球面上的表面积元的变换的雅可比行列式 $J(R,\\theta)$。用 $R$ 和 $\\theta$ 表示您的结果。\n\n- 对于对称角扰动，从第一性原理确定接受率中纯粹由 $(\\theta,\\phi)$ 和表面积测度之间的提议密度变换产生的乘法因子，该因子用移动 $(\\theta,\\phi) \\to (\\theta',\\phi')$ 中的 $\\theta$ 和 $\\theta'$ 表示。\n\n- 使用上述角坐标提议，实现粒子在球面上的蒙特卡洛（MC）模拟。构建两种变体：\n  1. 一种变体，在其接受决策中使用了由您的雅可比行列式所蕴含的正确提议密度变换，从而使链对于均匀表面积分布保持不变。\n  2. 一种变体，在其接受决策中错误地忽略了此变换。\n\n- 对于每个变体，使用固定的种子以保证可复现性，估计可观测量 $f(\\theta,\\phi) = \\cos^2(\\theta)$ 在链的稳态分布下的期望值。\n\n角度必须以弧度为单位。所有数值答案必须表示为不带单位的实数。\n\n测试套件和要求的输出：\n\n1. 在以下参数对上评估雅可比行列式 $J(R,\\theta)$：\n   - $(R,\\theta) = (1,\\pi/6)$，\n   - $(R,\\theta) = (2,\\pi/2)$，\n   - $(R,\\theta) = (3,\\pi)$。\n\n2. 对于对称角扰动，为以下 $(\\theta,\\theta')$ 对评估提议密度雅可比比率因子：\n   - $(\\theta,\\theta') = (\\pi/12,\\pi/3)$，\n   - $(\\theta,\\theta') = (\\pi/3,5\\pi/12)$。\n\n3. 运行一个模拟，总步数为 $N = 200000$，预烧期为 $B = 5000$，半径为 $R = 1$，起始角度为 $(\\theta_0,\\phi_0) = (1.234,2.345)$，高斯提议标准差为 $\\sigma_\\theta = 0.3$ 和 $\\sigma_\\phi = 0.6$。使用固定的种子 $123$。为 $\\mathbb{E}[\\cos^2(\\theta)]$ 生成两个估计值：\n   - 一个使用正确考虑了您的雅可比行列式所引起的提议密度变换的接受决策。\n   - 一个使用忽略了该提议密度变换的接受决策。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n  - 来自第 $1$ 项的三个雅可比行列式值，按给定顺序排列。\n  - 来自第 $2$ 项的两个提议密度雅可比比率因子，按给定顺序排列。\n  - 来自第 $3$ 项的两个蒙特卡洛估计值，按给定顺序排列（首先是正确变体的估计值，然后是错误变体的估计值）。\n  例如，输出必须具有 $[\\text{J1},\\text{J2},\\text{J3},\\text{F1},\\text{F2},\\text{E\\_correct},\\text{E\\_wrong}]$ 的形式。", "solution": "所提出的问题是计算统计力学中一个定义明确且有科学依据的练习，具体涉及 Metropolis-Hastings 算法在非笛卡尔坐标系中的应用。对问题陈述的严格验证没有发现任何不一致、模糊不清或违反科学原则之处。因此，我将从第一性原理出发，给出一个完整的解决方案。\n\n解决方案分为三个部分，与问题陈述中列出的任务相对应。\n\n首先，我们确定从球坐标到球面上表面积元的变换的雅可比行列式。半径为 $R$ 的球面上的一个点，在笛卡尔坐标 $(x, y, z)$ 中，使用球坐标 $(\\theta, \\phi)$ 参数化为：\n$$\n\\vec{r}(\\theta, \\phi) = (R \\sin\\theta \\cos\\phi, R \\sin\\theta \\sin\\phi, R \\cos\\theta)\n$$\n其中 $\\theta \\in [0, \\pi]$ 是极角，$\\phi \\in [0, 2\\pi)$ 是方位角。一个无穷小的表面积元 $dA$，由切向量 $\\frac{\\partial\\vec{r}}{\\partial\\theta}$ 和 $\\frac{\\partial\\vec{r}}{\\partial\\phi}$ 的叉积的模给出。\n\n偏导数是：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} = (R \\cos\\theta \\cos\\phi, R \\cos\\theta \\sin\\phi, -R \\sin\\theta)\n$$\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\phi} = (-R \\sin\\theta \\sin\\phi, R \\sin\\theta \\cos\\phi, 0)\n$$\n叉积是：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} = (R^2 \\sin^2\\theta \\cos\\phi, R^2 \\sin^2\\theta \\sin\\phi, R^2 \\sin\\theta \\cos\\theta)\n$$\n该向量的模，即为变换的雅可比行列式，是：\n$$\nJ(R, \\theta) = \\left\\| \\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} \\right\\| = \\sqrt{(R^2 \\sin^2\\theta \\cos\\phi)^2 + (R^2 \\sin^2\\theta \\sin\\phi)^2 + (R^2 \\sin\\theta \\cos\\theta)^2}\n$$\n$$\nJ(R, \\theta) = \\sqrt{R^4 \\sin^4\\theta (\\cos^2\\phi + \\sin^2\\phi) + R^4 \\sin^2\\theta \\cos^2\\theta} = \\sqrt{R^4 \\sin^2\\theta (\\sin^2\\theta + \\cos^2\\theta)} = \\sqrt{R^4 \\sin^2\\theta}\n$$\n由于 $\\theta \\in [0, \\pi]$，所以 $\\sin\\theta \\ge 0$。因此，雅可比行列式为：\n$$\nJ(R, \\theta) = R^2 \\sin\\theta\n$$\n这个量将球面上的微分面积元 $dA$ 与角坐标的微分增量联系起来：$dA = J(R, \\theta) d\\theta d\\phi = R^2 \\sin\\theta d\\theta d\\phi$。\n\n其次，我们确定由坐标变换引起的 Metropolis-Hastings 接受率中的因子。从状态 $s$ 移动到提议状态 $s'$ 的接受概率 $\\alpha$ 由下式给出：\n$$\n\\alpha(s \\to s') = \\min\\left(1, \\frac{\\pi(s')}{\\pi(s)} \\frac{g(s' \\to s)}{g(s \\to s')}\\right)\n$$\n这里，$\\pi(s)$ 是目标概率密度，而 $g(s \\to s')$ 是从 $s$ 到 $s'$ 的提议概率密度。状态 $s$ 和 $s'$ 是球面上的点。目标分布相对于表面积测度是均匀的，这意味着对于球面上所有的点 $s$，$\\pi(s) = \\text{constant}$。因此，目标密度的比率 $\\frac{\\pi(s')}{\\pi(s)} = 1$。\n\n提议是在角坐标 $(\\theta, \\phi)$ 中进行的，而不是直接在球面上。设 $g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$ 是角坐标空间中的提议密度。球面上相应的提议密度 $g(s \\to s')$ 必须是相对于表面积测度 $dA$ 定义的。概率守恒要求 $g(s \\to s') dA' = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi')) d\\theta' d\\phi'$。使用 $dA' = J(\\theta') d\\theta' d\\phi'$，我们得到：\n$$\ng(s \\to s') = \\frac{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))}{J(\\theta')}\n$$\n类似地，对于逆向移动：\n$$\ng(s' \\to s) = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{J(\\theta)}\n$$\n因此，接受概率中的提议密度之比为：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))} \\times \\frac{J(\\theta')}{J(\\theta)}\n$$\n问题陈述指出角扰动是对称的，意味着角度空间中的前向和后向提议具有相同的分布。这意味着 $g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi)) = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$。因此，该比率简化为雅可比行列式的比率：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{J(\\theta')}{J(\\theta)} = \\frac{R^2 \\sin\\theta'}{R^2 \\sin\\theta} = \\frac{\\sin\\theta'}{\\sin\\theta}\n$$\n这就是所要求的乘法因子。正确的接受概率是 $\\alpha = \\min\\left(1, \\frac{\\sin\\theta'}{\\sin\\theta}\\right)$。\n\n第三，我们设计蒙特卡洛模拟。目标是估计可观测量 $f(\\theta, \\phi) = \\cos^2(\\theta)$ 在球面上均匀分布的期望值。理论期望值为：\n$$\n\\mathbb{E}[\\cos^2\\theta] = \\frac{\\int_0^{2\\pi} \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta d\\phi}{\\int_0^{2\\pi} \\int_0^\\pi \\sin\\theta \\,d\\theta d\\phi} = \\frac{2\\pi \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta}{4\\pi} = \\frac{1}{2}\\left[-\\frac{\\cos^3\\theta}{3}\\right]_0^\\pi = \\frac{1}{2}\\left(-\\frac{(-1)^3}{3} - \\left(-\\frac{1^3}{3}\\right)\\right) = \\frac{1}{3}\n$$\n模拟按如下方式实现：\n1.  在 $k=0$ 时，将状态 $(\\theta_k, \\phi_k)$ 初始化为 $(\\theta_0, \\phi_0)$。\n2.  对 $k = 0, \\dots, N-1$ 进行迭代：\n    a. 通过从高斯分布 $\\mathcal{N}(0, \\sigma_\\theta^2)$ 和 $\\mathcal{N}(0, \\sigma_\\phi^2)$ 中分别抽取独立增量 $\\Delta\\theta$ 和 $\\Delta\\phi$ 来提议一个新状态 $(\\theta_p, \\phi_p)$。\n    b. 应用边界条件。新的极角 $\\theta_p$ 是通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta_k + \\Delta\\theta$ 得到的。这可以通过变换 $\\theta_p = \\text{mod}(\\theta_k+\\Delta\\theta, 2\\pi)$，然后在 $\\theta_p > \\pi$ 时令 $\\theta_p = 2\\pi - \\theta_p$ 来实现。新的方位角 $\\phi_p$ 是通过将 $\\phi_k + \\Delta\\phi$ 进行模 $2\\pi$ 环绕得到的。\n    c. 计算接受概率 $\\alpha$。\n       - **正确变体**：$\\alpha = \\min\\left(1, \\frac{\\sin\\theta_p}{\\sin\\theta_k}\\right)$。\n       - **错误变体**：忽略雅可比因子。接受概率变为 $\\alpha = \\min(1, 1) = 1$，意味着所有移动都被接受。\n    d. 抽取一个随机数 $u \\sim U(0,1)$。如果 $u < \\alpha$，则设置 $(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_p, \\phi_p)$。否则，$(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_k, \\phi_k)$。\n3.  经过 $B$ 步的预烧期后，通过对剩下的 $N-B$ 步上的 $\\cos^2(\\theta_k)$ 进行平均来估计期望值 $\\mathbb{E}[\\cos^2\\theta]$。\n\n错误变体采样的概率密度在 $(\\theta, \\phi)$ 空间中是均匀的，即 $p(\\theta, \\phi) \\propto 1$。在此错误分布下的期望值为 $\\mathbb{E}_{incorrect}[\\cos^2\\theta] = \\frac{1}{2\\pi^2} \\int_0^{2\\pi} d\\phi \\int_0^\\pi \\cos^2\\theta \\,d\\theta = \\frac{1}{\\pi} \\int_0^\\pi \\frac{1+\\cos(2\\theta)}{2}d\\theta = \\frac{1}{2\\pi}[\\theta + \\frac{\\sin(2\\theta)}{2}]_0^\\pi = \\frac{1}{2}$。模拟结果应与这些 $1/3$ 和 $1/2$ 的理论预测相符。实现将精确遵循此设计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_mc_simulation(params, correct_jacobian, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation of a particle on a sphere.\n\n    Args:\n        params (tuple): A tuple containing simulation parameters:\n                        (N, B, R, theta0, phi0, sigma_theta, sigma_phi).\n        correct_jacobian (bool): If True, use the correct acceptance criterion.\n                                 If False, use the incorrect one.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated expectation value of cos^2(theta).\n    \"\"\"\n    N, B, R, theta0, phi0, sigma_theta, sigma_phi = params\n    \n    # Initialize a new random number generator for each independent run\n    rng = np.random.default_rng(seed)\n    \n    theta = theta0\n    phi = phi0\n    \n    observable_sum = 0.0\n    samples_collected = 0\n    \n    for step in range(N):\n        # Propose a move in angular coordinates\n        d_theta = rng.normal(0.0, sigma_theta)\n        d_phi = rng.normal(0.0, sigma_phi)\n        \n        theta_prop = theta + d_theta\n        phi_prop = phi + d_phi\n        \n        # Apply boundary conditions\n        # For theta: reflection at 0 and pi\n        # This maps the real line to [0, pi] via folding\n        theta_p = np.mod(theta_prop, 2.0 * np.pi)\n        if theta_p > np.pi:\n            theta_p = 2.0 * np.pi - theta_p\n            \n        # For phi: wrapping modulo 2*pi\n        phi_p = np.mod(phi_prop, 2.0 * np.pi)\n        \n        # Calculate acceptance probability\n        if correct_jacobian:\n            # The target distribution is uniform on the sphere, so pi(s')/pi(s) = 1.\n            # The acceptance probability is determined by the Jacobian factor.\n            sin_theta_k = np.sin(theta)\n            sin_theta_p = np.sin(theta_p)\n            \n            # To avoid division by zero if theta is at a pole (0 or pi).\n            if sin_theta_k < 1e-12:\n                # If moving from a pole, the volume element is increasing from zero,\n                # so the move should always be accepted unless the proposed\n                # point is also a pole, in which case the ratio is 1.\n                acceptance_ratio = 1.0 if sin_theta_p < 1e-12 else np.inf\n            else:\n                acceptance_ratio = sin_theta_p / sin_theta_k\n            \n            alpha = min(1.0, acceptance_ratio)\n        else:\n            # Incorrect variant: ignore the Jacobian factor.\n            # Since the target density is uniform, the acceptance probability is 1.\n            alpha = 1.0\n            \n        # Accept or reject the move\n        if rng.uniform(0.0, 1.0) < alpha:\n            theta = theta_p\n            phi = phi_p\n            \n        # Collect samples after the burn-in period\n        if step >= B:\n            observable_sum += np.cos(theta)**2\n            samples_collected += 1\n            \n    if samples_collected == 0:\n        return np.nan\n        \n    return observable_sum / samples_collected\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, calculate all required values,\n    and print the final output in the specified format.\n    \"\"\"\n    # ====== Task 1: Evaluate Jacobian determinant J(R, theta) ======\n    # J(R, theta) = R^2 * sin(theta)\n    \n    # Test case 1: (R, theta) = (1, pi/6)\n    R1, theta1 = 1.0, np.pi/6.0\n    J1 = R1**2 * np.sin(theta1)\n    \n    # Test case 2: (R, theta) = (2, pi/2)\n    R2, theta2 = 2.0, np.pi/2.0\n    J2 = R2**2 * np.sin(theta2)\n    \n    # Test case 3: (R, theta) = (3, pi)\n    R3, theta3 = 3.0, np.pi\n    J3 = R3**2 * np.sin(theta3)\n    \n    # ====== Task 2: Evaluate proposal-density Jacobian ratio factor ======\n    # Factor = sin(theta') / sin(theta)\n    \n    # Test case 1: (theta, theta') = (pi/12, pi/3)\n    theta_a1, theta_a2 = np.pi/12.0, np.pi/3.0\n    F1 = np.sin(theta_a2) / np.sin(theta_a1)\n\n    # Test case 2: (theta, theta') = (pi/3, 5*pi/12)\n    theta_b1, theta_b2 = np.pi/3.0, 5.0*np.pi/12.0\n    F2 = np.sin(theta_b2) / np.sin(theta_b1)\n    \n    # ====== Task 3: Run Monte Carlo simulations ======\n    sim_params = (\n        200000,  # N: total steps\n        5000,    # B: burn-in steps\n        1.0,     # R: radius\n        1.234,   # theta0\n        2.345,   # phi0\n        0.3,     # sigma_theta\n        0.6      # sigma_phi\n    )\n    seed = 123\n    \n    # Run simulation with correct Jacobian factor\n    E_correct = run_mc_simulation(sim_params, correct_jacobian=True, seed=seed)\n    \n    # Run simulation with incorrect (ignored) Jacobian factor\n    E_wrong = run_mc_simulation(sim_params, correct_jacobian=False, seed=seed)\n\n    # Collate results\n    results = [J1, J2, J3, F1, F2, E_correct, E_wrong]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2458841"}]}