{"hands_on_practices": [{"introduction": "为了模拟体相系统而非孤立的纳米团簇，分子动力学（MD）模拟广泛采用周期性边界条件（PBC）。此练习将带您实践几乎所有MD模拟的基石：为正交模拟盒子实现最小镜像约定（MIC）。通过编程解决此问题，您将学会如何正确计算周期性系统中的粒子间距离，这是精确计算力和能量的先决条件 [@problem_id:2458300]。", "problem": "您需要编写一个完整、可运行的程序，以演示在分子动力学 (MD) 模拟中周期性边界条件的最小镜像约定的效果。该程序必须以两种方式计算正交周期性模拟盒子中两个粒子之间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位表示，并报告四舍五入到恰好六位小数的结果。\n\n背景与基本原理：在采用周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，通过对有限的模拟盒子进行无限平铺来模拟宏观体系的行为。两个粒子之间的物理距离被解释为一个粒子与另一个粒子的任意周期性镜像之间的最小距离。其底层的几何规则源于欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离的获得方式是：沿着每个轴选择整数倍盒子长度的平移，以使位移矢量的欧几里得范数最小化。您的程序必须实现这一规则。\n\n您的任务：\n- 定义一个函数，给定两个以纳米为单位的三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子边长 $(L_x,L_y,L_z)$，该函数返回两个值：\n  1) 朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$（单位 nm），\n  2) 最小镜像约定距离 $d_{\\text{mic}}$（单位 nm），该距离通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以最小化其范数而获得。\n- 将盒子视为正交且轴对齐的。\n- 坐标位置可能位于主盒子区间之外。您的实现必须仍然能够利用周期性正确计算 $d_{\\text{mic}}$。\n- 为使您的实现清晰，请在程序中包含一个多行伪代码字符串（该字符串不被打印），用以概述您所实现的最小镜像约定逻辑。\n\n数值与单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离必须四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n您的程序必须按照给定的顺序，为以下 $5$ 个测试用例中的每一个计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小间距：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿单个坐标轴跨越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子及沿多轴的回绕：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿单个坐标轴恰好为半个盒子长度的间距（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 坐标位置位于主盒子区间之外：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的数对列表。每个数对按指定顺序对应一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值均以纳米为单位且四舍五入到恰好 $6$ 位小数。输出中不得有空格。\n- 例如，要求的整体格式为 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且有恰好 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基本练习，具体涉及分子动力学 (MD) 模拟中周期性边界条件 (PBC) 的实现。使用 PBC 是一种标准且必要的技术，它通过模拟少量有限的粒子来近似宏观系统的性质。它减轻了严重的表面效应，否则这种效应将主导小系统的行为。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所决定。\n\n该问题提法明确，有科学依据，并为获得唯一且可验证的解提供了所有必要的数据。我们将进行严格的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，即 $\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它是根据位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出的。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。这种计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上被无限复制。位于位置 $\\mathbf{r}$ 的粒子，其周期性镜像构成一个无限晶格，位置为 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$，其中 $n_x, n_y, n_z$ 为任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任意*一个周期性镜像之间的最短距离。\n\n在数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 以最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是最接近比值 $\\Delta x / L_x$ 的整数时，即可达到此目的。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经过 MIC 调整的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n此公式将位移矢量分量正确地“回绕”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑适用于 $y$ 和 $z$ 分量。于是，完整的经 MIC 调整的位移矢量 $\\Delta\\mathbf{r}'$ 为：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这个矢量运算是鲁棒的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移才有意义。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个调整后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n所提供的测试用例将使用这一既定方法来解决。实现将利用 `numpy` 库进行高效的矢量运算。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到恰好 $6$ 位小数进行报告。对于位移恰好为半个盒子长度的特殊情况，例如 $\\Delta x = L_x/2$，它由 `round` 函数处理，该函数通常会舍入到最近的偶数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "定义了模拟盒子后，我们必须在时间上推进系统。本练习将深入探讨MD算法的核心，研究速度Verlet积分器——因其稳定性和辛性而被广泛使用的积分方法。通过理论推导并以经验方式验证能量误差与时间步长 $\\Delta t$ 的标度关系，您将更深刻地理解数值选择如何影响模拟的物理准确性 [@problem_id:2651929]。", "problem": "考虑一个一维简谐振子，其质量为 $m$，弹簧常数为 $k$，在牛顿第二定律 $m\\,d^2x/dt^2 = -\\,dV/dx$ 和势 $V(x) = \\tfrac{1}{2}k x^2$ 的作用下演化。在分子动力学（MD）中，一种常用的二阶辛、时间可逆积分器是速度Verlet格式。从哈密顿力学的角度来看，辛积分器保持相空间体积，并精确守恒一个修正哈密顿量，该修正哈密顿量与真实哈密顿量之差为时间步长 $\\Delta t$ 的高阶项。从这个基本基础（牛顿定律、哈密顿结构以及辛积分和时间可逆积分的定义）出发，推导速度Verlet积分器的全局能量误差关于 $\\Delta t$ 的领头阶标度关系。具体来说，将在时长为 $T$ 的模拟中的绝对能量偏差 $A(\\Delta t)$ 定义为\n$$\nA(\\Delta t) = \\max_{0 \\le t \\le T}\\,\\big|E(t) - E(0)\\big| \\quad \\text{其中} \\quad E(t) = \\tfrac{1}{2}m v(t)^2 + \\tfrac{1}{2}k x(t)^2,\n$$\n并量化对于二阶辛速度Verlet方法，当 $\\Delta t \\to 0$ 时，$A(\\Delta t)$ 如何随 $\\Delta t$ 标度变化。\n\n然后，设计一个经验性方案，用于在微正则系综（粒子数 $N$、体积 $V$ 和能量 $E$ 恒定；常称为 $NVE$）的生产性分子动力学（MD）模拟中测量能量漂移，并将此方案转化为关于谐振子的计算实验。具体来说：\n- 为具有参数 $m$、$k$、初始位置 $x(0)$ 和初始速度 $v(0)$ 的谐振子实现速度Verlet积分器。\n- 对于一组时间步长 $\\{\\Delta t_i\\}$，将积分器运行至总时间 $T$，并记录每个离散时间 $t_n = n \\Delta t_i$ 时的总能量 $E(t_n)$。对于每个 $\\Delta t_i$：\n  1. 计算绝对能量偏差 $A(\\Delta t_i) = \\max_n |E(t_n) - E(0)|$，单位为焦耳。\n  2. 将单位时间的经验线性能量漂移 $D(\\Delta t_i)$（单位为焦耳/秒）估计为运行期间 $E(t)$ 对 $t$ 的最小二乘斜率，即在普通最小二乘意义上对点 $(t_n, E(t_n))$ 的最佳拟合直线的斜率。\n  3. 通过监测积分在 $[0,T]$ 上是否保持数值稳定来确定一个布尔稳定性标志。如果在任何采样点，总能量变为非有限或增长超过 $E(0)$ 的某个预设倍数，则声明轨迹不稳定；否则声明其稳定。\n- 仅使用稳定轨迹，通过对 $\\log A$ 和 $\\log \\Delta t$ 进行线性回归来拟合幂律 $A(\\Delta t) \\propto \\Delta t^{p}$，以估计标度指数 $p$。\n\n您的程序必须使用以下物理参数和测试套件，并以指定单位报告所要求的量：\n- 物理参数：\n  - 质量 $m = 1.66053906660 \\times 10^{-27}\\ \\text{kg}$。\n  - 劲度系数 $k = 1.0\\ \\text{N}\\,\\text{m}^{-1}$。\n  - 初始条件 $x(0) = 1.0 \\times 10^{-9}\\ \\text{m}$ 和 $v(0) = 0.0\\ \\text{m}\\,\\text{s}^{-1}$。\n- 总模拟时间：$T = 2.0 \\times 10^{-11}\\ \\text{s}$。\n- 时间步长测试套件：\n  - $\\Delta t_1 = 1.0 \\times 10^{-15}\\ \\text{s}$ (典型稳定情况)。\n  - $\\Delta t_2 = 2.0 \\times 10^{-15}\\ \\text{s}$ (典型稳定情况)。\n  - $\\Delta t_3 = 4.0 \\times 10^{-15}\\ \\text{s}$ (较大但预期稳定)。\n  - $\\Delta t_4 = 3.0 \\times 10^{-14}\\ \\text{s}$ (超出谐振子的线性稳定性极限，即一个预期不稳定的边缘情况)。\n- 稳定性检测规则：如果任何时候总能量非有限或满足 $|E(t) - E(0)|/E(0) > 10^{6}$，则声明轨迹不稳定并停止该 $\\Delta t$ 的运行。\n\n单位和数值报告要求：\n- 以焦耳为单位报告 $A(\\Delta t_i)$。\n- 以焦耳/秒为单位报告 $D(\\Delta t_i)$。\n- 指数 $p$ 是无量纲的。\n- 本问题不使用角度。\n- 所有浮点数应以编程语言默认转换产生的标准十进制或科学记数法输出，输出中不嵌入单位。\n\n最终输出格式：\n- 您的程序应生成包含单个列表的单行输出。此列表必须为测试套件中的每个时间步长包含一个条目，最后一个条目为指数 $p$。每个时间步长的条目必须是 $[\\text{stable}, A(\\Delta t_i), D(\\Delta t_i)]$ 的形式，其中 $\\text{stable}$ 是一个布尔值。因此，输出应如下所示：\n$[[\\text{stable}_1, A_1, D_1],[\\text{stable}_2, A_2, D_2],[\\text{stable}_3, A_3, D_3],[\\text{stable}_4, A_4, D_4],p]$\n逗号后无空格，并用一对单独的方括号括起来。\n\n覆盖性设计：\n- 所选的 $\\Delta t_1$ 和 $\\Delta t_2$ 代表了用于评估标度关系的典型稳定案例。\n- 所选的 $\\Delta t_3$ 探究了较大但仍稳定的步长。\n- 所选的 $\\Delta t_4$ 超过了线性稳定性极限 $\\Delta t < 2/\\omega$（其中 $\\omega = \\sqrt{k/m}$），旨在触发不稳定性检测器。\n\n您的推导必须从所述的基本原理开始，并且不得预先假设目标标度关系。", "solution": "所述问题定义明确，植根于经典力学和数值分析的基本原理。它在科学上是合理的，并为得出唯一解提供了所有必要信息。我们着手解决此问题，包括一个理论推导和一个计算流程。\n\n**能量误差标度的理论推导**\n\n所考虑的系统是一个一维简谐振子，其哈密顿量为 $H(x, p) = \\frac{p^2}{2m} + \\frac{1}{2}kx^2$，其中 $p=mv$ 是动量。运动方程为 $m\\ddot{x} = -kx$。动力学将使用速度Verlet算法进行积分，这是一种二阶对称的辛积分器。\n\n从时间 $t$ 到 $t+\\Delta t$ 的一个时间步长 $\\Delta t$ 的更新方案如下：\n$$x(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2$$\n$$v(t + \\Delta t) = v(t) + \\frac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right]\\Delta t$$\n其中 $a(t) = F(x(t))/m = -kx(t)/m$。\n\n辛积分器的一个基本性质是它不守恒系统的真实哈密顿量 $H$。相反，该算法生成的点序列 $(x_n, v_n)$ 位于一个修正的或“影子”哈密顿量 $\\tilde{H}$ 的不变流形上。对于一个 $2r$ 阶的对称积分器（对于速度Verlet，阶数为2，所以 $r=1$），这个影子哈密顿量可以表示为时间步长 $\\Delta t$ 的偶次幂的渐近级数：\n$$\\tilde{H}(x, v; \\Delta t) = H(x, v) + (\\Delta t)^2 H_2(x, v) + (\\Delta t)^4 H_4(x, v) + \\mathcal{O}((\\Delta t)^6)$$\n函数 $H_j(x, v)$ 由原始哈密顿量和积分器的具体形式决定。\n\n在时间点 $t_n = n\\Delta t$ 上的数值轨迹 $(x_n, v_n)$ 精确地守恒这个影子哈密顿量（在机器精度范围内）：\n$$\\tilde{H}(x_n, v_n; \\Delta t) = \\text{常数} = \\tilde{E}_0$$\n这个守恒量 $\\tilde{E}_0$ 的值由初始条件 $(x_0, v_0)$ 确定：\n$$\\tilde{E}_0 = \\tilde{H}(x_0, v_0; \\Delta t) = H(x_0, v_0) + (\\Delta t)^2 H_2(x_0, v_0) + \\mathcal{O}((\\Delta t)^4)$$\n设 $E_0 = H(x_0, v_0)$ 为真实初始能量。那么 $\\tilde{E}_0 \\approx E_0 + (\\Delta t)^2 H_2(x_0, v_0)$。\n\n模拟过程中测量的能量是*真实*哈密顿量 $E_n = H(x_n, v_n)$ 在数值轨迹上每一点的值。通过重新排列 $\\tilde{H}$ 的级数，我们可以将 $E_n$ 表示为：\n$$E_n = H(x_n, v_n) = \\tilde{H}(x_n, v_n; \\Delta t) - (\\Delta t)^2 H_2(x_n, v_n) - \\mathcal{O}((\\Delta t)^4)$$\n由于对于所有 $n$，$\\tilde{H}(x_n, v_n; \\Delta t) = \\tilde{E}_0$，我们有：\n$$E_n \\approx \\tilde{E}_0 - (\\Delta t)^2 H_2(x_n, v_n)$$\n我们感兴趣的是能量与初始能量的偏差 $E_n - E_0$。代入 $\\tilde{E}_0$ 的表达式：\n$$E_n - E_0 \\approx \\left( E_0 + (\\Delta t)^2 H_2(x_0, v_0) \\right) - (\\Delta t)^2 H_2(x_n, v_n) - E_0$$\n$$E_n - E_0 \\approx (\\Delta t)^2 \\left( H_2(x_0, v_0) - H_2(x_n, v_n) \\right)$$\n对于像谐振子这样的束缚系统，轨迹 $(x_n, v_n)$ 在相空间中是周期性或准周期性的。随着系统的演化，函数 $H_2(x_n, v_n)$ 的值会发生变化。这导致计算出的能量 $E_n$ 围绕一个平均值振荡，而不是保持恒定或系统性漂移。这些能量振荡的振幅与领头阶项 $(\\Delta t)^2$ 成正比。\n\n我们感兴趣的量是最大绝对能量偏差 $A(\\Delta t) = \\max_n |E_n - E_0|$。根据上述分析，此偏差的大小由 $(\\Delta t)^2$ 项在整个轨迹上的最大变化决定。因此，我们推导出标度律：\n$$A(\\Delta t) \\propto (\\Delta t)^2$$\n这预测了关系式 $A(\\Delta t) \\propto (\\Delta t)^p$ 中的标度指数 $p$ 等于 $2$。线性能量漂移 $D(\\Delta t)$ 预计可以忽略不计，它源于有限精度计算而非算法本身，因为对于有界运动，辛积分器没有系统性能量漂移。\n\n**计算方案**\n\n这个理论结果将通过指定的直接数值模拟进行经验性检验。步骤如下：\n1.  **积分器实现**：为力 $F(x) = -kx$ 的一维简谐振子实现速度Verlet算法。\n2.  **模拟循环**：对于所提供的测试套件中的每个时间步长 $\\Delta t_i$，从 $t=0$ 到 $t=T$ 执行模拟。状态 $(x(t), v(t))$ 初始化为 $(x(0), v(0))$。\n3.  **数据收集与稳定性检查**：在每一步 $n$，计算并存储总能量 $E(t_n) = \\frac{1}{2}m v(t_n)^2 + \\frac{1}{2}k x(t_n)^2$。进行稳定性检查：如果 $|E(t_n) - E(0)|/E(0) > 10^6$ 或者 $E(t_n)$ 变为非有限值，则将轨迹标记为不稳定，并终止该 $\\Delta t_i$ 的模拟。\n4.  **指标计算**：在完成（或终止）给定 $\\Delta t_i$ 的运行后：\n    *   在生成的轨迹上计算绝对能量偏差 $A(\\Delta t_i) = \\max_n |E(t_n) - E(0)|$。\n    *   通过对能量数据 $\\{E(t_n)\\}$ 与时间数据 $\\{t_n\\}$ 进行普通最小二乘线性回归，来估计单位时间的线性能量漂移 $D(\\Delta t_i)$。$D(\\Delta t_i)$ 是最佳拟合线的斜率。\n5.  **标度指数估计**：使用所有*稳定*轨迹的数据，确定标度指数 $p$。这是通过拟合幂律 $A(\\Delta t) = C(\\Delta t)^p$ 来实现的。对两边取对数得到 $\\log A = p \\log \\Delta t + \\log C$。对 $\\log A$ 与 $\\log \\Delta t$ 进行线性回归，所得斜率即为 $p$ 的经验估计值。\n\n该计算实验旨在验证 $p=2$ 的理论预测，量化能量涨落，并测试该系统积分器的稳定性极限。最终输出将是一个执行此方案并按指定格式报告结果的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing the velocity Verlet integrator for a 1D harmonic oscillator.\n    \n    This function performs the following steps:\n    1. Sets up the physical parameters and simulation settings for a harmonic oscillator.\n    2. Iterates through a test suite of time steps (dt).\n    3. For each dt, runs a molecular dynamics simulation using the velocity Verlet algorithm.\n    4. Monitors the simulation for numerical stability based on energy conservation.\n    5. Calculates the maximum absolute energy deviation (A) and the linear energy drift (D).\n    6. For stable runs, performs a power-law fit to find the scaling exponent (p) of A versus dt.\n    7. Formats and prints the results as specified in the problem statement.\n    \"\"\"\n    \n    # Physical parameters and initial conditions\n    m = 1.66053906660e-27  # Mass in kg\n    k = 1.0                # Spring constant in N/m\n    x0 = 1.0e-9            # Initial position in m\n    v0 = 0.0               # Initial velocity in m/s\n    \n    # Simulation parameters\n    T_total = 2.0e-11      # Total simulation time in s\n    dts = [1.0e-15, 2.0e-15, 4.0e-15, 3.0e-14] # Time step test suite in s\n    \n    # Stability detection rule\n    STABILITY_REL_ENERGY_THRESHOLD = 1e6\n\n    # Initial energy, E(0)\n    E0 = 0.5 * k * x0**2 + 0.5 * m * v0**2\n\n    final_results = []\n    stable_run_data = []\n\n    for dt in dts:\n        # --- Simulation for a single time step dt ---\n        # Initialization\n        x, v = x0, v0\n        t = 0.0\n        \n        times = [t]\n        energies = [E0]\n        \n        stable = True\n        \n        # Initial acceleration a(t=0)\n        a = -k * x / m\n        \n        # Run the integrator up to total time T\n        num_steps = int(np.ceil(T_total / dt))\n        for _ in range(num_steps):\n            # Velocity Verlet Algorithm\n            # 1. Update position x(t + dt)\n            x_new = x + v * dt + 0.5 * a * dt**2\n            \n            # 2. Calculate new acceleration a(t + dt)\n            a_new = -k * x_new / m\n            \n            # 3. Update velocity v(t + dt)\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            # Update state for the next iteration\n            x, v, a = x_new, v_new, a_new\n            t += dt\n            \n            # Calculate and store current energy E(t)\n            current_E = 0.5 * k * x**2 + 0.5 * m * v**2\n            \n            # Append results for this step\n            times.append(t)\n            energies.append(current_E)\n\n            # Check for numerical instability and terminate run if needed\n            is_finite = np.isfinite(current_E)\n            rel_error_exceeded = (E0 > 0 and abs(current_E - E0) / E0 > STABILITY_REL_ENERGY_THRESHOLD)\n            \n            if not is_finite or rel_error_exceeded:\n                stable = False\n                break\n    \n        # --- Post-processing for this dt ---\n        times_arr = np.array(times)\n        energies_arr = np.array(energies)\n        \n        # Filter out non-finite values that could result from instability\n        finite_indices = np.isfinite(energies_arr)\n        valid_times = times_arr[finite_indices]\n        valid_energies = energies_arr[finite_indices]\n\n        # 1. Compute absolute energy deviation A(dt)\n        if valid_energies.size > 0:\n            A_dt = np.max(np.abs(valid_energies - E0))\n        else:\n            A_dt = np.inf\n\n        # 2. Estimate linear energy drift D(dt) via least-squares\n        if valid_times.size > 1:\n            # linregress returns: slope, intercept, r-value, p-value, stderr\n            D_dt, _, _, _, _ = linregress(valid_times, valid_energies)\n        else:\n            D_dt = 0.0\n        \n        # Store results for this dt\n        final_results.append([stable, A_dt, D_dt])\n        \n        if stable:\n            stable_run_data.append({'dt': dt, 'A': A_dt})\n\n    # --- Final analysis across stable runs ---\n    # Fit power law A(dt) ~ dt^p by linear regression of log(A) on log(dt)\n    if len(stable_run_data) > 1:\n        log_dts = np.log([d['dt'] for d in stable_run_data])\n        log_As = np.log([d['A'] for d in stable_run_data])\n        # The slope of the log-log plot is the scaling exponent p\n        p, _, _, _, _ = linregress(log_dts, log_As)\n    else:\n        # This case should not be reached with the given problem parameters\n        p = np.nan\n\n    # --- Format final output string ---\n    output_parts = []\n    for result_item in final_results:\n        stable_str = str(result_item[0]).lower()\n        A_val = result_item[1]\n        D_val = result_item[2]\n        output_parts.append(f'[{stable_str},{A_val},{D_val}]')\n    \n    output_parts.append(str(p))\n    \n    # Print the single-line output in the exact required format\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2651929"}, {"introduction": "一次成功的MD模拟不仅要稳定运行，还必须正确地对目标统计系综进行抽样。这项实践要求您从程序员转变为计算科学家，为恒温器的输出设计一个严谨的统计检验。通过实现带有Kolmogorov-Smirnov检验的参数自助法，您将学到一种强大的、可推广的方法，以验证您的模拟是否产生了与正则系综一致的、具有物理意义的结果 [@problem_id:2652001]。", "problem": "您的任务是设计并实现一个严谨的、程序化的统计检验，以验证分子动力学（MD）恒温器是否能为一个具有已知二次自由度数量的系统生成正则动能分布。在对应于逆热能 $\\beta$ 的温度下的正则系综中，一个具有 $f$ 个独立二次自由度的系统的瞬时标量动能 $K \\ge 0$ 预计遵循以下分布\n$$\nP(K) \\propto K^{\\frac{f}{2} - 1} e^{-\\beta K}.\n$$\n这是伽马分布族，其形状参数为 $k = \\frac{f}{2}$，尺度参数为 $\\theta = \\frac{1}{\\beta}$。\n\n从以下基本事实出发：\n- 玻尔兹曼分布意味着在正则系综中，对于哈密顿量 $H$，概率密度与 $\\exp(-\\beta H)$ 成正比。\n- 对于一个具有 $f$ 个独立二次速度模式的系统，动能是 $f$ 个二次项之和，从而得到动能 $K$ 的伽马分布，其形状参数为 $k = \\frac{f}{2}$。\n- 概率积分变换指出，如果 $X$ 具有连续累积分布函数 $F$，则 $U = F(X)$ 在 $[0,1]$ 上服从均匀分布。\n\n您的任务是提出、论证并实现一个具有以下零假设和操作约束的假设检验：\n- 零假设 $H_0$：动能样本 $\\{K_i\\}_{i=1}^n$ 是独立同分布的，遵循正则预测，其中 $f$ 已知（因此形状参数 $k = \\frac{f}{2}$ 已知），而未知的 $\\beta > 0$ 需要从样本中估计。\n- 检验设计约束：\n  1. 您必须在 $H_0$ 假设下，使用仅由固定 $k$ 的最大似然法证明为合理的量，从数据中估计 $\\beta$。\n  2. 您必须使用拟合模型的累积分布函数对样本进行变换，以获得在 $H_0$ 假设下应为在 $[0,1]$ 上独立同分布的均匀分布值。\n  3. 您必须计算一个在整个支持域上都敏感的无分布拟合优度统计量，并在 $\\beta$ 是估计值的情况下，校准其在 $H_0$ 下的抽样分布。解析校准不能假设参数已知；相反，您必须使用一个从第一性原理出发且与 $H_0$ 一致的、有原则的重抽样方法。\n\n实现要求：\n- 编写一个完整且可运行的程序，该程序构建以下合成测试数据集（无量纲能量；不需要物理单位），对每个数据集应用您的检验，并输出一行包含布尔决策列表的内容，指明对于每个测试用例，是否在显著性水平 $\\alpha = 0.05$ 下接受 $H_0$。使用以下确定性数据集构建规则：\n  - 对于任何“纯伽马”数据集，使用逆累积分布函数，在均匀间隔的分位数 $u_i = \\frac{i - \\frac{1}{2}}{n}$（其中 $i = 1,\\dots,n$）处构建一个大小为 $n$ 的确定性分布样本，方法是取 $K_i = F^{-1}_{\\Gamma}(u_i; k, \\theta)$，其中 $k = \\frac{f}{2}$ 且 $\\theta = \\frac{1}{\\beta_{\\text{true}}}$。\n  - 对于任何“混合”数据集，一半样本来自参数为 $(k, \\theta_1)$ 的伽马分布的逆累积分布函数分位数，另一半来自参数为 $(k, \\theta_2)$ 的伽马分布，每半部分都使用均匀间隔的分位数。\n- 您的检验必须实现：\n  - 从样本均值 $\\overline{K}$ 获得的、针对固定 $k = \\frac{f}{2}$ 的 $\\beta$ 的最大似然估计量。\n  - 一个概率积分变换 $u_i = F_{\\Gamma}(K_i; k, \\hat{\\theta})$，其中 $\\hat{\\theta} = \\frac{1}{\\hat{\\beta}}$。\n  - 一个从 $\\{u_i\\}$ 计算的单样本柯尔莫哥洛夫-斯米尔诺夫统计量，通过参数化自举法进行校准，该方法使用 $B$ 个在拟合参数 $\\hat{\\beta}$ 下、根据 $H_0$ 生成的合成数据集，其中每个自举数据集都重新估计 $\\hat{\\beta}^{(b)}$ 并重新计算统计量。使用无偏有限样本 p 值约定 $p = \\frac{1 + \\#\\{D^{(b)} \\ge D_{\\text{obs}}\\}}{B + 1}$。自举法是为考虑从数据中估计参数这一因素所必需的校准方法。\n- 显著性水平：$\\alpha = 0.05$（无量纲）。\n- 不涉及角度单位。\n- 最终输出格式：您的程序应生成单行输出，其中包含对测试套件的决策，格式为逗号分隔的 Python 布尔值列表，例如，“[True,False,True]”。\n\n在程序内部实现的测试套件：\n- 案例 1（理想情况，中等 $f$）：$f = 12$，$\\beta_{\\text{true}} = 0.8$， $n = 2500$，纯伽马分布，使用假定的 $f = 12$ 进行检验。\n- 案例 2（理想情况，指数分布特例）：$f = 2$，$\\beta_{\\text{true}} = 1.5$，$n = 1000$，纯伽马分布，使用假定的 $f = 2$ 进行检验。\n- 案例 3（结构化模型违例；温度不均匀性）：$f = 12$，$n = 2500$，由等权重的 $\\beta_1 = 0.8$ 和 $\\beta_2 = 1.2$ 混合而成，使用假定的 $f = 12$ 进行检验。\n- 案例 4（结构化模型违例；有效自由度不正确）：真实生成器 $f_{\\text{true}} = 16$，$\\beta_{\\text{true}} = 1.0$，$n = 3000$，但使用假定的 $f = 12$ 进行检验。\n- 案例 5（边界条件；小样本，纯伽马分布）：$f = 12$，$\\beta_{\\text{true}} = 0.8$，$n = 80$，纯伽马分布，使用假定的 $f = 12$ 进行检验。\n\n所有能量都是无量纲的。您的程序必须完全按照规定在内部构建这些数据集，使用 $B = 500$ 次重复的参数化自举法执行检验（使用固定的随机种子以确保确定性输出），并按案例 1 到 5 的顺序，打印包含布尔决策列表的单行内容。", "solution": "任务是设计并实现一个统计检验，以验证来自某个分子动力学模拟的动能样本是否遵循理论上预测的正则分布。此问题定义明确且科学上合理，它基于统计力学和统计推断的基本原理。我们将给出一个完整且论证充分的解决方案。\n\n问题的核心是针对一个形状参数已知、但尺度参数未知且必须从数据中估计的伽马分布进行拟合优度检验。\n\n**1. 零假设和动能分布**\n\n零假设 $H_0$ 指出，动能样本 $\\{K_i\\}_{i=1}^n$ 是独立同分布（i.i.d.）的，遵循为正则系综中的系统所预测的分布。对于一个具有 $f$ 个独立二次自由度的系统，动能 $K$ 遵循伽马分布。伽马分布的概率密度函数（PDF）由下式给出：\n$$\nP(K; k, \\theta) = \\frac{1}{\\Gamma(k)\\theta^k} K^{k-1} e^{-K/\\theta}\n$$\n其中 $k$ 是形状参数，$\\theta$ 是尺度参数。在我们的物理情境中，形状参数由自由度决定，$k = f/2$，而尺度参数通过 $\\theta = 1/\\beta$ 与逆温度 $\\beta = (k_B T)^{-1}$ 相关联。由于问题陈述使用 $\\beta$ 作为感兴趣的参数，我们可以将 PDF 写为：\n$$\nP(K; k, \\beta) = \\frac{\\beta^k}{\\Gamma(k)} K^{k-1} e^{-\\beta K}\n$$\n在 $H_0$ 假设下，形状参数 $k$ 是已知的（因为 $f$ 已给定），但 $\\beta$ 是未知的。\n\n**2. 尺度参数 $\\beta$ 的最大似然估计**\n\n为了执行检验，我们必须首先从业已观测的数据 $\\{K_i\\}_{i=1}^n$ 中估计未知参数 $\\beta$。题目指定了最大似然估计（MLE）方法。似然函数是观测到数据的联合概率，对于 i.i.d. 样本，它是各单个概率的乘积：\n$$\n\\mathcal{L}(\\beta | \\{K_i\\}, k) = \\prod_{i=1}^n P(K_i; k, \\beta) = \\prod_{i=1}^n \\frac{\\beta^k}{\\Gamma(k)} K_i^{k-1} e^{-\\beta K_i} \n$$\n处理对数似然函数 $\\ln \\mathcal{L}$ 更为方便：\n$$\n\\ln \\mathcal{L}(\\beta) = \\sum_{i=1}^n \\left( k \\ln \\beta - \\ln \\Gamma(k) + (k-1) \\ln K_i - \\beta K_i \\right)\n$$\n$$\n\\ln \\mathcal{L}(\\beta) = n k \\ln \\beta - n \\ln \\Gamma(k) + (k-1) \\sum_{i=1}^n \\ln K_i - \\beta \\sum_{i=1}^n K_i\n$$\n为了找到使该函数最大化的 $\\beta$ 值，我们对其求关于 $\\beta$ 的导数并令其为零：\n$$\n\\frac{d \\ln \\mathcal{L}}{d \\beta} = \\frac{n k}{\\beta} - \\sum_{i=1}^n K_i = 0\n$$\n对 $\\beta$ 求解，得到其 MLE，记为 $\\hat{\\beta}$：\n$$\n\\frac{n k}{\\hat{\\beta}} = \\sum_{i=1}^n K_i \\implies \\hat{\\beta} = \\frac{n k}{\\sum_{i=1}^n K_i} = \\frac{k}{\\overline{K}}\n$$\n其中 $\\overline{K} = \\frac{1}{n} \\sum_{i=1}^n K_i$ 是样本平均动能。对应的尺度参数 $\\theta$ 的 MLE 是 $\\hat{\\theta} = 1/\\hat{\\beta} = \\overline{K}/k$。这证实了所要求的估计步骤。\n\n**3. 拟合优度检验**\n\n有了估计参数 $\\hat{\\beta}$，我们现在可以进行拟合优度检验。\n\n**步骤 3a：概率积分变换（PIT）**\nPIT 指出，对于一个具有累积分布函数（CDF）$F_X(x)$ 的连续随机变量 $X$，随机变量 $U = F_X(X)$ 在 $[0, 1]$ 上服从均匀分布。我们将此原理应用于我们的数据。假设 $H_0$为真且我们的估计参数 $\\hat{\\beta}$ 接近真实值，那么变换后的值\n$$\nu_i = F_{\\Gamma}(K_i; k, \\hat{\\beta}) = \\int_0^{K_i} P(x; k, \\hat{\\beta}) dx\n$$\n应形成一个近似于从 Uniform($0,1$) 分布中抽取的 i.i.d. 样本。与均匀分布的显著偏离构成了反对 $H_0$ 的证据。\n\n**步骤 3b：柯尔莫哥洛夫-斯米尔诺夫（KS）统计量**\n为了量化与均匀性的偏离，我们使用单样本柯尔莫哥洛夫-斯米尔诺夫（KS）统计量。我们首先计算变换后样本 $\\{u_i\\}_{i=1}^n$ 的经验分布函数（EDF）。令 $u_{(i)}$ 为排序后的值。EDF 为：\n$$\nE_n(u) = \\frac{1}{n} \\sum_{i=1}^n \\mathbb{I}(u_i \\le u)\n$$\nKS 统计量 $D_n$ 是 EDF 与目标分布的 CDF 之间的最大绝对差值。在此情况下，目标分布是标准均匀分布，其 CDF 为 $F_U(u) = u$（对于 $u \\in [0,1]$）：\n$$\nD_{obs} = \\sup_{u \\in [0,1]} |E_n(u) - u|\n$$\n在计算上，这由下式给出：\n$$\nD_{obs} = \\max_{i=1, \\dots, n} \\left\\{ \\max\\left( \\frac{i}{n} - u_{(i)}, u_{(i)} - \\frac{i-1}{n} \\right) \\right\\}\n$$\n\n**4. 使用参数化自举法进行校准**\n\n一个关键点是，KS 统计量的标准临界值在这里不适用。标准的 KS 检验假定所假设分布的参数是预先指定且*不是*从数据中估计的。通过使用从数据中估计的 $\\hat{\\beta}$，我们将零假设分布与特定样本绑定，这通常导致 $D_{obs}$ 比使用真实 $\\beta$ 时预期的要小。这使得标准检验是保守的（即更不容易拒绝原假设）。\n\n为了获得正确的 p 值，我们必须在*给定参数是从数据中估计*的条件下，确定 $H_0$ 下 $D_n$ 的抽样分布。这可以通过参数化自举法实现，该方法在零假设下模拟了数据生成和检验的全过程。\n\n流程如下：\n1.  从原始数据 $\\{K_i\\}$ 计算 $\\overline{K}$ 和 MLE $\\hat{\\beta} = k/\\overline{K}$。\n2.  如上所述计算观察到的检验统计量 $D_{obs}$。\n3.  生成 $B$ 个自举样本。对于每个重复 $b=1, \\dots, B$：\n    a.  通过从拟合的伽马分布 $\\text{Gamma}(k, 1/\\hat{\\beta})$ 中抽取 $n$ 个随机变量，生成一个合成数据集 $\\{K_i^{*(b)}\\}_{i=1}^n$。\n    b.  对此合成数据集，计算其自身的参数 MLE：$\\hat{\\beta}^{*(b)} = k/\\overline{K}^{*(b)}$。\n    c.  使用其自身估计的参数，对合成数据应用 PIT：$u_i^{*(b)} = F_{\\Gamma}(K_i^{*(b)}; k, 1/\\hat{\\beta}^{*(b)})$。\n    d.  计算此重复的 KS 统计量 $D^{(b)}$。\n4.  集合 $\\{D^{(b)}\\}_{b=1}^B$ 作为我们检验统计量零分布的一个经验近似。\n\n**5. 决策规则**\n\np 值是在假设 $H_0$ 为真的前提下，观测到等于或比 $D_{obs}$ 更极端的检验统计量的概率。使用自举分布，我们按如下方式计算 p 值：\n$$\np = \\frac{1 + N_{\\text{extreme}}}{B+1}\n$$\n其中 $N_{\\text{extreme}} = \\#\\{D^{(b)} \\ge D_{obs}\\}$ 是达到或超过观测值的自举统计量的数量。在分子和分母上加 1 是一种标准约定，以避免 p 值为 0，并确保 p 值在零假设下得到适当校准。\n\n最后，我们将 p 值与预先指定的显著性水平 $\\alpha = 0.05$ 进行比较。\n- 如果 $p < \\alpha$，我们拒绝零假设 $H_0$。这表明数据并非来自指定的伽马分布族。对应的输出是 `False`。\n- 如果 $p \\ge \\alpha$，我们未能拒绝 $H_0$。这意味着数据与零假设一致。对应的输出是 `True`。\n\n这个完整的程序提供了一个严谨、有原则的检验方法，用于验证模拟中动能分布的有效性，并正确地考虑了参数估计的影响。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import gamma, kstest\n\ndef solve():\n    \"\"\"\n    Implements and applies a statistical test to verify the canonical kinetic energy distribution\n    from a Molecular Dynamics simulation, as specified in the problem statement.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the bootstrap procedure\n    np.random.seed(42)\n\n    # Parameters for the test\n    B = 500  # Number of bootstrap replicates\n    alpha = 0.05  # Significance level\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: happy path, moderate f\n        {'type': 'pure', 'f_true': 12, 'beta_true': 0.8, 'n': 2500, 'f_test': 12},\n        # Case 2: happy path, exponential special case\n        {'type': 'pure', 'f_true': 2, 'beta_true': 1.5, 'n': 1000, 'f_test': 2},\n        # Case 3: structured model violation; temperature inhomogeneity\n        {'type': 'mixture', 'f_true': 12, 'beta1': 0.8, 'beta2': 1.2, 'n': 2500, 'f_test': 12},\n        # Case 4: structured model violation; incorrect effective degrees of freedom\n        {'type': 'pure', 'f_true': 16, 'beta_true': 1.0, 'n': 3000, 'f_test': 12},\n        # Case 5: boundary condition; small sample, pure Gamma\n        {'type': 'pure', 'f_true': 12, 'beta_true': 0.8, 'n': 80, 'f_test': 12},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # --- 1. Generate Synthetic Dataset as per problem specification ---\n        n = case['n']\n        f_test = case['f_test']\n        k_test = f_test / 2.0\n\n        if case['type'] == 'pure':\n            f_true = case['f_true']\n            k_true = f_true / 2.0\n            beta_true = case['beta_true']\n            theta_true = 1.0 / beta_true\n            quantiles = (np.arange(1, n + 1) - 0.5) / n\n            K_data = gamma.ppf(quantiles, a=k_true, scale=theta_true)\n        elif case['type'] == 'mixture':\n            f_true = case['f_true']\n            k_true = f_true / 2.0\n            beta1, beta2 = case['beta1'], case['beta2']\n            theta1, theta2 = 1.0 / beta1, 1.0 / beta2\n            \n            n1 = n // 2\n            n2 = n - n1\n            \n            quantiles1 = (np.arange(1, n1 + 1) - 0.5) / n1\n            K1 = gamma.ppf(quantiles1, a=k_true, scale=theta1)\n            \n            quantiles2 = (np.arange(1, n2 + 1) - 0.5) / n2\n            K2 = gamma.ppf(quantiles2, a=k_true, scale=theta2)\n            \n            K_data = np.concatenate([K1, K2])\n\n        # --- 2. Perform Hypothesis Test ---\n        # Estimate parameters from data (MLE for Gamma with known shape)\n        K_bar_obs = np.mean(K_data)\n        # Handle case of zero mean, though unlikely with this data generation\n        if K_bar_obs == 0:\n            # Cannot proceed, but this case won't occur in practice here.\n            # We can treat this as a failure to reject.\n            results.append(True) \n            continue\n            \n        beta_hat_obs = k_test / K_bar_obs\n        theta_hat_obs = 1.0 / beta_hat_obs\n\n        # Apply Probability Integral Transform (PIT)\n        u_obs = gamma.cdf(K_data, a=k_test, scale=theta_hat_obs)\n        \n        # Compute the observed Kolmogorov-Smirnov statistic\n        D_obs = kstest(u_obs, 'uniform').statistic\n\n        # --- 3. Parametric Bootstrap Calibration ---\n        D_bootstrap = np.zeros(B)\n        for i in range(B):\n            # a. Generate bootstrap sample from the fitted null model\n            K_star = gamma.rvs(a=k_test, scale=theta_hat_obs, size=n)\n            \n            # b. Re-estimate beta for the bootstrap sample\n            K_bar_star = np.mean(K_star)\n            if K_bar_star == 0: # Extremely unlikely\n                beta_hat_star = np.inf\n                theta_hat_star = 0\n            else:\n                beta_hat_star = k_test / K_bar_star\n                theta_hat_star = 1.0 / beta_hat_star\n            \n            # c. Apply PIT to the bootstrap sample with its own re-estimated parameter\n            u_star = gamma.cdf(K_star, a=k_test, scale=theta_hat_star)\n            \n            # d. Compute and store the KS statistic for the bootstrap replicate\n            D_bootstrap[i] = kstest(u_star, 'uniform').statistic\n            \n        # --- 4. Calculate p-value and make a decision ---\n        num_extreme = np.sum(D_bootstrap >= D_obs)\n        p_value = (1.0 + num_extreme) / (B + 1.0)\n        \n        decision = (p_value >= alpha)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2652001"}]}