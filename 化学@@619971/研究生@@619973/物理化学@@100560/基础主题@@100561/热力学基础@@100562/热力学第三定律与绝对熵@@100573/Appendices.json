{"hands_on_practices": [{"introduction": "本练习将引导你从第一性原理出发，推导出一个核心的统计热力学公式——混合熵。通过运用玻尔兹曼熵公式 $S = k_{B} \\ln W$ 和斯特林近似，你将亲手揭示宏观熵值如何源于微观粒子排布的多样性。这个实践对于深刻理解熵的统计力学本质，以及第三定律中“完美晶体”假设的重要性至关重要。[@problem_id:2680901]", "problem": "一种单原子晶体由两种同位素 A 和 B 组成，它们以固定的摩尔分数 $x$ 和 $1-x$ 随机占据 $N$ 个等效晶格格点。假设在 $T \\to 0$ 的极限下，所有晶格格点对 A 和 B 而言在能量上是等效的，振动自由度处于基态，因此激发没有贡献，并且在 $T \\to 0$ 时简并度的唯一来源是同位素在格点上的取代排列。该固体是一种宏观上大尺寸的、遍历性不可及的、与其低温平衡组成一致的淬火无规排列。\n\n从熵的 Boltzmann 定义 $S = k_{B} \\ln W$ 和晶格上同位素可区分构型数 $W$ 的组合计数出发，在热力学极限下推导出每个摩尔晶格格点的摩尔残留熵 $S_{\\mathrm{res},m}$ 作为 $x$ 的函数。然后，对于等摩尔情况 $x = \\tfrac{1}{2}$，计算该摩尔残留熵。将最终数值结果以 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 为单位表示，并四舍五入到四位有效数字。", "solution": "所述问题是有效的。这是一个科学上成立、提法恰当且客观的物理化学问题，可以使用统计力学的基本原理解答。\n\n问题要求推导晶格上二元同位素混合物的摩尔残留熵 $S_{\\mathrm{res},m}$。该推导的基础是熵的 Boltzmann 定义，它将熵 $S$ 与系统可及的微观态数目 $W$ 联系起来：\n$$S = k_{B} \\ln W$$\n其中 $k_{B}$ 是 Boltzmann 常数。\n\n问题指明，在温度 $T \\to 0$ 时，熵的唯一来源是由两种同位素 A 和 B 在 $N$ 个晶格格点上的无规排列引起的构型简并。给定有 $N_A = xN$ 个同位素 A 原子和 $N_B = (1-x)N$ 个同位素 B 原子，其中 $x$ 是同位素 A 的摩尔分数，$N$ 是总晶格格点数。\n\n可区分构型数 $W$ 是将 $N_A$ 个 A 类相同物品和 $N_B$ 个 B 类相同物品排列在 $N = N_A + N_B$ 个不同位置上的方法数。这由二项式系数给出：\n$$W = \\binom{N}{N_A} = \\frac{N!}{N_A! N_B!}$$\n将此代入 Boltzmann 熵公式可得：\n$$S = k_{B} \\ln \\left( \\frac{N!}{N_A! N_B!} \\right) = k_{B} (\\ln(N!) - \\ln(N_A!) - \\ln(N_B!))$$\n由于该固体是宏观的，原子数 $N$、$N_A$ 和 $N_B$ 都非常大。因此，我们可以对阶乘的自然对数使用斯特林近似 (Stirling's approximation)，即对于大的 $n$，有 $\\ln(n!) \\approx n \\ln n - n$。将此应用于每个阶乘项：\n$$ \\ln(N!) \\approx N \\ln N - N $$\n$$ \\ln(N_A!) \\approx N_A \\ln N_A - N_A $$\n$$ \\ln(N_B!) \\approx N_B \\ln N_B - N_B $$\n将这些近似值代入熵 $S$ 的表达式中：\n$$ S \\approx k_{B} \\left[ (N \\ln N - N) - (N_A \\ln N_A - N_A) - (N_B \\ln N_B - N_B) \\right] $$\n$$ S \\approx k_{B} \\left[ N \\ln N - N_A \\ln N_A - N_B \\ln N_B - (N - N_A - N_B) \\right] $$\n由于 $N = N_A + N_B$，项 $(N - N_A - N_B)$ 等于 $0$。表达式简化为：\n$$ S \\approx k_{B} \\left[ N \\ln N - N_A \\ln N_A - N_B \\ln N_B \\right] $$\n现在，我们用总格点数 $N$ 和摩尔分数 $x$ 来表示 $N_A$ 和 $N_B$：$N_A = xN$ 和 $N_B = (1-x)N$。\n$$ S \\approx k_{B} \\left[ N \\ln N - (xN) \\ln(xN) - ((1-x)N) \\ln((1-x)N) \\right] $$\n使用对数性质 $\\ln(ab) = \\ln a + \\ln b$：\n$$ S \\approx k_{B} \\left[ N \\ln N - xN(\\ln x + \\ln N) - (1-x)N(\\ln(1-x) + \\ln N) \\right] $$\n$$ S \\approx k_{B} \\left[ N \\ln N - xN \\ln x - xN \\ln N - (1-x)N \\ln(1-x) - (1-x)N \\ln N \\right] $$\n我们可以将包含 $\\ln N$ 的项组合在一起：\n$$ S \\approx k_{B} \\left[ (N - xN - (1-x)N) \\ln N - xN \\ln x - (1-x)N \\ln(1-x) \\right] $$\n乘以 $\\ln N$ 的项是 $N - xN - N + xN = 0$。剩下：\n$$ S = -N k_{B} \\left[ x \\ln x + (1-x) \\ln(1-x) \\right] $$\n这是 $N$ 个格点系统的总残留熵。问题要求的是摩尔残留熵 $S_{\\mathrm{res},m}$，即每摩尔晶格格点的熵。晶格格点的摩尔数是 $n = N/N_{Av}$，其中 $N_{Av}$ 是阿伏伽德罗常数 (Avogadro's constant)。\n$$ S_{\\mathrm{res},m} = \\frac{S}{n} = \\frac{-N k_{B} \\left[ x \\ln x + (1-x) \\ln(1-x) \\right]}{N/N_{Av}} $$\n$$ S_{\\mathrm{res},m} = -N_{Av} k_{B} \\left[ x \\ln x + (1-x) \\ln(1-x) \\right] $$\n阿伏伽德罗常数和 Boltzmann 常数的乘积是通用气体常数，$R = N_{Av} k_{B}$。因此，作为组分 $x$ 的函数的摩尔残留熵为：\n$$ S_{\\mathrm{res},m}(x) = -R \\left[ x \\ln x + (1-x) \\ln(1-x) \\right] $$\n这就完成了问题的第一部分。\n\n第二部分要求对等摩尔情况，$x = \\frac{1}{2}$ 或 $x = 0.5$，计算该表达式的值。\n将 $x = 0.5$ 代入推导出的公式中：\n$$ S_{\\mathrm{res},m}(0.5) = -R \\left[ 0.5 \\ln(0.5) + (1-0.5) \\ln(0.5) \\right] $$\n$$ S_{\\mathrm{res},m}(0.5) = -R \\left[ 0.5 \\ln(0.5) + 0.5 \\ln(0.5) \\right] = -R \\ln(0.5) $$\n使用对数性质 $\\ln(0.5) = \\ln(\\frac{1}{2}) = -\\ln(2)$：\n$$ S_{\\mathrm{res},m}(0.5) = -R (-\\ln(2)) = R \\ln(2) $$\n为了求得数值，我们使用通用气体常数的值 $R \\approx 8.314462618 \\, \\mathrm{J\\,mol^{-1}\\,K^{-1}}$ 和 $\\ln(2) \\approx 0.69314718056$。\n$$ S_{\\mathrm{res},m}(0.5) \\approx (8.314462618 \\, \\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\times (0.69314718056) $$\n$$ S_{\\mathrm{res},m}(0.5) \\approx 5.76281 \\, \\mathrm{J\\,mol^{-1}\\,K^{-1}} $$\n问题要求答案四舍五入到四位有效数字。第五位有效数字是 $8$，所以我们将第四位数字向上取整。\n$$ S_{\\mathrm{res},m}(0.5) \\approx 5.763 \\, \\mathrm{J\\,mol^{-1}\\,K^{-1}} $$", "answer": "$$\\boxed{5.763}$$", "id": "2680901"}, {"introduction": "接下来，我们将通过一个思想实验来探讨第三定律的深远推论。本练习要求你基于简化的热容模型，比较有序晶相和无序非晶相的熵，从而揭示一个潜在的热力学悖论。这个过程将引出重要的考兹曼温度（Kauzmann temperature）$T_K$ 概念，它是理解玻璃态物质和过冷液体物理性质的关键。[@problem_id:2022102]", "problem": "一种新的二维 (2D) 聚合物已被合成，它在低温下可以以两种不同的固态形式存在：一种是完全有序的结晶单层，另一种是无序的非晶单层。根据热力学第三定律，结晶形式的摩尔熵在绝对零度时为零，$S_{m}^{(c)}(0) = 0$。非晶形式由于其固有的无序性，在绝对零度时拥有一个非零的剩余摩尔熵，记为 $S_0$。\n\n对于低温情况，理论模型预测两相的恒压摩尔热容 $C_{p,m}$ 可以用以下关于温度 $T$ 的函数很好地近似：\n- 对于结晶单层：$C_{p,m}^{(c)}(T) = \\alpha T^{2}$\n- 对于非晶单层：$C_{p,m}^{(a)}(T) = \\beta T$\n\n在此，$\\alpha$ 和 $\\beta$ 是该材料特有的正常数。如果无序非晶相的熵低于有序结晶相的熵，就会出现一个热力学悖论，有时被称为“熵危机”。假设给定的低温热容模型对于外推是有效的，请确定一个假想温度 $T_K > 0$，在该温度下，非晶单层的摩尔熵将变得与结晶单层的摩尔熵相等。\n\n请用 $\\alpha$、$\\beta$ 和 $S_0$ 的符号表达式表示你的答案。", "solution": "对于恒压下的可逆路径，摩尔熵的变化遵循\n$$\n\\mathrm{d}S_{m}=\\frac{C_{p,m}(T)}{T}\\,\\mathrm{d}T.\n$$\n从绝对零度积分到温度 $T$ 可得\n$$\nS_{m}(T)=S_{m}(0)+\\int_{0}^{T}\\frac{C_{p,m}(T')}{T'}\\,\\mathrm{d}T'.\n$$\n\n结晶单层：给定 $S_{m}^{(c)}(0)=0$ 和 $C_{p,m}^{(c)}(T)=\\alpha T^{2}$，\n$$\nS_{m}^{(c)}(T)=0+\\int_{0}^{T}\\frac{\\alpha {T'}^{2}}{T'}\\,\\mathrm{d}T'=\\alpha\\int_{0}^{T}T'\\,\\mathrm{d}T'=\\frac{\\alpha}{2}T^{2}.\n$$\n\n非晶单层：给定 $S_{m}^{(a)}(0)=S_{0}$ 和 $C_{p,m}^{(a)}(T)=\\beta T$，\n$$\nS_{m}^{(a)}(T)=S_{0}+\\int_{0}^{T}\\frac{\\beta T'}{T'}\\,\\mathrm{d}T'=S_{0}+\\beta\\int_{0}^{T}\\mathrm{d}T'=S_{0}+\\beta T.\n$$\n\n假想的 Kauzmann 温度 $T_{K}$ 定义为 $S_{m}^{(a)}(T_{K})=S_{m}^{(c)}(T_{K})$。因此，\n$$\nS_{0}+\\beta T_{K}=\\frac{\\alpha}{2}T_{K}^{2},\n$$\n整理后得到二次方程\n$$\n\\frac{\\alpha}{2}T_{K}^{2}-\\beta T_{K}-S_{0}=0.\n$$\n两边乘以 $2$，\n$$\n\\alpha T_{K}^{2}-2\\beta T_{K}-2S_{0}=0.\n$$\n求解 $T_{K}$，\n$$\nT_{K}=\\frac{2\\beta\\pm\\sqrt{(2\\beta)^{2}+8\\alpha S_{0}}}{2\\alpha}=\\frac{\\beta\\pm\\sqrt{\\beta^{2}+2\\alpha S_{0}}}{\\alpha}.\n$$\n由于 $\\alpha>0$，$\\beta>0$，且 $S_{0}>0$，物理上相关（正值）的根由正号得到：\n$$\nT_{K}=\\frac{\\beta+\\sqrt{\\beta^{2}+2\\alpha S_{0}}}{\\alpha}.\n$$", "answer": "$$\\boxed{\\frac{\\beta+\\sqrt{\\beta^{2}+2\\alpha S_{0}}}{\\alpha}}$$", "id": "2022102"}, {"introduction": "最后这个实践将理论与实际应用联系起来，构成一个综合性的挑战。虽然第三定律为完美晶体的熵提供了零点 $S(0)=0$，但我们如何在任意温度下计算其绝对熵呢？本练习要求你编写程序，通过对分段的实验热容数据进行积分并考虑相变的影响，来计算物质的绝对摩尔熵，这是一项在化学热力学中至关重要的基本技能。[@problem_id:2680899]", "problem": "给定一种假设的晶体物质，其测得的摩尔定压热容（Cp）由连续温度区间上的分段多项式表示，并存在两次一级相变。目标是仅使用平衡热力学的基础定律和定义，计算绝对摩尔熵作为温度的函数，并通过程序实现该计算，确保在各个区间和相变温度下获得数值稳定的结果。假设在零温下为完美晶体，因此热力学第三定律适用，无残余熵。\n\n物质数据：\n- $C_p$ 分段拟合（每个多项式均为温度 $T$ 的幂函数，系数按 $\\{a_0,a_1,a_2,\\dots\\}$ 顺序排列，使得 $C_p(T)=\\sum_{k=0}^{n} a_k T^k$）：\n  1. 区间 $\\left[0.0,50.0\\right)$ 开尔文，系数为 $\\{0.0,0.0,0.0,1.5\\times 10^{-4}\\}$。\n  2. 区间 $\\left[50.0,150.0\\right)$ 开尔文，系数为 $\\{12.0,0.02,1.0\\times 10^{-4}\\}$。\n  3. 区间 $\\left[150.0,400.0\\right)$ 开尔文，系数为 $\\{20.0,0.015,2.0\\times 10^{-5}\\}$。\n  4. 区间 $\\left[400.0,800.0\\right]$ 开尔文，系数为 $\\{30.0,0.005\\}$。\n\n- 一级相变，由温度和摩尔潜热表征：\n  1. 在 $T=150.0$ 开尔文发生固-固相变，潜热 $L=500.0$ 焦耳/摩尔。\n  2. 在 $T=400.0$ 开尔文发生熔化，潜热 $L=10000.0$ 焦耳/摩尔。\n\n假设与要求：\n- 将每个多项式区间视为仅在其指定温度范围内有效的独立拟合。\n- 在 $T=150.0$ 开尔文和 $T=400.0$ 开尔文的相变必须被纳入计算，以使绝对熵沿从 $T=0.0$ 开尔文向上的平衡路径上是温度的连续函数。将“在或高于”某一相变温度解释为包含该潜热贡献。\n- 从适用于定压可逆加热和热力学第三定律的第一性原理定义出发；不要使用任何其他唯象的简化方法。\n- 所有积分和求和的计算方式必须在 $T=0.0$ 开尔文和分段边界处明确定义。数据所隐含的被积函数结构使得这在不引入任何非物理行为的情况下成为可能。\n\n单位：\n- 温度必须以开尔文为单位。\n- 热容单位为焦耳/(摩尔·开尔文)。\n- 潜热单位为焦耳/摩尔。\n- 报告的绝对摩尔熵单位为焦耳/(摩尔·开尔文)，四舍五入至六位小数。\n\n测试组：\n计算以下温度（开尔文）下的绝对摩尔熵：$\\{0.0, 25.0, 50.0, 150.0, 200.0, 333.33, 400.0, 600.0\\}$。\n\n程序输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$，其中每个 $\\text{result}_i$ 是一个四舍五入到六位小数的浮点数，顺序与测试组温度相同。", "solution": "问题陈述是有效的。这是一个物理化学领域的良定问题，基于热力学的基本原理，并为获得唯一解提供了所有必要数据。所提供的分段热容函数在区间边界处存在不连续性，这是经验模型的常见特征，但这并不影响熵（作为状态函数）的热力学计算。我们将继续进行求解。\n\n物质在温度 $T$ 下的绝对摩尔熵 $S(T)$ 由热力学第三定律和熵变的定义确定。热力学第三定律指出，完美晶体在绝对零度时的熵为零。\n$$S(T=0 \\text{ K}) = 0$$\n对于一个定压 $P$ 下的可逆过程，熵的微小变化 $dS$ 与定压热容 $C_p$ 的关系如下：\n$$dS = \\frac{dq_{\\text{rev}}}{T} = \\frac{C_p(T) dT}{T}$$\n假设在此温度区间内没有发生相变，将此式从 0 K 积分到温度 $T$，即可得到绝对熵：\n$$S(T) = S(0) + \\int_{0}^{T} \\frac{C_p(T')}{T'} dT' = \\int_{0}^{T} \\frac{C_p(T')}{T'} dT'$$\n如果物质在温度 $T_{\\text{tr}}$ 发生一级相变，其摩尔相变潜热为 $L_{\\text{tr}}$，则会产生一个额外的熵变，大小为：\n$$\\Delta S_{\\text{tr}} = \\frac{L_{\\text{tr}}}{T_{\\text{tr}}}$$\n因此，在温度 $T$ 下的绝对熵是从加热和在低于或等于 $T$ 的温度下发生的相变所引起的所有熵增的总和。\n$$S(T) = \\int_{0}^{T} \\frac{C_p(T')}{T'} dT' + \\sum_{T_{\\text{tr},i} \\le T} \\frac{L_{\\text{tr},i}}{T_{\\text{tr},i}}$$\n热容 $C_p(T)$ 以分段多项函数的形式给出，$C_p(T) = \\sum_{k=0}^{n} a_k T^k$。必须对每个分段计算 $\\frac{C_p(T)}{T}$ 的积分。对于一个通用的多项式分段，积分为：\n$$\\int \\frac{\\sum_{k=0}^{n} a_k (T')^k}{T'} dT' = \\int \\left( \\frac{a_0}{T'} + a_1 + a_2 T' + \\dots + a_n (T')^{n-1} \\right) dT' = a_0 \\ln(T') + a_1 T' + \\frac{a_2}{2}(T')^2 + \\dots + \\frac{a_n}{n}(T')^n$$\n我们必须在给定的温度区间和相变中累积应用此过程。我们定义以下变化点：$T_1 = 50.0$ K（函数改变），$T_2 = 150.0$ K（函数改变和相变），以及 $T_3 = 400.0$ K（函数改变和相变）。\n\n**1. 区间 1: $T \\in [0.0, 50.0)$ K**\n$C_{p,1}(T) = 1.5 \\times 10^{-4} T^3$。该形式与低温下的 Debye $T^3$ 定律一致。\n$$S(T) = \\int_{0}^{T} \\frac{1.5 \\times 10^{-4} (T')^3}{T'} dT' = \\int_{0}^{T} 1.5 \\times 10^{-4} (T')^2 dT' = \\left[ \\frac{1.5 \\times 10^{-4}}{3} (T')^3 \\right]_0^T = \\frac{1.5 \\times 10^{-4}}{3} T^3$$\n在边界 $T_1 = 50.0$ K 处，熵为：\n$$S(50.0) = \\frac{1.5 \\times 10^{-4} \\times (50.0)^3}{3} = 6.25 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n**2. 区间 2: $T \\in [50.0, 150.0)$ K**\n$C_{p,2}(T) = 12.0 + 0.02T + 1.0 \\times 10^{-4} T^2$。对于此区间内的温度 $T$，熵为：\n$$S(T) = S(50.0) + \\int_{50.0}^{T} \\frac{C_{p,2}(T')}{T'} dT'$$\n在 $T_2 = 150.0$ K 发生第一次相变前，熵为：\n$$S(150.0^{-}) = S(50.0) + \\int_{50.0}^{150.0} \\left( \\frac{12.0}{T'} + 0.02 + 1.0 \\times 10^{-4} T' \\right) dT'$$\n$$S(150.0^{-}) = 6.25 + \\left[ 12.0 \\ln(T') + 0.02 T' + \\frac{1.0 \\times 10^{-4}}{2}(T')^2 \\right]_{50.0}^{150.0} \\approx 6.25 + 16.183347 = 22.433347 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n在 $T_2 = 150.0$ K，发生固-固相变，其 $L_1 = 500.0$ J mol$^{-1}$。相变熵为 $\\Delta S_{\\text{tr},1} = \\frac{500.0}{150.0} = \\frac{10}{3} \\text{ J mol}^{-1} \\text{K}^{-1}$。\n在 150.0 K 时，包含相变在内的熵为：\n$$S(150.0) = S(150.0^{-}) + \\Delta S_{\\text{tr},1} \\approx 22.433347 + 3.333333 = 25.766681 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n**3. 区间 3: $T \\in [150.0, 400.0)$ K**\n$C_{p,3}(T) = 20.0 + 0.015T + 2.0 \\times 10^{-5} T^2$。对于此区间内的温度 $T$：\n$$S(T) = S(150.0) + \\int_{150.0}^{T} \\frac{C_{p,3}(T')}{T'} dT'$$\n在 $T_3 = 400.0$ K 熔化前，熵为：\n$$S(400.0^{-}) = S(150.0) + \\int_{150.0}^{400.0} \\left( \\frac{20.0}{T'} + 0.015 + 2.0 \\times 10^{-5} T' \\right) dT'$$\n$$S(400.0^{-}) \\approx 25.766681 + \\left[ 20.0 \\ln(T') + 0.015 T' + \\frac{2.0 \\times 10^{-5}}{2}(T')^2 \\right]_{150.0}^{400.0} \\approx 25.766681 + 24.741585 = 50.508266 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n在 $T_3 = 400.0$ K，发生熔化，其 $L_2 = 10000.0$ J mol$^{-1}$。熔化熵为 $\\Delta S_{\\text{tr},2} = \\frac{10000.0}{400.0} = 25.0 \\text{ J mol}^{-1} \\text{K}^{-1}$。\n在 400.0 K 时的熵为：\n$$S(400.0) = S(400.0^{-}) + \\Delta S_{\\text{tr},2} \\approx 50.508266 + 25.0 = 75.508266 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n**4. 区间 4: $T \\in [400.0, 800.0]$ K**\n$C_{p,4}(T) = 30.0 + 0.005T$。对于此区间内的温度 $T$：\n$$S(T) = S(400.0) + \\int_{400.0}^{T} \\frac{C_{p,4}(T')}{T'} dT' = S(400.0) + \\int_{400.0}^{T} \\left( \\frac{30.0}{T'} + 0.005 \\right) dT'$$\n例如，在 $T = 600.0$ K 时：\n$$S(600.0) = S(400.0) + \\left[ 30.0 \\ln(T') + 0.005 T' \\right]_{400.0}^{600.0} \\approx 75.508266 + 13.163953 = 88.672219 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n程序的实现将包含一个函数，该函数为给定的温度 $T$ 确定其所在的温度区间，并通过累加所有先前区间和相变的贡献，再加上当前区间内的贡献来计算熵。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute molar entropy for a hypothetical substance at various temperatures.\n    The calculation is based on piecewise polynomial fits for heat capacity (Cp) and\n    includes entropy changes from two first-order phase transitions, adhering to the\n    Third Law of Thermodynamics.\n    \"\"\"\n\n    # Test temperatures in Kelvin\n    test_temperatures = [0.0, 25.0, 50.0, 150.0, 200.0, 333.33, 400.0, 600.0]\n\n    # Model parameters\n    # Cp(T) = sum(a_k * T^k)\n    # Coefficients {a0, a1, a2, ...} for each segment\n    cp_coeffs = {\n        1: [0.0, 0.0, 0.0, 1.5e-4],       # T in [0, 50)\n        2: [12.0, 0.02, 1.0e-4],         # T in [50, 150)\n        3: [20.0, 0.015, 2.0e-5],        # T in [150, 400)\n        4: [30.0, 0.005]                 # T in [400, 800]\n    }\n    \n    # Phase transitions\n    transitions = {\n        150.0: 500.0,   # T_tr in K, Latent heat L in J/mol\n        400.0: 10000.0\n    }\n    \n    # Temperature boundaries for Cp segments\n    T_boundaries = [0.0, 50.0, 150.0, 400.0, 800.0]\n\n    def integral_cp_over_t(coeffs, T_low, T_high):\n        \"\"\"\n        Calculates the definite integral of Cp(T)/T from T_low to T_high for a given polynomial.\n        int( (a0/T + a1 + a2*T + ...) dT ) = a0*ln(T) + a1*T + (a2/2)*T^2 + ...\n        \"\"\"\n        if T_high <= T_low:\n            return 0.0\n\n        def antiderivative(T):\n            if T == 0: return 0.0\n            val = 0.0\n            # a0*ln(T) term\n            if len(coeffs) > 0 and coeffs[0] != 0.0:\n                val += coeffs[0] * np.log(T)\n            # Higher order terms: (a_k / k) * T^k for k>=1\n            for k in range(1, len(coeffs)):\n                val += (coeffs[k] / k) * T**k\n            return val\n            \n        return antiderivative(T_high) - antiderivative(T_low)\n\n    # Pre-calculate entropy at boundary points for efficiency\n    s_boundaries = {}\n    s_boundaries[T_boundaries[0]] = 0.0\n    \n    # S at 50K\n    s_50 = integral_cp_over_t(cp_coeffs[1], T_boundaries[0], T_boundaries[1])\n    s_boundaries[T_boundaries[1]] = s_50\n    \n    # S at 150K\n    s_150_pre = s_50 + integral_cp_over_t(cp_coeffs[2], T_boundaries[1], T_boundaries[2])\n    s_150_post = s_150_pre + transitions[T_boundaries[2]] / T_boundaries[2]\n    s_boundaries[T_boundaries[2]] = s_150_post\n\n    # S at 400K\n    s_400_pre = s_150_post + integral_cp_over_t(cp_coeffs[3], T_boundaries[2], T_boundaries[3])\n    s_400_post = s_400_pre + transitions[T_boundaries[3]] / T_boundaries[3]\n    s_boundaries[T_boundaries[3]] = s_400_post\n\n    def calculate_entropy(T):\n        \"\"\"\n        Calculates absolute molar entropy at a specific temperature T.\n        \"\"\"\n        if T < 0.0:\n            raise ValueError(\"Temperature must be non-negative.\")\n        \n        if T < T_boundaries[1]: # T in [0, 50)\n            return s_boundaries[T_boundaries[0]] + integral_cp_over_t(cp_coeffs[1], T_boundaries[0], T)\n        \n        elif T < T_boundaries[2]: # T in [50, 150)\n            return s_boundaries[T_boundaries[1]] + integral_cp_over_t(cp_coeffs[2], T_boundaries[1], T)\n        \n        elif T == T_boundaries[2]: # T = 150\n            return s_boundaries[T_boundaries[2]] # Includes transition\n        \n        elif T < T_boundaries[3]: # T in (150, 400)\n            return s_boundaries[T_boundaries[2]] + integral_cp_over_t(cp_coeffs[3], T_boundaries[2], T)\n        \n        elif T == T_boundaries[3]: # T = 400\n            return s_boundaries[T_boundaries[3]] # Includes transition\n        \n        elif T <= T_boundaries[4]: # T in (400, 800]\n            return s_boundaries[T_boundaries[3]] + integral_cp_over_t(cp_coeffs[4], T_boundaries[3], T)\n        \n        else: # T > 800\n            # Problem data does not cover this range, but can extrapolate if needed.\n            # As per problem, assume T <= 800.\n            raise ValueError(f\"Temperature {T}K is outside the valid range [0, 800].\")\n\n    results = [calculate_entropy(T) for T in test_temperatures]\n    \n    # Format output as a list of strings with 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2680899"}]}