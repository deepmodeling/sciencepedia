{"hands_on_practices": [{"introduction": "任何有物理意义的波函数都必须是归一化的，这是量子力学概率诠释的基石。这个基本要求确保了在全空间中找到粒子的总概率为1。本练习将通过一个核心模型——量子谐振子——来实践归一化过程，让你掌握处理高斯型波函数这一在化学和物理中无处不在的重要技能。[@problem_id:2023855]", "problem": "简单双原子分子沿其键轴的振动可以用一维量子力学模型来近似。在此模型中，核间距与其平衡值的位移由坐标 $x$ 给出，其取值范围为 $-\\infty$ 到 $+\\infty$。对于最低能量的振动态（基态），其未归一化的波函数由下式给出：\n$$ \\Psi(x) = N \\exp(-\\alpha x^2) $$\n其中 $N$ 是归一化常数，$\\alpha$ 是一个与分子键的力常数相关的正常实数参数。\n\n根据对波函数的玻恩诠释，在给定区域内发现粒子的概率与波函数模的平方 $|\\Psi(x)|^2$ 在该区域上的积分成正比。为使波函数具有物理意义，在全空间中找到该粒子的总概率必须为1。\n\n试确定归一化常数 $N$ 关于参数 $\\alpha$ 的表达式。假设 $N$ 为一个正常实数。", "solution": "归一化波函数的基本原理是玻恩诠释，该诠释指出，在所有可能空间中的某处找到粒子的总概率必须等于1。对于坐标 $x$ 的取值范围为 $-\\infty$ 到 $+\\infty$ 的一维系统，此归一化条件可由数学公式表示为：\n$$ \\int_{-\\infty}^{\\infty} |\\Psi(x)|^2 \\, dx = 1 $$\n\n我们已知的未归一化波函数为 $\\Psi(x) = N \\exp(-\\alpha x^2)$。首先，我们求其模的平方 $|\\Psi(x)|^2$。由于归一化常数 $N$ 被定为一个正常实数，且参数 $\\alpha$ 和坐标 $x$ 也都是实数，所以整个表达式 $\\Psi(x)$ 都是实数。因此，$|\\Psi(x)|^2 = (\\Psi(x))^2$。\n$$ |\\Psi(x)|^2 = \\left(N \\exp(-\\alpha x^2)\\right)^2 = N^2 \\exp(-2\\alpha x^2) $$\n\n现在，我们将此表达式代入归一化积分中：\n$$ \\int_{-\\infty}^{\\infty} N^2 \\exp(-2\\alpha x^2) \\, dx = 1 $$\n\n由于 $N$ 是一个常数，我们可以将 $N^2$ 提到积分外面：\n$$ N^2 \\int_{-\\infty}^{\\infty} \\exp(-2\\alpha x^2) \\, dx = 1 $$\n\n该积分是形式为 $\\int_{-\\infty}^{\\infty} \\exp(-bx^2) \\, dx$ 的标准高斯积分，其解已知为 $\\sqrt{\\frac{\\pi}{b}}$。在本例中，常数 $b$ 对应于 $2\\alpha$。\n因此，该积分的值为：\n$$ \\int_{-\\infty}^{\\infty} \\exp(-2\\alpha x^2) \\, dx = \\sqrt{\\frac{\\pi}{2\\alpha}} $$\n\n将此结果代回我们求 $N$ 的方程中：\n$$ N^2 \\left( \\sqrt{\\frac{\\pi}{2\\alpha}} \\right) = 1 $$\n\n现在，我们求解 $N^2$：\n$$ N^2 = \\frac{1}{\\sqrt{\\frac{\\pi}{2\\alpha}}} = \\left(\\frac{\\pi}{2\\alpha}\\right)^{-1/2} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/2} $$\n\n最后，我们通过取平方根来求得 $N$。由于题目指明 $N$ 是一个正常实数，我们取正根：\n$$ N = \\left( \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/2} \\right)^{1/2} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4} $$\n\n因此，归一化常数 $N$ 用 $\\alpha$ 表示为 $\\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4}$。", "answer": "$$\\boxed{\\left(\\frac{2\\alpha}{\\pi}\\right)^{1/4}}$$", "id": "2023855"}, {"introduction": "并非所有数学函数都可以作为描述量子态的有效波函数。一个函数要成为物理上可接受的波函数，其模的平方必须在整个定义域上是可积的，即它必须是“平方可积”的。本练习将引导你检验一个给定的函数是否满足这个关键的“可归一化”条件，从而加深对波函数基本数学约束的理解。[@problem_id:2829871]", "problem": "在一维空间非相对论量子力学的背景下，考虑一个定义在半无限区间 $x \\in [1,\\infty)$ 上的定态。候选波函数为 $\\psi(x)=C/x$，其中 $C$ 是一个常数。根据玻恩（Born）的概率诠释（即概率密度为 $|\\psi(x)|^{2}$）以及总概率在整个定义域上等于 $1$ 的要求，判断 $\\psi(x)$ 在其定义域上是否可归一化。如果它是可归一化的，假设 $C$ 是实数且非负，并求出使 $\\psi(x)$ 归一化的 $C$ 值。在最终答案中仅报告 $C$ 的值。无需单位，也无需四舍五入。", "solution": "在尝试求解之前，将根据所需标准对问题进行验证。\n\n**步骤 1：提取已知条件**\n-   **系统**：一维空间非相对论量子力学。\n-   **状态类型**：定态。\n-   **定义域**：坐标 $x$ 限制在区间 $[1, \\infty)$ 内。\n-   **候选波函数**：$\\psi(x) = \\frac{C}{x}$。\n-   **常数**：$C$ 是一个归一化常数。\n-   **物理解释**：概率密度由玻恩（Born）定则给出，$\\rho(x) = |\\psi(x)|^2$。\n-   **归一化条件**：在定义域上的总概率必须为 1，即 $\\int_{1}^{\\infty} |\\psi(x)|^2 dx = 1$。\n-   **目标**：首先，判断 $\\psi(x)$ 在其定义域上是否可归一化。其次，如果可归一化，则在假设 $C$ 为实数且非负的情况下，求出 $C$ 的值。\n\n**步骤 2：问题验证**\n该问题在量子力学的标准框架内是良定义的。它提出了一个关于函数在指定定义域上平方可积性的标准数学问题。\n-   **科学依据**：波函数、玻恩（Born）概率诠释和归一化条件是量子力学的基本原理。该问题在科学上是合理的。\n-   **良定性**：该问题提供了一个特定的函数、一个特定的定义域和一个明确的测试条件（归一化）。函数是否可归一化的问题，其数学答案取决于一个积分的收敛或发散。归一化常数的值（如果存在）由非负约束唯一确定。该问题是良定的。\n-   **客观性和完整性**：问题陈述是精确、定量的，并包含了进行下一步所需的所有信息。没有歧义或缺失数据。\n\n**结论：** 该问题被认为是有效的，因为它具有科学依据、良定性、客观性和完整性。将提供解答。\n\n**步骤 3：求解推导**\n要使一个波函数 $\\psi(x)$ 在物理上可接受，它必须是可归一化的。这意味着其概率密度 $|\\psi(x)|^2$ 在所有可及空间上的积分必须是一个有限的非零数。归一化条件则要求这个积分值被设为 $1$。\n\n给定的候选波函数是在定义域 $x \\in [1, \\infty)$ 上的 $\\psi(x) = \\frac{C}{x}$。概率密度为：\n$$\n\\rho(x) = |\\psi(x)|^2 = \\left| \\frac{C}{x} \\right|^2 = \\frac{|C|^2}{|x|^2}\n$$\n在定义域 $x \\in [1, \\infty)$ 上，坐标 $x$ 始终是实数且为正，因此 $|x| = x$。题目说明我们可以假设 $C$ 是一个实数且非负的常数。因此，$|C| = C$。概率密度简化为：\n$$\n\\rho(x) = \\frac{C^2}{x^2}\n$$\n为了判断波函数是否可归一化，我们必须计算该密度在指定定义域上的积分，并检查它是否收敛到一个有限值。\n$$\nI = \\int_{1}^{\\infty} \\rho(x) dx = \\int_{1}^{\\infty} \\frac{C^2}{x^2} dx\n$$\n我们可以将常数 $C^2$ 提取出来：\n$$\nI = C^2 \\int_{1}^{\\infty} \\frac{1}{x^2} dx = C^2 \\int_{1}^{\\infty} x^{-2} dx\n$$\n这是一个瑕积分，使用极限来计算：\n$$\n\\int_{1}^{\\infty} x^{-2} dx = \\lim_{b \\to \\infty} \\int_{1}^{b} x^{-2} dx\n$$\n当 $n \\neq 1$ 时，$x^{-n}$ 的反导数是 $\\frac{x^{-n+1}}{-n+1}$。对于 $n=2$，反导数是 $\\frac{x^{-1}}{-1} = -\\frac{1}{x}$。\n$$\n\\lim_{b \\to \\infty} \\left[ -\\frac{1}{x} \\right]_{1}^{b} = \\lim_{b \\to \\infty} \\left( -\\frac{1}{b} - \\left(-\\frac{1}{1}\\right) \\right) = \\lim_{b \\to \\infty} \\left( 1 - \\frac{1}{b} \\right)\n$$\n当 $b \\to \\infty$ 时，项 $\\frac{1}{b} \\to 0$。因此，极限为：\n$$\n\\lim_{b \\to \\infty} \\left( 1 - \\frac{1}{b} \\right) = 1 - 0 = 1\n$$\n该积分收敛到一个有限值。因此，总积分 $I$ 为：\n$$\nI = C^2 \\cdot 1 = C^2\n$$\n由于积分是有限的，波函数 $\\psi(x) = \\frac{C}{x}$ 在定义域 $[1, \\infty)$ 上确实是可归一化的。\n\n为了求出归一化常数 $C$ 的值，我们应用归一化条件，即该积分必须等于 $1$。\n$$\nI = 1\n$$\n代入我们的积分结果，得到：\n$$\nC^2 = 1\n$$\n求解 $C$，我们得到两个可能的实数解：$C = 1$ 和 $C = -1$。\n然而，问题附加了 $C$ 必须是实数且非负的约束。这排除了 $C = -1$ 的解，只留下一个有效的选择。\n$$\nC = 1\n$$\n这就是使粒子在定义域 $[1, \\infty)$ 中被找到的总概率等于 1 的归一化常数的值。", "answer": "$$\\boxed{1}$$", "id": "2829871"}, {"introduction": "波函数的概率诠释不仅限于计算特定区域的概率，它还为强大的计算方法提供了理论基础。$|\\Psi|^2$ 分布可以直接作为概率密度函数，通过蒙特卡洛等随机取样方法来模拟量子体系。这个高级计算练习将指导你实现一个量子蒙特卡洛程序，让你亲身体验如何利用波恩法则来预测原子和分子的可观测量，连接了抽象理论与前沿计算化学实践。[@problem_id:2681732]", "problem": "实现一个 Metropolis–Hastings 量子蒙特卡洛程序，该程序根据波函数的概率诠释（玻恩定则），在原子单位下，从波函数模方的分布中进行抽样。请从以下基本原则出发：(i) 玻恩定则，即位置的概率密度由波函数的模方 $|\\psi(\\mathbf{r})|^2$ 给出；以及 (ii) 可观测量的期望值定义为关于玻恩定则概率测度的积分。您还必须使用非相对论哈密顿算符的定义，并通过局域能量计算能量期望值。局域能量是通过将哈密顿算符作用于波函数并除以波函数得到的。除了所选波函数的精确性所暗含的性质外，不要假定任何方差缩减特性。所有距离单位为玻尔（bohr），所有能量单位为哈特里（Hartree）（哈特里原子单位）。\n\n您的程序必须：\n- 使用 Metropolis–Hastings 算法，通过对称高斯提议从与 $|\\psi|^2$ 成正比的目标分布中抽样位置。如果提议方差为 $\\sigma^2$，则在一维情况下提议 $x' = x + \\sigma \\eta$（其中 $\\eta \\sim \\mathcal{N}(0,1)$），在三维情况下提议 $\\mathbf{r}' = \\mathbf{r} + \\sigma \\,\\boldsymbol{\\eta}$（其中各分量 $\\eta_i \\sim \\mathcal{N}(0,1)$ 独立）。使用基于未归一化目标密度对数值变化的常规 Metropolis 接受准则。\n- 对每个抽样位置，评估所需的可观测量，并在 burn-in 期结束后的马尔可夫链上对它们进行平均，以估计相应的期望值。\n- 对于能量，计算并平均局域能量，其逐点定义为 $E_{\\mathrm{L}} = \\dfrac{\\hat{H}\\psi}{\\psi}$，其中 $\\hat{H}$ 是哈密顿算符。您必须通过应用动能算符并加上势能项，为每个波函数推导出局域能量的解析形式，然后在代码中实现这些解析表达式。请勿使用有限差分近似。\n\n使用以下三个测试用例（测试套件），每个用例都指定了一个系统、一个波函数、一个哈密顿算符和蒙特卡洛参数。所有符号和数字必须严格按照规定实现。\n\n测试用例 A（一维谐振子基态）：\n- 系统：一维谐振子，角频率 $\\omega = 1$。哈密顿算符 $\\hat{H} = -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} + \\dfrac{1}{2}\\,\\omega^2 x^2$。\n- 波函数：$\\psi_0(x) = \\left(\\dfrac{\\omega}{\\pi}\\right)^{1/4}\\exp\\!\\left(-\\dfrac{\\omega x^2}{2}\\right)$。\n- 目标密度：与 $|\\psi_0(x)|^2$ 成正比。\n- 要求输出的可观测量（按此顺序）：$\\langle x\\rangle$、$\\langle x^2\\rangle$、$\\langle T\\rangle$、$\\langle V\\rangle$、$\\langle E\\rangle$，其中 $T$ 是动能，$V$ 是势能。\n- Metropolis 参数：高斯提议标准差 $\\sigma = 1.1$，初始位置 $x_0 = 0.0$，burn-in 步数 $B = 20000$，保留的样本数 $N = 120000$，随机种子 $s = 314159$。\n\n测试用例 B（一维谐振子第一激发态）：\n- 系统：与测试用例 A 相同的哈密顿算符，$\\omega = 1$。\n- 波函数：$\\psi_1(x) = \\dfrac{1}{\\sqrt{2}}\\left(\\dfrac{\\omega}{\\pi}\\right)^{1/4} 2\\sqrt{\\omega}\\,x\\exp\\!\\left(-\\dfrac{\\omega x^2}{2}\\right)$。\n- 目标密度：与 $|\\psi_1(x)|^2$ 成正比。\n- 要求输出的可观测量（按此顺序）：$\\langle x\\rangle$、$\\langle x^2\\rangle$、$\\langle E\\rangle$。\n- Metropolis 参数：高斯提议标准差 $\\sigma = 1.0$，初始位置 $x_0 = 1.0$，burn-in 步数 $B = 30000$，保留的样本数 $N = 120000$，随机种子 $s = 271828$。\n\n测试用例 C（三维氢原子类氢 $1s$ 轨道）：\n- 系统：三维非相对论氢原子，核电荷 $Z = 1$。哈密顿算符 $\\hat{H} = -\\dfrac{1}{2}\\nabla^2 - \\dfrac{1}{r}$，其中 $r = \\|\\mathbf{r}\\|$。\n- 波函数：$\\psi_{1s}(\\mathbf{r}) = \\dfrac{1}{\\sqrt{\\pi}} e^{-r}$。\n- 目标密度：在 $\\mathbb{R}^3$ 中与 $|\\psi_{1s}(\\mathbf{r})|^2$ 成正比。\n- 要求输出的可观测量（按此顺序）：$\\langle r\\rangle$、$\\langle r^2\\rangle$、$\\langle 1/r\\rangle$、$\\langle E\\rangle$。\n- Metropolis 参数：高斯提议标准差 $\\sigma = 0.7$，初始位置 $\\mathbf{r}_0 = (1.0, 0.0, 0.0)$，burn-in 步数 $B = 30000$，保留的样本数 $N = 150000$，随机种子 $s = 161803$。\n\n实现细节和约束：\n- 全程使用哈特里原子单位：能量单位为哈特里，距离单位为玻尔。输出是这些单位下的纯实数。\n- 对于 Metropolis 接受步骤，比较提议点和当前点未归一化目标密度的对数值。对于谐振子基态，未归一化的对数密度是 $-\\omega x^2$；对于第一激发态，使用 $\\log(x^2) - \\omega x^2$；对于类氢 $1s$ 轨道，使用 $-2r$，其中 $r = \\|\\mathbf{r}\\|$。\n- 确保在节面附近或原点处的数值鲁棒性：对于激发态波函数，避免在 $x = 0$ 处初始化；对于类氢情况，在远离 $\\mathbf{r} = \\mathbf{0}$ 的位置初始化。\n- 角度单位在此不适用。\n- 您的程序必须生成恰好一行输出，其中包含所有三个测试用例的聚合结果，形式为一个逗号分隔的浮点数列表，并用一对单独的方括号括起来。这 $12$ 个数字的顺序必须是：\n  1. 测试用例 A: $\\langle x\\rangle$, $\\langle x^2\\rangle$, $\\langle T\\rangle$, $\\langle V\\rangle$, $\\langle E\\rangle$\n  2. 测试用例 B: $\\langle x\\rangle$, $\\langle x^2\\rangle$, $\\langle E\\rangle$\n  3. 测试用例 C: $\\langle r\\rangle$, $\\langle r^2\\rangle$, $\\langle 1/r\\rangle$, $\\langle E\\rangle$\n- 每个数字在打印前必须四舍五入到恰好 $6$ 位小数。因此，最终输出格式必须类似于 $[-_1, -_2, \\dots, -_{12}]$，其中每个 $-_i$ 是一个保留 $6$ 位小数的十进制数。\n\n不从标准输入读取任何输入，也不可写入任何文件。程序必须在给定种子的情况下完全确定，并且不得依赖任何外部资源。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，问题提出得当，是客观的，并包含了构建唯一、可验证解所需的所有信息。该问题涉及应用 Metropolis-Hastings 算法对基本量子力学系统进行变分蒙特卡洛（Variational Monte Carlo, VMC）计算，这是计算物理化学中的一项标准和基础技术。我们将着手求解。\n\n问题的核心是估计可观测量 $\\hat{O}$ 的期望值，其由下式给出\n$$ \\langle O \\rangle = \\frac{\\int \\psi^*(\\mathbf{r}) \\hat{O} \\psi(\\mathbf{r}) \\, d\\mathbf{r}}{\\int |\\psi(\\mathbf{r})|^2 \\, d\\mathbf{r}} $$\n这可以使用玻恩定則的概率密度 $P(\\mathbf{r}) = |\\psi(\\mathbf{r})|^2 / \\int |\\psi(\\mathbf{r})|^2 \\, d\\mathbf{r}$ 重写。对于一个依赖于位置的可观测量 $O(\\mathbf{r})$，其期望值就是 $\\langle O \\rangle = \\int O(\\mathbf{r}) P(\\mathbf{r}) \\, d\\mathbf{r}$。这个积分可以通过从分布 $P(\\mathbf{r})$ 中抽取大量位置样本 $\\{\\mathbf{r}_i\\}_{i=1}^N$ 并计算样本均值来估计：\n$$ \\langle O \\rangle \\approx \\frac{1}{N} \\sum_{i=1}^{N} O(\\mathbf{r}_i) $$\n位置 $\\mathbf{r}_i$ 是使用 Metropolis-Hastings 算法生成的，该算法从一个与 $|\\psi(\\mathbf{r})|^2$ 成正比的分布中抽样。给定当前位置 $\\mathbf{r}_{curr}$，从一个对称的提议分布 $g(\\mathbf{r}_{prop}|\\mathbf{r}_{curr})$ 中提议一个新的位置 $\\mathbf{r}_{prop}$。该提议以如下概率被接受\n$$ \\alpha = \\min\\left(1, \\frac{|\\psi(\\mathbf{r}_{prop})|^2}{|\\psi(\\mathbf{r}_{curr})|^2}\\right) $$\n在实践中，我们使用概率密度的对数 $\\log(|\\psi|^2)$ 来提高数值稳定性。接受条件变为，如果 $\\log u < \\log(|\\psi(\\mathbf{r}_{prop})|^2) - \\log(|\\psi(\\mathbf{r}_{curr})|^2)$，则接受移动，其中 $u \\sim U(0,1)$。\n\n能量的期望值 $\\langle E \\rangle$ 需要特殊处理。它是通过平均局域能量 $E_L(\\mathbf{r})$ 来计算的，定义如下：\n$$ E_L(\\mathbf{r}) = \\frac{\\hat{H}\\psi(\\mathbf{r})}{\\psi(\\mathbf{r})} $$\n期望值则为 $\\langle E \\rangle = \\langle E_L \\rangle \\approx \\frac{1}{N} \\sum_{i=1}^N E_L(\\mathbf{r}_i)$。对于哈密顿算符 $\\hat{H}$ 的一个精确本征态 $\\psi$ 和其本征值 $E$，我们有 $\\hat{H}\\psi = E\\psi$，这意味着局域能量 $E_L(\\mathbf{r}) = E$ 对所有 $\\mathbf{r}$ 都是一个常数。这对我们的推导和实现提供了一个强有力的检验。\n\n我们现在为每个测试用例推导局域能量的解析表达式。\n\n**测试用例 A：一维谐振子基态**\n哈密顿算符为 $\\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$，其中 $\\omega=1$。\n波函数为 $\\psi_0(x) = C_0 \\exp(-\\frac{1}{2}\\omega x^2)$，其中 $C_0$ 是归一化常数。\n一阶导数：\n$$ \\frac{d\\psi_0}{dx} = C_0 (-\\omega x) \\exp\\left(-\\frac{1}{2}\\omega x^2\\right) = -\\omega x \\psi_0(x) $$\n二阶导数：\n$$ \\frac{d^2\\psi_0}{dx^2} = \\frac{d}{dx}(-\\omega x \\psi_0(x)) = -\\omega \\psi_0(x) - \\omega x \\frac{d\\psi_0}{dx} = -\\omega \\psi_0(x) - \\omega x (-\\omega x \\psi_0(x)) = (\\omega^2 x^2 - \\omega)\\psi_0(x) $$\n将哈密顿算符作用于波函数：\n$$ \\hat{H}\\psi_0 = -\\frac{1}{2}(\\omega^2 x^2 - \\omega)\\psi_0 + \\frac{1}{2}\\omega^2 x^2 \\psi_0 = \\left(-\\frac{1}{2}\\omega^2 x^2 + \\frac{1}{2}\\omega + \\frac{1}{2}\\omega^2 x^2\\right)\\psi_0 = \\frac{1}{2}\\omega\\psi_0 $$\n因此，局域能量为常数：\n$$ E_{L,0}(x) = \\frac{\\hat{H}\\psi_0}{\\psi_0} = \\frac{1}{2}\\omega $$\n当 $\\omega=1$ 时，$E_{L,0}(x) = 1/2$。局域動能由动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 导出：\n$$ T_L(x) = \\frac{\\hat{T}\\psi_0}{\\psi_0} = -\\frac{1}{2}(\\omega^2 x^2 - \\omega) = \\frac{1}{2}\\omega - \\frac{1}{2}\\omega^2 x^2 $$\n当 $\\omega=1$ 时，$T_{L}(x) = 1/2 - 1/2 x^2$。势能即为 $V(x) = \\frac{1}{2}\\omega^2 x^2 = \\frac{1}{2}x^2$。\n\n**测试用例 B：一维谐振子第一激发态**\n哈密顿算符相同，$\\omega=1$。波函数为 $\\psi_1(x) = C_1 x \\exp(-\\frac{1}{2}\\omega x^2)$。\n一阶导数：\n$$ \\frac{d\\psi_1}{dx} = C_1 \\left( \\exp\\left(-\\frac{1}{2}\\omega x^2\\right) - \\omega x^2 \\exp\\left(-\\frac{1}{2}\\omega x^2\\right) \\right) = \\frac{1-\\omega x^2}{x} \\psi_1(x) $$\n二阶导数：\n$$ \\frac{d^2\\psi_1}{dx^2} = \\frac{d}{dx}\\left(\\frac{1-\\omega x^2}{x} \\psi_1(x)\\right) = \\left( \\frac{-2\\omega x \\cdot x - (1-\\omega x^2) \\cdot 1}{x^2} \\right)\\psi_1(x) + \\left(\\frac{1-\\omega x^2}{x}\\right)\\frac{d\\psi_1}{dx} $$\n$$ = \\left( \\frac{-\\omega x^2 - 1}{x^2} \\right)\\psi_1 + \\left(\\frac{1-\\omega x^2}{x}\\right)^2 \\psi_1 = \\left( \\frac{-\\omega x^2 - 1}{x^2} + \\frac{1 - 2\\omega x^2 + \\omega^2 x^4}{x^2} \\right)\\psi_1 = \\left( \\frac{\\omega^2 x^4 - 3\\omega x^2}{x^2} \\right)\\psi_1 = (\\omega^2 x^2 - 3\\omega)\\psi_1 $$\n将哈密顿算符作用于波函数：\n$$ \\hat{H}\\psi_1 = -\\frac{1}{2}(\\omega^2 x^2 - 3\\omega)\\psi_1 + \\frac{1}{2}\\omega^2 x^2\\psi_1 = \\left( -\\frac{1}{2}\\omega^2 x^2 + \\frac{3}{2}\\omega + \\frac{1}{2}\\omega^2 x^2 \\right)\\psi_1 = \\frac{3}{2}\\omega\\psi_1 $$\n局域能量同样为常数：\n$$ E_{L,1}(x) = \\frac{\\hat{H}\\psi_1}{\\psi_1} = \\frac{3}{2}\\omega $$\n当 $\\omega=1$ 时，$E_{L,1}(x) = 3/2$。\n\n**测试用例 C：氢原子 1s 态**\n对于核电荷 $Z=1$ 的哈密顿算符是 $\\hat{H} = -\\frac{1}{2}\\nabla^2 - \\frac{1}{r}$。波函数是 $\\psi_{1s}(r) = C_{1s} \\exp(-r)$。\n我们对球对称函数 $f(r)$ 使用球坐标下的拉普拉斯算子：$\\nabla^2 f(r) = \\frac{d^2f}{dr^2} + \\frac{2}{r}\\frac{df}{dr}$。\n对 $r$ 的一阶导数：\n$$ \\frac{d\\psi_{1s}}{dr} = - \\psi_{1s} $$\n二阶导数：\n$$ \\frac{d^2\\psi_{1s}}{dr^2} = \\psi_{1s} $$\n应用拉普拉斯算子：\n$$ \\nabla^2\\psi_{1s} = \\psi_{1s} + \\frac{2}{r}(-\\psi_{1s}) = \\left(1 - \\frac{2}{r}\\right)\\psi_{1s} $$\n将哈密顿算符作用于波函数：\n$$ \\hat{H}\\psi_{1s} = -\\frac{1}{2}\\left(1 - \\frac{2}{r}\\right)\\psi_{1s} - \\frac{1}{r}\\psi_{1s} = \\left(-\\frac{1}{2} + \\frac{1}{r} - \\frac{1}{r}\\right)\\psi_{1s} = -\\frac{1}{2}\\psi_{1s} $$\n如预期的那样，局域能量为常数：\n$$ E_{L,1s}(r) = \\frac{\\hat{H}\\psi_{1s}}{\\psi_{1s}} = -\\frac{1}{2} $$\n这些推导出的解析表达式将在程序中实现，用于计算所需的可观测量平均值。程序将对每个测试用例执行 Metropolis-Hastings 过程，使用指定的参数，在 burn-in 期后收集可观测量样本，并计算它们的平均值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_metropolis(dim, x0, log_p_func, obs_func, sigma, n_burn, n_samples, seed):\n    \"\"\"\n    Runs a Metropolis-Hastings simulation.\n\n    Args:\n        dim (int): Dimensionality of the space.\n        x0 (list or np.ndarray): Initial position.\n        log_p_func (callable): Function returning the log of the unnormalized probability density.\n        obs_func (callable): Function that takes a position and returns an array of observables.\n        sigma (float): Standard deviation of the Gaussian proposal distribution.\n        n_burn (int): Number of burn-in steps.\n        n_samples (int): Number of samples to collect after burn-in.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        np.ndarray: An array of mean values for each observable.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    current_pos = np.array(x0, dtype=float)\n    \n    # Check for invalid initial position for log_p evaluations\n    try:\n        current_log_p = log_p_func(current_pos)\n    except (ValueError, ZeroDivisionError) as e:\n        raise ValueError(f\"Invalid initial position {x0}: {e}\")\n\n    # Determine the number of observables\n    first_obs = obs_func(current_pos)\n    n_obs = len(first_obs)\n    \n    # Burn-in phase\n    for _ in range(n_burn):\n        proposal_pos = current_pos + sigma * rng.normal(size=dim)\n        \n        try:\n            proposal_log_p = log_p_func(proposal_pos)\n        except (ValueError, ZeroDivisionError):\n            continue # Reject proposals at singularities\n\n        log_alpha = proposal_log_p - current_log_p\n        if np.log(rng.random()) < log_alpha:\n            current_pos = proposal_pos\n            current_log_p = proposal_log_p\n    \n    # Sampling phase\n    samples_obs = np.zeros((n_samples, n_obs))\n    for i in range(n_samples):\n        proposal_pos = current_pos + sigma * rng.normal(size=dim)\n        \n        try:\n            proposal_log_p = log_p_func(proposal_pos)\n        except (ValueError, ZeroDivisionError):\n            # If proposal is invalid, it's rejected. The current position is sampled again.\n            samples_obs[i] = obs_func(current_pos)\n            continue\n\n        log_alpha = proposal_log_p - current_log_p\n        if np.log(rng.random()) < log_alpha:\n            current_pos = proposal_pos\n            current_log_p = proposal_log_p\n        \n        samples_obs[i] = obs_func(current_pos)\n        \n    return np.mean(samples_obs, axis=0)\n\n# --- Test Case A: 1D QHO Ground State ---\ndef log_p_A(x_vec):\n    x = x_vec[0]\n    return -x**2\n\ndef observables_A(x_vec):\n    x = x_vec[0]\n    # Observables: <x>, <x^2>, <T>, <V>, <E>\n    # From derivation: T_L = 0.5 - 0.5*x^2, V = 0.5*x^2, E_L = 0.5\n    return np.array([x, x**2, 0.5 - 0.5*x**2, 0.5*x**2, 0.5])\n\n# --- Test Case B: 1D QHO First Excited State ---\ndef log_p_B(x_vec):\n    x = x_vec[0]\n    if x == 0.0:\n        return -np.inf # Node at x=0\n    return np.log(x**2) - x**2\n\ndef observables_B(x_vec):\n    x = x_vec[0]\n    # Observables: <x>, <x^2>, <E>\n    # From derivation: E_L = 1.5\n    return np.array([x, x**2, 1.5])\n\n# --- Test Case C: 3D Hydrogen Atom 1s State ---\ndef log_p_C(r_vec):\n    r = np.linalg.norm(r_vec)\n    return -2.0 * r\n\ndef observables_C(r_vec):\n    r = np.linalg.norm(r_vec)\n    # Observables: <r>, <r^2>, <1/r>, <E>\n    # From derivation: E_L = -0.5\n    if r == 0.0:\n        # This should not happen with proper initialization and continuous proposals\n        # but as a safeguard, return values that do not corrupt the average.\n        # <1/r> would be infinite. We can return NaNs or handle it.\n        # Since r=0 has zero probability measure, we return NaNs to be filtered\n        # or just rely on the fact that this branch is unreachable.\n        # For simplicity, let's assume it's not reached.\n        pass\n    return np.array([r, r**2, 1.0/r, -0.5])\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            'dim': 1, 'x0': [0.0], 'log_p_func': log_p_A, 'obs_func': observables_A,\n            'sigma': 1.1, 'n_burn': 20000, 'n_samples': 120000, 'seed': 314159\n        },\n        # Test Case B\n        {\n            'dim': 1, 'x0': [1.0], 'log_p_func': log_p_B, 'obs_func': observables_B,\n            'sigma': 1.0, 'n_burn': 30000, 'n_samples': 120000, 'seed': 271828\n        },\n        # Test Case C\n        {\n            'dim': 3, 'x0': [1.0, 0.0, 0.0], 'log_p_func': log_p_C, 'obs_func': observables_C,\n            'sigma': 0.7, 'n_burn': 30000, 'n_samples': 150000, 'seed': 161803\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_metropolis(\n            dim=params['dim'],\n            x0=params['x0'],\n            log_p_func=params['log_p_func'],\n            obs_func=params['obs_func'],\n            sigma=params['sigma'],\n            n_burn=params['n_burn'],\n            n_samples=params['n_samples'],\n            seed=params['seed']\n        )\n        all_results.extend(results)\n\n    # Format the final output string\n    formatted_results = ','.join(f\"{r:.6f}\" for r in all_results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "2681732"}]}