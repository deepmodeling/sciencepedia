{"hands_on_practices": [{"introduction": "不确定性驱动的主动学习策略的核心在于量化模型在构型空间中哪些区域“知道”得最少。高斯过程（GP）为此提供了一个严谨的数学框架，其后验方差直接反映了模型预测的不确定性。本练习将引导你完成一个基础但至关重要的计算，即如何将后验方差与信息增益联系起来，从而为选择下一个最高价值的从头计算点提供理论依据。[@problem_id:2760116]", "problem": "在数据高效的势能面（PES）构建中，主动学习器选择新的量子化学计算，以最有效地减少认知不确定性。考虑一个一维反应坐标 $s$，沿该坐标在潜在能量 $f(s)$ 上放置一个零均值高斯过程（GP; Gaussian Process）先验，其协方差函数为 $k(s,s') = \\sigma_{f}^{2}\\exp\\!\\big(-\\frac{(s-s')^{2}}{2\\ell^{2}}\\big)$。独立的观测噪声被建模为方差为 $\\sigma_{n}^{2}$ 的高斯分布。您已经在两个构型 $s_{1} = 0$ 和 $s_{2} = 1$ 处进行了电子结构计算（计算所请求的量不需要具体的能量数值）。您正在考虑一个候选构型 $s_{c} = 0.5$ 用于下一次计算。\n\n假设超参数 $\\sigma_{f}^{2} = 1$（单位为 $(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$），$\\ell = 1$（单位与 $s$ 的长度单位相同），以及 $\\sigma_{n}^{2} = 0.01$（单位为 $(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$）。仅使用多元高斯条件化和微分熵的基本性质，计算在给定两个现有输入的情况下潜在能量 $f(s_{c})$ 的后验方差，然后将此量解释为主动学习的单步信息增益代理。具体而言，将在 $s_{c}$ 处查询的预期信息增益视为新噪声观测与当前数据集条件下 $s_{c}$ 处的潜在能量之间的互信息。\n\n请将 $s_{c}$ 处的预期信息增益的数值作为最终答案报告，以纳特（nats）为单位，并四舍五入到四位有效数字。在您的最终方框答案中不要包含单位。", "solution": "该问题已经过验证，被认为是科学上可靠、适定、客观的，并包含唯一解所需的所有必要信息。所涉及的概念在用于理论化学的机器学习领域是标准的。因此，我将继续进行解答。\n\n目标是计算在候选构型 $s_c$ 处执行新的量子化学计算所带来的预期信息增益。该增益被定义为在现有数据集 $D$ 的条件下，$s_c$ 处预期噪声观测 $y_c$ 与真实潜在能量 $f_c \\equiv f(s_c)$ 之间的互信息。因此，信息增益（表示为 $IG$）由下式给出：\n$$\nIG = I(y_c; f_c | D)\n$$\n根据互信息和微分熵 $h(\\cdot)$ 的性质，这可以表示为两种等价形式：\n$$\nI(y_c; f_c | D) = h(f_c | D) - h(f_c | y_c, D) = h(y_c | D) - h(y_c | f_c, D)\n$$\n对于一个方差为 $\\sigma^2$ 的高斯随机变量 $X$，其微分熵为 $h(X) = \\frac{1}{2}\\ln(2\\pi e \\sigma^2)$。因此，信息增益是方差的函数。\n\n让我们使用第二种形式，$h(y_c | D) - h(y_c | f_c, D)$。\n观测模型为 $y_c = f_c + \\epsilon_c$，其中 $\\epsilon_c \\sim \\mathcal{N}(0, \\sigma_n^2)$ 是独立噪声。\n在给定真实潜在值 $f_c$ 的条件下，观测值 $y_c$ 的分布为 $p(y_c | f_c, D) = p(y_c | f_c) = \\mathcal{N}(y_c | f_c, \\sigma_n^2)$。其方差为 $\\mathrm{Var}(y_c | f_c, D) = \\sigma_n^2$。因此，其熵为：\n$$\nh(y_c | f_c, D) = \\frac{1}{2}\\ln(2\\pi e \\sigma_n^2)\n$$\n接下来，我们考虑仅以现有数据 $D$ 为条件的 $y_c$ 的分布。这就是后验预测分布。以 $D$ 为条件的潜在函数值 $f_c$ 是高斯的，$p(f_c | D) = \\mathcal{N}(f_c | \\mu_*(s_c), \\sigma^2_*(s_c))$，其中 $\\mu_*(s_c)$ 和 $\\sigma^2_*(s_c)$ 是高斯过程回归的后验均值和方差。观测值 $y_c$ 是两个独立高斯变量 $f_c|D$ 和 $\\epsilon_c$ 的和。它们的和的方差是它们方差的和：\n$$\n\\mathrm{Var}(y_c|D) = \\mathrm{Var}(f_c|D) + \\mathrm{Var}(\\epsilon_c) = \\sigma^2_*(s_c) + \\sigma_n^2\n$$\n$y_c$ 的后验预测分布的熵为：\n$$\nh(y_c|D) = \\frac{1}{2}\\ln\\left(2\\pi e (\\sigma^2_*(s_c) + \\sigma_n^2)\\right)\n$$\n结合这些结果，信息增益为：\n$$\nIG = \\frac{1}{2}\\ln\\left(2\\pi e (\\sigma^2_*(s_c) + \\sigma_n^2)\\right) - \\frac{1}{2}\\ln(2\\pi e \\sigma_n^2) = \\frac{1}{2}\\ln\\left(\\frac{\\sigma^2_*(s_c) + \\sigma_n^2}{\\sigma_n^2}\\right) = \\frac{1}{2}\\ln\\left(1 + \\frac{\\sigma^2_*(s_c)}{\\sigma_n^2}\\right)\n$$\n这个结果表明，信息增益仅取决于潜在函数的后验方差与观测噪声方差的比值。为了计算 $IG$，我们必须首先计算后验方差 $\\sigma^2_*(s_c)$。\n\n给定训练点 $\\mathbf{s} = [s_1, s_2]^T$，高斯过程在测试点 $s_c$ 的后验方差由以下公式给出：\n$$\n\\sigma^2_*(s_c) = k(s_c, s_c) - \\mathbf{k}_c^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{k}_c\n$$\n其中：\n- 协方差函数是 $k(s, s') = \\sigma_{f}^{2}\\exp\\left(-\\frac{(s-s')^{2}}{2\\ell^{2}}\\right)$。\n- 超参数是 $\\sigma_f^2 = 1$、$\\ell = 1$ 和 $\\sigma_n^2 = 0.01$。\n- 训练点是 $s_1=0$，$s_2=1$。候选点是 $s_c=0.5$。\n- $\\mathbf{k}_c$ 是测试点与训练点之间的协方差向量：$\\mathbf{k}_c = [k(s_c, s_1), k(s_c, s_2)]^T$。\n- $\\mathbf{K}$ 是训练点的协方差矩阵：$\\mathbf{K}_{ij} = k(s_i, s_j)$。\n- $\\mathbf{I}$ 是单位矩阵。\n\n使用给定值，核函数简化为 $k(s, s') = \\exp\\left(-\\frac{(s-s')^2}{2}\\right)$。我们计算必要的核函数值：\n$k(s_c, s_c) = k(0.5, 0.5) = \\exp(0) = 1$。\n$k(s_c, s_1) = k(0.5, 0) = \\exp\\left(-\\frac{0.5^2}{2}\\right) = \\exp(-0.125)$。\n$k(s_c, s_2) = k(0.5, 1) = \\exp\\left(-\\frac{(-0.5)^2}{2}\\right) = \\exp(-0.125)$。\n$k(s_1, s_1) = k(0, 0) = 1$。\n$k(s_2, s_2) = k(1, 1) = 1$。\n$k(s_1, s_2) = k(0, 1) = \\exp\\left(-\\frac{(-1)^2}{2}\\right) = \\exp(-0.5)$。\n\n向量 $\\mathbf{k}_c$ 和矩阵 $\\mathbf{K}$ 分别是：\n$$\n\\mathbf{k}_c = \\begin{pmatrix} \\exp(-0.125) \\\\ \\exp(-0.125) \\end{pmatrix} \\quad , \\quad\n\\mathbf{K} = \\begin{pmatrix} 1 & \\exp(-0.5) \\\\ \\exp(-0.5) & 1 \\end{pmatrix}\n$$\n现在我们构造待求逆的矩阵 $\\mathbf{M} = \\mathbf{K} + \\sigma_n^2 \\mathbf{I}$：\n$$\n\\mathbf{M} = \\begin{pmatrix} 1 + 0.01 & \\exp(-0.5) \\\\ \\exp(-0.5) & 1 + 0.01 \\end{pmatrix} = \\begin{pmatrix} 1.01 & \\exp(-0.5) \\\\ \\exp(-0.5) & 1.01 \\end{pmatrix}\n$$\n由于问题的对称性（$s_c$ 是 $s_1$ 和 $s_2$ 的中点），我们可以简化二次型 $\\mathbf{k}_c^T \\mathbf{M}^{-1} \\mathbf{k}_c$。令 $a = 1.01$，$b = \\exp(-0.5)$，以及 $k_{val} = \\exp(-0.125)$。\n$$\n\\mathbf{M}^{-1} = \\frac{1}{a^2 - b^2}\\begin{pmatrix} a & -b \\\\ -b & a \\end{pmatrix}\n$$\n$$\n\\mathbf{k}_c^T \\mathbf{M}^{-1} \\mathbf{k}_c = \\begin{pmatrix} k_{val} & k_{val} \\end{pmatrix} \\frac{1}{a^2-b^2} \\begin{pmatrix} a & -b \\\\ -b & a \\end{pmatrix} \\begin{pmatrix} k_{val} \\\\ k_{val} \\end{pmatrix} = \\frac{k_{val}^2}{a^2-b^2} \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} a-b \\\\ a-b \\end{pmatrix} = \\frac{2k_{val}^2(a-b)}{a^2-b^2}\n$$\n使用 $a^2-b^2 = (a-b)(a+b)$，上式简化为：\n$$\n\\mathbf{k}_c^T \\mathbf{M}^{-1} \\mathbf{k}_c = \\frac{2k_{val}^2}{a+b} = \\frac{2(\\exp(-0.125))^2}{1.01 + \\exp(-0.5)} = \\frac{2\\exp(-0.25)}{1.01 + \\exp(-0.5)}\n$$\n现在，我们代入数值：\n$\\exp(-0.25) \\approx 0.77880078$\n$\\exp(-0.5) \\approx 0.60653066$\n$$\n\\mathbf{k}_c^T \\mathbf{M}^{-1} \\mathbf{k}_c \\approx \\frac{2 \\times 0.77880078}{1.01 + 0.60653066} = \\frac{1.55760156}{1.61653066} \\approx 0.96354636\n$$\n那么，后验方差为：\n$$\n\\sigma^2_*(s_c) = k(s_c, s_c) - \\mathbf{k}_c^T \\mathbf{M}^{-1} \\mathbf{k}_c \\approx 1 - 0.96354636 = 0.03645364\n$$\n最后，我们计算信息增益，由于使用了自然对数，其单位是纳特（nats）：\n$$\nIG = \\frac{1}{2}\\ln\\left(1 + \\frac{\\sigma^2_*(s_c)}{\\sigma_n^2}\\right) \\approx \\frac{1}{2}\\ln\\left(1 + \\frac{0.03645364}{0.01}\\right) = \\frac{1}{2}\\ln(1 + 3.645364) = \\frac{1}{2}\\ln(4.645364)\n$$\n$$\nIG \\approx \\frac{1}{2} \\times 1.535876 \\approx 0.767938\n$$\n四舍五入到四位有效数字，预期信息增益为 $0.7679$。", "answer": "$$\\boxed{0.7679}$$", "id": "2760116"}, {"introduction": "在实际应用中，主动学习通常需要一次性选择一批（batch）候选点，而不仅仅是单个最不确定的点。为了避免所选点在构型上过于集中，确保采样多样性至关重要。本练习将介绍一种常见的策略：在描述符空间中利用聚类算法（如 k-means）对大量候选构型进行预选，从而选出一组能够代表不同区域的几何结构，以实现对势能面的更广泛探索。[@problem_id:2760075]", "problem": "设计并实现一个完整的、可运行的程序，该程序使用基于描述符的表示和 $k$-means 聚类，为势能面 (PESs) 的主动学习 (AL) 构建一个基于聚类的预选流水线。该程序必须实现此流水线，并数值上验证一个从第一性原理推导出的覆盖性质。该流水线必须纯粹以数学术语进行表述，并对一个合成的、但科学上合理的分子构型池进行操作。\n\n从以下基本基础开始：\n- 势能面 (PES) 是一个函数 $E(\\mathbf{R})$，它将原子核坐标 $\\mathbf{R}$ 映射到能量，而主动学习 (AL) 旨在高效地选择信息丰富的构型来学习 $E(\\mathbf{R})$。\n- 描述符映射 $\\phi$ 将一个分子构型嵌入到一个欧几里得向量空间中，以实现基于度量的选择；欧几里得距离定义为 $\\|\\mathbf{x}-\\mathbf{y}\\|_2 = \\sqrt{\\sum_i (x_i-y_i)^2}$。\n- $k$-means 聚类目标是将一个有限集 $\\{\\mathbf{v}_i\\}_{i=1}^n \\subset \\mathbb{R}^d$ 划分为 $k$ 个簇，每个簇有对应的质心 $\\{\\mathbf{c}_j\\}_{j=1}^k$，以最小化簇内欧几里得距离平方和。\n- 欧几里得空间中的三角不等式表明，对于所有 $\\mathbf{x},\\mathbf{y},\\mathbf{z} \\in \\mathbb{R}^d$，都有 $\\|\\mathbf{x}-\\mathbf{z}\\|_2 \\le \\|\\mathbf{x}-\\mathbf{y}\\|_2 + \\|\\mathbf{y}-\\mathbf{z}\\|_2$。\n\n数据集和描述符规范：\n- 考虑一个二维空间中的对称三原子体系 $\\text{A--B--A}$。对于每一种构型，将原子 $\\text{B}$ 置于原点，一个原子 $\\text{A}$ 置于 $(r, 0, 0)$，另一个原子 $\\text{A}$ 置于 $(r\\cos\\theta, r\\sin\\theta, 0)$，其中 $r$ 是键长，$\\theta$ 是键角。键长 $r$ 的单位是 $\\text{\\AA}$，角度 $\\theta$ 的单位是度，范围在 $[60,160]$ 之间；在内部，进行任何三角函数运算之前，需将 $\\theta$ 转换为弧度。\n- 将描述符 $\\phi$ 定义为三个成对原子间距离（单位为 $\\text{\\AA}$）的排序向量：两个 $\\text{A--B}$ 距离等于 $r$，$\\text{A--A}$ 距离等于 $2r\\sin(\\theta/2)$。因此 $\\phi(r,\\theta) \\in \\mathbb{R}^3$，其分量的单位为 $\\text{\\AA}$。\n- 通过取一个笛卡尔网格来构建候选池：$r \\in \\{1.0, 1.2, 1.4, 1.6, 1.8, 2.0\\}$（单位为 $\\text{\\AA}$）和 $\\theta \\in \\{60, 80, 100, 120, 140, 160\\}$（单位为度），从而得到 $36$ 个独特的构型。将前 $4$ 个描述符的副本追加到末尾，最终得到一个包含 $40$ 个描述符向量的池。\n\n待实现的预选流水线：\n1. 构建描述符矩阵 $\\mathbf{V} \\in \\mathbb{R}^{n \\times d}$，其中 $n=40$，$d=3$，第 $i$ 行是如上定义的 $\\phi(r_i,\\theta_i)$。可选地，通过 z-score 对描述符维度进行标准化：对于每一列 $j$，使用在整个池上计算出的样本均值 $\\mu_j$ 和标准差 $\\sigma_j$，将 $v_{ij}$ 转换为 $(v_{ij}-\\mu_j)/\\sigma_j$；如果禁用标准化，则使用原始的 $\\text{\\AA}$ 值。\n2. 在所选的表示（标准化的或原始的）上，使用欧几里得距离运行 $k$-means 聚类，该聚类具有确定性初始化和迭代界限。设得到的簇为 $C_1,\\dots,C_k$，其质心为 $\\mathbf{c}_1,\\dots,\\mathbf{c}_k$。\n3. 对于每个簇 $C_j$，计算其簇半径 $R_j = \\max_{\\mathbf{v}\\in C_j}\\|\\mathbf{v}-\\mathbf{c}_j\\|_2$，并选择 $C_j$ 中最接近 $\\mathbf{c}_j$ 的中心点（medoid） $\\mathbf{m}_j$；如果出现平局，则通过选择最小的全局索引来打破。\n4. 设 $S=\\{\\mathbf{m}_1,\\dots,\\mathbf{m}_k\\}$。定义全局覆盖半径\n$$\nR_{\\text{cov}}(S) = \\max_{1\\le i \\le n} \\min_{1\\le j \\le k} \\|\\mathbf{v}_i - \\mathbf{m}_j\\|_2.\n$$\n5. 仅使用三角不等式和上述定义，建立并数值验证\n$$\nR_{\\text{cov}}(S) \\le 2 \\cdot \\max_{1\\le j \\le k} R_j.\n$$\n当启用标准化时，距离是无量纲的；当禁用标准化时，距离的单位是 $\\text{\\AA}$。您必须在执行聚类的同一空间中计算 $R_{\\text{cov}}(S)$ 和该界限。\n\n测试套件：\n在上述描述的固定池上运行该流水线，使用以下参数集，并采用 k-means++ 算法（$k$ 个簇，最多 $200$ 次迭代，以及使用给定整数种子进行初始化）。对于每个测试，报告实际的覆盖半径和理论界限（两者都四舍五入到小数点后六位），以及一个二元指示符（如果不等式成立则为 $1$，否则为 $0$）。\n- 测试 1：$k=4$，禁用标准化，种子 $=42$。距离和界限必须以 $\\text{\\AA}$ 为单位报告，并四舍五入到小数点后六位。\n- 测试 2：$k=1$，启用标准化，种子 $=7$。距离和界限必须以标准化单位（无量纲）报告，并四舍五入到小数点后六位。\n- 测试 3：$k=10$，启用标准化，种子 $=123$。距离和界限必须以标准化单位（无量纲）报告，并四舍五入到小数点后六位。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含九个结果，形式为一个方括号括起来的逗号分隔列表。该列表必须是：\n$$\n[\\;R_{\\text{cov}}^{(1)},\\;B^{(1)},\\;\\text{ok}^{(1)},\\;R_{\\text{cov}}^{(2)},\\;B^{(2)},\\;\\text{ok}^{(2)},\\;R_{\\text{cov}}^{(3)},\\;B^{(3)},\\;\\text{ok}^{(3)}\\;],\n$$\n其中 $R_{\\text{cov}}^{(t)}$ 是测试 $t$ 的实际覆盖半径，$B^{(t)}$ 是测试 $t$ 的界限 $2\\max_j R_j$，而 $\\text{ok}^{(t)}$ 在 $R_{\\text{cov}}^{(t)} \\le B^{(t)}$ 时为 $1$，否则为 $0$。所有三个 $R_{\\text{cov}}^{(t)}$ 和所有三个 $B^{(t)}$ 都必须打印为四舍五入到小数点后六位的小数浮点数。对于禁用标准化的测试，单位是 $\\text{\\AA}$；对于启用标准化的测试，这些值是无量纲的。", "solution": "所提出的问题要求设计和实现一个用于势能面主动学习的预选流水线，该流水线基于描述符表示和 $k$-means 聚类。主要任务是为一个合成生成的数据集实现此流水线，并数值验证一个首先从第一性原理推导出的覆盖性质。\n\n在进行实现之前，我们必须确定该问题的有效性。该问题在理论化学和机器学习方面具有科学依据，在数学上是适定的，所有必要的数据和参数均已指定，并以客观、正式的语言进行了阐述。其核心不等式是三角不等式的直接推论，而三角不等式是度量空间的一个基本公理。因此，该问题被认为是有效的，有必要给出一个完整的解决方案。\n\n该解决方案分两个阶段进行：首先，对主导不等式进行形式化推导；其次，描述用于实现该流水线并验证该不等式的计算算法。\n\n**1. 覆盖半径不等式的推导**\n\n问题陈述了一组中心点 $S$ 的全局覆盖半径 $R_{\\text{cov}}(S)$ 与最大簇半径 $R_{\\max}$ 之间的一种关系。我们必须证明，对于一个被划分为簇 $C_1, \\dots, C_k$ 的数据集 $V$：\n$$\nR_{\\text{cov}}(S) \\le 2 \\cdot \\max_{1\\le j \\le k} R_j\n$$\n其中 $R_j = \\max_{\\mathbf{v}\\in C_j}\\|\\mathbf{v}-\\mathbf{c}_j\\|_2$ 是质心为 $\\mathbf{c}_j$ 的簇 $C_j$ 的半径，而 $S = \\{\\mathbf{m}_1, \\dots, \\mathbf{m}_k\\}$ 是簇中心点的集合。中心点 $\\mathbf{m}_j$ 是簇 $C_j$ 中最接近质心 $\\mathbf{c}_j$ 的点。\n\n推导过程如下：\n\n设 $\\mathbf{v}$ 是完整数据集 $V$ 中的一个任意数据点。由于簇 $\\{C_j\\}_{j=1}^k$ 构成了 $V$ 的一个划分，$\\mathbf{v}$ 必须恰好属于一个簇，记为 $C_j$。\n\n全局覆盖半径定义为 $R_{\\text{cov}}(S) = \\max_{\\mathbf{v} \\in V} \\min_{\\mathbf{m} \\in S} \\|\\mathbf{v} - \\mathbf{m}\\|_2$。让我们来求项 $\\min_{\\mathbf{m} \\in S} \\|\\mathbf{v} - \\mathbf{m}\\|_2$ 的一个上界。这个最小距离必然小于或等于到任何特定中心点的距离，包括 $\\mathbf{v}$ 所属簇 $C_j$ 对应的中心点 $\\mathbf{m}_j$：\n$$\n\\min_{\\mathbf{m} \\in S} \\|\\mathbf{v} - \\mathbf{m}\\|_2 \\le \\|\\mathbf{v} - \\mathbf{m}_j\\|_2\n$$\n我们可以利用描述符空间中的三角不等式，以质心 $\\mathbf{c}_j$ 作为中间点，来界定 $\\|\\mathbf{v} - \\mathbf{m}_j\\|_2$ 这一项：\n$$\n\\|\\mathbf{v} - \\mathbf{m}_j\\|_2 \\le \\|\\mathbf{v} - \\mathbf{c}_j\\|_2 + \\|\\mathbf{c}_j - \\mathbf{m}_j\\|_2\n$$\n现在，我们必须界定右侧的两项。\n1.  根据簇半径的定义 $R_j = \\max_{\\mathbf{x}\\in C_j}\\|\\mathbf{x}-\\mathbf{c}_j\\|_2$，并且由于 $\\mathbf{v} \\in C_j$，直接可得 $\\|\\mathbf{v} - \\mathbf{c}_j\\|_2 \\le R_j$。\n2.  中心点 $\\mathbf{m}_j$ 也是其所在簇 $C_j$ 内的一个点。因此，它到质心 $\\mathbf{c}_j$ 的距离也受簇半径的限制：$\\|\\mathbf{m}_j - \\mathbf{c}_j\\|_2 \\le R_j$。\n\n将这些界限代回到三角不等式中，得到：\n$$\n\\|\\mathbf{v} - \\mathbf{m}_j\\|_2 \\le R_j + R_j = 2 R_j\n$$\n结合我们的不等式，对于任何 $\\mathbf{v} \\in C_j$ 我们有：\n$$\n\\min_{\\mathbf{m} \\in S} \\|\\mathbf{v} - \\mathbf{m}\\|_2 \\le 2 R_j\n$$\n这个不等式对任何点 $\\mathbf{v}$ 都成立。为了找到全局覆盖半径，我们必须取遍 $V$ 中所有点的最大值。设 $R_{\\max} = \\max_{1\\le j \\le k} R_j$。\n由于对于任何簇 $j$ 都有 $R_j \\le R_{\\max}$，我们可以写出：\n$$\n\\min_{\\mathbf{m} \\in S} \\|\\mathbf{v} - \\mathbf{m}\\|_2 \\le 2 R_j \\le 2 R_{\\max}\n$$\n这对 $V$ 中的任何点 $\\mathbf{v}$ 都成立。因此，左侧对所有 $\\mathbf{v}$ 取最大值也必须满足这个不等式：\n$$\nR_{\\text{cov}}(S) = \\max_{\\mathbf{v} \\in V} \\min_{\\mathbf{m} \\in S} \\|\\mathbf{v} - \\mathbf{m}\\|_2 \\le 2 R_{\\max}\n$$\n这样就完成了形式化证明。\n\n**2. 算法实现**\n\n该不等式的验证将通过一个实现指定流水线的程序来执行。\n\n**步骤 1：数据生成。**构建一个包含 $n=40$ 个 $\\mathbb{R}^3$ 中描述符向量的池。分子构型由键长 $r$ 和键角 $\\theta$ 参数化。描述符 $\\phi(r, \\theta)$ 是三个原子间距离的排序向量。对于指定的对称三原子体系 A-B-A，两个距离等于 A-B 键长 $r$，第三个距离，即 A-A 距离，为 $d_{\\text{A-A}} = 2r\\sin(\\theta/2)$。对于给定的范围 $\\theta \\in [60, 160]$ 度，$d_{\\text{A-A}} \\ge r$。因此，排序后的描述符向量总是 $[r, r, 2r\\sin(\\theta/2)]$。\n程序首先从 $r \\in \\{1.0, 1.2, 1.4, 1.6, 1.8, 2.0\\}$ 和 $\\theta \\in \\{60, 80, 100, 120, 140, 160\\}$ 的笛卡尔积中生成 $36$ 个独特的描述符。为进行三角函数计算，角度必须从度转换为弧度。然后，将前 $4$ 个描述符的副本追加到末尾，形成最终的 $40 \\times 3$ 描述符矩阵 $\\mathbf{V}$。\n\n**步骤 2：标准化。**对于需要标准化的测试，矩阵 $\\mathbf{V}$ 的每一列 $j$ 都通过 z-score 进行转换：$v'_{ij} = (v_{ij} - \\mu_j) / \\sigma_j$，其中 $\\mu_j$ 和 $\\sigma_j$ 是列 $j$ 在所有 $40$ 个点上的样本均值和标准差。如果 $\\sigma_j = 0$，则不对该列进行缩放。随后的计算都在这个标准化的无量纲数据上进行。否则，计算使用以埃（$\\text{\\AA}$）为单位的原始数据。\n\n**步骤 3：K-Means 聚类。**需要一个确定性的 $k$-means 算法。这通过实现带有种子伪随机数生成器的 $k$-means++ 初始化算法，然后进行固定次数的迭代更新来实现。\n-   **初始化 ($k$-means++):**\n    1.  使用指定的整数为随机数生成器提供种子。\n    2.  从数据点中均匀随机选择第一个质心。\n    3.  对于每个后续的质心，选择数据点 $\\mathbf{v}_i$ 的概率与其到最近的现有质心的欧几里得距离平方成正比。\n-   **迭代:**\n    1.  **分配：**将每个数据点分配给其最近质心对应的簇。\n    2.  **更新：**将每个簇的质心重新计算为分配给它的所有点的均值。如果一个簇变为空，则不更新其质心。\n    此过程重复固定次数的迭代（按规定为 $200$ 次）。该算法输出最终的质心和每个数据点的簇分配（标签）。\n\n**步骤 4：计算与验证。**\n1.  **簇半径：**对于每个簇 $C_j$，计算簇半径 $R_j$ 为 $C_j$ 中任意点与簇质心 $\\mathbf{c}_j$ 之间的最大欧几里得距离。\n2.  **中心点选择：**对于每个簇 $C_j$，其中心点 $\\mathbf{m}_j$ 被确定为 $C_j$ 中与质心 $\\mathbf{c}_j$ 欧几里得距离最小的数据点。平局通过选择在 $40$ 点池中具有最小原始索引的点来打破。\n3.  **覆盖半径：**计算所有 $40$ 个数据点与 $k$ 个选定中心点之间的距离矩阵。然后，通过首先取每个数据点到任意中心点的最小距离，再取这些最小距离中的最大值，来找到全局覆盖半径 $R_{\\text{cov}}(S)$。\n4.  **不等式检验：**理论界限计算为 $B = 2 \\cdot \\max_j R_j$。对不等式 $R_{\\text{cov}}(S) \\le B$ 进行评估，产生一个二元结果（真为 $1$，假为 $0$）。\n\n对指定的三个测试用例中的每一个都执行这个完整的流水线，并按要求收集和格式化结果（$R_{\\text{cov}}$、$B$ 和二元标志）。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to run the active learning preselection pipeline and verify the covering property.\n    \"\"\"\n\n    def generate_descriptors():\n        \"\"\"\n        Constructs the pool of descriptor vectors for the A-B-A system.\n        \"\"\"\n        r_vals = np.array([1.0, 1.2, 1.4, 1.6, 1.8, 2.0])\n        theta_vals_deg = np.array([60, 80, 100, 120, 140, 160])\n        theta_vals_rad = np.deg2rad(theta_vals_deg)\n\n        n_r = len(r_vals)\n        n_theta = len(theta_vals_deg)\n        n_unique = n_r * n_theta\n        descriptors = np.zeros((n_unique, 3))\n\n        idx = 0\n        for r in r_vals:\n            for theta in theta_vals_rad:\n                d_ab = r\n                d_aa = 2 * r * np.sin(theta / 2)\n                # For theta >= 60 deg, d_aa >= r, so sorted vector is always [r, r, d_aa]\n                descriptors[idx] = [d_ab, d_ab, d_aa]\n                idx += 1\n        \n        # Append duplicates of the first 4 descriptors\n        final_descriptors = np.vstack([descriptors, descriptors[:4]])\n        return final_descriptors\n\n    def standardize_descriptors(v):\n        \"\"\"\n        Applies z-score standardization to the descriptor matrix.\n        \"\"\"\n        mean = np.mean(v, axis=0)\n        std = np.std(v, axis=0)\n        # Avoid division by zero if a column is constant\n        std[std == 0] = 1.0\n        return (v - mean) / std\n\n    def kmeans_plusplus_init(X, k, rng):\n        \"\"\"\n        Deterministic k-means++ initialization.\n        \"\"\"\n        n_samples, n_features = X.shape\n        centroids = np.zeros((k, n_features))\n        \n        # 1. Choose first centroid uniformly at random\n        first_idx = rng.choice(n_samples)\n        centroids[0] = X[first_idx]\n        \n        # 2. For subsequent centroids\n        distances = np.full(n_samples, np.inf)\n        for i in range(1, k):\n            # Update distances to nearest known centroid\n            dist_sq = np.sum((X - centroids[i-1])**2, axis=1)\n            distances = np.minimum(distances, dist_sq)\n            \n            # Choose next centroid with probability proportional to D(x)^2\n            probs = distances / np.sum(distances)\n            next_idx = rng.choice(n_samples, p=probs)\n            centroids[i] = X[next_idx]\n            \n        return centroids\n\n    def kmeans_clustering(X, k, n_iter, seed):\n        \"\"\"\n        A complete, deterministic k-means implementation.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        # Initialize centroids using k-means++\n        centroids = kmeans_plusplus_init(X, k, rng)\n\n        for _ in range(n_iter):\n            # Assignment step\n            dist_matrix = cdist(X, centroids, 'euclidean')\n            labels = np.argmin(dist_matrix, axis=1)\n            \n            # Update step\n            new_centroids = np.zeros_like(centroids)\n            for j in range(k):\n                cluster_points = X[labels == j]\n                if len(cluster_points) > 0:\n                    new_centroids[j] = np.mean(cluster_points, axis=0)\n                else:\n                    # Keep old centroid if cluster is empty\n                    new_centroids[j] = centroids[j]\n            centroids = new_centroids\n            \n        return centroids, labels\n\n    def run_pipeline(k, standardize, seed):\n        \"\"\"\n        Executes the entire pipeline for a single test case.\n        \"\"\"\n        # Step 1: Generate data\n        V = generate_descriptors()\n        \n        # Step 2: Standardize if required\n        X = standardize_descriptors(V) if standardize else V\n        n_points, n_dims = X.shape\n\n        # Step 3: Run k-means\n        centroids, labels = kmeans_clustering(X, k, n_iter=200, seed=seed)\n\n        # Step 4: Compute radii and medoids\n        cluster_radii = np.zeros(k)\n        medoids = np.zeros((k, n_dims))\n        medoid_indices = np.zeros(k, dtype=int)\n\n        for j in range(k):\n            cluster_mask = (labels == j)\n            if np.sum(cluster_mask) == 0:\n                # Handle empty cluster: radius is 0, medoid is undefined but we place it at centroid\n                cluster_radii[j] = 0.0\n                medoids[j] = centroids[j] \n                # This case is unlikely, if it happens, argmin on empty will fail.\n                # To assign a \"dummy\" medoid index, find the point closest to this lonely centroid\n                medoid_indices[j] = np.argmin(cdist(X, centroids[j:j+1]))\n                continue\n\n            cluster_points = X[cluster_mask]\n            point_indices = np.where(cluster_mask)[0]\n            \n            # Compute cluster radius\n            distances_to_centroid = cdist(cluster_points, centroids[j:j+1]).flatten()\n            cluster_radii[j] = np.max(distances_to_centroid)\n            \n            # Find medoid\n            medoid_local_idx = np.argmin(distances_to_centroid)\n            medoid_global_idx = point_indices[medoid_local_idx]\n            medoids[j] = X[medoid_global_idx]\n            medoid_indices[j] = medoid_global_idx\n        \n        # Step 5: Compute covering radius and bound\n        # Covering radius R_cov(S)\n        dist_to_medoids = cdist(X, medoids)\n        min_dist_to_medoid = np.min(dist_to_medoids, axis=1)\n        r_cov = np.max(min_dist_to_medoid)\n        \n        # Theoretical bound B\n        max_radius = np.max(cluster_radii) if k > 0 else 0.0\n        bound = 2 * max_radius\n        \n        # Check inequality\n        # Use a small tolerance for floating point comparison, although direct is fine\n        is_inequality_valid = 1 if r_cov = bound + 1e-9 else 0\n        \n        return r_cov, bound, is_inequality_valid\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # k, standardization_enabled, seed\n        (4, False, 42),\n        (1, True, 7),\n        (10, True, 123),\n    ]\n\n    results = []\n    for k, standardize, seed in test_cases:\n        r_cov, bound, is_valid = run_pipeline(k, standardize, seed)\n        results.append(f\"{r_cov:.6f}\")\n        results.append(f\"{bound:.6f}\")\n        results.append(str(is_valid))\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2760075"}, {"introduction": "一个高质量的机器学习势能面不仅要准确预测能量和力，还必须遵守基本的物理定律。其中一条基本定律是，势能面产生的力场必须是保守的，即沿任何闭合路径所做的功为零。本练习将指导你设计并实现一个数值诊断工具，通过计算力场沿闭合回路的环量 $\\oint_C \\mathbf{F}(\\mathbf{R})\\cdot d\\mathbf{R}$ 来检验其是否满足保守性，这是一种检测非保守力伪影的有效方法，对于确保分子动力学模拟的物理真实性至关重要。[@problem_id:2760109]", "problem": "你的任务是设计一种数值诊断方法，通过学习得到的势能面（PES）所导出的力场，来检测其中的非保守伪影。在理想情况下，如果力场 $\\mathbf{F}(\\mathbf{R})$ 是保守的，即对于某个标量势 $E(\\mathbf{R})$ 存在 $\\mathbf{F}(\\mathbf{R})=-\\nabla E(\\mathbf{R})$，那么对于位形空间中任意足够光滑的闭合回路 $C$，其环量满足 $\\oint_C \\mathbf{F}(\\mathbf{R})\\cdot d\\mathbf{R} = 0$。根据 Stokes' 定理，这等价于以 $C$ 为边界的任意曲面 $S$ 上的曲面积分 $\\iint_{S} (\\nabla \\times \\mathbf{F})\\cdot \\mathbf{\\hat{n}}\\, dA$ 为零，其中 $\\mathbf{\\hat{n}}$ 是单位法向量。在实践中，学习误差或数值不一致性可能会在 $\\mathbf{F}(\\mathbf{R})$ 中引入非保守分量。\n\n从这些基本性质出发，设计并实现一个数值检验。该检验给定一个平面闭合回路 $C$ 和一个力预测器 $\\mathbf{F}(\\mathbf{R})$，通过沿 $C$ 的一条折线近似使用复合中点求积法来估算环量 $\\oint_C \\mathbf{F}\\cdot d\\mathbf{R}$，然后将估算的环量除以所围面积 $A(C)$，从而形成一个标量诊断值，用以近似回路所围面积上旋度的平均法向分量。具体而言，对于一条顶点为 $\\{\\mathbf{R}_k\\}_{k=0}^{N-1}$（其中 $\\mathbf{R}_N\\equiv \\mathbf{R}_0$）的折线，使用公式\n$$\n\\widehat{\\Gamma}_N(C) \\equiv \\sum_{k=0}^{N-1} \\mathbf{F}\\!\\left(\\frac{\\mathbf{R}_{k}+\\mathbf{R}_{k+1}}{2}\\right)\\cdot\\left(\\mathbf{R}_{k+1}-\\mathbf{R}_{k}\\right),\n$$\n并定义诊断值为\n$$\n\\omega(C) \\equiv \\frac{\\widehat{\\Gamma}_N(C)}{A(C)}.\n$$\n如果 $|\\omega(C)|$ 的值非零且超出用户指定的容差 $\\tau$，则表明存在非保守伪影。当使用角度对曲线进行参数化时，必须使用弧度单位。本问题中所有量均为无量纲。\n\n实现一个程序，该程序能够构建指定的回路 $C$，在所需的点上计算 $\\mathbf{F}(\\mathbf{R})$，使用复合中点法则计算 $\\widehat{\\Gamma}_N(C)$，再除以给定回路形状的精确面积 $A(C)$，并为每个测试用例返回一个布尔分类：如果 $|\\omega(C)|$ 超过给定的容差 $\\tau$，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。对于任何随机部分，你必须使用固定的伪随机种子 $0$ 以确保输出是确定性的。\n\n你的程序必须能处理以下两种二维回路族：\n- 圆形：圆心在原点，半径为 $r$，由 $\\theta\\in[0,2\\pi)$ 参数化，$\\mathbf{R}(\\theta)=\\big(r\\cos\\theta,\\, r\\sin\\theta\\big)$，离散化为 $N$ 个相等的角步长。使用精确面积 $A(C)=\\pi r^2$。\n- 轴对齐矩形：中心在原点，宽为 $w$，高为 $h$，逆时针遍历，每条边分为 $N_{\\text{side}}$ 个相等的线段。使用精确面积 $A(C)=w\\,h$。\n\n你的程序必须在二维空间中实现以下力场 $\\mathbf{F}(\\mathbf{R})$：\n- 谐振保守场：从 $E(x,y)=\\tfrac{1}{2}\\big(k_x x^2 + k_y y^2\\big)$ 导出，因此 $\\mathbf{F}(x,y)=\\big(-k_x x,\\,-k_y y\\big)$。\n- 谐振加涡旋场：$\\mathbf{F}(x,y)=\\big(-k_x x,\\,-k_y y\\big) + \\gamma\\,\\big(-y,\\,x\\big)$。\n- 谐振加各向同性高斯噪声场：$\\mathbf{F}(x,y)=\\big(-k_x x,\\,-k_y y\\big) + \\boldsymbol{\\xi}$，其中 $\\boldsymbol{\\xi}$ 的每个分量都是从均值为 $0$、标准差为 $\\sigma$ 的正态分布中抽取的独立样本，在每个求值点都进行独立地重新采样；为保证可复现性，使用固定的伪随机种子 $0$。\n- 纯涡旋场：$\\mathbf{F}(x,y)=\\gamma\\,\\big(-y,\\,x\\big)$。\n- 零力场：$\\mathbf{F}(x,y)=\\big(0,\\,0\\big)$。\n\n测试套件。你的程序必须计算并报告以下每个用例的布尔分类：\n- 用例 1（保守场，圆形）：谐振场，$k_x=3.0$，$k_y=5.0$；圆形回路，$r=1.0$，$N=1024$；容差 $\\tau=1.0\\times 10^{-8}$。\n- 用例 2（非保守场，圆形）：谐振加涡旋场，$k_x=3.0$，$k_y=5.0$，$\\gamma=0.05$；圆形回路，$r=1.0$，$N=1024$；容差 $\\tau=1.0\\times 10^{-3}$。\n- 用例 3（带噪声的保守场，圆形）：谐振加噪声场，$k_x=3.0$，$k_y=5.0$，$\\sigma=1.0\\times 10^{-3}$；圆形回路，$r=1.0$，$N=2048$；容差 $\\tau=1.0\\times 10^{-2}$。\n- 用例 4（零力场，矩形）：零力场；矩形回路，$w=2.0$，$h=1.0$，$N_{\\text{side}}=200$；容差 $\\tau=1.0\\times 10^{-12}$。\n- 用例 5（非保守场，矩形）：纯涡旋场，$\\gamma=0.02$；矩形回路，$w=1.0$，$h=1.0$，$N_{\\text{side}}=16$；容差 $\\tau=5.0\\times 10^{-3}$。\n\n最终输出格式。你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[True,False,True,False,True]”），其中第 $i$ 个条目是按上述顺序列出的用例 $i$ 的布尔结果。", "solution": "该问题要求设计并实现一种数值诊断方法，用于识别给定二维力场 $\\mathbf{F}(\\mathbf{R})$ 中的非保守伪影。该诊断方法基于应用于保守矢量场的矢量微积分基本原理。\n\n如果一个力场 $\\mathbf{F}$ 可以表示为标量势能函数 $E$ 的负梯度，即 $\\mathbf{F}(\\mathbf{R}) = -\\nabla E(\\mathbf{R})$，则该力场被定义为保守场。任何保守场的一个关键性质是，沿任意闭合路径所做的功（称为环量 $\\Gamma(C)$）恒等于零。这由线路积分 $\\Gamma(C) = \\oint_C \\mathbf{F}(\\mathbf{R})\\cdot d\\mathbf{R} = 0$ 表示。根据 Stokes' 定理，这等价于力场的旋度处处为零的条件，即 $\\nabla \\times \\mathbf{F} = \\mathbf{0}$。一个学习得到的势能面所产生的力场可能不严格满足此条件，我们的任务就是检测此类偏差。\n\n估算环量 $\\widehat{\\Gamma}_N(C)$ 的数值流程是通过一条由 $N$ 个顶点序列 $\\{\\mathbf{R}_k\\}_{k=0}^{N}$（其中 $\\mathbf{R}_N \\equiv \\mathbf{R}_0$）定义的折线来近似闭合回路 $C$。然后使用复合中点求积法则来近似该线路积分。对于从 $\\mathbf{R}_k$ 到 $\\mathbf{R}_{k+1}$ 的每条线段，力在其中点 $\\frac{\\mathbf{R}_{k}+\\mathbf{R}_{k+1}}{2}$ 处被计算。该线段对环量的贡献是此力与线段位移矢量 $\\mathbf{R}_{k+1}-\\mathbf{R}_{k}$ 的点积。将所有线段的贡献求和，即可得到总的估算环量：\n$$\n\\widehat{\\Gamma}_N(C) \\equiv \\sum_{k=0}^{N-1} \\mathbf{F}\\!\\left(\\frac{\\mathbf{R}_{k}+\\mathbf{R}_{k+1}}{2}\\right)\\cdot\\left(\\mathbf{R}_{k+1}-\\mathbf{R}_{k}\\right)\n$$\n为了创建一个尺度不变的诊断值，我们通过二维下的 Stokes' 定理将环量与旋度联系起来：$\\oint_C \\mathbf{F}\\cdot d\\mathbf{R} = \\iint_S (\\nabla \\times \\mathbf{F})_z \\,dA$。根据积分中值定理，在由 $C$ 包围的曲面 $S$ 中存在一点，该点处 $(\\nabla \\times \\mathbf{F})_z$ 的值等于其在整个曲面上的平均值，即 $\\frac{1}{A(C)}\\iint_S (\\nabla \\times \\mathbf{F})_z \\,dA$，其中 $A(C)$ 是 $S$ 的面积。因此，我们将标量诊断值 $\\omega(C)$ 定义为由回路面积归一化的估算环量：\n$$\n\\omega(C) \\equiv \\frac{\\widehat{\\Gamma}_N(C)}{A(C)}\n$$\n这个量 $\\omega(C)$ 可作为回路所围面积上旋度平均法向分量的数值近似。如果 $|\\omega(C)|$ 的非零值大于指定的容差 $\\tau$，则标志着可能存在非保守伪影。最终输出是一个布尔值，表示是否满足 $|\\omega(C)| > \\tau$ 这个条件。\n\n该实现以模块化的方式构建，以确保其清晰性和正确性。\n首先，设计函数来生成指定闭合回路的顶点：圆形和轴对齐矩形。半径为 $r$ 的圆被离散化为 $N$ 个相等的角步长，产生 $N+1$ 个顶点。宽度为 $w$、高度为 $h$ 的矩形每条边被离散化为 $N_{\\text{side}}$ 个线段。总线段数为 $4 \\times N_{\\text{side}}$。\n其次，一组函数实现了指定的力场。每个函数都被设计为矢量化的，接受一个形状为 $(M, 2)$ 的包含 $M$ 个位置矢量的数组，并返回一个相应的包含 $M$ 个力矢量的数组。这种方法对计算效率至关重要。\n对于涉及随机性的情况（`harmonic_noise`），使用固定的种子 $0$ 初始化一个随机数生成器，以确保结果的确定性和可复现性。\n实现的核心是计算诊断值的函数。该函数将折线顶点、回路面积、力函数和容差作为输入。它计算折线所有线段的中点和位移矢量。然后，用所有中点组成的数组作为参数，调用一次力函数。通过对每条线段的力和位移矢量的点积求和，来计算环量 $\\widehat{\\Gamma}_N(C)$。在 NumPy 中，这个和可以高效地计算为 `np.sum(forces * displacements)`。最后，计算诊断值 $\\omega(C)$，并将其绝对值与容差 $\\tau$ 进行比较，以返回 `True` 或 `False`。\n主程序遍历一个预定义的测试套件。对于每个用例，它配置相应的回路、力场和参数，调用诊断计算，并将布尔结果追加到一个列表中。最终输出是代表此布尔值列表的单个字符串，并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# The problem specifies a fixed pseudorandom seed of 0 for reproducibility.\nRNG = np.random.default_rng(seed=0)\n\ndef generate_circle_polyline(r, N):\n    \"\"\"\n    Generates vertices for a circle centered at the origin, discretized into N segments.\n    The polyline contains N+1 points, with the last point being the same as the first.\n    \n    Args:\n        r (float): The radius of the circle.\n        N (int): The number of segments.\n        \n    Returns:\n        np.ndarray: An (N+1, 2) array of vertex coordinates.\n    \"\"\"\n    thetas = np.linspace(0.0, 2.0 * np.pi, N + 1)\n    x = r * np.cos(thetas)\n    y = r * np.sin(thetas)\n    return np.stack([x, y], axis=1)\n\ndef generate_rectangle_polyline(w, h, N_side):\n    \"\"\"\n    Generates vertices for an axis-aligned rectangle centered at the origin.\n    The path is counterclockwise and has N_side segments per side.\n    \n    Args:\n        w (float): The width of the rectangle.\n        h (float): The height of the rectangle.\n        N_side (int): The number of segments per side.\n        \n    Returns:\n        np.ndarray: An (4*N_side + 1, 2) array of vertex coordinates.\n    \"\"\"\n    half_w, half_h = w / 2.0, h / 2.0\n    p1 = np.array([-half_w, -half_h])  # Bottom-left\n    p2 = np.array([half_w, -half_h])   # Bottom-right\n    p3 = np.array([half_w, half_h])    # Top-right\n    p4 = np.array([-half_w, half_h])   # Top-left\n\n    bottom_edge = np.array([np.linspace(p1[0], p2[0], N_side + 1), np.full(N_side + 1, p1[1])]).T\n    right_edge = np.array([np.full(N_side + 1, p2[0]), np.linspace(p2[1], p3[1], N_side + 1)]).T\n    top_edge = np.array([np.linspace(p3[0], p4[0], N_side + 1), np.full(N_side + 1, p3[1])]).T\n    left_edge = np.array([np.full(N_side + 1, p4[0]), np.linspace(p4[1], p1[1], N_side + 1)]).T\n    \n    # Concatenate edges, removing duplicate corners to form a closed loop.\n    return np.concatenate((bottom_edge[:-1], right_edge[:-1], top_edge[:-1], left_edge))\n\n# --- Vectorized Force Field Functions ---\n# Each function accepts an (M, 2) array of positions and returns an (M, 2) array of forces.\n\ndef force_harmonic_conservative(R, kx, ky):\n    return np.array([-kx * R[:, 0], -ky * R[:, 1]]).T\n\ndef force_harmonic_swirl(R, kx, ky, gamma):\n    x, y = R[:, 0], R[:, 1]\n    fx = -kx * x - gamma * y\n    fy = -ky * y + gamma * x\n    return np.stack([fx, fy], axis=1)\n\ndef force_harmonic_noise(R, kx, ky, sigma):\n    M = R.shape[0]\n    base_force = np.array([-kx * R[:, 0], -ky * R[:, 1]]).T\n    noise = RNG.normal(0.0, sigma, size=(M, 2))\n    return base_force + noise\n\ndef force_pure_swirl(R, gamma):\n    x, y = R[:, 0], R[:, 1]\n    return np.stack([-gamma * y, gamma * x], axis=1)\n\ndef force_zero(R):\n    return np.zeros_like(R)\n\n# --- Main Diagnostic Calculation ---\ndef calculate_diagnostic(polyline, area, force_func, tolerance):\n    \"\"\"\n    Calculates the diagnostic omega and compares its magnitude to a tolerance.\n    \"\"\"\n    # Midpoints of the polyline segments\n    midpoints = (polyline[:-1] + polyline[1:]) / 2.0\n    # Displacement vectors for each segment\n    displacements = polyline[1:] - polyline[:-1]\n    \n    # Evaluate forces at all midpoints in a vectorized manner\n    forces = force_func(midpoints)\n    \n    # Calculate circulation using the composite midpoint rule.\n    # The sum of element-wise products is equivalent to the sum of dot products.\n    circulation = np.sum(forces * displacements)\n    \n    # Calculate the diagnostic omega, avoiding division by zero.\n    if area == 0.0:\n        omega = 0.0 if circulation == 0.0 else np.inf\n    else:\n        omega = circulation / area\n        \n    return abs(omega) > tolerance\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Conservative harmonic field on a circle. Expect near-zero circulation.\n        {'loop_type': 'circle', 'loop_params': {'r': 1.0, 'N': 1024},\n         'force_type': 'harmonic', 'force_params': {'kx': 3.0, 'ky': 5.0},\n         'tolerance': 1.0e-8},\n        # Case 2: Non-conservative swirl field on a circle. Expect non-zero circulation.\n        {'loop_type': 'circle', 'loop_params': {'r': 1.0, 'N': 1024},\n         'force_type': 'harmonic_swirl', 'force_params': {'kx': 3.0, 'ky': 5.0, 'gamma': 0.05},\n         'tolerance': 1.0e-3},\n        # Case 3: Conservative field with noise. Circulation expected to be small.\n        {'loop_type': 'circle', 'loop_params': {'r': 1.0, 'N': 2048},\n         'force_type': 'harmonic_noise', 'force_params': {'kx': 3.0, 'ky': 5.0, 'sigma': 1.0e-3},\n         'tolerance': 1.0e-2},\n        # Case 4: Zero field on a rectangle. Circulation must be zero.\n        {'loop_type': 'rectangle', 'loop_params': {'w': 2.0, 'h': 1.0, 'N_side': 200},\n         'force_type': 'zero', 'force_params': {},\n         'tolerance': 1.0e-12},\n        # Case 5: Pure swirl field on a rectangle. Expect non-zero circulation.\n        {'loop_type': 'rectangle', 'loop_params': {'w': 1.0, 'h': 1.0, 'N_side': 16},\n         'force_type': 'pure_swirl', 'force_params': {'gamma': 0.02},\n         'tolerance': 5.0e-3},\n    ]\n\n    results = []\n    \n    force_map = {\n        'harmonic': force_harmonic_conservative,\n        'harmonic_swirl': force_harmonic_swirl,\n        'harmonic_noise': force_harmonic_noise,\n        'pure_swirl': force_pure_swirl,\n        'zero': force_zero\n    }\n\n    for case in test_cases:\n        # Generate polyline and determine loop area\n        if case['loop_type'] == 'circle':\n            r = case['loop_params']['r']\n            N = case['loop_params']['N']\n            polyline = generate_circle_polyline(r, N)\n            area = np.pi * r**2\n        elif case['loop_type'] == 'rectangle':\n            w = case['loop_params']['w']\n            h = case['loop_params']['h']\n            N_side = case['loop_params']['N_side']\n            polyline = generate_rectangle_polyline(w, h, N_side)\n            area = w * h\n        \n        # Create the specific force function with its parameters\n        force_func_base = force_map[case['force_type']]\n        force_params = case['force_params']\n        force_func = lambda R: force_func_base(R, **force_params)\n\n        # Run the diagnostic test and store the boolean result\n        result = calculate_diagnostic(polyline, area, force_func, case['tolerance'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2760109"}]}