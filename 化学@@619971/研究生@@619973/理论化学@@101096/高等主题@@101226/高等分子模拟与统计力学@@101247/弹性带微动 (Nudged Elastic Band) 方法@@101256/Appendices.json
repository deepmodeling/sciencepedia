{"hands_on_practices": [{"introduction": "一个高质量的初始路径是成功进行微动弹性带（NEB）计算的基石。一个常见的方法，即在笛卡尔坐标中进行线性插值，虽然简单，但可能导致不符合物理实际的构型，例如产生过度拉伸的化学键。本练习将引导你通过解析推导来量化这种畸变，帮助你建立直觉，判断何时需要采用更复杂的插值方法（如内坐标插值），这是设置可靠模拟的一项关键实践技能。[@problem_id:2818647]", "problem": "在用于识别化学反应中最低能量路径的微动弹性带 (NEB) 方法中，反应物和产物构型之间的初始路径通常是通过在笛卡尔坐标中进行线性插值来生成的。考虑一个三原子分子，其原子标记为 $A$–$B$–$C$。其中中心原子 $B$ 固定在原点，原子 $A$ 固定在 $\\left(-r,\\,0,\\,0\\right)$，原子 $C$ 在 $x$–$y$ 平面内移动，在初始和最终构型之间保持固定的键长 $|BC|=r$。不失一般性地，设 $C$ 的初始位置为 $\\mathbf{R}_{C}^{(0)}=\\left(r,\\,0,\\,0\\right)$，最终位置为 $\\mathbf{R}_{C}^{(1)}=\\left(r\\cos\\Delta\\theta,\\,r\\sin\\Delta\\theta,\\,0\\right)$，其中 $\\Delta\\theta$ 是 $B$ 处弯曲角的变化量。\n\n$C$ 的笛卡尔线性插值对于 $t\\in[0,\\,1]$ 定义为\n$$\n\\mathbf{R}_{C}(t)\\;=\\;(1-t)\\,\\mathbf{R}_{C}^{(0)}\\;+\\;t\\,\\mathbf{R}_{C}^{(1)}.\n$$\n该插值描绘了以 $B$ 为中心、半径为 $r$ 的圆上两个端点之间的直线弦，并且通常会扭曲瞬时键长 $|BC(t)|=|\\mathbf{R}_{C}(t)|$。相比之下，仅改变弯曲角而保持 $|BC|=r$ 固定的内坐标插值将使 $BC$ 键长在整个路径上（沿着圆弧）保持恒定。\n\n仅从向量范数和基本三角恒等式出发，推导出沿笛卡尔线性插值的 $BC$ 键长的最大相对偏差（作为 $\\Delta\\theta$ 的函数），并由此得出一个标准：如果在插值过程中对允许的最大相对键长偏差施加一个硬性容差 $\\varepsilon$，何时内坐标插值是更可取的。\n\n最后，对于容差 $\\varepsilon=0.02$（表示为小数），计算临界角变化 $\\Delta\\theta_{c}$，使得当 $\\Delta\\theta>\\Delta\\theta_{c}$ 时，根据此标准，内坐标插值是更可取的。将 $\\Delta\\theta_{c}$ 用弧度表示，并将您的答案四舍五入到四位有效数字。", "solution": "题目所述问题在科学上是合理的，提法明确，并且包含了得到唯一解所需的所有信息。我们开始推导。\n\n原子 $C$ 的初始和最终位置分别为 $\\mathbf{R}_{C}^{(0)} = (r, 0, 0)$ 和 $\\mathbf{R}_{C}^{(1)} = (r\\cos\\Delta\\theta, r\\sin\\Delta\\theta, 0)$。原子 $B$ 位于原点。因此，键矢量 $\\mathbf{R}_{BC}$ 与原子 $C$ 的位置矢量 $\\mathbf{R}_{C}$ 相同。端点处的键长为 $|\\mathbf{R}_{C}^{(0)}| = r$ 和 $|\\mathbf{R}_{C}^{(1)}| = r$。\n\n沿线性插值路径的原子 $C$ 的位置矢量由 $\\mathbf{R}_{C}(t)$ 给出，其中 $t \\in [0, 1]$：\n$$\n\\mathbf{R}_{C}(t) = (1-t)\\mathbf{R}_{C}^{(0)} + t\\mathbf{R}_{C}^{(1)}\n$$\n代入坐标矢量：\n$$\n\\mathbf{R}_{C}(t) = (1-t)(r, 0, 0) + t(r\\cos\\Delta\\theta, r\\sin\\Delta\\theta, 0)\n$$\n$$\n\\mathbf{R}_{C}(t) = ((1-t)r + tr\\cos\\Delta\\theta, tr\\sin\\Delta\\theta, 0)\n$$\n$$\n\\mathbf{R}_{C}(t) = (r(1-t+t\\cos\\Delta\\theta), tr\\sin\\Delta\\theta, 0)\n$$\n$BC$ 的瞬时键长是该矢量的大小，我们将其表示为 $|BC(t)|_L$，其中下标 $L$ 表示线性插值。我们计算其平方：\n$$\n|BC(t)|_L^2 = |\\mathbf{R}_{C}(t)|^2 = [r(1-t+t\\cos\\Delta\\theta)]^2 + [tr\\sin\\Delta\\theta]^2\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t+t\\cos\\Delta\\theta)^2 + t^2\\sin^2\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t)^2 + 2t(1-t)\\cos\\Delta\\theta + t^2\\cos^2\\Delta\\theta + t^2\\sin^2\\Delta\\theta \\right)\n$$\n使用基本三角恒等式 $\\cos^2\\Delta\\theta + \\sin^2\\Delta\\theta = 1$：\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t)^2 + 2t(1-t)\\cos\\Delta\\theta + t^2 \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t + t^2 + 2t\\cos\\Delta\\theta - 2t^2\\cos\\Delta\\theta + t^2 \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t + 2t^2 + (2t - 2t^2)\\cos\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t(1-t) + 2t(1-t)\\cos\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t(1-t)(1-\\cos\\Delta\\theta) \\right)\n$$\n我们应用半角恒等式 $1-\\cos\\Delta\\theta = 2\\sin^2(\\frac{\\Delta\\theta}{2})$：\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right)\n$$\n因此，瞬时键长为：\n$$\n|BC(t)|_L = r \\sqrt{1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right)}\n$$\n键长与其标称值 $r$ 的相对偏差为：\n$$\nD(t) = \\frac{r - |BC(t)|_L}{r} = 1 - \\frac{|BC(t)|_L}{r} = 1 - \\sqrt{1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right)}\n$$\n为了找到最大相对偏差 $D_{max}$，我们必须找到 $D(t)$ 在 $t \\in [0, 1]$ 上的最大值。这等价于找到 $|BC(t)|_L$ 的最小值，而这又等价于最大化在平方根下被减去的正项 $4t(1-t)\\sin^2(\\frac{\\Delta\\theta}{2})$。由于对于给定路径 $\\Delta\\theta$ 是常数，我们只需要在区间 $t \\in [0, 1]$ 上最大化函数 $f(t) = t(1-t) = t - t^2$。\n通过将其导数设为零来找到 $f(t)$ 的最大值：\n$$\n\\frac{df}{dt} = 1 - 2t = 0 \\implies t = \\frac{1}{2}\n$$\n该点代表一个最大值，因为二阶导数 $\\frac{d^2f}{dt^2} = -2 < 0$。最大值为 $f(\\frac{1}{2}) = \\frac{1}{2}(1-\\frac{1}{2}) = \\frac{1}{4}$。这发生在弦的中点。\n\n最小键长 $|BC|_{min}$ 出现在 $t=\\frac{1}{2}$ 处：\n$$\n|BC|_{min}^2 = r^2 \\left( 1 - 4\\left(\\frac{1}{4}\\right)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right) = r^2 \\left( 1 - \\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right) = r^2 \\cos^2\\left(\\frac{\\Delta\\theta}{2}\\right)\n$$\n假设 $\\Delta\\theta \\in [0, \\pi]$，则 $\\cos(\\frac{\\Delta\\theta}{2}) \\ge 0$, 所以 $|BC|_{min} = r\\cos(\\frac{\\Delta\\theta}{2})$。\n\n那么，最大相对偏差 $D_{max}$ 为：\n$$\nD_{max} = 1 - \\frac{|BC|_{min}}{r} = 1 - \\frac{r\\cos(\\frac{\\Delta\\theta}{2})}{r} = 1 - \\cos\\left(\\frac{\\Delta\\theta}{2}\\right)\n$$\n这就是所要求的最大相对偏差作为 $\\Delta\\theta$ 函数的表达式。\n\n优先选择内坐标插值的标准是，该最大偏差超过了给定的容差 $\\varepsilon$。内坐标插值能完美地保持键长，因此其偏差为 $0$。因此，当以下条件成立时，笛卡尔插值是不可接受的：\n$$\nD_{max} > \\varepsilon\n$$\n$$\n1 - \\cos\\left(\\frac{\\Delta\\theta}{2}\\right) > \\varepsilon\n$$\n这就是该标准。\n\n最后，我们计算临界角变化 $\\Delta\\theta_c$，在该角度下最大偏差等于容差 $\\varepsilon=0.02$。\n$$\n1 - \\cos\\left(\\frac{\\Delta\\theta_c}{2}\\right) = \\varepsilon\n$$\n$$\n\\cos\\left(\\frac{\\Delta\\theta_c}{2}\\right) = 1 - \\varepsilon\n$$\n$$\n\\frac{\\Delta\\theta_c}{2} = \\arccos(1 - \\varepsilon)\n$$\n$$\n\\Delta\\theta_c = 2 \\arccos(1 - \\varepsilon)\n$$\n代入指定的容差 $\\varepsilon = 0.02$：\n$$\n\\Delta\\theta_c = 2 \\arccos(1 - 0.02) = 2 \\arccos(0.98)\n$$\n使用计算器并调至弧度模式：\n$$\n\\arccos(0.98) \\approx 0.20033400 \\, \\text{rad}\n$$\n$$\n\\Delta\\theta_c \\approx 2 \\times 0.20033400 = 0.40066800 \\, \\text{rad}\n$$\n四舍五入到四位有效数字，临界角为 $0.4007$ 弧度。对于任何角度变化 $\\Delta\\theta > \\Delta\\theta_c$，简单线性路径的键长扭曲将超过 $2\\%$ 的容差，这使得基于内坐标的路径更为可取。", "answer": "$$\\boxed{0.4007}$$", "id": "2818647"}, {"introduction": "设定好初始路径后，NEB 方法将对其进行优化。该方法的精髓在于其独特的力分解方案，它能防止路径上的“珠子”（即图像）滑落到能量最低点，同时确保它们沿着路径均匀分布。本练习是一个核心的编程实践，你将亲手计算 NEB 力的两个关键分量：沿路径切线方向的弹簧力和垂直于路径切线方向的势能力。通过实现一个优化步骤，你将对 NEB 如何引导路径走向最小能量路径获得深刻的实践理解。[@problem_id:2818674]", "problem": "在一个标量势能面上，连接两个局域极小值点的离散化路径由 $\\mathbb{R}^d$ 空间中 $M+1$ 个构型向量的有限序列 $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ 表示，其中 $\\mathbf{R}_0$ 和 $\\mathbf{R}_M$ 是固定端点。考虑用于近似最小能量路径的微动弹性带（Nudged Elastic Band, NEB）方法。NEB 框架将相邻构象视作由谐振子弹簧连接，并通过一个弹簧力（约束在局域切线方向上）和一个势能力（移除了其切向分量）的组合来推动内部构象的演化。本问题中所有量均为无量纲。所有角度（如适用）均以弧度为单位。\n\n从以下基本陈述出发：\n- 势能是一个标量场 $V(\\mathbf{R})$，由该势产生的物理力为 $-\\nabla V(\\mathbf{R})$。\n- 相邻构象之间的弹簧相互作用是谐性的，具有一个恒定的弹簧系数 $k>0$。\n- 内部构象处的局域路径切线是位置的离散中心差分的方向。\n- NEB 方案仅组合平行于局域切线的弹簧力分量和垂直于该切线的势能力分量。\n\n基于这些基本陈述，推导出以下各项的显式表达式：\n- 仅使用 $\\mathbf{R}_{i-1},\\mathbf{R}_{i},\\mathbf{R}_{i+1}$ 表示每个内部构象 $i\\in\\{1,\\dots,M-1\\}$ 处的单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$。\n- 作用在每个内部构象 $i$ 上且被约束在切线方向上的弹簧力。\n- 作用在每个内部构象 $i$ 上且被约束在垂直于切线的子空间中的势能力。\n\n然后，设计一个算法，给定一条初始路径，对内部构象执行一个显式最速下降步骤：\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\alpha\\, \\mathbf{F}_i,\n$$\n其中 $\\alpha>0$ 是步长，$\\mathbf{F}_i$ 是根据上述原理组合而成的 NEB 力。端点 $i=0$ 和 $i=M$ 不被更新。令构象间距离为 $d_i=\\left\\|\\mathbf{R}_{i+1}-\\mathbf{R}_i\\right\\|$，对于 $i\\in\\{0,\\dots,M-1\\}$。对于每一步，通过变异系数 $c_v = \\sigma_d/\\mu_d$ 来量化间距的均匀性，其中 $\\sigma_d$ 和 $\\mu_d$ 分别是 $\\{d_i\\}_{i=0}^{M-1}$ 的标准差和均值。令 $r$ 为比率 $r=c_v^{\\text{after}}/c_v^{\\text{before}}$。此外，计算内部构象上切向弹簧力的平均大小 $\\bar{s}$。\n\n实现一个程序，该程序针对下面指定的每个测试用例，计算一个 NEB 更新步骤，并以浮点数形式返回数对 $[r,\\bar{s}]$，四舍五入到六位小数。\n\n使用以下测试套件（所有量均为无量纲）：\n\n- 测试用例 A（理想情况；在对称双势阱上设置不均匀的初始间距）：\n  - 势能 $V_1(x,y) = (x^2-1)^2 + 0.1\\,y^2$。\n  - 梯度 $\\nabla V_1(x,y)$ 必须由您自己推导。\n  - 维度 $d=2$。\n  - 构象数量 $M+1=7$，端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_6=(1,0)$。\n  - 初始内部构象：$\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.7,0)$, $\\mathbf{R}_3 = (-0.2,0)$, $\\mathbf{R}_4 = (0.3,0)$, $\\mathbf{R}_5 = (0.8,0)$。\n  - 弹簧系数 $k=1.0$。\n  - 步长 $\\alpha=0.05$。\n\n- 测试用例 B（边界条件；在相同势能上已为等间距）：\n  - 势能 $V_1(x,y)$ 同上。\n  - 维度 $d=2$。\n  - 构象数量 $M+1=7$，端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_6=(1,0)$。\n  - 初始内部构象沿直线段等距分布：$\\mathbf{R}_i = (-1 + i\\cdot \\Delta,0)$，对于 $i\\in\\{1,\\dots,5\\}$，其中 $\\Delta = \\frac{2}{6}$。\n  - 弹簧系数 $k=1.0$。\n  - 步长 $\\alpha=0.05$。\n\n- 测试用例 C（弯曲谷底；不均匀间距和不可忽略的垂直力）：\n  - 势能 $V_2(x,y) = \\big(y-\\sin(\\pi x)\\big)^2 + 0.01\\,x^2$。角度使用弧度单位。\n  - 梯度 $\\nabla V_2(x,y)$ 必须由您自己推导。\n  - 维度 $d=2$。\n  - 构象数量 $M+1=7$，端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_6=(1,0)$。\n  - 初始内部构象：$\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.6,0)$, $\\mathbf{R}_3 = (-0.1,0)$, $\\mathbf{R}_4 = (0.4,0)$, $\\mathbf{R}_5 = (0.9,0)$。\n  - 弹簧系数 $k=1.0$。\n  - 步长 $\\alpha=0.05$。\n\n您的程序应为每个测试用例计算如上定义的数对 $[r,\\bar{s}]$。如果 $c_v^{\\text{before}}=0$，则按照约定定义 $r=1$。您的程序应生成单行输出，其中包含这些数对的逗号分隔列表，并用方括号括起来，例如：\n$[\\,[r_A,\\bar{s}_A],[r_B,\\bar{s}_B],[r_C,\\bar{s}_C]\\,]$,\n每个浮点数四舍五入到六位小数。不应产生任何其他输出。", "solution": "问题陈述是有效的。它提出了一个计算化学领域中具有科学依据的、适定的问题，具体涉及微动弹性带（NEB）方法。给定的定义和约束对于推导必要的公式和实现算法是充分且一致的。\n\n任务要求基于问题中提供的第一性原理，推导出 NEB 方法中使用的力，然后设计并实现一个算法来执行单个优化步骤。该问题是理解和应用 NEB 方法的一个标准练习。\n\n推导过程如下。该系统包含一条由 $M+1$ 个构象离散化而成的路径，由 $d$ 维空间 $\\mathbb{R}^d$ 中的位置向量 $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ 表示。端点 $\\mathbf{R}_0$ 和 $\\mathbf{R}_M$ 是固定的。内部构象 $i \\in \\{1, \\dots, M-1\\}$ 需要被更新。\n\n首先，我们推导内部构象 $i$ 处的单位切向量表达式。问题陈述中说明这是“位置的离散中心差分的方向”。这是连接相邻构象 $\\mathbf{R}_{i-1}$ 和 $\\mathbf{R}_{i+1}$ 的向量。\n因此，切向量 $\\boldsymbol{\\tau}_i$ 为：\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\n$$\n相应的单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$ 通过将此向量归一化得到：\n$$\n\\hat{\\boldsymbol{\\tau}}_i = \\frac{\\boldsymbol{\\tau}_i}{\\|\\boldsymbol{\\tau}_i\\|} = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n$$\n只要 $\\mathbf{R}_{i+1} \\neq \\mathbf{R}_{i-1}$，该定义就有效，否则范数将为零。对于给定的测试用例，此条件成立。\n\n其次，我们推导弹簧力。问题陈述中说明“相邻构象视作由谐振子弹簧连接，具有一个恒定的弹簧系数 $k>0$”。整条带的总弹性势能 $S$ 是每个分段谐振子势能之和：\n$$\nS(\\{\\mathbf{R}_i\\}) = \\sum_{j=0}^{M-1} \\frac{1}{2} k \\left\\| \\mathbf{R}_{j+1} - \\mathbf{R}_j \\right\\|^2\n$$\n作用在特定构象 $i$ 上的力是该总势能对其位置 $\\mathbf{R}_i$ 的负梯度。总和中只有两项依赖于 $\\mathbf{R}_i$：$j=i-1$ 和 $j=i$ 的项。\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\nabla_{\\mathbf{R}_i} S = - \\frac{\\partial}{\\partial \\mathbf{R}_i} \\left[ \\frac{1}{2} k \\left\\| \\mathbf{R}_i - \\mathbf{R}_{i-1} \\right\\|^2 + \\frac{1}{2} k \\left\\| \\mathbf{R}_{i+1} - \\mathbf{R}_i \\right\\|^2 \\right]\n$$\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\left[ k (\\mathbf{R}_i - \\mathbf{R}_{i-1}) + k (\\mathbf{R}_i - \\mathbf{R}_{i+1}) \\right] = k(\\mathbf{R}_{i-1} - \\mathbf{R}_i) + k(\\mathbf{R}_{i+1} - \\mathbf{R}_i) = k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right)\n$$\n问题规定，对于 NEB 力，我们必须使用“仅平行于局域切线的弹簧力分量”。这是 $\\mathbf{F}_{i, \\text{spring}}^{\\text{total}}$ 在单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$ 上的投影。\n$$\n\\mathbf{F}_{i, s}^{\\parallel} = \\left( \\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = \\left[ k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right] \\hat{\\boldsymbol{\\tau}}_i\n$$\n这就是所要求的切向弹簧力表达式。\n\n第三，我们推导垂直于切线的势能力分量。由势能面 $V(\\mathbf{R})$ 作用在构象 $i$ 上的力是 $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$。问题陈述我们使用“仅垂直于该切线的势能力分量”。$\\mathbf{F}_{i, \\text{pot}}$ 垂直于 $\\hat{\\boldsymbol{\\tau}}_i$ 的分量可以通过减去其平行分量得到：\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = \\mathbf{F}_{i, \\text{pot}} - \\left( \\mathbf{F}_{i, \\text{pot}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\n代入 $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$：\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = -\\nabla V(\\mathbf{R}_i) - \\left( (-\\nabla V(\\mathbf{R}_i)) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = -\\nabla V(\\mathbf{R}_i) + \\left( \\nabla V(\\mathbf{R}_i) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\n该力分量将路径推向最小能量路径，而不会导致构象沿路径滑动。\n\n作用在内部构象 $i$ 上的总 NEB 力 $\\mathbf{F}_i$ 是这两个分量之和：\n$$\n\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}\n$$\n\n必须计算指定势能 $V_1(x,y) = (x^2-1)^2 + 0.1 y^2$ 和 $V_2(x,y) = (y-\\sin(\\pi x))^2 + 0.01 x^2$ 的梯度。对于 $\\mathbf{R}=(x,y)$：\n- 对于 $V_1$：$\\nabla V_1(x,y) = \\left( \\frac{\\partial V_1}{\\partial x}, \\frac{\\partial V_1}{\\partial y} \\right) = (4x(x^2-1), 0.2y)$。\n- 对于 $V_2$：$\\nabla V_2(x,y) = \\left( \\frac{\\partial V_2}{\\partial x}, \\frac{\\partial V_2}{\\partial y} \\right) = (0.02x - 2\\pi(y-\\sin(\\pi x))\\cos(\\pi x), 2(y-\\sin(\\pi x)))$。\n\n单个更新步骤的算法如下：\n1.  给定初始路径 $\\{\\mathbf{R}_i\\}_{i=0}^{M}$、参数 $k$ 和步长 $\\alpha$。\n2.  计算初始构象间距离集合 $\\{d_i\\}_{i=0}^{M-1}$，其中 $d_i = \\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\|$。计算它们的均值 $\\mu_d^{\\text{before}}$ 和标准差 $\\sigma_d^{\\text{before}}$。计算 $c_v^{\\text{before}} = \\sigma_d^{\\text{before}} / \\mu_d^{\\text{before}}$，并通过设置 $c_v^{\\text{before}}=0$ 来处理 $\\mu_d^{\\text{before}}=0$ 的情况。\n3.  初始化一个新的路径数组 $\\{\\mathbf{R}'_i\\}$ 并复制固定端点：$\\mathbf{R}'_0 = \\mathbf{R}_0$ 和 $\\mathbf{R}'_M = \\mathbf{R}_M$。初始化一个列表以存储弹簧力的大小。\n4.  对于从 $1$ 到 $M-1$ 的每个内部构象 $i$：\n    a. 使用原始路径位置 $\\mathbf{R}_{i-1}$ 和 $\\mathbf{R}_{i+1}$ 计算单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$。\n    b. 计算切向弹簧力 $\\mathbf{F}_{i, s}^{\\parallel}$ 并存储其大小 $\\|\\mathbf{F}_{i, s}^{\\parallel}\\| = |\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i|$。\n    c. 计算势能梯度 $\\nabla V(\\mathbf{R}_i)$ 和垂直势能力 $\\mathbf{F}_{i, \\text{pot}}^{\\perp}$。\n    d. 将各力相加得到总 NEB 力 $\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}$。\n    e. 计算更新后的位置：$\\mathbf{R}'_i = \\mathbf{R}_i + \\alpha \\mathbf{F}_i$。\n5.  更新所有内部构象后，从新路径 $\\{\\mathbf{R}'_i\\}$ 计算新的距离集合 $\\{d'_i\\}_{i=0}^{M-1}$。计算它们的均值 $\\mu_d^{\\text{after}}$ 和标准差 $\\sigma_d^{\\text{after}}$，并求出 $c_v^{\\text{after}} = \\sigma_d^{\\text{after}} / \\mu_d^{\\text{after}}$。\n6.  计算比率 $r = c_v^{\\text{after}} / c_v^{\\text{before}}$。如果 $c_v^{\\text{before}}=0$，则根据问题规定设置 $r=1$。\n7.  通过对步骤 4b 中存储的值求平均，计算切向弹簧力的平均大小 $\\bar{s}$。\n8.  返回数对 $[r, \\bar{s}]$。\n\n对每个提供的测试用例实现此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases for the NEB problem.\n    \"\"\"\n\n    def grad_V1(R):\n        \"\"\"Gradient of V1(x,y) = (x^2-1)^2 + 0.1*y^2\"\"\"\n        x, y = R\n        dx = 4 * x * (x**2 - 1)\n        dy = 0.2 * y\n        return np.array([dx, dy])\n\n    def grad_V2(R):\n        \"\"\"Gradient of V2(x,y) = (y-sin(pi*x))^2 + 0.01*x^2\"\"\"\n        x, y = R\n        sin_pix = np.sin(np.pi * x)\n        cos_pix = np.cos(np.pi * x)\n        term1 = y - sin_pix\n        dx = 0.02 * x - 2 * np.pi * term1 * cos_pix\n        dy = 2 * term1\n        return np.array([dx, dy])\n\n    def get_cv(path):\n        \"\"\"Calculate the coefficient of variation of inter-image distances.\"\"\"\n        distances = [np.linalg.norm(path[i+1] - path[i]) for i in range(len(path) - 1)]\n        mean_dist = np.mean(distances)\n        if mean_dist == 0:\n            return 0.0\n        std_dist = np.std(distances)\n        return std_dist / mean_dist\n\n    def process_case(initial_path_internal, R0, RM, grad_V, k, alpha):\n        \"\"\"\n        Processes one test case of the NEB calculation.\n        Performs one update step and computes the required metrics [r, s_bar].\n        \"\"\"\n        # Construct full initial path\n        path = [R0] + initial_path_internal + [RM]\n        path = [np.array(p) for p in path]\n        M = len(path) - 1\n        num_internal_images = M - 1\n\n        # --- Before the update step ---\n        cv_before = get_cv(path)\n\n        # --- Perform one NEB update step ---\n        new_path = [p.copy() for p in path]\n        tangential_spring_force_mags = []\n\n        for i in range(1, M):\n            # Current, previous, and next image positions\n            R_i = path[i]\n            R_prev = path[i-1]\n            R_next = path[i+1]\n\n            # 1. Calculate tangent\n            tau_vec = R_next - R_prev\n            norm_tau = np.linalg.norm(tau_vec)\n            if norm_tau == 0:\n                tau_hat = np.zeros_like(tau_vec)\n            else:\n                tau_hat = tau_vec / norm_tau\n\n            # 2. Calculate tangential spring force F_s_parallel\n            F_spring_total = k * (R_prev + R_next - 2 * R_i)\n            F_s_parallel_scalar = np.dot(F_spring_total, tau_hat)\n            F_s_parallel = F_s_parallel_scalar * tau_hat\n            tangential_spring_force_mags.append(np.abs(F_s_parallel_scalar))\n\n            # 3. Calculate perpendicular potential force F_pot_perp\n            grad_Vi = grad_V(R_i)\n            F_pot_total = -grad_Vi\n            F_pot_perp = F_pot_total - np.dot(F_pot_total, tau_hat) * tau_hat\n\n            # 4. Total NEB force and update position\n            F_i = F_s_parallel + F_pot_perp\n            new_path[i] = R_i + alpha * F_i\n        \n        # --- After the update step ---\n        cv_after = get_cv(new_path)\n\n        # --- Calculate final metrics ---\n        if cv_before == 0.0:\n            r = 1.0\n        else:\n            r = cv_after / cv_before\n\n        s_bar = np.mean(tangential_spring_force_mags) if tangential_spring_force_mags else 0.0\n\n        return [round(r, 6), round(s_bar, 6)]\n\n    # Test Case A\n    R0_A = [-1.0, 0.0]\n    RM_A = [1.0, 0.0]\n    path_internal_A = [\n        [-0.9, 0.0], [-0.7, 0.0], [-0.2, 0.0], [0.3, 0.0], [0.8, 0.0]\n    ]\n    k_A = 1.0\n    alpha_A = 0.05\n    \n    # Test Case B\n    R0_B = [-1.0, 0.0]\n    RM_B = [1.0, 0.0]\n    delta_B = 2.0 / 6.0\n    path_internal_B = [\n        [-1 + i * delta_B, 0.0] for i in range(1, 6)\n    ]\n    k_B = 1.0\n    alpha_B = 0.05\n    \n    # Test Case C\n    R0_C = [-1.0, 0.0]\n    RM_C = [1.0, 0.0]\n    path_internal_C = [\n        [-0.9, 0.0], [-0.6, 0.0], [-0.1, 0.0], [0.4, 0.0], [0.9, 0.0]\n    ]\n    k_C = 1.0\n    alpha_C = 0.05\n\n    test_cases = [\n        (path_internal_A, R0_A, RM_A, grad_V1, k_A, alpha_A),\n        (path_internal_B, R0_B, RM_B, grad_V1, k_B, alpha_B),\n        (path_internal_C, R0_C, RM_C, grad_V2, k_C, alpha_C)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = process_case(*params)\n        results.append(result)\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{r},{s}]\" for r, s in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2818674"}, {"introduction": "NEB 计算的最终目标通常是精确定位过渡态。我们通常假设离散路径上能量最高的图像就是过渡态，但本练习将揭示这只是一个近似。其准确性对路径的离散化程度非常敏感。通过一个简化的模型，你将探索不均匀的图像间距如何对过渡态的能量和位置估计引入显著的偏差，并学习如何通过在关键区域插入更多图像来系统地提高结果的准确性。这项练习将培养你评估和改进 NEB 计算结果质量的关键能力。[@problem_id:2818689]", "problem": "设计并实现一个程序，用于定量分析微动弹性带（Nudged Elastic Band, NEB）方法中因一维最小能量路径上构象（image）间距不均而产生的离散化偏差。该分析必须从一个明确定义的势能面出发，并依据微积分的第一性原理进行。\n\n考虑由下式给出的一维势能函数\n$$\nV(x) = \\frac{1}{4}\\left(x^2 - 1\\right)^2,\n$$\n该势能在 $x=-1$ 和 $x=1$ 处有极小值点，并在原点处有一个唯一的过渡态（鞍点）。连接这两个极小值点的最小能量路径是构型空间中由 $x$ 本身参数化的直线。对于此路径，真实的能垒位置和能量位于 $x^\\ddagger = 0$，其值为 $V^\\ddagger = V(0)$。\n\n在NEB的描述中，一条路径被离散为一系列连接端点 $x_0=-1$ 和 $x_{N-1}=1$ 的构象（点）$x_0, x_1, \\dots, x_{N-1}$。能量最高的构象 $x_k$ 被用作鞍点位置和能垒能量的估计量。当构象间距不均匀时，$x_k$ 可能会偏离 $x^\\ddagger$，从而导致能垒能量的估计出现偏差。在鞍点附近，一个平滑的势可以进行泰勒展开\n$$\nV(x) \\approx V^\\ddagger - \\frac{|\\kappa|}{2}\\,\\delta^2 + \\mathcal{O}(\\delta^4),\n$$\n其中 $\\delta = x - x^\\ddagger$，$|\\kappa|$ 是鞍点处负曲率的绝对值。因此，离散最大值点处的绝对能量偏差与最邻近构象到鞍点的距离的平方成正比。通过在当前最大值点附近插入额外的构象，可以减小 $\\delta$，从而减小能量偏差。\n\n您的任务是：\n- 使用由下式定义的单调映射 $s \\mapsto x$ 生成路径上包含 $N$ 个构象（含端点）的初始集合：\n$$\nx_i = -1 + 2\\, s_i^p,\\quad s_i = \\frac{i}{N-1},\\quad i\\in\\{0,1,\\dots,N-1\\},\n$$\n其中指数 $p \\geq 1$ 控制间距不均匀的程度。选择 $p=1$ 会产生均匀的间距，而 $p>1$ 则使构象向左侧极小值点聚集。此参数化纯粹是一种数学手段，用于模拟 NEB 中不均匀切向弹簧分布的影响，而无需显式地引入弹簧力。\n- 对于每个构象集，计算能量最高构象的索引 $k$、对应的坐标 $x_k$ 及其能量 $V(x_k)$。使用 $x^\\ddagger=0$ 和 $V^\\ddagger=V(0)$ 作为精确的鞍点位置和能垒能量，计算绝对能量误差\n$$\n\\Delta E_{\\text{before}} = \\left|V(x_k) - V^\\ddagger\\right|\n$$\n和位置误差\n$$\n\\Delta x_{\\text{before}} = \\left|x_k - x^\\ddagger\\right|.\n$$\n- 模拟在离散最大值点附近进行定向的 NEB 构象插入：在 $x_k$ 的紧邻区域插入 $m$ 个新构象。具体方法为，将两个相邻区间 $\\left[x_{k-1},x_k\\right]$ 和 $\\left[x_k,x_{k+1}\\right]$ 各自划分为相等的子区间，并插入等距的内部点，总共添加 $m$ 个新构象，其中 $\\lceil m/2 \\rceil$ 个位于左侧区间，$m - \\lceil m/2 \\rceil$ 个位于右侧区间。保持端点固定在 $x=-1$ 和 $x=1$。插入后重新计算能量最高的构象，以获得类似定义的 $\\Delta E_{\\text{after}}$ 和 $\\Delta x_{\\text{after}}$。\n- 对于每个测试用例，输出由浮点数组成的四元组 $[\\Delta E_{\\text{before}}, \\Delta E_{\\text{after}}, \\Delta x_{\\text{before}}, \\Delta x_{\\text{after}}]$，四舍五入到 $10$ 位小数，以此报告插入的定量效果。\n\n测试套件：\n- 情况 A（间距不均，中等分辨率）：$N=9$, $p=3$, $m=2$。\n- 情况 B（间距均匀，高分辨率）：$N=33$, $p=1$, $m=2$。\n- 情况 C（间距高度不均，非常粗糙）：$N=5$, $p=5$, $m=2$。\n- 情况 D（间距均匀且有一个构象恰好在鞍点处）：$N=11$, $p=1$, $m=2$。\n\n科学真实性要求：\n- 所有计算都应在所提供的精确解析函数 $V(x)$ 上执行。将能量和位置视为无量纲。\n- 本问题不使用角度。\n- 插入算法规则必须尊重邻接关系：构象只能在 $\\left[x_{k-1},x_k\\right]$ 和 $\\left[x_k,x_{k+1}\\right]$ 内插入。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试结果，形式为一个包含在方括号中的逗号分隔列表。按顺序连接情况 A、情况 B、情况 C 和情况 D 的四个舍入后的数字。也就是说，输出是一个包含 $16$ 个浮点数的扁平列表：\n$[\\Delta E_{\\text{before}}^{(A)},\\Delta E_{\\text{after}}^{(A)},\\Delta x_{\\text{before}}^{(A)},\\Delta x_{\\text{after}}^{(A)},\\dots,\\Delta E_{\\text{before}}^{(D)},\\Delta E_{\\text{after}}^{(D)},\\Delta x_{\\text{before}}^{(D)},\\Delta x_{\\text{after}}^{(D)}]$。", "solution": "我们从应用于离散化最小能量路径的微积分第一性原理出发。微动弹性带（NEB）方法通过有限的一组构象 $x_0,\\dots,x_{N-1}$ 来表示构型空间中的一条连续路径，其中 $x_0$ 和 $x_{N-1}$ 固定在反应物和产物的极小值点。能量最高的构象被用作鞍点的离散代理。当构象分布不均时，离真实鞍点 $x^\\ddagger$ 最近的构象可能会有一个有限的偏移量 $\\delta = x_k - x^\\ddagger$，从而对鞍点位置和能垒能量产生有偏差的估计。\n\n基本原理：对于一个在 $x^\\ddagger$ 处具有非简并鞍点的光滑势能面 $V(x)$，在 $x^\\ddagger$ 邻域内的泰勒展开得到\n$$\nV(x^\\ddagger + \\delta) = V^\\ddagger + \\frac{1}{2} V''(x^\\ddagger)\\,\\delta^2 + \\mathcal{O}(\\delta^3),\n$$\n根据驻点条件 $V'(x^\\ddagger)=0$，并根据一阶鞍点的定义 $V''(x^\\ddagger)<0$。对于给定的势能函数\n$$\nV(x) = \\frac{1}{4}(x^2-1)^2 = \\frac{1}{4} - \\frac{1}{2}x^2 + \\frac{1}{4}x^4,\n$$\n根据对称性可知 $x^\\ddagger=0$，$V^\\ddagger = V(0) = \\frac{1}{4}$，且 $V''(0) = -1$。因此，\n$$\nV(\\delta) = \\frac{1}{4} - \\frac{1}{2}\\delta^2 + \\frac{1}{4}\\delta^4,\n$$\n在离鞍点距离为 $\\delta$ 的离散最大值点处的绝对能量偏差为\n$$\n\\Delta E = \\left|V(\\delta) - V^\\ddagger\\right| = \\frac{1}{2}\\delta^2 - \\frac{1}{4}\\delta^4.\n$$\n对于足够小的 $\\delta$，主导行为是二次的，\n$$\n\\Delta E \\approx \\frac{1}{2}\\delta^2,\n$$\n这将一个直观的认识形式化了：能垒能量的离散化偏差随着构象到鞍点距离的平方而衰减。\n\n算法设计：为了在不显式引入切向弹簧力的情况下模拟不均匀的 NEB 间距，我们通过 $x_i = -1 + 2\\,(\\frac{i}{N-1})^p$ 来参数化初始构象。当 $p>1$ 时，这将使构象向左侧极小值点聚集。我们通过最大化 $V(x_i)$ 来计算能量最高构象的索引 $k$。相应的绝对误差为\n$$\n\\Delta x_{\\text{before}} = |x_k - x^\\ddagger|, \\quad \\Delta E_{\\text{before}} = |V(x_k) - V^\\ddagger|.\n$$\n为减小偏差，我们在 $x_k$ 的紧邻区域通过细分相邻区间 $[x_{k-1},x_k]$ 和 $[x_k,x_{k+1}]$ 来定向插入 $m$ 个构象。具体来说，我们在 $[x_{k-1},x_k]$ 中放置 $\\lceil m/2 \\rceil$ 个等距的内部点，在 $[x_k,x_{k+1}]$ 中放置 $m - \\lceil m/2 \\rceil$ 个。这会将离散最大值点附近的局部网格尺寸减半或更多，并相应地减小 $\\Delta x$。由于 $\\Delta E$ 在 $\\Delta x$ 中是渐近二次的，因此在鞍点附近进行理想的对称细化时，可以预期能量偏差会有一个接近 4 的近似缩减因子。\n\n我们将此应用于测试套件：\n- 情况 A：$N=9$, $p=3$, $m=2$。初始构象向 $x=-1$ 聚集，在鞍点附近留下一个很大的间隙。离散最大值点位于某个 $x_k<0$ 的位置，且 $\\Delta x_{\\text{before}}>0$。插入 $m=2$ 个构象会在每个相邻区间各放置一个，使最近的构象更接近 $x^\\ddagger=0$，并显著减小了 $\\Delta x$ 和 $\\Delta E$，这与二次标度关系一致。\n- 情况 B：$N=33$, $p=1$, $m=2$。奇数 $N$ 的均匀间距会使一个构象恰好位于 $x=0$ 处，因此 $\\Delta x_{\\text{before}}=0$ 且 $\\Delta E_{\\text{before}}=0$。插入操作后最大值点仍留在 $x^\\ddagger$，所以误差保持为零。\n- 情况 C：$N=5$, $p=5$, $m=2$。极度不均匀的粗糙间距使最近的构象位于一个大的 $|\\delta|$ 处，产生一个大的 $\\Delta E_{\\text{before}}$。插入两个构象会大幅减小 $\\Delta x$，因此 $\\Delta E$ 的减小量超过 4 倍的量级，尽管精确的因子取决于相邻区间的非对称性。\n- 情况 D：$N=11$, $p=1$, $m=2$。与情况 B 一样，一个构象恰好位于 $x^\\ddagger$，使得插入前后的误差均为零。\n\n实现细节：\n- 直接从解析的 $V(x)$ 及其对称性计算 $V^\\ddagger = V(0)$ 和 $x^\\ddagger=0$。\n- 通过直接计算 $V(x_i)$ 来确定能量最高的构象。\n- 通过在每个相邻区间上放置等距的内部点来执行插入，同时保持端点 $x=-1$ 和 $x=1$ 不变。\n- 插入后重新计算最大值点和误差。\n- 对于每个测试用例，按 A、B、C、D 的顺序，输出四元组 $[\\Delta E_{\\text{before}}, \\Delta E_{\\text{after}}, \\Delta x_{\\text{before}}, \\Delta x_{\\text{after}}]$，四舍五入到 10 位小数，并连接成一个扁平列表。\n\n该设计将 $V(x)$ 在鞍点附近的数学展开与一个具体的算法补救措施（局部插入）直接联系起来，并通过提供的测试用例演示了如何通过减小最大值点附近的局部离散化长度来纠正位置和能垒能量估计中的偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef potential(x):\n    # V(x) = 1/4 (x^2 - 1)^2\n    return 0.25 * (x**2 - 1.0)**2\n\ndef generate_images(N, p):\n    # Generate N images including endpoints using x = -1 + 2*(s^p), s in [0,1]\n    s = np.linspace(0.0, 1.0, N, dtype=float)\n    x = -1.0 + 2.0 * (s ** p)\n    # Ensure sorted uniqueness (should already be sorted)\n    x = np.array(sorted(set(np.round(x, 16))))  # guard against fp duplicates\n    return x\n\ndef analyze_images(x, x_saddle=0.0):\n    E = potential(x)\n    k = int(np.argmax(E))\n    x_max = float(x[k])\n    E_max = float(E[k])\n    E_saddle = float(potential(x_saddle))\n    dE = abs(E_max - E_saddle)\n    dx = abs(x_max - x_saddle)\n    return dE, dx, k\n\ndef insert_near_max(x, k, m):\n    # Insert m new images near index k: distribute ceil(m/2) on left interval [x[k-1], x[k]]\n    # and the rest on right interval [x[k], x[k+1]]. Endpoints remain fixed.\n    if m <= 0:\n        return np.array(x, dtype=float)\n    n = len(x)\n    # Safety: k should not be at endpoints for this potential; if it is, return unchanged\n    if k <= 0 or k >= n - 1:\n        return np.array(x, dtype=float)\n    left_count = int(np.ceil(m / 2.0))\n    right_count = int(m - left_count)\n    new_points = []\n\n    # Left interval subdivision: generate equally spaced interior points\n    xL, xK = x[k - 1], x[k]\n    if left_count > 0:\n        for j in range(1, left_count + 1):\n            frac = j / (left_count + 1)\n            new_points.append(xL + frac * (xK - xL))\n\n    # Right interval subdivision\n    xK, xR = x[k], x[k + 1]\n    if right_count > 0:\n        for j in range(1, right_count + 1):\n            frac = j / (right_count + 1)\n            new_points.append(xK + frac * (xR - xK))\n\n    x_aug = np.concatenate([x, np.array(new_points, dtype=float)])\n    x_aug.sort()\n    # Deduplicate with tolerance\n    x_unique = []\n    for xi in x_aug:\n        if len(x_unique) == 0 or abs(xi - x_unique[-1]) > 1e-15:\n            x_unique.append(float(xi))\n    return np.array(x_unique, dtype=float)\n\ndef run_case(N, p, m):\n    x0 = generate_images(N, p)\n    dE_before, dx_before, k = analyze_images(x0, 0.0)\n    x1 = insert_near_max(x0, k, m)\n    dE_after, dx_after, _ = analyze_images(x1, 0.0)\n    return dE_before, dE_after, dx_before, dx_after\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, p, m)\n    test_cases = [\n        (9, 3.0, 2),   # Case A\n        (33, 1.0, 2),  # Case B\n        (5, 5.0, 2),   # Case C\n        (11, 1.0, 2),  # Case D\n    ]\n\n    results = []\n    for N, p, m in test_cases:\n        dE_before, dE_after, dx_before, dx_after = run_case(N, p, m)\n        # Round to 10 decimal places as specified\n        results.extend([\n            round(dE_before, 10),\n            round(dE_after, 10),\n            round(dx_before, 10),\n            round(dx_after, 10),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2818689"}]}