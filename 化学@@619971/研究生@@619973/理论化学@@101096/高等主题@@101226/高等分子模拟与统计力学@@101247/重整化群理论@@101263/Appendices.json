{"hands_on_practices": [{"introduction": "本练习将引导你完成一个经典的实空间重整化群计算。通过对一个一维谐振子链模型进行“抽取”（decimation）——即积分掉部分自由度——你将亲手推导出一个有效的、粗粒化的哈密顿量。这个过程将具体地展示系统参数（如弹簧常数$\\kappa$）是如何在尺度变换下被“重整化”的，从而让你对重整化群的核心思想，即尺度不变性和参数流，有一个直观且坚实的理解。[@problem_id:2801692]", "problem": "一个经典的一维相同原子链模型用于描述聚合物骨架中的纵向振动。该链由哈密顿量\n$$\nH=\\frac{1}{2}\\sum_{i=1}^{N}\\left[\\frac{p_i^2}{m}+\\kappa\\left(x_{i+1}-x_i\\right)^2\\right],\n$$\n描述，满足周期性边界条件，其中$N$为偶数， $m$是质量，$\\kappa$是最近邻弹簧常数，$x_i$是格点$i$的位移，而$p_i$是其共轭动量。考虑在逆温度$\\beta=1/(k_{\\mathrm{B}}T)$下的正则配分函数：\n$$\nZ=\\int \\prod_{i=1}^{N} dx_i\\,dp_i\\,\\exp\\left(-\\beta H\\right).\n$$\n执行重整化群（RG）的一次实空间抽取步骤，在该步骤中，你将对所有奇数格点上的自由度进行积分。仅使用以下基本事实：（i）对于二次型哈密顿量，正则配分函数是一个相空间高斯积分；（ii）对一部分变量进行高斯积分，会得到一个关于剩余变量的、相差一个乘法常数的另一个高斯型函数。假设平移不变性和周期性边界条件成立，因此边界项可以忽略，并假设微观上只存在最近邻谐波相互作用。\n\n在进行任何重标定之前，推导偶数格点的有效粗粒化哈密顿量，然后执行一步格点重标定，通过将偶数格点重新标记为长度为$N/2$、格点间距与原始链相同的链上的最近邻格点，从而恢复原始的格点间距。在什么假设下，有效哈密顿量能保持与最近邻位移相关的相同谐波函数形式，并带有一个重整化的弹簧常数？明确陈述这些假设。最后，确定经过这单次抽取和重标定步骤后，重整化弹簧常数$\\kappa_{\\mathrm{R}}$的显式闭合形式表达式，该表达式仅用$\\kappa$表示。请给出$\\kappa_{\\mathrm{R}}$的最终答案，形式为一个无单位的解析表达式。", "solution": "所述问题具有科学依据，内容自洽，且提法明确。这是统计力学中一个标准的、用于阐述实空间重整化群的教学问题。我们继续进行解答。\n\n系统由哈密顿量描述：\n$$\nH=\\frac{1}{2}\\sum_{i=1}^{N}\\left[\\frac{p_i^2}{m}+\\kappa\\left(x_{i+1}-x_i\\right)^2\\right]\n$$\n在逆温度$\\beta$下的正则配分函数为：\n$$\nZ=\\int \\prod_{i=1}^{N} dx_i\\,dp_i\\,\\exp\\left(-\\beta H\\right)\n$$\n哈密顿量可以分离为动能项和势能项。对动量$\\{p_i\\}$的积分可以独立于位置$\\{x_i\\}$进行。\n$$\n\\int \\prod_{i=1}^{N} dp_i \\exp\\left(-\\frac{\\beta}{2m}\\sum_{i=1}^{N}p_i^2\\right) = \\left(\\int dp \\exp\\left(-\\frac{\\beta p^2}{2m}\\right)\\right)^N = \\left(\\sqrt{\\frac{2\\pi m}{\\beta}}\\right)^N\n$$\n这部分对配分函数贡献一个常数因子，并且不影响势能参数的重整化。因此，我们可以专注于配分函数的位形部分，它涉及对位置坐标$\\{x_i\\}$和势能$V = \\frac{1}{2}\\sum_{i=1}^{N}\\kappa(x_{i+1}-x_i)^2$进行积分。\n位形配分函数是：\n$$\nZ_x = \\int \\prod_{i=1}^{N} dx_i \\exp\\left(-\\beta V\\right)\n$$\n重整化群的抽取步骤要求对奇数编号格点对应的自由度进行积分，即对$i=1, 3, \\dots, N-1$的$\\{x_i, p_i\\}$进行积分。由于奇数格点的动量积分仅贡献一个总的常数，我们只需考虑对奇数格点位置变量$\\{x_i\\}_{i \\text{ 奇}}$的积分。\n\n势能$V$只涉及最近邻相互作用。一个奇数格点$x_k$（其中$k$是奇数）只与其偶数编号的邻居$x_{k-1}$和$x_{k+1}$相互作用。势能中涉及$x_k$的项是$\\frac{\\kappa}{2}(x_k - x_{k-1})^2$和$\\frac{\\kappa}{2}(x_{k+1} - x_k)^2$。因为每个奇数格点仅与其直接的偶数邻居耦合，所以对不同奇数格点位置的积分是相互独立的。我们可以将对奇数格点的积分写成每个奇数格点积分的乘积：\n$$\n\\int \\prod_{i \\text{ odd}} dx_i \\exp(-\\beta V) = \\int \\prod_{i \\text{ odd}} dx_i \\exp\\left(-\\frac{\\beta \\kappa}{2} \\sum_{j \\text{ all}} (x_{j+1}-x_j)^2\\right) = \\prod_{k \\text{ odd}} \\int dx_k \\exp\\left(-\\frac{\\beta \\kappa}{2} \\left[ (x_k - x_{k-1})^2 + (x_{k+1} - x_k)^2 \\right] \\right)\n$$\n让我们计算其中一个高斯积分。对于给定的奇数格点$x_k$，指数的自变量是$x_k$的二次函数：\n$$\n-\\frac{\\beta \\kappa}{2} \\left[ (x_k - x_{k-1})^2 + (x_{k+1} - x_k)^2 \\right] = -\\frac{\\beta \\kappa}{2} \\left[ x_k^2 - 2x_k x_{k-1} + x_{k-1}^2 + x_{k+1}^2 - 2x_{k+1}x_k + x_k^2 \\right]\n$$\n$$\n= -\\frac{\\beta \\kappa}{2} \\left[ 2x_k^2 - 2x_k(x_{k-1} + x_{k+1}) + (x_{k-1}^2 + x_{k+1}^2) \\right]\n$$\n为了对$x_k$进行积分，我们对包含$x_k$的项进行配方：\n$$\n2x_k^2 - 2x_k(x_{k-1} + x_{k+1}) = 2\\left[x_k^2 - x_k(x_{k-1} + x_{k+1})\\right] = 2\\left[\\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\left(\\frac{x_{k-1} + x_{k+1}}{2}\\right)^2\\right]\n$$\n将此代入指数的自变量中，得到：\n$$\n-\\frac{\\beta \\kappa}{2} \\left[ 2\\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\frac{1}{2}(x_{k-1} + x_{k+1})^2 + x_{k-1}^2 + x_{k+1}^2 \\right]\n$$\n$$\n= -\\frac{\\beta \\kappa}{2} \\left[ 2\\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 + \\frac{1}{2}(x_{k-1}^2 - 2x_{k-1}x_{k+1} + x_{k+1}^2) \\right]\n$$\n$$\n= -\\beta \\kappa \\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2\n$$\n现在对$x_k$的积分就变得很简单了：\n$$\n\\int_{-\\infty}^{\\infty} dx_k \\exp\\left[ -\\beta \\kappa \\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right] \n$$\n$$\n= \\exp\\left( - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right) \\int_{-\\infty}^{\\infty} dx_k \\exp\\left[ -\\beta \\kappa \\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 \\right]\n$$\n该积分的计算结果是一个常数$\\sqrt{\\pi/(\\beta\\kappa)}$，它与剩余的偶数格点坐标无关。将所有$N/2$个奇数格点积分产生的所有此类常数合并，得到一个总的常数前置因子。玻尔兹曼因子中依赖于偶数格点坐标的剩余部分，定义了有效势$V_{\\text{eff}}$。\n在对所有奇数格点进行积分后，偶数格点的新玻尔兹曼因子为：\n$$\n\\exp(-\\beta V_{\\text{eff}}) \\propto \\prod_{k \\text{ odd}} \\exp\\left( - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right) = \\exp\\left( - \\beta \\sum_{k \\text{ odd}} \\frac{\\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right)\n$$\n因此，偶数格点$\\{x_2, x_4, \\dots, x_N\\}$的有效势为：\n$$\nV_{\\text{eff}} = \\sum_{k \\text{ odd}} \\frac{\\kappa}{4} (x_{k+1} - x_{k-1})^2 = \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x_{2j+2}-x_{2j})^2\n$$\n其中使用了周期性边界条件 ($x_{N+2} = x_2$)。在重标定之前，由$N/2$个偶数编号格点组成的粗粒化系统的有效哈密顿量为：\n$$\nH_{\\text{eff}} = \\sum_{j=1}^{N/2} \\frac{p_{2j}^2}{2m} + \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x_{2j+2}-x_{2j})^2\n$$\n这个有效哈密顿量描述了一个具有$N/2$个格点的新链。相互作用仍然是谐波的，并且发生在新生的、更粗的格点上的最近邻之间。这种函数形式的保持并非重整化群变换的一般特征。在这里它之所以成立，是由于两个关键假设：\n$1$. 原始哈密顿量是关于自由度的二次型（谐波）函数。这使得配分函数成为高斯积分的乘积，对一部分变量进行积分会产生一个关于剩余变量的新的高斯函数。\n$2$. 原始哈密顿量中的相互作用严格限于最近邻。这确保了对一个奇数格点$x_k$的积分仅在其直接邻居$x_{k-1}$和$x_{k+1}$（它们在粗粒化格点上成为最近邻）之间产生新的有效相互作用。如果初始时存在次近邻或更长程的相互作用，抽取步骤将产生一个复杂得多的非局域有效哈密顿量。\n\n现在，我们进行格点重标定。我们为尺寸为$N/2$的粗粒化格点定义一组新坐标：\n$$\nx'_j = x_{2j}, \\quad p'_j = p_{2j} \\quad \\text{for } j=1, 2, \\dots, N/2\n$$\n用这些新变量表示的重标定哈密顿量$H_{\\text{R}}$为：\n$$\nH_{\\text{R}} = \\sum_{j=1}^{N/2} \\frac{(p'_j)^2}{2m} + \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x'_{j+1}-x'_{j})^2\n$$\n问题要求这个重整化的哈密顿量具有与原始哈密顿量相同的函数形式，即\n$$\nH_{\\text{R}} = \\frac{1}{2} \\sum_{j=1}^{N/2} \\left[ \\frac{(p'_j)^2}{m'} + \\kappa_{\\text{R}} (x'_{j+1}-x'_{j})^2 \\right]\n$$\n在这种情况下，没有进行质量的重标定，所以$m' = m$。我们比较势能项：\n$$\n\\frac{1}{2} \\sum_{j=1}^{N/2} \\kappa_{\\text{R}} (x'_{j+1}-x'_{j})^2 = \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x'_{j+1}-x'_{j})^2\n$$\n通过令系数相等，我们找到了重整化弹簧常数$\\kappa_{\\text{R}}$的关系式：\n$$\n\\frac{\\kappa_{\\text{R}}}{2} = \\frac{\\kappa}{4}\n$$\n这得出了重整化弹簧常数的最终表达式：\n$$\n\\kappa_{\\text{R}} = \\frac{\\kappa}{2}\n$$", "answer": "$$\n\\boxed{\\frac{\\kappa}{2}}\n$$", "id": "2801692"}, {"introduction": "在掌握了实空间方法的基本逻辑后，我们转向更普遍、更强大的动量空间重整化方法。此练习将带你实践 Kenneth G. Wilson 的动量层壳积分方法，通过对高动量（“快”）模式进行积分，推导出低动量（“慢”）模式的有效理论。本次实践的核心目标是推导理论的$\\beta$函数，它描述了耦合常数如何随观察尺度的变化而“流动”，这是运用重整化群分析相变与临界现象的关键一步。[@problem_id:2801635]", "problem": "考虑一个单分量实标量序参量场$\\phi$，其欧几里得作用量为 $S[\\phi]=\\int d^d x \\left[\\frac{1}{2}(\\nabla \\phi)^2+\\frac{r}{2}\\phi^2+\\frac{u}{4!}\\phi^4\\right]$，且具有尖锐的紫外动量截断$|\\mathbf{k}|\\le \\Lambda$。执行一个威尔逊动量壳重整化群（RG）步骤：首先积分掉快模（$\\Lambda/b<|\\mathbf{q}|\\le \\Lambda$，其中$b=\\exp(\\ell)$且$\\ell$为无穷小量），然后进行标度变换 $x'=x/b$ 和场重标度，选择重标度以保持动能项$\\frac{1}{2}(\\nabla \\phi)^2$的系数不变。使用累积量展开计算至单圈阶，并在递推关系中保留至$u^2$阶的项。\n\n你的推导必须从配分函数的路径积分表示$Z=\\int \\mathcal{D}\\phi\\,\\exp\\!\\left(-S[\\phi]\\right)$、将场$\\phi=\\phi_<+\\phi_>$分解为慢模和快模，以及对慢模有效作用量进行相关阶数的累积量展开开始。假设对于标量$\\phi^4$理论，在此阶数下不存在波函数重整化。使用以下关于几何因子的定义：$S_d=2\\pi^{d/2}/\\Gamma(d/2)$和$K_d \\equiv \\frac{S_d}{2(2\\pi)^d}$。定义无量纲耦合$\\tau \\equiv r/\\Lambda^2$和$g \\equiv K_d\\,u\\,\\Lambda^{d-4}$。在源于传播子分母的单圈壳积分中，保留对$\\tau$的领头依赖关系。\n\n推导微分递推关系（β函数）$d\\tau/d\\ell$和$dg/d\\ell$至$u^2$阶，并完全用$d$、$\\tau$和$g$表示。以包含两个β函数的单个闭式解析行向量的形式给出最终答案。不需要进行数值计算，也不涉及单位。最终答案必须是单个解析表达式。", "solution": "该问题要求使用威尔逊动量壳积分方案，推导 $d$ 维标量 $\\phi^4$ 理论的单圈重整化群（RG）β函数。\n\n配分函数由标量场 $\\phi$ 的路径积分给出：\n$$Z = \\int \\mathcal{D}\\phi \\, \\exp(-S[\\phi])$$\n其中欧几里得作用量为\n$$S[\\phi] = \\int d^d x \\left[\\frac{1}{2}(\\nabla \\phi)^2 + \\frac{r}{2}\\phi^2 + \\frac{u}{4!}\\phi^4\\right]$$\n场具有一个尖锐的紫外动量截断 $|\\mathbf{k}| \\le \\Lambda$。\n\n威尔逊RG过程的第一步是将场 $\\phi$ 分解为慢模 $\\phi_<$ 和快模 $\\phi_>$。在动量空间中：\n$$\n\\phi(\\mathbf{k}) =\n\\begin{cases}\n\\phi_<(\\mathbf{k}) & \\text{对于 } 0 \\le |\\mathbf{k}| \\le \\Lambda/b \\\\\n\\phi_>(\\mathbf{k}) & \\text{对于 } \\Lambda/b < |\\mathbf{k}| \\le \\Lambda\n\\end{cases}\n$$\n其中 $b = \\exp(\\ell)$，$\\ell$ 是一个无穷小参数。作用量可以分解为依赖于 $\\phi_<$ 和 $\\phi_>$ 的部分。\n$$S[\\phi_< + \\phi_>] = S_0[\\phi_<] + S_0[\\phi_>] + S_{int}[\\phi_< + \\phi_>]$$\n这里，$S_0[\\phi] = \\int \\frac{d^d k}{(2\\pi)^d} \\frac{1}{2}(k^2+r) |\\phi(\\mathbf{k})|^2$ 是作用量的二次（自由）部分，而 $S_{int}[\\phi] = \\int d^d x \\frac{u}{4!}\\phi^4$ 是相互作用部分。\n\n积分掉快模 $\\phi_>$ 会得到慢模的有效作用量 $S_{eff}[\\phi_<]$：\n$$\\exp(-S_{eff}[\\phi_<]) = \\int \\mathcal{D}\\phi_> \\, \\exp(-S[\\phi_< + \\phi_>])$$\n有效作用量可以被系统地计算。在单圈阶，作用量的变化 $\\Delta S = S_{eff}[\\phi_<] - S[\\phi_<]$ 由具有内部快模传播子和外部慢模场的单圈1PI图给出。这等价于计算泛函迹：\n$$\\Delta S[\\phi_<] = \\frac{1}{2}\\text{Tr}\\ln\\left(\\frac{\\delta^2 S}{\\delta\\phi_> \\delta\\phi_>}\\right)\\Big|_{\\phi_> = 0} - \\text{const.}$$\n对数中的算符是 $\\frac{\\delta^2 S}{\\delta\\phi_>(x) \\delta\\phi_>(y)} = (-\\nabla^2+r)\\delta^{(d)}(x-y) + \\frac{u}{2}\\phi^2(x)\\delta^{(d)}(x-y) + O(\\phi^4)$。将 $\\phi_<$ 视为背景场，这变为\n$$-\\nabla^2 + r + \\frac{u}{2}\\phi_<^2(x)$$\n快模的传播子是 $G_>(q) = \\frac{1}{q^2+r}$ (对于 $\\Lambda/b < |q| \\le \\Lambda$)。\n作用量的变化则为\n$$\\Delta S[\\phi_<] = \\frac{1}{2}\\text{Tr}\\ln\\left[ G_>^{-1}\\left(1 + G_> \\frac{u}{2}\\phi_<^2\\right) \\right] = \\text{const.} + \\frac{1}{2}\\text{Tr}\\ln\\left(1 + G_> \\frac{u}{2}\\phi_<^2\\right)$$\n使用展开式 $\\ln(1+X) \\approx X - \\frac{1}{2}X^2$，我们保留到 $\\phi_<^4$ 阶的项。\n$$\\Delta S[\\phi_<] \\approx \\frac{1}{2}\\text{Tr}\\left(G_> \\frac{u}{2}\\phi_<^2\\right) - \\frac{1}{4}\\text{Tr}\\left( (G_> \\frac{u}{2}\\phi_<^2)^2 \\right)$$\n\n第一项修正了质量项 $\\frac{r}{2}\\phi^2$：\n$$\\Delta S_r = \\frac{u}{4}\\text{Tr}(G_> \\phi_<^2) = \\frac{u}{4} \\int d^d x \\, \\phi_<^2(x) G_>(x,x)$$\n其中 $G_>(x,x) = \\int_{\\Lambda/b<|q|\\le\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{1}{q^2+r} \\equiv I_1$。这个在薄动量壳上的积分是\n$$I_1 = \\int_{\\Lambda/b}^{\\Lambda} \\frac{S_d q^{d-1} dq}{(2\\pi)^d} \\frac{1}{q^2+r}$$\n其中 $S_d = 2\\pi^{d/2}/\\Gamma(d/2)$ 是 $d$ 维单位超球面的表面积。对于无穷小 $\\ell$，$b = e^\\ell \\approx 1+\\ell$，所以壳的宽度是 $\\Lambda - \\Lambda/b \\approx \\Lambda\\ell$。\n$$I_1 \\approx \\frac{S_d \\Lambda^{d-1}}{(2\\pi)^d} \\frac{1}{\\Lambda^2+r} (\\Lambda\\ell) = \\frac{S_d}{(2\\pi)^d} \\frac{\\Lambda^d}{\\Lambda^2(1+r/\\Lambda^2)}\\ell = 2 K_d \\frac{\\Lambda^{d-2}}{1+\\tau}\\ell$$\n使用了定义 $K_d = \\frac{S_d}{2(2\\pi)^d}$ 和 $\\tau=r/\\Lambda^2$。作用量中 $\\frac{1}{2}\\phi_<^2$ 的系数变化量为 $\\Delta r$：\n$$\\frac{\\Delta r}{2} = \\frac{u}{4}I_1 \\implies \\Delta r = \\frac{u}{2}I_1 = u K_d \\frac{\\Lambda^{d-2}}{1+\\tau}\\ell$$\n\n$\\Delta S$ 展开式中的第二项修正了相互作用项 $\\frac{u}{4!}\\phi^4$：\n$$\\Delta S_u = -\\frac{1}{8}\\text{Tr}\\left( (G_> \\frac{u}{2}\\phi_<^2)^2 \\right) = -\\frac{u^2}{32}\\text{Tr}(G_> \\phi_<^2 G_> \\phi_<^2)$$\n为计算局域顶角修正，将 $\\phi_<$ 近似为空间常数，这变为\n$$\\Delta S_u \\approx -\\frac{u^2}{32}\\phi_<^4 \\int d^dx \\, \\text{Tr}(G_> G_>) = -\\frac{u^2}{32}\\phi_<^4 \\int d^dx \\int_{\\Lambda/b<|q|\\le\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\left(\\frac{1}{q^2+r}\\right)^2$$\n积分为 $I_2 \\equiv \\int_{\\Lambda/b<|q|\\le\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{1}{(q^2+r)^2}$。在薄壳上计算：\n$$I_2 \\approx \\frac{S_d \\Lambda^{d-1}}{(2\\pi)^d} \\frac{1}{(\\Lambda^2+r)^2} (\\Lambda\\ell) = 2 K_d \\frac{\\Lambda^{d-4}}{(1+\\tau)^2}\\ell$$\n$\\frac{1}{4!}\\phi_<^4$ 的系数变化量为 $\\Delta u$。注意，上述计算给出了一个写为 $-\\frac{u^2}{32}\\phi_<^4 \\int d^d x I_2$ 的项的修正。对四点函数有贡献的单圈修正有3个通道，这对应于图的组合学。来自费曼图的标准结果给出 $\\Delta u = -\\frac{3}{2}u^2 I_2$。\n$$\\Delta u = -\\frac{3}{2}u^2 I_2 = -\\frac{3}{2}u^2 \\left( 2 K_d \\frac{\\Lambda^{d-4}}{(1+\\tau)^2}\\ell \\right) = -3 u^2 K_d \\frac{\\Lambda^{d-4}}{(1+\\tau)^2}\\ell$$\n\nRG过程的第二步是重标度空间和场，以恢复原始的截断尺度 $\\Lambda$ 和规范的动能项。令 $x' = x/b$ 且 $\\phi_<(x) = \\zeta^{-1}\\phi'(x')$。\n动能项变换如下：\n$$\\int d^dx \\frac{1}{2}(\\nabla\\phi_<)^2 = \\int b^d d^dx' \\frac{1}{2} (b^{-1}\\nabla' (\\zeta^{-1}\\phi'))^2 = b^{d-2}\\zeta^{-2} \\int d^dx' \\frac{1}{2}(\\nabla'\\phi')^2$$\n为保持此项不变，我们必须有 $b^{d-2}\\zeta^{-2} = 1$，这给出 $\\zeta = b^{(d-2)/2}$。质量项和相互作用项变换如下：\n$$\\int d^dx \\, \\frac{r'}{2}\\phi_<^2 = \\int b^d d^dx' \\, \\frac{r'}{2}(\\zeta^{-1}\\phi')^2 = b^d \\zeta^{-2} \\int d^dx' \\frac{r'}{2}(\\phi')^2 = b^2 \\int d^dx' \\frac{r'}{2}(\\phi')^2$$\n$$\\int d^dx \\, \\frac{u'}{4!}\\phi_<^4 = \\int b^d d^dx' \\, \\frac{u'}{4!}(\\zeta^{-1}\\phi')^4 = b^d \\zeta^{-4} \\int d^dx' \\frac{u'}{4!}(\\phi')^4 = b^{4-d} \\int d^dx' \\frac{u'}{4!}(\\phi')^4$$\n其中 $r'=r+\\Delta r$ 且 $u'=u+\\Delta u$。\n参数的递推关系为：\n$$r(\\ell) = (r+\\Delta r)b^2 = (r+\\Delta r)e^{2\\ell} \\approx (r+\\Delta r)(1+2\\ell) \\approx r + 2r\\ell + \\Delta r$$\n$$u(\\ell) = (u+\\Delta u)b^{4-d} = (u+\\Delta u)e^{(4-d)\\ell} \\approx (u+\\Delta u)(1+(4-d)\\ell) \\approx u + (4-d)u\\ell + \\Delta u$$\n通过取极限 $\\ell \\to 0$ 可获得微分流方程：\n$$\\frac{dr}{d\\ell} = \\lim_{\\ell\\to 0}\\frac{r(\\ell)-r}{\\ell} = 2r + \\frac{\\Delta r}{\\ell} = 2r + u K_d \\Lambda^{d-2}(1+\\tau)^{-1}$$\n$$\\frac{du}{d\\ell} = \\lim_{\\ell\\to 0}\\frac{u(\\ell)-u}{\\ell} = (4-d)u + \\frac{\\Delta u}{\\ell} = (4-d)u - 3u^2 K_d \\Lambda^{d-4}(1+\\tau)^{-2}$$\n\n最后，我们推导无量纲耦合 $\\tau = r/\\Lambda^2$ 和 $g=K_d u \\Lambda^{d-4}$ 的β函数。在这些定义中，截断 $\\Lambda$ 被视为固定的标度参数。\n$$\\frac{d\\tau}{d\\ell} = \\frac{1}{\\Lambda^2} \\frac{dr}{d\\ell} = \\frac{1}{\\Lambda^2}\\left(2r + u K_d \\Lambda^{d-2}\\frac{1}{1+\\tau}\\right) = 2\\frac{r}{\\Lambda^2} + (u K_d \\Lambda^{d-4})\\frac{1}{1+\\tau}$$\n$$\\frac{d\\tau}{d\\ell} = 2\\tau + \\frac{g}{1+\\tau}$$\n对于耦合 $g$：\n$$\\frac{dg}{d\\ell} = K_d \\Lambda^{d-4} \\frac{du}{d\\ell} = K_d \\Lambda^{d-4} \\left( (4-d)u - 3u^2 K_d \\Lambda^{d-4}\\frac{1}{(1+\\tau)^2} \\right)$$\n$$\\frac{dg}{d\\ell} = (4-d)(K_d u \\Lambda^{d-4}) - 3(K_d u \\Lambda^{d-4})^2\\frac{1}{(1+\\tau)^2}$$\n$$\\frac{dg}{d\\ell} = (4-d)g - \\frac{3g^2}{(1+\\tau)^2}$$\n这些就是所需至 $u^2$ 阶的递推关系。", "answer": "$$\n\\boxed{\\begin{pmatrix} 2\\tau + \\frac{g}{1+\\tau} & (4-d)g - \\frac{3g^2}{(1+\\tau)^2} \\end{pmatrix}}\n$$", "id": "2801635"}, {"introduction": "理论的价值最终体现在其解释和预测能力上，本练习旨在将抽象的重整化群理论与计算科学实践联系起来。重整化群预测了在临界点附近系统会展现出普适的标度行为，但实际研究（无论是实验还是模拟）中的系统尺寸总是有限的。这个练习要求你运用有限尺寸标度分析方法，包括考虑修正项，从合成的聚合物链数据中提取普适的临界指数$\\nu$，这将让你体验到研究者们如何处理和分析模拟数据以验证理论预测。[@problem_id:2801617]", "problem": "您的任务是编写一个程序，给定一小组合成聚合物数据集，利用重整化群理论中的有限尺寸标度思想，从长链的回旋半径$R_g$作为链长$N$的函数中，估算临界尺寸指数$\\nu$，同时考虑次领头的有限尺寸修正。其核心物理背景是，稀聚合物溶液中的排除体积相互作用驱动了一个重整化群不动点，该不动点设定了渐近标度关系$R_g \\sim N^{\\nu}$，而修正是由随$N$增大而衰减的无关算符控制的。您的算法应基于原则，不应依赖于特设的曲线匹配；它应使用模型选择准则来决定是否需要修正项，如果需要，则决定哪个备选修正指数能最好地解释数据。\n\n使用的基本原理：\n- 聚合物链的回旋半径$R_g$的定义是其特征尺寸，对于长链，由于在重整化群不动点处的标度不变性，$R_g$对链长$N$存在渐近的幂律依赖关系。\n- 广泛使用的有限尺寸标度拟设，即领头标度修正是$N$的一个衰减幂次，由一个正的标度修正指数$\\Delta$控制。\n\n您的计算任务：\n1. 对于每个数据集，根据指定参数，使用带有单个领头修正的有限尺寸标度形式，构建$R_g$的合成测量值，不添加任何噪声。这为估计量建立了可复现的输入：\n   - $R_g(N) = A\\, N^{\\nu_{\\text{true}}}\\left(1 + B\\, N^{-\\Delta}\\right)$，其中$A > 0$，$B$可为正或负，且$\\Delta > 0$。\n2. 仅给定得到的$\\{(N_i, R_{g,i})\\}$数据对，通过比较以下备选模型来估计指数$\\nu$：\n   - 纯渐近标度：$R_g(N) = A\\, N^{\\nu}$。\n   - 带有一个次领头修正的标度，备选指数为$\\Delta \\in \\{0.5, 1.0\\}$：$R_g(N) = A\\, N^{\\nu}\\left(1 + B\\, N^{-\\Delta}\\right)$。\n3. 对每个备选模型，在原始（非对数）空间中执行非线性最小二乘估计，使用物理上合理的界限（$A > 0$，$0 < \\nu < 1$，以及对$B$的宽泛界限）。通过最小化小样本修正的Akaike信息准则 (AICc)来选择首选模型，该准则对于$n$个数据点和$k$个参数定义为：\n   $$ \\mathrm{AIC} = n \\ln\\!\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2k,\\quad \\mathrm{AICc} = \\mathrm{AIC} + \\frac{2k(k+1)}{n - k - 1}, $$\n   其中$\\mathrm{RSS} = \\sum_{i=1}^{n}\\left(R_{g,i}^{\\text{fit}} - R_{g,i}\\right)^2$。如果$n - k - 1 \\le 0$，则使用$\\mathrm{AIC}$代替$\\mathrm{AICc}$。\n4. 报告每个数据集的选定模型的$\\nu$估计值，四舍五入到三位小数。\n\n测试套件（完全按照规定构建合成数据集；$N$是无量纲的，$R_g$使用任意一致的单位，但最终答案无需报告单位）：\n- 数据集1（具有强修正的一般情况，类三维排除体积）：\n  - $N \\in \\{20, 40, 80, 160, 320, 640\\}$, $A = 0.35$, $\\nu_{\\text{true}} = 0.588$, $B = 0.8$, $\\Delta = 0.5$。\n- 数据集2（无修正项的边界情况，理想链或类 theta 链）：\n  - $N \\in \\{10, 20, 40, 80, 160, 320\\}$, $A = 0.6$, $\\nu_{\\text{true}} = 0.5$, $B = 0.0$, $\\Delta = 1.0$。\n- 数据集3（具有解析修正的类二维情况）：\n  - $N \\in \\{30, 60, 120, 240, 480\\}$, $A = 0.25$, $\\nu_{\\text{true}} = 0.75$, $B = 0.5$, $\\Delta = 1.0$。\n- 数据集4（具有非常强修正的短链）：\n  - $N \\in \\{12, 18, 26, 38, 58, 86\\}$, $A = 0.4$, $\\nu_{\\text{true}} = 0.588$, $B = 1.2$, $\\Delta = 0.5$。\n- 数据集5（点数很少且无修正的边缘情况）：\n  - $N \\in \\{50, 100, 200, 400\\}$, $A = 0.5$, $\\nu_{\\text{true}} = 0.588$, $B = 0.0$, $\\Delta = 0.5$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含五个估计的$\\nu$值（每个数据集一个），形式为用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数，例如 $[0.588,0.500,0.750,0.590,0.585]$（此示例仅为说明）。\n\n不涉及角度单位。最终数值输出中不需要物理单位。唯一接受的输出是如上所述的浮点数。", "solution": "所呈现的问题经过了严格验证，被认为是有效的。它构成了一个定义明确的计算练习，其基础是高分子统计力学和重整化群理论的基本原理。任务是实施一个基于原则的模型选择协议，从合成数据中估算一个普适临界指数，这是分析模拟和实验结果的标准程序。所有必需的参数和方法都已明确指定，问题不存在科学不准确或逻辑矛盾之处。\n\n中心物理原理是，长柔性聚合物链的特征尺寸，由其回旋半径$R_g$量化，随其长度（单体单元数）$N$按幂律进行标度。在大的$N$下，系统由一个重整化群不动点描述，导致普适的标度行为：\n$$ R_g(N) \\sim N^{\\nu} $$\n其中$\\nu$是一个普适临界指数，仅取决于空间维度和相互作用的性质（例如，是否存在排除体积）。对于有限的$N$，预期会偏离此渐近定律。这些偏离由标度修正来描述，在重整化群框架中由无关算子控制。领头修正通常呈$N$的幂律形式，导致以下关于$R_g(N)$标度的拟设：\n$$ R_g(N) = A N^{\\nu} \\left(1 + B N^{-\\Delta} + \\dots\\right) $$\n这里，$A$是一个非普适振幅，$B$是第二个非普适振幅，而$\\Delta > 0$是领头标度修正指数，它也是一个普适量。\n\n任务是获取从此形式生成的合成无噪声数据集$\\{(N_i, R_{g,i})\\}$，并确定$\\nu$的最佳估计值。这不是通过可能产生误导的朴素对数作图来完成的，而是通过一个正式的模型比较程序。\n\n具体步骤如下：\n$1$. 对于每个数据集，使用提供的真实参数$(\\nu_{\\text{true}}, A, B, \\Delta)$生成$R_g$作为$N$的函数的合成数据。\n\n$2$. 将三个不同的备选模型拟合到此合成数据：\n    - 模型 $0$：纯幂律，$R_g(N) = A N^{\\nu}$。该模型有$k=2$个自由参数：$A$和$\\nu$。\n    - 模型 $1$：带有领头修正（指数固定为$\\Delta=0.5$）的幂律，$R_g(N) = A N^{\\nu} (1 + B N^{-0.5})$。该模型与三维自回避行走相关，有$k=3$个参数：$A$、$\\nu$和$B$。\n    - 模型 $2$：带有领头修正（指数固定为$\\Delta=1.0$）的幂律，$R_g(N) = A N^{\\nu} (1 + B N^{-1.0})$。该模型，例如在二维中相关，也有$k=3$个参数：$A$、$\\nu$和$B$。\n\n$3$. 通过执行非线性最小二乘回归来确定每个模型的参数，该回归最小化残差平方和($\\mathrm{RSS}$):\n$$ \\mathrm{RSS} = \\sum_{i=1}^{n} \\left( R_{g,i}^{\\text{fit}} - R_{g,i} \\right)^2 $$\n其中$n$是数据点的数量。优化受物理上合理的界限约束，即$A > 0$和$0 < \\nu < 1$。\n\n$4$. 通过采用小样本修正的Akaike信息准则($\\mathrm{AICc}$)来选择最合适的模型。该准则提供了一种在拟合优度（较低的$\\mathrm{RSS}$）和模型复杂度（较少的参数$k$）之间进行权衡的正式方法。aic定义为：\n$$ \\mathrm{AIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2k $$\n修正版本$\\mathrm{AICc}$在小样本量$n$时更可靠，由下式给出：\n$$ \\mathrm{AICc} = \\mathrm{AIC} + \\frac{2k(k+1)}{n - k - 1} $$\n选择表现出最小$\\mathrm{AICc}$值的模型作为数据的首选描述。一个关键细节是，当条件$n - k - 1 \\le 0$对某个备选模型成立时，$\\mathrm{AICc}$中的修正项会发散或无定义。在这种情况下，为了进行一致的比较，对于该特定数据集的所有比较模型，我们将退而使用标准的$\\mathrm{AIC}$。这种情况发生在数据集5中，其中$n=4$，而$k=3$的模型满足$4-3-1=0$。\n\n$5$. 由于输入数据是从作为备选模型特例的函数无噪声生成的，正确模型（或更复杂、嵌套的模型）的$\\mathrm{RSS}$将在数值上为零。在这种情况下，$\\mathrm{AIC}$中的对数项变为$-\\infty$。如果多个模型达到这种完美拟合，将选择具有最小复杂度惩罚项（即最小$k$值）的模型，这遵循了简约原则。\n\n$6$. 为每个数据集报告的$\\nu$的最终估计值是从所选模型的参数拟合中获得的值。\n\n整个过程在提供的程序中实现。它系统地处理每个数据集，执行模型拟合和选择，并报告由此产生的指数$\\nu$的最佳估计值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the polymer scaling exponent nu using\n    finite-size scaling and model selection via AICc.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": np.array([20, 40, 80, 160, 320, 640]), \"A\": 0.35,\n            \"nu_true\": 0.588, \"B\": 0.8, \"Delta\": 0.5\n        },\n        {\n            \"N\": np.array([10, 20, 40, 80, 160, 320]), \"A\": 0.6,\n            \"nu_true\": 0.5, \"B\": 0.0, \"Delta\": 1.0\n        },\n        {\n            \"N\": np.array([30, 60, 120, 240, 480]), \"A\": 0.25,\n            \"nu_true\": 0.75, \"B\": 0.5, \"Delta\": 1.0\n        },\n        {\n            \"N\": np.array([12, 18, 26, 38, 58, 86]), \"A\": 0.4,\n            \"nu_true\": 0.588, \"B\": 1.2, \"Delta\": 0.5\n        },\n        {\n            \"N\": np.array([50, 100, 200, 400]), \"A\": 0.5,\n            \"nu_true\": 0.588, \"B\": 0.0, \"Delta\": 0.5\n        },\n    ]\n\n    # Model definitions\n    # Model 0: Pure scaling (k=2)\n    model_0 = lambda N, A, nu: A * N**nu\n    # Model 1: Correction with Delta=0.5 (k=3)\n    model_1 = lambda N, A, nu, B: A * N**nu * (1 + B * N**-0.5)\n    # Model 2: Correction with Delta=1.0 (k=3)\n    model_2 = lambda N, A, nu, B: A * N**nu * (1 + B * N**-1.0)\n    \n    models = [\n        {'func': model_0, 'k': 2, 'name': 'Model 0 (k=2)'},\n        {'func': model_1, 'k': 3, 'name': 'Model 1 (k=3, D=0.5)'},\n        {'func': model_2, 'k': 3, 'name': 'Model 2 (k=3, D=1.0)'}\n    ]\n\n    results_nu = []\n\n    for case in test_cases:\n        N_data = case[\"N\"]\n        A_true, nu_true, B_true, Delta_true = case[\"A\"], case[\"nu_true\"], case[\"B\"], case[\"Delta\"]\n\n        # 1. Generate synthetic data\n        rg_func_true = lambda n: A_true * n**nu_true * (1 + B_true * n**(-Delta_true))\n        Rg_data = rg_func_true(N_data)\n\n        fit_results = []\n        n = len(N_data)\n\n        # Determine if AIC fallback is needed for this dataset\n        use_aic_fallback = any(n - model['k'] - 1 <= 0 for model in models)\n\n        for model_spec in models:\n            k = model_spec['k']\n            model_func = model_spec['func']\n            \n            # Set parameter bounds for the nonlinear fitter\n            if k == 2:\n                bounds = ([0, 0], [np.inf, 1.0])\n                # Good initial guess can help convergence, though not strictly necessary here\n                p0 = [1.0, 0.5]\n            else: # k == 3\n                bounds = ([0, 0, -np.inf], [np.inf, 1.0, np.inf])\n                p0 = [1.0, 0.5, 0.0]\n\n            try:\n                popt, _ = curve_fit(model_func, N_data, Rg_data, p0=p0, bounds=bounds, maxfev=10000)\n                \n                Rg_fit = model_func(N_data, *popt)\n                rss = np.sum((Rg_fit - Rg_data)**2)\n\n                # Use a small threshold to handle numerically zero RSS\n                if rss < 1e-25:\n                    log_likelihood_term = -np.inf\n                else:\n                    log_likelihood_term = n * np.log(rss / n)\n                \n                aic = log_likelihood_term + 2 * k\n                \n                if use_aic_fallback:\n                    criterion = aic\n                else:\n                    # AICc calculation\n                    correction_term = (2 * k * (k + 1)) / (n - k - 1)\n                    criterion = aic + correction_term\n\n                fit_results.append({'popt': popt, 'criterion': criterion, 'model': model_spec})\n                \n            except RuntimeError:\n                # If fit fails, assign an infinitely bad criterion value\n                fit_results.append({'popt': [np.nan]*k, 'criterion': np.inf, 'model': model_spec})\n\n        # 3. Select the best model (minimum AICc or AIC)\n        best_fit = min(fit_results, key=lambda x: x['criterion'])\n        \n        # 4. Extract estimated nu from the best model\n        # The exponent nu is always the second parameter (index 1)\n        nu_estimated = best_fit['popt'][1]\n        results_nu.append(nu_estimated)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{nu:.3f}\" for nu in results_nu]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2801617"}]}