{"hands_on_practices": [{"introduction": "分子动力学模拟通常只对宏观系统的一小部分进行建模。为了避免不切实际的表面效应，我们使用周期性边界条件（PBC）。本练习将让你亲手实践 PBC 的基石——最小镜像约定，这对于在周期性系统中正确计算相互作用至关重要。掌握这一点是构建或理解任何 MD 引擎的关键第一步。[@problem_id:2458300]", "problem": "您需要编写一个完整的、可运行的程序，以演示分子动力学 (MD) 模拟中周期性边界条件下最小镜像约定的效果。该程序必须用两种方式计算正交周期性模拟盒子中两个粒子之间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位表示，并四舍五入到恰好六位小数。\n\n背景与基本原理：在采用周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，通过对有限的模拟盒子进行无限平铺来模仿宏观体系的行为。两个粒子之间的物理距离被解释为一个粒子与另一个粒子的任何周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿各轴选择整数倍盒子长度的平移来获得的，该平移使得位移向量的欧几里得范数最小化。您的程序必须实现此规则。\n\n您的任务：\n- 定义一个函数，给定两个以纳米为单位的 $3$ 维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子边长 $(L_x,L_y,L_z)$，该函数返回两个值：\n  1) 朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$（单位为 nm），\n  2) 最小镜像约定距离 $d_{\\text{mic}}$（单位为 nm），该距离通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以使其范数最小化来获得。\n- 将盒子视为正交且轴对齐。\n- 粒子位置可能位于主盒子区间之外。您的实现必须仍然能利用周期性正确计算出 $d_{\\text{mic}}$。\n- 为使您的实现清晰，还请在程序中包含一个多行伪代码字符串（不打印），概述您所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离必须四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n您的程序必须按规定顺序为以下 $5$ 个测试用例计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小距离分离：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴跨越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子和沿多轴的回绕：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的分离（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位于主盒子区间之外的位置：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的数对列表。每个数对按指定顺序对应一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值均以纳米为单位四舍五入到恰好 $6$ 位小数。输出中不得包含空格。\n- 例如，要求的整体格式类似于 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且恰有 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基本练习，具体涉及分子动力学 (MD) 模拟中周期性边界条件 (PBC) 的实现。PBC 的使用是一种标准且必要的技术，通过模拟少量有限的粒子来近似宏观系统的性质。它减轻了严重的表面效应，否则这些效应将主导小型系统的行为。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所决定。\n\n这个问题提法明确，具有科学依据，并为获得唯一且可验证的解提供了所有必要数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由对应于边长的一组三个正交向量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由向量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它是根据位移向量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出的。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 处有一系列无限的周期性镜像晶格，其中 $n_x、n_y、n_z$ 为任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*周期性镜像之间的最短距离。\n\n数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移向量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是最接近比率 $\\Delta x / L_x$ 的整数时，即可实现此目的。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经过最小镜像约定调整后的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n这个公式正确地将位移向量分量“回绕”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。那么，经过最小镜像约定调整后的完整位移向量 $\\Delta\\mathbf{r}'$ 是：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这个向量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移才有意义。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个调整后位移向量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n所提供的测试用例将使用此既定方法来解决。实现将利用 `numpy` 库进行高效的向量算术运算。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到恰好 $6$ 位小数后报告。对于位移恰好是盒子长度一半的特殊情况，例如 $\\Delta x = L_x/2$，`round` 函数会进行处理。该函数通常会四舍五入到最近的偶数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "分子动力学模拟的核心是求解牛顿运动方程的数值积分算法。积分时间步长 $dt$ 的选择对于模拟的稳定性和准确性至关重要。本实践将通过一个简化模型，让你亲身体验过大的时间步长如何导致系统能量灾难性的“爆炸”，从而揭示计算效率与物理真实性之间的一个基本权衡。[@problem_id:2458247]", "problem": "你需要实现一个基于第一性原理的自洽计算实验，以研究分子动力学（MD）中代表蛋白质刚性简正模的单个一维谐振模式的时间步长稳定性。该系统是一个质量为 $m$ 的粒子，被限制在力常数为 $k$ 的谐波势中，其运动遵循牛顿第二定律。整个过程使用约化的无量纲单位；不要为任何量附加物理单位。\n\n动力学行为由牛顿第二定律 $m \\,\\ddot{x}(t) = - k \\, x(t)$ 定义，初始条件为 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$。总能量为 $E(t) = \\tfrac{1}{2} m \\,\\dot{x}(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$。对于给定的离散时间步长 $dt$，在总模拟时间 $T$ 内模拟其运动，并在此轨迹中监测 $E(t)$。\n\n对于一个选定的 $dt$，如果在任何模拟步骤中发生以下三个事件中的任何一个，则定义为发生了“爆炸”：\n- 计算出的总能量 $E(t)$ 变为非有限值（即，不是一个实数、有限的数）。\n- 相对能量误差超过指定的容差，即在模拟结束前的任何时间 $t$，有 $\\lvert E(t) - E(0) \\rvert / E(0) > \\varepsilon$。\n- 位置的绝对值超过一个根据初始能量导出的预设界限，即对于任何 $t$，有 $\\lvert x(t) \\rvert > B \\, A_0$，其中 $A_0 = \\sqrt{2 E(0)/k}$。\n\n对于下方的每个测试用例，都给你一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots, dt_n]$。对每个测试用例，按给定顺序分别为每个 $dt_i$ 模拟系统，并找出列表中导致上述定义下发生爆炸的最小 $dt_i$。如果所列的 $dt_i$ 都没有导致爆炸，则返回哨兵值 $-1.0$。\n\n使用以下四个测试用例。下方的所有符号和数字都应被解释为约化的无量纲单位。\n\n测试用例 1:\n- 参数：$m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）：$[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$。\n\n测试用例 2:\n- 参数：$m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）：$[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$。\n\n测试用例 3:\n- 参数：$m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$。\n- 要测试的时间步长（按升序排列）：$[0.50, 1.00, 2.00, 3.00, 3.50]$。\n\n测试用例 4:\n- 参数：$m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）：$[0.02, 0.10, 0.19, 0.20, 0.25]$。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。每个结果都必须是一个浮点数，四舍五入到六位小数，并与上述测试用例的顺序相同。例如，如果四个测试用例的结果是 $r_1$, $r_2$, $r_3$ 和 $r_4$，你的程序必须精确打印\n\"[r1,r2,r3,r4]\"\n其中每个 $r_i$ 格式化为六位小数，无额外文本。\n\n角度量，如果在内部出现，必须以弧度处理。此问题中的所有值通过构造都是无量纲的，因此输出中不应显示任何物理单位。", "solution": "该问题要求进行一个计算实验，以确定一维谐振子数值积分方案的稳定性极限，该谐振子可作为分子动力学（MD）模拟中刚性振动模式的模型。此问题是适定的，并有科学依据。它构成了对数值积分稳定性的直接测试，这是计算科学中的一个基本概念。\n\n系统由简谐振子的运动方程描述：\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$k$ 是力常数，$x(t)$ 是位置。此振子的角频率是 $\\omega = \\sqrt{k/m}$。动力学行为将使用离散时间步长 $dt$ 从初始条件 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$ 开始演化。\n\n问题陈述并未指定数值积分算法。对于牛顿力学的MD模拟，Velocity-Verlet算法是一个标准、广泛使用且鲁棒的选择，因为它具有时间可逆性和辛性质，这带来了良好的长期能量守恒特性。因此，Velocity-Verlet积分器是适合实现的算法。\n\nVelocity-Verlet算法包括以下步骤，用于将系统从时间 $t$ 推进到 $t+dt$：\n1.  计算半步速度：\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  将位置更新到完整的新时间步：\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  计算新位置处的加速度。加速度由力 $F(x) = -kx$ 导出，所以 $a(x) = F(x)/m = -(k/m)x$:\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  计算新时间的全步速度：\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\n对于每个测试用例，我们都有一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots]$。任务是从此列表中找到导致模拟变得不稳定或“爆炸”的最小 $dt_i$。对于给定的 $dt$，模拟运行总时间 $T$，对应于 $N_{steps} = \\lfloor T/dt \\rfloor$ 个积分步数。\n\n在模拟循环开始之前，我们必须为爆炸判据建立基准。初始总能量 $E(0)$ 计算如下：\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\n问题指出，对于所有测试用例，$x_0$、$v_0$、$m$ 和 $k$ 均为正值，确保 $E(0) > 0$。特征振幅 $A_0$ 则定义为：\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\n这个 $A_0$ 代表了精确解析解中的最大位移。\n\n模拟通过迭代Velocity-Verlet算法 $N_{steps}$ 次来进行。每步之后，我们获得新状态 $(x(t+dt), v(t+dt))$ 并检查三个爆炸条件：\n1.  **能量的有限性**：新步骤的总能量 $E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$ 必须是一个有限的实数。在计算上，通过验证该值是否不是 `NaN` （非数字）或无穷大来检查。此条件可检测灾难性的数值溢出。\n2.  **相对能量守恒**：当前能量与初始能量的相对偏差不得超过容差 $\\varepsilon$。\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)} > \\varepsilon\n    $$\n    此条件检测数值积分误差何时导致总能量出现显著的、非物理的漂移，即使轨迹尚未发散到无穷大。\n3.  **位置界限**：位置的绝对值不得超过特征振幅的一个较大倍数。\n    $$\n    \\lvert x(t+dt) \\rvert > B \\cdot A_0\n    $$\n    这是另一个用于检查轨迹发散的实用方法，即粒子逃逸到离势能最小值非物理的大距离处。\n\n每个测试用例的总体流程如下：\n遍历所提供的时间步长列表 $dt_i$（已按升序排序）。对于每个 $dt_i$：\n- 运行一个总时间为 $T$ 的完整模拟。\n- 在模拟的每一步，检查三个爆炸条件。\n- 如果在模拟过程中的任何时刻满足任一条件，则认为此 $dt_i$ 的模拟是不稳定的。此 $dt_i$ 即为该测试用例的结果，然后我们继续处理下一个测试用例。\n- 如果模拟在时间 $T$ 内完成且未发生任何爆炸，则认为此 $dt_i$ 是稳定的。然后我们继续测试列表中的下一个 $dt_i$。\n\n如果给定测试用例的列表中所有时间步长都导致稳定的模拟，则该测试用例的结果为哨兵值 $-1.0$。\n\n实现将包括一个主函数，该函数遍历所有测试用例。此函数将为每个测试用例调用一个子函数，该子函数再遍历提供的 $dt$ 值并调用一个模拟函数。模拟函数实现上述的Velocity-Verlet循环和稳定性检查。最终输出是每个案例的最小爆炸 $dt$ 列表，如果找不到，则为 $-1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) -> bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt <= 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0 > 0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0 > epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x) > x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458247"}, {"introduction": "分子动力学的强大威力之一，在于它能够将微观涨落与宏观热力学性质联系起来。本练习将理论与实践相结合，要求你根据 NVT 模拟中观察到的能量涨落来计算等容热容（$C_v$）。这不仅是涨落-耗散定理的一个生动实例，也展示了我们如何从模拟轨迹中提取可与实验相验证的数据。[@problem_id:2458251]", "problem": "在正则系综（也称为恒定粒子数-体积-温度系综，即NVT系综）中进行的分子动力学（MD）模拟，会为在固定体积和温度下的单个系统产生一个总能量的离散时间序列。在正则系综中，微观态的概率遵循玻尔兹曼分布，其逆温度为 $\\beta = 1/(k_B T)$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。正则配分函数为 $Z(\\beta) = \\sum_i e^{-\\beta E_i}$，热力学平均值则作为相对于此分布的系综期望进行计算。定容热容 $C_v$ 定义为在固定体积下平均能量对温度的导数，$C_v = \\left(\\frac{\\partial \\langle E \\rangle}{\\partial T}\\right)_V$。从这些正则系综的定义和基本微积分出发，请推导出一个将 $C_v$ 与正则系综中总能量的涨落联系起来的表达式。然后，使用来自NVT轨迹的总能量有限时间序列，以数值方式实现该表达式。\n\n您的任务是编写一个完整的、可运行的程序，为每个给定的测试用例，根据能量轨迹计算 $C_v$。计算时需使用系综（总体）的一阶矩和二阶矩（即 $\\langle E \\rangle$ 和 $\\langle E^2 \\rangle$）的估计值，这些估计值通过对轨迹数据进行简单算术平均得到。使用玻尔兹曼常数 $k_B = 1.380\\,649 \\times 10^{-23}$（SI单位）。能量单位为焦耳（Joules），温度单位为开尔文（Kelvin），每个测试用例所需的输出是定容热容，单位为焦耳/开尔文。假设所提供的能量对应于单个系统（而非每摩尔）；不要引入阿伏伽德罗常数。\n\n实现要求：\n- 对于在温度 $T$ 下包含 $N$ 个样本 $E_1, E_2, \\ldots, E_N$ 的轨迹，通过算术平均 $\\frac{1}{N}\\sum_{i=1}^N E_i$ 来估计 $\\langle E \\rangle$，通过 $\\frac{1}{N}\\sum_{i=1}^N E_i^2$ 来估计 $\\langle E^2 \\rangle$。使用这些估计值来计算您推导出的 $C_v$ 表达式。如果能量轨迹的方差为零，则得到的 $C_v$ 必须为 $0$。\n- 最终的 $C_v$ 值以焦耳/开尔文（$\\mathrm{J/K}$）为单位表示。\n- 本任务不涉及角度。\n- 程序必须是自包含的：不要从用户或文件读取输入。\n\n测试套件：\n- 情况A（一般情况，非平凡涨落）：能量为 $[1.0 \\times 10^{-20}, 2.0 \\times 10^{-20}, 3.0 \\times 10^{-20}, 4.0 \\times 10^{-20}]$，温度 $T = 300$。\n- 情况B（零涨落边界情况）：能量为 $[5.0 \\times 10^{-21}, 5.0 \\times 10^{-21}, 5.0 \\times 10^{-21}, 5.0 \\times 10^{-21}, 5.0 \\times 10^{-21}]$，温度 $T = 100$。\n- 情况C（能量有正有负，中等温度）：能量为 $[-1.0 \\times 10^{-21}, 2.0 \\times 10^{-21}, 0.0, 4.0 \\times 10^{-21}, -2.0 \\times 10^{-21}]$，温度 $T = 50$。\n- 情况D（单一样本边缘情况）：能量为 $[1.234 \\times 10^{-20}]$，温度 $T = 300$。\n\n数值与格式要求：\n- 使用 $k_B = 1.380\\,649 \\times 10^{-23}$，单位为 $\\mathrm{J/K}$。\n- 计算每个情况的 $C_v$，单位为 $\\mathrm{J/K}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个数字必须格式化为科学记数法，小数点后保留六位有效数字（例如，$[1.234000\\mathrm{e}{-03},0.000000\\mathrm{e}{+00}]$ 应打印为 [1.234000e-03,0.000000e+00]）。不应打印任何其他文本。\n\n最终结果对于每个用例都必须是正确的，并且必须遵循上述确切的输出格式。", "solution": "问题陈述在科学上是合理的，阐述清晰，并包含了完整解决方案所需的所有信息。因此，我将继续进行推导和实现。\n\n目标是推导一个在正则（NVT）系综框架下，用总能量 $E$ 的涨落表示定容热容 $C_v$ 的表达式，然后编写一个程序，根据给定的能量时间序列来计算它。\n\n定容热容由平均能量 $\\langle E \\rangle$ 对温度 $T$ 的偏导数定义：\n$$\nC_v = \\left(\\frac{\\partial \\langle E \\rangle}{\\partial T}\\right)_V\n$$\n在正则系综中，具有能量 $E_i$ 的微观态 $i$ 的概率由玻尔兹曼分布给出，$P_i = Z^{-1} e^{-\\beta E_i}$，其中 $\\beta = (k_B T)^{-1}$ 是逆温度，$Z = \\sum_i e^{-\\beta E_i}$ 是正则配分函数。玻尔兹曼常数用 $k_B$ 表示。\n\n平均能量 $\\langle E \\rangle$ 是能量的系综平均值：\n$$\n\\langle E \\rangle = \\sum_i E_i P_i = \\frac{\\sum_i E_i e^{-\\beta E_i}}{\\sum_i e^{-\\beta E_i}}\n$$\n统计力学中的一个关键洞见是，分子可以表示为配分函数 $Z$ 对 $\\beta$ 的导数：\n$$\n\\sum_i E_i e^{-\\beta E_i} = -\\frac{\\partial}{\\partial \\beta} \\left(\\sum_i e^{-\\beta E_i}\\right) = -\\frac{\\partial Z}{\\partial \\beta}\n$$\n这使我们能够以更紧凑的形式写出平均能量：\n$$\n\\langle E \\rangle = -\\frac{1}{Z} \\frac{\\partial Z}{\\partial \\beta} = -\\frac{\\partial (\\ln Z)}{\\partial \\beta}\n$$\n为了计算 $C_v$，我们必须对 $\\langle E \\rangle$ 求关于 $T$ 的导数。更方便的做法是首先使用链式法则将微分变量从 $T$ 更改为 $\\beta$：\n$$\n\\frac{\\partial}{\\partial T} = \\frac{d\\beta}{dT} \\frac{\\partial}{\\partial \\beta}\n$$\n从定义 $\\beta = (k_B T)^{-1}$，我们求得导数：\n$$\n\\frac{d\\beta}{dT} = -\\frac{1}{k_B T^2}\n$$\n将此代入 $C_v$ 的定义中：\n$$\nC_v = \\left(-\\frac{1}{k_B T^2}\\right) \\frac{\\partial \\langle E \\rangle}{\\partial \\beta}\n$$\n现在我们必须计算 $\\langle E \\rangle$ 对 $\\beta$ 的导数：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} \\left(\\frac{\\sum_i E_i e^{-\\beta E_i}}{Z}\\right)\n$$\n应用商法则求导可得：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = \\frac{1}{Z^2} \\left[ Z \\left(\\frac{\\partial}{\\partial \\beta} \\sum_i E_i e^{-\\beta E_i}\\right) - \\left(\\sum_i E_i e^{-\\beta E_i}\\right) \\left(\\frac{\\partial Z}{\\partial \\beta}\\right) \\right]\n$$\n方括号中的各项计算如下：\n$$\n\\frac{\\partial}{\\partial \\beta} \\sum_i E_i e^{-\\beta E_i} = \\sum_i (-E_i^2) e^{-\\beta E_i} = - \\sum_i E_i^2 e^{-\\beta E_i}\n$$\n$$\n\\frac{\\partial Z}{\\partial \\beta} = -\\sum_i E_i e^{-\\beta E_i}\n$$\n将这些代回，我们得到：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = \\frac{1}{Z^2} \\left[ Z \\left(-\\sum_i E_i^2 e^{-\\beta E_i}\\right) - \\left(\\sum_i E_i e^{-\\beta E_i}\\right) \\left(-\\sum_j E_j e^{-\\beta E_j}\\right) \\right]\n$$\n通过在求和内部除以 $Z$，我们可以用系综平均 $\\langle E \\rangle$ 和 $\\langle E^2 \\rangle$ 来表示此式：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -\\frac{\\sum_i E_i^2 e^{-\\beta E_i}}{Z} + \\left(\\frac{\\sum_i E_i e^{-\\beta E_i}}{Z}\\right)^2 = -\\langle E^2 \\rangle + \\langle E \\rangle^2\n$$\n这个结果是能量方差 $\\sigma_E^2 = \\langle E^2 \\rangle - \\langle E \\rangle^2$ 的负值。\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -\\sigma_E^2\n$$\n最后，我们将其代回 $C_v$ 的表达式中：\n$$\nC_v = \\left(-\\frac{1}{k_B T^2}\\right) (-\\sigma_E^2) = \\frac{\\sigma_E^2}{k_B T^2}\n$$\n这就导出了最终的著名公式，它将宏观热力学响应函数（$C_v$）与微观涨落（能量方差 $\\sigma_E^2$）联系起来：\n$$\nC_v = \\frac{\\langle E^2 \\rangle - \\langle E \\rangle^2}{k_B T^2}\n$$\n对于数值实现，我们使用来自MD轨迹的 $N$ 个能量值的时间序列 $\\{E_i\\}_{i=1}^N$。系综平均值由其样本对应项估计：能量的期望值 $\\langle E \\rangle$ 由样本均值 $\\bar{E} = \\frac{1}{N}\\sum_{i=1}^N E_i$ 估计，能量平方的期望值 $\\langle E^2 \\rangle$ 由平方的均值 $\\overline{E^2} = \\frac{1}{N}\\sum_{i=1}^N E_i^2$ 估计。因此，分子 $\\langle E^2 \\rangle - \\langle E \\rangle^2$ 由能量样本的总体方差估计。如果能量样本的方差为零，这意味着 $C_v$ 为零，这对于没有热涨落的系统是一个正确的物理结果。对于单一样本轨迹，方差天生为零，导致 $C_v = 0$。\n\n每个测试用例的算法如下：\n1. 给定一个能量数组 $E_{arr}$ 和一个温度 $T$。\n2. 计算能量的方差，$\\sigma_E^2 = \\mathrm{Var}(E_{arr})$。\n3. 使用给定的 $k_B$ 值计算分母项 $k_B T^2$。\n4. 计算 $C_v = \\sigma_E^2 / (k_B T^2)$。\n此过程将应用于所有提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the constant-volume heat capacity (Cv) from energy trajectories\n    in the canonical (NVT) ensemble for a set of predefined test cases.\n    \"\"\"\n\n    # Define the Boltzmann constant in SI units (J/K).\n    KB = 1.380649e-23\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (list of energies in Joules, temperature in Kelvin).\n    test_cases = [\n        # Case A: general, nontrivial fluctuations\n        (np.array([1.0e-20, 2.0e-20, 3.0e-20, 4.0e-20]), 300.0),\n        # Case B: zero fluctuations boundary\n        (np.array([5.0e-21, 5.0e-21, 5.0e-21, 5.0e-21, 5.0e-21]), 100.0),\n        # Case C: energies with sign changes and moderate temperature\n        (np.array([-1.0e-21, 2.0e-21, 0.0, 4.0e-21, -2.0e-21]), 50.0),\n        # Case D: single-sample edge case\n        (np.array([1.234e-20]), 300.0),\n    ]\n\n    results = []\n    for energies, temperature in test_cases:\n        # The constant-volume heat capacity Cv is related to the variance of the\n        # total energy (sigma_E^2) by the formula:\n        # Cv = sigma_E^2 / (k_B * T^2)\n        # where sigma_E^2 = <E^2> - <E>^2.\n        # This is equivalent to the population variance of the energy samples.\n        # numpy.var calculates the population variance by default (ddof=0).\n        \n        # 1. Calculate the variance of the energy.\n        # For a single sample, the variance is 0.\n        # For a constant array, the variance is 0.\n        energy_variance = np.var(energies)\n\n        # 2. Denominator is k_B * T^2.\n        denominator = KB * temperature**2\n\n        # 3. Calculate Cv. If variance is zero, Cv is zero.\n        # This naturally handles cases B and D.\n        if energy_variance == 0.0:\n            cv = 0.0\n        else:\n            cv = energy_variance / denominator\n        \n        results.append(cv)\n\n    # Format the results into a single string as specified.\n    # Each number is formatted in scientific notation with 6 decimal places.\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2458251"}]}