{"hands_on_practices": [{"introduction": "在进行实际的量子化学计算时，能够准确解读和选择基组是至关重要的一步。Pople风格的基组表示法，如 $6-31+G(d,p)$，是一种简洁而强大的语言，它精确地描述了对原子轨道基函数的扩展。这项练习将帮助你掌握这种表示法，通过将抽象的符号翻译成对重原子和氢原子所添加的具体的极化和弥散函数的集合，从而确保计算设置的准确性 [@problem_id:2796127]。", "problem": "您正在使用Pople分裂价高斯型轨道(GTO)基组，准备对一个主族阴离子和一个氢键复合物进行从头计算。该基组的标记是$\\text{6-31+G(d,p)}$。根据Pople风格标记法的标准语义，确定相对于母基组$\\text{6-31G}$，在非氢（“重”）原子和氢原子上确切添加了哪些额外的壳层，以及每个这样添加的壳层包含多少个高斯原函数。您的推理应基于以下广为接受的事实：极化函数是角动量高于给定原子上已占据价空间最低要求的GTO；弥散函数是与已占据价空间具有相同角动量的低指数GTO，可改善弱束缚电子密度的径向灵活性；符号“$+$”仅为重原子增加弥散函数，而“$++$”则为重原子和氢原子都增加弥散函数；在Pople基组中，每个指定的极化或弥散“组”都是以每个原子上每个角动量添加一个非收缩原函数的方式实现的。\n\n哪个选项是正确的？\n\nA. 重原子：添加$1$个非收缩的$d$型极化原函数，并添加$1$个弥散$s$原函数和$1$个弥散$p$原函数；氢原子：添加$1$个非收缩的$p$型极化原函数；氢原子上没有弥散原函数。\n\nB. 重原子：添加$1$个非收缩的$d$型极化原函数，且仅添加$1$个弥散$s$原函数；氢原子：添加$1$个弥散$s$原函数；氢原子上没有极化函数。\n\nC. 重原子：添加$1$个非收缩的$d$型和$1$个非收缩的$p$型极化原函数，并添加$1$个弥散$s$原函数；氢原子：添加$1$个非收缩的$d$型极化原函数。\n\nD. 重原子：添加$1$个非收缩的$f$型极化原函数，并添加$1$个弥散$s$原函数和$1$个弥散$p$原函数；氢原子：添加$1$个非收缩的$p$型极化原函数和$1$个弥散$s$原函数。\n\nE. 重原子：添加$1$个非收缩的$d$型极化原函数；氢原子：添加$1$个非收缩的$p$型极化原函数；重原子上的弥散增强包括每个原子$2$个$s$原函数和$2$个$p$原函数；氢原子上没有弥散原函数。", "solution": "对此问题的分析必须严格遵守理论化学的既定原则。首先，必须验证问题陈述本身的科学合理性和逻辑一致性。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n-   **系统**：一个主族阴离子和一个氢键复合物。\n-   **方法**：从头计算。\n-   **基组**：Pople分裂价高斯型轨道(GTO)基组，具体标记为$\\text{6-31+G(d,p)}$。\n-   **目标**：确定在母基组$\\text{6-31G}$的基础上，为非氢（“重”）原子和氢原子添加了哪些额外的壳层，包括每个添加的壳层所包含的高斯原函数数量。\n-   **提供的定义和规则**：\n    1.  极化函数是角动量高于给定原子上已占据价空间最低要求的GTO。\n    2.  弥散函数是与已占据价空间具有相同角动量的低指数GTO。\n    3.  符号“$+$”仅为重原子增加弥散函数。\n    4.  符号“$++$”则为重原子和氢原子都增加弥散函数。\n    5.  在Pople基组中，每个指定的极化或弥散“组”都是以每个原子上每个角动量添加一个非收缩原函数的方式实现的。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于量子化学中用于Pople风格基组的标准标记法和定义。对极化和弥散函数的描述，以及像`$+$`和`(d,p)`等符号的含义，都与该领域普遍接受的惯例一致。选择的体系（阴离子、氢键复合物）正确地说明了使用此类函数来描述弥散电子密度和电荷分布畸变的动机。该问题在科学上是合理的。\n-   **适定性**：问题精确无歧义。根据题目明确提供的Pople标记法的标准语义，可以推导出一个唯一的、确定的解。\n-   **客观性**：问题以客观、技术性的语言陈述，不含任何主观或非科学内容。\n\n**步骤 3：结论与行动**\n问题陈述在科学上是合理的、适定的、客观的且内部一致。它包含了推导唯一答案所需的所有必要信息。因此，该问题是**有效的**。我将继续进行解答。\n\n**解答推导**\n\n任务是分解基组标记$\\text{6-31+G(d,p)}$，并确定在基础的$\\text{6-31G}$基组上添加了哪些函数。我们将按照标准惯例，分别分析`+G`和`(d,p)`这两个部分。\n\n1.  **极化函数分析：`(d,p)`**\n    标记 `(d,p)` 指定了极化函数的添加。逗号前的函数适用于重（非氢）原子，逗号后的函数适用于氢原子。\n    -   **重原子**：符号`d`表示添加$d$型极化函数。如所提供的规则所述，极化函数拥有比价轨道更高的角动量($L$)。对于主族重原子（例如，碳、氧、氮），价壳层由$s$($L=0$)和$p$($L=1$)轨道组成。下一个更高的角动量是$d$($L=2$)。问题陈述中指出，每个指定的组都是一个非收缩原函数。因此，对于每个重原子，会添加**一个非收缩的d型原函数壳层**。\n    -   **氢原子**：逗号后的符号`p`表示向氢原子添加$p$型极化函数。对于氢，价壳层由一个$s$轨道($L=0$)组成。下一个更高的角动量是$p$($L=1$)。因此，对于每个氢原子，会添加**一个非收缩的p型原函数壳层**。\n\n2.  **弥散函数分析：`+G`**\n    位于`G`前的`+`符号表示添加了弥散函数。\n    -   **重原子**：问题明确指出，单个`+`仅为**重原子**增加弥散函数。它还指出，弥散函数与已占据价空间具有相同的角动量。对于主族重原子，价轨道是s型和p型。因此，必须同时添加s型和p型的弥散函数。根据“每个‘组’都是一个非收缩原函数”的规则，这意味着向每个重原子添加**一个非收缩弥散s型原函数**和**一个非收缩弥散p型原函数**。\n    -   **氢原子**：问题明确指出`+`符号仅适用于重原子。要向氢原子添加弥散函数，需要使用`++`标记。因此，**不会向氢原子添加任何弥散函数**。\n\n**$\\text{6-31G}$基组的增加项总结：**\n-   **在每个重原子上**：一个非收缩$d$型极化原函数，一个非收缩弥散$s$型原函数，以及一个非收缩弥散$p$型原函数。\n-   **在每个氢原子上**：一个非收缩$p$型极化原函数。\n\n根据这个正确的推导，我们现在来评估所提供的选项。\n\n**逐项选项分析**\n\n-   **A. 重原子：添加$1$个非收缩的$d$型极化原函数，并添加$1$个弥散$s$原函数和$1$个弥散$p$原函数；氢原子：添加$1$个非收缩的$p$型极化原函数；氢原子上没有弥散原函数。**\n    此陈述与我们推导出的结论完全匹配。它正确地指出了重原子上的$d$极化、氢原子上的$p$极化、重原子上同时添加$s$和$p$弥散函数，以及氢原子上没有弥散函数。根据题目的前提，每个添加的壳层类型的原函数数量（$1$个）也是正确的。\n    **结论：正确。**\n\n-   **B. 重原子：添加$1$个非收缩的$d$型极化原函数，且仅添加$1$个弥散$s$原函数；氢原子：添加$1$个弥散$s$原函数；氢原子上没有极化函数。**\n    这个选项在多个方面都是错误的。对于重原子，它遗漏了必要的弥散$p$原函数。对于氢原子，它错误地添加了一个弥散$s$原函数（这将需要`++`）并且错误地遗漏了`(d,p)`所表示的$p$型极化函数。\n    **结论：不正确。**\n\n-   **C. 重原子：添加$1$个非收缩的$d$型和$1$个非收缩的$p$型极化原函数，并添加$1$个弥散$s$原函数；氢原子：添加$1$个非收缩的$d$型极化原函数。**\n    这个选项存在根本性错误。它错误地为重原子添加了$p$型极化函数。它遗漏了重原子的弥散$p$型函数。它错误地为氢原子添加了$d$型极化函数，这与`(d,p)`的含义不符。\n    **结论：不正确。**\n\n-   **D. 重原子：添加$1$个非收缩的$f$型极化原函数，并添加$1$个弥散$s$原函数和$1$个弥散$p$原函数；氢原子：添加$1$个非收缩的$p$型极化原函数和$1$个弥散$s$原函数。**\n    这个选项不正确。它为重原子指定了$f$型极化，而标记是`(d,p)`。它还错误地为氢原子添加了弥散函数。\n    **结论：不正确。**\n\n-   **E. 重原子：添加$1$个非收缩的$d$型极化原函数；氢原子：添加$1$个非收缩的$p$型极化原函数；重原子上的弥散增强包括每个原子$2$个$s$原函数和$2$个$p$原函数；氢原子上没有弥散原函数。**\n    这个选项正确地指出了极化函数以及氢原子上没有弥散函数。然而，它错误地描述了重原子上的弥散函数增强。`+`标记添加的是一组弥散函数（一个$s$原函数和一个$p$原函数），而不是两个。一个每个价角动量拥有`2`个弥散原函数的基组会有不同的标记方式，并且与“每个指定的...弥散‘组’都是以一个非收缩原函数的方式实现”的前提相矛盾。\n    **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2796127"}, {"introduction": "理解了基组的构成后，下一步是探索这些函数对分子属性的具体物理影响。极化函数通过提供更高的角动量自由度，使得电子云能够在外电场作用下发生形变，这对于准确描述分子的响应性质至关重要。本练习通过一个简化的微扰理论模型，将添加单个$d$极化函数与静态偶极极化率$\\alpha_{kk}$的增加直接联系起来，从而将抽象的基函数概念与可测量的物理性质联系起来，深刻揭示其在分子响应计算中的核心作用 [@problem_id:2916115]。", "problem": "考虑当一个角动量为$d$的单极化函数被添加到水分子的氧原子中心时，静态偶极极化率的变化。该问题按如下最小化方式建模。使用哈特里原子单位（a.u.），其中基本电荷、约化普朗克常数和电子质量均设为 $1$，偶极矩单位为玻尔（$a_0$），能量单位为哈特里（$E_h$），极化率单位为 $a_0^3$。\n\n从静态偶极极化率张量$\\alpha_{ij}$的定义出发，即电子基态能量$E$关于均匀电场分量$\\mathcal{E}_i$的二阶导数，并在零场下求值，也即$\\alpha_{ij} = -\\left.\\frac{\\partial^2 E}{\\partial \\mathcal{E}_i \\partial \\mathcal{E}_j}\\right|_{\\mathcal{E}=0}$。使用非简并定态 Rayleigh–Schrödinger 微扰理论和标准的态求和表示作为基本依据，推导当通过添加一个单一、正交归一化的笛卡尔$d$型高斯型轨道（GTO）引入一个以氧为中心的新的虚轨道通道时，沿一个固定的分子轴$k$的单个张量分量$\\Delta \\alpha_{kk}$的最低阶表达式。\n\n采用以下具有物理动机且自洽的建模假设，以使问题明确且可数值检验，除此处列出的近似外，不引入任何其他近似：\n- 变化$\\Delta \\alpha_{kk}$主要由一个被占据的、具有$p$特征的、以氧为中心的孤对电子状分子轨道$\\lvert p \\rangle$与由添加的$d$型 GTO 支持的新虚轨道组态$\\lvert d \\rangle$之间的混合所主导。所有其他占据-虚轨道通道均被假定为不变，因此在差值中被抵消。\n- 这两个组态之间的能隙是一个正常数$\\Delta E = E_d - E_p > 0$，以$E_h$为单位，并针对每个测试用例指定。\n- 沿$k$轴的跃迁偶极矩阵元与所添加的笛卡尔$d$型 GTO 的空间延展成比例。具体而言，设矩阵元大小为$\\mu_{pd}^{(k)} = S\\,\\zeta_d^{-1/2}$，其中$\\zeta_d > 0$是$d$函数的高斯指数，单位为$a_0^{-2}$，而$S > 0$是一个无量纲的振幅，用于捕捉氧上沿$k$轴的有效$p$特征以及角向耦合。\n- 假设所涉及的态是正交归一的，并忽略电场一阶以上弛豫效应，这与线性响应理论一致。\n\n你的任务是：\n1. 仅使用所述的基本依据和建模假设，推导$\\Delta \\alpha_{kk}$关于$\\Delta E$、$\\zeta_d$和$S$的显式表达式，并确定其符号。你的推导必须基于一阶微扰密度观点和态求和图像，并且必须在逻辑上将$\\mu_{pd}^{(k)}$的标度关系与观察到的$\\Delta \\alpha_{kk}$对$\\zeta_d$和$\\Delta E$的依赖关系联系起来。\n2. 实现一个程序，对于下面给定的一小组参数三元组$(\\Delta E, \\zeta_d, S)$，计算你推导出的表达式的值。为每个测试用例生成$\\Delta \\alpha_{kk}$的数值，单位为 $a_0^3$。\n3. 最终输出必须是单行，包含一个 Python 列表字面量，其中包含测试用例的结果，顺序与所列顺序相同，每个值四舍五入到$6$位小数，例如 $[x_1,x_2,x_3]$。\n4. 你需要以$a_0^3$为单位表示结果。\n\n测试套件（每个三元组为 $(\\Delta E, \\zeta_d, S)$，其中 $\\Delta E$ 单位为 $E_h$，$\\zeta_d$ 单位为 $a_0^{-2}$，$S$ 为无量纲）：\n- 用例 A（常规理想路径）：$(0.6, 1.5, 1.1)$。\n- 用例 B（紧凑 $d$ 函数，类边界行为）：$(1.5, 6.0, 1.1)$。\n- 用例 C（弥散 $d$ 函数，边缘情况行为）：$(0.3, 0.5, 1.1)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3]$），其中每个 $r_i$ 是相应测试用例计算出的$\\Delta \\alpha_{kk}$值（单位 $a_0^3$），并四舍五入到 $6$ 位小数。", "solution": "首先对问题陈述进行验证程序。\n\n步骤 1：提取的已知条件。\n- 静态偶极极化率张量的定义为 $\\alpha_{ij} = -\\left.\\frac{\\partial^2 E}{\\partial \\mathcal{E}_i \\partial \\mathcal{E}_j}\\right|_{\\mathcal{E}=0}$。\n- 理论基础是非简并定态 Rayleigh–Schrödinger 微扰理论和态求和表示。\n- 所求量是在水分子氧原子上添加一个单一笛卡尔 $d$ 型高斯型轨道（GTO）后，极化率张量分量 $\\Delta \\alpha_{kk}$ 的变化。\n- 假设 1：变化 $\\Delta \\alpha_{kk}$ 完全由一个被占据的 $p$ 型分子轨道（MO）$\\lvert p\\rangle$ 和一个新的 $d$ 型虚轨道（MO）$\\lvert d\\rangle$ 之间引入的新激发通道引起。\n- 假设 2：这两个态之间的能隙是一个正常数 $\\Delta E = E_d - E_p > 0$。\n- 假设 3：这些态之间沿 $k$ 轴的跃迁偶极矩阵元的大小由模型 $\\mu_{pd}^{(k)} = S\\,\\zeta_d^{-1/2}$ 给出，其中 $\\zeta_d > 0$ 是 GTO 指数，$S > 0$ 是一个无量纲振幅。\n- 假设 4：这些态是正交归一的，并且忽略了一阶以上的电子弛豫效应。\n- 所有计算均在哈特里原子单位中进行，极化率以 $a_0^3$ 为单位表示。\n- $(\\Delta E, \\zeta_d, S)$ 的测试用例：用例 A $(0.6, 1.5, 1.1)$；用例 B $(1.5, 6.0, 1.1)$；用例 C $(0.3, 0.5, 1.1)$。\n\n步骤 2：验证。\n该问题具有科学依据，基于量子化学的标准原理（微扰理论、基组、分子性质）。其简化假设虽然大胆，但具有物理动机，旨在创建一个易于处理的模型，并且已明确说明。该问题是适定的、客观的、自洽的，提供了推导唯一表达式和计算所需数值的所有必要信息。它不违反任何基本定律，也不是无足轻重或定义不明确的。\n\n步骤 3：结论。\n该问题有效。将提供一个合理的解决方案。\n\n推导从静态偶极极化率的态求和（SOS）表达式开始，该表达式是二阶 Rayleigh-Schrödinger 微扰理论应用于静电场中分子的直接结果。对于对角分量 $\\alpha_{kk}$，SOS 表达式为：\n$$\n\\alpha_{kk} = 2 \\sum_{n \\neq 0} \\frac{|\\langle \\Psi_0 | \\hat{\\mu}_k | \\Psi_n \\rangle|^2}{E_n - E_0}\n$$\n其中 $\\Psi_0$ 是能量为 $E_0$ 的电子基态，$\\{\\Psi_n\\}_{n \\neq 0}$ 是能量为 $E_n$ 的所有电子激发态的集合，$\\hat{\\mu}_k$ 是电偶极算符的 $k$ 分量。所有量均采用原子单位。\n\n问题陈述指出，添加一个新的 $d$ 型 GTO 会引入一个涉及被占据轨道 $\\lvert p \\rangle$ 和新虚轨道 $\\lvert d \\rangle$ 的单一新虚通道。所有其他占据-虚轨道通道均被假定为不受影响。因此，极化率的变化 $\\Delta \\alpha_{kk}$ 就是这个单一新项对态求和的贡献：\n$$\n\\Delta \\alpha_{kk} = 2 \\frac{|\\langle \\Psi_0 | \\hat{\\mu}_k | \\Psi_{p \\to d} \\rangle|^2}{E_{p \\to d} - E_0}\n$$\n其中 $\\Psi_{p \\to d}$ 是新出现的可及激发态，对应于电子从 $\\lvert p \\rangle$ 跃迁到 $\\lvert d \\rangle$。\n\n现在我们应用建模假设来计算此表达式。\n1. 能量分母 $E_{p \\to d} - E_0$ 是激发能。在分子轨道图像中，这可以近似为轨道能量之差。问题直接将此值作为能隙 $\\Delta E = E_d - E_p$ 提供。\n2. 分子包含跃迁偶极矩的平方，$|\\langle \\Psi_0 | \\hat{\\mu}_k | \\Psi_{p \\to d} \\rangle|^2$。在单粒子模型中，这个态-态矩阵元与轨道矩阵元 $\\mu_{pd}^{(k)} = \\langle p | \\hat{\\mu}_k | d \\rangle$ 成正比。问题为该有效跃迁矩的大小提供了一个模型：$|\\mu_{pd}^{(k)}| = S \\zeta_d^{-1/2}$。\n\n将这些模型参数代入 $\\Delta \\alpha_{kk}$ 的表达式中：\n$$\n\\Delta \\alpha_{kk} = 2 \\frac{(S \\zeta_d^{-1/2})^2}{\\Delta E}\n$$\n这简化为最终表达式：\n$$\n\\Delta \\alpha_{kk} = \\frac{2 S^2}{\\Delta E \\cdot \\zeta_d}\n$$\n这是 $\\Delta \\alpha_{kk}$ 关于给定参数 $\\Delta E$、$\\zeta_d$ 和 $S$ 的显式表达式。\n\n为确定 $\\Delta \\alpha_{kk}$ 的符号，我们注意到根据定义 $S > 0$，因此 $S^2 > 0$。能隙 $\\Delta E > 0$ 和高斯指数 $\\zeta_d > 0$ 也被给定为正常数。由于表达式中的所有因子都是正的，所以极化率的变化 $\\Delta \\alpha_{kk}$ 必定是正的。这在物理上是正确的：为电子密度响应外部电场增加一个极化通道，必然会增加系统的极化率。\n\n该推导也阐明了 $\\Delta \\alpha_{kk}$ 对模型参数的依赖性。与能隙成反比的关系，$\\Delta \\alpha_{kk} \\propto 1/\\Delta E$，是二阶微扰理论的典型特征：较小的能隙导致更强的耦合和更大的响应。与指数成反比的关系，$\\Delta \\alpha_{kk} \\propto 1/\\zeta_d$，源于跃迁偶极矩的标度。较小的指数 $\\zeta_d$ 意味着一个空间上更弥散的 GTO。一个弥散的函数具有更大的空间延展，这导致依赖于位置的偶极算符 $\\mu_{pd}^{(k)}$ 的矩阵元值更大。这个更大的跃迁矩反过来又对极化率产生更大的贡献，这与已知的事实相符，即弥散基函数对于准确描述极化率至关重要。\n\n现在，问题简化为使用推导出的公式对所提供的测试用例进行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the change in static dipole polarizability based on a derived\n    two-level model and provided test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (delta_E, zeta_d, S)\n    test_cases = [\n        (0.6, 1.5, 1.1),  # Case A: General happy path\n        (1.5, 6.0, 1.1),  # Case B: Tight d function, boundary-like behavior\n        (0.3, 0.5, 1.1),  # Case C: Diffuse d function, edge-case behavior\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case\n        delta_E, zeta_d, S = case\n\n        # The derived formula for the change in polarizability is:\n        # delta_alpha_kk = (2 * S^2) / (delta_E * zeta_d)\n        # All inputs are in Hartree atomic units, so the result is in the\n        # atomic unit of polarizability, which is a_0^3.\n        delta_alpha_kk = (2 * S**2) / (delta_E * zeta_d)\n\n        # Append the result formatted to 6 decimal places as required.\n        results.append(f\"{delta_alpha_kk:.6f}\")\n\n    # Final print statement in the exact required format: [r1,r2,r3]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2916115"}, {"introduction": "除了描述分子响应，基函数在精确刻画电子态的空间特征方面也扮演着关键角色，特别是对于弥散函数和激发态的研究。弥散函数对于描述空间延展的、弱束缚的电子态（如里德堡态）至关重要。本练习将指导你通过计算分子轨道的二阶矩 $\\langle r^{2} \\rangle$ 和弥散函数的贡献，来定量分析目标轨道的空间特性。通过这种方式，你将学会如何直接从波函数的数学构成出发，对其进行物理分类（价层态 vs. 里德堡态），这是解读和验证激发态计算结果的一项核心技能 [@problem_id:2916133]。", "problem": "要求您设计并实现一个数学上自洽的程序，通过检查在有和没有增广弥散函数的情况下氨分子玩具模型中的附着密度和轨道特征，来区分价激发和里德堡激发。整个过程使用原子单位，其中长度以玻尔（bohr）为单位，指数以$\\text{bohr}^{-2}$为单位。所有最终的二阶矩半径必须以$\\text{bohr}^{2}$表示。\n\n该模型如下。考虑一个以原点为中心的归一化 $s$ 型高斯型轨道（GTO）的单中心基组，每个基函数形式为 $\\chi_{p}(\\mathbf{r}) = N(\\alpha_{p}) \\exp(-\\alpha_{p} r^{2})$，其中 $r = \\|\\mathbf{r}\\|$，归一化因子为 $N(\\alpha) = \\left(\\dfrac{2\\alpha}{\\pi}\\right)^{3/4}$。一个分子轨道 $\\phi(\\mathbf{r})$ 是这些基函数的线性组合，$\\phi(\\mathbf{r}) = \\sum_{p=1}^{M} c_{p} \\chi_{p}(\\mathbf{r})$，其中 $M$ 是基元的数量。从一个占据轨道到一个虚拟轨道的单电子激发的附着密度被认为是 $|\\phi_{\\mathrm{virt}}(\\mathbf{r})|^{2}$，它编码了激发后电子的空间特征。\n\n您可以使用的、针对同一中心的 $s$ 型函数的基本高斯积分结果如下：\n- 重叠积分 $S_{pq} = \\int \\chi_{p}(\\mathbf{r}) \\chi_{q}(\\mathbf{r}) \\, d^{3}r = \\left(\\dfrac{2\\sqrt{\\alpha_{p}\\alpha_{q}}}{\\alpha_{p}+\\alpha_{q}}\\right)^{3/2}$。\n- 二阶矩积分 $R^{(2)}_{pq} = \\int r^{2}\\,\\chi_{p}(\\mathbf{r}) \\chi_{q}(\\mathbf{r}) \\, d^{3}r = S_{pq}\\,\\dfrac{3}{2(\\alpha_{p}+\\alpha_{q})}$。\n\n给定一个系数向量 $\\mathbf{c} \\in \\mathbb{R}^{M}$ 以及矩阵 $S = [S_{pq}]$ 和 $R^{(2)} = [R^{(2)}_{pq}]$，附着密度（等效于虚拟轨道）的二阶矩是\n$$\\langle r^{2} \\rangle_{\\mathrm{attach}} = \\frac{\\mathbf{c}^{\\mathsf{T}} R^{(2)} \\mathbf{c}}{\\mathbf{c}^{\\mathsf{T}} S \\mathbf{c}},$$\n该值必须以$\\text{bohr}^{2}$报告。对于一个指定的弥散基元指标集 $\\mathcal{D}$，轨道的类马力肯弥散分数的定义为\n$$ f_{\\mathrm{diffuse}} = \\frac{\\sum_{p\\in \\mathcal{D}} \\sum_{q=1}^{M} c_{p}\\,c_{q}\\,S_{pq}}{\\sum_{p=1}^{M} \\sum_{q=1}^{M} c_{p}\\,c_{q}\\,S_{pq}}。$$\n\n对于下方的每个测试用例，您将获得：\n- 一个纯价层指数集 $\\{\\alpha_{v}\\}$。\n- 一个增广的弥散指数集 $\\{\\alpha_{d}\\}$，将附加到价层集以形成增广基组。\n- 在增广基组中的两个未归一化系数列表：一个用于占据的价分子轨道 $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}}$，另一个用于虚拟目标轨道 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}}$。\n- 两个阈值 $r^{2}_{\\mathrm{cut}}$（单位为$\\text{bohr}^{2}$）和 $f_{\\mathrm{cut}}$（无量纲，以小数形式表示）。\n\n您的程序必须对每个测试用例执行以下操作：\n1. 通过拼接 $\\{\\alpha_{v}\\}$ 和 $\\{\\alpha_{d}\\}$（先是价层指数，然后是弥散指数）来构建增广基组。使用上述公式为该增广基组构建 $S$ 和 $R^{(2)}$ 矩阵。\n2. 相对于 $S$ 度规，对 $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}}$ 和 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}}$ 进行归一化，即缩放 $\\mathbf{c}$ 使得 $\\mathbf{c}^{\\mathsf{T}} S \\mathbf{c} = 1$。\n3. 使用归一化的 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}}$ 和对应于附加的弥散基元的弥散指标集 $\\mathcal{D}$，计算增广情况下的附着二阶矩 $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}}$ 和弥散分数 $f_{\\mathrm{diffuse}}^{\\mathrm{aug}}$。\n4. 通过丢弃弥散基元并将系数向量截断为价层部分，来构建非增广（纯价层）基组，然后使用纯价层重叠矩阵重新归一化。计算非增广情况下的附着二阶矩 $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{noaug}}$。定义 $f_{\\mathrm{diffuse}}^{\\mathrm{noaug}} = 0$，因为不存在弥散基元。\n5. 当且仅当 $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}} \\ge r^{2}_{\\mathrm{cut}}$ 和 $f_{\\mathrm{diffuse}}^{\\mathrm{aug}} \\ge f_{\\mathrm{cut}}$ 同时满足时，将增广基组中的激发分类为“里德堡”（Rydberg）。否则，将其分类为“价”（valence）。将此分类报告为整数，$1$ 代表里德堡，$0$ 代表价。\n6. 计算 $\\Delta r^{2} = \\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}} - \\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{noaug}}$，单位为$\\text{bohr}^{2}$。\n\n测试套件。使用以下四个测试用例；每个列表按（价层指数、弥散指数、增广基组中的占据轨道系数、增广基组中的虚拟轨道系数、$r^{2}_{\\mathrm{cut}}$、$f_{\\mathrm{cut}}$）的顺序列出：\n- 用例 $1$（典型情况，在增广下表现为强里德堡特性）：\n  - $\\{\\alpha_{v}\\} = \\{1.6, 0.5\\}$, $\\{\\alpha_{d}\\} = \\{0.08, 0.03\\}$,\n  - $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}} = (0.8, 1.0, 0.05, 0.02)$,\n  - $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}} = (0.1, 0.2, 1.0, 0.9)$,\n  - $r^{2}_{\\mathrm{cut}} = 8.0$ $\\text{bohr}^{2}$, $f_{\\mathrm{cut}} = 0.6$。\n- 用例 $2$（类价层虚拟轨道，增广存在但不重要）：\n  - $\\{\\alpha_{v}\\} = \\{1.6, 0.6\\}$, $\\{\\alpha_{d}\\} = \\{0.1\\}$,\n  - $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}} = (0.9, 1.0, 0.0)$,\n  - $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}} = (0.7, 0.8, 0.1)$,\n  - $r^{2}_{\\mathrm{cut}} = 6.0$ $\\text{bohr}^{2}$, $f_{\\mathrm{cut}} = 0.5$。\n- 用例 $3$（价层与弥散特征的临界混合）：\n  - $\\{\\alpha_{v}\\} = \\{1.2, 0.4\\}$, $\\{\\alpha_{d}\\} = \\{0.08\\}$,\n  - $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}} = (0.9, 1.1, 0.05)$,\n  - $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}} = (0.45, 0.50, 0.45)$,\n  - $r^{2}_{\\mathrm{cut}} = 6.0$ $\\text{bohr}^{2}$, $f_{\\mathrm{cut}} = 0.5$。\n- 用例 $4$（具有极度弥散增广的边缘情况）：\n  - $\\{\\alpha_{v}\\} = \\{1.8\\}$, $\\{\\alpha_{d}\\} = \\{0.02\\}$,\n  - $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}} = (1.0, 0.01)$,\n  - $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}} = (0.05, 1.0)$,\n  - $r^{2}_{\\mathrm{cut}} = 12.0$ $\\text{bohr}^{2}$, $f_{\\mathrm{cut}} = 0.8$。\n\n最终输出格式。您的程序必须生成单行，其中包含一个列表，其条目按顺序为每个测试用例的以下内容：\n- $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}}$（浮点数，单位为$\\text{bohr}^{2}$），\n- $f_{\\mathrm{diffuse}}^{\\mathrm{aug}}$（浮点数，无量纲），\n- $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{noaug}}$（浮点数，单位为$\\text{bohr}^{2}$），\n- $f_{\\mathrm{diffuse}}^{\\mathrm{noaug}}$（浮点数，始终为 $0$），\n- $\\Delta r^{2}$（浮点数，单位为$\\text{bohr}^{2}$），\n- 分类整数（$1$ 表示里德堡，$0$ 表示价）。\n\n因此，对于 $4$ 个用例，程序应打印出形如\n$[x_{1},x_{2},\\dots,x_{24}]$\n的单行，其中条目按上述顺序出现。所有二阶矩量都必须以$\\text{bohr}^{2}$为单位，所有分数必须是小数（无百分号）。此问题中不出现角度。计算必须是完全确定性的，并且不需要任何用户输入。", "solution": "所呈现的问题是一个有效且自洽的计算量子化学练习。它要求实现一个简化模型，以基于目标分子轨道的空间广延性来分析和分类电子激发。该模型虽然是一个玩具表示，但建立在量子力学的可靠和标准原则之上，即使用高斯型轨道（GTOs）作为基组，并从此基组中构建的波函数计算电子性质。所有必要的定义、公式和数据都已提供，逻辑上没有矛盾或模糊之处。我们继续进行求解。\n\n模型的基本组成部分是原子基函数、分子轨道（MO）以及物理性质的算符。基组由归一化的、单中心的 $s$ 型高斯型轨道 $\\chi_{p}(\\mathbf{r})$ 组成，由指数 $\\alpha_{p}$ 定义：\n$$ \\chi_{p}(\\mathbf{r}) = \\left(\\frac{2\\alpha_{p}}{\\pi}\\right)^{3/4} \\exp(-\\alpha_{p} r^{2}) $$\n一个分子轨道 $\\phi(\\mathbf{r})$ 是这些基函数的线性组合：\n$$ \\phi(\\mathbf{r}) = \\sum_{p=1}^{M} c_{p} \\chi_{p}(\\mathbf{r}) $$\n其中 $\\mathbf{c} = (c_1, c_2, \\dots, c_M)^{\\mathsf{T}}$ 是在 $M$ 个 GTO 基组中的分子轨道系数向量。\n\n轨道性质的分析需要计算GTO基组中算符的矩阵元。问题提供了重叠矩阵 $S$ 和二阶矩半径矩阵 $R^{(2)}$ 的必要解析公式：\n$$ S_{pq} = \\int \\chi_{p}(\\mathbf{r}) \\chi_{q}(\\mathbf{r}) \\, d^{3}r = \\left(\\frac{2\\sqrt{\\alpha_{p}\\alpha_{q}}}{\\alpha_{p}+\\alpha_{q}}\\right)^{3/2} $$\n$$ R^{(2)}_{pq} = \\int r^{2}\\,\\chi_{p}(\\mathbf{r}) \\chi_{q}(\\mathbf{r}) \\, d^{3}r = S_{pq}\\,\\frac{3}{2(\\alpha_{p}+\\alpha_{q})} $$\n对于由系数向量 $\\mathbf{c}$ 描述的轨道，半径平方的期望值 $\\langle r^2 \\rangle$ 由非正交基中期望值的一般公式给出：\n$$ \\langle r^{2} \\rangle = \\frac{\\int \\phi^{*}(\\mathbf{r}) r^2 \\phi(\\mathbf{r}) \\, d^3r}{\\int \\phi^{*}(\\mathbf{r}) \\phi(\\mathbf{r}) \\, d^3r} = \\frac{\\mathbf{c}^{\\mathsf{T}} R^{(2)} \\mathbf{c}}{\\mathbf{c}^{\\mathsf{T}} S \\mathbf{c}} $$\n分母 $\\mathbf{c}^{\\mathsf{T}} S \\mathbf{c}$ 是分子轨道的范数平方。对于一个归一化的轨道，此分母为 $1$，从而简化了表达式。归一化条件是 $\\mathbf{c}^{\\mathsf{T}} S \\mathbf{c} = 1$。一个未归一化的系数向量 $\\mathbf{c}_{\\mathrm{unnorm}}$ 通过缩放进行归一化：$\\mathbf{c}_{\\mathrm{norm}} = \\mathbf{c}_{\\mathrm{unnorm}} / \\sqrt{\\mathbf{c}_{\\mathrm{unnorm}}^{\\mathsf{T}} S \\mathbf{c}_{\\mathrm{unnorm}}}$。\n\n该问题通过关注虚拟（目标）轨道 $\\phi_{\\mathrm{virt}}$ 的特征来模拟电子激发。附着密度被定义为 $|\\phi_{\\mathrm{virt}}(\\mathbf{r})|^2$，其空间广延性由 $\\langle r^2 \\rangle_{\\mathrm{attach}} = \\langle r^2 \\rangle_{\\phi_{\\mathrm{virt}}}$ 来量化，并作为主要度量。大的 $\\langle r^2 \\rangle$ 表示一个弥散的、类里德堡的轨道，而较小的 $\\langle r^2 \\rangle$ 则表明一个更紧凑的、类价层的轨道。\n\n第二个度量，弥散分数 $f_{\\mathrm{diffuse}}$，量化了一组指定的弥散基函数（那些具有小指数 $\\alpha_p$ 的函数）对分子轨道的贡献。指定的定义是总电子密度的一种类马力肯划分：\n$$ f_{\\mathrm{diffuse}} = \\frac{\\sum_{p\\in \\mathcal{D}} \\sum_{q=1}^{M} c_{p}\\,c_{q}\\,S_{pq}}{\\mathbf{c}^{\\mathsf{T}} S \\mathbf{c}} $$\n其中 $\\mathcal{D}$ 是弥散基元的指标集。对于一个归一化的分子轨道，分母为 $1$。分子可以高效地计算：令 $\\mathbf{v} = S \\mathbf{c}$；则分子为 $\\sum_{p \\in \\mathcal{D}} c_p v_p$。\n\n每个测试用例的计算过程如下：\n1.  **构建基组和矩阵**：\n    增广基组通过拼接价层指数 $\\{\\alpha_v\\}$ 和弥散指数 $\\{\\alpha_d\\}$ 形成。设 $N_v$ 为价函数的数量，$M$ 为函数的总数。构建大小为 $M \\times M$ 的增广重叠矩阵 $S^{\\mathrm{aug}}$ 和二阶矩矩阵 $(R^{(2)})^{\\mathrm{aug}}$。纯价层矩阵 $S^{\\mathrm{noaug}}$ 和 $(R^{(2)})^{\\mathrm{noaug}}$ 是增广矩阵的左上角 $N_v \\times N_v$ 子块。\n\n2.  **处理轨道**：\n    问题为占据轨道和虚拟轨道提供了未归一化的系数向量 $\\mathbf{c}_{\\mathrm{occ}}^{\\mathrm{aug}}$ 和 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}}$。指令要求对两者进行归一化。必须注意，只有虚拟轨道的性质用于最终的分类和输出。处理占据轨道是按指令执行的，但仅作为程序性检查。\n    \n    对于虚拟轨道：\n    a.  **增广情况**：使用 $S^{\\mathrm{aug}}$ 对向量 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}}$ 进行归一化。使用归一化后的向量，计算 $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}}$ 和 $f_{\\mathrm{diffuse}}^{\\mathrm{aug}}$。用于弥散分数的集合 $\\mathcal{D}$ 由对应于 $\\{\\alpha_d\\}$ 的指标组成。\n    b.  **非增广情况**：将向量 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{aug}}$ 截断为其前 $N_v$ 个分量，得到 $\\mathbf{c}_{\\mathrm{virt}}^{\\mathrm{noaug}}$。使用 $S^{\\mathrm{noaug}}$ 对该向量进行重新归一化。然后，计算 $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{noaug}}$。根据定义，由于此基组中没有弥散函数，所以 $f_{\\mathrm{diffuse}}^{\\mathrm{noaug}} = 0$。\n\n3.  **分类和报告**：\n    如果 $\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}} \\ge r^{2}_{\\mathrm{cut}}$ 和 $f_{\\mathrm{diffuse}}^{\\mathrm{aug}} \\ge f_{\\mathrm{cut}}$ 同时满足，则激发被分类为里德堡（输出 $1$）。否则，分类为价（输出 $0$）。计算二阶矩的变化量 $\\Delta r^{2} = \\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}} - \\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{noaug}}$。对每个用例，将最终的六个量——$\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{aug}}$、$f_{\\mathrm{diffuse}}^{\\mathrm{aug}}$、$\\langle r^{2} \\rangle_{\\mathrm{attach}}^{\\mathrm{noaug}}$、$f_{\\mathrm{diffuse}}^{\\mathrm{noaug}}$、$\\Delta r^{2}$ 和分类整数——汇编起来。\n\n这种将基本量子化学原理系统地应用于所提供数据的方法，产生了一个确定性且可验证的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the quantum chemistry problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (happy path, strongly Rydberg under augmentation)\n        {\n            \"alpha_v\": [1.6, 0.5], \"alpha_d\": [0.08, 0.03],\n            \"c_occ_aug\": [0.8, 1.0, 0.05, 0.02],\n            \"c_virt_aug\": [0.1, 0.2, 1.0, 0.9],\n            \"r2_cut\": 8.0, \"f_cut\": 0.6\n        },\n        # Case 2 (valence-like virtual, augmentation present but unimportant)\n        {\n            \"alpha_v\": [1.6, 0.6], \"alpha_d\": [0.1],\n            \"c_occ_aug\": [0.9, 1.0, 0.0],\n            \"c_virt_aug\": [0.7, 0.8, 0.1],\n            \"r2_cut\": 6.0, \"f_cut\": 0.5\n        },\n        # Case 3 (borderline mixture of valence and diffuse character)\n        {\n            \"alpha_v\": [1.2, 0.4], \"alpha_d\": [0.08],\n            \"c_occ_aug\": [0.9, 1.1, 0.05],\n            \"c_virt_aug\": [0.45, 0.50, 0.45],\n            \"r2_cut\": 6.0, \"f_cut\": 0.5\n        },\n        # Case 4 (edge case with extremely diffuse augmentation)\n        {\n            \"alpha_v\": [1.8], \"alpha_d\": [0.02],\n            \"c_occ_aug\": [1.0, 0.01],\n            \"c_virt_aug\": [0.05, 1.0],\n            \"r2_cut\": 12.0, \"f_cut\": 0.8\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = process_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef build_matrices(alphas):\n    \"\"\"\n    Constructs overlap (S) and second-moment-radius (R2) matrices.\n    \n    Args:\n        alphas (list of float): List of Gaussian exponents.\n        \n    Returns:\n        (np.ndarray, np.ndarray): The S and R2 matrices.\n    \"\"\"\n    n = len(alphas)\n    S = np.zeros((n, n))\n    R2 = np.zeros((n, n))\n    \n    for i in range(n):\n        for j in range(n):\n            ap = alphas[i]\n            aq = alphas[j]\n            \n            S_pq = (2 * np.sqrt(ap * aq) / (ap + aq))**1.5\n            R2_pq = S_pq * 1.5 / (ap + aq)\n            \n            S[i, j] = S_pq\n            R2[i, j] = R2_pq\n            \n    return S, R2\n\ndef normalize_coeffs(c, S):\n    \"\"\"Normalizes a coefficient vector with respect to the overlap matrix S.\"\"\"\n    norm_sq = c.T @ S @ c\n    if norm_sq <= 0: # Should not happen with valid positive definite S\n        raise ValueError(\"Non-positive norm squared.\")\n    return c / np.sqrt(norm_sq)\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case according to the problem specification.\n    \n    Args:\n        case_data (dict): A dictionary containing all data for one test case.\n        \n    Returns:\n        list of float: The 6 result values for the case.\n    \"\"\"\n    alpha_v = case_data[\"alpha_v\"]\n    alpha_d = case_data[\"alpha_d\"]\n    c_occ_aug_unnorm = np.array(case_data[\"c_occ_aug\"])\n    c_virt_aug_unnorm = np.array(case_data[\"c_virt_aug\"])\n    r2_cut = case_data[\"r2_cut\"]\n    f_cut = case_data[\"f_cut\"]\n\n    n_v = len(alpha_v)\n    n_d = len(alpha_d)\n    M = n_v + n_d\n    \n    alpha_aug = alpha_v + alpha_d\n    \n    # 1. Build augmented basis matrices\n    S_aug, R2_aug = build_matrices(alpha_aug)\n\n    # Extract non-augmented (valence-only) sub-matrices\n    S_noaug = S_aug[:n_v, :n_v]\n    R2_noaug = R2_aug[:n_v, :n_v]\n    \n    # 2. Normalize both occupied and virtual orbitals (as per instructions)\n    # The occupied orbital calculations are performed for procedural completeness\n    # but are not used in the final output values.\n    _ = normalize_coeffs(c_occ_aug_unnorm, S_aug)\n    c_occ_noaug_unnorm = c_occ_aug_unnorm[:n_v]\n    if n_v > 0:\n        _ = normalize_coeffs(c_occ_noaug_unnorm, S_noaug)\n\n    # Process the virtual orbital for the required outputs\n    # Augmented case\n    c_virt_aug_norm = normalize_coeffs(c_virt_aug_unnorm, S_aug)\n    \n    # 3. Compute augmented-case metrics\n    r2_attach_aug = c_virt_aug_norm.T @ R2_aug @ c_virt_aug_norm\n    \n    # Denominator for f_diffuse is 1 due to normalization\n    norm_check_aug = c_virt_aug_norm.T @ S_aug @ c_virt_aug_norm\n    \n    # Numerator of f_diffuse\n    v_vec = S_aug @ c_virt_aug_norm\n    diffuse_indices = range(n_v, M)\n    f_diffuse_num = np.dot(c_virt_aug_norm[diffuse_indices], v_vec[diffuse_indices])\n    f_diffuse_aug = f_diffuse_num / norm_check_aug\n\n    # 4. Compute non-augmented case metrics\n    c_virt_noaug_unnorm = c_virt_aug_unnorm[:n_v]\n    if n_v > 0:\n        c_virt_noaug_norm = normalize_coeffs(c_virt_noaug_unnorm, S_noaug)\n        r2_attach_noaug = c_virt_noaug_norm.T @ R2_noaug @ c_virt_noaug_norm\n    else: # Should not happen based on test cases\n        r2_attach_noaug = 0.0\n\n    f_diffuse_noaug = 0.0\n    \n    # 5. Classify the excitation\n    is_rydberg = (r2_attach_aug >= r2_cut and f_diffuse_aug >= f_cut)\n    classification = 1 if is_rydberg else 0\n    \n    # 6. Compute delta r^2\n    delta_r2 = r2_attach_aug - r2_attach_noaug\n\n    return [\n        r2_attach_aug,\n        f_diffuse_aug,\n        r2_attach_noaug,\n        f_diffuse_noaug,\n        delta_r2,\n        classification\n    ]\n\nsolve()\n```", "id": "2916133"}]}