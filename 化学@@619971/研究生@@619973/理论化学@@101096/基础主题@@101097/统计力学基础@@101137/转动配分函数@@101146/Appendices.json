{"hands_on_practices": [{"introduction": "双原子分子中原子核的同位性对其允许的转动能态具有深远影响，这是一种纯粹的量子力学效应。本练习将指导你计算异核分子（$\\text{CO}$）与同核分子（$^{14}$N$_2$）的转动配分函数之比，从而直接阐明对称数 $\\sigma$ 的关键作用。通过这个实践，你将具体理解分子对称性如何限制量子态空间 [@problem_id:1991137]。", "problem": "考虑两种双原子气体，一氧化碳 ($\\text{CO}$) 和氮气 ($^{14}$N$_2$)，它们都处于高温 $T$。在此温度下，对离散转动能级的求和可以很好地用积分来近似。\n\n一氧化碳的转动常数已知为 $B_{\\text{CO}} = 1.931 \\text{ cm}^{-1}$。\n由氮-14同位素组成的氮分子的转动常数已知为 $B_{^{14}\\text{N}_2} = 1.998 \\text{ cm}^{-1}$。\n\n计算单个 $^{14}$N$_2$ 分子的转动配分函数与单个 $\\text{CO}$ 分子的转动配分函数之比，即 $\\frac{q_{\\text{rot}}(^{14}\\text{N}_2)}{q_{\\text{rot}}(\\text{CO})}$。\n\n以无量纲数的形式给出您的答案，并四舍五入到三位有效数字。", "solution": "对于线性刚性转子，其转动能级为 $E_{J} = h c B J(J+1)$，具有对称数 $\\sigma$ 的转动配分函数为\n$$\nq_{\\text{rot}} = \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} (2J+1) \\exp\\!\\left(-\\frac{h c B}{k_{B} T} J(J+1)\\right).\n$$\n在高温下，用积分代替求和：\n$$\nq_{\\text{rot}} \\approx \\frac{1}{\\sigma} \\int_{0}^{\\infty} (2J+1) \\exp\\!\\left(-x J(J+1)\\right) \\, dJ,\n$$\n其中 $x = \\frac{h c B}{k_{B} T}$。使用换元法，令 $u = J(J+1)$，则 $du = (2J+1)\\, dJ$，积分上下限从 $u=0$ 映至 $u\\to\\infty$，得到\n$$\nq_{\\text{rot}} \\approx \\frac{1}{\\sigma} \\int_{0}^{\\infty} \\exp(-x u)\\, du = \\frac{1}{\\sigma} \\frac{1}{x} = \\frac{k_{B} T}{\\sigma h c B}.\n$$\n因此，该比值为\n$$\n\\frac{q_{\\text{rot}}(^{14}\\text{N}_{2})}{q_{\\text{rot}}(\\text{CO})} = \\frac{\\frac{k_{B} T}{\\sigma_{^{14}\\text{N}_{2}} h c B_{^{14}\\text{N}_{2}}}}{\\frac{k_{B} T}{\\sigma_{\\text{CO}} h c B_{\\text{CO}}}} = \\frac{\\sigma_{\\text{CO}}}{\\sigma_{^{14}\\text{N}_{2}}} \\frac{B_{\\text{CO}}}{B_{^{14}\\text{N}_{2}}}.\n$$\n对于同核分子 $^{14}\\text{N}_{2}$，$\\sigma_{^{14}\\text{N}_{2}}=2$；对于异核分子 $\\text{CO}$，$\\sigma_{\\text{CO}}=1$。使用给定的 $B$ 值（单位相同，因此在比值中会消去），\n$$\n\\frac{q_{\\text{rot}}(^{14}\\text{N}_{2})}{q_{\\text{rot}}(\\text{CO})} = \\frac{1}{2} \\frac{1.931}{1.998} \\approx \\frac{1}{2} \\times 0.966467 \\approx 0.483.\n$$\n四舍五入到三位有效数字，该比值为 $0.483$。", "answer": "$$\\boxed{0.483}$$", "id": "1991137"}, {"introduction": "刚性转子模型是一个强大的起点，但真实的分子是柔性的，其化学键会在转动应力下伸长。本练习引入了离心畸变修正，这是朝着更真实地描述分子转动迈出的第一步。你将推导非刚性转子的高温配分函数，学习如何运用微扰技术将物理上的精细修正融入到你的统计力学模型中 [@problem_id:1991133]。", "problem": "简单刚性双原子分子的转动能级通常用表达式 $E_J^{\\text{rigid}} = hcB J(J+1)$ 来近似，其中 $J$ 是转动量子数，$h$ 是 Planck 常数，$c$ 是光速，$B$ 是转动常数。然而，真实分子并非完全刚性。当分子旋转得更快时（即在更高的 $J$ 值下），原子间的化学键会因离心力而伸长。这种效应被称为离心畸变，它会降低能级。一个更精确的转动能级表达式，包含了对离心畸变的一阶修正，由下式给出：\n$$E_J = hc[B J(J+1) - D J^2(J+1)^2]$$\n此处，$D$ 是离心畸变常数，它是一个小的正常数，满足 $D \\ll B$。\n\n考虑一个处于高绝对温度 $T$ 下的异核双原子分子，使得 $k_B T \\gg hcB$，其中 $k_B$ 是 Boltzmann 常数。请推导一个包含此一阶离心畸变修正的分子转动配分函数 $q_{\\text{rot}}$ 的近似表达式。你的最终表达式应以 $T$，$B$，$D$ 以及基本常数 $h$，$c$ 和 $k_B$ 表示。", "solution": "对于包含离心畸变的异核双原子转子，其转动配分函数的定义为\n$$\nq_{\\text{rot}}=\\sum_{J=0}^{\\infty}(2J+1)\\exp\\!\\left[-\\frac{E_{J}}{k_{B}T}\\right],\n$$\n其能级为\n$$\nE_{J}=hc\\left[BJ(J+1)-DJ^{2}(J+1)^{2}\\right],\n$$\n其中 $D\\ll B$ 且温度 $T$ 很高，使得 $k_{B}T\\gg hcB$。定义 $\\beta=1/(k_{B}T)$ 并设\n$$\na=\\beta hcB,\\qquad b=\\beta hcD.\n$$\n则\n$$\nq_{\\text{rot}}=\\sum_{J=0}^{\\infty}(2J+1)\\exp\\!\\left[-aJ(J+1)+bJ^{2}(J+1)^{2}\\right].\n$$\n对于 $D\\ll B$ 的情况，将 Boltzmann 因子对 $D$ 作一阶展开：\n$$\n\\exp\\!\\left[-aJ(J+1)+bJ^{2}(J+1)^{2}\\right]\\approx \\exp\\!\\left[-aJ(J+1)\\right]\\left[1+bJ^{2}(J+1)^{2}\\right].\n$$\n在高温下，许多 $J$ 能级上都有布居，求和可以用积分来近似：\n$$\nq_{\\text{rot}}\\approx\\int_{0}^{\\infty}(2J+1)\\exp\\!\\left[-aJ(J+1)\\right]\\left[1+bJ^{2}(J+1)^{2}\\right]\\,dJ.\n$$\n令 $y=J(J+1)$，则 $dy=(2J+1)\\,dJ$。那么\n$$\nq_{\\text{rot}}\\approx \\int_{0}^{\\infty}\\exp(-ay)\\,dy + b\\int_{0}^{\\infty}y^{2}\\exp(-ay)\\,dy.\n$$\n使用标准积分 $\\int_{0}^{\\infty}y^{n}\\exp(-ay)\\,dy=\\frac{n!}{a^{n+1}}$（对于 $a>0$），我们得到\n$$\n\\int_{0}^{\\infty}\\exp(-ay)\\,dy=\\frac{1}{a},\\qquad \\int_{0}^{\\infty}y^{2}\\exp(-ay)\\,dy=\\frac{2}{a^{3}}.\n$$\n因此，\n$$\nq_{\\text{rot}}\\approx \\frac{1}{a}+\\frac{2b}{a^{3}}.\n$$\n将 $a=\\frac{hcB}{k_{B}T}$ 和 $b=\\frac{hcD}{k_{B}T}$ 代回，得到\n$$\nq_{\\text{rot}}\\approx \\frac{k_{B}T}{hcB}+\\frac{2D(k_{B}T)^{2}}{(hc)^{2}B^{3}}=\\frac{k_{B}T}{hcB}\\left(1+\\frac{2D}{B^{2}}\\frac{k_{B}T}{hc}\\right).\n$$\n此结果在 $k_{B}T\\gg hcB$ 和 $\\frac{D}{B^{2}}\\frac{k_{B}T}{hc}\\ll 1$ 的联合极限下有效，这确保了对 $D$ 的一阶展开是充分的。", "answer": "$$\\boxed{\\frac{k_{B}T}{hcB}\\left(1+\\frac{2D}{B^{2}}\\frac{k_{B}T}{hc}\\right)}$$", "id": "1991133"}, {"introduction": "理论化学家的工具箱必须同时包含解析近似方法和稳健的数值计算。这项高级实践要求你通过编程实现转动配分函数的精确数值求和，并将其与高温近似进行比较，从而弥合理论与计算之间的鸿沟。通过分析这些方法的收敛性和误差，你将培养出在实践中评估理论模型有效性和准确性的关键技能 [@problem_id:2821764]。", "problem": "要求您设计一个程序，使用数值求和与渐近近似方法，计算并分析气相线性刚性转子的转动配分函数。您的实现必须仅依赖于基本的统计力学定义和经过充分检验的光谱学事实。\n\n您必须使用的基本依据是：\n- 正则（构型）配分函数的定义：对于一组具有简并度 $\\{g_i\\}$ 的离散能级 $\\{E_i\\}$，单分子配分函数为 $q = \\sum_i g_i \\exp(-\\beta E_i)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$T$ 是以开尔文为单位的绝对温度，$k_{\\mathrm{B}}$ 是 Boltzmann 常数。\n- 对于转动惯量为 $I$ 的线性刚性转子，其量子转动能级为 $E_J = \\dfrac{\\hbar^2}{2 I} J (J+1)$，其中 $J$ 为非负整数，简并度为 $g_J = 2J+1$。等效地，使用以反厘米为单位的光谱转动常数 $\\tilde{B}$，则 $E_J = h c \\tilde{B} J(J+1)$，其中 $h$ 是 Planck 常数，$c$ 是光速。定义转动温度 $\\theta_{\\mathrm{rot}} = \\dfrac{h c \\tilde{B}}{k_{\\mathrm{B}}}$，使得 Boltzmann 因子为 $\\exp\\!\\big(-\\theta_{\\mathrm{rot}} J(J+1)/T\\big)$。\n- 对于同核线性转子，需包含对称数 $\\sigma$（一个整数，例如，对于两端不可区分的双原子分子 $\\sigma = 2$），方法是将转动配分函数除以 $\\sigma$。\n\n任务要求：\n1) 为线性刚性转子的单分子转动配分函数实现一个自适应数值求和，\n$$\nq_{\\mathrm{rot}}(T,\\tilde{B},\\sigma) \\;=\\; \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} (2J+1)\\, \\exp\\!\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right),\n$$\n方法是在一个依赖于数据的最大值 $J_{\\max}$ 处截断求和，以确保收敛。使用以下停止判据：设 $S_N$ 是截至 $J=N$ 的当前部分和，$t_{N+1}=(2(N+1)+1)\\exp\\!\\left[-(\\theta_{\\mathrm{rot}}/T)(N+1)(N+2)\\right]$ 为下一项；当 $t_{N+1}/S_N < \\varepsilon$ 时停止，容差 $\\varepsilon = 10^{-12}$。为确保稳健性，强制设置一个硬性上限 $J_{\\max}^{\\mathrm{cap}} = 10^6$，如果达到此上限仍未满足容差，则停止并使用在该上限处的部分和。返回的 $q_{\\mathrm{rot}}$ 必须是无量纲的，并且您还必须报告实际使用的最终 $J_{\\max}$（一个整数）。\n\n2) 通过用对连续变量的积分代替对 $J$ 的求和，推导并实现领头的经典高温近似，从而获得以 $T$、$\\tilde{B}$ 和 $\\sigma$ 表示的领头阶表达式 $q_{\\mathrm{cl,lead}}(T,\\tilde{B},\\sigma)$。此外，通过系统性的渐近改进（例如，通过 Euler–Maclaurin 公式）推导并实现第一修正项，以产生一个改进的近似 $q_{\\mathrm{cl,imp}}(T,\\tilde{B},\\sigma)$。\n\n3) 对于每个测试用例，计算：\n- 收敛的数值 $q_{\\mathrm{rot}}$，\n- 领头的经典近似 $q_{\\mathrm{cl,lead}}$，\n- 领头近似的相对误差，$\\left|q_{\\mathrm{cl,lead}}-q_{\\mathrm{rot}}\\right|/q_{\\mathrm{rot}}$，\n- 改进近似的相对误差，$\\left|q_{\\mathrm{cl,imp}}-q_{\\mathrm{rot}}\\right|/q_{\\mathrm{rot}}$，\n- 您的求和所使用的最终 $J_{\\max}$。\n\n物理和数值单位及常数：\n- 温度 $T$ 必须以开尔文（K）为单位。\n- 光谱转动常数 $\\tilde{B}$ 必须以反厘米（$\\mathrm{cm}^{-1}$）为单位。\n- 使用一个可靠的 codata 源提供的精确物理常数 $h$（Planck 常数）、$c$（光速）和 $k_{\\mathrm{B}}$（Boltzmann 常数）。在计算 $\\theta_{\\mathrm{rot}}=\\dfrac{h c \\tilde{B}}{k_{\\mathrm{B}}}$ 时，若 $\\tilde{B}$ 的单位为 $\\mathrm{cm}^{-1}$，请确保正确的单位转换以获得单位为开尔文的 $\\theta_{\\mathrm{rot}}$。\n\n测试套件：\n计算并报告以下四组参数的结果，全部使用容差 $\\varepsilon = 10^{-12}$：\n- 情况 A（异核，极低温度）：$T = 0.5\\ \\mathrm{K}$，$\\tilde{B} = 2.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 1$。\n- 情况 B（异核，中等温度）：$T = 5.0\\ \\mathrm{K}$，$\\tilde{B} = 2.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 1$。\n- 情况 C（同核，高温）：$T = 300.0\\ \\mathrm{K}$，$\\tilde{B} = 2.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 2$。\n- 情况 D（异核，高温但转动常数较大）：$T = 300.0\\ \\mathrm{K}$，$\\tilde{B} = 10.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 1$。\n\n最终输出格式：\n您的程序应生成单行输出，包含四个测试用例的聚合结果，形式为方括号内以逗号分隔的列表。对于每种情况，按顺序附加五个值\n$[q_{\\mathrm{rot}},\\ q_{\\mathrm{cl,lead}},\\ \\mathrm{relErr}_{\\mathrm{lead}},\\ \\mathrm{relErr}_{\\mathrm{imp}},\\ J_{\\max}]$，\n因此最终行将总共包含 20 个条目。所有的 $q$ 值和相对误差都必须报告为无量纲的浮点数，$J_{\\max}$ 报告为整数。例如，输出必须形如\n$[x_1,x_2,x_3,x_4,x_5,x_6,\\dots,x_{20}]$\n不带任何附加文本。", "solution": "所述问题定义严谨、科学上合理且内容自洽。它基于统计力学和量子力学的基本原理在分子光谱学中的应用。所有参数、常数和目标都已明确指定。因此，该问题是有效的，我们着手进行求解。\n\n解答分为两部分：首先是必要公式的推导，其次是将这些公式实现为一个计算程序。\n\n线性刚性转子的转动配分函数由下式给出\n$$\nq_{\\mathrm{rot}}(T, \\tilde{B}, \\sigma) = \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} g_J \\exp\\left(-\\frac{E_J}{k_{\\mathrm{B}} T}\\right)\n$$\n其中 $T$ 是绝对温度，$\\sigma$ 是对称数，$k_{\\mathrm{B}}$ 是 Boltzmann 常数，能级 $E_J$ 及其简并度 $g_J$ 由量子力学给出。对于线性刚性转子，转动能级为 $E_J = h c \\tilde{B} J(J+1)$，简并度为 $g_J = 2J+1$，其中转动量子数 $J = 0, 1, 2, \\dots$。这里，$h$ 是 Planck 常数，$c$ 是光速，$\\tilde{B}$ 是光谱转动常数。\n\n定义特征转动温度 $\\theta_{\\mathrm{rot}} = \\frac{h c \\tilde{B}}{k_{\\mathrm{B}}}$ 会很方便。该参数具有温度的单位，表示转动能级之间的能量间距。使用此定义，配分函数变为：\n$$\nq_{\\mathrm{rot}}(T, \\tilde{B}, \\sigma) = \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} (2J+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right)\n$$\n\n### 1. 配分函数的数值计算\n\n为了进行数值计算，必须截断这个无限求和。当级数中的下一项与当前部分和相比足够小时，求和将终止。设 $S_N$ 是截至量子数 $J=N$ 的部分和，$t_{N+1}$ 是对应于 $J=N+1$ 的项。\n$$\nS_N = \\sum_{J=0}^{N} (2J+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right)\n$$\n$$\nt_{N+1} = (2(N+1)+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} (N+1)(N+2)\\right)\n$$\n对于给定的容差 $\\varepsilon = 10^{-12}$，当条件 $t_{N+1}/S_N < \\varepsilon$ 满足时，求和在 $J_{\\max} = N$ 处终止。施加了 $J_{\\max}^{\\mathrm{cap}} = 10^6$ 的硬性上限，以防止过度计算。最终数值计算得到的配分函数为 $q_{\\mathrm{rot}} = S_{J_{\\max}} / \\sigma$。\n\n### 2. 高温渐近近似\n\n在高温极限下，即 $T \\gg \\theta_{\\mathrm{rot}}$ 时，离散求和可以用积分来近似。\n\n#### 领头阶经典近似\n\n领头阶项 $q_{\\mathrm{cl,lead}}$ 是通过用从 $J=0$ 到 $J=\\infty$ 的积分替换对 $J$ 的求和得到的：\n$$\nq_{\\mathrm{cl,lead}} = \\frac{1}{\\sigma} \\int_0^\\infty (2J+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right) dJ\n$$\n让我们进行变量替换。令 $x = J(J+1)$。则微分是 $dx = (2J+1)dJ$。$x$ 的积分限仍然是 $0$ 到 $\\infty$。积分简化为一个标准形式：\n$$\nq_{\\mathrm{cl,lead}} = \\frac{1}{\\sigma} \\int_0^\\infty \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} x\\right) dx = \\frac{1}{\\sigma} \\left[ -\\frac{T}{\\theta_{\\mathrm{rot}}} \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} x\\right) \\right]_0^\\infty\n$$\n在积分限处求值得到：\n$$\nq_{\\mathrm{cl,lead}} = \\frac{1}{\\sigma} \\left( 0 - \\left(-\\frac{T}{\\theta_{\\mathrm{rot}}}\\right) \\right) = \\frac{T}{\\sigma \\theta_{\\mathrm{rot}}}\n$$\n这是众所周知的转动配分函数的经典近似。\n\n#### 带一阶修正的改进近似\n\n一个更精确的近似 $q_{\\mathrm{cl,imp}}$ 可以通过包含来自半经典展开的修正项来找到，这些修正项可通过 Euler-Maclaurin 公式推导。该公式将离散求和与积分及其导数联系起来：\n$$\n\\sum_{J=0}^{\\infty} f(J) \\approx \\int_{0}^{\\infty} f(x) dx + \\frac{1}{2}f(0) - \\frac{1}{12}f'(0) + \\dots\n$$\n令 $y = \\theta_{\\mathrm{rot}}/T$ 且 $f(J) = (2J+1)\\exp(-y J(J+1))$。我们已经找到了积分项：\n$$\n\\int_{0}^{\\infty} f(x) dx = \\frac{1}{y} = \\frac{T}{\\theta_{\\mathrm{rot}}}\n$$\n接下来，我们在 $J=0$ 处计算函数及其导数：\n$$\nf(0) = (2(0)+1)\\exp(0) = 1\n$$\n$$\nf'(J) = \\frac{d}{dJ} \\left( (2J+1)e^{-y J(J+1)} \\right) = 2e^{-y J(J+1)} - y(2J+1)^2 e^{-y J(J+1)}\n$$\n$$\nf'(0) = 2e^0 - y(1)^2 e^0 = 2 - y\n$$\n将这些代入 Euler-Maclaurin 公式，得到求和为：\n$$\n\\sum_{J=0}^{\\infty} f(J) \\approx \\frac{1}{y} + \\frac{1}{2}(1) - \\frac{1}{12}(2-y) = \\frac{1}{y} + \\frac{1}{2} - \\frac{1}{6} + \\frac{y}{12} = \\frac{1}{y} + \\frac{1}{3} + \\frac{y}{12}\n$$\n高温极限对应于小的 $y$。求和按 $y$ 的展开式为 $\\frac{1}{y} + \\frac{1}{3} + O(y)$。改进的近似 $q_{\\mathrm{cl,imp}}$ 包含此展开式的前两项：\n$$\nq_{\\mathrm{cl,imp}} = \\frac{1}{\\sigma} \\left( \\frac{T}{\\theta_{\\mathrm{rot}}} + \\frac{1}{3} \\right) = q_{\\mathrm{cl,lead}} + \\frac{1}{3\\sigma}\n$$\n这提供了对经典结果的一阶量子修正。\n\n### 3. 实现与常数\n\n对于计算，我们使用从 `scipy.constants` 库中获取的 CODATA 2018 物理常数值：\n- Planck 常数, $h \\approx 6.62607015 \\times 10^{-34}$ J s\n- 光速, $c \\approx 2.99792458 \\times 10^{8}$ m/s\n- Boltzmann 常数, $k_{\\mathrm{B}} \\approx 1.380649 \\times 10^{-23}$ J/K\n\n转动常数 $\\tilde{B}$ 的单位是 cm$^{-1}$。为了以开尔文计算 $\\theta_{\\mathrm{rot}}$，$\\tilde{B}$ 必须通过乘以 $100$ 转换为 m$^{-1}$。\n$$\n\\theta_{\\mathrm{rot}}[\\mathrm{K}] = \\frac{h[\\mathrm{J \\cdot s}] \\cdot c[\\mathrm{m/s}] \\cdot (\\tilde{B}[\\mathrm{cm^{-1}}] \\times 100 [\\mathrm{m/cm}])}{k_{\\mathrm{B}}[\\mathrm{J/K}]}\n$$\n相对误差按指定方式计算：$\\mathrm{relErr}_{\\mathrm{lead}} = |q_{\\mathrm{cl,lead}} - q_{\\mathrm{rot}}| / q_{\\mathrm{rot}}$ 和 $\\mathrm{relErr}_{\\mathrm{imp}} = |q_{\\mathrm{cl,imp}} - q_{\\mathrm{rot}}| / q_{\\mathrm{rot}}$。\n程序将对每个测试用例执行这些计算，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import h, c, k\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the rotational partition function for a linear\n    rigid rotor for a defined set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (T [K], B_tilde [cm^-1], sigma), Case Label\n        (0.5, 2.0, 1),    # Case A\n        (5.0, 2.0, 1),    # Case B\n        (300.0, 2.0, 2),  # Case C\n        (300.0, 10.0, 1)  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        T, B_tilde, sigma = case\n        res_tuple = calculate_rotational_properties(T, B_tilde, sigma)\n        results.extend(res_tuple)\n\n    # Final print statement in the exact required format.\n    # We format floats with a general precision specifier for clarity,\n    # and integers as standard integers.\n    print(f\"[{','.join(f'{val:.12g}' if isinstance(val, float) else str(val) for val in results)}]\")\n\ndef calculate_rotational_properties(T, B_tilde, sigma):\n    \"\"\"\n    Calculates q_rot, q_cl_lead, relative errors, and J_max for a single case.\n\n    Args:\n        T (float): Absolute temperature in Kelvin.\n        B_tilde (float): Rotational constant in cm^-1.\n        sigma (int): Symmetry number.\n\n    Returns:\n        tuple: A tuple containing (q_rot, q_cl_lead, relErr_lead, relErr_imp, J_max).\n    \"\"\"\n    epsilon = 1e-12\n    J_max_cap = 1000000\n\n    # Calculate the characteristic rotational temperature, theta_rot.\n    # B_tilde is in cm^-1, so it's converted to m^-1 by multiplying by 100.\n    theta_rot = (h * c * B_tilde * 100.0) / k\n    theta_rot_over_T = theta_rot / T\n\n    # 1. Numerical summation for q_rot\n    # The sum starts with the J=0 term.\n    current_sum = 1.0  # This is S_0\n    J = 0\n    J_max = 0\n\n    while J < J_max_cap:\n        J_next = J + 1\n        exponent_next = -theta_rot_over_T * (J_next * (J_next + 1))\n        \n        # Check for potential underflow to prevent exp() from returning 0\n        # prematurely, which might affect very low-temperature calculations.\n        # np.exp handles large negative exponents gracefully.\n        term_next = (2.0 * J_next + 1.0) * np.exp(exponent_next)\n\n        # Stopping criterion: t_{N+1} / S_N < epsilon\n        # We stop when the next term is negligible compared to the current sum.\n        if term_next == 0.0 or term_next / current_sum < epsilon:\n            J_max = J  # The sum is converged up to J.\n            break\n        \n        current_sum += term_next\n        J += 1\n    else:  # This 'else' belongs to the 'while' loop.\n        J_max = J_max_cap\n\n    q_rot = current_sum / sigma\n\n    # 2. High-temperature approximations\n    q_cl_lead = (T / theta_rot) / sigma\n    q_cl_imp = q_cl_lead + 1.0 / (3.0 * sigma)\n\n    # 3. Relative errors\n    relErr_lead = np.abs(q_cl_lead - q_rot) / q_rot if q_rot != 0 else 0.0\n    relErr_imp = np.abs(q_cl_imp - q_rot) / q_rot if q_rot != 0 else 0.0\n\n    return q_rot, q_cl_lead, relErr_lead, relErr_imp, J_max\n\nsolve()\n```", "id": "2821764"}]}