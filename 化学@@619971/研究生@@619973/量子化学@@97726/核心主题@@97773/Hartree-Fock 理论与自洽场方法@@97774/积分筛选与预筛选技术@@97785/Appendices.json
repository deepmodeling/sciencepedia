{"hands_on_practices": [{"introduction": "柯西-施瓦茨不等式是现代量子化学中积分筛选技术的基石。本练习旨在通过一个直接的数值计算，展示这一强大的数学工具在实践中的具体应用。通过这个例子，您将亲自体验如何利用一个严格的积分上限值来判断是否可以安全地忽略某些计算成本高昂的电子排斥积分，这是应对构建福克矩阵时 $O(N^4)$ 复杂度挑战的第一步 [@problem_id:2898934]。", "problem": "在基于实高斯原子轨道基组的限制性 Hartree-Fock (RHF) 方法中构建 Fock 矩阵的库仑贡献时，考虑如下定义的双电子排斥积分\n$$(\\mu\\nu|\\lambda\\sigma) \\equiv \\iint \\varphi_{\\mu}(\\mathbf{r}_{1})\\,\\varphi_{\\nu}(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,\\varphi_{\\lambda}(\\mathbf{r}_{2})\\,\\varphi_{\\sigma}(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2},$$\n其中 $r_{12} = |\\mathbf{r}_{1}-\\mathbf{r}_{2}|$ 且 $\\{\\varphi_{\\kappa}\\}$ 是归一化基函数。在积分筛选中，一个常见的预筛选步骤是基于应用于 $(\\mathbf{r}_{1},\\mathbf{r}_{2})$ 函数的适当 $L^{2}$ 内积的 Cauchy–Schwarz 不等式。\n\n从上述定义和平方可积函数的 Cauchy–Schwarz 不等式出发，推导 $|(\\mu\\nu|\\lambda\\sigma)|$ 关于 $(\\mu\\nu|\\mu\\nu)$ 和 $(\\lambda\\sigma|\\lambda\\sigma)$ 的严格上界。然后，使用用户指定的筛选阈值 $\\tau>0$，陈述一个准则，据此准则，在为 Fock 矩阵元 $F_{\\mu\\nu}$ 构建库仑项时可以跳过壳层四重积分 $(\\mu\\nu,\\lambda\\sigma)$。如果该四重积分未被跳过，使用你推导出的上界来确定由单个密度矩阵元 $D_{\\lambda\\sigma}$ 产生的对 $F_{\\mu\\nu}$ 的库仑贡献的最大可能量值。\n\n使用以下数据：\n$$(\\mu\\nu|\\mu\\nu) = 0.80\\ \\text{哈特里},\\quad (\\lambda\\sigma|\\lambda\\sigma) = 0.45\\ \\text{哈特里},\\quad \\tau = 0.55\\ \\text{哈特里},\\quad D_{\\lambda\\sigma} = 0.18.$$\n\n报告由给定 $(\\mu\\nu,\\lambda\\sigma)$ 四重积分对 $F_{\\mu\\nu}$ 的库仑贡献的最大可能量值（以哈特里为单位）的单个数值，并遵循如果该四重积分被跳过则报告值为 $0$ 的约定。将你的答案四舍五入到四位有效数字，并以哈特里为单位表示最终能量。", "solution": "提交分析的问题陈述被认为是有效的。它在科学上基于量子化学原理，特别是 Hartree-Fock 理论，并且在数学上是适定的。所有必需的数据均已提供，问题没有矛盾或歧义。我们将进行严格的求解。\n\n该问题要求三个相继的结果：首先，推导双电子排斥积分 (ERI) 的上界；其次，建立筛选此积分的准则；第三，基于此筛选计算对库仑矩阵的最大贡献。\n\n让我们从双电子排斥积分的定义开始：\n$$(\\mu\\nu|\\lambda\\sigma) \\equiv \\iint \\varphi_{\\mu}(\\mathbf{r}_{1})\\,\\varphi_{\\nu}(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,\\varphi_{\\lambda}(\\mathbf{r}_{2})\\,\\varphi_{\\sigma}(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2}$$\n其中 $r_{12} = |\\mathbf{r}_{1}-\\mathbf{r}_{2}|$。我们定义电荷分布（或基函数乘积）为 $\\rho_{\\mu\\nu}(\\mathbf{r}) = \\varphi_{\\mu}(\\mathbf{r})\\varphi_{\\nu}(\\mathbf{r})$ 和 $\\rho_{\\lambda\\sigma}(\\mathbf{r}) = \\varphi_{\\lambda}(\\mathbf{r})\\varphi_{\\sigma}(\\mathbf{r})$。该积分可以更紧凑地表示为：\n$$(\\mu\\nu|\\lambda\\sigma) = \\iint \\rho_{\\mu\\nu}(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,\\rho_{\\lambda\\sigma}(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2}$$\n此表达式在实数平方可积函数空间上定义了一个内积。对于任意两个此类函数 $f(\\mathbf{r})$ 和 $g(\\mathbf{r})$，其内积由下式给出：\n$$\\langle f|g \\rangle = \\iint f(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,g(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2}$$\n对应于核 $\\frac{1}{r_{12}}$ 的算符是正定的，这确保了这是一个有效的内积。此内积的 Cauchy–Schwarz 不等式表明 $|\\langle f|g \\rangle|^2 \\le \\langle f|f \\rangle \\langle g|g \\rangle$。\n\n通过令 $f = \\rho_{\\mu\\nu}$ 和 $g = \\rho_{\\lambda\\sigma}$，我们可以将 Cauchy-Schwarz 不等式直接应用于 ERI：\n$$|(\\mu\\nu|\\lambda\\sigma)|^2 = |\\langle \\rho_{\\mu\\nu}|\\rho_{\\lambda\\sigma} \\rangle|^2 \\le \\langle \\rho_{\\mu\\nu}|\\rho_{\\mu\\nu} \\rangle \\langle \\rho_{\\lambda\\sigma}|\\rho_{\\lambda\\sigma} \\rangle$$\n转换回标准的 ERI 表示法，我们得到：\n$$|(\\mu\\nu|\\lambda\\sigma)|^2 \\le (\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)$$\n对两边取平方根，得到该积分量值的严格上界：\n$$|(\\mu\\nu|\\lambda\\sigma)| \\le \\sqrt{(\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)}$$\n这就是广泛应用于电子排斥积分的 Schwarz 不等式。\n\n接下来，我们建立筛选准则。在预筛选步骤中，人们试图避免计算可忽略的积分。一个常见的准则是将推导出的上界与指定的阈值进行比较。令 $I_{max} = \\sqrt{(\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)}$。问题提供了一个筛选阈值 $\\tau$。如果四重积分 $(\\mu\\nu,\\lambda\\sigma)$ 的最大可能量值 $I_{max}$ 小于此阈值，则认为它是可忽略的，因此被跳过。该准则为：\n$$\\text{若 } \\sqrt{(\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)} < \\tau \\text{，则跳过该四重积分}$$\n\n现在我们使用所提供的数据应用此准则：$(\\mu\\nu|\\mu\\nu) = 0.80$ 哈特里，$(\\lambda\\sigma|\\lambda\\sigma) = 0.45$ 哈特里，以及 $\\tau = 0.55$ 哈特里。\n首先，我们计算上界 $I_{max}$：\n$$I_{max} = \\sqrt{(0.80)(0.45)} = \\sqrt{0.36} = 0.60\\ \\text{哈特里}$$\n现在，我们将此上界与阈值 $\\tau$ 进行比较：\n$$0.60 < 0.55$$\n此不等式不成立。因此，根据指定的准则和数据，该积分四重积分 $(\\mu\\nu,\\lambda\\sigma)$ **不**被跳过。\n\n最后的任务是确定从此特定四重积分对 Fock 矩阵元 $F_{\\mu\\nu}$ 的库仑贡献的最大可能量值。来自密度矩阵元 $D_{\\lambda\\sigma}$ 的库仑贡献由项 $C = D_{\\lambda\\sigma} (\\mu\\nu|\\lambda\\sigma)$ 给出。此贡献的量值为 $|C| = |D_{\\lambda\\sigma}| |(\\mu\\nu|\\lambda\\sigma)|$。当 $|(\\mu\\nu|\\lambda\\sigma)|$ 达到其上界 $I_{max}$ 时，出现最大可能量值 $|C|_{max}$：\n$$|C|_{max} = |D_{\\lambda\\sigma}| \\times I_{max}$$\n使用给定值 $D_{\\lambda\\sigma} = 0.18$ 和我们计算出的值 $I_{max} = 0.60$ 哈特里：\n$$|C|_{max} = |0.18| \\times 0.60 = 0.18 \\times 0.60 = 0.108\\ \\text{哈特里}$$\n问题要求答案以四位有效数字报告。因此，我们将 $0.108$ 表示为 $0.1080$。\n如果该四重积分被跳过，答案将是 $0$。由于它未被跳过，因此计算出的最大贡献就是正确答案。", "answer": "$$\\boxed{0.1080}$$", "id": "2898934"}, {"introduction": "对于计算科学家而言，将理论公式转化为可执行的程序是一项至关重要的技能。本实践将引导您从第一性原理出发，实现施瓦茨筛选引擎的核心部分——壳层对界限 $B_{IJ}$ 的计算器。通过为 s-型高斯函数编写 $(IJ|IJ)$ 积分的求值代码，您将深入理解高斯乘积定理和 Boys 函数的实际运作机制，从而搭建起连接教科书公式与实用计算代码的桥梁 [@problem_id:2898970]。", "problem": "构建一个完整、可运行的程序。在给定一组固定的收缩、归一化、笛卡尔坐标下的 $s$ 型高斯壳层，以及一组带有阈值的壳层四重态的情况下，该程序为每对壳层 $\\left(I,J\\right)$ 计算一个壳层对界 $B_{IJ}$，并且当且仅当 $B_{IJ}\\,B_{KL}<\\tau$ 时，筛选掉一个壳层四重态 $\\left(I,J\\mid K,L\\right)$。您的程序必须从以下公认的基础出发，从第一性原理实现该计算。\n\n使用的基础定义与事实：\n- 一个中心位于 $\\mathbf{A}\\in\\mathbb{R}^{3}$、指数为 $\\alpha>0$ 的原初、归一化的 $s$ 型高斯函数是 $\\phi\\left(\\mathbf{r};\\alpha,\\mathbf{A}\\right)=N\\left(\\alpha\\right)\\,\\exp\\left(-\\alpha\\left\\lVert\\mathbf{r}-\\mathbf{A}\\right\\rVert^{2}\\right)$，其中 $N\\left(\\alpha\\right)=\\left(\\dfrac{2\\alpha}{\\pi}\\right)^{3/4}$。\n- 一个收缩 $s$ 型壳层 $I$ 是一个线性组合 $\\Phi_{I}\\left(\\mathbf{r}\\right)=\\sum_{a=1}^{n_{I}} d_{a}^{\\left(I\\right)}\\,\\phi\\left(\\mathbf{r};\\alpha_{a}^{\\left(I\\right)},\\mathbf{A}_{I}\\right)$，具有实数收缩系数 $d_{a}^{\\left(I\\right)}$ 和原初指数 $\\alpha_{a}^{\\left(I\\right)}>0$，它们都共享相同的中心 $\\mathbf{A}_{I}$。\n- 对两个收缩壳层乘积的电子排斥积分定义为 $\\left(IJ\\mid KL\\right)=\\displaystyle\\iint \\dfrac{\\Phi_{I}\\left(\\mathbf{r}_{1}\\right)\\Phi_{J}\\left(\\mathbf{r}_{1}\\right)\\,\\Phi_{K}\\left(\\mathbf{r}_{2}\\right)\\Phi_{L}\\left(\\mathbf{r}_{2}\\right)}{\\left\\lVert\\mathbf{r}_{1}-\\mathbf{r}_{2}\\right\\rVert}\\,\\mathrm{d}\\mathbf{r}_{1}\\,\\mathrm{d}\\mathbf{r}_{2}$。\n- Cauchy–Schwarz 不等式导出一个筛选界 $\\left\\lvert\\left(IJ\\mid KL\\right)\\right\\rvert\\le \\sqrt{\\left(IJ\\mid IJ\\right)}\\,\\sqrt{\\left(KL\\mid KL\\right)}$。定义壳层对界 $B_{IJ}=\\sqrt{\\left(IJ\\mid IJ\\right)}$。\n- 高斯乘积定理和经过充分检验的一维积分降维方法，可以得到用 0 阶 Boys 函数表示的原初 $s$ 型电子排斥积分的闭合形式，$F_{0}\\!\\left(T\\right)=\\dfrac{1}{2}\\sqrt{\\dfrac{\\pi}{T}}\\,\\mathrm{erf}\\!\\left(\\sqrt{T}\\right)$（对于 $T>0$），其连续极限为 $F_{0}\\!\\left(0\\right)=1$。您的程序必须以数值稳定的方式计算所有 $T\\ge 0$ 的 $F_{0}\\!\\left(T\\right)$。\n\n算法任务：\n- 仅使用上述基础项，推导并实现一个算法，通过展开为原初积分和对 Boys 函数的数值计算，来精确计算收缩 $s$ 型壳层的 $\\left(IJ\\mid IJ\\right)$，并由此计算出 $B_{IJ}$。然后，对每个阈值为 $\\tau$ 的四重态 $\\left(I,J\\mid K,L\\right)$，通过检验 $B_{IJ}\\,B_{KL}<\\tau$ 来判断其是否被筛选掉。\n\n嵌入此任务中的输入 (固定测试套件)：\n- 有 4 个壳层，索引为 $0,1,2,3$，每个都是一个 $s$ 型收缩高斯壳层，参数如下：\n  - 壳层 $0$: 中心 $\\mathbf{A}_{0}=\\left(0.0,0.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.5,0.15\\right]$，系数 $\\left[d\\right]=\\left[0.6,0.4\\right]$。\n  - 壳层 $1$: 中心 $\\mathbf{A}_{1}=\\left(1.2,0.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.9\\right]$，系数 $\\left[d\\right]=\\left[1.0\\right]$。\n  - 壳层 $2$: 中心 $\\mathbf{A}_{2}=\\left(0.0,2.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.3,1.0\\right]$，系数 $\\left[d\\right]=\\left[0.7,0.3\\right]$。\n  - 壳层 $3$: 中心 $\\mathbf{A}_{3}=\\left(6.0,0.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.2\\right]$，系数 $\\left[d\\right]=\\left[1.0\\right]$。\n- 用给定的阈值 $\\tau$ 评估以下 $5$ 个测试四重态 $\\left(I,J\\mid K,L\\right)$：\n  - 情况 $1$: $\\left(0,1\\mid 0,1\\right)$，阈值为 $\\tau=10^{-3}$。\n  - 情况 $2$: $\\left(0,3\\mid 1,3\\right)$，阈值为 $\\tau=10^{-6}$。\n  - 情况 $3$: $\\left(1,1\\mid 1,1\\right)$，阈值为 $\\tau=10^{-1}$。\n  - 情况 $4$: $\\left(0,2\\mid 0,2\\right)$，阈值为 $\\tau=10^{-3}$。\n  - 情况 $5$: $\\left(2,3\\mid 2,3\\right)$，阈值为 $\\tau=10^{-5}$。\n\n输出要求：\n- 对每种情况，输出一个布尔值，指示该四重态是否被筛选掉，即 $B_{IJ}\\,B_{KL}<\\tau$ 的计算结果是否为真。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，不含空格，顺序与上述 $5$ 种情况一致；例如，`[True,False,...]`，但打印时无空格，形如 `[True,False,...]`。\n- 不涉及物理单位；所有量均为无量纲量。\n\n约束条件：\n- 您不得硬编码任何超出基础项所推导范围的收缩积分闭合形式表达式。通过对原初贡献的显式求和来计算收缩量，并在仔细处理 $T\\to 0$ 的情况下数值计算 $F_{0}\\!\\left(T\\right)$。\n- 假设所有壳层均为 $s$ 型；大于零的角动量超出了本任务的范围。", "solution": "问题陈述经评估有效。它在科学上植根于量子化学原理，特别是 Hartree-Fock 方法的积分计算部分。该问题是适定(well-posed)的，为获得唯一解提供了所有必要的定义、常数和数据。其语言客观，任务是计算化学中的一个标准、可形式化的过程。\n\n问题的核心是基于 Cauchy-Schwarz 不等式确定一个表示为 $\\left(IJ\\mid KL\\right)$ 的电子排斥积分壳层四重态是否可以被忽略。筛选条件由 $B_{IJ}\\,B_{KL}<\\tau$ 给出，其中 $\\tau$ 是一个数值阈值，而 $B_{PQ}$ 是定义为 $B_{PQ} = \\sqrt{\\left(PQ\\mid PQ\\right)}$ 的壳层对界。为了实现这一筛选过程，我们必须首先开发一种方法来计算任意一对收缩 $s$ 型高斯壳层 $I$ 和 $J$ 的积分 $\\left(IJ\\mid IJ\\right)$。\n\n一个收缩 $s$ 型壳层 $\\Phi_{I}$ 是原初 $s$ 型高斯函数 $\\phi_a^I$ 的线性组合：\n$$ \\Phi_{I}\\left(\\mathbf{r}\\right)=\\sum_{a=1}^{n_{I}} d_{a}^{\\left(I\\right)}\\,\\phi\\left(\\mathbf{r};\\alpha_{a}^{\\left(I\\right)},\\mathbf{A}_{I}\\right) $$\n其中 $d_{a}^{\\left(I\\right)}$ 是收缩系数，$\\alpha_{a}^{\\left(I\\right)}$ 是指数，$\\mathbf{A}_{I}$ 是壳层的中心。原初高斯函数 $\\phi$ 是归一化的，其归一化常数为 $N\\left(\\alpha\\right)=\\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}$。\n\n双电子排斥积分 $\\left(IJ\\mid IJ\\right)$ 是在这些收缩壳层上定义的：\n$$ \\left(IJ\\mid IJ\\right)=\\iint \\dfrac{\\Phi_{I}\\left(\\mathbf{r}_{1}\\right)\\Phi_{J}\\left(\\mathbf{r}_{1}\\right)\\,\\Phi_{I}\\left(\\mathbf{r}_{2}\\right)\\Phi_{J}\\left(\\mathbf{r}_{2}\\right)}{\\left\\lVert\\mathbf{r}_{1}-\\mathbf{r}_{2}\\right\\rVert}\\,\\mathrm{d}\\mathbf{r}_{1}\\,\\mathrm{d}\\mathbf{r}_{2} $$\n通过代入 $\\Phi_I$ 和 $\\Phi_J$ 的线性展开式，该积分变成对原初高斯函数积分的求和：\n$$ \\left(IJ\\mid IJ\\right) = \\sum_{a \\in I} \\sum_{b \\in J} \\sum_{c \\in I} \\sum_{d \\in J} d_{a}^{\\left(I\\right)} d_{b}^{\\left(J\\right)} d_{c}^{\\left(I\\right)} d_{d}^{\\left(J\\right)} \\left(\\phi_a^I \\phi_b^J \\mid \\phi_c^I \\phi_d^J\\right) $$\n其中 $\\left(\\phi_a^I \\phi_b^J \\mid \\phi_c^I \\phi_d^J\\right)$ 是涉及四个高斯函数的原初积分：$\\phi_a^I$ 中心在 $\\mathbf{A}_I$，$\\phi_b^J$ 在 $\\mathbf{A}_J$，$\\phi_c^I$ 在 $\\mathbf{A}_I$，而 $\\phi_d^J$ 在 $\\mathbf{A}_J$。\n\n一个指数为 $\\alpha_a, \\alpha_b, \\alpha_c, \\alpha_d$、中心为 $\\mathbf{A}, \\mathbf{B}, \\mathbf{C}, \\mathbf{D}$ 的原初 $s$ 型电子排斥积分(ERI) $\\left(\\phi_a \\phi_b \\mid \\phi_c \\phi_d\\right)$ 的值可以使用高斯乘积定理推导得出。两个高斯函数的乘积是另一个高斯函数。这使得六维积分可以被简化为一个已知形式。对归一化原初函数的最终解析表达式为：\n$$ \\left(\\phi_a \\phi_b \\mid \\phi_c \\phi_d\\right) = N_a N_b N_c N_d \\frac{2\\pi^{5/2}}{p_{ab}p_{cd}\\sqrt{p_{ab}+p_{cd}}} \\exp\\left(-\\frac{\\alpha_a\\alpha_b}{p_{ab}}\\left\\lVert\\mathbf{A}-\\mathbf{B}\\right\\rVert^2 - \\frac{\\alpha_c\\alpha_d}{p_{cd}}\\left\\lVert\\mathbf{C}-\\mathbf{D}\\right\\rVert^2\\right) F_0\\left(T\\right) $$\n此处使用以下定义：\n- $p_{ab} = \\alpha_a + \\alpha_b$ 以及 $p_{cd} = \\alpha_c + \\alpha_d$。\n- 乘积高斯函数的新中心是 $\\mathbf{P}_{ab} = \\frac{\\alpha_a\\mathbf{A} + \\alpha_b\\mathbf{B}}{p_{ab}}$ 和 $\\mathbf{P}_{cd} = \\frac{\\alpha_c\\mathbf{C} + \\alpha_d\\mathbf{D}}{p_{cd}}$。\n- Boys 函数的自变量是 $T = \\frac{p_{ab}p_{cd}}{p_{ab}+p_{cd}}\\left\\lVert\\mathbf{P}_{ab}-\\mathbf{P}_{cd}\\right\\rVert^2$。\n- $N_k = \\left(\\frac{2\\alpha_k}{\\pi}\\right)^{3/4}$ 是原初函数 $\\phi_k$ 的归一化常数。\n\n0 阶 Boys 函数 $F_0\\left(T\\right)$ 对于 $T > 0$ 给出如下：\n$$ F_0\\left(T\\right) = \\frac{1}{2}\\sqrt{\\frac{\\pi}{T}}\\,\\mathrm{erf}\\left(\\sqrt{T}\\right) $$\n对于 $T=0$，其极限为 $F_0\\left(0\\right)=1$。在数值上，当 $T$ 很小时，直接使用该公式是不稳定的。我们使用 $F_0(T)$ 在 $T=0$ 附近的泰勒级数展开：\n$$ F_0\\left(T\\right) = \\sum_{n=0}^{\\infty} \\frac{\\left(-T\\right)^n}{2n+1} = 1 - \\frac{T}{3} + \\frac{T^2}{5} - O\\left(T^3\\right) $$\n使用一个小的 $T$ 阈值（例如 $10^{-8}$）来在级数展开和涉及误差函数 $\\mathrm{erf}$ 的精确公式之间切换。\n\n算法流程如下：\n1. 对测试套件中的每个壳层四重态 $\\left(I,J\\mid K,L\\right)$ 和阈值 $\\tau$，确定所需的壳层对：$\\left(I,J\\right)$ 和 $\\left(K,L\\right)$。\n2. 对每个唯一的壳层对 $\\left(P,Q\\right)$，使用上述公式，通过对其所有组成的原初积分求和来计算积分 $\\left(PQ\\mid PQ\\right)$。使用缓存来存储和重用计算出的界值 $B_{PQ}$，以避免冗余计算。\n3. 计算壳层对界 $B_{PQ} = \\sqrt{\\left(PQ\\mid PQ\\right)}$。\n4. 在计算出界 $B_{IJ}$ 和 $B_{KL}$ 后，评估筛选条件 $B_{IJ}B_{KL} < \\tau$。\n5. 此比较的布尔结果决定了该四重态是否被筛选掉。收集所有测试用例的结果，并将其格式化为所需的输出字符串。\n该过程按照规定从第一性原理正确地实现了积分筛选。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the integral screening problem for a fixed set of Gaussian shells and quartets.\n    \"\"\"\n\n    # Define shell data structure\n    # Shells are dictionaries with center (np.array), alphas (np.array), and coeffs (np.array)\n    shells = [\n        # Shell 0\n        {'center': np.array([0.0, 0.0, 0.0]), 'alphas': np.array([0.5, 0.15]), 'coeffs': np.array([0.6, 0.4])},\n        # Shell 1\n        {'center': np.array([1.2, 0.0, 0.0]), 'alphas': np.array([0.9]), 'coeffs': np.array([1.0])},\n        # Shell 2\n        {'center': np.array([0.0, 2.0, 0.0]), 'alphas': np.array([0.3, 1.0]), 'coeffs': np.array([0.7, 0.3])},\n        # Shell 3\n        {'center': np.array([6.0, 0.0, 0.0]), 'alphas': np.array([0.2]), 'coeffs': np.array([1.0])},\n    ]\n\n    # Test cases: (I, J, K, L, tau)\n    test_cases = [\n        (0, 1, 0, 1, 1e-3),\n        (0, 3, 1, 3, 1e-6),\n        (1, 1, 1, 1, 1e-1),\n        (0, 2, 0, 2, 1e-3),\n        (2, 3, 2, 3, 1e-5),\n    ]\n\n    def boys_F0(T):\n        \"\"\"\n        Computes the Boys function F_0(T) in a numerically stable manner.\n        \"\"\"\n        if T < 1e-8:\n            return 1.0 - T/3.0 + T**2/5.0 - T**3/7.0 + T**4/9.0\n        else:\n            return 0.5 * np.sqrt(np.pi / T) * erf(np.sqrt(T))\n\n    # Vectorize the Boys function to apply it to NumPy arrays\n    vec_boys_F0 = np.vectorize(boys_F0)\n\n    def compute_B_IJ(shell_I, shell_J):\n        \"\"\"\n        Computes the shell-pair bound B_IJ = sqrt((IJ|IJ)).\n        This function is vectorized for efficiency and clarity.\n        \"\"\"\n        coeffs_I = shell_I['coeffs']\n        alphas_I = shell_I['alphas']\n        center_I = shell_I['center']\n\n        coeffs_J = shell_J['coeffs']\n        alphas_J = shell_J['alphas']\n        center_J = shell_J['center']\n\n        dist_sq_IJ = np.sum((center_I - center_J)**2)\n\n        # Expand primitive parameters into 4D arrays for vectorized computation\n        # Dimensions correspond to prims a, b, c, d\n        da = coeffs_I[:, None, None, None]\n        db = coeffs_J[None, :, None, None]\n        dc = coeffs_I[None, None, :, None]\n        dd = coeffs_J[None, None, None, :]\n        coeffs_prod = da * db * dc * dd\n        \n        aa = alphas_I[:, None, None, None]\n        ab = alphas_J[None, :, None, None]\n        ac = alphas_I[None, None, :, None]\n        ad = alphas_J[None, None, None, :]\n\n        # Compute arguments for the ERI formula\n        pab = aa + ab\n        pcd = ac + ad\n        \n        # Argument for Boys function\n        # T = [p_ab*p_cd / (p_ab+p_cd)] * ||P_ab - P_cd||^2\n        # ||P_ab - P_cd||^2 = [ (alpha_a*alpha_d - alpha_b*alpha_c) / (p_ab*p_cd) ]^2 * ||A_I - A_J||^2\n        T_factor = ((aa*ad - ab*ac)**2 / (pab * pcd * (pab + pcd)))\n        T = T_factor * dist_sq_IJ\n\n        # Handle T=0 case by avoiding division by zero\n        # This occurs when aa*ad - ab*ac = 0 or dist_sq_IJ = 0.\n        # np.nan_to_num will convert NaN from 0/0 to 0, which is correct for T.\n        T = np.nan_to_num(T)\n        f0_values = vec_boys_F0(T)\n\n        # Exponential prefactor\n        exp_term = np.exp(-(aa*ab/pab + ac*ad/pcd) * dist_sq_IJ)\n\n        # Normalization constants\n        N_a = (2 * aa / np.pi)**0.75\n        N_b = (2 * ab / np.pi)**0.75\n        N_c = (2 * ac / np.pi)**0.75\n        N_d = (2 * ad / np.pi)**0.75\n\n        # Constant part of the primitive integral formula\n        const_factor = (2 * np.pi**2.5) / (pab * pcd * np.sqrt(pab + pcd))\n        \n        # Combine all parts to get the primitive integrals\n        prim_integrals = N_a * N_b * N_c * N_d * const_factor * exp_term * f0_values\n        \n        # Sum over all primitive contributions\n        total_integral = np.sum(coeffs_prod * prim_integrals)\n\n        return np.sqrt(total_integral)\n\n    # Main logic\n    results = []\n    B_cache = {}\n\n    for I, J, K, L, tau in test_cases:\n        # Use sorted tuples as keys for commutativity, e.g., B_IJ = B_JI\n        pair1 = tuple(sorted((I, J)))\n        pair2 = tuple(sorted((K, L)))\n        \n        if pair1 not in B_cache:\n            B_cache[pair1] = compute_B_IJ(shells[pair1[0]], shells[pair1[1]])\n        \n        if pair2 not in B_cache:\n            B_cache[pair2] = compute_B_IJ(shells[pair2[0]], shells[pair2[1]])\n            \n        B_IJ = B_cache[pair1]\n        B_KL = B_cache[pair2]\n        \n        is_screened = B_IJ * B_KL < tau\n        results.append(is_screened)\n\n    # Format output as required: [True,False,...] with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2898970"}, {"introduction": "开发稳健的科学软件需要具备预见并处理极端情况的能力。虽然施瓦茨不等式在数学上是严谨的，但其简单的应用在处理收缩基组时可能会出现微妙的失效。本问题提出了一个发人深省的场景：基元函数间的相长干涉效应可能导致积分的真实范数远大于根据单个基元估算的范数，从而造成灾难性的筛选错误 [@problem_id:2899009]。分析此案例将有助于培养设计和评估更可靠、多阶段筛选策略所必需的批判性思维。", "problem": "考虑高斯基组中的电子排斥积分（ERI），其对收缩高斯型轨道（CGTO）的定义如下。每个收缩基函数是归一化原函数的线性组合，$\\chi_{\\mu}(\\mathbf{r}) = \\sum_{p} c_{\\mu p} g_{\\mu p}(\\mathbf{r})$，一个通用的 ERI 为 $(\\mu\\nu|\\lambda\\sigma) = \\iint \\chi_{\\mu}(\\mathbf{r}_1)\\chi_{\\nu}(\\mathbf{r}_1)\\frac{1}{r_{12}}\\chi_{\\lambda}(\\mathbf{r}_2)\\chi_{\\sigma}(\\mathbf{r}_2)\\,d\\mathbf{r}_1 d\\mathbf{r}_2$。根据柯西-施瓦茨不等式（CSI），可以得到界限 $|(\\mu\\nu|\\lambda\\sigma)| \\le \\| \\mu\\nu \\| \\cdot \\| \\lambda\\sigma \\|$，其中 $\\| \\mu\\nu \\| \\equiv \\sqrt{(\\mu\\nu|\\mu\\nu)}$。在实践中，积分筛选通常会在决定是否计算 $(\\mu\\nu|\\lambda\\sigma)$ 之前，以较低的计算成本估计 $\\|\\mu\\nu\\|$。\n\n给定一个具体的壳层对例子，旨在探究忽略收缩效应的朴素施瓦茨筛选的失效模式。假设有两个壳层对 $AB$ 和 $CD$，每个壳层由两个原函数构成，使得在库仑度规下的收缩壳层对“向量”可以表示为两个近乎平行的原函数乘积贡献的线性组合，\n$\\mathbf{v}_{AB} = w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2$ 和 $\\mathbf{v}_{CD} = u_1 \\mathbf{u}_1 + u_2 \\mathbf{u}_2$。假设以下明确数据成立：\n- 对于 $AB$：$\\|\\mathbf{v}_1\\| = \\|\\mathbf{v}_2\\| = 10^{-2}$，$\\langle \\mathbf{v}_1,\\mathbf{v}_2 \\rangle = 0.99 \\times 10^{-4}$，以及由收缩系数和归一化产生的权重 $w_1 = w_2 = 5$。\n- 对于 $CD$：$\\|\\mathbf{u}_1\\| = \\|\\mathbf{u}_2\\| = 10^{-2}$，$\\langle \\mathbf{u}_1,\\mathbf{u}_2 \\rangle = 0.99 \\times 10^{-4}$，以及权重 $u_1 = u_2 = 5$。\n\n进一步假设，收缩壳层对向量的相对方向满足 $\\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle = \\cos\\theta \\, \\|\\mathbf{v}_{AB}\\| \\, \\|\\mathbf{v}_{CD}\\|$，其中 $\\cos\\theta = 0.5$。筛选阈值 $\\tau$ 的使用方式如下：如果存在一个估计量 $\\widehat{\\|\\mu\\nu\\|}$，当 $\\widehat{\\|\\mu\\nu\\|}\\,\\widehat{\\|\\lambda\\sigma\\|} < \\tau$ 时，代码会跳过 $(\\mu\\nu|\\lambda\\sigma)$。取 $\\tau = 10^{-3}$。\n\n一位开发人员提出了一种忽略收缩结构的朴素单阶段估计，取 $\\widehat{\\|AB\\|} = \\max_{i\\in\\{1,2\\}} \\|\\mathbf{v}_i\\|$，对 $CD$ 也类似。要求你分析这种朴素筛选是否会在上述具体例子中漏掉大的 ERI，并仅使用基本不等式（柯西-施瓦茨不等式和三角不等式）和定义，选择一个不会漏掉它们的、鲁棒的多阶段筛选方法。\n\n以下哪个选项对该失效模式给出了正确的诊断，并提供了一个鲁棒、安全的多阶段筛选协议，该协议能在本例中避免漏掉大的 ERI，同时保持计算效率？\n\nA. 仅使用朴素的单阶段界限 $\\widehat{\\|AB\\|} = \\max_{i} \\|\\mathbf{v}_i\\|$ 和 $\\widehat{\\|CD\\|} = \\max_{j} \\|\\mathbf{u}_j\\|$。因为每个原函数的范数是任何收缩的上界，所以这保证是安全的；乘积 $10^{-2}\\cdot 10^{-2} = 10^{-4}$ 低于 $\\tau$，因此可以跳过 $(AB|CD)$。\n\nB. 使用一个考虑收缩效应的两阶段施瓦茨筛选。阶段1：应用三角不等式得到安全但廉价的界限 $\\widehat{\\|AB\\|}_{1} = \\sum_{i} |w_i| \\|\\mathbf{v}_i\\|$ 和 $\\widehat{\\|CD\\|}_{1} = \\sum_{j} |u_j| \\|\\mathbf{u}_j\\|$；如果 $\\widehat{\\|AB\\|}_{1}\\,\\widehat{\\|CD\\|}_{1} < \\tau$，则安全地跳过。否则，进入阶段2：通过原函数库仑度规计算精确的收缩壳层对范数，$\\|AB\\|^2 = \\mathbf{w}^\\top \\mathbf{M}^{(AB)} \\mathbf{w}$ 和 $\\|CD\\|^2 = \\mathbf{u}^\\top \\mathbf{M}^{(CD)} \\mathbf{u}$，其中 $\\mathbf{M}^{(AB)}_{ij} = \\langle \\mathbf{v}_i,\\mathbf{v}_j\\rangle$，对 $CD$ 也类似，然后应用收缩施瓦茨界限来决定。为了构建福克矩阵，添加密度加权筛选 $|P_{\\mu\\nu}|\\,\\| \\mu\\nu \\|$ 以进一步减少工作量。\n\nC. 用重叠度规筛选替换库仑度规施瓦茨界限，通过 $\\|S_{\\mu\\nu}\\| \\equiv \\sqrt{\\langle \\chi_\\mu \\chi_\\nu, \\chi_\\mu \\chi_\\nu \\rangle_S}$ 来估计 $\\|\\mu\\nu\\|$，其中 $\\langle \\cdot,\\cdot \\rangle_S$ 是重叠内积，因为重叠积分更便宜。由于重叠随距离的衰减比库仑相互作用快，这将比施瓦茨筛选更安全。\n\nD. 完全依赖于中心间距筛选。使用点电荷估计 $\\widehat{|(\\mu\\nu|\\lambda\\sigma)|} = 1/R_{\\text{min}}$，其中 $R_{\\text{min}}$ 是 $\\{A,B\\}$ 和 $\\{C,D\\}$ 之间的最小中心间距，忽略收缩系数和指数。这是一个通用的上界，因此任何满足 $\\widehat{|(\\mu\\nu|\\lambda\\sigma)|} < \\tau$ 的积分都可以被安全地跳过。", "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n- 收缩高斯型轨道 (CGTO): $\\chi_{\\mu}(\\mathbf{r}) = \\sum_{p} c_{\\mu p} g_{\\mu p}(\\mathbf{r})$。\n- 电子排斥积分 (ERI): $(\\mu\\nu|\\lambda\\sigma) = \\iint \\chi_{\\mu}(\\mathbf{r}_1)\\chi_{\\nu}(\\mathbf{r}_1)\\frac{1}{r_{12}}\\chi_{\\lambda}(\\mathbf{r}_2)\\chi_{\\sigma}(\\mathbf{r}_2)\\,d\\mathbf{r}_1 d\\mathbf{r}_2$。\n- 柯西-施瓦茨不等式 (CSI) 界限: $|(\\mu\\nu|\\lambda\\sigma)| \\le \\| \\mu\\nu \\| \\cdot \\| \\lambda\\sigma \\|$。\n- 壳层对范数: $\\| \\mu\\nu \\| \\equiv \\sqrt{(\\mu\\nu|\\mu\\nu)}$。\n- 收缩壳层对向量: $\\mathbf{v}_{AB} = w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2$ 和 $\\mathbf{v}_{CD} = u_1 \\mathbf{u}_1 + u_2 \\mathbf{u}_2$。内积是库仑度规，$\\langle \\mathbf{x}, \\mathbf{y} \\rangle \\equiv (\\mathbf{x}|\\mathbf{y})$。\n- $AB$ 壳层对原函数的数据：$\\|\\mathbf{v}_1\\| = 10^{-2}$，$\\|\\mathbf{v}_2\\| = 10^{-2}$，$\\langle \\mathbf{v}_1,\\mathbf{v}_2 \\rangle = 0.99 \\times 10^{-4}$，以及权重 $w_1 = 5$，$w_2 = 5$。\n- $CD$ 壳层对原函数的数据：$\\|\\mathbf{u}_1\\| = 10^{-2}$，$\\|\\mathbf{u}_2\\| = 10^{-2}$，$\\langle \\mathbf{u}_1,\\mathbf{u}_2 \\rangle = 0.99 \\times 10^{-4}$，以及权重 $u_1 = 5$，$u_2 = 5$。\n- 相对方向: $\\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle = \\cos\\theta \\, \\|\\mathbf{v}_{AB}\\| \\, \\|\\mathbf{v}_{CD}\\|$，其中 $\\cos\\theta = 0.5$。\n- 筛选阈值: $\\tau = 10^{-3}$。\n- 朴素估计量: $\\widehat{\\|AB\\|} = \\max_{i\\in\\{1,2\\}} \\|\\mathbf{v}_i\\|$。\n\n验证结论：\n该问题具有科学依据，题意明确，客观且内部一致。它通过一个具体、可形式化的例子，描述了量子化学积分计算中一个已知的、非平凡的复杂问题。所有必要数据均已提供。因此，该问题被认定为 **有效**。\n\n任务是分析朴素筛选协议的失效，并找出一个鲁棒的替代方案。我们进行严格的分析。\n\n首先，我们分析朴素筛选协议。收缩壳层对 $AB$ 的范数估计量为 $\\widehat{\\|AB\\|} = \\max_{i} \\|\\mathbf{v}_i\\|$。给定 $\\|\\mathbf{v}_1\\| = \\|\\mathbf{v}_2\\| = 10^{-2}$，可得 $\\widehat{\\|AB\\|} = 10^{-2}$。壳层对 $CD$ 的数据相同，所以 $\\widehat{\\|CD\\|} = \\max_{j} \\|\\mathbf{u}_j\\| = 10^{-2}$。筛选条件基于这些估计量的乘积：\n$$ \\widehat{\\|AB\\|} \\cdot \\widehat{\\|CD\\|} = (10^{-2}) \\cdot (10^{-2}) = 10^{-4} $$\n给定的阈值为 $\\tau = 10^{-3}$。由于 $10^{-4} < 10^{-3}$，这种朴素协议将不经计算就丢弃积分 $(AB|CD)$。\n\n接下来，我们必须通过计算积分的精确值来判断这个决定是否正确。该积分定义为内积 $(AB|CD) = \\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle$。我们已知 $\\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle = 0.5 \\cdot \\|\\mathbf{v}_{AB}\\| \\cdot \\|\\mathbf{v}_{CD}\\|$。我们必须计算收缩壳层对向量的精确范数。\n对于 $\\mathbf{v}_{AB}$:\n$$ \\|\\mathbf{v}_{AB}\\|^2 = \\langle w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2, w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2 \\rangle $$\n$$ \\|\\mathbf{v}_{AB}\\|^2 = w_1^2 \\|\\mathbf{v}_1\\|^2 + w_2^2 \\|\\mathbf{v}_2\\|^2 + 2 w_1 w_2 \\langle \\mathbf{v}_1, \\mathbf{v}_2 \\rangle $$\n代入所提供的数据：\n$$ \\|\\mathbf{v}_{AB}\\|^2 = (5^2)(10^{-2})^2 + (5^2)(10^{-2})^2 + 2(5)(5)(0.99 \\times 10^{-4}) $$\n$$ \\|\\mathbf{v}_{AB}\\|^2 = 25 \\times 10^{-4} + 25 \\times 10^{-4} + 50 \\times 0.99 \\times 10^{-4} $$\n$$ \\|\\mathbf{v}_{AB}\\|^2 = 50 \\times 10^{-4} + 49.5 \\times 10^{-4} = 99.5 \\times 10^{-4} $$\n$\\mathbf{v}_{CD}$ 的数据是相同的，所以 $\\|\\mathbf{v}_{CD}\\|^2 = 99.5 \\times 10^{-4}$。\n现在我们计算积分 $(AB|CD)$ 的值：\n$$ (AB|CD) = 0.5 \\cdot \\|\\mathbf{v}_{AB}\\| \\cdot \\|\\mathbf{v}_{CD}\\| = 0.5 \\cdot \\sqrt{99.5 \\times 10^{-4}} \\cdot \\sqrt{99.5 \\times 10^{-4}} $$\n$$ (AB|CD) = 0.5 \\cdot (99.5 \\times 10^{-4}) = 49.75 \\times 10^{-4} = 4.975 \\times 10^{-3} $$\n该积分的量值为 $|(AB|CD)| = 4.975 \\times 10^{-3}$。这个值大于筛选阈值 $\\tau = 10^{-3}$。朴素筛选协议估计其贡献量级为 $10^{-4}$，因此已灾难性地失败，并且会错误地丢弃一个数值上很重要的积分。失败源于原函数乘积分布之间的相长干涉（$\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 近乎平行，因为 $\\langle \\mathbf{v}_1, \\mathbf{v}_2 \\rangle / (\\|\\mathbf{v}_1\\|\\|\\mathbf{v}_2\\|) = 0.99$），并被大的收缩系数所放大。\n\n我们现在评估给出的选项。\n\nA. 该选项主张采用朴素筛选，声称它是“保证安全的”，因为“每个原函数的范数是任何收缩的上界”。这个前提显然是错误的。我们计算出收缩范数 $\\|\\mathbf{v}_{AB}\\| = \\sqrt{99.5 \\times 10^{-4}} \\approx 9.975 \\times 10^{-2}$，这比原函数范数 $\\|\\mathbf{v}_i\\| = 10^{-2}$ 大了将近一个数量级。如上所示，跳过该积分的结论是错误的。结论：**不正确**。\n\nB. 此选项提出一个两阶段筛选协议。阶段1：使用三角不等式建立一个安全的上界：$\\|\\mathbf{v}_{AB}\\| = \\|w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2\\| \\le |w_1|\\|\\mathbf{v}_1\\| + |w_2|\\|\\mathbf{v}_2\\|$。这是一个数学上严格的上界。我们来计算这个估计量 $\\widehat{\\|AB\\|}_{1}$:\n$$ \\widehat{\\|AB\\|}_{1} = |5| \\cdot 10^{-2} + |5| \\cdot 10^{-2} = 10 \\times 10^{-2} = 10^{-1} $$\n类似地，$\\widehat{\\|CD\\|}_{1} = 10^{-1}$。筛选乘积为 $\\widehat{\\|AB\\|}_{1} \\cdot \\widehat{\\|CD\\|}_{1} = 10^{-1} \\cdot 10^{-1} = 10^{-2}$。\n由于 $10^{-2} > \\tau = 10^{-3}$，这第一阶段正确地防止了积分被跳过，并要求进入下一阶段。\n阶段2：该阶段涉及计算精确的收缩范数的平方，$\\|AB\\|^2 = \\mathbf{w}^\\top \\mathbf{M}^{(AB)} \\mathbf{w}$，其中 $\\mathbf{M}^{(AB)}_{ij} = \\langle \\mathbf{v}_i, \\mathbf{v}_j \\rangle$。这正是我们为求得 $\\|\\mathbf{v}_{AB}\\|^2 = 99.5 \\times 10^{-4}$ 所做的计算。由此产生的施瓦茨界限是 $\\|\\mathbf{v}_{AB}\\| \\cdot \\|\\mathbf{v}_{CD}\\| = 99.5 \\times 10^{-4} \\approx 10^{-2}$。由于这个值大于 $\\tau=10^{-3}$，该积分被正确地标记为需要完全计算。这个两阶段协议既鲁棒（它在每个阶段都提供数学上保证的上界）又高效（只有当廉价的阶段1表明有必要时，才执行昂贵的阶段2）。关于密度加权筛选的最后评论是对实际代码中进一步优化的准确描述。结论：**正确**。\n\nC. 此选项建议用重叠度规筛选替换库仑度规施瓦茨界限。其声称这样做“更安全”，因为据说重叠比库仑相互作用衰减得更快。这在根本上是有缺陷的。筛选的安全性要求有严格的上界。没有普适的不等式能保证重叠范数 $\\sqrt{\\int (\\chi_\\mu\\chi_\\nu)^2 d\\mathbf{r}}$ 为库仑范数 $\\sqrt{(\\mu\\nu|\\mu\\nu)}$ 提供一个上界。对于弥散函数，其电荷分布很广，即使重叠很小，长程库仑相互作用仍然可能很大。该协议不能保证安全，它依赖的是物理直觉而非数学上的严谨性。结论：**不正确**。\n\nD. 此选项建议使用点电荷近似 $\\widehat{|(\\mu\\nu|\\lambda\\sigma)|} = 1/R_{\\text{min}}$，并声称它是一个“通用上界”。这显然是错误的。一个ERI的值关键取决于四个基函数的空间延展和重叠，这由它们的指数和收缩系数决定，而不仅仅是它们中心之间的距离。人们可以轻易地构造出反例。例如，对于两个高度弥散、相互重叠的电荷分布，即使 $R_{\\text{min}}$ 很大，积分值也可能非常大。反之，对于四个非常紧凑的函数，即使 $R_{\\text{min}}$ 很小，积分也可能微不足道。这个估计量是一个粗略的近似，而不是一个严格的界限，因此用于筛选是不安全的。结论：**不正确**。\n\n总之，只有选项 B 正确地诊断了朴素方法的失败，并提出了一个数学上可靠、鲁棒且分阶段的筛选协议，该协议能正确处理给定例子中收缩基函数的相长干涉情况。", "answer": "$$\\boxed{B}$$", "id": "2899009"}]}