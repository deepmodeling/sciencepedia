{"hands_on_practices": [{"introduction": "高效的直接 SCF 方法依赖于避免计算可忽略的积分，从而节省计算资源。要做到这一点，我们必须首先建立一个严格的数学基础，以便在不实际计算一个积分的情况下估算其贡献的大小。这项练习将引导你使用柯西-施瓦茨不等式，为交换矩阵（$K$ 矩阵）的一个关键组成部分推导出这样一个实用的上界，揭示积分筛选背后的核心原理。", "problem": "在积分驱动的直接自洽场 (SCF) 交换项构建中，交换矩阵元通过缩并 $K_{\\mu\\nu}=\\sum_{\\lambda\\sigma}(\\mu\\lambda|\\nu\\sigma)P_{\\lambda\\sigma}$ 定义，其中 $(\\mu\\lambda|\\nu\\sigma)$ 是在正交归一的原子中心高斯基组上的电子排斥积分 (ERI)，而 $P_{\\lambda\\sigma}$ 是单粒子密度矩阵的矩阵元。假设通过积分预筛选和密度的局域性，先验地已知以下信息：\n- 对于每对指标 $\\mu$ 和 $\\lambda$，定义 Schwarz 量 $Q_{\\mu\\lambda}=(\\mu\\lambda|\\mu\\lambda)$；对于每对指标 $\\nu$ 和 $\\sigma$，定义 $Q_{\\nu\\sigma}=(\\nu\\sigma|\\nu\\sigma)$。令累加的 Schwarz 和为 $A_{\\mu}=\\sum_{\\lambda}Q_{\\mu\\lambda}$ 和 $A_{\\nu}=\\sum_{\\sigma}Q_{\\nu\\sigma}$。\n- 密度矩阵是局域的，即最多有 $M$ 个矩阵元 $P_{\\lambda\\sigma}$ 非零，并且对于某个已知的常数 $P_{0}>0$，每个矩阵元都满足 $|P_{\\lambda\\sigma}|\\le P_{0}$。\n\n仅从 $K_{\\mu\\nu}$ 的定义、柯西-施瓦茨不等式以及上述局域性信息出发，确定您能保证的 $|K_{\\mu\\nu}|$ 的最紧标量上界 $B_{\\mu\\nu}$，该上界仅依赖于 $A_{\\mu}$、$A_{\\nu}$、$M$ 和 $P_{0}$，且不引入任何额外的体系特定量。请用一个仅包含 $A_{\\mu}$、$A_{\\nu}$、$M$ 和 $P_{0}$ 的单一闭式解析表达式给出您的最终结果。不需要进行数值计算，最终表达式也不需要单位。", "solution": "问题陈述经评估后被确定为有效。它在科学上基于量子化学原理，特别是 Hartree-Fock 理论，并且是一个提法恰当的数学问题，具有足够的信息来获得唯一解。\n\n目标是利用给定的定义和约束，求出交换矩阵元大小 $|K_{\\mu\\nu}|$ 的最紧标量上界。交换矩阵元定义为：\n$$\nK_{\\mu\\nu} = \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma}\n$$\n此处，$(\\mu\\lambda|\\nu\\sigma)$ 是电子排斥积分 (ERI)，而 $P_{\\lambda\\sigma}$ 是单粒子密度矩阵的矩阵元。指标 $\\mu, \\nu, \\lambda, \\sigma$ 指的是正交归一基组中的基函数。\n\n为求 $|K_{\\mu\\nu}|$ 的上界，我们首先对定义表达式取绝对值：\n$$\n|K_{\\mu\\nu}| = \\left| \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma} \\right|\n$$\n对指标对 $(\\lambda, \\sigma)$ 的求和可以解释为两个高维向量的点积。设一个向量 $V$ 由 ERI 元 $V_{\\lambda\\sigma} = (\\mu\\lambda|\\nu\\sigma)$ 构成，第二个向量 $P$ 由密度矩阵元 $P_{\\lambda\\sigma}$ 构成。那么该求和等价于一个点积。我们应用柯西-施瓦茨不等式，该不等式表明对于两个向量 $V$ 和 $P$，有 $|\\langle V, P \\rangle|^2 \\le \\|V\\|^2 \\|P\\|^2$。用我们的符号表示，这变为：\n$$\n|K_{\\mu\\nu}|^2 = \\left| \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma} \\right|^2 \\le \\left( \\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\right) \\left( \\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 \\right)\n$$\n现在，我们利用问题陈述中提供的信息，分别求出右侧两项的上界。\n\n首先，我们来界定包含 ERI 的项：$\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2$。\n该问题要求使用柯西-施瓦茨不等式。一个标准的 ERI 不等式是：该不等式本身是在库仑算符下，对电荷分布 $\\rho_{\\mu\\lambda}(\\mathbf{r}_1) = \\phi_{\\mu}^*(\\mathbf{r}_1)\\phi_{\\lambda}(\\mathbf{r}_1)$ 和 $\\rho_{\\nu\\sigma}(\\mathbf{r}_2) = \\phi_{\\nu}^*(\\mathbf{r}_2)\\phi_{\\sigma}(\\mathbf{r}_2)$ 应用柯西-施瓦茨不等式得到的结果。\n$$\n|(\\mu\\lambda|\\nu\\sigma)|^2 \\le (\\mu\\lambda|\\mu\\lambda)(\\nu\\sigma|\\nu\\sigma)\n$$\n问题中给出了 Schwarz 量的定义：$Q_{\\mu\\lambda} = (\\mu\\lambda|\\mu\\lambda)$ 和 $Q_{\\nu\\sigma} = (\\nu\\sigma|\\nu\\sigma)$。将这些代入不等式，得到：\n$$\n|(\\mu\\lambda|\\nu\\sigma)|^2 \\le Q_{\\mu\\lambda} Q_{\\nu\\sigma}\n$$\n由于这对求和中的每一项都成立，我们可以写出：\n$$\n\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\le \\sum_{\\lambda,\\sigma} Q_{\\mu\\lambda} Q_{\\nu\\sigma}\n$$\n右侧的被加数是一个关于 $\\lambda$ 的函数和一个关于 $\\sigma$ 的函数的乘积。因此，这个双重求和可以分解为两个单一求和的乘积：\n$$\n\\sum_{\\lambda,\\sigma} Q_{\\mu\\lambda} Q_{\\nu\\sigma} = \\left( \\sum_{\\lambda} Q_{\\mu\\lambda} \\right) \\left( \\sum_{\\sigma} Q_{\\nu\\sigma} \\right)\n$$\n使用累加的 Schwarz 和的定义，$A_{\\mu}=\\sum_{\\lambda}Q_{\\mu\\lambda}$ 和 $A_{\\nu}=\\sum_{\\sigma}Q_{\\nu\\sigma}$，我们得到第一项的上界：\n$$\n\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\le A_{\\mu} A_{\\nu}\n$$\n\n接下来，我们界定包含密度矩阵的项：$\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2$。\n给定条件是最多有 $M$ 个 $P_{\\lambda\\sigma}$ 元素非零。设 $S$ 为使 $P_{\\lambda\\sigma} \\neq 0$ 的指标对 $(\\lambda, \\sigma)$ 的集合。该集合的大小为 $|S| \\le M$。因此，求和可以简化为对集合 $S$ 的求和：\n$$\n\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 = \\sum_{(\\lambda, \\sigma) \\in S} |P_{\\lambda\\sigma}|^2\n$$\n我们还知道，对于任何元素，都有 $|P_{\\lambda\\sigma}| \\le P_0$。将此不等式平方，得到 $|P_{\\lambda\\sigma}|^2 \\le P_0^2$。将此应用于求和中的每一项：\n$$\n\\sum_{(\\lambda, \\sigma) \\in S} |P_{\\lambda\\sigma}|^2 \\le \\sum_{(\\lambda, \\sigma) \\in S} P_0^2 = |S| P_0^2\n$$\n利用 $|S| \\le M$ 这一事实，我们得到第二项的上界：\n$$\n\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 \\le M P_0^2\n$$\n\n最后，我们将这两项的上界合并回关于 $|K_{\\mu\\nu}|^2$ 的原始不等式中：\n$$\n|K_{\\mu\\nu}|^2 \\le (A_{\\mu} A_{\\nu}) (M P_0^2) = M P_0^2 A_{\\mu} A_{\\nu}\n$$\n对两边取平方根，得到 $|K_{\\mu\\nu}|$ 所需的上界 $B_{\\mu\\nu}$。因为 $P_0 > 0$，我们有：\n$$\n|K_{\\mu\\nu}| \\le \\sqrt{M P_0^2 A_{\\mu} A_{\\nu}} = P_0 \\sqrt{M A_{\\mu} A_{\\nu}}\n$$\n该表达式是仅根据给定信息所能保证的最紧上界，因为它是由不等式的直接应用推导出来的。虽然这些不等式的等号成立条件通常不满足，但若无进一步的体系特定知识，该上界也无法改进。最终结果按要求仅依赖于 $A_{\\mu}$、$A_{\\nu}$、$M$ 和 $P_{0}$。", "answer": "$$\n\\boxed{P_{0} \\sqrt{M A_{\\mu} A_{\\nu}}}\n$$", "id": "2886238"}, {"introduction": "了解了可以对积分进行筛选之后，下一个关键问题是量化这种策略带来的性能提升。本实践将探讨算术强度（arithmetic intensity）这一高性能计算中的核心指标，通过它来比较有无积分筛选的直接 SCF 计算。通过这个练习，你将理解筛选如何改变计算的瓶颈，例如从受内存带宽限制转变为受 CPU 计算速度限制，从而更深入地把握算法的性能特征。", "problem": "考虑一个直接自洽场 (SCF) Fock 矩阵的构建，该构建使用积分驱动算法，基于大小为 $N=20$ 的原子轨道 (AO) 基组。在此设置中，电子排斥积分 (ERIs) 是即时计算并立即收缩到 Fock 矩阵中的。假设采用以下具有科学依据的成本模型，该模型旨在捕捉此类构建的主要算术和内存行为：\n\n- 整个过程使用双精度，因此每个浮点数占用 $8$ 字节。\n- 排列唯一的 AO ERI 的数量近似为 $N^{4}/8$。\n- 计算一个收缩的 AO ERI 需要 $2000$ 次浮点运算 (flops)。\n- 对于每个实际计算（即未被筛选掉）的 ERI，会执行恰好 $6$ 次 Fock 更新；每次更新是对一个 Fock 元素进行一次乘加操作，并伴随一次密度读取：\n  - 将每次乘加计为 $2$ flops。\n  - 将每次密度读取计为 $8$ 字节。\n  - 将每次 Fock 更新计为一次双精度数的读-改-写操作，每次更新的 Fock 元素的内存流量为 $16$ 字节。\n- 在没有筛选的情况下，所有 $N^{4}/8$ 个积分都会被计算，并且不执行任何筛选检查。\n- 在使用 Schwarz 型筛选的情况下，对于每个候选积分（在相同的 $N^{4}/8$ 个候选项中），会通过读取两个预先计算的壳层对界限（每个 AO 对一个）来执行一次界限检查，每个候选项的成本为总计 $16$ 字节和 $2$ flops。只有一部分 $s=0.10$ 的候选项通过界限检查，并继续进行上述完整的 ERI 计算和 Fock 更新。如果一个候选项未能通过检查，则不会对该候选项执行 ERI 计算和 Fock 更新。\n\n使用算术强度（总浮点运算次数除以与主内存之间传输的总字节数）的定义，计算整个 Fock 构建过程的算术强度：\n- $I_{\\text{no-screen}}$：无筛选情况，\n- $I_{\\text{screen}}$：有筛选情况。\n\n两个答案都以 flops/byte 为单位表示。将你的答案四舍五入到三位有效数字。在最终的方框答案中不要包含单位；按顺序 $\\bigl(I_{\\text{no-screen}},\\,I_{\\text{screen}}\\bigr)$ 报告这两个值。", "solution": "该问题要求计算在两种条件下（无积分筛选和有积分筛选）直接自洽场 (SCF) Fock 矩阵构建的算术强度。算术强度 $I$ 定义为总浮点运算次数 (flops) 与进出主内存的总字节数之比。\n\n$$I = \\frac{\\text{总浮点运算量}}{\\text{总字节数}}$$\n\n首先，我们确定问题陈述中给出的参数。\n原子轨道 (AO) 基组的大小为 $N=20$。\n排列唯一的双电子排斥积分 (ERIs) 的数量近似为 $N_{ERI} = \\frac{N^{4}}{8}$。\n当 $N=20$ 时，其值为：\n$$N_{ERI} = \\frac{20^{4}}{8} = \\frac{160000}{8} = 20000$$\n\n成本模型参数如下：\n- 计算一个 ERI 的 flops：$F_{eval} = 2000$ flops。\n- 每个计算的 ERI 对应的 Fock 更新次数：$U_{ERI} = 6$。\n- 每次 Fock 更新的成本：\n    - flops：$F_{update} = 2$ flops（一次乘加）。\n    - 内存流量：$B_{update} = 8 \\text{ 字节 (密度读取)} + 16 \\text{ 字节 (Fock 读-改-写)} = 24 \\text{ 字节}$。\n- 每次筛选检查的成本：\n    - flops：$F_{screen\\_check} = 2$ flops。\n    - 内存流量：$B_{screen\\_check} = 16$ 字节（两个壳层对界限）。\n- 通过筛选的积分比例：$s = 0.10$。\n\n我们现在将分别分析每种情况。\n\n情况 1：无筛选 ($I_{\\text{no-screen}}$)\n在这种情况下，所有 $N_{ERI}$ 个积分都被计算并贡献给 Fock 矩阵。不执行任何筛选检查。\n\n首先，我们计算总浮点运算次数 $F_{\\text{no-screen}}$。这是 ERI 计算的 flops 与后续 Fock 更新的 flops 之和。\n所有 $N_{ERI}$ 个积分的 ERI 计算 flops 为 $N_{ERI} \\times F_{eval}$。\n所有 $N_{ERI}$ 个积分的 Fock 更新 flops 为 $N_{ERI} \\times U_{ERI} \\times F_{update}$。\n$$F_{\\text{no-screen}} = N_{ERI} \\times (F_{eval} + U_{ERI} \\times F_{update})$$\n$$F_{\\text{no-screen}} = 20000 \\times (2000 + 6 \\times 2) = 20000 \\times (2000 + 12) = 20000 \\times 2012 = 40240000 \\text{ flops}$$\n\n接下来，我们计算总内存流量 $B_{\\text{no-screen}}$。在这种直接算法中，唯一指定的内存流量是在更新步骤中由密度矩阵读取和 Fock 矩阵的读-改-写操作产生的。\n$$B_{\\text{no-screen}} = N_{ERI} \\times U_{ERI} \\times B_{update}$$\n$$B_{\\text{no-screen}} = 20000 \\times 6 \\times 24 = 2880000 \\text{ 字节}$$\n\n算术强度是这两个量的比值。\n$$I_{\\text{no-screen}} = \\frac{F_{\\text{no-screen}}}{B_{\\text{no-screen}}} = \\frac{40240000}{2880000} = \\frac{4024}{288} \\approx 13.9722$$\n四舍五入到三位有效数字，我们得到 $I_{\\text{no-screen}} = 14.0$ flops/byte。\n\n情况 2：使用 Schwarz 型筛选 ($I_{\\text{screen}}$)\n在这种情况下，对 $N_{ERI}$ 个候选积分中的每一个都执行筛选检查。只有一部分 $s$ 的积分通过检查，并继续进行完整的 ERI 计算和 Fock 更新步骤。\n\n实际计算的积分数量为 $N_{comp} = s \\times N_{ERI} = 0.10 \\times 20000 = 2000$。\n\n总浮点运算次数 $F_{\\text{screen}}$ 是所有筛选检查的 flops，加上对通过检查的积分进行计算和处理的 flops 之和。\n所有 $N_{ERI}$ 个候选项的筛选检查 flops：$N_{ERI} \\times F_{screen\\_check}$。\n计算的 $N_{comp}$ 个积分的 ERI 计算和 Fock 更新 flops：$N_{comp} \\times (F_{eval} + U_{ERI} \\times F_{update})$。\n$$F_{\\text{screen}} = (N_{ERI} \\times F_{screen\\_check}) + (s \\times N_{ERI}) \\times (F_{eval} + U_{ERI} \\times F_{update})$$\n$$F_{\\text{screen}} = (20000 \\times 2) + (0.10 \\times 20000) \\times (2000 + 6 \\times 2)$$\n$$F_{\\text{screen}} = 40000 + 2000 \\times 2012 = 40000 + 4024000 = 4064000 \\text{ flops}$$\n\n总内存流量 $B_{\\text{screen}}$ 是所有筛选检查产生的内存流量与通过筛选的积分的 Fock 更新产生的流量之和。\n所有 $N_{ERI}$ 个候选项的筛选检查产生的内存流量：$N_{ERI} \\times B_{screen\\_check}$。\n计算的 $N_{comp}$ 个积分的 Fock 更新产生的内存流量：$N_{comp} \\times U_{ERI} \\times B_{update}$。\n$$B_{\\text{screen}} = (N_{ERI} \\times B_{screen\\_check}) + (s \\times N_{ERI}) \\times U_{ERI} \\times B_{update}$$\n$$B_{\\text{screen}} = (20000 \\times 16) + (0.10 \\times 20000) \\times 6 \\times 24$$\n$$B_{\\text{screen}} = 320000 + 2000 \\times 144 = 320000 + 288000 = 608000 \\text{ 字节}$$\n\n算术强度是这两个量的比值。\n$$I_{\\text{screen}} = \\frac{F_{\\text{screen}}}{B_{\\text{screen}}} = \\frac{4064000}{608000} = \\frac{4064}{608} \\approx 6.6842$$\n四舍五入到三位有效数字，我们得到 $I_{\\text{screen}} = 6.68$ flops/byte。\n\n结果是 $I_{\\text{no-screen}} \\approx 14.0$ 和 $I_{\\text{screen}} \\approx 6.68$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n14.0 & 6.68\n\\end{pmatrix}\n}\n$$", "id": "2886242"}, {"introduction": "在前两个练习的基础上，我们面临一个非常实际的挑战：如何选择合适的积分筛选阈值 $\\tau$。阈值太宽松会牺牲计算精度，而太严格则会牺牲计算效率。这个问题将指导你设计一个自适应算法，该算法能够自动确定最佳阈值，以保证总能量的误差在用户指定的容差范围内。这个练习将理论界限与稳健的实际应用联系起来，展示了如何在实践中智能地平衡计算的准确性与效率。", "problem": "设计并实现一个算法测试，该测试在采用积分驱动筛选的直接自洽场 (SCF) 程序中，对于给定的闭壳层限制性 Hartree-Fock (RHF) 迭代，自适应地选择积分筛选阈值 $ \\tau $，以使每次迭代中总电子能量的最终变化不超过指定的以 Hartree 为单位的容差。该算法必须基于第一性原理，且不得依赖任何为 $ \\tau $ 预先计算的快捷公式。\n\n假设以下基本事实和定义：\n- 在原子轨道基下，RHF Fock 矩阵 $ F $ 的元素为\n$$ F_{\\mu \\nu} = H_{\\mu \\nu} + \\sum_{\\lambda \\sigma} P_{\\lambda \\sigma} \\left[ (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{2} (\\mu \\lambda|\\nu \\sigma) \\right], $$\n其中 $ H_{\\mu \\nu} $ 是单电子（核心）哈密顿量，$ P_{\\lambda \\sigma} $ 是密度矩阵，$ (\\mu \\nu|\\lambda \\sigma) $ 是化学家记法中的双电子排斥积分。\n- RHF 总电子能量为\n$$ E = \\tfrac{1}{2} \\sum_{\\mu \\nu} P_{\\mu \\nu} \\left( H_{\\mu \\nu} + F_{\\mu \\nu} \\right) $$\n- 在采用积分驱动算法的直接 SCF 方法中，积分使用 Cauchy–Schwarz 不等式进行筛选。定义一个非负对界限矩阵 $ Q \\in \\mathbb{R}^{N \\times N} $，其元素为\n$$ Q_{\\mu \\nu} = \\sqrt{ (\\mu \\nu|\\mu \\nu) }, $$\n因此 Cauchy–Schwarz 界给出\n$$ \\left| (\\mu \\nu|\\lambda \\sigma) \\right| \\le Q_{\\mu \\nu} \\, Q_{\\lambda \\sigma} $$\n- 使用一个阈值 $ \\tau > 0 $ 来忽略任何其界限严格小于 $ \\tau $ 的双电子贡献。具体而言，如果 $ Q_{\\mu \\nu} Q_{\\lambda \\sigma} < \\tau $，则忽略一个库仑贡献 $ (\\mu \\nu|\\lambda \\sigma) $；如果 $ Q_{\\mu \\lambda} Q_{\\nu \\sigma} < \\tau $，则忽略一个交换贡献 $ (\\mu \\lambda|\\nu \\sigma) $。\n\n你的任务是：\n- 从上述定义和三角不等式出发，推导出一个可计算且单调不减的上界 $ \\Delta E_{\\mathrm{bound}}(\\tau) $，该上界是关于 $ \\tau $ 的函数，表示在固定密度 $ P $ 的情况下，单次 SCF 迭代中仅由积分筛选所引起的能量变化大小 $ |\\Delta E| $。你必须仅使用 $ P $、$ Q $ 和 $ \\tau $ 来表示此界，不含任何未知积分。\n- 利用此界，设计一个 $ \\tau $ 的自适应选择规则，选择使 $ \\Delta E_{\\mathrm{bound}}(\\tau) \\le \\varepsilon $ 成立的最大 $ \\tau $，其中 $ \\varepsilon $ 是用户指定的、因筛选导致的每次迭代总能量最大允许变化的容差（以 Hartree 为单位）。\n- 将此选择规则实现为一个程序，该程序为每个测试用例计算并返回所选的 $ \\tau $。\n\n实现要求：\n- 将 $ P $ 和 $ Q $ 表示为大小为 $ N \\times N $ 的稠密数组。为每个测试用例明确定义 $ N $。\n- 将所有量视为无量纲，但能量容差 $ \\varepsilon $ 除外，其必须理解为以 Hartree 为单位。\n- 对于给定的 $ \\tau $，定义指示函数\n$$ \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) = \\begin{cases} 1 & \\text{if } Q_{\\mu \\nu} Q_{\\lambda \\sigma} < \\tau, \\\\ 0 & \\text{otherwise}, \\end{cases}\n\\quad\n\\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) = \\begin{cases} 1 & \\text{if } Q_{\\mu \\lambda} Q_{\\nu \\sigma} < \\tau, \\\\ 0 & \\text{otherwise}, \\end{cases} $$\n并在你的界中使用密度绝对值 $ |P_{\\mu \\nu}| $，以通过三角不等式确保其为上界。\n- 对于固定的 $ \\tau $，你的界 $ \\Delta E_{\\mathrm{bound}}(\\tau) $ 必须能在 $ O(N^4) $ 或更优的时间内计算，并且必须是关于 $ \\tau $ 的单调不减函数。\n- 选择 $ \\tau $ 的搜索区间为 $ [0, \\tau_{\\max}] $，其中\n$$ \\tau_{\\max} = \\left( \\max_{\\mu \\nu} Q_{\\mu \\nu} \\right)^2, $$\n并选择 $ [0, \\tau_{\\max}] $ 中满足 $ \\Delta E_{\\mathrm{bound}}(\\tau) \\le \\varepsilon $ 的最大 $ \\tau $。如果 $ \\Delta E_{\\mathrm{bound}}(\\tau_{\\max}) \\le \\varepsilon $，则返回 $ \\tau_{\\max} $。\n- 使用鲁棒的单调求根策略（如二分法）来找到最大的允许 $ \\tau $。\n\n测试套件：\n提供一个程序，为以下四个测试用例评估自适应的 $ \\tau $。每个测试用例包含一个矩阵大小 $ N $、一个密度矩阵 $ P \\in \\mathbb{R}^{N \\times N} $（使用对称的 $ P $）、一个具有非负元素的对界限矩阵 $ Q \\in \\mathbb{R}^{N \\times N} $，以及一个以 Hartree 为单位的能量容差 $ \\varepsilon $。除 $ \\varepsilon $ 外，以下所有数字均为无量纲。\n\n- 案例 A（通用，中等容差）：$ N = 3 $，\n  $$\n  P = \\begin{pmatrix}\n  1.90 & 0.20 & 0.10 \\\\\n  0.20 & 1.80 & 0.05 \\\\\n  0.10 & 0.05 & 1.70\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.50 & 0.20 & 0.10 \\\\\n  0.20 & 0.60 & 0.15 \\\\\n  0.10 & 0.15 & 0.40\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-4}.\n  $$\n- 案例 B（零密度边缘情况）：$ N = 2 $，\n  $$\n  P = \\begin{pmatrix}\n  0.0 & 0.0 \\\\\n  0.0 & 0.0\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.30 & 0.10 \\\\\n  0.10 & 0.25\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-6}.\n  $$\n- 案例 C（与 A 相同，但容差更紧）：$ N = 3 $，\n  $$\n  P = \\begin{pmatrix}\n  1.90 & 0.20 & 0.10 \\\\\n  0.20 & 1.80 & 0.05 \\\\\n  0.10 & 0.05 & 1.70\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.50 & 0.20 & 0.10 \\\\\n  0.20 & 0.60 & 0.15 \\\\\n  0.10 & 0.15 & 0.40\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-8}.\n  $$\n- 案例 D（与 A 相同，但容差更宽松）：$ N = 3 $，\n  $$\n  P = \\begin{pmatrix}\n  1.90 & 0.20 & 0.10 \\\\\n  0.20 & 1.80 & 0.05 \\\\\n  0.10 & 0.05 & 1.70\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.50 & 0.20 & 0.10 \\\\\n  0.20 & 0.60 & 0.15 \\\\\n  0.10 & 0.15 & 0.40\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-2}.\n  $$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例 A、B、C、D 相同。每个 $ \\tau $ 值必须四舍五入到恰好 $ 8 $ 位小数。例如，输出应类似于 $ [\\tau_A,\\tau_B,\\tau_C,\\tau_D] $，每个 $ \\tau $ 打印到 $ 8 $ 位小数，且无额外文本。无需用户输入。", "solution": "所提出的问题是计算量子化学中一个明确定义的练习，具体涉及直接自洽场 (SCF) 方法。它在科学上基于 Hartree-Fock 理论的原理以及使用标准数学不等式进行积分筛选。该问题是自洽的，提供了所有必要的定义和数据，并且没有歧义或矛盾。因此值得一个完整的、有理有据的解答。\n\n目标是推导因在单次限制性 Hartree-Fock (RHF) 迭代中进行积分筛选而引入的总电子能量误差的上界，并利用此界自适应地选择筛选阈值 $\\tau$。\n\n步骤 1：能量误差界 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 的推导\n\nRHF 总电子能量由下式给出：\n$$ E = \\tfrac{1}{2} \\sum_{\\mu \\nu} P_{\\mu \\nu} (H_{\\mu \\nu} + F_{\\mu \\nu}) $$\n其中 $P$ 是密度矩阵，$H$ 是核心哈密顿矩阵，$F$ 是 Fock 矩阵。将 Fock 矩阵的表达式\n$$ F_{\\mu \\nu} = H_{\\mu \\nu} + \\sum_{\\lambda \\sigma} P_{\\lambda \\sigma} \\left[ (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{2} (\\mu \\lambda|\\nu \\sigma) \\right] $$\n代入能量表达式可得：\n$$ E = \\tfrac{1}{2} \\sum_{\\mu \\nu} P_{\\mu \\nu} \\left( 2H_{\\mu \\nu} + \\sum_{\\lambda \\sigma} P_{\\lambda \\sigma} \\left[ (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{2} (\\mu \\lambda|\\nu \\sigma) \\right] \\right) $$\n$$ E = \\sum_{\\mu \\nu} P_{\\mu \\nu} H_{\\mu \\nu} + \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\lambda|\\nu \\sigma) $$\n在阈值 $\\tau$ 下进行积分筛选会因忽略某些双电子排斥积分而引入误差。能量的单电子部分 $\\sum_{\\mu \\nu} P_{\\mu \\nu} H_{\\mu \\nu}$ 不受影响。能量变化 $\\Delta E$ 是所有被忽略的双电子能量贡献之和。根据问题描述，如果一个库仑项 $(\\mu \\nu|\\lambda \\sigma)$ 的 Cauchy-Schwarz 界 $Q_{\\mu \\nu} Q_{\\lambda \\sigma} < \\tau$，则该项被忽略；如果一个交换项 $(\\mu \\lambda|\\nu \\sigma)$ 的界 $Q_{\\mu \\lambda} Q_{\\nu \\sigma} < \\tau$，则该项被忽略。使用问题中定义的指示函数 $\\chi^J$ 和 $\\chi^K$，总能量变化为：\n$$ \\Delta E(\\tau) = \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\nu|\\lambda \\sigma) \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) - \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\lambda|\\nu \\sigma) \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) $$\n我们寻求此变化大小 $|\\Delta E(\\tau)|$ 的上界。使用三角不等式：\n$$ |\\Delta E(\\tau)| \\le \\left| \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\nu|\\lambda \\sigma) \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) \\right| + \\left| \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\lambda|\\nu \\sigma) \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) \\right| $$\n再次应用三角不等式将绝对值移到求和符号内部，并利用属性 $|ab| = |a||b|$：\n$$ |\\Delta E(\\tau)| \\le \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| |(\\mu \\nu|\\lambda \\sigma)| \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) + \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| |(\\mu \\lambda|\\nu \\sigma)| \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) $$\n现在，我们应用所提供的积分的 Cauchy-Schwarz 界：$|(\\mu \\nu|\\lambda \\sigma)| \\le Q_{\\mu \\nu} Q_{\\lambda \\sigma}$ 和 $|(\\mu \\lambda|\\nu \\sigma)| \\le Q_{\\mu \\lambda} Q_{\\nu \\sigma}$。这就得出了一个可计算的上界 $\\Delta E_{\\mathrm{bound}}(\\tau)$：\n$$ \\Delta E_{\\mathrm{bound}}(\\tau) = \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| Q_{\\mu \\nu} Q_{\\lambda \\sigma} \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) + \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| Q_{\\mu \\lambda} Q_{\\nu \\sigma} \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) $$\n此表达式定义了所求的界。它仅依赖于已知的矩阵 $P$ 和 $Q$ 以及阈值 $\\tau$。求和是在满足相应筛选条件（$Q_{\\mu \\nu} Q_{\\lambda \\sigma} < \\tau$ 和 $Q_{\\mu \\lambda} Q_{\\nu \\sigma} < \\tau$）的所有指标上进行的。由于求和中的所有项都是非负的，并且随着 $\\tau$ 的增加，求和的范围会扩大或保持不变，因此 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 是关于 $\\tau$ 的单调不减函数。\n\n步骤 2：自适应阈值选择的算法设计\n\n目标是找到区间 $[0, \\tau_{\\max}]$ 内使得 $\\Delta E_{\\mathrm{bound}}(\\tau) \\le \\varepsilon$ 成立的最大阈值 $\\tau$，其中 $\\varepsilon$ 是给定的容差。最大阈值由积分界限的最大可能值决定：\n$$ \\tau_{\\max} = \\left( \\max_{\\mu, \\nu} Q_{\\mu \\nu} \\right)^2 $$\n函数 $f(\\tau) = \\Delta E_{\\mathrm{bound}}(\\tau) - \\varepsilon$ 是单调不减的。我们正在寻找使 $f(\\tau) \\le 0$ 成立的最大 $\\tau$。这是一个求根问题。\n\n算法流程如下：\n1.  对于给定的测试用例（$N$、$P$、$Q$、$\\varepsilon$），计算 $\\tau_{\\max}$。\n2.  计算 $\\Delta E_{\\mathrm{bound}}(\\tau_{\\max})$。如果 $\\Delta E_{\\mathrm{bound}}(\\tau_{\\max}) \\le \\varepsilon$，则区间 $[0, \\tau_{\\max}]$ 内的任何 $\\tau$ 都可接受。其中最大的值为 $\\tau_{\\max}$，即为解。\n3.  如果 $\\Delta E_{\\mathrm{bound}}(\\tau_{\\max}) > \\varepsilon$，则必须存在一个解 $\\tau^* < \\tau_{\\max}$，因为 $\\Delta E_{\\mathrm{bound}}(0) = 0 \\le \\varepsilon$。由于 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 是单调的，存在唯一的根 $\\tau^*$ 使得 $\\Delta E_{\\mathrm{bound}}(\\tau^*) = \\varepsilon$。此根即为 $\\tau$ 的最大允许值。我们可以使用二分搜索在区间 $[0, \\tau_{\\max}]$ 上找到它。\n\n二分算法如下：\na.  初始化 `low` = $0$，`high` = $\\tau_{\\max}$。\nb.  重复足够多的迭代次数（例如，对于双精度准确性，重复 100 次）：\n    i.   计算 `mid` = (`low` + `high`) / $2$。\n    ii.  计算 $E_{\\text{mid}} = \\Delta E_{\\mathrm{bound}}(\\text{mid})$。\n    iii. 如果 $E_{\\text{mid}} \\le \\varepsilon$，这意味着 `mid` 是一个有效的阈值，并且可能存在更大的阈值。因此，我们将搜索空间更新到上半部分：`low` = `mid`。\n    iv.  如果 $E_{\\text{mid}} > \\varepsilon$，则 `mid` 太大。我们必须在下半部分搜索一个更小的阈值：`high` = `mid`。\nc.  `low`（或 `high`）的最终值就是所求的最优阈值 $\\tau$。\n\n计算 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 的函数将使用四个嵌套循环为两个项（库仑项和交换项）中的每一项进行实现，每次计算的总体复杂度为 $O(N^4)$，考虑到问题的约束和较小的 $N$ 值，这是可以接受的。\n\n此过程为确定积分筛选阈值提供了一种鲁棒且有原则的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta_e_bound(tau, P, Q):\n    \"\"\"\n    Computes the upper bound on the energy change due to integral screening.\n\n    Args:\n        tau (float): The integral screening threshold.\n        P (np.ndarray): The density matrix (N x N).\n        Q (np.ndarray): The pair bound matrix (N x N).\n\n    Returns:\n        float: The energy error bound Delta_E_bound(tau).\n    \"\"\"\n    N = P.shape[0]\n    P_abs = np.abs(P)\n    \n    # Coulomb term contribution\n    J_bound = 0.0\n    for mu in range(N):\n        for nu in range(N):\n            for lam in range(N):\n                for sig in range(N):\n                    q_prod = Q[mu, nu] * Q[lam, sig]\n                    if q_prod < tau:\n                        J_bound += 0.5 * P_abs[mu, nu] * P_abs[lam, sig] * q_prod\n\n    # Exchange term contribution\n    K_bound = 0.0\n    for mu in range(N):\n        for nu in range(N):\n            for lam in range(N):\n                for sig in range(N):\n                    q_prod = Q[mu, lam] * Q[nu, sig]\n                    if q_prod < tau:\n                        K_bound += 0.25 * P_abs[mu, nu] * P_abs[lam, sig] * q_prod\n\n    return J_bound + K_bound\n\ndef find_optimal_tau(P, Q, epsilon):\n    \"\"\"\n    Finds the largest screening threshold tau such that the energy error\n    bound does not exceed epsilon.\n\n    Args:\n        P (np.ndarray): The density matrix.\n        Q (np.ndarray): The pair bound matrix.\n        epsilon (float): The energy tolerance.\n\n    Returns:\n        float: The optimal screening threshold tau.\n    \"\"\"\n    if np.max(Q) == 0.0:\n        # If all Q entries are zero, any tau > 0 will screen all integrals,\n        # but the bound will always be 0. tau_max is also 0.\n        return 0.0\n        \n    tau_max = np.max(Q)**2\n    \n    # Handle the zero density edge case where bound is always 0.\n    if np.all(P == 0):\n        return tau_max\n\n    # Check if the maximum possible threshold already satisfies the condition.\n    bound_at_max = compute_delta_e_bound(tau_max, P, Q)\n    if bound_at_max <= epsilon:\n        return tau_max\n\n    # Perform a bisection search for the optimal tau.\n    low = 0.0\n    high = tau_max\n    \n    # 100 iterations are sufficient for double precision convergence.\n    for _ in range(100):\n        mid = (low + high) / 2.0\n        if mid == low or mid == high: # Convergence reached\n            break\n            \n        bound_at_mid = compute_delta_e_bound(mid, P, Q)\n        \n        if bound_at_mid <= epsilon:\n            # mid is a valid threshold, try for a larger one\n            low = mid\n        else:\n            # mid is too high, reduce the threshold\n            high = mid\n            \n    return low\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each case.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3,\n            \"P\": np.array([\n                [1.90, 0.20, 0.10],\n                [0.20, 1.80, 0.05],\n                [0.10, 0.05, 1.70]\n            ]),\n            \"Q\": np.array([\n                [0.50, 0.20, 0.10],\n                [0.20, 0.60, 0.15],\n                [0.10, 0.15, 0.40]\n            ]),\n            \"epsilon\": 1.0e-4\n        },\n        {\n            \"N\": 2,\n            \"P\": np.array([\n                [0.0, 0.0],\n                [0.0, 0.0]\n            ]),\n            \"Q\": np.array([\n                [0.30, 0.10],\n                [0.10, 0.25]\n            ]),\n            \"epsilon\": 1.0e-6\n        },\n        {\n            \"N\": 3,\n            \"P\": np.array([\n                [1.90, 0.20, 0.10],\n                [0.20, 1.80, 0.05],\n                [0.10, 0.05, 1.70]\n            ]),\n            \"Q\": np.array([\n                [0.50, 0.20, 0.10],\n                [0.20, 0.60, 0.15],\n                [0.10, 0.15, 0.40]\n            ]),\n            \"epsilon\": 1.0e-8\n        },\n        {\n            \"N\": 3,\n            \"P\": np.array([\n                [1.90, 0.20, 0.10],\n                [0.20, 1.80, 0.05],\n                [0.10, 0.05, 1.70]\n            ]),\n            \"Q\": np.array([\n                [0.50, 0.20, 0.10],\n                [0.20, 0.60, 0.15],\n                [0.10, 0.15, 0.40]\n            ]),\n            \"epsilon\": 1.0e-2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        P = case[\"P\"]\n        Q = case[\"Q\"]\n        epsilon = case[\"epsilon\"]\n        \n        # Ensure matrices are symmetric as per problem statement hint\n        P = 0.5 * (P + P.T)\n        \n        tau = find_optimal_tau(P, Q, epsilon)\n        results.append(f\"{tau:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2886212"}]}