{"hands_on_practices": [{"introduction": "任何可靠的计算研究都必须建立在严格收敛性测试的基础之上。这个练习旨在挑战你像计算科学家一样思考，设计一个方案来系统地分离平面波计算中的主要误差来源：基组不完备性（由动能截断 $E_{\\text{cut}}$ 控制）、布里渊区采样的离散化（由 $k$ 点网格控制）以及赝势的可移植性。掌握这种系统性的方法对于获得可复现且值得信赖的结果至关重要，使你能够超越“黑箱式”的计算。[@problem_id:2915024]", "problem": "您正在将使用平面波基组和赝势计算出的砷化镓的平衡晶格常数与一个可靠的全电子参考值进行比较。您的计算结果比参考值大了约$1.5\\%$。您怀疑差异来自三个来源：平面波基组不完备性（由动能截断能 $E_{\\text{cut}}$ 控制）、布里渊区采样误差（由 $k$ 点网格控制）以及赝势的可移植性（在模守恒、超软和投影缀加波类型中选择，并涉及对镓 $3d$ 态的具体处理方式）。您必须设计一个灵敏度分析，将此差异归因于上述来源，并仅使用已广为接受的原则：平面波基组的完备性随平面波动能截断能 $E_{\\text{cut}}$ 单调增加；布里渊区积分由离散的 $k$ 点网格近似，并随着采样密度的增加而收敛；赝势近似了价电子与离子实之间的相互作用，其可移植性必须通过不同类型赝势和价电子划分方案的交叉检验来验证。设计应通过一次只改变一个控制变量来避免混淆变量，并应包括使用多种赝势类型的交叉检验。\n\n下列哪种分析方案最能可靠地分离基组、 $k$ 点和赝势误差的贡献，并包含必要的交叉检验以归因所观察到的 $1.5\\%$ 的差异？\n\nA. 同时按比例缩放 $E_{\\text{cut}}$ 和 $k$ 点网格的线性密度（例如，每一步都将二者加倍），并在每个组合设置下完全弛豫结构，直到力小于 $10^{-3}\\ \\text{eV}/\\text{Å}$。在整个过程中使用单一的投影缀加波赝势集。如果在两三次这样的缩放后差异仍然存在，则将其归因于交换关联泛函，因为基组和 $k$ 点是同步增加的。\n\nB. 在固定的实验体积和原胞形状下，进行平面波截断能收敛测试，通过增加 $E_{\\text{cut}}$ 直到总能量变化低于 $1$ meV/原子且所有应力张量分量在连续的 $E_{\\text{cut}}$ 值之间变化小于 $0.1$ GPa，此过程中使用足够密集的 $k$ 点网格和适用于半导体的固定展宽。将总能量与 $E_{\\text{cut}}$ 的关系拟合到一个光滑的渐近形式，以估计 $E_{\\text{cut}} \\to \\infty$ 的极限。接下来，将 $E_{\\text{cut}}$ 固定在收敛值，使用一致的积分方案（例如，四面体方法或固定宽度展宽）对 $k$ 点网格密度（例如，以Γ为中心的Monkhorst–Pack网格）进行收敛测试，并在需要时外推到无限网格极限。只有在两个控制参数都收敛后，才使用多种赝势重复计算：模守恒和超软赝势（其中镓的 $3d$ 电子分别作为芯电子和价电子处理），以及投影缀加波数据集。对于每种赝势，在相同的数值容差下重新确定 $E_{\\text{cut}}$ 和 $k$ 点的收敛性，然后重新弛豫结构并比较得到的晶格常数；如果可行，可以选择性地与全电子参考值进行单点交叉检验。将在基组和 $k$ 点收敛后，不同赝势之间的任何残余差异归因于赝势的可移植性。\n\nC. 对所有赝势使用统一的 $E_{\\text{cut}}$（选择赝势生成器推荐的最小值），并使用仅含 $\\Gamma$ 点的 $k$ 点网格。如果差异仍然存在，将电子展宽宽度增加2倍以稳定自洽场循环。将任何剩余的差异归因于赝势误差，因为基组和 $k$ 点设置都保持不变。\n\nD. 首先使用一个较低的 $E_{\\text{cut}}$（以保持计算成本低廉）来收敛 $k$ 点网格，然后假设在收敛的 $k$ 点网格下，能量收敛所需的 $E_{\\text{cut}}$ 是相似的。仅比较将镓 $3d$ 置于芯区的模守恒赝势。如果它们在 $5$ meV/原子内一致，则断定赝势不是误差来源，并将 $1.5\\%$ 的差异归因于基组误差。\n\nE. 在三个相隔 $10$ Ry 的 $E_{\\text{cut}}$ 值下进行完整的体积优化，每次都拟合状态方程；选择能得到与下一个更大 $E_{\\text{cut}}$ 计算结果相差 $0.2\\%$ 以内的晶格常数的最小 $E_{\\text{cut}}$。然后测试 $k$ 点网格，直到总能量变化小于 $10$ meV/原子。如果 $1.5\\%$ 的差异仍然存在，切换到另一个模守恒赝势库；如果晶格常数变化小于 $0.1\\%$，则宣布该赝势可接受，并将剩余误差归因于 $k$ 点。", "solution": "问题陈述是计算材料科学领域一个有效且定义明确的问题。它描述了在使用平面波基组和赝势进行密度泛函理论（DFT）计算时遇到的一个标准情景。已识别的误差来源——平面波基组不完备性（$E_{\\text{cut}}$）、布里渊区采样（$k$ 点）和赝势选择——是为获得准确结果而必须收敛的主要数值参数。目标是设计一个方案，能正确地分离出每个误差源对计算出的砷化镓（$GaAs$）晶格常数中 $1.5\\%$ 差异的贡献。\n\n一项科学上严谨的灵敏度分析必须遵守一次只改变一个参数的基本原则。同时改变多个参数会引入混淆变量，使得将观察到的变化归因于特定来源变得不可能。针对此问题的正确方案必须在评估物理近似（赝势）之前，按顺序收敛数值参数。\n\n正确的步骤如下：\n1.  选择一种赝势。\n2.  选择一个非常密集的 $k$ 点网格，以在基组收敛过程中最小化其误差贡献。在固定的几何结构（例如，实验晶格常数）下，为一系列递增的平面波动能截断能 $E_{\\text{cut}}$ 计算总能量或应力张量。当所选的可观测量（例如，每个原子的总能量）在最后两个截断能值之间的变化小于一个严格的容差时，认为截断能已收敛。\n3.  使用已收敛的 $E_{\\text{cut}}$ 值，对 $k$ 点网格进行收敛测试。为一系列密度递增的 $k$ 点网格（例如，$4 \\times 4 \\times 4$，$6 \\times 6 \\times 6$ 等）计算总能量。当总能量的变化小于一个严格的容差时，认为网格已收敛。\n4.  在 $E_{\\text{cut}}$ 和 $k$ 点网格都收敛后，进行完整的结构弛豫（几何优化）以找到平衡晶格常数。此计算的结果代表了所选赝势的预测值，该值在基组和 $k$ 点方面是收敛的。\n5.  为了评估赝势误差，用不同的赝势重复整个过程（步骤1-4）。这必须包括不同的类型（模守恒、超软、投影缀加波），以及对镓来说至关重要的不同价电子组态（即将Ga $3d$ 态作为芯电子或价电子处理）。最终收敛的晶格常数的分布范围是衡量赝势可移植性误差的指标。与可靠的全电子计算的偏差量化了每种赝势的绝对误差。\n\n基于这种正确的方法论，我们评估每个提出的选项。\n\n**选项A：** 该方案建议同时缩放 $E_{\\text{cut}}$ 和 $k$ 点网格密度。这在根本上是有缺陷的，因为它引入了混淆变量。观察到的晶格常数变化不能唯一地归因于基组的改进或布里渊区采样的改善，因为两者都在变化。将持续存在的误差归因于交换关联泛函的结论是不合逻辑的推论，因为主要数值参数的贡献没有被恰当地分离出来。\n**判定：错误。**\n\n**选项B：** 该方案描述了一个系统而严谨的程序，与公认的最佳实践完全一致。它正确地将数值参数的收敛与最终计算分离开来。首先，它在一个固定的、密集的 $k$ 点网格下收敛 $E_{\\text{cut}}$。其次，它在已确定的 $E_{\\text{cut}}$ 下收敛 $k$ 点网格。这个顺序过程正确地分离了变量。关键的是，它规定整个收敛性研究必须对多种赝势重复进行，包括不同类型和价电子处理方式（Ga $3d$ 态），并且最终的收敛结果应该进行比较。这是将最终误差可靠地归因于赝势选择的唯一方法。该方案条理清晰、方法可靠，并且旨在得出站得住脚的结论。\n**判定：正确。**\n\n**选项C：** 该方案严重不足。使用“推荐的最小值”$E_{\\text{cut}}$ 对于像晶格常数这样的结构性质的高精度计算几乎是永远不够的。对于像 $GaAs$ 这样的半导体使用仅含 $\\Gamma$ 点的 $k$ 点网格将导致布里渊区积分中非常大的、不受控制的误差。增加电子展宽对于半导体是一种不合适的工具，并且不能解决基组或 $k$ 点不足的问题。在这些不受控制的条件下将误差归因于赝势是毫无根据的。\n**判定：错误。**\n\n**选项D：** 该方案颠倒了正确的收敛程序。不应该使用一个低的、未收敛的 $E_{\\text{cut}}$ 来收敛 $k$ 点网格。所需的 $k$ 点采样水平可能依赖于基组，使用不充分的基组进行此测试可能会产生误导性结果。标准的、稳健的程序是使用一个“安全”（过度收敛）的 $k$ 点网格来确定所需的 $E_{\\text{cut}}$，然后使用该 $E_{\\text{cut}}$ 来确定最小的足够 $k$ 点网格。此外，仅测试一种价电子组态（Ga $3d$ 在芯区）的模守恒赝势是对赝势误差的不完整评估。最大的误差通常来自价电子划分的选择或不同赝势类型之间的差异（例如，模守恒与投影缀加波）。\n**判定：错误。**\n\n**选项E：** 该方案使用了一种宽松且不可靠的收敛方法。仅在三个 $E_{\\text{cut}}$ 值下检查晶格常数的收敛性过于稀疏。对最终性质（晶格常数收敛到 $0.2\\%$）设置收敛容差，不如将总能量或力收敛到一个严格的容差（例如，亚毫电子伏特级别）那样直接和可靠。评估赝势的逻辑也是有缺陷的。发现两种不同的赝势给出相似的结果（变化小于 $0.1\\%$）并不能证明它们是正确的；它们可能都受到相同的系统误差的影响。宣布赝势可接受并将剩余的 $1.5\\%$ 大误差归咎于 $k$ 点是一种未经证实的猜测。\n**判定：错误。**", "answer": "$$\\boxed{B}$$", "id": "2915024"}, {"introduction": "在建立了确保计算准确性的总体策略之后，我们现在将注意力集中在一个关键的数值参数上：布里渊区的采样。对于金属体系而言，这一点尤为重要。本编码练习将指导你从第一性原理出发，构建一个简单的自由电子气模型，以探索 $k$ 点网格密度和电子展宽（smearing）之间的相互作用。通过这个实践，你将获得关于展宽技术如何加速收敛的直接、定量的理解，并学会如何在计算精度与成本之间找到最佳平衡。[@problem_id:2915098]", "problem": "您将编写一个完整、可运行的程序，在平面波形式论和周期性边界条件下，使用“空”赝势（零势），模拟一个三维自由电子金属，使其仅包含动能贡献。目标是研究对于不同的电子展宽宽度，每个电子的总能量如何相对于 $k$ 点采样的密度收敛，然后找出展宽和 $k$ 点采样之间的最佳平衡，从而以最小的计算成本达到指定的目标精度。\n\n从第一性原理出发，使用以下物理上和数值上明确定义的基础：\n- 在原子单位制（Hartree 原子单位制：$\\hbar = 1$, $m_e = 1$, $e = 1$）中，自由电子（空赝势）的 Kohn–Sham (KS) 单粒子哈密顿量给出的单粒子能量为 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2 / 2$。\n- 周期性原胞是一个边长为 $a$、体积为 $V = a^3$ 的立方体，具有简单立方倒易点阵，其第一布里渊区 (BZ) 为 $\\mathbf{k} \\in [-\\pi/a, \\pi/a)^3$。\n- 布里渊区积分通过一个均匀的、以 $\\Gamma$ 点为中心的 Monkhorst-Pack (MP) 网格进行近似，每个倒易轴上有 $g$ 个点，总共有 $N_k = g^3$ 个点，且权重相等，为 $w_{\\mathbf{k}} = 1/N_k$。使用一个半平移的均匀网格，以避免将点精确地置于布里渊区边界上：对于每个笛卡尔分量，使用点 $k_i = -\\pi/a + (i + 1/2)\\Delta k$，其中 $\\Delta k = 2\\pi/(ag)$ 且 $i = 0, 1, \\dots, g-1$。\n- 自旋简并度为 $g_s = 2$，因此占据数为 $f(\\varepsilon, \\mu, \\sigma) = 1 / \\left( 1 + \\exp\\left( (\\varepsilon - \\mu)/\\sigma \\right) \\right)$，这是在电子展宽宽度为 $\\sigma$（以 Hartree 为单位，其作用类似于 $k_B T$）时的费米–狄拉克分布。化学势 $\\mu$ 由总电子数约束条件 $g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f(\\varepsilon_{\\mathbf{k}}, \\mu, \\sigma) = N_e$ 确定，该约束强制每个原胞的总电子数为 $N_e$。\n- 在此模型中，每个电子的内能等于每个电子的动能，由下式给出：$E_{\\mathrm{num}} = \\dfrac{g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f(\\varepsilon_{\\mathbf{k}}, \\mu, \\sigma)\\, \\varepsilon_{\\mathbf{k}}}{N_e}$。\n- 对于下面指定的测试参数，请确保费米球位于第一布里渊区内，从而只有最低的自由电子分支 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2 / 2$ 有贡献。这一点由所选的 $N_e$ 和 $a$ 值保证。\n- 对于三维均匀自由电子气，每个电子的精确零温参考能量为 $E_{\\mathrm{exact}} = \\dfrac{3}{5} E_F$，其中 $E_F = k_F^2/2$ 且 $k_F = (3 \\pi^2 n)^{1/3}$，电子数密度为 $n = N_e / V$。\n\n您的程序必须：\n1) 将 $k$ 点求和实现为 MP 网格上的黎曼和，并对于给定的 $g$ 和 $\\sigma$，通过使用鲁棒的求根程序求解电子数约束来确定 $\\mu$。\n2) 对于每个测试用例，计算每个电子的内能 $E_{\\mathrm{num}}$ 和绝对误差 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert$（以 Hartree 为单位）。\n3) 在一个预设的离散 $(g, \\sigma)$ 对集合中进行搜索，以找到能以最少的 $k$ 点数 $N_k = g^3$ 使绝对误差低于指定容差的组合。如果没有组合满足该容差，则选择并报告所达到的绝对误差最小的组合。\n\n所有计算均使用以下固定的物理参数（以 Hartree 原子单位制）：\n- 立方原胞边长 $a = 20$ bohr（因此 $V = a^3$）。\n- 每个原胞的总电子数 $N_e = 1$。\n- 自旋简并度 $g_s = 2$。\n\n使用上述公式，由 $n = N_e/V$ 和 $k_F = (3 \\pi^2 n)^{1/3}$ 计算精确参考能量。\n\n数值细节和要求：\n- 对每个测试的 $g$ 使用上述的半平移均匀 MP 网格。\n- 使用费米–狄拉克展宽，宽度为 $\\sigma$（以 Hartree 为单位）。不要使用零展宽宽度。\n- 对于每个 $(g,\\sigma)$，通过如二分法之类的区间法求解电子数方程 $g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f(\\varepsilon_{\\mathbf{k}}, \\mu, \\sigma) = N_e$ 来确定化学势 $\\mu$，以保证对所有 $\\sigma > 0$ 都收敛。\n- 为每个测试用例计算 $E_{\\mathrm{num}}$ 和绝对误差 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert$。\n- 所有能量必须以 Hartree 报告。不涉及角度。不使用百分比。\n\n测试套件：\n- 为了说明收敛性，请评估以下 8 个测试用例 $(g, \\sigma)$（其中 $\\sigma$ 以 Hartree 为单位）的绝对误差：$(4, 0.002)$、$(6, 0.002)$、$(8, 0.002)$、$(12, 0.002)$、$(4, 0.01)$、$(6, 0.01)$、$(8, 0.01)$、$(12, 0.01)$。\n- 对于最佳平衡搜索，使用候选集 $g \\in \\{4, 6, 8, 10, 12, 16\\}$ 和 $\\sigma \\in \\{0.002, 0.01, 0.05\\}$，容差为 $\\tau = 10^{-3}$ Hartree。当按 $N_k = g^3$ 递增的顺序扫描时，最佳配对是第一个满足条件 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert \\le \\tau$ 的组合；如果没有组合满足容差，则选择误差最小的组合。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔且无空格的结果列表。\n- 前 8 个条目必须是上述 8 个测试用例的绝对误差（以 Hartree 为单位），以浮点数形式报告。\n- 最后 4 个条目必须按此顺序报告：最佳 $g$（整数）、最佳 $\\sigma$（浮点数，以 Hartree 为单位）、对应的 $N_k = g^3$（整数）以及实现的绝对误差（浮点数，以 Hartree 为单位）。因此，输出列表的总长度为 12 个条目。\n- 所需输出格式形状示例（非实际数值）：$[e_1,e_2,\\dots,e_8,g_{\\mathrm{opt}},\\sigma_{\\mathrm{opt}},N_{k,\\mathrm{opt}},e_{\\mathrm{opt}}]$。\n\n科学合理性与推导期望：\n- 证明在给定的 $a$ 和 $N_e$ 下，费米球严格位于第一布里渊区内，因此 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$ 已足够，无需考虑更高阶的倒易点阵平移。解释为什么在这种空赝势极限下，每个电子的内能等于每个电子的动能。\n- 使用费米–狄拉克分布和 Mermin 的有限温形式论（在定义的层面上），论证为什么有限的 $\\sigma$ 会在 $E_{\\mathrm{num}}$ 中引入一个可控的偏差，但同时会减少 $k$ 点求和中的积分误差，从而导致一个必须由最佳平衡搜索来解决的权衡问题。\n\n本问题陈述中的所有数学符号、变量、函数、算符和数字都必须使用行内数学定界符以 LaTeX 格式书写，并且所有能量都必须如上所述以 Hartree 表示。您的实现必须遵守稍后定义的执行环境和库约束，并且不得读取外部输入。", "solution": "我们在原子单位制和平面波框架下模拟一个三维自由电子金属，采用空赝势，使 Kohn–Sham (KS) 哈密顿量简化为动能算符。布洛赫波的单粒子色散关系为 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$。立方原胞的边长为 $a$，体积为 $V = a^3$。简单立方晶格的第一布里渊区 (BZ) 是一个立方体 $\\mathbf{k} \\in [-\\pi/a,\\pi/a)^3$。\n\n基础推导：\n1) 平面波基组与空赝势。在 Hartree 原子单位制中，自由电子的 KS 哈密顿量为 $\\hat{H} = -\\nabla^2/2$。其本征函数是平面波 $\\exp(i \\mathbf{k} \\cdot \\mathbf{r})$，对应的本征值为 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$。在周期性超胞中，$\\mathbf{k}$ 被限制在第一布里渊区内，对布里渊区的积分可以得到每个原胞的物理观测量。\n\n2) 有限展宽下的占据数。在电子展宽宽度为 $\\sigma$（费米–狄拉克分布，作用类似于 $k_B T$）时，占据数为 $f(\\varepsilon,\\mu,\\sigma) = \\big(1 + \\exp((\\varepsilon - \\mu)/\\sigma)\\big)^{-1}$，其中 $\\mu$ 由电子数约束确定。对于自旋简并度为 $g_s = 2$ 的电子，每个原胞的电子数为\n$$\nN_e = g_s \\int_{\\mathrm{BZ}} \\frac{d^3 k}{\\Omega_{\\mathrm{BZ}}}\\, f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big),\n$$\n其中 $\\Omega_{\\mathrm{BZ}}$ 是布里渊区的体积。在数值上，我们用一个均匀的、以 $\\Gamma$ 点为中心的 Monkhorst-Pack (MP) 网格来代替积分，每个轴上有 $g$ 个点，总点数为 $N_k = g^3$，权重相等，为 $w_{\\mathbf{k}} = 1/N_k$。我们采用半平移法，使得格点不落在布里渊区边界上：\n$$\nk_i = -\\frac{\\pi}{a} + \\left(i + \\frac{1}{2}\\right)\\Delta k,\\quad \\Delta k = \\frac{2\\pi}{a g},\\quad i = 0,1,\\dots,g-1.\n$$\n离散化的电子数约束变为\n$$\nN_e = g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big) = g_s \\frac{1}{N_k} \\sum_{\\mathbf{k}} f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big).\n$$\n这个关于 $\\mu$ 的单调方程可以通过二分法鲁棒地求解，因为当 $\\mu \\to -\\infty$ 时，$f\\to 0$ 且总和趋于零，而当 $\\mu \\to +\\infty$ 时，$f\\to 1$ 且总和趋近于 $g_s$；因此，对于任何 $N_e \\in (0,g_s)$ 都存在解。\n\n3) 每个电子的内能。在空赝势极限下，总内能等于动能。其离散估计量为\n$$\nE_{\\mathrm{num}} = \\frac{g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big)\\, \\varepsilon(\\mathbf{k})}{N_e}.\n$$\n我们以 Hartree 为单位报告此值。\n\n4) 精确参考能量与费米球条件。数密度为 $n = N_e/V$。零温下的费米波矢为 $k_F = (3\\pi^2 n)^{1/3}$，费米能为 $E_F = k_F^2/2$，而每个电子的精确零温内能为\n$$\nE_{\\mathrm{exact}} = \\frac{3}{5} E_F = \\frac{3}{5}\\frac{k_F^2}{2}.\n$$\n我们还必须确保费米球位于第一布里渊区内，这样只有最低的自由电子抛物面有贡献，而无需考虑能带折叠。BZ 边界的模长为 $\\pi/a$。对于给定的参数 $a = 20$ bohr 和 $N_e = 1$，原胞体积为 $V = a^3 = 20^3 = 8000$，密度为 $n = N_e/V = 1/8000 = 0.000125$，这得到\n$$\nk_F = \\big(3\\pi^2 n\\big)^{1/3} = \\big(3\\pi^2 \\times 0.000125\\big)^{1/3},\n$$\n和\n$$\n\\frac{\\pi}{a} = \\frac{\\pi}{20}.\n$$\n数值上，$k_F \\approx 0.154$ 且 $\\pi/a \\approx 0.157$，所以 $k_F < \\pi/a$，确保了费米球严格位于第一 BZ 内部。因此，使用 BZ 内的 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$ 足以描述此设置下的所有占据态。\n\n5) 展宽与 $k$ 点的权衡。有限的展宽平滑了费米面处的不连续性，并减少了离散 $k$ 点求和中的积分误差（尤其是在 $k$ 点网格较粗时），但它相对于零温值，在 $E_{\\mathrm{num}}$ 中引入了一个偏差。对于费米–狄拉克统计，Sommerfeld 展开表明，对于较小的 $\\sigma$，内能中的主要偏差与 $\\mathcal{O}(\\sigma^2)$ 成正比，而有限 $k$ 点采样引入的积分误差通常随着网格的加密而减小。因此，在 $\\sigma$ 和网格密度之间存在一个最佳平衡，可以在满足精度约束的前提下，最小化计算成本（此处用 $N_k = g^3$ 衡量）。\n\n算法设计：\n- 对每个测试用例 $(g,\\sigma)$，构建均匀的半平移 MP 网格并计算 $\\varepsilon(\\mathbf{k})$。\n- 对方程 $g_s \\frac{1}{N_k}\\sum_{\\mathbf{k}} f(\\varepsilon(\\mathbf{k}),\\mu,\\sigma) - N_e = 0$ 使用二分法求解 $\\mu$。在极值能量周围使用一个宽泛、安全的区间（通过 $\\sigma$ 的倍数进行调整），以确保方程左侧在该区间内变号。映射 $\\mu \\mapsto \\sum f$ 是严格单调递增的，这保证了二分法的收敛性。\n- 计算 $E_{\\mathrm{num}} = \\dfrac{g_s}{N_e} \\frac{1}{N_k}\\sum_{\\mathbf{k}} f(\\varepsilon(\\mathbf{k}),\\mu,\\sigma)\\, \\varepsilon(\\mathbf{k})$ 和绝对误差 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert$（以 Hartree 为单位）。\n- 对于最佳平衡搜索，枚举候选集 $g \\in \\{4,6,8,10,12,16\\}$ 和 $\\sigma \\in \\{0.002,0.01,0.05\\}$，计算每对组合的误差，并按 $N_k = g^3$ 递增的顺序，选择第一个满足容差 $\\tau = 10^{-3}$ Hartree 的组合。如果没有组合满足容差，则选择误差最小的组合。\n\n测试套件与输出：\n- 按顺序计算 8 个测试用例 $(g,\\sigma)$ 的绝对误差：$(4, 0.002)$、$(6, 0.002)$、$(8, 0.002)$、$(12, 0.002)$、$(4, 0.01)$、$(6, 0.01)$、$(8, 0.01)$、$(12, 0.01)$。\n- 在指定的候选集和容差下执行最佳平衡选择。\n- 以 $[e_1,e_2,\\dots,e_8,g_{\\mathrm{opt}},\\sigma_{\\mathrm{opt}},N_{k,\\mathrm{opt}},e_{\\mathrm{opt}}]$ 的精确格式输出单行结果，无空格，其中 $e_i$ 和 $e_{\\mathrm{opt}}$ 是以 Hartree 为单位的绝对误差，$g_{\\mathrm{opt}}$ 和 $N_{k,\\mathrm{opt}}$ 是整数，$\\sigma_{\\mathrm{opt}}$ 是以 Hartree 为单位的浮点数。\n\n该方法清晰地将平面波与赝势框架（空赝势）、Mermin 形式论中的有限温（展宽）占据数，以及通过均匀 $k$ 点采样的布里渊区积分联系起来，从而可以在一个严格、可验证的精度标准下，对收敛性进行定量研究，并给出了一个明确的算法来确定展宽和 $k$ 点密度之间的最佳平衡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used)\n# Self-contained: no input, no external files.\n\ndef build_k_grid_and_energies(a_bohr: float, g: int):\n    \"\"\"\n    Construct half-shifted, uniform Monkhorst–Pack-like k-grid for a simple cubic BZ:\n      k_i = -pi/a + (i + 0.5) * (2pi/(a*g)), for i = 0..g-1\n    Returns flattened energies eps = |k|^2 / 2 in Hartree (atomic units).\n    \"\"\"\n    dk = 2.0 * np.pi / (a_bohr * g)\n    kmin = -np.pi / a_bohr\n    # Half-shifted grid avoids boundary points\n    k1d = kmin + (np.arange(g) + 0.5) * dk\n    # Build 3D grid and compute energies\n    kx, ky, kz = np.meshgrid(k1d, k1d, k1d, indexing='ij')\n    k2 = kx*kx + ky*ky + kz*kz\n    eps = 0.5 * k2  # Hartree (since atomic units)\n    return eps.reshape(-1)\n\ndef fermi_dirac_occ(eps: np.ndarray, mu: float, sigma: float):\n    \"\"\"\n    Stable Fermi-Dirac occupation f = 1 / (1 + exp((eps-mu)/sigma)).\n    sigma > 0 (Hartree). Returns vector of same shape as eps.\n    \"\"\"\n    x = (eps - mu) / sigma\n    # Use stable logistic evaluation\n    # For x >= 0: f = exp(-x) / (1 + exp(-x))\n    # For x < 0:  f = 1 / (1 + exp(x))\n    occ = np.empty_like(x)\n    mask = x >= 0\n    # Avoid overflow by clipping exponentials\n    xm = x[mask]\n    xp = x[~mask]\n    occ[mask] = np.exp(-np.clip(xm, -700, 700))\n    occ[mask] = occ[mask] / (1.0 + occ[mask])\n    exp_xp = np.exp(np.clip(xp, -700, 700))\n    occ[~mask] = 1.0 / (1.0 + exp_xp)\n    return occ\n\ndef solve_mu_for_number(eps: np.ndarray, sigma: float, Ne: float, gs: float):\n    \"\"\"\n    Solve for chemical potential mu such that:\n      gs * mean(f(eps, mu, sigma)) = Ne\n    using bisection on a safe bracket.\n    \"\"\"\n    # Safe bracket around min/max energies extended by multiples of sigma and a buffer\n    e_min = float(np.min(eps))\n    e_max = float(np.max(eps))\n    # Ensure sigma contributes to bracket extent; add additive buffer in case sigma is tiny\n    buffer = max(1.0, 10.0 * sigma)\n    mu_lo = e_min - 10.0 * buffer\n    mu_hi = e_max + 10.0 * buffer\n\n    def electrons(mu):\n        f = fermi_dirac_occ(eps, mu, sigma)\n        return gs * float(np.mean(f))\n\n    # Expand bracket if necessary to ensure monotonic bracket captures root\n    N_lo = electrons(mu_lo)\n    N_hi = electrons(mu_hi)\n    # If for numerical reasons the bracket is not wide enough, expand geometrically\n    expand_count = 0\n    while N_lo = Ne and expand_count  50:\n        mu_lo -= 2.0 * buffer\n        N_lo = electrons(mu_lo)\n        expand_count += 1\n    expand_count = 0\n    while N_hi >= Ne and expand_count  50:\n        mu_hi += 2.0 * buffer\n        N_hi = electrons(mu_hi)\n        expand_count += 1\n\n    # Bisection\n    for _ in range(100):\n        mu_mid = 0.5 * (mu_lo + mu_hi)\n        N_mid = electrons(mu_mid)\n        if N_mid > Ne:\n            mu_hi = mu_mid\n        else:\n            mu_lo = mu_mid\n        if abs(mu_hi - mu_lo)  1e-12:\n            break\n    return 0.5 * (mu_lo + mu_hi)\n\ndef compute_internal_energy_per_electron(a: float, g: int, sigma: float,\n                                         Ne: float, gs: float, E_exact: float,\n                                         cache):\n    \"\"\"\n    Compute E_num (Hartree per electron) and absolute error vs E_exact for given (g, sigma).\n    Uses a cache to avoid recomputation.\n    \"\"\"\n    key = (g, float(sigma))\n    if key in cache:\n        return cache[key]\n    eps = build_k_grid_and_energies(a, g)\n    mu = solve_mu_for_number(eps, sigma, Ne, gs)\n    f = fermi_dirac_occ(eps, mu, sigma)\n    # Internal energy per electron\n    E_num = (gs * float(np.mean(f * eps))) / Ne\n    err = abs(E_num - E_exact)\n    cache[key] = (E_num, err)\n    return cache[key]\n\ndef solve():\n    # Physical parameters (atomic units)\n    a = 20.0  # bohr\n    V = a**3  # bohr^3\n    Ne = 1.0\n    gs = 2.0\n\n    # Exact zero-temperature energy per electron for 3D free electron gas\n    n = Ne / V\n    kF = (3.0 * (np.pi**2) * n)**(1.0/3.0)\n    EF = 0.5 * (kF**2)\n    E_exact = (3.0/5.0) * EF  # Hartree per electron\n\n    # Test suite: 8 cases\n    test_cases = [\n        (4, 0.002),\n        (6, 0.002),\n        (8, 0.002),\n        (12, 0.002),\n        (4, 0.01),\n        (6, 0.01),\n        (8, 0.01),\n        (12, 0.01),\n    ]\n\n    # Compute errors for test cases\n    cache = {}\n    errors = []\n    for g, sigma in test_cases:\n        _, err = compute_internal_energy_per_electron(a, g, sigma, Ne, gs, E_exact, cache)\n        errors.append(round(err, 8))  # round for stable printing\n\n    # Optimal balance search\n    tau = 1e-3  # Hartree\n    g_candidates = [4, 6, 8, 10, 12, 16]\n    sigma_candidates = [0.002, 0.01, 0.05]\n\n    # Enumerate pairs ordered by increasing Nk = g^3\n    pairs = []\n    for g in g_candidates:\n        Nk = g**3\n        for sigma in sigma_candidates:\n            pairs.append((Nk, g, sigma))\n    pairs.sort(key=lambda x: x[0])  # sort by Nk\n\n    g_opt = None\n    sigma_opt = None\n    Nk_opt = None\n    err_opt = None\n\n    # Scan for first pair meeting tolerance\n    best_err = None\n    best_tuple = None\n    for Nk, g, sigma in pairs:\n        _, err = compute_internal_energy_per_electron(a, g, sigma, Ne, gs, E_exact, cache)\n        if (best_err is None) or (err  best_err):\n            best_err = err\n            best_tuple = (g, sigma, Nk, err)\n        if err = tau and g_opt is None:\n            g_opt, sigma_opt, Nk_opt, err_opt = g, sigma, Nk, err\n            break\n\n    # If none met tolerance, pick best-attained error\n    if g_opt is None:\n        g_opt, sigma_opt, Nk_opt, err_opt = best_tuple\n\n    # Prepare flat results list: 8 errors + g_opt + sigma_opt + Nk_opt + err_opt\n    results = []\n    for e in errors:\n        # ensure consistent numeric format\n        results.append(e if isinstance(e, float) else float(e))\n    results.append(int(g_opt))\n    results.append(float(sigma_opt))\n    results.append(int(Nk_opt))\n    results.append(round(float(err_opt), 8))\n\n    # Print as a single line, comma-separated, no spaces, enclosed in square brackets\n    def format_number(x):\n        # Ensure minimal yet readable representation, no spaces\n        if isinstance(x, int):\n            return str(x)\n        # For floats, ensure standard Python str formatting, but avoid scientific notation for small numbers if possible\n        return str(x)\n\n    print(\"[\" + \",\".join(format_number(x) for x in results) + \"]\")\n\nsolve()\n```", "id": "2915098"}, {"introduction": "除了数值参数，计算的准确性还关键性地取决于赝势本身的质量。这个高级编码实践在一个一维模型中模拟了赝势的行为，让你能够亲眼见证一个非物理的“鬼态”（ghost state）如何出现，并学习如何通过合理的投影子构造来消除它。这个练习揭示了赝势理论中一个臭名昭著的陷阱，让你清晰地理解什么构成了一个“好”的赝势，以及如何诊断某些特定的赝势病态。[@problem_id:2915027]", "problem": "您将实现一个一维平面波模拟，该模拟用于建模 Kleinman–Bylander 可分离非局域赝势的基本特征，并演示如何通过选择局域通道或投影子构建来消除鬼态，同时保持其可移植性。您将使用哈特里原子单位，其中电子质量为1，能量单位为哈特里 (Ha)，长度单位为玻尔 (bohr)，普朗克常数除以 $2\\pi$ 等于 $1$。该系统是一个长度为 $L$ 的一维大超胞，具有周期性边界条件，并使用由动能截断所限制的平面波基。\n\n基本基组与模型规范：\n- 考虑一个长度为 $L$ 的一维周期性超胞，其平面波基为 $\\{\\lvert G \\rangle\\}$，波矢为 $G = 2\\pi n/L$，其中 $n$ 为整数。这些平面波是正交归一的，即 $\\langle x \\lvert G \\rangle = L^{-1/2}\\exp(i G x)$。\n- 动能算符为 $T = -\\frac{1}{2} \\frac{d^2}{dx^2}$，在平面波基中，其对角元为 $T_{G,G'} = \\frac{G^2}{2} \\delta_{G,G'}$。\n- 局域势是一个高斯势阱 $V_{\\mathrm{loc}}(x) = V_0 \\exp\\!\\left[-(x/a)^2\\right]$，其中 $V_0  0$ 且 $a0$。其矩阵元为 $V^{\\mathrm{loc}}_{G,G'} = \\frac{1}{L}\\int_{-L/2}^{L/2} V_{\\mathrm{loc}}(x) e^{-i(G-G')x}\\,dx$。对于 $L \\gg a$ 的情况，该积分可以很好地被全域傅里叶变换近似，即 $V^{\\mathrm{loc}}_{G,G'} \\approx \\frac{1}{L} \\int_{-\\infty}^{\\infty} V_{\\mathrm{loc}}(x) e^{-i(G-G')x}\\,dx$。\n- 非局域赝势以 Kleinman–Bylander 可分离形式给出：$V_{\\mathrm{nl}} = \\sum_{i=1}^{N_p} D_i \\lvert \\beta_i \\rangle \\langle \\beta_i \\rvert$，其中 $D_i$ 是实数耦合系数，$\\beta_i(x)$ 是局域化投影函数。在平面波基中，非局域矩阵为 $\\left(V_{\\mathrm{nl}}\\right)_{G,G'} = \\sum_i D_i\\, \\langle G \\vert \\beta_i \\rangle \\langle \\beta_i \\vert G' \\rangle$，其中 $\\langle G \\vert \\beta_i \\rangle = L^{-1/2}\\int \\beta_i(x) e^{-i G x}\\,dx$。\n- 使用两种类型的投影子，通过一维中的宇称来模拟不同的角动量通道：“偶宇称”（s-like）和“奇宇称”（p-like）。使用以下模型投影子：\n  - 偶宇称投影子：$\\beta^{(\\mathrm{even})}_b(x) = \\exp\\!\\left[-(x/b)^2\\right]$，宽度参数为 $b0$。\n  - 奇宇称投影子：$\\beta^{(\\mathrm{odd})}_b(x) = x \\exp\\!\\left[-(x/b)^2\\right]$，宽度参数为 $b0$。\n  它们的平面波分量需通过定义积分 $\\langle G \\vert \\beta \\rangle = L^{-1/2} \\int_{-\\infty}^{\\infty} \\beta(x) e^{-i G x}\\,dx$ 获得。对于高斯函数，其傅里叶变换是标准的，并能得到闭合形式的解，您应当精确实现这些解。\n\n待构建和对角化的哈密顿量：\n- 截断的平面波基由能量截断 $E_{\\mathrm{cut}}$ 定义：包含所有满足 $\\frac{G^2}{2} \\le E_{\\mathrm{cut}}$ 的 $G$。在此基组中，构建三个厄米矩阵：\n  1. $H_{\\mathrm{loc}} = T + V_{\\mathrm{loc}}$（不含非局域投影子）。\n  2. $H_{A} = T + V_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(A)}$，用于“构建 A”，它使用一个吸引性的偶宇称投影子集，已知该投影子集容易产生鬼态。\n  3. $H_{B} = T + V_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(B)}$，用于“构建 B”，它模拟了局域通道和投影子构建的改变：保持偶宇称通道为局域，并将非局域权重置于奇宇称（排斥性）投影子中，从而最大限度地减少与偶宇称基态的耦合，以此消除鬼态，同时保持偶宇称（价）通道的可移植性。\n\n鬼态检测与可移植性度量：\n- 将有限超胞/基组中的束缚态数量定义为哈密顿量中严格小于 $0$ 的本征值的数量。用 $N_{-}(H)$ 表示此数量。\n- 当 $N_{-}(H_{A})  N_{-}(H_{\\mathrm{loc}})$ 时，即当可分离非局域构建产生了至少一个局域参考中不存在的额外负能态时，我们便在操作上检测到了“鬼态”。\n- 如果 $N_{-}(H_{B}) = N_{-}(H_{\\mathrm{loc}})$，则实现了消除。\n- 为量化“保持可移植性”，比较 $H_{B}$ 和 $H_{\\mathrm{loc}}$ 的最低束缚态能量（最负的本征值）。设 $E_0(H)$ 是 $H$ 的最小本征值。如果 $\\lvert E_0(H_{B}) - E_0(H_{\\mathrm{loc}}) \\rvert \\le \\varepsilon$（容差 $\\varepsilon = 10^{-4}$ Hartree），则认为可移植性得以保持。如果 $N_{-}(H_{\\mathrm{loc}}) = 0$，则跳过此可移植性检查，并为下方逻辑测试的目的默认其为满足。\n\n每个测试用例的最终计算结果：\n- 对于每个测试用例，返回一个由以下公式定义的布尔值：\n  $$\\mathrm{Result} = \\big(N_{-}(H_{A})  N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\big(N_{-}(H_{B}) = N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\Big(N_{-}(H_{\\mathrm{loc}})=0 \\ \\vee\\ \\lvert E_0(H_{B}) - E_0(H_{\\mathrm{loc}}) \\rvert \\le \\varepsilon\\Big).$$\n\n测试套件（所有能量单位为哈特里，长度单位为玻尔）：\n- 案例 1（理想情况；A中存在明显鬼态；B中已消除；可移植性得以保持）：\n  - $L = 40.0$, $E_{\\mathrm{cut}} = 0.8$, $V_0 = -0.20$, $a = 1.0$,\n  - 构建 A（偶宇称投影子）：$N_p=2$，宽度 $b = [0.6, 0.3]$，耦合 $D = [-100.0, -50.0]$，\n  - 构建 B（奇宇称投影子）：$N_p=2$，宽度 $b = [0.6, 0.3]$，耦合 $D = [20.0, 10.0]$。\n- 案例 2（基组受限的边缘情况；A中仍显示鬼态，B中已消除）：\n  - $L = 40.0$, $E_{\\mathrm{cut}} = 0.3$, $V_0 = -0.20$, $a = 1.0$,\n  - 构建 A（偶宇称）：$b = [0.6, 0.3]$, $D = [-80.0, -40.0]$,\n  - 构建 B（奇宇称）：$b = [0.6, 0.3]$, $D = [15.0, 7.0]$。\n- 案例 3（无问题性的非局域吸引；无鬼态可消除）：\n  - $L = 40.0$, $E_{\\mathrm{cut}} = 0.8$, $V_0 = -0.05$, $a = 1.0$,\n  - 构建 A（偶宇称）：$b = [0.6, 0.3]$, $D = [0.0, 0.0]$,\n  - 构建 B（奇宇称）：$b = [0.6, 0.3]$, $D = [2.0, 1.0]$。\n\n实现要求：\n- 直接根据上述定义计算矩阵元。对于高斯局域势和高斯（乘以 $x$）投影子，使用精确的全域傅里叶积分：\n  - $\\int_{-\\infty}^{\\infty} e^{-(x/a)^2} e^{-i q x}\\, dx = \\sqrt{\\pi}\\, a \\, e^{-(q a/2)^2}$，\n  - $\\int_{-\\infty}^{\\infty} e^{-(x/b)^2} e^{-i G x}\\, dx = \\sqrt{\\pi}\\, b \\, e^{-(G b/2)^2}$，\n  - $\\int_{-\\infty}^{\\infty} x\\, e^{-(x/b)^2} e^{-i G x}\\, dx = i \\sqrt{\\pi}\\, b \\left(- \\frac{G b^2}{2}\\right) e^{-(G b/2)^2}$。\n  一致地为每个 $\\langle G \\vert \\beta \\rangle$ 应用平面波归一化因子 $L^{-1/2}$，为 $V^{\\mathrm{loc}}_{G,G'}$ 应用 $L^{-1}$。\n- 对每个测试用例，对角化三个厄米矩阵 $H_{\\mathrm{loc}}$、$H_A$ 和 $H_B$。\n- 计算每个哈密顿量的负本征值数量，并评估所定义的布尔结果。\n- 所有计算必须在哈特里和玻尔单位下进行。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，例如 $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3]$，其中每个 $\\mathrm{result}_i$ 为 True 或 False（作为布尔字面量）。\n\n您的程序必须是完整的，并且能够按规定运行，无需任何外部输入。", "solution": "该问题要求实现一个一维平面波模拟，以研究赝势中的鬼态现象及其消除方法。这是一个基于计算量子力学原理的有效且良态的问题。其解决方案是通过在平面波基中构建周期性系统的哈密顿量，对其进行对角化以找到其能谱，并根据指定标准分析结果。\n\n该过程分为四个主要阶段：\n$1$. 构建平面波基组。\n$2$. 构建动能、局域势和非局域势算符的矩阵元。\n$3$. 组装并对角化三个指定的哈密顿量：$H_{\\mathrm{loc}}$、$H_{A}$ 和 $H_{B}$。\n$4$. 基于束缚态数量和能量可移植性评估结果。\n\n**$1$. 基组构建**\n\n量子系统被限制在一个长度为 $L$ 的具有周期性边界条件的一维超胞内。单粒子波函数在一组平面波基中展开，这些平面波是动量算符的本征函数。一个平面波 $\\lvert G \\rangle$ 的实空间表示为 $\\langle x \\lvert G \\rangle = L^{-1/2} \\exp(i G x)$，其中波矢 $G$ 必须与超胞的周期性兼容，即 $G = 2\\pi n / L$，其中 $n$ 为整数。\n\n无限的平面波集通过一个动能截断 $E_{\\mathrm{cut}}$ 进行截断。只有动能 $\\frac{G^2}{2}$ 小于或等于此截断值的平面波才被保留在基组中。此条件表示为：\n$$\n\\frac{1}{2} \\left( \\frac{2\\pi n}{L} \\right)^2 \\le E_{\\mathrm{cut}} \\implies |n| \\le \\frac{L \\sqrt{2 E_{\\mathrm{cut}}}}{2\\pi}\n$$\n因此，定义基组的整数集为 $n \\in \\{-n_{\\mathrm{max}}, \\dots, n_{\\mathrm{max}}\\}$，其中 $n_{\\mathrm{max}} = \\lfloor L\\sqrt{2E_{\\mathrm{cut}}} / (2\\pi) \\rfloor$。基函数的总数为 $N_G = 2n_{\\mathrm{max}} + 1$。\n\n**$2$. 哈密顿量矩阵元**\n\n总哈密顿量为 $H = T + V_{\\mathrm{loc}} + V_{\\mathrm{nl}}$。其矩阵表示在截断的平面波基 $\\{\\lvert G_k \\rangle\\}_{k=1}^{N_G}$ 中构建。\n\n**动能算符 ($T$):**\n动能算符 $T = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 在平面波基下是对角的，因为平面波是其本征函数：$T \\lvert G \\rangle = \\frac{G^2}{2} \\lvert G \\rangle$。因此，矩阵元为：\n$$\nT_{G,G'} = \\langle G \\vert T \\vert G' \\rangle = \\frac{{G'}^2}{2} \\langle G \\vert G' \\rangle = \\frac{G^2}{2} \\delta_{G,G'}\n$$\n\n**局域势算符 ($V_{\\mathrm{loc}}$):**\n局域势是一个高斯函数，$V_{\\mathrm{loc}}(x) = V_0 \\exp[-(x/a)^2]$。其矩阵元由势的傅里叶分量给出。对于大超胞（$L \\gg a$），这可以很好地通过在无穷域上的连续傅里叶变换来近似：\n$$\nV^{\\mathrm{loc}}_{G,G'} = \\frac{1}{L} \\int_{-L/2}^{L/2} V_{\\mathrm{loc}}(x) e^{-i(G-G')x} dx \\approx \\frac{1}{L} \\int_{-\\infty}^{\\infty} V_{\\mathrm{loc}}(x) e^{-iqx} dx\n$$\n其中 $q = G-G'$。使用为高斯函数提供的积分公式 $\\int_{-\\infty}^{\\infty} e^{-(x/a)^2} e^{-iqx} dx = \\sqrt{\\pi}\\, a \\, e^{-(qa/2)^2}$，我们得到：\n$$\nV^{\\mathrm{loc}}_{G,G'} = \\frac{V_0 \\sqrt{\\pi} a}{L} \\exp\\left[-\\left(\\frac{(G-G')a}{2}\\right)^2\\right]\n$$\n该矩阵是一个实对称的托普利兹 (Toeplitz) 矩阵。\n\n**非局域赝势算符 ($V_{\\mathrm{nl}}$):**\n非局域部分以可分离的 Kleinman-Bylander 形式给出，$V_{\\mathrm{nl}} = \\sum_{i=1}^{N_p} D_i \\lvert \\beta_i \\rangle \\langle \\beta_i \\rvert$。其矩阵元为：\n$$\n\\left(V_{\\mathrm{nl}}\\right)_{G,G'} = \\langle G \\vert V_{\\mathrm{nl}} \\vert G' \\rangle = \\sum_{i=1}^{N_p} D_i \\langle G \\vert \\beta_i \\rangle \\langle \\beta_i \\vert G' \\rangle\n$$\n项 $\\langle G \\vert \\beta_i \\rangle$ 是投影函数 $\\beta_i(x)$ 的平面波分量，计算公式为 $\\langle G \\vert \\beta_i \\rangle = L^{-1/2} \\int_{-\\infty}^{\\infty} \\beta_i(x) e^{-iGx} dx$。\n\n对于**偶宇称投影子** $\\beta^{(\\mathrm{even})}_b(x) = \\exp[-(x/b)^2]$，其分量是实数：\n$$\n\\langle G \\vert \\beta^{(\\mathrm{even})}_b \\rangle = \\frac{1}{\\sqrt{L}} \\int_{-\\infty}^{\\infty} e^{-(x/b)^2} e^{-iGx} dx = \\frac{\\sqrt{\\pi} b}{\\sqrt{L}} \\exp\\left[-\\left(\\frac{Gb}{2}\\right)^2\\right]\n$$\n对于**奇宇称投影子** $\\beta^{(\\mathrm{odd})}_b(x) = x \\exp[-(x/b)^2]$，其分量是纯虚数：\n$$\n\\langle G \\vert \\beta^{(\\mathrm{odd})}_b \\rangle = \\frac{1}{\\sqrt{L}} \\int_{-\\infty}^{\\infty} x e^{-(x/b)^2} e^{-iGx} dx = \\frac{i}{\\sqrt{L}} \\left( \\sqrt{\\pi} b \\left( -\\frac{Gb^2}{2} \\right) \\exp\\left[-\\left(\\frac{Gb}{2}\\right)^2\\right] \\right)\n$$\n我们将 $\\langle G \\vert \\beta_i \\rangle$ 表示为 $\\tilde{\\beta}_i(G)$。对于奇宇称投影子，非局域矩阵为 $(V_{\\mathrm{nl}})_{G,G'} = D_i \\tilde{\\beta}_i(G) \\tilde{\\beta}_i(G')^*$。由于 $\\tilde{\\beta}_i$ 是纯虚数，$\\tilde{\\beta}_i^* = - \\tilde{\\beta}_i$，因此乘积 $\\tilde{\\beta}_i(G) \\tilde{\\beta}_i(G')^*$ 变为实数。在所有情况下，最终的哈密顿矩阵都是实对称的。\n\n**$3$. 哈密顿量组装与对角化**\n\n构建并对角化三个不同的哈密顿量：\n$1$. $H_{\\mathrm{loc}} = T + V_{\\mathrm{loc}}$: 只包含局域势的参考哈密顿量。\n$2$. $H_{A} = H_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(A)}$: 构建 A，使用吸引性（$D_i  0$）偶宇称投影子。这种配置已知容易产生非物理的、深度束缚的“鬼”态。\n$3$. $H_{B} = H_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(B)}$: 构建 B，使用排斥性（$D_i  0$）奇宇称投影子。这种设计避免了与偶宇称基态的强耦合，从而防止了鬼态的产生，同时旨在保持价态的物理性质（可移植性）。\n\n这些 $N_G \\times N_G$ 的厄米矩阵使用标准的数值本征求解器进行对角化，以获得它们的本征值，这些本征值对应于系统的能级。\n\n**$4$. 分析与最终评估**\n\n分析遵循问题陈述中指定的规则。\n首先，我们计算每个哈密顿量的负本征值数量 $N_{-}(H)$。这些代表系统的束縛态。\n- 如果构建 A 引入了比局域参考更多的新束缚态，即 $N_{-}(H_A)  N_{-}(H_{\\mathrm{loc}})$，则检测到了一个**鬼态**。\n- 如果构建 B 产生的束缚态数量与参考相同，即 $N_{-}(H_B) = N_{-}(H_{\\mathrm{loc}})$，则鬼态被**消除**。\n- **可移植性**是衡量基本物理性质（例如基态能量）被保持得有多好的一种度量。如果在容差 $\\varepsilon = 10^{-4}$ Ha 内，基态能量保持不变，即 $|E_0(H_B) - E_0(H_{\\mathrm{loc}})| \\le \\varepsilon$，则认为可移植性得以保持。这里，$E_0(H)$ 是哈密顿量 $H$ 的最低本征值。如果参考哈密顿量 $H_{\\mathrm{loc}}$ 没有束缚态（即 $N_{-}(H_{\\mathrm{loc}})=0$），则绕过此检查。\n\n对于每个测试用例，通过对这三个条件的逻辑“与”运算来计算最终的布尔结果：\n$$\n\\mathrm{Result} = \\big(N_{-}(H_{A})  N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\big(N_{-}(H_{B}) = N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\Big(N_{-}(H_{\\mathrm{loc}})=0 \\ \\vee\\ \\lvert E_0(H_{B}) - E_0(H_{\\mathrm{loc}}) \\rvert \\le \\varepsilon\\Big)\n$$\n这个协议系统地验证了构建 A 是否表现出鬼态的病态问题，以及构建 B 是否在保持物理准确性的同时成功地修正了该问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 40.0, \"E_cut\": 0.8, \"V0\": -0.20, \"a\": 1.0,\n            \"A\": {\"type\": \"even\", \"b\": [0.6, 0.3], \"D\": [-100.0, -50.0]},\n            \"B\": {\"type\": \"odd\", \"b\": [0.6, 0.3], \"D\": [20.0, 10.0]},\n        },\n        {\n            \"L\": 40.0, \"E_cut\": 0.3, \"V0\": -0.20, \"a\": 1.0,\n            \"A\": {\"type\": \"even\", \"b\": [0.6, 0.3], \"D\": [-80.0, -40.0]},\n            \"B\": {\"type\": \"odd\", \"b\": [0.6, 0.3], \"D\": [15.0, 7.0]},\n        },\n        {\n            \"L\": 40.0, \"E_cut\": 0.8, \"V0\": -0.05, \"a\": 1.0,\n            \"A\": {\"type\": \"even\", \"b\": [0.6, 0.3], \"D\": [0.0, 0.0]},\n            \"B\": {\"type\": \"odd\", \"b\": [0.6, 0.3], \"D\": [2.0, 1.0]},\n        },\n    ]\n\n    epsilon = 1e-4\n    results = []\n\n    for case in test_cases:\n        result = evaluate_case(\n            case[\"L\"], case[\"E_cut\"], case[\"V0\"], case[\"a\"],\n            case[\"A\"], case[\"B\"], epsilon\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef evaluate_case(L, E_cut, V0, a, proj_A_params, proj_B_params, epsilon):\n    \"\"\"\n    Performs the plane-wave simulation for a single test case.\n    \"\"\"\n    # 1. Basis Set Construction\n    # Determine the maximum integer n for the G-vectors based on E_cut\n    n_max = int(np.floor(L * np.sqrt(2 * E_cut) / (2 * np.pi)))\n    G_vec = (2 * np.pi / L) * np.arange(-n_max, n_max + 1)\n    N_G = len(G_vec)\n\n    # 2. Kinetic Energy Matrix (T)\n    T_mat = 0.5 * np.diag(G_vec**2)\n\n    # 3. Local Potential Matrix (V_loc)\n    # G-G' matrix\n    q_mat = G_vec[:, None] - G_vec[None, :]\n    V_loc_mat = (V0 / L) * np.sqrt(np.pi) * a * np.exp(-((q_mat * a / 2.0)**2))\n\n    # 4. Nonlocal Potential Matrices (V_nl)\n    # Construction A\n    V_nl_A = np.zeros((N_G, N_G), dtype=float)\n    b_vals_A, D_vals_A = proj_A_params[\"b\"], proj_A_params[\"D\"]\n    for b, D in zip(b_vals_A, D_vals_A):\n        # Even projector: beta_G = L^{-1/2} * sqrt(pi)*b * exp(-(Gb/2)^2)\n        beta_G_vec_even = (np.sqrt(np.pi) * b / np.sqrt(L)) * \\\n                          np.exp(-((G_vec * b / 2.0)**2))\n        V_nl_A += D * np.outer(beta_G_vec_even, beta_G_vec_even)\n    \n    # Construction B\n    V_nl_B = np.zeros((N_G, N_G), dtype=float)\n    b_vals_B, D_vals_B = proj_B_params[\"b\"], proj_B_params[\"D\"]\n    for b, D in zip(b_vals_B, D_vals_B):\n        # Odd projector: beta_G = i * f(G), where f(G) is real.\n        # The matrix becomes D * f(G_i) * f(G_j)\n        f_G_vec_odd = (np.sqrt(np.pi) * b / np.sqrt(L)) * \\\n                      (-G_vec * b**2 / 2.0) * \\\n                      np.exp(-((G_vec * b / 2.0)**2))\n        V_nl_B += D * np.outer(f_G_vec_odd, f_G_vec_odd)\n\n    # 5. Assemble Hamiltonians\n    H_loc = T_mat + V_loc_mat\n    H_A = H_loc + V_nl_A\n    H_B = H_loc + V_nl_B\n\n    # 6. Diagonalize Matrices to find eigenvalues\n    eigvals_loc = eigh(H_loc, eigvals_only=True)\n    eigvals_A = eigh(H_A, eigvals_only=True)\n    eigvals_B = eigh(H_B, eigvals_only=True)\n\n    # 7. Analyze eigenvalues and compute final boolean result\n    # Count negative eigenvalues (bound states)\n    N_neg_loc = np.sum(eigvals_loc  0)\n    N_neg_A = np.sum(eigvals_A  0)\n    N_neg_B = np.sum(eigvals_B  0)\n\n    # Condition 1: Ghost state detected in Construction A\n    cond1_ghost_detected = N_neg_A > N_neg_loc\n\n    # Condition 2: Ghost state eliminated in Construction B\n    cond2_ghost_eliminated = N_neg_B == N_neg_loc\n\n    # Condition 3: Transferability is retained\n    cond3_transferability = False\n    if N_neg_loc == 0:\n        cond3_transferability = True\n    else:\n        # Check energy difference only if there are bound states in reference\n        E0_loc = np.min(eigvals_loc)\n        E0_B = np.min(eigvals_B)\n        if abs(E0_B - E0_loc) = epsilon:\n            cond3_transferability = True\n            \n    final_result = cond1_ghost_detected and cond2_ghost_eliminated and cond3_transferability\n    return final_result\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2915027"}]}