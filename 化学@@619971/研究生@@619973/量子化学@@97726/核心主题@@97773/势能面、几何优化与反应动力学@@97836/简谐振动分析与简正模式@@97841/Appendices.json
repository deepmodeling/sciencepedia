{"hands_on_practices": [{"introduction": "谐振分析不仅能提供振动频率($\\omega_k$)，还能给出作为光谱强度计算基础的简正模向量。本练习将指导您完成一个从头计算拉曼活性的过程，这是一个解释拉曼光谱的关键性质。您将应用有限差分法，这是一种在解析导数不可用时将势能面、极化率和最终光谱强度联系起来的实用技术，从而将抽象的简正模向量与可预测的光谱联系起来。[@problem_id:2894873]", "problem": "设计并实现一个完整的、可运行的程序，该程序仅使用电子能量对外部均匀电场和原子核笛卡尔坐标的解析二阶导数，计算振动简正模的转动平均拉曼散射活性。您的推导和算法应基于以下在量子化学和分子光谱学中被认为是基础的原理和事实：\n\n- 在玻恩–奥本海默（Born–Oppenheimer, BO）近似下，电子基态能量可以表示为原子核笛卡尔坐标和外部均匀电场的函数。能量相对于平衡构型附近原子核笛卡尔位移的二阶泰勒展开，产生一个由能量关于原子核笛卡尔坐标的海森矩阵表征的二次型。谐振分析利用此二次型以及对角化的原子核质量矩阵来定义质量加权简正模和谐振频率。\n- 在静态、空间均匀的电场中，感生电子偶极矩通过极化率张量与电场线性相关，该张量等于电子能量对外部电场各分量的负二阶导数。此关系源于能量对电场的二阶泰勒展开。\n- 在电偶极近似和非共振（Placzek）极限下，结合双谐波近似，振动模的拉曼散射活性取决于由极化率张量对质量加权简正坐标的一阶导数构建的转动不变量。\n\n您不得假设可以获取高于二阶的关于坐标或电场的导数。因此，为了获得极化率张量对简正坐标的导数，您必须沿每个质量加权简正模坐标使用中心有限差分方案，在位移后的构型上计算极化率张量。任何构型下的极化率张量都是通过在该构型下能量对电场的二阶导数获得的。假设位移很小，并且对于电场而言线性响应机制有效，对于原子核位移而言谐波机制有效。\n\n您的程序必须以纯数学术语实现以下协议：\n\n- 结合原子核质量矩阵（对角矩阵）和原子核笛卡尔海森矩阵（对称矩阵），构建质量加权海森矩阵。对质量加权海森矩阵进行对角化，以获得谐振频率和正交归一的质量加权简正模。按频率递增的顺序对模进行排序。\n- 对于每个简正模，使用基于在相等且相反的简正模位移处计算的两个给定极化率张量的中心有限差分法，评估极化率张量对相应质量加权简正坐标的导数。\n- 对于每个模的导数张量，使用适用于非共振普拉切克和双谐波近似的极化率导数张量的标准各向同性和各向异性转动不变量，构建转动平均标量拉曼散射活性。\n- 对于每个测试用例，返回一个标量，该标量等于所有振动模的模式分辨拉曼活性之和。\n\n使用以下测试套件。所有矩阵和向量的解释如下。质量矩阵是对角矩阵，其元素等于原子核质量。原子核笛卡尔海森矩阵是在已经消除整体平移和转动的子空间中的对称正定矩阵。极化率张量是对称的，并以在沿质量加权简正坐标位移的构型处计算的能量对电场分量的二阶导数形式提供。所有输入的单位均为与哈特里原子单位制一致的原子单位。您必须以输入所隐含的相同内部原子单位表示最终的标量输出，不进行单位转换，并将每个标量结果四舍五入到 $6$ 位小数。\n\n测试用例 1：\n- 质量（对角线）：$[2000.0]$。\n- 原子核笛卡尔海森矩阵：\n$$\n\\begin{bmatrix}\n0.5\n\\end{bmatrix}\n$$\n- 沿质量加权简正坐标的模位移大小：$[\\;0.1\\;]$。\n- 单个模在 $+\\Delta Q$ 和 $-\\Delta Q$ 处的极化率张量（每个为 $3\\times 3$ 对称张量），其中每个条目均以原子单位给出：\n$$\n\\alpha^{(+)} =\n\\begin{bmatrix}\n10.0 & 0.2 & 0.0\\\\\n0.2 & 10.5 & 0.0\\\\\n0.0 & 0.0 & 9.8\n\\end{bmatrix},\n\\quad\n\\alpha^{(-)} =\n\\begin{bmatrix}\n9.8 & 0.1 & 0.0\\\\\n0.1 & 10.2 & 0.0\\\\\n0.0 & 0.0 & 9.9\n\\end{bmatrix}.\n$$\n\n测试用例 2：\n- 质量（对角线）：$[1000.0, 3000.0]$。\n- 原子核笛卡尔海森矩阵：\n$$\n\\begin{bmatrix}\n0.4 & 0.05\\\\\n0.05 & 0.6\n\\end{bmatrix}\n$$\n- 沿质量加权简正坐标的模位移大小：按谐振频率递增顺序为 $[\\,0.1,\\;0.07\\,]$。\n- 每个模 $k=1,2$ 在 $+\\Delta Q_k$ 和 $-\\Delta Q_k$ 处的极化率张量（每个为 $3\\times 3$ 对称张量），按谐振频率递增顺序提供：\n模 1：\n$$\n\\alpha^{(+)}_1 =\n\\begin{bmatrix}\n8.02 & 0.0 & 0.0\\\\\n0.0 & 7.99 & 0.0\\\\\n0.0 & 0.0 & 8.01\n\\end{bmatrix},\n\\quad\n\\alpha^{(-)}_1 =\n\\begin{bmatrix}\n8.00 & 0.0 & 0.0\\\\\n0.0 & 8.00 & 0.0\\\\\n0.0 & 0.0 & 8.00\n\\end{bmatrix}.\n$$\n模 2：\n$$\n\\alpha^{(+)}_2 =\n\\begin{bmatrix}\n7.7 & 0.4 & 0.0\\\\\n0.4 & 7.9 & -0.05\\\\\n0.0 & -0.05 & 7.85\n\\end{bmatrix},\n\\quad\n\\alpha^{(-)}_2 =\n\\begin{bmatrix}\n7.5 & 0.2 & 0.1\\\\\n0.2 & 8.0 & -0.1\\\\\n0.1 & -0.1 & 7.8\n\\end{bmatrix}.\n$$\n\n测试用例 3：\n- 质量（对角线）：$[1500.0]$。\n- 原子核笛卡尔海森矩阵：\n$$\n\\begin{bmatrix}\n0.3\n\\end{bmatrix}\n$$\n- 沿质量加权简正坐标的模位移大小：$[\\;0.05\\;]$。\n- 单个模在 $+\\Delta Q$ 和 $-\\Delta Q$ 处的极化率张量：\n$$\n\\alpha^{(+)} =\n\\begin{bmatrix}\n6.0 & 0.0 & 0.0\\\\\n0.0 & 6.0 & 0.0\\\\\n0.0 & 0.0 & 6.0\n\\end{bmatrix},\n\\quad\n\\alpha^{(-)} =\n\\begin{bmatrix}\n6.0 & 0.0 & 0.0\\\\\n0.0 & 6.0 & 0.0\\\\\n0.0 & 0.0 & 6.0\n\\end{bmatrix}.\n$$\n\n您必须在协议中采用的关键近似：\n- 用于分离电子和原子核运动的玻恩-奥本海默（Born–Oppenheimer, BO）近似。\n- 拉曼散射的电偶极相互作用和非共振（Placzek）近似。\n- 双谐波近似：谐波核势以及极化率对简正坐标在平衡点附近的线性依赖关系。\n- 在每个构型下，相对于外部电场的静态场极限和线性响应。\n- 忽略振动非谐性、超出简正坐标线性阶数的电非谐性以及共振增强。\n\n您的程序必须生成单行输出，其中包含 $3$ 个标量结果，每个测试用例一个，形式为逗号分隔的列表，并用方括号括起来，四舍五入到 $6$ 位小数，例如，$[x_1,x_2,x_3]$，其中每个 $x_i$ 是如上所述的以原子单位表示的浮点数。", "solution": "所述问题在科学上是合理的、适定的且完整的。它描述了一种基于量子化学和分子光谱学基本原理的标准（尽管简化了）计算协议，用于确定拉曼散射活性。不存在不一致、模糊或违反物理定律之处。因此，我们可以进行严谨的求解。\n\n该问题要求计算分子振动的转动平均拉曼散射活性。这将分两个主要阶段完成：首先，进行谐振分析以确定简正模及其频率；其次，使用极化率张量的有限差分法计算每个模的拉曼活性。\n\n**1. 谐振分析**\n\n在玻恩-奥本海默近似下，分子的电子能量 $E$ 是其原子核坐标的函数，这定义了原子核运动的势能面（PES）$V(\\mathbf{x})$。对于从平衡构型 $\\mathbf{x}_{eq}$ 的小位移 $\\Delta \\mathbf{x} = \\mathbf{x} - \\mathbf{x}_{eq}$，PES 可以通过截断到二阶的泰勒级数展开来近似，即谐波近似：\n$$\nV(\\mathbf{x}) \\approx V(\\mathbf{x}_{eq}) + \\frac{1}{2} \\Delta \\mathbf{x}^T \\mathbf{H} \\Delta \\mathbf{x}\n$$\n这里，$\\mathbf{H}$ 是在平衡点计算的能量对 $N$ 个原子核笛卡尔坐标的二阶偏导数的海森矩阵：\n$$\nH_{ij} = \\left( \\frac{\\partial^2 E}{\\partial x_i \\partial x_j} \\right)_{\\mathbf{x}=\\mathbf{x}_{eq}}\n$$\n原子核的经典运动方程由牛顿第二定律给出，$\\mathbf{M} \\ddot{\\mathbf{x}} = -\\nabla V(\\mathbf{x}) = -\\mathbf{H} \\mathbf{x}$，其中我们已将原点移至 $\\mathbf{x}_{eq}$ 并设置 $V(\\mathbf{x}_{eq})=0$。$\\mathbf{M}$ 是原子核质量的对角矩阵，$M_{ii} = m_i$。为了简化这个广义特征值问题，我们引入质量加权笛卡尔坐标 $\\mathbf{q}$，定义为 $q_i = \\sqrt{m_i} x_i$。在这些坐标中，动能 T 具有简单的形式 $T = \\frac{1}{2} \\sum_i \\dot{q}_i^2$，而势能变为：\n$$\nV(\\mathbf{q}) = \\frac{1}{2} \\mathbf{q}^T \\mathbf{H}^{mw} \\mathbf{q}\n$$\n其中 $\\mathbf{H}^{mw}$ 是质量加权海森矩阵，构造如下：\n$$\nH^{mw}_{ij} = \\frac{H_{ij}}{\\sqrt{m_i m_j}} \\quad \\text{or in matrix form,} \\quad \\mathbf{H}^{mw} = \\mathbf{M}^{-1/2} \\mathbf{H} \\mathbf{M}^{-1/2}\n$$\n质量加权坐标中的运动方程为 $\\ddot{\\mathbf{q}} = -\\mathbf{H}^{mw} \\mathbf{q}$。我们寻求形式为 $\\mathbf{q}(t) = \\mathbf{l} \\cos(\\omega t + \\phi)$ 的解，这导致了标准的特征值问题：\n$$\n\\mathbf{H}^{mw} \\mathbf{l}_k = \\lambda_k \\mathbf{l}_k\n$$\n质量加权海森矩阵的特征值 $\\lambda_k$ 是谐振频率的平方，$\\lambda_k = \\omega_k^2$。相应的特征向量 $\\mathbf{l}_k$ 是质量加权简正模。这些特征向量构成一个正交归一基，$\\mathbf{l}_k^T \\mathbf{l}_j = \\delta_{kj}$。根据要求，我们将按频率 $\\omega_k$ 递增的顺序对这些模进行排序。\n\n**2. 拉曼散射活性**\n\n在非共振普拉切克（Placzek）近似中，对应于振动模 $k$ 的跃迁的拉曼散射强度与感生偶极矩的平方成正比，而感生偶极矩又取决于分子极化率张量 $\\alpha$ 对该模的简正坐标 $Q_k$ 的导数。极化率本身是电子能量对静态外部电场 $\\mathcal{E}$ 的负二阶导数，$\\alpha_{\\mu\\nu} = -\\frac{\\partial^2 E}{\\partial \\mathcal{E}_\\mu \\partial \\mathcal{E}_\\nu}$。\n\n问题要求使用中心有限差分方案计算极化率导数张量 $\\alpha'_k = \\frac{\\partial \\alpha}{\\partial Q_k}$。这是必要的，因为我们被限制只能使用能量的二阶导数。因此，模态 $k$ 的极化率导数近似为：\n$$\n\\alpha'_k \\approx \\frac{\\alpha(+\\Delta Q_k) - \\alpha(-\\Delta Q_k)}{2 \\Delta Q_k}\n$$\n其中 $\\alpha(\\pm\\Delta Q_k)$ 是在沿质量加权简正模坐标 $Q_k$ 位移了 $\\pm\\Delta Q_k$ 量的构型上计算的极化率张量。这些张量作为输入提供。\n\n对于模 $k$，转动平均拉曼散射活性 $S_k$ 由对称张量 $\\alpha'_k$ 的两个转动不变量构建而成：平均极化率导数 $\\bar{\\alpha}'_k$ 和各向异性 $(\\gamma'_k{}^2)$。公式为：\n$$\nS_k = 45(\\bar{\\alpha}'_k)^2 + 7(\\gamma'_k{}^2)\n$$\n各向同性不变量，或平均极化率导数，是 $\\alpha'_k$ 的迹的三分之一：\n$$\n\\bar{\\alpha}'_k = \\frac{1}{3} \\text{Tr}(\\alpha'_k) = \\frac{1}{3} (\\alpha'_{k,xx} + \\alpha'_{k,yy} + \\alpha'_{k,zz})\n$$\n各向异性不变量定义为：\n$$\n(\\gamma'_k)^2 = \\frac{1}{2} \\left[ (\\alpha'_{k,xx} - \\alpha'_{k,yy})^2 + (\\alpha'_{k,yy} - \\alpha'_{k,zz})^2 + (\\alpha'_{k,zz} - \\alpha'_{k,xx})^2 \\right] + 3 \\left[ (\\alpha'_{k,xy})^2 + (\\alpha'_{k,yz})^2 + (\\alpha'_{k,zx})^2 \\right]\n$$\n一个等效且更紧凑的表达式是 $(\\gamma'_k)^2 = \\frac{1}{2} \\left( 3 \\text{Tr}[(\\alpha'_k)^2] - (\\text{Tr}[\\alpha'_k])^2 \\right)$，这便于数值实现。\n\n**3. 计算协议**\n\n所实现的算法将对每个测试用例严格遵循以下步骤：\n1.  构建对角质量矩阵 $\\mathbf{M}$ 及其逆平方根 $\\mathbf{M}^{-1/2}$。\n2.  构建质量加权海森矩阵 $\\mathbf{H}^{mw} = \\mathbf{M}^{-1/2} \\mathbf{H} \\mathbf{M}^{-1/2}$。\n3.  对 $\\mathbf{H}^{mw}$ 进行对角化以获得其特征值 $\\lambda_k$（频率的平方）。\n4.  按升序对特征值进行排序。得到的模序将用于处理所提供的特定于模的数据（$\\Delta Q_k$ 和 $\\alpha_k^{(\\pm)}$），问题说明这些数据已按此排序顺序提供。此步骤用作模序的形式验证。\n5.  初始化总拉曼活性累加器，$S_{total} = 0$。\n6.  遍历每个振动模 $k$：\n    a. 检索相应的位移大小 $\\Delta Q_k$ 和预先计算的极化率张量 $\\alpha^{(+)}_k$ 和 $\\alpha^{(-)}_k$。\n    b. 使用中心有限差分公式计算极化率导数张量 $\\alpha'_k$。\n    c. 从 $\\alpha'_k$ 的分量计算不变量 $\\bar{\\alpha}'_k$ 和 $(\\gamma'_k)^2$。\n    d. 计算该模的拉曼活性，$S_k = 45(\\bar{\\alpha}'_k)^2 + 7(\\gamma'_k{}^2)$。\n    e. 将其加到总和中：$S_{total} = S_{total} + S_k$。\n7.  测试用例的最终结果是计算出的标量值 $S_{total}$，该值将四舍五入到 $6$ 位小数。\n\n该协议忠实地实现了所要求的物理模型和数值程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes rotationally averaged Raman scattering activities for vibrational normal modes.\n    \"\"\"\n    test_cases = [\n        {\n            \"masses\": np.array([2000.0]),\n            \"hessian\": np.array([[0.5]]),\n            \"displacements\": np.array([0.1]),\n            \"alpha_plus\": [\n                np.array([\n                    [10.0, 0.2, 0.0],\n                    [0.2, 10.5, 0.0],\n                    [0.0, 0.0, 9.8]\n                ])\n            ],\n            \"alpha_minus\": [\n                np.array([\n                    [9.8, 0.1, 0.0],\n                    [0.1, 10.2, 0.0],\n                    [0.0, 0.0, 9.9]\n                ])\n            ],\n        },\n        {\n            \"masses\": np.array([1000.0, 3000.0]),\n            \"hessian\": np.array([\n                [0.4, 0.05],\n                [0.05, 0.6]\n            ]),\n            \"displacements\": np.array([0.1, 0.07]),\n            \"alpha_plus\": [\n                np.array([\n                    [8.02, 0.0, 0.0],\n                    [0.0, 7.99, 0.0],\n                    [0.0, 0.0, 8.01]\n                ]),\n                np.array([\n                    [7.7, 0.4, 0.0],\n                    [0.4, 7.9, -0.05],\n                    [0.0, -0.05, 7.85]\n                ])\n            ],\n            \"alpha_minus\": [\n                np.array([\n                    [8.00, 0.0, 0.0],\n                    [0.0, 8.00, 0.0],\n                    [0.0, 0.0, 8.00]\n                ]),\n                np.array([\n                    [7.5, 0.2, 0.1],\n                    [0.2, 8.0, -0.1],\n                    [0.1, -0.1, 7.8]\n                ])\n            ],\n        },\n        {\n            \"masses\": np.array([1500.0]),\n            \"hessian\": np.array([[0.3]]),\n            \"displacements\": np.array([0.05]),\n            \"alpha_plus\": [\n                np.array([\n                    [6.0, 0.0, 0.0],\n                    [0.0, 6.0, 0.0],\n                    [0.0, 0.0, 6.0]\n                ])\n            ],\n            \"alpha_minus\": [\n                np.array([\n                    [6.0, 0.0, 0.0],\n                    [0.0, 6.0, 0.0],\n                    [0.0, 0.0, 6.0]\n                ])\n            ],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        masses = case[\"masses\"]\n        H = case[\"hessian\"]\n        \n        # 1. Construct and diagonalize the mass-weighted Hessian\n        # This step is performed to determine the correct ordering of vibrational modes.\n        m_inv_sqrt = np.diag(1.0 / np.sqrt(masses))\n        H_mw = m_inv_sqrt @ H @ m_inv_sqrt\n        \n        # Eigenvalues are squared frequencies (lambda = omega^2).\n        # np.linalg.eigh returns eigenvalues in ascending order.\n        eigenvalues, _ = np.linalg.eigh(H_mw)\n        \n        # The problem provides mode-specific data (displacements, polarizabilities)\n        # pre-sorted by increasing frequency. The sorting of eigenvalues here\n        # provides the indices that correspond to this pre-sorted data.\n        # sort_indices = np.argsort(eigenvalues) # not needed as eigh already sorts\n        \n        num_modes = len(eigenvalues)\n        total_activity = 0.0\n\n        for k in range(num_modes):\n            # 2. Get data for the current mode k\n            # The indices from the sorted eigenvalues correspond to the pre-sorted input arrays.\n            delta_Q_k = case[\"displacements\"][k]\n            alpha_plus_k = case[\"alpha_plus\"][k]\n            alpha_minus_k = case[\"alpha_minus\"][k]\n\n            # 3. Compute the polarizability derivative tensor via central finite difference\n            alpha_prime_k = (alpha_plus_k - alpha_minus_k) / (2.0 * delta_Q_k)\n\n            # 4. Calculate the rotational invariants\n            # Mean polarizability derivative (isotropic invariant)\n            mean_alpha_prime_k = (1.0/3.0) * np.trace(alpha_prime_k)\n\n            # Anisotropy of the polarizability derivative\n            # Implemented using the compact trace form: \n            # gamma_prime^2 = 0.5 * (3*Tr(alpha_prime^2) - (Tr(alpha_prime))^2)\n            tr_alpha_prime_sq = (3.0 * mean_alpha_prime_k)**2\n            tr_alpha_prime_mat_sq = np.trace(alpha_prime_k @ alpha_prime_k)\n            gamma_prime_k_sq = 0.5 * (3.0 * tr_alpha_prime_mat_sq - tr_alpha_prime_sq)\n\n            # 5. Compute the Raman scattering activity for the mode\n            activity_k = 45.0 * (mean_alpha_prime_k**2) + 7.0 * gamma_prime_k_sq\n            \n            # 6. Accumulate the total activity\n            total_activity += activity_k\n            \n        # Round the final result for the test case to 6 decimal places.\n        results.append(f\"{total_activity:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2894873"}, {"introduction": "计算结果并非绝对可靠，确保其准确性是至关重要的一步。在振动分析中，一个常见的挑战是由于几何优化不完全或数值噪声而出现虚假的小频率或虚频。本练习模拟了一个在计算化学中真实而常见的情景，旨在训练您像专家一样思考，批判性地评估计算参数，并诊断可疑结果究竟是真实的物理特征还是需要修正的数值伪影。[@problem_id:2895011]", "problem": "一个包含 $N=8$ 个原子的非线性分子，使用密度泛函理论 (DFT) 和中等大小的基组及默认数值设置进行优化。几何优化被宣布收敛，其收敛标准为：能量变化阈值 $10^{-6}\\ E_{\\mathrm{h}}$，最大笛卡尔力阈值 $3\\times 10^{-4}\\ E_{\\mathrm{h}}/a_{0}$，以及均方根 (RMS) 力 $6\\times 10^{-5}\\ E_{\\mathrm{h}}/a_{0}$。自洽场 (SCF) 过程采用迭代子空间直接求逆 (DIIS) 加速器，当密度变化低于 $10^{-6}$ 时终止。然而，在某些优化步骤中，能量变化接近 $10^{-7}\\ E_{\\mathrm{h}}$ 时达到了 DIIS 迭代次数的上限。DFT 正交格点被设置为粗略的默认值。随后的简谐振动分析产生了一个虚频 $\\tilde{\\nu}_{1} = i\\,18\\ \\mathrm{cm}^{-1}$，两个非常低的正频率 $9\\ \\mathrm{cm}^{-1}$ 和 $12\\ \\mathrm{cm}^{-1}$，所有其余频率均高于 $200\\ \\mathrm{cm}^{-1}$。程序报告的六个名义上的平动/转动模式的最低频率为 $7, 5, 3, 2, 1,$ 和 $0\\ \\mathrm{cm}^{-1}$。与虚频模式相对应的动画位移在视觉上表现为轻微的整体漂移和小振幅扭转的组合。\n\n假设势能面是光滑的，且优化后的几何结构应对应于一个真极小点。仅根据简谐振动分析和简正模的第一性原理，判断以下哪些操作是确定低频特征是否为伪数值赝象（例如，由不完全的SCF收敛或数值噪声引起）并在其非物理时消除它们的最合适的诊断和补救步骤。选择所有适用项。\n\nA. 使用更严格的收敛阈值（例如，能量变化 $10^{-10}\\ E_{\\mathrm{h}}$，最大力 $10^{-5}\\ E_{\\mathrm{h}}/a_{0}$）重新优化几何结构，强制执行更严格的SCF密度收敛（例如，$10^{-10}$）且不允许因达到迭代次数上限而终止，增加DFT积分格点和积分精度，然后重新计算一个解析Hessian矩阵，并使用Eckart条件明确地投影掉整体的平动/转动。在精炼后的驻点重新评估振动光谱。\n\nB. 施加精确的点群对称性约束，并通过完整约束冻结整体的转动/平动，同时保持原始的SCF和数值阈值不变，寄希望于通过强制对称性来消除数值赝象而无需进一步提高精度。\n\nC. 在不改变收敛或数值设置的情况下，用笛卡尔坐标下的有限差分Hessian矩阵替换解析Hessian矩阵，使用更大的位移步长来抑制噪声，并认为由此产生的频率在构造上更可靠。\n\nD. 沿着虚频模式的本征向量构建一维势能扫描，通过几个小步骤（例如，在无量纲质量加权简正坐标中位移 $\\pm 0.05$）移动几何结构，并在每个位移点上将SCF和力收敛到非常严格的阈值。如果能量曲线在驻点附近局部是凸的并且在数值噪声范围内是平坦的，则将原始虚频归因于数值赝象；如果获得鞍点形状的曲线，则认为该模式是物理的。\n\n仅有以上信息可用；除其非线性特征外，不要假定分子有任何特殊性质。选择最佳的操作组合。", "solution": "问题陈述已经过验证，被认为是有效的。它展示了计算量子化学中一个真实而常见的情景，为回答所提出的问题提供了充分且一致的信息。该情景具有科学依据，设定良好且客观。我们可以继续进行分析。\n\n简谐振动分析的基础在于对势能面 (PES) $V(\\mathbf{q})$ 上的驻点进行表征，在该点上梯度（力）为零：$\\nabla V = \\mathbf{0}$。该点的性质——是极小点、过渡态还是更高阶的鞍点——由质量加权Hessian矩阵的本征值决定，该矩阵包含能量相对于原子坐标的二阶导数。对于一个真极小点，质量加权Hessian矩阵的所有 $3N$ 个本征值必须为非负。对于一个包含 $N$ 个原子的非线性分子，这对应于 $3N-6$ 个正的振动频率和6个与整体平动和转动相关的零频率。单个负本征值（表现为单个虚频，$\\tilde{\\nu} \\propto \\sqrt{-\\lambda}$）表示一个一阶鞍点，即过渡态。\n\n所提供的数据描述了对一个包含 $N=8$ 个原子的非线性分子的计算。一个真极小点应表现出 $3(8)-6 = 18$ 个正振动频率和6个零频率。而呈现的结果是：\n1.  一个小的虚频：$\\tilde{\\nu}_{1} = i\\,18\\ \\mathrm{cm}^{-1}$。\n2.  两个非常低的正频率：$9\\ \\mathrm{cm}^{-1}$和$12\\ \\mathrm{cm}^{-1}$。\n3.  6个平动和转动 (T/R) 模式的频率为非零值：$7, 5, 3, 2, 1,$ 和 $0\\ \\mathrm{cm}^{-1}$。\n4.  几何优化在相对宽松的收敛标准下终止（例如，最大力为$3\\times 10^{-4}\\ E_{\\mathrm{h}}/a_{0}$）。\n5.  底层的电子结构计算不够严格：自洽场 (SCF) 收敛标准宽松（密度变化$10^{-6}$），有时不完全收敛（达到迭代次数上限），并且使用了粗略的DFT积分格点。\n\n这些症状的组合强烈地指向了数值赝象。几何结构没有完全收敛到一个真正的驻点（梯度并非真正为零），并且Hessian矩阵被粗略格点和不充分收敛的SCF所产生的数值噪声污染了。一个小的虚频，在视觉上通常表现为低能内部运动与整体平动或转动的混合，是这些数值问题的典型标志。非零的平动/转动（T/R）模式频率是含噪声的Hessian矩阵和不完全收敛的直接后果，这妨碍了将这些模式清晰地投影到零。任务是确定正确的诊断和补救措施。\n\n现在，我们逐一评估每个选项。\n\n**A. 使用更严格的收敛阈值（例如，能量变化 $10^{-10}\\ E_{\\mathrm{h}}$，最大力 $10^{-5}\\ E_{\\mathrm{h}}/a_{0}$）重新优化几何结构，强制执行更严格的SCF密度收敛（例如，$10^{-10}$）且不允许因达到迭代次数上限而终止，增加DFT积分格点和积分精度，然后重新计算一个解析Hessian矩阵，并使用Eckart条件明确地投影掉整体的平动/转动。在精炼后的驻点重新评估振动光谱。**\n\n该选项提出了一个系统而全面的解决方案，解决了所有已识别的误差来源：\n-   **更严格的优化阈值：** 强制执行例如 $10^{-5}\\ E_{\\mathrm{h}}/a_{0}$ 的最大力阈值，确保几何结构更接近梯度几乎为零的真驻点。\n-   **更严格的SCF收敛和更高的格点质量：** 提高SCF收敛标准（例如，密度变化达到 $10^{-10}$）并使用更精细的积分格点（以及更严格的积分截断），对于获得准确的能量以及更重要的，准确的解析导数（力和Hessian矩阵）至关重要。这直接减少了困扰当前Hessian矩阵的数值噪声。\n-   **使用Eckart投影的解析Hessian矩阵：** 在这个新的、高质量的驻点上计算解析Hessian矩阵，可以提供最准确的二阶导数。随后使用Eckart条件进行投影，是形式上正确的分离内振动模式与整体平动和转动的程序，这应导致六个频率在数值上为零。\n\n这一系列操作代表了获得可靠简谐频率的黄金标准。它既是针对所观察到问题的补救措施，也是一种诊断确认——如果新的频率都是实数且为正。\n\n结论：**正确**。\n\n**B. 施加精确的点群对称性约束，并通过完整约束冻结整体的转动/平动，同时保持原始的SCF和数值阈值不变，寄希望于通过强制对称性来消除数值赝象而无需进一步提高精度。**\n\n这种方法存在根本性缺陷。虽然施加对称性（如果分子具有对称性）可能是一个好方法，但它无法弥补数值精度的不足。主要问题是宽松的收敛标准和粗略的格点，这导致了对势能面本身的不准确表述。在这些不佳的设置下计算Hessian矩阵，无论是否应用对称性约束，都将产生一个充满噪声、不可靠的结果。冻结平动和转动是一种粗糙的方法，不能保证找到了真正的驻点。这个选项未能解决问题的根本原因。\n\n结论：**不正确**。\n\n**C. 在不改变收敛或数值设置的情况下，用笛卡尔坐标下的有限差分Hessian矩阵替换解析Hessian矩阵，使用更大的位移步长来抑制噪声，并认为由此产生的频率在构造上更可靠。**\n\n这是一个被误导的方法。有限差分Hessian矩阵是通过对梯度进行微分计算的，因此它仍然依赖于底层力计算的质量，而在本例中这个质量很差（“垃圾进，垃圾出”）。更关键的是，对于*简谐*分析，使用“更大的位移步长”在理论上是错误的。根据定义，简谐近似仅在无穷小位移的极限下有效。更大的步长会有意地将非谐效应引入Hessian矩阵，这是用系统误差来换取数值噪声的减小。这不会产生更“可靠”的简谐频率，而是一个不同的、不正确的数值。\n\n结论：**不正确**。\n\n**D. 沿着虚频模式的本征向量构建一维势能扫描，通过几个小步骤（例如，在无量纲质量加权简正坐标中位移 $\\pm 0.05$）移动几何结构，并在每个位移点上将SCF和力收敛到非常严格的阈值。如果能量曲线在驻点附近局部是凸的并且在数值噪声范围内是平坦的，则将原始虚频归因于数值赝象；如果获得鞍点形状的曲线，则认为该模式是物理的。**\n\n这个选项描述了一个标准且强大的*诊断*程序。通过沿着有问题的坐标绘制势能面（PES），可以直接观察其真实性质。对扫描路径上的每个点使用严格的收敛标准对其有效性至关重要。如果得到的能量曲线基本平坦 ($k \\approx 0$)，或者显示真极小点与起始点有轻微位移（凸形曲线, $k > 0$），这就为虚频 ($k < 0$) 是数值赝象提供了确凿的证据。这直接回答了问题中关于“确定低频特征是否为伪”的方法部分。虽然这个方法本身并不能为所有18个振动模式提供补救，但在开始执行选项A中更耗费计算资源的全面补救措施之前，这是确切诊断问题的关键且非常合适的一步。\n\n结论：**正确**。\n\n选项A和D都是非常合适的操作。选项D是确认虚频性质的绝佳诊断步骤。选项A是获得正确且具有物理意义的完整振动光谱的全面补救程序。问题要求选择“诊断和补救步骤”，并“选择所有适用项”。D是诊断，A是补救。因此，两者都是正确的。", "answer": "$$\\boxed{AD}$$", "id": "2895011"}, {"introduction": "谐振子模型是一个近似，因此计算出的谐振频率($\\omega$)与实验测量的基频($\\nu_{exp}$)之间存在系统性偏差。本练习将介绍一种标准而强大的技术来弥合这一差距：使用统一的缩放因子($s$)，使得 $\\nu_{exp} \\approx s \\times \\omega$。您将实施一个统计方案，通过将计算出的谐振频率与一组实验基频进行拟合来确定最佳缩放因子，这是进行准确预测和将计算结果与实验测量进行比较的关键一步。[@problem_id:2894984]", "problem": "你的任务是设计并实现一个完全可复现的计算方案，该方案基于分子振动的谐振近似，旨在使用一组实验基频作为参考，为指定的电子结构方法和基组组合确定一个单一的振动频率乘法标度因子。该方案必须从第一性原理出发：在谐振近似中，给定方法预测的简正模式频率是通过 Born–Oppenheimer 势能面的质量加权 Hessian 矩阵的本征值得到的。实验基频包含非谐性以及其他系统性的方法/基组误差，这些误差通常可以被一个单一的乘法标度因子很好地修正。假设一个模型，其中每个实验基频 $y_i$（单位为 $\\mathrm{cm}^{-1}$）通过 $y_i \\approx s \\, x_i + \\varepsilon_i$ 与计算出的谐振频率 $x_i$（单位为 $\\mathrm{cm}^{-1}$）相关联，其中 $s$ 是待确定的（未知）标度因子，而 $\\varepsilon_i$ 集合了由非谐性、基组不完备性和测量噪声引起的残余偏差。为了物理上的一致性，要求回归通过原点（无截距），因为消失的谐振频率必须映射到消失的基频。使用加权拟合来纳入已报告的实验不确定度。\n\n你的程序必须对下面的每个数据集执行以下步骤：\n\n1. 预处理：丢弃任何计算出的谐振频率 $x_i$ 严格小于数据集特定下限截止值 $f_{\\min}$（单位为 $\\mathrm{cm}^{-1}$）的模式，因为极低频的扭转和摆动通常无法用谐振模型很好地描述。所有输入和输出中的频率单位均为 $\\mathrm{cm}^{-1}$。\n\n2. 零截距加权拟合：确定值 $\\hat{s}$，使其最小化加权平方和 $\\sum_i w_i \\, (s \\, x_i - y_i)^2$，其中权重 $w_i = 1/u_i^2$，$u_i$ 是 $y_i$ 的已报告标准不确定度（单位为 $\\mathrm{cm}^{-1}$）。不包含截距项。\n\n3. 单遍稳健离群值剔除：计算残差 $r_i = \\hat{s} \\, x_i - y_i$ 和标准化残差 $t_i = \\sqrt{w_i} \\, r_i$。计算一个稳健的尺度 $\\sigma_{\\mathrm{rob}} = 1.4826 \\times \\mathrm{median}(|t_i - \\mathrm{median}(t_i)|)$。如果 $\\sigma_{\\mathrm{rob}} = 0$，则回退使用 $t_i$ 相对于零的均方根。移除满足 $|t_i| > 3 \\, \\sigma_{\\mathrm{rob}}$ 的观测值。使用剩余的观测值和相同的加权、零截距准则重新拟合以获得最终的 $\\hat{s}$。\n\n4. 不确定度传播与误差度量：对于保留的 $n$ 个观测值和 $p = 1$ 个拟合参数，计算残差平方和 $\\mathrm{RSS} = \\sum_i w_i \\, r_i^2$、尺度估计 $\\hat{\\sigma}^2 = \\mathrm{RSS}/(n - p)$ 以及标度因子的标准不确定度 $u_s = \\sqrt{\\hat{\\sigma}^2 / \\sum_i w_i x_i^2}$。此外，计算标度化频率相对于实验值的未加权均方根误差 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{n} \\sum_i r_i^2}$，单位为 $\\mathrm{cm}^{-1}$。\n\n5. 输出：对于每个数据集，输出一个列表 $[\\hat{s}, u_s, \\mathrm{RMSE}]$。你的程序必须生成单行输出，其中包含所有数据集的结果，格式为列表的列表 $[[\\hat{s}_1,u_{s,1},\\mathrm{RMSE}_1],[\\hat{s}_2,u_{s,2},\\mathrm{RMSE}_2],[\\hat{s}_3,u_{s,3},\\mathrm{RMSE}_3]]$，每个浮点值四舍五入到六位小数。\n\n实现上述方案并将其应用于以下测试套件。每个数据集提供计算出的谐振频率 $x$、实验基频 $y$、实验标准不确定度 $u$ 和下限截止值 $f_{\\min}$ 的数组，所有单位均为 $\\mathrm{cm}^{-1}$。\n\n- 数据集 A（一般情况，包含多种中高频模式）：\n  - $x = [3880, 3650, 3100, 3050, 1710, 1650, 1500, 1100, 1000, 700]$\n  - $y = [3723.68, 3512.65, 2971.1, 2937.05, 1643.31, 1582.65, 1447.5, 1055.1, 962.0, 672.7]$\n  - $u = [2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]$\n  - $f_{\\min} = 100$\n\n- 数据集 B（边界情况，包含一个待排除的极低频模式）：\n  - $x = [50, 180, 300, 500, 800, 1200, 2200, 3300]$\n  - $y = [47.9, 172.94, 286.4, 479.0, 767.0, 1149.0, 2108.0, 3162.0]$\n  - $u = [1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5]$\n  - $f_{\\min} = 100$\n\n- 数据集 C（边缘情况，包含一个因指认错误导致的单个严重离群值）：\n  - $x = [4000, 3900, 3600, 2000, 1500, 1400, 1200, 900, 600]$\n  - $y = [3860.0, 3766.5, 3470.0, 1932.0, 1600.0, 1352.0, 1160.0, 867.5, 579.0]$\n  - $u = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]$\n  - $f_{\\min} = 100$\n\n你的程序必须实现完整的方案，包括预处理、零截距加权拟合、单遍稳健离群值剔除、重新拟合、不确定度传播和误差度量计算。所有结果以 $\\mathrm{cm}^{-1}$ 报告，并将每个输出值四舍五入到六位小数。最终输出必须是单行，包含如上所述的列表的列表 $[[\\hat{s}_A,u_{s,A},\\mathrm{RMSE}_A],[\\hat{s}_B,u_{s,B},\\mathrm{RMSE}_B],[\\hat{s}_C,u_{s,C},\\mathrm{RMSE}_C]]$，不含任何额外文本。", "solution": "所提出的问题是计算化学中一个有效且定义明确的任务。它涉及到将计算出的谐振频率与实验基频进行统计校准。该方案在科学上是合理的，采用了加权最小二乘回归、稳健离群值检测和不确定性分析等标准方法。我将继续提供完整的解决方案。\n\n问题的核心在于确定一个单一的乘法标度因子 $s$，该因子能够最好地将一组计算出的谐振频率 $\\{x_i\\}$ 映射到一组相应的实验基频 $\\{y_i\\}$。其动机在于，在谐振近似下的电子结构计算会因忽略非谐性及其他方法特定误差而系统性地高估振动频率。单一标度因子通常能提供一种实用且有效的修正。\n\n所提出的强制通过原点的线性模型为 $y_i = s x_i + \\varepsilon_i$。这个物理约束是恰当的：零频率模式（平动或转动）应对应于零实验频率。项 $\\varepsilon_i$ 代表残余误差。$s$ 的最优值（记为 $\\hat{s}$）通过最小化加权残差平方和 $\\chi^2(s) = \\sum_i w_i (y_i - s x_i)^2$ 来找到。权重 $w_i = 1/u_i^2$ 源自实验不确定度 $u_i$，给予更精确的测量更大的影响。\n\n该方案通过以下严谨的步骤进行：\n\n1.  **预处理**：众所周知，谐振近似对于像扭转这样极低频、大振幅的运动描述得不好。因此，作为第一步，任何计算出的谐振频率 $x_i$ 小于指定截止值 $f_{\\min}$ 的数据点 $(x_i, y_i, u_i)$ 都将从数据集中移除。所有后续计算都在此过滤后的数据集上执行。\n\n2.  **初始加权最小二乘拟合**：为了找到使 $\\chi^2(s)$ 最小化的 $s$ 值，我们通过将其对 $s$ 的导数设为零来求解驻点：\n    $$\n    \\frac{d\\chi^2}{ds} = \\frac{d}{ds} \\sum_i w_i (y_i - s x_i)^2 = \\sum_i 2 w_i (y_i - s x_i)(-x_i) = 0\n    $$\n    化简后得到：\n    $$\n    \\sum_i w_i y_i x_i - s \\sum_i w_i x_i^2 = 0\n    $$\n    解出 $s$ 得到估计量 $\\hat{s}$：\n    $$\n    \\hat{s} = \\frac{\\sum_i w_i x_i y_i}{\\sum_i w_i x_i^2}\n    $$\n    此公式用于获得标度因子的初始估计。\n\n3.  **单遍稳健离群值剔除**：实验数据可能包含严重错误，例如来自谱线指认错误。需要一个稳健的统计程序来识别和移除此类离群值。\n    -   首先，计算初始拟合的残差：$r_i = \\hat{s} x_i - y_i$。\n    -   然后使用实验不确定度（即 $y_i$ 值的标准差）将它们标准化：$t_i = r_i / u_i = \\sqrt{w_i} r_i$。\n    -   使用中位数绝对偏差 (MAD) 计算这些标准化残差展布的一个稳健度量：$\\sigma_{\\mathrm{rob}} = 1.4826 \\times \\mathrm{median}(|t_i - \\mathrm{median}(t_i)|)$。因子 $1.4826$ 是 $1/\\Phi^{-1}(0.75)$ 的近似值，其中 $\\Phi^{-1}$ 是标准正态分布的分位数函数；这种标度使得 $\\sigma_{\\mathrm{rob}}$ 成为正态分布数据下标准差的一致估计量。\n    -   在 $\\sigma_{\\mathrm{rob}}$ 变为零的情况下（这可能发生在小数据集或高度一致的数据中），采用一种回退方法：稳健尺度将改为标准化残差相对于零的均方根，$\\sigma_{\\mathrm{rob}} = \\sqrt{\\frac{1}{n} \\sum_i t_i^2}$。\n    -   任何绝对标准化残差 $|t_i|$ 超过此稳健尺度 $3$ 倍的观测值，即 $|t_i| > 3 \\sigma_{\\mathrm{rob}}$，都将被标记为离群值并从数据集中移除。\n\n4.  **最终拟合与不确定度计算**：移除离群值后，使用相同的加权最小二乘公式对剩余的 $n$ 个数据点重新计算标度因子 $\\hat{s}$。让这个最终值作为报告的 $\\hat{s}$。\n    -   确定此最终 $\\hat{s}$ 的不确定度。在通过原点的加权线性回归中，斜率的方差由 $\\mathrm{Var}(\\hat{s}) = \\hat{\\sigma}^2 / (\\sum_i w_i x_i^2)$ 给出，其中求和遍及 $n$ 个保留点。\n    -   项 $\\hat{\\sigma}^2$ 是单位权重观测的估计方差，通常称为约化卡方。它是根据最终拟合的残差平方和 (RSS) 计算的：$\\hat{\\sigma}^2 = \\mathrm{RSS} / (n-p)$，其中 $\\mathrm{RSS} = \\sum_i w_i r_i^2$（使用最终残差 $r_i = \\hat{s} x_i - y_i$），$p=1$ 是拟合参数的数量。\n    -   因此，标度因子的标准不确定度为：\n    $$\n    u_s = \\sqrt{\\mathrm{Var}(\\hat{s})} = \\sqrt{\\frac{\\mathrm{RSS}}{(n-1) \\sum_i w_i x_i^2}}\n    $$\n    -   最后，计算未加权均方根误差 (RMSE)，以提供以原始单位 $\\mathrm{cm}^{-1}$ 表示的典型预测误差的度量：\n    $$\n    \\mathrm{RMSE} = \\sqrt{\\frac{1}{n} \\sum_i (\\hat{s} x_i - y_i)^2} = \\sqrt{\\frac{1}{n} \\sum_i r_i^2}\n    $$\n这套完整的方案不仅提供了最优的标度因子，还对其不确定度和整体拟合优度进行了统计上严谨的量化。实现将为每个提供的数据集精确遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the vibrational frequency scaling protocol\n    for all test cases and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"x\": [3880, 3650, 3100, 3050, 1710, 1650, 1500, 1100, 1000, 700],\n            \"y\": [3723.68, 3512.65, 2971.1, 2937.05, 1643.31, 1582.65, 1447.5, 1055.1, 962.0, 672.7],\n            \"u\": [2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n            \"f_min\": 100\n        },\n        {\n            \"x\": [50, 180, 300, 500, 800, 1200, 2200, 3300],\n            \"y\": [47.9, 172.94, 286.4, 479.0, 767.0, 1149.0, 2108.0, 3162.0],\n            \"u\": [1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5],\n            \"f_min\": 100\n        },\n        {\n            \"x\": [4000, 3900, 3600, 2000, 1500, 1400, 1200, 900, 600],\n            \"y\": [3860.0, 3766.5, 3470.0, 1932.0, 1600.0, 1352.0, 1160.0, 867.5, 579.0],\n            \"u\": [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],\n            \"f_min\": 100\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        x = np.array(case[\"x\"], dtype=float)\n        y = np.array(case[\"y\"], dtype=float)\n        u = np.array(case[\"u\"], dtype=float)\n        f_min = case[\"f_min\"]\n        \n        result = calculate_scaling_factor(x, y, u, f_min)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    formatted_results = []\n    for result_list in all_results:\n        formatted_list = f\"[{','.join([f'{val:.6f}' for val in result_list])}]\"\n        formatted_results.append(formatted_list)\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\ndef _weighted_fit_zero_intercept(x, y, u):\n    \"\"\"\n    Performs a weighted least-squares fit for a y = s*x model.\n    Returns the scaling factor s.\n    \"\"\"\n    w = 1.0 / u**2\n    numerator = np.sum(w * x * y)\n    denominator = np.sum(w * x**2)\n    if denominator == 0:\n        return 0.0 # Avoid division by zero\n    return numerator / denominator\n\ndef calculate_scaling_factor(x, y, u, f_min):\n    \"\"\"\n    Implements the full protocol for a single dataset.\n    \"\"\"\n    # Step 1: Preprocessing\n    mask = x >= f_min\n    x_proc = x[mask]\n    y_proc = y[mask]\n    u_proc = u[mask]\n\n    # Step 2: Initial weighted fit\n    s_initial = _weighted_fit_zero_intercept(x_proc, y_proc, u_proc)\n\n    # Step 3: One-pass robust outlier rejection\n    r = s_initial * x_proc - y_proc\n    t = r / u_proc\n    \n    median_t = np.median(t)\n    mad_t = np.median(np.abs(t - median_t))\n    sigma_rob = 1.4826 * mad_t\n    \n    # Fallback if sigma_rob is zero\n    if sigma_rob == 0:\n        sigma_rob = np.sqrt(np.mean(t**2))\n        \n    outlier_mask = np.abs(t) <= 3 * sigma_rob\n    \n    x_final = x_proc[outlier_mask]\n    y_final = y_proc[outlier_mask]\n    u_final = u_proc[outlier_mask]\n    \n    # Step 4: Refit and compute metrics\n    s_final = _weighted_fit_zero_intercept(x_final, y_final, u_final)\n    \n    n = len(x_final)\n    p = 1 # Number of fitted parameters\n    \n    if n <= p:\n         # Cannot compute uncertainty if degrees of freedom is not positive\n        return [s_final, 0.0, 0.0]\n\n    r_final = s_final * x_final - y_final\n    w_final = 1.0 / u_final**2\n    \n    # Residual Sum of Squares\n    rss = np.sum(w_final * r_final**2)\n    \n    # Scale estimate\n    sigma2_hat = rss / (n - p)\n    \n    # Standard uncertainty of the scale factor\n    sum_wx2 = np.sum(w_final * x_final**2)\n    if sum_wx2 == 0:\n        u_s = 0.0\n    else:\n        u_s = np.sqrt(sigma2_hat / sum_wx2)\n    \n    # Unweighted Root-Mean-Square Error\n    rmse = np.sqrt(np.mean(r_final**2))\n    \n    return [s_final, u_s, rmse]\n\nsolve()\n```", "id": "2894984"}]}