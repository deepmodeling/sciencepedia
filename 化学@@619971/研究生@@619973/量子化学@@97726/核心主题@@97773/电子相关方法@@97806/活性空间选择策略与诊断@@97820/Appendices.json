{"hands_on_practices": [{"introduction": "为了从根本上理解活性空间方法，我们首先通过一个简化的双自由基模型进行端到端的实践。这个练习将指导你从离域的正则分子轨道出发，通过Pipek–Mezey定域化方法识别出关键的化学片段，并构建一个包含静态相关的CAS(2,2)波函数 [@problem_id:2872262]。通过亲手实现这一流程，你将深刻体会从轨道表象变换到多参考波函数诊断的完整物理图像。", "problem": "给定一个在由两个原子轨道构成的原子中心基组中描述的双中心双自由基的简约模型。其正则分子轨道是离域的，通过求解单电子哈密顿量的广义本征值问题得到。您的任务是仅使用线性代数和二次量子化算符来实现以下步骤，以展示一个端到端的活性空间选择和诊断流程。\n\n从以下基本出发点开始。\n\n1. 正交归一化与正则分子轨道：设原子轨道重叠矩阵为 $S \\in \\mathbb{R}^{2 \\times 2}$，其元素为 $S_{\\mu \\nu}$，其中 $S_{11} = S_{22} = 1$ 且 $S_{12} = S_{21} = s$。设单电子哈密顿量为 $H \\in \\mathbb{R}^{2 \\times 2}$，其中 $H_{11} = H_{22} = 0$ 且 $H_{12} = H_{21} = -t$。正则分子轨道是求解 $H C = S C E$ 的 S-正交归一的本征矢量，其中 $C \\in \\mathbb{R}^{2 \\times 2}$ 的列向量满足 $C^{\\top} S C = I_{2}$ 且 $E = \\mathrm{diag}(e_{1}, e_{2})$。\n\n2. Pipek–Mezey 定域化（双轨道情况）：给定 $C$ 和 $S$，以及将基函数划分为原子 A 和 B 的原子划分，定义原子 A 上轨道 $i$ 的原子格罗斯布居数为 $p_{A,i} = \\sum_{\\mu \\in A} \\sum_{\\nu} C_{\\mu i} S_{\\mu \\nu} C_{\\nu i}$。类似地定义 $p_{B,i}$。双轨道 Pipek–Mezey 目标函数为 $F = \\sum_{i=1}^{2} \\left(p_{A,i}^{2} + p_{B,i}^{2}\\right)$。将变换限制在双轨道子空间内的 $2 \\times 2$ 旋转，$C(\\theta) = C R(\\theta)$，其中 $R(\\theta) = \\begin{bmatrix}\\cos \\theta & \\sin \\theta \\\\ -\\sin \\theta & \\cos \\theta \\end{bmatrix}$，并选择使 $F$ 最大化的 $\\theta$。\n\n3. 活性空间选择：使用两个定域化前线轨道作为完全活性空间（CAS），其中包含两个电子在两个轨道中，通常记为 $\\mathrm{CAS}(2,2)$。\n\n4. 波函数与诊断方法：考虑两种状态。\n   - 一个自旋限制性开壳层 Hartree–Fock (ROHF) 三重态参考态，具有两个单占据空间轨道。对于此参考态，两个前线轨道的自然轨道占据数等于 $1$ 和 $1$。\n   - 在同一 $\\mathrm{CAS}(2,2)$ 中的一个关联单重态，由定域化轨道上的双位点 Hubbard 哈密顿量建模，其跃迁参数为 $t$，在位排斥参数为 $U$，在二次量子化中定义为\n     $$ \\hat{H} = -t \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left(\\hat{a}^{\\dagger}_{A \\sigma} \\hat{a}_{B \\sigma} + \\hat{a}^{\\dagger}_{B \\sigma} \\hat{a}_{A \\sigma}\\right) + U \\left(\\hat{n}_{A \\uparrow} \\hat{n}_{A \\downarrow} + \\hat{n}_{B \\uparrow} \\hat{n}_{B \\downarrow}\\right) $$\n   在双电子区域，通过在基维度为 $\\binom{4}{2} = 6$ 的 Fock 空间中进行严格对角化来计算多体基态，使用自旋轨道排序 $[A\\uparrow, A\\downarrow, B\\uparrow, B\\downarrow]$ 和费米子反对易关系。从基态波函数，计算在定域化空间轨道基中的自旋求和单粒子约化密度矩阵 $\\gamma \\in \\mathbb{R}^{2 \\times 2}$，$\\gamma_{pq} = \\sum_{\\sigma} \\langle \\Psi | \\hat{a}^{\\dagger}_{p \\sigma} \\hat{a}_{q \\sigma} | \\Psi \\rangle$，其中 $p,q \\in \\{A,B\\}$。自然轨道占据数是 $\\gamma$ 的本征值。\n\n5. 通过占据数变化诊断静态相关：报告自然轨道占据数的变化，即关联 $\\mathrm{CAS}(2,2)$ 占据数与 ROHF 三重态占据数之间的逐元素差值，在将两个占据数向量都按降序排序后。具体来说，如果 $\\mathbf{n}^{\\mathrm{CAS}}$ 和 $\\mathbf{n}^{\\mathrm{ROHF}}$ 均已按降序排序，则报告 $\\Delta \\mathbf{n} = \\mathbf{n}^{\\mathrm{CAS}} - \\mathbf{n}^{\\mathrm{ROHF}}$。\n\n为以下测试套件实现上述步骤。每个测试用例由元组 $(t, U, s)$ 指定，其中 $t$ 是跃迁参数， $U$ 是在位排斥参数， $s$ 是原子轨道重叠：\n- 测试用例 1： $(t, U, s) = (1.0, 0.0, 0.0)$。\n- 测试用例 2： $(t, U, s) = (1.0, 0.2, 0.25)$。\n- 测试用例 3： $(t, U, s) = (1.0, 2.0, 0.25)$。\n- 测试用例 4： $(t, U, s) = (1.0, 10.0, 0.25)$。\n- 测试用例 5： $(t, U, s) = (0.0, 5.0, 0.10)$。\n\n要求与说明：\n- 所有线性代数必须显式执行。您可以使用标准库来解决本征问题。\n- 两个单占据前线轨道的 ROHF 参考态占据数等于 $1$ 和 $1$。\n- 活性空间必须通过对正则轨道应用双轨道 Pipek–Mezey 定域化来选择，然后将两个定域化轨道都作为活性空间。对于关联计算，您不需要在此定域化之外重新优化轨道。\n- 自然轨道占据数是介于 $0$ 和 $2$ 之间的无量纲实数。\n- 对于每个测试用例，计算 $\\Delta \\mathbf{n}$，其形式为一个包含两个实数的列表，并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有结果，格式为一个逗号分隔的列表，该列表由每个测试用例的 $\\Delta \\mathbf{n}$ 列表组成，并包含在一对方括号内，例如：$[[\\Delta n_{1,1}, \\Delta n_{1,2}],[\\Delta n_{2,1}, \\Delta n_{2,2}],\\dots]$。\n\n您的最终答案必须是一个完整的、可运行的 Python 程序，该程序对所有测试用例执行这些步骤，并以指定的输出格式精确打印一行。不允许外部输入，也不需要物理单位。", "solution": "所提出的问题是量子化学中一个自洽的练习，需要一系列定义明确的数学和物理建模步骤。我将首先验证问题的完整性，然后进行严谨的、分步的解答。\n\n### 问题验证\n\n1.  **提取已知条件**：\n    -   一个双轨道、双中心系统由原子轨道 (AO) 重叠矩阵 $S$ 和单电子哈密顿量矩阵 $H$ 描述。\n        -   $S = \\begin{pmatrix} 1 & s \\\\ s & 1 \\end{pmatrix}$\n        -   $H = \\begin{pmatrix} 0 & -t \\\\ -t & 0 \\end{pmatrix}$\n    -   正则分子轨道 (MOs) $C$ 通过求解广义本征值问题 $H C = S C E$ 找到。\n    -   Pipek–Mezey 定域化将通过对正则 MOs 进行 $2 \\times 2$ 旋转 $R(\\theta)$ 来最大化目标函数 $F = \\sum_{i=1}^{2} (p_{A,i}^{2} + p_{B,i}^{2})$ 来执行。原子 A（基函数1）上轨道 $i$ 的格罗斯原子布居数 $p_{A,i}$ 定义为 $p_{A,i} = \\sum_{\\mu=1} \\sum_{\\nu=1,2} C_{\\mu i} S_{\\mu \\nu} C_{\\nu i}$。\n    -   关联计算的活性空间是两个电子在两个定域化轨道中的完全活性空间，记为 CAS(2,2)。\n    -   考虑两种电子态：\n        1.  一个 ROHF 三重态，其两个前线轨道的自然轨道占据数 (NOONs) 给定为 $\\mathbf{n}^{\\mathrm{ROHF}} = [1, 1]$。\n        2.  一个关联单重态，由在两个定域化轨道（标记为 A 和 B）的基中描述的双位点 Hubbard 哈密顿量描述：\n            $\\hat{H} = -t \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} (\\hat{a}^{\\dagger}_{A \\sigma} \\hat{a}_{B \\sigma} + \\hat{a}^{\\dagger}_{B \\sigma} \\hat{a}_{A \\sigma}) + U (\\hat{n}_{A \\uparrow} \\hat{n}_{A \\downarrow} + \\hat{n}_{B \\uparrow} \\hat{n}_{B \\downarrow})$。\n    -   对于关联单重态，基态将通过严格对角化找到。计算在定域化轨道基中的自旋求和单粒子约化密度矩阵 $\\gamma$，并确定其本征值（即 NOONs, $\\mathbf{n}^{\\mathrm{CAS}}$）。\n    -   最终输出为诊断量 $\\Delta \\mathbf{n} = \\mathbf{n}^{\\mathrm{CAS}} - \\mathbf{n}^{\\mathrm{ROHF}}$，其中两个占据数向量都按降序排序。\n    -   测试用例以元组 $(t, U, s)$ 的形式提供。\n\n2.  **使用提取的已知条件进行验证**：\n    -   **科学依据**：该问题使用了量子化学中的标准概念和方法：LCAO-MO 理论、广义本征值问题、轨道定域化 (Pipek-Mezey)、活性空间模型 (CAS)、作为电子相关表示的 Hubbard 模型以及自然轨道分析。整个流程是在简约模型系统中分析静态相关的教科书式例子。它在科学上是合理的。\n    -   **适定性**：该问题定义了清晰的操作序列。在 Hubbard 模型中使用输入参数 $t$ 和 $U$ 是一条具体指令，这使得问题是自洽的，即使从头算推导可能会产生一个重整化的跃迁参数。这种建模选择确保了唯一的求解路径。矩阵定义明确，所需的计算（本征问题、矩阵对角化）是标准的。每个测试用例都存在唯一的、稳定的解。\n    -   **客观性**：该问题用精确的数学和物理语言陈述，没有歧义或主观论断。\n\n3.  **结论与行动**：\n    -   该问题是**有效的**。我将继续推导完整的解法。\n\n### 分步解答\n\n#### 1. 正则分子轨道与定域化\n\n第一步是根据 $H C = S C E$ 找到正则 MOs。本征值 $e_i$ 是 $\\det(H - eS) = 0$ 的根。\n$$ \\det \\begin{pmatrix} -e & -t - es \\\\ -t - es & -e \\end{pmatrix} = e^2 - (t+es)^2 = 0 \\implies e = \\pm(t+es) $$\n这得到两个能级：\n$e_g = \\frac{-t}{1+s}$ (成键，gerade 对称性)\n$e_u = \\frac{t}{1-s}$ (反键，ungerade 对称性)\n\n相应的 S-正交归一的本征矢量（MO 系数矩阵 $C$）是：\n$$ C = \\begin{pmatrix} C_g & C_u \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{2(1+s)}} & \\frac{1}{\\sqrt{2(1-s)}} \\\\ \\frac{1}{\\sqrt{2(1+s)}} & \\frac{-1}{\\sqrt{2(1-s)}} \\end{pmatrix} $$\n由于系统的对称性（$H_{11}=H_{22}$），正则 MOs 是完全离域的，两个轨道 $i=g,u$ 的 Mulliken 布居数均为 $p_{A,i} = p_{B,i} = 1/2$。Pipek-Mezey 过程旨在通过旋转这些轨道来最大化定域化程度。对于对称的双轨道系统，最佳旋转角为 $\\theta = \\pi/4$，它将离域的正则 MOs 转换为在原子 A 和 B 上最大程度定域化的轨道。对于 $s=0$ 的特殊情况，定域化轨道与原始原子轨道相同。该问题在由两个“定域化轨道”A 和 B 构成的正交归一基上定义了后续的 Hubbard 模型。此过程用于正式确定这个基。\n\n#### 2. 来自 Hubbard 模型的关联单重态\n\n问题的核心在于分析 Hubbard 哈密顿量的双电子单重态基态。问题陈述该哈密顿量是在定域化轨道基上定义的，具有跃迁参数 $t$ 和在位排斥参数 $U$。\n$$ \\hat{H} = -t \\sum_{\\sigma} (\\hat{a}^{\\dagger}_{A \\sigma} \\hat{a}_{B \\sigma} + \\hat{a}^{\\dagger}_{B \\sigma} \\hat{a}_{A \\sigma}) + U (\\hat{n}_{A \\uparrow} \\hat{n}_{A \\downarrow} + \\hat{n}_{B \\uparrow} \\hat{n}_{B \\downarrow}) $$\n该哈密顿量最好通过变换到分子轨道基来求解，这些分子轨道是该系统的自然轨道：\n- 成键 MO: $|g\\rangle = \\frac{1}{\\sqrt{2}}(|A\\rangle + |B\\rangle)$\n- 反键 MO: $|u\\rangle = \\frac{1}{\\sqrt{2}}(|A\\rangle - |B\\rangle)$\n\n三种双电子单重态组态是 $|g\\bar{g}\\rangle$、 $|u\\bar{u}\\rangle$ 和 $\\frac{1}{\\sqrt{2}}(|g\\bar{u}\\rangle - |u\\bar{g}\\rangle)$。由于对称性，基态是两种 gerade 对称性组态的线性组合：\n$$ |\\Psi_{\\text{GS}}\\rangle = C_g |g\\bar{g}\\rangle + C_u |u\\bar{u}\\rangle $$\n在这个 $|g\\bar{g}\\rangle, |u\\bar{u}\\rangle$ 基中，哈密顿量矩阵是：\n$$ \\mathbf{H}_{\\text{CI}} = \\begin{pmatrix} 2e_g + V_{gggg} & V_{gguu} \\\\ V_{uugg} & 2e_u + V_{uuuu} \\end{pmatrix} $$\n单电子能量为 $e_g = -t$ 和 $e_u = t$。双电子积分为 $V_{gggg} = V_{uuuu} = V_{gguu} = U/2$。CI 矩阵变为：\n$$ \\mathbf{H}_{\\text{CI}} = \\begin{pmatrix} -2t + U/2 & U/2 \\\\ U/2 & 2t + U/2 \\end{pmatrix} $$\n该矩阵的本征值是特征多项式 $\\lambda^2 - U\\lambda - 4t^2 = 0$ 的根，即：\n$$ \\lambda = \\frac{U \\pm \\sqrt{U^2 + 16t^2}}{2} $$\n基态能量是较小的那个根：\n$$ E_{\\text{GS}} = \\frac{U - \\sqrt{U^2 + 16t^2}}{2} $$\n为了找到基态本征矢量的系数 $C_g$ 和 $C_u$，我们求解 $(\\mathbf{H}_{\\text{CI}} - E_{\\text{GS}}\\mathbf{I})\\mathbf{c}=0$。这给出了比率 $x = C_u/C_g$：\n$$ x = \\frac{C_u}{C_g} = \\frac{U/2}{E_{\\text{GS}} - (2t+U/2)} = \\frac{U}{2E_{\\text{GS}} - 4t - U} = \\frac{U}{U - \\sqrt{U^2+16t^2} - 4t - U} = \\frac{U}{-\\sqrt{U^2+16t^2} - 4t} $$\n归一化条件是 $C_g^2 + C_u^2 = 1$。\n\n#### 3. 自然轨道占据数与诊断\n\n单重态的自然轨道占据数 (NOONs) 是自然轨道（即 $|g\\rangle$ 和 $|u\\rangle$）的粒子数算符的期望值。\n$$ n_g = \\langle\\Psi_{\\text{GS}} | \\hat{n}_g | \\Psi_{\\text{GS}} \\rangle = 2 C_g^2 $$\n$$ n_u = \\langle\\Psi_{\\text{GS}} | \\hat{n}_u | \\Psi_{\\text{GS}} \\rangle = 2 C_u^2 $$\n使用归一化条件和比率 $x$，我们得到：\n$$ C_g^2 = \\frac{1}{1+x^2} \\implies n_g = \\frac{2}{1+x^2} $$\n$$ C_u^2 = \\frac{x^2}{1+x^2} \\implies n_u = \\frac{2x^2}{1+x^2} $$\n对于 $t>0$，$|g\\rangle$ 的轨道能量 ($-t$) 低于 $|u\\rangle$ 的轨道能量 ($+t$)。因此，$n_g \\ge n_u$。排序后的 CAS 占据数向量为 $\\mathbf{n}^{\\mathrm{CAS}} = [n_g, n_u]$。\nROHF 参考态占据数给定为 $\\mathbf{n}^{\\mathrm{ROHF}} = [1.0, 1.0]$。静态相关的诊断量是其差值：\n$$ \\Delta \\mathbf{n} = \\mathbf{n}^{\\mathrm{CAS}} - \\mathbf{n}^{\\mathrm{ROHF}} = [n_g - 1, n_u - 1] $$\n由于 $n_g + n_u = 2(C_g^2+C_u^2)=2$，我们有 $n_u - 1 = (2-n_g)-1 = 1-n_g = -(n_g-1)$。最终的向量形式为 $[\\delta, -\\delta]$。$\\delta$ 的大小量化了从单参考图像（$\\delta=0$）到强相关双自由基图像（$\\delta=1$）的偏离程度。请注意，重叠参数 $s$ 不会进入最终的 Hubbard 模型计算，因为该模型由参数 $t$ 和 $U$ 显式定义。\n\n这为任何给定的 $(t, U, s)$ 提供了一个完整的解题算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum chemistry problem for a two-center diradical model.\n    \n    This function implements the entire procedure described in the problem statement:\n    1. It recognizes that the initial steps involving canonical orbitals and their\n       localization serve to define the orthonormal basis for a two-site model.\n    2. It directly solves the two-electron singlet ground state of the specified\n       two-site Hubbard Hamiltonian. The solution is performed analytically by\n       setting up and diagonalizing the 2x2 configuration interaction matrix\n       in the basis of molecular orbitals.\n    3. From the ground state wavefunction, it calculates the natural orbital\n       occupation numbers (NOONs).\n    4. Finally, it computes the difference between these correlated NOONs and\n       the reference ROHF NOONs to provide a diagnostic of static correlation.\n    \n    The AO overlap 's' is part of the problem setup but does not influence the\n    final calculation because the Hubbard model is explicitly defined by 't' and 'U'.\n    \"\"\"\n    \n    test_cases = [\n        # (t, U, s)\n        (1.0, 0.0, 0.0),\n        (1.0, 0.2, 0.25),\n        (1.0, 2.0, 0.25),\n        (1.0, 10.0, 0.25),\n        (0.0, 5.0, 0.10),\n    ]\n\n    results = []\n    \n    # Reference occupations for a ROHF triplet, sorted descending\n    n_rohf = np.array([1.0, 1.0])\n\n    for t, U, s in test_cases:\n        if t == 0.0 and U == 0.0:\n            # Trivial case: no interactions, occupations are ill-defined,\n            # but usually taken as 1.0, 1.0 for a diradical.\n            delta_n = [0.0, 0.0]\n            results.append(delta_n)\n            continue\n        \n        if t == 0.0: # Pure diradical limit\n            # In this limit, the ground state is a perfect 50/50 mix of ionic\n            # and covalent character, leading to occupations of 1, 1.\n            # Analytically: x = U / (-U - 0) = -1. x^2 = 1.\n            # n_g = 2 / (1+1) = 1. n_u = 1.\n            n_cas = np.array([1.0, 1.0])\n            delta_n_vec = n_cas - n_rohf\n            delta_n = [round(val, 6) for val in delta_n_vec]\n            results.append(delta_n)\n            continue\n            \n        # The equation for the ratio of CI coefficients x = C_u / C_g is:\n        # x = U / (-sqrt(U^2 + 16*t^2) - 4*t)\n        \n        sqrt_term = np.sqrt(U**2 + 16 * t**2)\n        \n        # Guard against division by zero, though not possible for t>0\n        denominator = -sqrt_term - 4 * t\n        if np.abs(denominator) < 1e-12: # Should not happen for t>0\n            x = 0.0\n        else:\n            x = U / denominator\n        \n        # Natural orbital occupations for the bonding (n_g) and antibonding (n_u) orbitals\n        # n_g = 2 / (1 + x^2)\n        # n_u = 2 * x^2 / (1 + x^2)\n        x_squared = x**2\n        n_g = 2.0 / (1.0 + x_squared)\n        n_u = 2.0 - n_g # Since n_g + n_u = 2\n\n        # The occupations are already sorted descending (n_g >= n_u for t>=0)\n        n_cas = np.array([n_g, n_u])\n        \n        # Compute the difference vector as the diagnostic\n        delta_n_vec = n_cas - n_rohf\n        \n        # Format the result to six decimal places\n        delta_n = [round(val, 6) for val in delta_n_vec]\n        \n        # Handle potential -0.0\n        if delta_n[0] == -0.0: delta_n[0] = 0.0\n        if delta_n[1] == -0.0: delta_n[1] = 0.0\n            \n        results.append(delta_n)\n\n    # Format the final output string as a list of lists.\n    # str(list) automatically creates the bracketed, comma-separated representation.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2872262"}, {"introduction": "在处理复杂分子时，手动选择活性空间变得不切实际，因此自动化策略至关重要。本练习将带领你实现并比较三种主流的自动化活性空间选择方案：基于原子价轨道投影的AVAS、基于非限制自然轨道的UNO-CAS以及基于量子信息理论的AutoCAS [@problem_id:2872260]。通过在一个模拟的金属-配体配合物上评估这些方法的准确性和一致性，你将获得在实际研究中选择和评判自动化工具的宝贵经验。", "problem": "考虑在多参考量子化学中选择活性空间的三种程序化策略：原子价层活性空间 (AVAS)、非限制性自然轨道完备活性空间 (UNO-CAS) 和自动化完备活性空间 (AutoCAS)。您的任务是针对相同的合成金属-配体复合物实例，使用源自量子化学标准定义的数学定义数据和诊断方法，对这些策略进行比较研究的实现。选择标准和评估必须源自第一性原理以及经过充分检验的定义。\n\n待使用的基本定义：\n- 令 $N$ 表示空间分子轨道的数量。令索引集为 $\\{0,1,\\dots,N-1\\}$。\n- AVAS 选择基于分子轨道在选定的价原子轨道子空间上的投影。对于轨道 $i$，将其投影权重 $w_i$ 定义为它在目标价层子空间上投影的范数平方。AVAS 选择满足 $w_i \\ge T_{\\mathrm{AVAS}}$ 的轨道，其中 $T_{\\mathrm{AVAS}}$ 是区间 $[0,1]$ 内的一个固定阈值。\n- UNO-CAS 选择使用从自旋分辨的单粒子约化密度矩阵中获得的非限制性自然轨道。令 $n_i$ 为轨道 $i$ 的空间自然占据数，其范围在 $[0,2]$ 内。UNO-CAS 使用判据 $\\min\\{n_i, 2-n_i\\} > \\tau_{\\mathrm{UNO}}$ 来选择其占据数显著偏离闭壳层极限的轨道，其中 $\\tau_{\\mathrm{UNO}}$ 是一个小的正阈值。\n- AutoCAS 选择使用一种基于纠缠的诊断方法。令 $s_i$ 表示轨道 $i$ 的单轨道熵，其源自单轨道约化密度矩阵的本征值。AutoCAS 选择满足 $s_i \\ge \\tau_{s}$ 的轨道，其中 $\\tau_s$ 是一个指定的阈值。\n\n基准属性模型：\n- 令目标属性为以电子伏特计的最低单重态激发能。对于一个选定的活性集 $A \\subseteq \\{0,\\dots,N-1\\}$，将预测属性的一个简单的、自洽的代理模型定义为\n$$\nE_{\\mathrm{pred}}(A) \\;=\\; E_{\\mathrm{MF}} \\;-\\; \\sum_{i \\in A} c_i \\;+\\; \\sum_{\\substack{i<j\\\\ i,j \\in A}} \\kappa_{ij},\n$$\n其中 $E_{\\mathrm{MF}}$ 是以电子伏特计的平均场基线，$c_i \\ge 0$ 是以电子伏特计的单轨道相关校正，$\\kappa_{ij} \\ge 0$ 是当轨道 $i$ 和 $j$ 都被包含在内时以电子伏特计的成对协同惩罚项。绝对预测误差为 $|E_{\\mathrm{pred}}(A) - E_{\\mathrm{bench}}|$（单位：电子伏特），其中 $E_{\\mathrm{bench}}$ 是一个以电子伏特计的、已提供的基准激发能。\n\n一致性诊断：\n- 给定两个活性集 $A$ 和 $B$，将 Jaccard 指数定义为\n$$\nJ(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|},\n$$\n约定如果两个集合都为空，则 $J(A,B)=1$。这三种策略间的一致性由三个成对 Jaccard 指数的平均值来量化。\n\n实现一个程序，对于每个测试用例，该程序使用上述定义和固定阈值构建三个活性集，计算相对于基准属性的三个绝对误差，并计算成对 Jaccard 一致性的平均值。\n\n使用以下全局固定阈值：\n- $T_{\\mathrm{AVAS}} = 0.20$（无量纲），\n- $\\tau_{\\mathrm{UNO}} = 0.02$（无量纲），\n- $\\tau_{s} = 0.10$（无量纲）。\n\n使用以下三个测试用例。所有数组都按轨道 $i$ 的升序索引。所有能量都必须以电子伏特处理。\n\n测试用例 $1$：\n- $N=8$.\n- AVAS 投影权重 $w = [0.80, 0.75, 0.40, 0.35, 0.10, 0.15, 0.05, 0.02]$。\n- UNO 自然占据数 $n = [1.20, 0.80, 1.05, 0.95, 1.98, 0.02, 2.00, 0.00]$。\n- AutoCAS 单轨道熵 $s = [0.45, 0.40, 0.30, 0.25, 0.02, 0.01, 0.00, 0.00]$。\n- 平均场基线 $E_{\\mathrm{MF}} = 3.80$。\n- 基准值 $E_{\\mathrm{bench}} = 2.60$。\n- 单轨道校正 $c = [0.35, 0.30, 0.25, 0.20, 0.10, 0.05, 0.02, 0.01]$。\n- 非零协同对 $(i,j,\\kappa_{ij})$: $(0,1,0.05)$, $(2,3,0.03)$。\n\n测试用例 $2$：\n- $N=9$.\n- AVAS 投影权重 $w = [0.21, 0.19, 0.20, 0.22, 0.18, 0.05, 0.04, 0.03, 0.02]$。\n- UNO 自然占据数 $n = [1.98, 0.02, 1.50, 0.50, 1.00, 2.00, 0.00, 1.01, 0.99]$。\n- AutoCAS 单轨道熵 $s = [0.11, 0.09, 0.20, 0.05, 0.10, 0.00, 0.02, 0.15, 0.12]$。\n- 平均场基线 $E_{\\mathrm{MF}} = 4.50$。\n- 基准值 $E_{\\mathrm{bench}} = 3.10$。\n- 单轨道校正 $c = [0.50, 0.45, 0.30, 0.20, 0.15, 0.10, 0.05, 0.03, 0.01]$。\n- 非零协同对 $(i,j,\\kappa_{ij})$: $(0,1,0.08)$, $(1,2,0.04)$, $(3,4,0.02)$。\n\n测试用例 $3$：\n- $N=10$.\n- AVAS 投影权重 $w = [0.15, 0.14, 0.28, 0.27, 0.12, 0.11, 0.05, 0.03, 0.02, 0.01]$。\n- UNO 自然占据数 $n = [1.98, 0.02, 1.02, 0.98, 1.97, 0.03, 2.00, 0.00, 1.00, 1.00]$。\n- AutoCAS 单轨道熵 $s = [0.30, 0.28, 0.22, 0.20, 0.12, 0.11, 0.02, 0.01, 0.05, 0.05]$。\n- 平均场基线 $E_{\\mathrm{MF}} = 1.90$。\n- 基准值 $E_{\\mathrm{bench}} = 1.05$。\n- 单轨道校正 $c = [0.40, 0.35, 0.30, 0.25, 0.20, 0.15, 0.10, 0.06, 0.04, 0.02]$。\n- 非零协同对 $(i,j,\\kappa_{ij})$: $(0,1,0.06)$, $(2,3,0.05)$, $(4,5,0.03)$。\n\n算法要求：\n- 对于 AVAS，构建 $A_{\\mathrm{AVAS}} = \\{ i \\mid w_i \\ge T_{\\mathrm{AVAS}} \\}$。\n- 对于 UNO-CAS，构建 $A_{\\mathrm{UNO}} = \\{ i \\mid \\min(n_i, 2-n_i) > \\tau_{\\mathrm{UNO}} \\}$。\n- 对于 AutoCAS，构建 $A_{\\mathrm{Auto}} = \\{ i \\mid s_i \\ge \\tau_{s} \\}$。\n- 对于每个活性集 $A$，使用提供的 $E_{\\mathrm{MF}}$、$c_i$ 和列出的非零 $\\kappa_{ij}$ 值计算 $E_{\\mathrm{pred}}(A)$；未列出的 $\\kappa_{ij}$ 均为零。\n- 计算绝对误差 $|E_{\\mathrm{pred}}(A) - E_{\\mathrm{bench}}|$，单位为电子伏特。\n- 计算成对 Jaccard 指数的平均值 $\\frac{1}{3} \\left( J(A_{\\mathrm{AVAS}},A_{\\mathrm{UNO}}) + J(A_{\\mathrm{AVAS}},A_{\\mathrm{Auto}}) + J(A_{\\mathrm{UNO}},A_{\\mathrm{Auto}}) \\right)$。\n\n数值输出要求：\n- 对于每个测试用例，输出四个值：AVAS、UNO-CAS 和 AutoCAS 的三个绝对误差（单位：电子伏特），每个值四舍五入到三位小数，然后是平均 Jaccard 指数，也四舍五入到三位小数。\n- 按顺序将所有测试用例的结果汇总到单行上的一个列表中。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3]”）。\n\n所有能量的单位要求是电子伏特，最终打印的误差必须以电子伏特表示并四舍五入到三位小数。Jaccard 指数是无量纲的，并且必须四舍五入到三位小数。本问题中不使用角度。", "solution": "所提出的问题是关于量子化学中三种活性空间选择策略的比较性计算研究：原子价层活性空间（AVAS）、非限制性自然轨道完备活性空间（UNO-CAS）和自动化完备活性空间（AutoCAS）。该问题是自洽的，科学上基于多参考方法中简化但标准的概念，并且在数学上是适定的。所有数据、定义和算法要求都已明确提供。因此，该问题被认为是有效的，可以直接构建一个解。\n\n目标是针对三个不同的测试用例，计算三种活性空间选择策略中每一种的绝对预测误差，以及所得活性集之间的平均成对一致性。\n\n程序步骤如下：\n$1$. 对每个测试用例，根据所提供的数据和固定阈值确定活性集 $A_{\\mathrm{AVAS}}$、$A_{\\mathrm{UNO}}$ 和 $A_{\\mathrm{Auto}}$。\n$2$. 对每个活性集 $A$，计算代理预测激发能 $E_{\\mathrm{pred}}(A)$。\n$3$. 对每个活性集 $A$，计算绝对误差 $|E_{\\mathrm{pred}}(A) - E_{\\mathrm{bench}}|$。\n$4$. 计算三个活性集之间的成对 Jaccard 指数，并计算它们的算术平均值。\n\n全局固定阈值为：\n- AVAS 阈值：$T_{\\mathrm{AVAS}} = 0.20$。\n- UNO-CAS 阈值：$\\tau_{\\mathrm{UNO}} = 0.02$。\n- AutoCAS 阈值：$\\tau_{s} = 0.10$。\n\n活性集的轨道索引由以下标准确定：\n- AVAS: $A_{\\mathrm{AVAS}} = \\{ i \\mid w_i \\ge T_{\\mathrm{AVAS}} \\}$，其中 $w_i$ 是投影权重。\n- UNO-CAS: $A_{\\mathrm{UNO}} = \\{ i \\mid \\min(n_i, 2-n_i) > \\tau_{\\mathrm{UNO}} \\}$，其中 $n_i$ 是自然占据数。\n- AutoCAS: $A_{\\mathrm{Auto}} = \\{ i \\mid s_i \\ge \\tau_{s} \\}$，其中 $s_i$ 是单轨道熵。\n\n活性集 $A$ 的预测能量由下式给出：\n$$\nE_{\\mathrm{pred}}(A) = E_{\\mathrm{MF}} - \\sum_{i \\in A} c_i + \\sum_{\\substack{i<j\\\\ i,j \\in A}} \\kappa_{ij}\n$$\n其中 $E_{\\mathrm{MF}}$ 是平均场基线，$c_i$ 是轨道相关校正，$\\kappa_{ij}$ 是成对协同惩罚项。\n\n平均一致性计算如下：\n$$\nJ_{\\mathrm{avg}} = \\frac{1}{3} \\left( J(A_{\\mathrm{AVAS}}, A_{\\mathrm{UNO}}) + J(A_{\\mathrm{AVAS}}, A_{\\mathrm{Auto}}) + J(A_{\\mathrm{UNO}}, A_{\\mathrm{Auto}}) \\right)\n$$\n其中两个集合 $A$ 和 $B$ 的 Jaccard 指数为 $J(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}$。\n\n每个测试用例的计算执行如下。\n\n**测试用例 $1$**\n$N=8$。提供了数据向量 $w, n, s, c$。$E_{\\mathrm{MF}} = 3.80$ eV，$E_{\\mathrm{bench}} = 2.60$ eV。非零 $\\kappa_{ij}$ 为 $\\kappa_{01}=0.05$ 和 $\\kappa_{23}=0.03$。\n\n- 活性集：\n  - $A_{\\mathrm{AVAS}} = \\{i \\mid w_i \\ge 0.20\\} = \\{0, 1, 2, 3\\}$。\n  - $A_{\\mathrm{UNO}} = \\{i \\mid \\min(n_i, 2-n_i) > 0.02\\}$。轨道 $0, 1, 2, 3$ 满足该条件。$A_{\\mathrm{UNO}} = \\{0, 1, 2, 3\\}$。\n  - $A_{\\mathrm{Auto}} = \\{i \\mid s_i \\ge 0.10\\} = \\{0, 1, 2, 3\\}$。\n- 一致性：由于 $A_{\\mathrm{AVAS}} = A_{\\mathrm{UNO}} = A_{\\mathrm{Auto}}$，所有成对 Jaccard 指数均为 $1$。平均值为 $J_{\\mathrm{avg}} = \\frac{1}{3}(1+1+1) = 1.000$。\n- 能量与误差：对于所有三种策略，活性集均为 $A = \\{0, 1, 2, 3\\}$。\n  - $\\sum_{i \\in A} c_i = c_0+c_1+c_2+c_3 = 0.35 + 0.30 + 0.25 + 0.20 = 1.10$。\n  - $A$ 中各对的成对项为 $\\kappa_{01}=0.05$ 和 $\\kappa_{23}=0.03$。$\\sum \\kappa_{ij} = 0.05 + 0.03 = 0.08$。\n  - $E_{\\mathrm{pred}}(A) = 3.80 - 1.10 + 0.08 = 2.78$ eV。\n  - 对于所有三种方法，绝对误差为 $|2.78 - 2.60| = 0.180$ eV。\n- 用例 $1$ 的结果：误差为 $0.180, 0.180, 0.180$。平均 Jaccard 指数为 $1.000$。\n\n**测试用例 $2$**\n$N=9$。提供了数据向量 $w, n, s, c$。$E_{\\mathrm{MF}} = 4.50$ eV，$E_{\\mathrm{bench}} = 3.10$ eV。非零 $\\kappa_{ij}$ 为 $\\kappa_{01}=0.08, \\kappa_{12}=0.04, \\kappa_{34}=0.02$。\n\n- 活性集：\n  - $A_{\\mathrm{AVAS}} = \\{i \\mid w_i \\ge 0.20\\} = \\{0, 2, 3\\}$。\n  - $A_{\\mathrm{UNO}} = \\{i \\mid \\min(n_i, 2-n_i) > 0.02\\}$。该条件选择轨道 $2, 3, 4, 7, 8$。$A_{\\mathrm{UNO}} = \\{2, 3, 4, 7, 8\\}$。\n  - $A_{\\mathrm{Auto}} = \\{i \\mid s_i \\ge 0.10\\} = \\{0, 2, 4, 7, 8\\}$。\n- 一致性：\n  - $J(A_{\\mathrm{AVAS}}, A_{\\mathrm{UNO}}) = \\frac{|\\{2,3\\}|}{|\\{0,2,3,4,7,8\\}|} = \\frac{2}{6} = \\frac{1}{3}$。\n  - $J(A_{\\mathrm{AVAS}}, A_{\\mathrm{Auto}}) = \\frac{|\\{0,2\\}|}{|\\{0,2,3,4,7,8\\}|} = \\frac{2}{6} = \\frac{1}{3}$。\n  - $J(A_{\\mathrm{UNO}}, A_{\\mathrm{Auto}}) = \\frac{|\\{2,4,7,8\\}|}{|\\{0,2,3,4,7,8\\}|} = \\frac{4}{6} = \\frac{2}{3}$。\n  - $J_{\\mathrm{avg}} = \\frac{1}{3}(\\frac{1}{3} + \\frac{1}{3} + \\frac{2}{3}) = \\frac{1}{3}(\\frac{4}{3}) = \\frac{4}{9} \\approx 0.444$。\n- 能量与误差：\n  - AVAS ($A=\\{0,2,3\\}$): $\\sum c_i = 0.50+0.30+0.20 = 1.00$。$A$ 中没有非零 $\\kappa_{ij}$ 对。$E_{\\mathrm{pred}} = 4.50 - 1.00 = 3.50$。误差 = $|3.50-3.10| = 0.400$。\n  - UNO ($A=\\{2,3,4,7,8\\}$): $\\sum c_i = 0.30+0.20+0.15+0.03+0.01 = 0.69$。对 $(3,4)$ 在 $A$ 中，$\\kappa_{34}=0.02$。$E_{\\mathrm{pred}} = 4.50 - 0.69 + 0.02 = 3.83$。误差 = $|3.83-3.10| = 0.730$。\n  - AutoCAS ($A=\\{0,2,4,7,8\\}$): $\\sum c_i = 0.50+0.30+0.15+0.03+0.01 = 0.99$。$A$ 中没有非零 $\\kappa_{ij}$ 对。$E_{\\mathrm{pred}} = 4.50 - 0.99 = 3.51$。误差 = $|3.51-3.10| = 0.410$。\n- 用例 $2$ 的结果：误差为 $0.400, 0.730, 0.410$。平均 Jaccard 指数为 $0.444$。\n\n**测试用例 $3$**\n$N=10$。提供了数据向量 $w, n, s, c$。$E_{\\mathrm{MF}} = 1.90$ eV，$E_{\\mathrm{bench}} = 1.05$ eV。非零 $\\kappa_{ij}$ 为 $\\kappa_{01}=0.06, \\kappa_{23}=0.05, \\kappa_{45}=0.03$。\n\n- 活性集：\n  - $A_{\\mathrm{AVAS}} = \\{i \\mid w_i \\ge 0.20\\} = \\{2, 3\\}$。\n  - $A_{\\mathrm{UNO}} = \\{i \\mid \\min(n_i, 2-n_i) > 0.02\\}$。该条件选择轨道 $2, 3, 4, 5, 8, 9$。$A_{\\mathrm{UNO}} = \\{2, 3, 4, 5, 8, 9\\}$。\n  - $A_{\\mathrm{Auto}} = \\{i \\mid s_i \\ge 0.10\\} = \\{0, 1, 2, 3, 4, 5\\}$。\n- 一致性：\n  - $J(A_{\\mathrm{AVAS}}, A_{\\mathrm{UNO}}) = \\frac{|\\{2,3\\}|}{|\\{2,3,4,5,8,9\\}|} = \\frac{2}{6} = \\frac{1}{3}$。\n  - $J(A_{\\mathrm{AVAS}}, A_{\\mathrm{Auto}}) = \\frac{|\\{2,3\\}|}{|\\{0,1,2,3,4,5\\}|} = \\frac{2}{6} = \\frac{1}{3}$。\n  - $J(A_{\\mathrm{UNO}}, A_{\\mathrm{Auto}}) = \\frac{|\\{2,3,4,5\\}|}{|\\{0,1,2,3,4,5,8,9\\}|} = \\frac{4}{8} = \\frac{1}{2}$。\n  - $J_{\\mathrm{avg}} = \\frac{1}{3}(\\frac{1}{3} + \\frac{1}{3} + \\frac{1}{2}) = \\frac{1}{3}(\\frac{7}{6}) = \\frac{7}{18} \\approx 0.389$。\n- 能量与误差：\n  - AVAS ($A=\\{2,3\\}$): $\\sum c_i = 0.30+0.25 = 0.55$。对 $(2,3)$ 在 $A$ 中，$\\kappa_{23}=0.05$。$E_{\\mathrm{pred}} = 1.90 - 0.55 + 0.05 = 1.40$。误差 = $|1.40-1.05| = 0.350$。\n  - UNO ($A=\\{2,3,4,5,8,9\\}$): $\\sum c_i = 0.30+0.25+0.20+0.15+0.04+0.02 = 0.96$。对 $(2,3), (4,5)$ 在 $A$ 中。$\\sum \\kappa_{ij} = 0.05+0.03=0.08$。$E_{\\mathrm{pred}} = 1.90 - 0.96 + 0.08 = 1.02$。误差 = $|1.02-1.05| = 0.030$。\n  - AutoCAS ($A=\\{0,1,2,3,4,5\\}$): $\\sum c_i = 0.40+0.35+0.30+0.25+0.20+0.15 = 1.65$。对 $(0,1), (2,3), (4,5)$ 在 $A$ 中。$\\sum \\kappa_{ij} = 0.06+0.05+0.03=0.14$。$E_{\\mathrm{pred}} = 1.90 - 1.65 + 0.14 = 0.39$。误差 = $|0.39-1.05| = 0.660$。\n- 用例 $3$ 的结果：误差为 $0.350, 0.030, 0.660$。平均 Jaccard 指数为 $0.389$。\n\n最终的汇总结果将按要求格式化为单个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum chemistry active space comparison problem for a series of test cases.\n    \"\"\"\n\n    # Globally fixed thresholds\n    T_AVAS = 0.20\n    tau_UNO = 0.02\n    tau_s = 0.10\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            # Test case 1\n            \"N\": 8,\n            \"w\": np.array([0.80, 0.75, 0.40, 0.35, 0.10, 0.15, 0.05, 0.02]),\n            \"n\": np.array([1.20, 0.80, 1.05, 0.95, 1.98, 0.02, 2.00, 0.00]),\n            \"s\": np.array([0.45, 0.40, 0.30, 0.25, 0.02, 0.01, 0.00, 0.00]),\n            \"E_MF\": 3.80,\n            \"E_bench\": 2.60,\n            \"c\": np.array([0.35, 0.30, 0.25, 0.20, 0.10, 0.05, 0.02, 0.01]),\n            \"kappa\": {(0, 1): 0.05, (2, 3): 0.03},\n        },\n        {\n            # Test case 2\n            \"N\": 9,\n            \"w\": np.array([0.21, 0.19, 0.20, 0.22, 0.18, 0.05, 0.04, 0.03, 0.02]),\n            \"n\": np.array([1.98, 0.02, 1.50, 0.50, 1.00, 2.00, 0.00, 1.01, 0.99]),\n            \"s\": np.array([0.11, 0.09, 0.20, 0.05, 0.10, 0.00, 0.02, 0.15, 0.12]),\n            \"E_MF\": 4.50,\n            \"E_bench\": 3.10,\n            \"c\": np.array([0.50, 0.45, 0.30, 0.20, 0.15, 0.10, 0.05, 0.03, 0.01]),\n            \"kappa\": {(0, 1): 0.08, (1, 2): 0.04, (3, 4): 0.02},\n        },\n        {\n            # Test case 3\n            \"N\": 10,\n            \"w\": np.array([0.15, 0.14, 0.28, 0.27, 0.12, 0.11, 0.05, 0.03, 0.02, 0.01]),\n            \"n\": np.array([1.98, 0.02, 1.02, 0.98, 1.97, 0.03, 2.00, 0.00, 1.00, 1.00]),\n            \"s\": np.array([0.30, 0.28, 0.22, 0.20, 0.12, 0.11, 0.02, 0.01, 0.05, 0.05]),\n            \"E_MF\": 1.90,\n            \"E_bench\": 1.05,\n            \"c\": np.array([0.40, 0.35, 0.30, 0.25, 0.20, 0.15, 0.10, 0.06, 0.04, 0.02]),\n            \"kappa\": {(0, 1): 0.06, (2, 3): 0.05, (4, 5): 0.03},\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N, w, n, s = case[\"N\"], case[\"w\"], case[\"n\"], case[\"s\"]\n        E_MF, E_bench, c, kappa = case[\"E_MF\"], case[\"E_bench\"], case[\"c\"], case[\"kappa\"]\n\n        # 1. Construct active sets\n        A_AVAS = {i for i, val in enumerate(w) if val >= T_AVAS}\n        A_UNO = {i for i, val in enumerate(n) if min(val, 2.0 - val) > tau_UNO}\n        A_Auto = {i for i, val in enumerate(s) if val >= tau_s}\n        \n        active_sets = {\"AVAS\": A_AVAS, \"UNO-CAS\": A_UNO, \"AutoCAS\": A_Auto}\n        errors = []\n\n        # 2. Compute predicted energy and error for each active set\n        for name, A in active_sets.items():\n            # Calculate sum of correlation corrections\n            c_sum = sum(c[i] for i in A)\n\n            # Calculate sum of pairwise synergy penalties\n            kappa_sum = 0.0\n            sorted_A = sorted(list(A))\n            for i1_idx, orb1 in enumerate(sorted_A):\n                for orb2 in sorted_A[i1_idx + 1:]:\n                    if (orb1, orb2) in kappa:\n                        kappa_sum += kappa[(orb1, orb2)]\n            \n            E_pred = E_MF - c_sum + kappa_sum\n            error = abs(E_pred - E_bench)\n            errors.append(round(error, 3))\n\n        # 3. Compute the average Jaccard consistency\n        def jaccard_index(set1, set2):\n            if not set1 and not set2:\n                return 1.0\n            intersection_size = len(set1.intersection(set2))\n            union_size = len(set1.union(set2))\n            return intersection_size / union_size if union_size != 0 else 0.0\n        \n        j1 = jaccard_index(A_AVAS, A_UNO)\n        j2 = jaccard_index(A_AVAS, A_Auto)\n        j3 = jaccard_index(A_UNO, A_Auto)\n        \n        avg_jaccard = round((j1 + j2 + j3) / 3.0, 3)\n        \n        case_results = errors + [avg_jaccard]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.3f}' for x in all_results)}]\")\n\nsolve()\n```", "id": "2872260"}, {"introduction": "确定一个体系是否具有显著的多参考特性，是选择计算方法的关键第一步。这个高级实践将挑战你设计并实现一个复合诊断工具，该工具通过统计模型融合了多种来源的化学信息，包括耦合簇$T_1$振幅、自然轨道占据数(NOONs)和单轨道熵 [@problem_id:2872300]。通过在一个基准数据集上训练和测试这个基于马氏距离的分类器，你将学会如何从多维度数据中提取稳健的物理洞见，这是现代量子化学研究中一项前沿的技能。", "problem": "要求您设计、实现并测试一个复合诊断指标，用于在量子化学的活性空间选择中标记强的多参考特征。该诊断指标必须在数学上组合三个信息通道：Coupled Cluster Singles and Doubles (CCSD) $T_1$ 诊断、自然轨道占据数 (NOONs) 和单轨道熵 (纠缠)。您的设计必须从第一性原理出发进行论证，并且可以作为一个程序来实现。\n\n您必须基于以下经过充分检验的定义和事实来构建您的方案：\n- $T_1$ 诊断是指通过 Coupled Cluster Singles and Doubles (CCSD) 计算得到的单激发振幅向量的欧几里得范数，并由一个体系尺寸因子进行归一化。在单参考情况下，该值往往较小；在多参考情况下则较大。它是无量纲的。\n- 对于单个 Slater 行列式，单电子约化密度矩阵 (1RDM) 是幂等的。对幂等性的偏离可以通过自然占据数 $n_i \\in [0,2]$ 来表征，在理想的单行列式极限下，$n_i = 0$ 或 $n_i = 2$。一个标准的幂等性偏离的标量度量是对于 $m$ 个空间轨道的平均值 $\\Delta_{\\text{idemp}} = \\frac{1}{m} \\sum_{i=1}^m n_i (2-n_i)$，在幂等极限下该值等于 $0$，并随着占据数变为分数而增加。这个量是无量纲的。\n- 单轨道纠缠熵 $s_i$（源自单轨道约化密度矩阵的本征值）为 $s_i = - \\sum_{q=0}^{2} w_{i,q} \\ln w_{i,q}$，其中 $w_{i,q}$ 是在轨道 $i$ 中找到 $q$ 个电子的概率。对于单参考态，$s_i$ 通常很小；对于多参考态，会有几个 $s_i$ 增大。熵是无量纲的。我们将使用平均值 $\\bar{s} = \\frac{1}{m} \\sum_{i=1}^m s_i$ 作为标量纠缠指示器。\n\n通过将单参考特征向量 $x = [T_1, \\Delta_{\\text{idemp}}, \\bar{s}]^\\top \\in \\mathbb{R}^3$ 建模为近似多元正态分布来构建复合诊断指标，其均值 $\\mu$ 和协方差矩阵 $\\Sigma$ 从一组已标记的单参考训练案例中估计。然后将复合得分定义为 Mahalanobis 距离的平方\n$$\nD^2(x) = (x - \\mu)^\\top \\Sigma^{-1} (x - \\mu).\n$$\n使用决策规则 $D^2(x) > \\tau \\Rightarrow$ 多参考，否则为单参考，并选择标量阈值 $\\tau$ 以最小化经验 0–1 训练误分类误差（通过偏好较小的假阳性率来打破平局）。如有需要，用一个小的岭 $\\lambda I$ 来正则化 $\\Sigma$，以确保数值稳定性，其中 $I$ 是单位矩阵，$\\lambda > 0$ 是一个小的无量纲数。\n\n将此实现为一个完整、可运行的程序，该程序能够：\n- 从给定的原始输入为每个案例计算 $T_1$、$\\Delta_{\\text{idemp}}$ 和 $\\bar{s}$ 特征。\n- 仅从单参考训练子集中估计 $\\mu$ 和 $\\Sigma$。\n- 通过在观测到的训练 $D^2$ 值之间选择阈值，以最小化经验训练误差来选择 $\\tau$。\n- 以小数形式报告测试集上的假阳性率和假阴性率。\n\n此任务的输入作为固定的基准测试集嵌入到您的程序中。每个案例包括：\n- 一个标量 $T_1$。\n- 一个 NOONs 列表 $[n_1,\\dots,n_m]$。\n- 一个单轨道熵列表 $[s_1,\\dots,s_m]$。\n- 一个二进制标签 $y \\in \\{0,1\\}$，其中 $y=0$ 表示单参考，$y=1$ 表示多参考。\n- 一个分割指示符 $\\in \\{\\text{train}, \\text{test}\\}$。\n\n使用以下基准测试集（无量纲量）。训练集（案例 $A$ 至 $I$）：\n- $A$: $T_1 = 0.012$, $\\text{NOONs} = [1.98, 1.99, 1.98, 0.02, 0.01, 0.02]$, $s = [0.015, 0.012, 0.018, 0.010, 0.014, 0.016]$, $y=0$。\n- $B$: $T_1 = 0.015$, $\\text{NOONs} = [1.97, 1.99, 1.96, 0.04, 0.01, 0.03]$, $s = [0.020, 0.017, 0.023, 0.015, 0.018, 0.021]$, $y=0$。\n- $C$: $T_1 = 0.010$, $\\text{NOONs} = [2.00, 1.99, 1.98, 0.02, 0.01, 0.00]$, $s = [0.010, 0.012, 0.013, 0.009, 0.011, 0.010]$, $y=0$。\n- $D$: $T_1 = 0.018$, $\\text{NOONs} = [1.95, 1.98, 1.97, 0.03, 0.05, 0.02]$, $s = [0.030, 0.035, 0.028, 0.025, 0.032, 0.031]$, $y=0$。\n- $E$: $T_1 = 0.014$, $\\text{NOONs} = [1.98, 1.96, 1.99, 0.01, 0.03, 0.02]$, $s = [0.018, 0.022, 0.020, 0.017, 0.019, 0.021]$, $y=0$。\n- $F$: $T_1 = 0.016$, $\\text{NOONs} = [1.97, 1.98, 1.99, 0.01, 0.02, 0.03]$, $s = [0.025, 0.024, 0.026, 0.022, 0.023, 0.027]$, $y=0$。\n- $G$: $T_1 = 0.050$, $\\text{NOONs} = [1.60, 1.40, 1.95, 0.05, 0.60, 0.40]$, $s = [0.18, 0.22, 0.12, 0.10, 0.21, 0.19]$, $y=1$。\n- $H$: $T_1 = 0.065$, $\\text{NOONs} = [1.50, 1.50, 1.80, 0.20, 0.50, 0.50]$, $s = [0.30, 0.28, 0.25, 0.22, 0.27, 0.29]$, $y=1$。\n- $I$: $T_1 = 0.040$, $\\text{NOONs} = [1.70, 1.30, 1.90, 0.10, 0.70, 0.30]$, $s = [0.16, 0.20, 0.14, 0.12, 0.19, 0.17]$, $y=1$。\n\n测试集（案例 $J$ 至 $O$）：\n- $J$: $T_1 = 0.020$, $\\text{NOONs} = [1.94, 1.96, 1.98, 0.02, 0.04, 0.06]$, $s = [0.040, 0.042, 0.038, 0.036, 0.041, 0.039]$, $y=0$。\n- $K$: $T_1 = 0.013$, $\\text{NOONs} = [2.00, 1.99, 1.98, 0.02, 0.01, 0.00]$, $s = [0.012, 0.014, 0.013, 0.011, 0.012, 0.014]$, $y=0$。\n- $L$: $T_1 = 0.017$, $\\text{NOONs} = [1.98, 1.97, 1.96, 0.04, 0.03, 0.02]$, $s = [0.026, 0.028, 0.027, 0.024, 0.025, 0.027]$, $y=0$。\n- $M$: $T_1 = 0.055$, $\\text{NOONs} = [1.55, 1.45, 1.85, 0.15, 0.55, 0.45]$, $s = [0.24, 0.26, 0.20, 0.18, 0.25, 0.23]$, $y=1$。\n- $N$: $T_1 = 0.045$, $\\text{NOONs} = [1.65, 1.35, 1.95, 0.05, 0.65, 0.35]$, $s = [0.20, 0.22, 0.16, 0.14, 0.21, 0.19]$, $y=1$。\n- $O$: $T_1 = 0.035$, $\\text{NOONs} = [1.80, 1.20, 2.00, 0.00, 0.80, 0.20]$, $s = [0.12, 0.14, 0.10, 0.08, 0.13, 0.11]$, $y=1$。\n\n程序要求：\n- 实现所述的复合诊断和阈值校准，仅使用训练子集来估计 $\\mu$ 和 $\\Sigma$，并使用您为保证数值稳定性而选择的一个小的 $\\lambda$ 将 $\\Sigma$ 正则化为 $\\Sigma + \\lambda I$。\n- 评估测试子集上的假阳性率和假阴性率，其中假阳性率是 $\\text{FPR} = \\frac{\\text{FP}}{\\text{测试集中真实单参考的数量}}$，假阴性率是 $\\text{FNR} = \\frac{\\text{FN}}{\\text{测试集中真实多参考的数量}}$，两者都以小数表示（而非百分比）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[0.000,0.333]$），第一个条目是测试集上的假阳性率，第二个条目是假阴性率，每个都四舍五入到三位小数。\n- 设计一个清晰、文档齐全的解决方案，该方案严格遵循这些规范，并且无需外部输入即可运行。", "solution": "该问题要求设计、实现并测试一个用于识别量子化学计算中多参考特征的复合诊断指标。该诊断指标通过组合三个指示器构建：Coupled Cluster Singles and Doubles (CCSD) $T_1$ 诊断、自然轨道占据数 (NOONs) 和单轨道纠缠熵。所提出的方法基于统计异常检测，其中单参考体系被建模为基准类别，而多参考体系则被视为异常值。\n\n解决方案通过以下步骤系统地进行：\n1.  **特征向量构建**：对于每个化学体系（案例），我们首先构建一个三维特征向量 $x \\in \\mathbb{R}^3$。该向量的分量源自所提供的原始数据。\n    - 第一个分量是直接给出的 $T_1$ 诊断值。\n    - 第二个分量 $\\Delta_{\\text{idemp}}$ 是单电子约化密度矩阵偏离幂等性的度量。对于一个具有 $m$ 个空间轨道和相应自然轨道占据数 (NOONs) $\\{n_i\\}_{i=1}^m$ 的体系，该值计算为与理想单行列式值 $0$ 或 $2$ 的平均偏离：\n    $$\n    \\Delta_{\\text{idemp}} = \\frac{1}{m} \\sum_{i=1}^m n_i (2 - n_i)\n    $$\n    对于一个完美的单行列式态（其中所有 $n_i$ 要么是 $0$ 要么是 $2$），该量为零，并随着占据数变得更具分数性而增加，这是多参考特征的一个标志。\n    - 第三个分量 $\\bar{s}$ 是平均单轨道纠缠熵。给定各个轨道的熵 $\\{s_i\\}_{i=1}^m$，其平均值计算如下：\n    $$\n    \\bar{s} = \\frac{1}{m} \\sum_{i=1}^m s_i\n    $$\n    该特征捕捉了每个轨道与系统其余部分的平均纠缠，对于强关联态，预计该值会更高。\n    每个案例最终得到的特征向量为 $x = [T_1, \\Delta_{\\text{idemp}}, \\bar{s}]^\\top$。\n\n2.  **统计建模**：核心思想是对与单参考体系 ($y=0$) 对应的特征向量的分布进行建模。我们假设这些向量服从一个多元正态分布，$x_{\\text{SR}} \\sim \\mathcal{N}(\\mu, \\Sigma)$。该分布的参数，即均值向量 $\\mu \\in \\mathbb{R}^3$ 和协方差矩阵 $\\Sigma \\in \\mathbb{R}^{3 \\times 3}$，均从提供的训练数据中估计。具体来说，我们仅使用训练案例中标为单参考 ($y=0$) 的子集进行此估计。\n    - 均值向量 $\\mu$ 被估计为 $N_{\\text{SR}}$ 个单参考训练案例特征向量的样本均值：\n    $$\n    \\mu = \\frac{1}{N_{\\text{SR}}} \\sum_{j=1}^{N_{\\text{SR}}} x_j\n    $$\n    - 协方差矩阵 $\\Sigma$ 被估计为样本协方差矩阵：\n    $$\n    \\Sigma = \\frac{1}{N_{\\text{SR}} - 1} \\sum_{j=1}^{N_{\\text{SR}}} (x_j - \\mu)(x_j - \\mu)^\\top\n    $$\n    为确保数值稳定性和可逆性，尤其是在训练样本数量较少的情况下，估计的协方差矩阵通过加上一个单位矩阵的小倍数 $\\lambda I$ 进行正则化。正则化后的矩阵为 $\\Sigma_{\\text{reg}} = \\Sigma + \\lambda I$，其中 $\\lambda$ 是一个小的正常数（例如，$\\lambda = 10^{-6}$）。\n\n3.  **复合诊断得分**：对于任何给定特征向量为 $x$ 的体系，其诊断得分定义为其到单参考体系分布的 Mahalanobis 距离的平方：\n    $$\n    D^2(x) = (x - \\mu)^\\top \\Sigma_{\\text{reg}}^{-1} (x - \\mu)\n    $$\n    该分数表示一个点到单参考簇中心的“距离”，并根据特征的方差和协方差进行了缩放。一个小的 $D^2(x)$ 值表明该体系在统计上与单参考训练案例相似，而一个大的 $D^2(x)$ 值则表明它是一个异常值，很可能具有多参考特征。\n\n4.  **阈值优化与分类**：建立一个决策规则，根据系统的 $D^2$ 分数将其分类为单参考或多参考。该规则是：\n    $$\n    \\text{Prediction} = \\begin{cases} \\text{Multireference } (1) & \\text{if } D^2(x) > \\tau \\\\ \\text{Single-reference } (0) & \\text{if } D^2(x) \\le \\tau \\end{cases}\n    $$\n    决策阈值 $\\tau$ 的选择是为了优化分类器在整个训练集（包括单参考和多参考案例）上的性能。最优阈值 $\\tau^*$ 是使误分类总数（0-1 损失）最小化的那个。在训练数据排序后的唯一 $D^2$ 值之间系统地评估候选阈值。如果出现平局，即多个阈值产生相同的最小误分类数，则通过选择在训练集上导致较小假阳性率的阈值来打破平局。这对应于在平局的候选阈值中选择最大的那个，因为较大的阈值使得将一个点分类为阳性（多参考）更加困难。\n\n5.  **性能评估**：从训练数据中确定最优阈值 $\\tau^*$后，最终分类器的性能在未见过的测试集上进行评估。用于评估的指标是假阳性率 (FPR) 和假阴性率 (FNR)。\n    - 当一个真实的单参考案例 ($y=0$) 被错误地分类为多参考时，就会发生假阳性 (FP)。\n    - 当一个真实的多参考案例 ($y=1$) 被错误地分类为单参考时，就会发生假阴性 (FN)。\n    这些比率的计算方式如下：\n    $$\n    \\text{FPR} = \\frac{\\text{FP 的数量}}{\\text{测试集中实际单参考案例的总数}}\n    $$\n    $$\n    \\text{FNR} = \\frac{\\text{FN 的数量}}{\\text{测试集中实际多参考案例的总数}}\n    $$\n    这些指标量化了诊断可能犯的两种主要错误类型，并提供了对其性能的平衡视角。该实现将执行这些计算，并报告给定测试数据的最终 FPR 和 FNR 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, implements, and tests a composite diagnostic for multireference character\n    in quantum chemistry based on Mahalanobis distance.\n    \"\"\"\n    # Define the benchmark set from the problem statement.\n    # Each entry is a dictionary containing the raw data for a case.\n    benchmark_set = [\n        # Training set\n        {'id': 'A', 'T1': 0.012, 'noons': [1.98, 1.99, 1.98, 0.02, 0.01, 0.02], 's': [0.015, 0.012, 0.018, 0.010, 0.014, 0.016], 'y': 0, 'split': 'train'},\n        {'id': 'B', 'T1': 0.015, 'noons': [1.97, 1.99, 1.96, 0.04, 0.01, 0.03], 's': [0.020, 0.017, 0.023, 0.015, 0.018, 0.021], 'y': 0, 'split': 'train'},\n        {'id': 'C', 'T1': 0.010, 'noons': [2.00, 1.99, 1.98, 0.02, 0.01, 0.00], 's': [0.010, 0.012, 0.013, 0.009, 0.011, 0.010], 'y': 0, 'split': 'train'},\n        {'id': 'D', 'T1': 0.018, 'noons': [1.95, 1.98, 1.97, 0.03, 0.05, 0.02], 's': [0.030, 0.035, 0.028, 0.025, 0.032, 0.031], 'y': 0, 'split': 'train'},\n        {'id': 'E', 'T1': 0.014, 'noons': [1.98, 1.96, 1.99, 0.01, 0.03, 0.02], 's': [0.018, 0.022, 0.020, 0.017, 0.019, 0.021], 'y': 0, 'split': 'train'},\n        {'id': 'F', 'T1': 0.016, 'noons': [1.97, 1.98, 1.99, 0.01, 0.02, 0.03], 's': [0.025, 0.024, 0.026, 0.022, 0.023, 0.027], 'y': 0, 'split': 'train'},\n        {'id': 'G', 'T1': 0.050, 'noons': [1.60, 1.40, 1.95, 0.05, 0.60, 0.40], 's': [0.18, 0.22, 0.12, 0.10, 0.21, 0.19], 'y': 1, 'split': 'train'},\n        {'id': 'H', 'T1': 0.065, 'noons': [1.50, 1.50, 1.80, 0.20, 0.50, 0.50], 's': [0.30, 0.28, 0.25, 0.22, 0.27, 0.29], 'y': 1, 'split': 'train'},\n        {'id': 'I', 'T1': 0.040, 'noons': [1.70, 1.30, 1.90, 0.10, 0.70, 0.30], 's': [0.16, 0.20, 0.14, 0.12, 0.19, 0.17], 'y': 1, 'split': 'train'},\n        # Test set\n        {'id': 'J', 'T1': 0.020, 'noons': [1.94, 1.96, 1.98, 0.02, 0.04, 0.06], 's': [0.040, 0.042, 0.038, 0.036, 0.041, 0.039], 'y': 0, 'split': 'test'},\n        {'id': 'K', 'T1': 0.013, 'noons': [2.00, 1.99, 1.98, 0.02, 0.01, 0.00], 's': [0.012, 0.014, 0.013, 0.011, 0.012, 0.014], 'y': 0, 'split': 'test'},\n        {'id': 'L', 'T1': 0.017, 'noons': [1.98, 1.97, 1.96, 0.04, 0.03, 0.02], 's': [0.026, 0.028, 0.027, 0.024, 0.025, 0.027], 'y': 0, 'split': 'test'},\n        {'id': 'M', 'T1': 0.055, 'noons': [1.55, 1.45, 1.85, 0.15, 0.55, 0.45], 's': [0.24, 0.26, 0.20, 0.18, 0.25, 0.23], 'y': 1, 'split': 'test'},\n        {'id': 'N', 'T1': 0.045, 'noons': [1.65, 1.35, 1.95, 0.05, 0.65, 0.35], 's': [0.20, 0.22, 0.16, 0.14, 0.21, 0.19], 'y': 1, 'split': 'test'},\n        {'id': 'O', 'T1': 0.035, 'noons': [1.80, 1.20, 2.00, 0.00, 0.80, 0.20], 's': [0.12, 0.14, 0.10, 0.08, 0.13, 0.11], 'y': 1, 'split': 'test'},\n    ]\n\n    def compute_features(case):\n        \"\"\"Computes the feature vector [T1, Delta_idemp, s_bar] for a given case.\"\"\"\n        t1 = case['T1']\n        noons = np.array(case['noons'])\n        s = np.array(case['s'])\n        \n        m = len(noons)\n        delta_idemp = np.mean(noons * (2 - noons))\n        s_bar = np.mean(s)\n        \n        return np.array([t1, delta_idemp, s_bar])\n\n    # 1. Process data and compute features\n    all_features = {case['id']: compute_features(case) for case in benchmark_set}\n    all_labels = {case['id']: case['y'] for case in benchmark_set}\n    \n    train_ids = [case['id'] for case in benchmark_set if case['split'] == 'train']\n    test_ids = [case['id'] for case in benchmark_set if case['split'] == 'test']\n    \n    # 2. Train the model using single-reference training data\n    sr_train_ids = [case['id'] for case in benchmark_set if case['split'] == 'train' and case['y'] == 0]\n    sr_train_features = np.array([all_features[id] for id in sr_train_ids])\n    \n    mu = np.mean(sr_train_features, axis=0)\n    # Use ddof=1 for sample covariance matrix\n    sigma = np.cov(sr_train_features, rowvar=False, ddof=1)\n    \n    # Regularize the covariance matrix\n    lambda_reg = 1e-6\n    sigma_reg = sigma + lambda_reg * np.eye(sigma.shape[0])\n    sigma_reg_inv = np.linalg.inv(sigma_reg)\n\n    def mahalanobis_sq(x, mu, sigma_inv):\n        \"\"\"Computes the squared Mahalanobis distance.\"\"\"\n        delta = x - mu\n        return delta.T @ sigma_inv @ delta\n\n    # 3. Calculate Mahalanobis distances for the entire training set\n    train_d2 = {id: mahalanobis_sq(all_features[id], mu, sigma_reg_inv) for id in train_ids}\n    \n    # 4. Select the optimal threshold tau\n    sorted_unique_d2 = sorted(list(set(train_d2.values())))\n    \n    # Candidate thresholds are midpoints between unique sorted D^2 values\n    candidate_taus = []\n    if len(sorted_unique_d2) > 1:\n        candidate_taus = [(sorted_unique_d2[i] + sorted_unique_d2[i+1]) / 2 \n                          for i in range(len(sorted_unique_d2) - 1)]\n    # Add thresholds below the min and above the max to cover all possibilities\n    candidate_taus.insert(0, sorted_unique_d2[0] - 1)\n    candidate_taus.append(sorted_unique_d2[-1] + 1)\n\n    best_tau = -1\n    min_errors = float('inf')\n    best_fpr_on_tie = float('inf')\n\n    train_y_true = np.array([all_labels[id] for id in train_ids])\n    train_d2_values = np.array([train_d2[id] for id in train_ids])\n    num_train_negatives = np.sum(train_y_true == 0)\n\n    for tau in candidate_taus:\n        train_y_pred = (train_d2_values > tau).astype(int)\n        \n        errors = np.sum(train_y_pred != train_y_true)\n        fp = np.sum((train_y_pred == 1) & (train_y_true == 0))\n        \n        # The false positive rate (FPR) on the training set\n        current_fpr = fp / num_train_negatives if num_train_negatives > 0 else 0\n        \n        if errors < min_errors:\n            min_errors = errors\n            best_tau = tau\n            best_fpr_on_tie = current_fpr\n        elif errors == min_errors:\n            # Tie-breaking rule: prefer smaller false positive rate\n            if current_fpr < best_fpr_on_tie:\n                best_fpr_on_tie = current_fpr\n                best_tau = tau\n            # If FPR is also tied, a larger tau is preferred to minimize FPR\n            elif current_fpr == best_fpr_on_tie and tau > best_tau:\n                best_tau = tau\n\n\n    # 5. Evaluate the model on the test set\n    test_y_true = np.array([all_labels[id] for id in test_ids])\n    test_features = [all_features[id] for id in test_ids]\n    \n    test_d2_values = np.array([mahalanobis_sq(feat, mu, sigma_reg_inv) for feat in test_features])\n    test_y_pred = (test_d2_values > best_tau).astype(int)\n\n    # Calculate FP and FN on the test set\n    fp_test = np.sum((test_y_pred == 1) & (test_y_true == 0))\n    fn_test = np.sum((test_y_pred == 0) & (test_y_true == 1))\n    \n    num_test_negatives = np.sum(test_y_true == 0)\n    num_test_positives = np.sum(test_y_true == 1)\n\n    fpr = fp_test / num_test_negatives if num_test_negatives > 0 else 0.0\n    fnr = fn_test / num_test_positives if num_test_positives > 0 else 0.0\n\n    # Final print statement in the exact required format.\n    print(f\"[{fpr:.3f},{fnr:.3f}]\")\n\nsolve()\n```", "id": "2872300"}]}