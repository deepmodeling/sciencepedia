{"hands_on_practices": [{"introduction": "原子部分电荷不是一个唯一的量子力学可观测量，而是依赖于其定义和计算方案的模型构造。这个练习提供了一个宝贵的机会，通过为一个简化的双原子分子模型编写代码，来亲手计算并比较几种常见的电荷分配方案：Mulliken布居分析、Löwdin布居分析以及基于静电势（ESP）拟合的RESP电荷。通过这个实践，您将深刻理解不同电荷方案背后的数学定义，并学会批判性地分析它们在不同化学情境下（如对称、极化和病态重叠）的差异与适用性 [@problem_id:2889438]。", "problem": "您将获得一个封闭壳层双原子分子的最小数学模型，该模型定义良好，具有两个以原子为中心的基函数。电子密度在一个以原子为中心（AO）的轨道基组中，由一个对称的、自旋求和的密度矩阵表示；AO重叠由一个对称的正定重叠矩阵表示。您的任务是为每个测试用例计算四组原子部分电荷：\n- Mulliken 电荷，\n- Löwdin 电荷，\n- 在最小基组双AO极限下的自然键轨道（NBO）电荷（如下文所述），\n- 从对给定静电势值的正则化最小二乘拟合中得到的约束静电势（RESP）电荷。\n\n所有计算都必须以原子单位进行。距离必须以玻尔（bohr）为单位，静电势以原子单位的电势（哈特里每单位电荷）为单位，电荷以基本电荷为单位。\n\n使用的基本和核心定义：\n- 由AO密度矩阵描述的封闭壳层系统中的总电子数为 $N_{\\mathrm{e}} = \\mathrm{Tr}\\!\\left(\\mathbf{P}\\mathbf{S}\\right)$，其中 $\\mathbf{P}$ 是自旋求和的AO密度矩阵，$\\mathbf{S}$ 是AO重叠矩阵。\n- 对于一个双函数AO基组 $\\{\\chi_1,\\chi_2\\}$，重叠矩阵为 $\\mathbf{S} = \\begin{pmatrix} 1 & s \\\\ s & 1 \\end{pmatrix}$，其中 $|s| < 1$ 以确保正定性。一个归一化的已占据分子轨道 $\\phi = c_1 \\chi_1 + c_2 \\chi_2$ 满足 $\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c} = 1$，且自旋求和的密度为 $\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\top}$。\n- 原子 $A$ 的 Mulliken 总原子布居（其AO索引集为 $\\mathcal{A}$）为 $N_A^{\\mathrm{Mul}} = \\sum_{\\mu \\in \\mathcal{A}} \\left(\\mathbf{P}\\mathbf{S}\\right)_{\\mu\\mu}$。Mulliken 电荷为 $q_A^{\\mathrm{Mul}} = Z_A - N_A^{\\mathrm{Mul}}$，其中 $Z_A$ 是原子 $A$ 的核电荷。\n- Löwdin 布居分析通过对称正交化进行。设 $\\mathbf{S} = \\mathbf{U}\\,\\boldsymbol{\\sigma}\\,\\mathbf{U}^{\\top}$ 为特征分解，其中 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_1,\\sigma_2)$ 且 $\\sigma_i > 0$。定义 $\\mathbf{S}^{1/2} = \\mathbf{U}\\,\\boldsymbol{\\sigma}^{1/2}\\,\\mathbf{U}^{\\top}$。Löwdin正交密度为 $\\mathbf{P}_L = \\mathbf{S}^{1/2}\\mathbf{P}\\mathbf{S}^{1/2}$。原子 $A$ 上的 Löwdin 总原子布居等于 $\\mathbf{P}_L$ 对角线上对应于 $A$ 的AO元素的总和。对于每个原子一个AO的双原子分子，有 $N_A^{\\mathrm{Low}} = \\left(\\mathbf{P}_L\\right)_{11}$ 和 $N_B^{\\mathrm{Low}} = \\left(\\mathbf{P}_L\\right)_{22}$。Löwdin 电荷为 $q_A^{\\mathrm{Low}} = Z_A - N_A^{\\mathrm{Low}}$。\n- 在最小双AO极限下，自然键轨道（NBO）电荷简化为在一组非常接近Löwdin正交化AO的自然原子轨道中评估的自然布居分析（NPA）电荷；因此，对于这个双函数模型，您必须取 $q_A^{\\mathrm{NBO}} = q_A^{\\mathrm{Low}}$。\n- 约束静电势（RESP）电荷是通过将以原子为中心的点电荷拟合到格点上的分子静电势（ESP）并施加二次约束来获得的。给定格点 $i$ 到原子 $A$ 和 $B$ 的距离 $r_{iA}$ 和 $r_{iB}$，以及ESP值 $V_i$，定义一个 $m \\times 2$ 的矩阵 $\\mathbf{A}$，其中 $A_{i1} = 1/r_{iA}$ 和 $A_{i2} = 1/r_{iB}$。对于约束参数 $\\alpha \\ge 0$ 和目标净电荷 $Q_{\\mathrm{tot}}$，求解约束Tikhonov正则化最小二乘问题：\n$$\n\\min_{\\mathbf{q}\\in\\mathbb{R}^2}\\ \\|\\mathbf{A}\\mathbf{q} - \\mathbf{V}\\|_2^2 + \\alpha \\|\\mathbf{q}\\|_2^2\\quad \\text{subject to}\\quad \\mathbf{c}^{\\top}\\mathbf{q} = Q_{\\mathrm{tot}},\n$$\n其中 $\\mathbf{c} = (1,1)^{\\top}$。其 Karush–Kuhn–Tucker 系统为：\n$$\n\\begin{pmatrix}\n\\mathbf{H} & \\mathbf{c} \\\\\n\\mathbf{c}^{\\top} & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{b} \\\\\nQ_{\\mathrm{tot}}\n\\end{pmatrix},\\quad\n\\mathbf{H} = \\mathbf{A}^{\\top}\\mathbf{A} + \\alpha \\mathbf{I}_2,\\quad \\mathbf{b} = \\mathbf{A}^{\\top}\\mathbf{V},\n$$\n该系统可解出RESP电荷 $\\mathbf{q}^{\\mathrm{RESP}}$。\n\n任务详情：\n1. 对于每个测试用例，您将获得一个标量AO重叠非对角参数 $s$，一个未归一化的分子轨道系数向量 $\\mathbf{u} = (u_1,u_2)^{\\top}$，核电荷 $(Z_A,Z_B)$，以及一个RESP拟合格点，其中包含元组 $(r_{iA}, r_{iB}, V_i)$（$i=1,\\dots,m$），还有一个约束参数 $\\alpha$。构建重叠矩阵 $\\mathbf{S} = \\begin{pmatrix} 1 & s \\\\ s & 1 \\end{pmatrix}$。将MO系数归一化为 $\\mathbf{c} = \\mathbf{u}/\\sqrt{\\mathbf{u}^{\\top}\\mathbf{S}\\mathbf{u}}$，然后形成自旋求和密度 $\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\top}$。\n2. 根据 Mulliken 方案计算 $q_A^{\\mathrm{Mul}}, q_B^{\\mathrm{Mul}}$。\n3. 根据 Löwdin 方案计算 $q_A^{\\mathrm{Low}}, q_B^{\\mathrm{Low}}$。\n4. 设 $q_A^{\\mathrm{NBO}} = q_A^{\\mathrm{Low}}$ 和 $q_B^{\\mathrm{NBO}} = q_B^{\\mathrm{Low}}$，其理由是如上所述的最小双AO极限。\n5. 通过求解目标净电荷为 $Q_{\\mathrm{tot}} = Z_A + Z_B - N_{\\mathrm{e}}$（其中 $N_{\\mathrm{e}} = \\mathrm{Tr}(\\mathbf{P}\\mathbf{S})$）的约束系统，计算RESP电荷 $(q_A^{\\mathrm{RESP}}, q_B^{\\mathrm{RESP}})$。\n\n测试套件：\n为以下三个测试用例提供结果。在所有情况下，距离单位为玻尔，电势单位为原子单位；由于 $Z_A + Z_B = N_{\\mathrm{e}}$，根据构造，约束目标电荷为零。\n- 用例1（同核，对称）：\n  - $s = 0.30$, $\\mathbf{u} = (1.0, 1.0)^{\\top}$, $(Z_A,Z_B) = (1.0, 1.0)$,\n  - RESP 格点： $\\{(r_{iA}, r_{iB}, V_i)\\}_{i=1}^4 = \\{(2.0, 2.0, 0.0),\\ (2.5, 2.5, 0.0),\\ (3.0, 3.0, 0.0),\\ (4.0, 4.0, 0.0)\\}$,\n  - $\\alpha = 0.10$.\n- 用例2（类异核，极化密度和信息丰富的ESP）：\n  - $s = 0.20$, $\\mathbf{u} = (0.35, 1.00)^{\\top}$, $(Z_A,Z_B) = (1.0, 1.0)$,\n  - RESP 格点： $\\{(2.0, 1.2, 0.0833333333),\\ (2.5, 1.3, 0.0923076923),\\ (3.0, 2.0, 0.0416666667),\\ (2.2, 4.0, -0.0511363636),\\ (5.0, 1.5, 0.1166666667)\\}$,\n  - $\\alpha = 0.01$.\n- 用例3（接近线性相关的病态重叠）：\n  - $s = 0.95$, $\\mathbf{u} = (1.0, 0.2)^{\\top}$, $(Z_A,Z_B) = (1.0, 1.0)$,\n  - RESP 格点： $\\{(2.0, 3.0, 0.0),\\ (3.0, 2.0, 0.0),\\ (4.0, 4.0, 0.0)\\}$,\n  - $\\alpha = 0.10$.\n\n角度单位不适用。不涉及百分比。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中按顺序列出每个测试用例的结果列表。每个测试用例的结果必须是包含四个列表的列表 $[q^{\\mathrm{Mul}}, q^{\\mathrm{Low}}, q^{\\mathrm{NBO}}, q^{\\mathrm{RESP}}]$，而其中每个列表又是一个双元素列表 $[q_A, q_B]$。\n- 所有数字必须打印为小数点后保留六位的小数浮点数。\n- 最终打印形式必须是单行，格式如下：\n$[[[q_{A,1}^{\\mathrm{Mul}},q_{B,1}^{\\mathrm{Mul}}],[q_{A,1}^{\\mathrm{Low}},q_{B,1}^{\\mathrm{Low}}],[q_{A,1}^{\\mathrm{NBO}},q_{B,1}^{\\mathrm{NBO}}],[q_{A,1}^{\\mathrm{RESP}},q_{B,1}^{\\mathrm{RESP}}]],\\ \\dots\\ ,[[q_{A,3}^{\\mathrm{Mul}},q_{B,3}^{\\mathrm{Mul}}],[q_{A,3}^{\\mathrm{Low}},q_{B,3}^{\\mathrm{Low}}],[q_{A,3}^{\\mathrm{NBO}},q_{B,3}^{\\mathrm{NBO}}],[q_{A,3}^{\\mathrm{RESP}},q_{B,3}^{\\mathrm{RESP}}]]]$ ，元素之间以逗号分隔，无附加文本。\n\n科学真实性和约束条件：\n- 完全在给定的矩阵和格点内工作；不要假设任何额外的基函数或外部数据。\n- 通过 $\\mathbf{P} = 2\\,\\mathbf{c}\\mathbf{c}^{\\top}$ 和 $\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c} = 1$ 的构造，该双原子分子是具有 $N_{\\mathrm{e}}=2$ 个电子的封闭壳层体系。\n- Mulliken 和 Löwdin 之间的差异源于对重叠的划分与正交化处理方式不同。在本文使用的最小双AO极限中，自然键轨道电荷与 Löwdin 电荷一致。与RESP的差异源于在电荷守恒约束和正则化下对静电势（ESP）的拟合。\n\n您的程序必须精确实现上述定义，并按照所描述的精确格式生成所需的单行输出。", "solution": "所提出的问题是计算量子化学中一个定义明确的练习，要求为一个双轨道的双原子分子最小模型计算四种类型的原子部分电荷。该问题在科学上基于已建立的理论，在数学上是一致的，并为得出唯一解提供了所有必要的数据。因此，该问题被认为是有效的。我们着手系统地推导求解过程。\n\n对每个测试用例执行整个过程，每个用例提供了原子轨道（AO）重叠参数 $s$、一个未归一化的分子轨道（MO）系数向量 $\\mathbf{u}$、核电荷 $(Z_A, Z_B)$、用于约束静电势（RESP）拟合的格点数据，以及RESP正则化参数 $\\alpha$。所有计算均以原子单位进行。\n\n**第1步：构建密度矩阵**\n\n首先，我们构建所有布居分析所需的基本矩阵。\n\n1.  **重叠矩阵 ($\\mathbf{S}$):** 给定非对角重叠元素 $s$，构建 $2 \\times 2$ 的AO重叠矩阵 $\\mathbf{S}$ 如下：\n    $$\n    \\mathbf{S} = \\begin{pmatrix} 1 & s \\\\ s & 1 \\end{pmatrix}\n    $$\n    为了使 $\\mathbf{S}$ 是正定的（这是基组重叠的物理要求），必须满足 $|s| < 1$，所有测试用例均满足此条件。\n\n2.  **MO系数归一化：** 给定的MO系数向量 $\\mathbf{u} = (u_1, u_2)^{\\top}$ 是在非正交的AO基组中定义的。相应MO $\\phi = \\sum_{\\mu} c_{\\mu} \\chi_{\\mu}$ 的归一化要求 $\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c} = 1$。归一化因子为 $N = (\\mathbf{u}^{\\top}\\mathbf{S}\\mathbf{u})^{-1/2}$。\n    内积计算如下：\n    $$\n    \\mathbf{u}^{\\top}\\mathbf{S}\\mathbf{u} = \\begin{pmatrix} u_1 & u_2 \\end{pmatrix} \\begin{pmatrix} 1 & s \\\\ s & 1 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} = u_1^2 + u_2^2 + 2su_1u_2\n    $$\n    归一化后的系数向量为 $\\mathbf{c} = \\mathbf{u} / \\sqrt{u_1^2 + u_2^2 + 2su_1u_2}$。\n\n3.  **密度矩阵 ($\\mathbf{P}$):** 对于一个具有一个双占据MO的封闭壳层系统，AO基组中的自旋求和密度矩阵 $\\mathbf{P}$ 由 $\\mathbf{P} = 2\\mathbf{c}\\mathbf{c}^{\\top}$ 给出。\n    $$\n    \\mathbf{P} = 2 \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} \\begin{pmatrix} c_1 & c_2 \\end{pmatrix} = 2 \\begin{pmatrix} c_1^2 & c_1c_2 \\\\ c_1c_2 & c_2^2 \\end{pmatrix}\n    $$\n    总电子数为 $N_{\\mathrm{e}} = \\mathrm{Tr}(\\mathbf{P}\\mathbf{S})$。根据构造，$\\mathrm{Tr}(\\mathbf{P}\\mathbf{S}) = \\mathrm{Tr}(2\\mathbf{c}\\mathbf{c}^{\\top}\\mathbf{S}) = 2\\,\\mathrm{Tr}(\\mathbf{c}^{\\top}\\mathbf{S}\\mathbf{c}) = 2(1) = 2$，这与问题描述一致。\n\n**第2步：Mulliken布居分析**\n\nMulliken 分析通过将密度-重叠积矩阵 $(\\mathbf{PS})$ 的对角线贡献分配给单个原子，并将非对角线（重叠布居）项均分来划分电子密度。原子 $A$（与基函数 $\\chi_1$ 相关）和原子 $B$（与 $\\chi_2$ 相关）的总原子布居为：\n$N_A^{\\mathrm{Mul}} = (\\mathbf{P}\\mathbf{S})_{11}$ 和 $N_B^{\\mathrm{Mul}} = (\\mathbf{P}\\mathbf{S})_{22}$。\n\n矩阵乘积 $\\mathbf{P}\\mathbf{S}$ 为：\n$$\n\\mathbf{P}\\mathbf{S} = 2 \\begin{pmatrix} c_1^2 & c_1c_2 \\\\ c_1c_2 & c_2^2 \\end{pmatrix} \\begin{pmatrix} 1 & s \\\\ s & 1 \\end{pmatrix} = 2 \\begin{pmatrix} c_1^2 + sc_1c_2 & sc_1^2 + c_1c_2 \\\\ sc_2^2 + c_1c_2 & c_2^2 + sc_1c_2 \\end{pmatrix}\n$$\n因此，布居为：\n$$\nN_A^{\\mathrm{Mul}} = 2(c_1^2 + sc_1c_2)\n$$\n$$\nN_B^{\\mathrm{Mul}} = 2(c_2^2 + sc_1c_2)\n$$\n然后，Mulliken部分电荷计算为 $q_A = Z_A - N_A$：\n$$\nq_A^{\\mathrm{Mul}} = Z_A - 2(c_1^2 + sc_1c_2)\n$$\n$$\nq_B^{\\mathrm{Mul}} = Z_B - 2(c_2^2 + sc_1c_2)\n$$\n\n**第3步：Löwdin和NBO布居分析**\n\nLöwdin 分析首先使用对称正交化 $\\boldsymbol{\\chi}' = \\boldsymbol{\\chi} \\mathbf{S}^{-1/2}$ 将基变换为正交基，然后计算布居。\n\n1.  **对称正交化矩阵：** 我们需要矩阵 $\\mathbf{S}^{1/2}$。这可以通过 $\\mathbf{S}$ 的特征分解 $\\mathbf{S} = \\mathbf{U}\\boldsymbol{\\sigma}\\mathbf{U}^{\\top}$ 计算得到，即 $\\mathbf{S}^{1/2} = \\mathbf{U}\\boldsymbol{\\sigma}^{1/2}\\mathbf{U}^{\\top}$。对于给定的 $2 \\times 2$ 矩阵 $\\mathbf{S}$，这可以解析或数值计算。为了稳健性，我们将使用一个数值库函数。\n\n2.  **Löwdin变换后的密度：** 在Löwdin正交化基中的密度矩阵 $\\mathbf{P}_L$ 由下式给出：\n    $$\n    \\mathbf{P}_L = \\mathbf{S}^{1/2} \\mathbf{P} \\mathbf{S}^{1/2}\n    $$\n\n3.  **Löwdin布居和电荷：** 在正交基中，总原子布居就是 $\\mathbf{P}_L$ 的对角线元素：\n    $$\n    N_A^{\\mathrm{Low}} = (\\mathbf{P}_L)_{11}\n    $$\n    $$\n    N_B^{\\mathrm{Low}} = (\\mathbf{P}_L)_{22}\n    $$\n    电荷随之计算为：\n    $$\n    q_A^{\\mathrm{Low}} = Z_A - N_A^{\\mathrm{Low}} \\quad \\text{和} \\quad q_B^{\\mathrm{Low}} = Z_B - N_B^{\\mathrm{Low}}\n    $$\n    \n4.  **NBO电荷：** 问题声明，对于这个最小的双AO模型，自然键轨道（NBO）电荷等同于Löwdin电荷。这是一个简化，因为真正的NBO分析涉及一个更复杂的，识别自然原子轨道和孤对电子的过程。因此我们设定：\n    $$\n    q_A^{\\mathrm{NBO}} = q_A^{\\mathrm{Low}} \\quad \\text{和} \\quad q_B^{\\mathrm{NBO}} = q_B^{\\mathrm{Low}}\n    $$\n\n**第4步：RESP电荷计算**\n\nRESP电荷 $\\mathbf{q} = (q_A, q_B)^{\\top}$ 是通过对 $m$ 个格点上的分子静电势（ESP）进行最小二乘拟合得到的，该拟合受电荷守恒约束和Tikhonov正则化。这是一个约束优化问题，通过Karush-Kuhn-Tucker（KKT）方程组求解。\n\n1.  **系统构建：** KKT系统指定为：\n    $$\n    \\begin{pmatrix}\n    \\mathbf{H} & \\mathbf{c_q} \\\\\n    \\mathbf{c_q}^{\\top} & 0\n    \\end{pmatrix}\n    \\begin{pmatrix}\n    \\mathbf{q} \\\\\n    \\lambda\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    \\mathbf{b} \\\\\n    Q_{\\mathrm{tot}}\n    \\end{pmatrix}\n    $$\n    其中 $\\mathbf{c_q} = (1, 1)^{\\top}$，$\\lambda$ 是一个拉格朗日乘子。\n\n2.  **分量构建：**\n    *   目标总电荷为 $Q_{\\mathrm{tot}} = Z_A + Z_B - N_{\\mathrm{e}} = (1.0+1.0) - 2.0 = 0$，对所有测试用例均如此。\n    *   ESP设计矩阵 $\\mathbf{A}$（$m \\times 2$）由格点距离构建：$A_{i1} = 1/r_{iA}$ 和 $A_{i2} = 1/r_{iB}$。\n    *   ESP值向量 $\\mathbf{V}$（$m \\times 1$）由给定的 $V_i$ 值组成。\n    *   正则化Hessian矩阵为 $\\mathbf{H} = \\mathbf{A}^{\\top}\\mathbf{A} + \\alpha \\mathbf{I}_2$。\n    *   梯度向量为 $\\mathbf{b} = \\mathbf{A}^{\\top}\\mathbf{V}$。\n\n3.  **求解：** 构建并求解这个 $3 \\times 3$ 的KKT线性系统，以得到向量 $(\\mathbf{q}^{\\top}, \\lambda)^{\\top}$。前两个元素就是所求的RESP电荷 $(q_A^{\\mathrm{RESP}}, q_B^{\\mathrm{RESP}})$。给定 $\\alpha > 0$ 且格点非共线，KKT矩阵是可逆的，保证了唯一解的存在。\n\n理论框架至此完成。实现将为三个测试用例中的每一个精确遵循这些步骤。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import sqrtm\n\ndef format_results(results):\n    \"\"\"\n    Formats the final results into the precise string representation required.\n    All numbers are rounded to six decimal places.\n    \"\"\"\n    case_strings = []\n    for case_result in results:\n        # case_result is a list of 4 charge pairs, e.g., [q_mul, q_low, q_nbo, q_resp]\n        charge_type_strings = []\n        for charge_pair in case_result:\n            # charge_pair is [q_A, q_B]\n            q_a, q_b = charge_pair\n            charge_type_strings.append(f\"[{q_a:.6f},{q_b:.6f}]\")\n        case_strings.append(f\"[{','.join(charge_type_strings)}]\")\n    return f\"[{','.join(case_strings)}]\"\n\ndef calculate_charges(s, u_vec, z_charges, resp_grid, alpha):\n    \"\"\"\n    Calculates Mulliken, Löwdin, NBO, and RESP charges for a single test case.\n    \"\"\"\n    u_vec = np.array(u_vec, dtype=float)\n    z_charges = np.array(z_charges, dtype=float)\n\n    # --- Step 1: Construct Density Matrix ---\n    S = np.array([[1.0, s], [s, 1.0]], dtype=float)\n    \n    # Normalize MO coefficients: c = u / sqrt(u^T * S * u)\n    norm_sq = u_vec.T @ S @ u_vec\n    c_vec = u_vec / np.sqrt(norm_sq)\n    \n    # Construct density matrix: P = 2 * c * c^T\n    P = 2 * np.outer(c_vec, c_vec)\n    \n    # --- Step 2: Mulliken Charges ---\n    PS = P @ S\n    N_mul = np.diag(PS)\n    q_mul = z_charges - N_mul\n\n    # --- Step 3: Löwdin and NBO Charges ---\n    # S_half is S^(1/2)\n    S_half = sqrtm(S)\n    P_L = S_half @ P @ S_half\n    N_low = np.diag(P_L)\n    q_low = z_charges - N_low\n    \n    # NBO charges are equal to Löwdin charges for this minimal model\n    q_nbo = q_low\n\n    # --- Step 4: RESP Charges ---\n    N_e = np.trace(PS).round(10) # Should be 2.0\n    Q_tot = np.sum(z_charges) - N_e\n\n    m = len(resp_grid) # Number of grid points\n    A = np.zeros((m, 2), dtype=float)\n    V = np.zeros(m, dtype=float)\n\n    for i, (r_iA, r_iB, V_i) in enumerate(resp_grid):\n        A[i, 0] = 1.0 / r_iA\n        A[i, 1] = 1.0 / r_iB\n        V[i] = V_i\n        \n    H = A.T @ A + alpha * np.identity(2)\n    b = A.T @ V\n\n    # Solve the 3x3 KKT system\n    kkt_matrix = np.zeros((3, 3), dtype=float)\n    kkt_matrix[:2, :2] = H\n    kkt_matrix[2, :2] = 1.0\n    kkt_matrix[:2, 2] = 1.0\n    \n    rhs_vector = np.zeros(3, dtype=float)\n    rhs_vector[:2] = b\n    rhs_vector[2] = Q_tot\n    \n    solution = np.linalg.solve(kkt_matrix, rhs_vector)\n    q_resp = solution[:2]\n\n    return [q_mul.tolist(), q_low.tolist(), q_nbo.tolist(), q_resp.tolist()]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"s\": 0.30,\n            \"u\": [1.0, 1.0],\n            \"Z\": [1.0, 1.0],\n            \"resp_grid\": [\n                (2.0, 2.0, 0.0), (2.5, 2.5, 0.0), \n                (3.0, 3.0, 0.0), (4.0, 4.0, 0.0)\n            ],\n            \"alpha\": 0.10,\n        },\n        {\n            \"s\": 0.20,\n            \"u\": [0.35, 1.00],\n            \"Z\": [1.0, 1.0],\n            \"resp_grid\": [\n                (2.0, 1.2, 0.0833333333), (2.5, 1.3, 0.0923076923),\n                (3.0, 2.0, 0.0416666667), (2.2, 4.0, -0.0511363636),\n                (5.0, 1.5, 0.1166666667)\n            ],\n            \"alpha\": 0.01,\n        },\n        {\n            \"s\": 0.95,\n            \"u\": [1.0, 0.2],\n            \"Z\": [1.0, 1.0],\n            \"resp_grid\": [\n                (2.0, 3.0, 0.0), (3.0, 2.0, 0.0), (4.0, 4.0, 0.0)\n            ],\n            \"alpha\": 0.10,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_charges(\n            case[\"s\"], case[\"u\"], case[\"Z\"], case[\"resp_grid\"], case[\"alpha\"]\n        )\n        results.append(result)\n\n    final_output = format_results(results)\n    print(final_output)\n\nsolve()\n```", "id": "2889438"}, {"introduction": "通过最小二乘法将点电荷拟合到量子力学计算的静电势（ESP）是一个经典的逆问题，其结果可能对数据中的噪声非常敏感。本练习旨在阐明在拟合过程中施加物理约束的重要性，特别是保持分子总电荷守恒。您将通过实现一个有约束和无约束的最小二乘拟合程序，并比较它们在含噪声数据下的表现，来量化总电荷约束如何提高电荷模型的稳定性和物理真实性，例如通过评估其对分子偶极矩的预测精度 [@problem_id:2889373]。", "problem": "考虑从第一性原理推导单价离子的静电势 (ESP) 拟合原子电荷的任务。完全在原子单位下进行计算：长度单位为玻尔半径 $a_0$，电荷单位为元电荷 $e$，静电势单位为哈特里/元电荷 ($e$)（因此库仑定律可简写为 $V(\\mathbf{r}) = \\sum_i q_i / \\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert$）。因此，电偶极矩为 $\\boldsymbol{\\mu} = \\sum_i q_i \\mathbf{R}_i$，单位为 $e\\,a_0$。假设测量噪声是加性的、独立的、同分布的，其均值为零，标准差为指定值。对于 $M$ 个网格点，其正向模型为\n$$\nV_j = \\sum_{i=1}^{N} \\frac{q_i}{\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert} + \\eta_j,\\quad j = 1,\\dots, M,\n$$\n其中 $N$ 是原子数，$\\mathbf{R}_i$ 是原子核位置， $q_i$ 是待拟合的未知原子电荷，$\\mathbf{r}_j$ 是网格点，$\\eta_j$ 是噪声样本。\n\n从库仑定律和最小二乘法原理出发，您必须：\n- 实现对 $\\mathbf{q}$ 的无约束最小二乘拟合，以最小化 $\\sum_{j=1}^{M} \\left(V_j - \\sum_{i=1}^N q_i / \\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert\\right)^2$。\n- 实现等式约束最小二乘拟合，该拟合使用基于第一性原理的数学可靠方法（例如，拉格朗日乘子 Karush–Kuhn–Tucker 系统）来强制执行总电荷约束 $\\sum_{i=1}^{N} q_i = Q_{\\text{tot}}$。\n- 对于每种拟合，计算：\n  1. 无约束拟合得到的总电荷 $\\sum_i \\hat{q}_i^{(\\text{uncon})}$（一个浮点数）。\n  2. 无约束拟合的电偶极矩矢量误差 $\\lVert \\sum_i (\\hat{q}_i^{(\\text{uncon})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$（一个浮点数，单位为 $e\\,a_0$）。\n  3. 约束拟合的电偶极矩矢量误差 $\\lVert \\sum_i (\\hat{q}_i^{(\\text{con})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$（一个浮点数，单位为 $e\\,a_0$）。\n\n使用以下测试套件。在所有情况下，通过 $V_j = \\sum_i q_i^{(\\text{true})}/\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert + \\eta_j$ 生成观测电势，其中 $\\eta_j$ 是具有所述标准差的独立高斯样本，使用固定的随机种子以保证可复现性。所有坐标单位为 $a_0$，所有电荷单位为 $e$，所有电势单位为原子单位，所有偶极矩误差必须以 $e\\,a_0$ 为单位报告。\n\n- 测试用例 A（一般超定，阳离子，中等噪声）：\n  - $N = 3$, $Q_{\\text{tot}} = +1$。\n  - 原子核位置 $\\mathbf{R}_i$：$[(0,0,0),\\ (1,0,0),\\ (0,1,0)]$。\n  - 真实电荷 $\\mathbf{q}^{(\\text{true})}$：$[0.3,\\ 0.5,\\ 0.2]$。\n  - 网格点 $\\mathbf{r}_j$：$[(2,0,0),\\ (0,2,0),\\ (2,2,0),\\ (1,1,1),\\ (-1,-1,0.5),\\ (3,1,0),\\ (1,3,0),\\ (1,1,-1)]$。\n  - 噪声：标准差为 $\\sigma = 10^{-4}$ 的高斯噪声；随机种子 $123$。\n\n- 测试用例 B（恰定，共线构型，极低噪声）：\n  - $N = 3$, $Q_{\\text{tot}} = +1$。\n  - 原子核位置 $\\mathbf{R}_i$：$[(0,0,0),\\ (1.2,0,0),\\ (2.4,0,0)]$。\n  - 真实电荷 $\\mathbf{q}^{(\\text{true})}$：$[0.7,\\ 0.2,\\ 0.1]$。\n  - 网格点 $\\mathbf{r}_j$：$[(0,2,0),\\ (1.2,2,0),\\ (2.4,2,0)]$。\n  - 噪声：标准差为 $\\sigma = 10^{-6}$ 的高斯噪声；随机种子 $321$。\n\n- 测试用例 C（超定，阴离子，较强噪声和一个远场点）：\n  - $N = 3$, $Q_{\\text{tot}} = -1$。\n  - 原子核位置 $\\mathbf{R}_i$：$[(0,0,0),\\ (1,0,0),\\ (0,0,1)]$。\n  - 真实电荷 $\\mathbf{q}^{(\\text{true})}$：$[-0.6,\\ -0.2,\\ -0.2]$。\n  - 网格点 $\\mathbf{r}_j$：$[(2,0,0),\\ (0,2,0),\\ (2,2,0),\\ (1,1,1),\\ (-1,-1,1),\\ (3,0,0),\\ (10,10,10)]$。\n  - 噪声：标准差为 $\\sigma = 5\\times 10^{-4}$ 的高斯噪声；随机种子 $999$。\n\n您的程序应：\n- 为每个测试用例构建设计矩阵，其元素为 $A_{j i} = 1/\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert$。\n- 使用给定的种子生成带指定噪声的 $V_j$。\n- 如上所述，计算无约束和约束拟合。\n- 为每个测试用例，按所述顺序计算所需的三个浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个列表的列表，每个列表对应一个测试用例，顺序为 A、B、C。每个内部列表的形式必须为 $[\\sum_i \\hat{q}_i^{(\\text{uncon})},\\ \\text{dipole\\_error}^{(\\text{uncon})},\\ \\text{dipole\\_error}^{(\\text{con})}]$，其中偶极矩误差的单位为 $e\\,a_0$。\n- 例如：$[[x_A,y_A,z_A],[x_B,y_B,z_B],[x_C,y_C,z_C]]$，其中每个 $x,y,z$ 都是一个浮点数。", "solution": "从静电势数据确定原子电荷的问题是计算化学中的一个经典反问题。我们给定一组原子核位置 $\\{\\mathbf{R}_i\\}_{i=1}^N$、一组网格点 $\\{\\mathbf{r}_j\\}_{j=1}^M$，以及在这些网格点上测得的相应静电势 $\\{V_j\\}_{j=1}^M$。基于原子单位下的库仑定律，正向模型通过一个受噪声干扰的线性方程组，将未知的原子电荷 $\\{q_i\\}_{i=1}^N$ 与电势关联起来：\n$$\nV_j = \\sum_{i=1}^{N} \\frac{q_i}{\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert} + \\eta_j\n$$\n这可以表示为矩阵形式：\n$$\n\\mathbf{V} = A \\mathbf{q} + \\boldsymbol{\\eta}\n$$\n在这里，$\\mathbf{V}$ 是观测电势的 $M \\times 1$ 列向量，$\\mathbf{q}$ 是未知电荷的 $N \\times 1$ 列向量，$\\boldsymbol{\\eta}$ 是未知噪声样本的 $M \\times 1$ 向量。$M \\times N$ 矩阵 $A$ 被称为设计矩阵，其元素为 $A_{ji} = 1 / \\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert$。我们的目标是根据 $\\mathbf{V}$ 和 $A$ 估计 $\\mathbf{q}$。\n\n首先，我们考虑无约束最小二乘拟合。目标是找到电荷向量 $\\hat{\\mathbf{q}}^{(\\text{uncon})}$，以最小化残差平方和 $S(\\mathbf{q}) = \\sum_{j=1}^M (V_j - (A\\mathbf{q})_j)^2$。在矩阵表示法中，这等同于最小化残差向量的欧几里得范数的平方：\n$$\nS(\\mathbf{q}) = \\lVert \\mathbf{V} - A\\mathbf{q} \\rVert_2^2 = (\\mathbf{V} - A\\mathbf{q})^T (\\mathbf{V} - A\\mathbf{q})\n$$\n为找到最小值，我们计算 $S(\\mathbf{q})$ 相对于 $\\mathbf{q}$ 的梯度并将其设为零。\n$$\n\\nabla_{\\mathbf{q}} S(\\mathbf{q}) = \\nabla_{\\mathbf{q}} (\\mathbf{V}^T\\mathbf{V} - 2\\mathbf{V}^T A\\mathbf{q} + \\mathbf{q}^T A^T A\\mathbf{q}) = -2 A^T \\mathbf{V} + 2 A^T A \\mathbf{q}\n$$\n令 $\\nabla_{\\mathbf{q}} S(\\mathbf{q}) = \\mathbf{0}$ 可得到著名的正规方程：\n$$\n(A^T A) \\mathbf{q} = A^T \\mathbf{V}\n$$\n假设矩阵 $A^T A$ 是可逆的（如果 $A$ 具有满列秩，则此条件成立，在非简并分子构型中通常满足），无约束最小二乘解为：\n$$\n\\hat{\\mathbf{q}}^{(\\text{uncon})} = (A^T A)^{-1} A^T \\mathbf{V}\n$$\n矩阵 $(A^T A)^{-1} A^T$ 是 $A$ 的 Moore-Penrose 伪逆。在计算上，这个系统使用诸如 QR 分解等稳定的数值方法来求解，这些方法已在标准线性代数库中实现。\n\n其次，我们处理等式约束最小二乘拟合。我们必须最小化相同的目标函数 $S(\\mathbf{q})$，但需服从物理约束，即原子电荷之和等于离子的总电荷 $Q_{\\text{tot}}$。此约束是线性的：\n$$\n\\sum_{i=1}^{N} q_i = Q_{\\text{tot}} \\quad \\text{或} \\quad \\mathbf{c}^T \\mathbf{q} = Q_{\\text{tot}}, \\quad \\text{其中 } \\mathbf{c} = [1, 1, \\dots, 1]^T\n$$\n这个约束优化问题使用拉格朗日乘子法求解。我们定义拉格朗日函数 $\\mathcal{L}(\\mathbf{q}, \\lambda)$：\n$$\n\\mathcal{L}(\\mathbf{q}, \\lambda) = \\frac{1}{2}\\lVert \\mathbf{V} - A\\mathbf{q} \\rVert_2^2 + \\lambda (\\mathbf{c}^T \\mathbf{q} - Q_{\\text{tot}})\n$$\n因子 $1/2$ 是为了代数上的方便。解 $(\\hat{\\mathbf{q}}^{(\\text{con})}, \\lambda^*)$ 在 $\\mathcal{L}$ 的一个驻点处找到。我们将关于 $\\mathbf{q}$ 和 $\\lambda$ 的偏导数设为零。\n$$\n\\nabla_{\\mathbf{q}} \\mathcal{L} = -A^T(\\mathbf{V} - A\\mathbf{q}) + \\lambda \\mathbf{c} = \\mathbf{0} \\implies (A^T A)\\mathbf{q} + \\lambda \\mathbf{c} = A^T \\mathbf{V}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = \\mathbf{c}^T \\mathbf{q} - Q_{\\text{tot}} = 0 \\implies \\mathbf{c}^T \\mathbf{q} = Q_{\\text{tot}}\n$$\n这两个方程构成了一个包含 $N+1$ 个未知数（$\\mathbf{q}$ 和 $\\lambda$）的 $N+1$ 个线性方程组。这被称为 Karush-Kuhn-Tucker (KKT) 系统，可以表示为分块矩阵形式：\n$$\n\\begin{pmatrix}\nA^T A & \\mathbf{c} \\\\\n\\mathbf{c}^T & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nA^T \\mathbf{V} \\\\\nQ_{\\text{tot}}\n\\end{pmatrix}\n$$\n求解该系统可得到约束电荷向量 $\\hat{\\mathbf{q}}^{(\\text{con})}$ 和拉格朗日乘子 $\\lambda$。\n\n对于每个测试用例，流程如下：\n$1$. 根据原子坐标 $\\mathbf{R}_i$ 和网格点坐标 $\\mathbf{r}_j$ 构建 $M \\times N$ 矩阵 $A$。\n$2$. 通过计算真实电势 $A\\mathbf{q}^{(\\text{true})}$ 并添加具有指定标准差 $\\sigma$ 和随机种子的高斯噪声，生成“观测”电势向量 $\\mathbf{V}$。\n$3$. 使用数值最小二乘求解器求解无约束电荷 $\\hat{\\mathbf{q}}^{(\\text{uncon})}$。\n$4$. 求解 KKT 系统以获得约束电荷 $\\hat{\\mathbf{q}}^{(\\text{con})}$。\n$5$. 计算所需量：\n   a. 无约束总电荷：$Q_{\\text{uncon}} = \\sum_{i=1}^N \\hat{q}_i^{(\\text{uncon})}$。\n   b. 无约束偶极矩误差：$\\lVert \\sum_i (\\hat{q}_i^{(\\text{uncon})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$。求和项代表误差偶极矩向量 $\\boldsymbol{\\mu}_{\\text{err}}^{(\\text{uncon})}$，因此我们计算其欧几里得范数。\n   c. 约束偶极矩误差：$\\lVert \\sum_i (\\hat{q}_i^{(\\text{con})} - q_i^{(\\text{true})}) \\mathbf{R}_i \\rVert_2$，即误差偶极矩向量 $\\boldsymbol{\\mu}_{\\text{err}}^{(\\text{con})}$ 的范数。\n这种严谨的、基于原理的方法确保了实现的正确性和鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for ESP-fitted charges using unconstrained and constrained least-squares\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"N\": 3, \"Q_tot\": 1.0,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"q_true\": np.array([0.3, 0.5, 0.2]),\n            \"r_grid\": np.array([\n                [2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 1.0, 1.0],\n                [-1.0, -1.0, 0.5], [3.0, 1.0, 0.0], [1.0, 3.0, 0.0], [1.0, 1.0, -1.0]\n            ]),\n            \"sigma\": 1e-4, \"seed\": 123\n        },\n        {\n            \"name\": \"B\",\n            \"N\": 3, \"Q_tot\": 1.0,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.2, 0.0, 0.0], [2.4, 0.0, 0.0]]),\n            \"q_true\": np.array([0.7, 0.2, 0.1]),\n            \"r_grid\": np.array([[0.0, 2.0, 0.0], [1.2, 2.0, 0.0], [2.4, 2.0, 0.0]]),\n            \"sigma\": 1e-6, \"seed\": 321\n        },\n        {\n            \"name\": \"C\",\n            \"N\": 3, \"Q_tot\": -1.0,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"q_true\": np.array([-0.6, -0.2, -0.2]),\n            \"r_grid\": np.array([\n                [2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 1.0, 1.0],\n                [-1.0, -1.0, 1.0], [3.0, 0.0, 0.0], [10.0, 10.0, 10.0]\n            ]),\n            \"sigma\": 5e-4, \"seed\": 999\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        R_atoms = case[\"R\"]\n        q_true = case[\"q_true\"]\n        r_grid = case[\"r_grid\"]\n        Q_tot = case[\"Q_tot\"]\n        sigma = case[\"sigma\"]\n        seed = case[\"seed\"]\n        N = case[\"N\"]\n        M = r_grid.shape[0]\n\n        # 1. Construct the design matrix A\n        # A_ji = 1 / ||r_j - R_i||\n        # Using broadcasting for efficiency:\n        distances = np.linalg.norm(r_grid[:, np.newaxis, :] - R_atoms[np.newaxis, :, :], axis=2)\n        A = 1.0 / distances\n\n        # 2. Generate the observed potential vector V\n        V_true = A @ q_true\n        rng = np.random.default_rng(seed)\n        eta = rng.normal(loc=0.0, scale=sigma, size=M)\n        V_obs = V_true + eta\n\n        # 3. Unconstrained least-squares fit\n        q_uncon = np.linalg.lstsq(A, V_obs, rcond=None)[0]\n\n        # 4. Constrained least-squares fit using KKT system\n        # | A^T*A   c | |  q_con  | = | A^T*V |\n        # |  c^T    0 | | lambda  |   | Q_tot |\n        \n        ATA = A.T @ A\n        ATV = A.T @ V_obs\n        \n        # Build KKT matrix (N+1 x N+1)\n        KKT_matrix = np.zeros((N + 1, N + 1))\n        KKT_matrix[:N, :N] = ATA\n        c = np.ones(N)\n        KKT_matrix[:N, N] = c\n        KKT_matrix[N, :N] = c\n\n        # Build RHS vector (N+1)\n        rhs = np.zeros(N + 1)\n        rhs[:N] = ATV\n        rhs[N] = Q_tot\n\n        # Solve the KKT system\n        solution_kkt = np.linalg.solve(KKT_matrix, rhs)\n        q_con = solution_kkt[:N]\n\n        # 5. Compute required quantities\n        # a. Total charge from unconstrained fit\n        total_q_uncon = np.sum(q_uncon)\n\n        # b. Dipole error for unconstrained fit\n        dipole_err_uncon_vec = (q_uncon - q_true) @ R_atoms\n        dipole_err_uncon_norm = np.linalg.norm(dipole_err_uncon_vec)\n        \n        # c. Dipole error for constrained fit\n        dipole_err_con_vec = (q_con - q_true) @ R_atoms\n        dipole_err_con_norm = np.linalg.norm(dipole_err_con_vec)\n\n        all_results.append([\n            total_q_uncon,\n            dipole_err_uncon_norm,\n            dipole_err_con_norm\n        ])\n\n    # Final print statement in the exact required format\n    # produces [[...],[...],[...]] without spaces\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2889373"}, {"introduction": "静电势（ESP）拟合的数值稳定性在很大程度上取决于拟合点的空间分布。当格点过于密集或在“信息”上冗余时，描述拟合问题的线性方程组可能变得病态（ill-conditioned），导致拟合出的电荷不稳定且不可靠。这个高级练习将引导您解决这一实际问题，通过实现一种基于核相关性的系统性网格去冗余策略，来提高最小二乘问题的条件数。这不仅能加深您对数值线代在计算化学中应用的理解，还为您提供了增强电荷计算稳健性的实用工具 [@problem_id:2889411]。", "problem": "给定一个量子化学中标准的静电势 (ESP) 电荷拟合设定。在一组网格点上的外部计算总静电势，被建模为由位于给定原子位置的固定点电荷所产生的库仑势。假设在三维空间中有 $M$ 个原子，其位置为 $\\{\\mathbf{R}_A\\}_{A=1}^{M}$，未知电荷为 $\\{q_A\\}_{A=1}^{M}$；并有 $N$ 个网格点，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$。由库仑核在网格点上诱导的特征向量，由分量映射 $\\phi_A(\\mathbf{r}) = 1 / \\|\\mathbf{r} - \\mathbf{R}_A\\|$ 定义，其中范数为欧几里得范数。使用此定义，线性系统矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times M}$ 的元素为 $A_{iA} = \\phi_A(\\mathbf{r}_i)$。在 ESP 衍生原子电荷的标准最小二乘拟合中，正规方程涉及矩阵 $\\mathbf{A}^\\top \\mathbf{A}$。当 $\\mathbf{A}$ 的行向量近似线性相关时，$\\mathbf{A}^\\top \\mathbf{A}$ 会变得病态，拟合出的电荷在数值上会变得不稳定。\n\n你的任务是设计并实现一种有原则的网格去重策略，该策略能移除相对于库仑核而言冗余的网格点。如果两个网格点 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的核特征向量之间的余弦相关性超过了指定的阈值，则认为它们是冗余的。对于任意两个网格点 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$，定义核相关性\n$$\nc(i,j) \\;=\\; \\frac{\\langle \\boldsymbol{\\phi}(\\mathbf{r}_i), \\boldsymbol{\\phi}(\\mathbf{r}_j) \\rangle}{\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2 \\, \\|\\boldsymbol{\\phi}(\\mathbf{r}_j)\\|_2} \\;=\\; \\frac{\\sum_{A=1}^{M} \\frac{1}{\\|\\mathbf{r}_i-\\mathbf{R}_A\\|} \\cdot \\frac{1}{\\|\\mathbf{r}_j-\\mathbf{R}_A\\|}}{\\left(\\sum_{A=1}^{M} \\frac{1}{\\|\\mathbf{r}_i-\\mathbf{R}_A\\|^2}\\right)^{1/2}\\left(\\sum_{A=1}^{M} \\frac{1}{\\|\\mathbf{r}_j-\\mathbf{R}_A\\|^2}\\right)^{1/2}} \\,,\n$$\n对于严格为正的特征，其值位于 $[0,1]$ 区间内。对于一个用户指定的阈值 $\\tau \\in [0,1]$，去重策略必须构建一个保留网格索引的子集 $S \\subset \\{1,\\dots,N\\}$，使得对于所有不同的 $i,j \\in S$，都有 $c(i,j) \\le \\tau$，同时尽可能多地保留信息丰富的点以避免分辨率损失。你必须从数学上论证，为什么对所有成对相关性施加上限 $\\tau$ 可以控制 $\\mathbf{A}$ 行向量之间的近似线性相关性，并改善最小二乘问题的条件数。你的算法应当是确定性的，并且在可能出现平局的情况下，应优先保留具有较大特征范数 $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$ 的点。\n\n你可以使用的基本出发点包括：库仑定律势 $V(\\mathbf{r}) = \\sum_{A=1}^{M} q_A / \\|\\mathbf{r} - \\mathbf{R}_A\\|$、欧几里得内积和范数、Gram 矩阵的性质、Gershgorin 圆盘定理以及基本的线性最小二乘条件数知识。不要假设任何预先给定的去重公式；应从这些基础上推导出逻辑。\n\n你的程序必须实现以下确定性贪婪选择策略：将网格点按其 $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$ 的降序排序，然后依次处理每个点，当且仅当该点与每个先前已保留点 $j$ 的相关性 $c(i,j)$ 均满足 $\\le \\tau$ 时，才保留该点。如果 $\\tau \\ge 1$，则保留所有点。如果 $\\tau \\le 0$，则最多保留一个点（具体来说，是排序后的第一个点）。使用严格不等式 $c(i,j) > \\tau$ 作为丢弃候选点 $i$ 的标准。\n\n物理单位：所有位置 $\\mathbf{R}_A$ 和 $\\mathbf{r}_i$ 均以埃（$\\text{\\AA}$）为单位。算法的输出是无单位的。\n\n测试套件：使用以下原子中心和网格集。\n- 原子中心 $\\{\\mathbf{R}_A\\}_{A=1}^{M}$，$M = 3$：\n  - $\\mathbf{R}_1 = (0.0000,\\, 0.0000,\\, 0.0000)$，\n  - $\\mathbf{R}_2 = (0.9572,\\, 0.0000,\\, 0.0000)$，\n  - $\\mathbf{R}_3 = (-0.2390,\\, 0.9270,\\, 0.0000)$。\n- 定义五个测试用例，每个用例为一个三元组 $(\\text{grid}, \\tau, \\text{name})$：\n  - 用例 1（聚集的远场，中等阈值）：网格点 $\\mathbf{r}_i$ 为 $(3.00,\\,0.00,\\,0.00)$、$(3.05,\\,0.00,\\,0.00)$、$(3.10,\\,0.00,\\,0.00)$、$(0.00,\\,3.00,\\,0.00)$、$(-3.00,\\,0.00,\\,0.00)$，且 $\\tau = 0.95$。\n  - 用例 2（重复点，高阈值）：网格点 $\\mathbf{r}_i$ 为 $(2.50,\\,0.00,\\,0.00)$、$(2.50,\\,0.00,\\,0.00)$、$(0.00,\\,2.50,\\,0.00)$、$(0.00,\\,2.50,\\,0.00)$、$(0.00,\\,0.00,\\,2.50)$，且 $\\tau = 0.99$。\n  - 用例 3（近核簇，更严格的阈值）：网格点 $\\mathbf{r}_i$ 为 $(0.20,\\,0.00,\\,0.00)$、$(0.25,\\,0.00,\\,0.00)$、$(0.30,\\,0.00,\\,0.00)$、$(0.00,\\,0.20,\\,0.00)$、$(0.00,\\,0.00,\\,0.20)$，且 $\\tau = 0.90$。\n  - 用例 4（边界情况-保留所有）：网格点 $\\mathbf{r}_i$ 为 $(1.50,\\,0.50,\\,0.00)$、$(-1.50,\\,-0.50,\\,0.00)$、$(0.00,\\,0.00,\\,1.50)$，且 $\\tau = 1.00$。\n  - 用例 5（边界情况-保留一个）：网格点 $\\mathbf{r}_i$ 为 $(4.00,\\,0.00,\\,0.00)$、$(0.00,\\,4.00,\\,0.00)$、$(0.00,\\,0.00,\\,4.00)$，且 $\\tau = 0.00$。\n\n对于每个测试用例，你的程序必须计算在应用指定的去重策略后保留的网格点数量。你的最终程序输出必须是一行，其中包含用例 1 到 5 的结果，形式为方括号括起来的逗号分隔列表，例如 $[n_1,n_2,n_3,n_4,n_5]$，其中 $n_k$ 是用例 $k$ 保留的网格点的整数数量。", "solution": "首先对问题进行严格的验证。\n\n**步骤 1：提取已知条件**\n\n从问题陈述中逐字提取已知条件：\n- 原子数：$M$。\n- 原子位置：$\\{\\mathbf{R}_A\\}_{A=1}^{M}$。\n- 网格点数：$N$。\n- 网格点位置：$\\{\\mathbf{r}_i\\}_{i=1}^{N}$。\n- 未知原子电荷：$\\{q_A\\}_{A=1}^{M}$。\n- 库仑核特征向量分量：$\\phi_A(\\mathbf{r}) = 1 / \\|\\mathbf{r} - \\mathbf{R}_A\\|$，其中 $\\|\\cdot\\|$ 是欧几里得范数。\n- 网格点 $\\mathbf{r}_i$ 的特征向量是 $\\boldsymbol{\\phi}(\\mathbf{r}_i) \\in \\mathbb{R}^M$，其分量为 $[\\phi_A(\\mathbf{r}_i)]_{A=1}^{M}$。\n- 线性系统矩阵：$\\mathbf{A} \\in \\mathbb{R}^{N \\times M}$，其元素为 $A_{iA} = \\phi_A(\\mathbf{r}_i)$。$\\mathbf{A}$ 的第 $i$ 行为 $\\boldsymbol{\\phi}(\\mathbf{r}_i)^\\top$。\n- 核相关性：$$c(i,j) \\;=\\; \\frac{\\langle \\boldsymbol{\\phi}(\\mathbf{r}_i), \\boldsymbol{\\phi}(\\mathbf{r}_j) \\rangle}{\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2 \\, \\|\\boldsymbol{\\phi}(\\mathbf{r}_j)\\|_2}$$\n- 去重阈值：$\\tau \\in [0,1]$。\n- 去重规则：保留索引的子集 $S$ 必须满足对于所有不同的 $i,j \\in S$，都有 $c(i,j) \\le \\tau$。\n- 算法规范：规定了确定性的贪婪选择策略。\n  1. 将网格点索引 $i$ 按特征向量范数 $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$ 的降序排序。\n  2. 顺序遍历排序后的索引。当且仅当一个点 $i$ 对于每个先前保留的点 $j$，其相关性 $c(i,j) \\le \\tau$ 时，才保留该点。丢弃的标准是严格的 $c(i,j) > \\tau$。\n- 测试用例的原子位置 ($M=3$)：$\\mathbf{R}_1=(0.0000, 0.0000, 0.0000)$，$\\mathbf{R}_2=(0.9572, 0.0000, 0.0000)$，$\\mathbf{R}_3=(-0.2390, 0.9270, 0.0000)$，单位为埃。\n- 提供了五个测试用例，每个都指定了一组网格点 $\\{\\mathbf{r}_i\\}$ 和一个阈值 $\\tau$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估：\n- **科学性**：该问题设定在量子化学的背景下，具体涉及静电势 (ESP) 衍生的原子电荷拟合。这是一种标准且成熟的计算化学方法。其数学表述，包括库仑定律、线性最小二乘、正规方程 ($\\mathbf{A}^\\top \\mathbf{A}$) 和矩阵条件数，完全合理，是数值科学计算的基础。使用余弦相似度（核相关性）来识别和移除冗余数据向量是数据分析和数值线性代数中用于解决病态问题的标准技术。该问题具有科学基础。\n- **适定性**：问题陈述清晰地定义了输入（原子坐标、网格坐标、阈值）、要遵循的确切步骤（一个确定性贪婪算法）以及要求的输出（保留点的数量）。鉴于算法的确定性，每个测试用例都存在唯一解。该问题是适定的。\n- **客观性**：所有定义都是数学化的和精确的。冗余和选择的标准是定量的。该问题使用客观语言表述，没有歧义或主观陈述。\n\n该问题没有表现出任何列出的无效性缺陷。它在数学上和科学上是一致的、完整的并且可形式化的。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。将提供一个解决方案。\n\n**数学论证**\n\n任务要求论证为何限制成对相关性 $c(i,j)$ 能够改善最小二乘问题的条件数。电荷 $\\mathbf{q}$ 的最小二乘解是通过解正规方程 $(\\mathbf{A}^\\top \\mathbf{A}) \\mathbf{q} = \\mathbf{A}^\\top \\mathbf{v}$ 得到的，其中 $\\mathbf{v}$ 是网格点上静电势的向量。该解的数值稳定性由矩阵 $\\mathbf{A}^\\top \\mathbf{A}$ 的条件数决定。大的条件数表示一个病态问题，其中输入中的小扰动可能导致解 $\\mathbf{q}$ 的巨大变化。\n\n去重策略创建了一个网格点子集，这对应于从矩阵 $\\mathbf{A}$ 中选择一个行子集来形成一个新矩阵，我们称之为 $\\mathbf{A}_S$。$\\mathbf{A}_S$ 的行是保留网格点集合 $S$ 的特征向量 $\\{\\boldsymbol{\\phi}(\\mathbf{r}_i)\\}_{i \\in S}$。新的正规方程涉及矩阵 $\\mathbf{A}_S^\\top \\mathbf{A}_S$。我们分析其条件数。\n\n$\\mathbf{A}_S^\\top \\mathbf{A}_S$ 的非零特征值与 Gram 矩阵 $\\mathbf{G} = \\mathbf{A}_S \\mathbf{A}_S^\\top$ 的非零特征值相同。这个 Gram 矩阵的元素是所选特征向量的内积：$G_{ij} = \\langle \\boldsymbol{\\phi}(\\mathbf{r}_i), \\boldsymbol{\\phi}(\\mathbf{r}_j) \\rangle$，其中 $i,j \\in S$。$\\mathbf{A}_S^\\top \\mathbf{A}_S$ 的条件数与 $\\mathbf{G}$ 的最大特征值与最小特征值之比有关。\n\n所规定的算法控制了*归一化* Gram 矩阵 $\\mathbf{G}'$ 的非对角元素，其元素为 $G'_{ij} = c(i,j)$。根据构造，对于所有不同的 $i,j \\in S$，我们有 $|G'_{ij}| = |c(i,j)| \\le \\tau$。对角元素为 $G'_{ii} = c(i,i) = 1$。\n\n我们可以对矩阵 $\\mathbf{G}'$ 应用 Gershgorin 圆盘定理。该定理指出，$\\mathbf{G}'$ 的每个特征值都至少位于一个 Gershgorin 圆盘 $D(G'_{ii}, R_i)$ 内，该圆盘在复平面中，圆心是 $G'_{ii}$，半径是 $R_i = \\sum_{j \\neq i} |G'_{ij}|$。\n对于我们的 $k \\times k$ 矩阵 $\\mathbf{G}'$（其中 $k = |S|$ 是保留点的数量），我们有：\n- 圆盘中心：$G'_{ii} = 1$。\n- 圆盘半径：$R_i = \\sum_{j \\in S, j \\neq i} |c(i,j)| \\le \\sum_{j \\in S, j \\neq i} \\tau = (k-1)\\tau$。\n\n由于 $\\mathbf{G}'$ 是一个实对称矩阵，其特征值 $\\lambda$ 是实数。因此，所有特征值都必须位于实数区间 $[1 - R_i, 1 + R_i]$ 的并集中。这意味着：\n$$ \\lambda_{\\min}(\\mathbf{G}') \\ge 1 - \\max_i R_i \\ge 1 - (k-1)\\tau $$\n$$ \\lambda_{\\max}(\\mathbf{G}') \\le 1 + \\max_i R_i \\le 1 + (k-1)\\tau $$\n$\\mathbf{G}'$ 的条件数是 $\\kappa(\\mathbf{G}') = \\lambda_{\\max}(\\mathbf{G}') / \\lambda_{\\min}(\\mathbf{G}')$。我们可以将其界定为：\n$$ \\kappa(\\mathbf{G}') \\le \\frac{1 + (k-1)\\tau}{1 - (k-1)\\tau} $$\n这个界限在 $1 - (k-1)\\tau > 0$，即 $\\tau < 1/(k-1)$ 的情况下是有意义的。通过强制一个小的阈值 $\\tau$，我们确保 $\\mathbf{A}_S$ 的行向量远离线性相关。这使得归一化 Gram 矩阵 $\\mathbf{G}'$ 的特征值远离零，从而限制了其条件数。限制条件数是确保基础矩阵 $\\mathbf{G}$ 是良态的标准方法。由于 $\\mathbf{A}_S^\\top \\mathbf{A}_S$ 与 $\\mathbf{G}$ 共享其非零特征值，这个过程直接改善了正规方程矩阵的条件数，从而实现了对 ESP 电荷的数值稳定和可靠的计算。\n\n**算法设计**\n\n实现遵循规定的确定性贪婪选择策略。\n\n1.  **预处理**：对于给定的测试用例（原子坐标 $\\{\\mathbf{R}_A\\}$，网格点 $\\{\\mathbf{r}_i\\}$），我们首先为每个网格点 $i \\in \\{1,\\dots,N\\}$ 计算必要的数据。\n    -   特征向量 $\\boldsymbol{\\phi}(\\mathbf{r}_i) \\in \\mathbb{R}^M$，其中第 $A$ 个分量是 $1/\\|\\mathbf{r}_i - \\mathbf{R}_A\\|_2$。\n    -   特征向量的 L2-范数，$\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$。\n    最好是通过创建一个 $N \\times M$ 的特征向量矩阵和一个 $N$ 维的范数数组来完成。\n\n2.  **排序**：网格点的原始索引 $\\{0, 1, \\dots, N-1\\}$，根据预先计算的范数 $\\|\\boldsymbol{\\phi}(\\mathbf{r}_i)\\|_2$ 按降序排序。这确定了点被考虑保留的优先顺序。\n\n3.  **贪婪选择循环**：\n    -   初始化一个空列表 `retained_indices`，用于存储被保留的网格点的索引。\n    -   算法遍历排序后的索引。对于每个候选索引 `current_idx`：\n        a. 一个标志 `is_redundant` 被设置为 `False`。\n        b. 然后算法遍历 `retained_indices` 中已有的索引。设其中一个索引为 `retained_idx`。\n        c. 使用预先计算的特征向量和范数计算核相关性 $c(\\text{current\\_idx}, \\text{retained\\_idx})$。\n        $$ c(\\text{current\\_idx}, \\text{retained\\_idx}) = \\frac{\\boldsymbol{\\phi}(\\mathbf{r}_{\\text{current\\_idx}}) \\cdot \\boldsymbol{\\phi}(\\mathbf{r}_{\\text{retained\\_idx}})}{\\|\\boldsymbol{\\phi}(\\mathbf{r}_{\\text{current\\_idx}})\\|_2 \\|\\boldsymbol{\\phi}(\\mathbf{r}_{\\text{retained\\_idx}})\\|_2} $$\n        d. 如果此相关性大于阈值 $\\tau$，即 $c(\\text{current\\_idx}, \\text{retained\\_idx}) > \\tau$，则认为候选点相对于一个已保留的点是冗余的。将 `is_redundant` 标志设置为 `True`，并终止内层循环（遍历 `retained_indices`）。\n        e. 在与所有 `retained_indices` 检查之后，如果 `is_redundant` 标志仍为 `False`，则将 `current_idx` 添加到 `retained_indices` 列表中。\n    -   对所有候选索引重复此过程。\n\n4.  **结果**：测试用例的最终结果是 `retained_indices` 列表的大小。对五个测试用例中的每一个都应用此过程，并收集结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid de-duplication problem for the given test cases.\n    \"\"\"\n    \n    # Define atomic centers as specified in the problem.\n    atom_centers = np.array([\n        [0.0000, 0.0000, 0.0000],\n        [0.9572, 0.0000, 0.0000],\n        [-0.2390, 0.9270, 0.0000]\n    ])\n\n    # Define the five test cases. Each is a tuple of (grid_points, threshold).\n    test_cases = [\n        (np.array([\n            [3.00, 0.00, 0.00], [3.05, 0.00, 0.00], [3.10, 0.00, 0.00],\n            [0.00, 3.00, 0.00], [-3.00, 0.00, 0.00]\n        ]), 0.95),  # Case 1\n        (np.array([\n            [2.50, 0.00, 0.00], [2.50, 0.00, 0.00],\n            [0.00, 2.50, 0.00], [0.00, 2.50, 0.00],\n            [0.00, 0.00, 2.50]\n        ]), 0.99),  # Case 2\n        (np.array([\n            [0.20, 0.00, 0.00], [0.25, 0.00, 0.00], [0.30, 0.00, 0.00],\n            [0.00, 0.20, 0.00], [0.00, 0.00, 0.20]\n        ]), 0.90),  # Case 3\n        (np.array([\n            [1.50, 0.50, 0.00], [-1.50, -0.50, 0.00], [0.00, 0.00, 1.50]\n        ]), 1.00),  # Case 4\n        (np.array([\n            [4.00, 0.00, 0.00], [0.00, 4.00, 0.00], [0.00, 0.00, 4.00]\n        ]), 0.00)   # Case 5\n    ]\n\n    results = []\n    \n    for grid_points, threshold in test_cases:\n        num_grid_points = grid_points.shape[0]\n        num_atoms = atom_centers.shape[0]\n\n        # Step 1: Preprocessing - Calculate feature vectors and their norms.\n        feature_vectors = np.zeros((num_grid_points, num_atoms))\n        for i in range(num_grid_points):\n            for a in range(num_atoms):\n                dist = np.linalg.norm(grid_points[i] - atom_centers[a])\n                # Handle the case where a grid point is exactly on an atom, though not in test data.\n                if dist > 1e-9:\n                    feature_vectors[i, a] = 1.0 / dist\n                else: # To avoid division by zero, assign a large but finite value.\n                    feature_vectors[i, a] = 1e9\n\n        feature_norms = np.linalg.norm(feature_vectors, axis=1)\n\n        # Step 2: Sorting - Sort indices by descending norm.\n        # Use negative norms for ascending sort to get descending order.\n        # np.argsort is stable, which handles ties correctly based on original order.\n        sorted_indices = np.argsort(-feature_norms, kind='stable')\n\n        # Step 3: Greedy Selection\n        retained_indices = []\n        for i in sorted_indices:\n            is_redundant = False\n            # Check correlation with already retained points.\n            for j in retained_indices:\n                # Handle perfect duplicates to avoid division by zero if norms are zero (not an issue here)\n                if feature_norms[i] == 0 or feature_norms[j] == 0:\n                    correlation = 1.0 if i == j else 0.0\n                else:\n                    dot_product = np.dot(feature_vectors[i], feature_vectors[j])\n                    correlation = dot_product / (feature_norms[i] * feature_norms[j])\n\n                if correlation > threshold:\n                    is_redundant = True\n                    break\n            \n            if not is_redundant:\n                retained_indices.append(i)\n\n        results.append(len(retained_indices))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2889411"}]}