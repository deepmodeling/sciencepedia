{"hands_on_practices": [{"introduction": "计算红外和拉曼强度的第一步是获得分子偶极矩和极化率张量对原子核位移的一阶导数。在实践中，这些导数通常通过有限差分法从一系列在原子核微小位移构型上执行的量子化学计算中数值求得。这个过程面临一个核心挑战：步长 $h$ 的选择必须在截断误差（源于有限差分公式的数学近似）和数值噪声（源于量化计算的有限精度）之间取得精妙平衡。本练习 [@problem_id:2898195] 将指导你设计一个最佳的中心差分方案，通过最小化均方误差来确定最优步长，这是所有计算化学家都必须掌握的一项基本功。", "problem": "在分子红外(IR)和拉曼光谱学中，一个简正模 $Q_k$ 的谱带强度由偶极矩分量 $\\mu_\\alpha$ 和极化率张量分量 $\\alpha_{ij}$ 在平衡几何构型处的一阶导数 $\\partial \\mu_\\alpha/\\partial Q_k$ 和 $\\partial \\alpha_{ij}/\\partial Q_k$ 决定。考虑气相水分子的对称伸缩简正坐标 $Q_s$ 作为一个代表性案例。假设在 $Q_s = 0$ 附近，性质函数沿 $Q_s$ 的变化可以很好地用奇次幂泰勒展开式来近似（这与全对称振动模式的对称性一致），如下：\n$$\n\\mu_z(Q_s) = \\mu_0 + \\mu_1 Q_s + \\frac{\\mu_3}{6} Q_s^3 + \\frac{\\mu_5}{120} Q_s^5,\n$$\n$$\n\\alpha_{zz}(Q_s) = a_0 + a_1 Q_s + \\frac{a_3}{6} Q_s^3 + \\frac{a_5}{120} Q_s^5,\n$$\n其中 $\\mu_0 = 0.728$（原子单位 $e\\,a_0$），$\\mu_1 = 0.400$，$\\mu_3 = 1.200$，$\\mu_5 = 2.000$，$a_0 = 9.86$（单位为 $a_0^3$），$a_1 = 0.150$，$a_3 = 0.500$，$a_5 = 1.000$。这里的 $a_0$ 是玻尔半径。进一步假设，每次从头计算的性质评估（在任意给定的 $Q_s$ 处）都受到独立的、零均值的、高斯分布的数值噪声的干扰，其已知标准差对于 $\\mu_z$ 为 $\\sigma_\\mu = 1.0\\times 10^{-6}$，对于 $\\alpha_{zz}$ 为 $\\sigma_\\alpha = 2.0\\times 10^{-6}$，这反映了严格但有限的数值阈值。\n\n您必须设计一个稳健的中心有限差分方案来估计一阶导数 $\\left.\\partial \\mu_z/\\partial Q_s\\right|_{0}$ 和 $\\left.\\partial \\alpha_{zz}/\\partial Q_s\\right|_{0}$，该方案能够最小化由截断（步长）误差和传播的数值噪声之间的竞争所产生的均方误差。您可以从以下关于 $Q_s=0$ 对称的中心差分方案中进行选择：\n- 使用 $Q_s=\\pm h$ 的两点中心差分，\n- 使用 $Q_s=\\pm h,\\pm 2h$ 的四点中心差分，\n- 由 $h$ 和 $h/2$ 处的中心差分构建的两级 Richardson 外推法。\n\n从泰勒定理和标准高斯误差传播出发，针对每种性质，确定哪种方案和步长 $h$ 可以在所述模型下最小化均方误差，并量化以下指标：\n- 单西格玛数值不确定度（来自噪声传播），\n- 在所选 $h$ 处的主要截断偏差（说明其符号），\n- 得到的导数估计期望值（将偏差应用于真实导数），\n所有结果均报告至三位有效数字。\n\n下面哪个选项为 $\\partial \\mu_z/\\partial Q_s$ 和 $\\partial \\alpha_{zz}/\\partial Q_s$ 同时提供了正确的稳健设计（方案、步长和定量误差分析）？\n\nA. 使用两点中心差分，最优平衡步长为 $h_\\mu \\approx 0.0136$ 和 $h_\\alpha \\approx 0.0229$。预测性能：\n- $\\partial \\mu_z/\\partial Q_s \\approx 0.400037$，单西格玛数值不确定度 $\\pm 5.20\\times 10^{-5}$，截断偏差 $+3.70\\times 10^{-5}$，均方根误差 $\\approx 6.38\\times 10^{-5}$。\n- $\\partial \\alpha_{zz}/\\partial Q_s \\approx 0.150044$，单西格玛数值不确定度 $\\pm 6.18\\times 10^{-5}$，截断偏差 $+4.37\\times 10^{-5}$，均方根误差 $\\approx 7.53\\times 10^{-5}$。\n\nB. 使用四点中心差分，最优平衡步长为 $h_\\mu \\approx 0.0936$ 和 $h_\\alpha \\approx 0.123$。预测性能：\n- $\\partial \\mu_z/\\partial Q_s \\approx 0.399995$，单西格玛数值不确定度 $\\pm 1.02\\times 10^{-5}$，截断偏差 $-5.10\\times 10^{-6}$，均方根误差 $\\approx 1.13\\times 10^{-5}$。\n- $\\partial \\alpha_{zz}/\\partial Q_s \\approx 0.149992$，单西格玛数值不确定度 $\\pm 1.55\\times 10^{-5}$，截断偏差 $-7.63\\times 10^{-6}$，均方根误差 $\\approx 1.73\\times 10^{-5}$。\n\nC. 使用四点中心差分，保守的通用步长为 $h_\\mu=h_\\alpha=0.0200$。预测性能：\n- $\\partial \\mu_z/\\partial Q_s \\approx 0.400000$，单西格玛数值不确定度 $\\pm 4.75\\times 10^{-5}$，截断偏差 $-1.07\\times 10^{-8}$，均方根误差 $\\approx 4.75\\times 10^{-5}$。\n- $\\partial \\alpha_{zz}/\\partial Q_s \\approx 0.150000$，单西格玛数值不确定度 $\\pm 9.50\\times 10^{-5}$，截断偏差 $-5.33\\times 10^{-9}$，均方根误差 $\\approx 9.50\\times 10^{-5}$。\n\nD. 使用两级 Richardson 外推法，步长为 $h_\\mu \\approx 0.0936$ 和 $h_\\alpha \\approx 0.123$。预测性能：\n- $\\partial \\mu_z/\\partial Q_s \\approx 0.400000$，单西格玛数值不确定度 $\\pm 1.02\\times 10^{-5}$，截断偏差 $-3.19\\times 10^{-7}$，均方根误差 $\\approx 1.02\\times 10^{-5}$。\n- $\\partial \\alpha_{zz}/\\partial Q_s \\approx 0.150000$，单西格玛数值不确定度 $\\pm 1.55\\times 10^{-5}$，截断偏差 $-4.77\\times 10^{-7}$，均方根误差 $\\approx 1.55\\times 10^{-5}$。\n\n选择唯一一个选项，该选项既能在所述噪声模型下为每种性质正确地最小化均方误差，又能准确地报告相应的步长和定量误差分析。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n性质，即偶极矩分量 $\\mu_z$ 和极化率张量分量 $\\alpha_{zz}$，被给出为简正坐标 $Q_s$ 的函数。在平衡几何构型（$Q_s=0$）附近，它们的展开式为：\n$$\n\\mu_z(Q_s) = \\mu_0 + \\mu_1 Q_s + \\frac{\\mu_3}{6} Q_s^3 + \\frac{\\mu_5}{120} Q_s^5\n$$\n$$\n\\alpha_{zz}(Q_s) = a_0 + a_1 Q_s + \\frac{a_3}{6} Q_s^3 + \\frac{a_5}{120} Q_s^5\n$$\n$\\mu_z(Q_s)$ 的系数为：$\\mu_0 = 0.728$，$\\mu_1 = 0.400$，$\\mu_3 = 1.200$，$\\mu_5 = 2.000$，单位为原子单位。\n$\\alpha_{zz}(Q_s)$ 的系数为：$a_0 = 9.86$，$a_1 = 0.150$，$a_3 = 0.500$，$a_5 = 1.000$，单位为原子单位。\n在 $Q_s=0$ 处的真实一阶导数为 $\\left.\\partial \\mu_z/\\partial Q_s\\right|_{0} = \\mu_1 = 0.400$ 和 $\\left.\\partial \\alpha_{zz}/\\partial Q_s\\right|_{0} = a_1 = 0.150$。\n问题陈述指出，每次性质评估都受到独立的、零均值的、高斯分布的数值噪声的干扰，其标准差对于 $\\mu_z$ 为 $\\sigma_\\mu = 1.0\\times 10^{-6}$，对于 $\\alpha_{zz}$ 为 $\\sigma_\\alpha = 2.0\\times 10^{-6}$。\n任务是在三个候选方案（两点中心差分、四点中心差分、两级 Richardson 外推法）中找到最优的中心有限差分方案，并找到相应能最小化一阶导数估计的均方误差（MSE）的最优步长 $h$。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据。其背景是量子化学，特别是红外和拉曼强度的计算，这取决于偶极矩和极化率的导数。使用泰勒级数近似性质势能面是一种标准技术。在有限差分计算中权衡截断误差和数值噪声误差的概念是数值分析中的一个基本课题。该问题是适定的，提供了所有必要的函数形式、系数值和精确的噪声模型，以唯一地确定一个最优数值策略。语言客观，数据一致。该问题未违反任何无效性标准。\n\n**第3步：结论与行动**\n问题有效。将推导解答。\n\n**推导**\n目标是估计一个函数 $f(Q_s)$ 在 0 处的一阶导数 $f'(0)$，该函数具有给定的泰勒级数展开式 $f(Q_s) = f_0 + f_1 Q_s + f_2 Q_s^2/2! + f_3 Q_s^3/3! + ...$ ，其中 $f$ 的评估值受到标准差为 $\\sigma$ 的噪声影响。问题指出，展开式中除常数项外只包含 $Q_s$ 的奇次幂，因此当 $n \\ge 1$ 时 $f_{2n}=0$。所以，$f(Q_s) = f_0 + f_1 Q_s + f_3 Q_s^3/6 + f_5 Q_s^5/120 + O(Q_s^7)$。我们寻求最小化估计的均方误差(MSE)，它是截断偏差的平方与传播的噪声方差之和：$\\text{MSE} = (\\epsilon_T)^2 + \\sigma_N^2$。\n\n**方案1：两点中心差分 ($D_2$)**\n公式为 $D_2(h) = \\frac{f(h) - f(-h)}{2h}$。\n使用 $f(h)$ 和 $f(-h)$ 的泰勒级数：\n$f(h) - f(-h) = (f_0 + f_1 h + \\frac{f_3}{6}h^3 + ...) - (f_0 - f_1 h - \\frac{f_3}{6}h^3 + ...)$\n$f(h) - f(-h) = 2f_1 h + \\frac{f_3}{3} h^3 + O(h^5)$。\n$D_2(h) = f_1 + \\frac{f_3}{6}h^2 + O(h^4)$。\n主要截断误差（偏差）为 $\\epsilon_T(h) = \\frac{f_3}{6}h^2$。\n噪声方差为 $\\sigma_N^2 = \\text{Var}\\left(\\frac{f_{\\text{noisy}}(h) - f_{\\text{noisy}}(-h)}{2h}\\right) = \\frac{\\sigma^2 + \\sigma^2}{(2h)^2} = \\frac{2\\sigma^2}{4h^2} = \\frac{\\sigma^2}{2h^2}$。\n均方误差为 $\\text{MSE}(h) = \\left(\\frac{f_3}{6}h^2\\right)^2 + \\frac{\\sigma^2}{2h^2} = \\frac{f_3^2}{36}h^4 + \\frac{\\sigma^2}{2}h^{-2}$。\n对 $h$ 进行最小化：$\\frac{d(\\text{MSE})}{dh} = \\frac{4f_3^2}{36}h^3 - \\frac{2\\sigma^2}{2}h^{-3} = 0 \\implies \\frac{f_3^2}{9}h^3 = \\sigma^2h^{-3}$。\n最优步长为 $h_{\\text{opt}} = \\left(\\frac{9\\sigma^2}{f_3^2}\\right)^{1/6}$。\n\n**方案2：四点中心差分 ($D_4$)**\n公式为 $D_4(h) = \\frac{f(-2h) - 8f(-h) + 8f(h) - f(2h)}{12h}$。\n这是一个标准的 $O(h^4)$ 公式。主要截断误差为 $\\epsilon_T(h) = -\\frac{f_5}{30}h^4$。\n噪声方差为 $\\sigma_N^2 = \\text{Var}\\left(\\frac{f_{\\text{noisy}}(-2h) - 8f_{\\text{noisy}}(-h) + ...}{12h}\\right) = \\frac{1^2+8^2+8^2+1^2}{(12h)^2}\\sigma^2 = \\frac{130}{144h^2}\\sigma^2 = \\frac{65}{72h^2}\\sigma^2$。\n均方误差为 $\\text{MSE}(h) = \\left(-\\frac{f_5}{30}h^4\\right)^2 + \\frac{65\\sigma^2}{72h^2} = \\frac{f_5^2}{900}h^8 + \\frac{65\\sigma^2}{72}h^{-2}$。\n对 $h$ 进行最小化：$\\frac{d(\\text{MSE})}{dh} = \\frac{8f_5^2}{900}h^7 - \\frac{130\\sigma^2}{72}h^{-3} = 0 \\implies \\frac{f_5^2}{112.5}h^7 = \\frac{65}{36}\\sigma^2h^{-3}$。\n最优步长为 $h_{\\text{opt}} = \\left(\\frac{112.5 \\times 65}{36} \\frac{\\sigma^2}{f_5^2}\\right)^{1/10} = \\left(203.125 \\frac{\\sigma^2}{f_5^2}\\right)^{1/10}$。\n\n**方案3：两级 Richardson 外推法 ($R$)**\n此方案结合了来自 $D_2$ 方案的两个估计值：$R(h) = \\frac{4D_2(h/2) - D_2(h)}{3}$。\n主要截断误差为 $\\epsilon_T(h) = -\\frac{f_5}{480}h^4$。\n噪声方差为 $\\sigma_N^2 = \\text{Var}\\left(\\frac{4}{3}D_2(h/2) - \\frac{1}{3}D_2(h)\\right)$。假设在点 $\\pm h, \\pm h/2$ 处的噪声是独立的：\n$\\sigma_N^2 = \\left(\\frac{4}{3}\\right)^2 \\text{Var}(D_2(h/2)) + \\left(-\\frac{1}{3}\\right)^2 \\text{Var}(D_2(h)) = \\frac{16}{9} \\left(\\frac{\\sigma^2}{2(h/2)^2}\\right) + \\frac{1}{9} \\left(\\frac{\\sigma^2}{2h^2}\\right) = \\frac{16}{9}\\frac{2\\sigma^2}{h^2} + \\frac{1}{18}\\frac{\\sigma^2}{h^2} = \\left(\\frac{32}{9}+\\frac{1}{18}\\right)\\frac{\\sigma^2}{h^2} = \\frac{65}{18h^2}\\sigma^2$。\n均方误差为 $\\text{MSE}(h) = \\left(-\\frac{f_5}{480}h^4\\right)^2 + \\frac{65\\sigma^2}{18h^2} = \\frac{f_5^2}{230400}h^8 + \\frac{65\\sigma^2}{18}h^{-2}$。\n对 $h$ 进行最小化：$\\frac{d(\\text{MSE})}{dh} = \\frac{8f_5^2}{230400}h^7 - \\frac{130\\sigma^2}{18}h^{-3} = 0$。\n最优步长为 $h_{\\text{opt}} = \\left(\\frac{230400 \\times 130}{8 \\times 18} \\frac{\\sigma^2}{f_5^2}\\right)^{1/10} = \\left(208000 \\frac{\\sigma^2}{f_5^2}\\right)^{1/10}$。\n\n**方案比较与误差分析**\n现在我们将这些公式应用于两种性质，以找出每种方案的最小均方根误差 (RMSE = $\\sqrt{\\text{MSE}}$)。\n\n对于 $\\mu_z$：$f_1=\\mu_1=0.400$，$f_3=\\mu_3=1.200$，$f_5=\\mu_5=2.000$，$\\sigma=\\sigma_\\mu=1.0\\times 10^{-6}$。\n- $D_2$：$h_{\\text{opt}} = (\\frac{9(10^{-6})^2}{1.2^2})^{1/6} \\approx 0.0136$。\n    - $\\epsilon_T = \\frac{1.2}{6}(0.0136)^2 \\approx +3.70\\times 10^{-5}$。\n    - $\\sigma_N = \\sqrt{\\frac{(10^{-6})^2}{2(0.0136)^2}} \\approx 5.20\\times 10^{-5}$。\n    - RMSE = $\\sqrt{(3.70\\times 10^{-5})^2 + (5.20\\times 10^{-5})^2} \\approx 6.38\\times 10^{-5}$。\n- $D_4$：$h_{\\text{opt}} = (203.125 \\frac{(10^{-6})^2}{2.0^2})^{1/10} \\approx 0.0936$。\n    - $\\epsilon_T = -\\frac{2.0}{30}(0.0936)^4 \\approx -5.10\\times 10^{-6}$。\n    - $\\sigma_N = \\sqrt{\\frac{65(10^{-6})^2}{72(0.0936)^2}} \\approx 1.02\\times 10^{-5}$。\n    - RMSE = $\\sqrt{(-5.10\\times 10^{-6})^2 + (1.02\\times 10^{-5})^2} \\approx 1.14\\times 10^{-5}$。\n- $R$：$h_{\\text{opt}} = (208000 \\frac{(10^{-6})^2}{2.0^2})^{1/10} \\approx 0.118$。\n    - RMSE $\\approx 1.61\\times 10^{-5}$。\n\n对于 $\\alpha_{zz}$：$f_1=a_1=0.150$，$f_3=a_3=0.500$，$f_5=a_5=1.000$，$\\sigma=\\sigma_\\alpha=2.0\\times 10^{-6}$。\n- $D_2$：$h_{\\text{opt}} = (\\frac{9(2 \\times 10^{-6})^2}{0.5^2})^{1/6} \\approx 0.0229$。\n    - $\\epsilon_T = \\frac{0.5}{6}(0.0229)^2 \\approx +4.37\\times 10^{-5}$。\n    - $\\sigma_N = \\sqrt{\\frac{(2 \\times 10^{-6})^2}{2(0.0229)^2}} \\approx 6.18\\times 10^{-5}$。\n    - RMSE = $\\sqrt{(4.37\\times 10^{-5})^2 + (6.18\\times 10^{-5})^2} \\approx 7.57\\times 10^{-5}$。\n- $D_4$：$h_{\\text{opt}} = (203.125 \\frac{(2 \\times 10^{-6})^2}{1.0^2})^{1/10} \\approx 0.123$。\n    - $\\epsilon_T = -\\frac{1.0}{30}(0.123)^4 \\approx -7.63\\times 10^{-6}$。\n    - $\\sigma_N = \\sqrt{\\frac{65(2 \\times 10^{-6})^2}{72(0.123)^2}} \\approx 1.55\\times 10^{-5}$。\n    - RMSE = $\\sqrt{(-7.63\\times 10^{-6})^2 + (1.55\\times 10^{-5})^2} \\approx 1.73\\times 10^{-5}$。\n- $R$：$h_{\\text{opt}} = (208000 \\frac{(2 \\times 10^{-6})^2}{1.0^2})^{1/10} \\approx 0.156$。\n    - RMSE $\\approx 2.44\\times 10^{-5}$。\n\n**结论**\n对于这两种性质，四点中心差分 ($D_4$) 方案提供了最小的均方误差。\n对于 $\\mu_z$：最小 RMSE 约为 $\\approx 1.14\\times 10^{-5}$。\n对于 $\\alpha_{zz}$：最小 RMSE 约为 $\\approx 1.73\\times 10^{-5}$。\n因此，采用相应最优步长的 $D_4$ 方案是正确的设计。\n\n**逐项分析**\n\nA. 该选项提出了两点中心差分方案。对此方案计算出的步长和误差分析是正确的。但是，该方案并非最优，因为四点差分方案对两种性质都能产生显著更低的均方误差。因此，此选项 **不正确**。\n\nB. 该选项提出了四点中心差分方案，我的分析已确认其为最优方案。所提出的步长（$h_\\mu \\approx 0.0936, h_\\alpha \\approx 0.123$）与我们为此方案计算出的最优值相匹配。所报告的性能指标（数值不确定度、截断偏差、均方根误差和导数期望值）对于两种性质均与我的推导一致。对于 $\\partial \\mu_z/\\partial Q_s$：不确定度 $\\approx 1.02\\times 10^{-5}$，偏差 $\\approx -5.10\\times 10^{-6}$，RMSE $\\approx 1.14\\times 10^{-5}$，导数 $\\approx 0.400 - 5.10\\times 10^{-6} = 0.3999949 \\approx 0.399995$。对于 $\\partial \\alpha_{zz}/\\partial Q_s$：不确定度 $\\approx 1.55\\times 10^{-5}$，偏差 $\\approx -7.63\\times 10^{-6}$，RMSE $\\approx 1.73\\times 10^{-5}$，导数 $\\approx 0.150 - 7.63\\times 10^{-6} = 0.14999237 \\approx 0.149992$。所有数值均吻合。此选项似乎是正确的。因此，此选项 **正确**。\n\nC. 该选项提出了正确的方案（四点），但使用了一个非最优的“保守”步长 $h=0.0200$。虽然针对此特定步长的误差分析在算术上是正确的，但这个选择并不能最小化均方误差。由此产生的均方根误差远大于选项B中采用最优步长所能达到的值。因此，此选项 **不正确**。\n\nD. 该选项提出了 Richardson 外推法。我的分析表明，与四点公式相比，该方案是次优的。此外，该选项错误地使用了四点公式的最优步长（$h_\\mu \\approx 0.0936, h_\\alpha \\approx 0.123$）而不是 Richardson 外推法的正确最优步长（$h_\\mu \\approx 0.118, h_\\alpha \\approx 0.156$）。至关重要的是，它接着使用了四点方案的噪声传播公式（$\\sigma_N \\propto 1/h$）而不是 Richardson 外推法的正确公式（$\\sigma_N \\propto 1/h$），从而导致了错误的数值不确定度值。因此，此选项存在根本性缺陷且 **不正确**。", "answer": "$$\\boxed{B}$$", "id": "2898195"}, {"introduction": "得到一张包含频率和强度的谱图列表只是分析的开始，真正的洞见来自于理解每个谱峰对应的具体分子运动。然而，从头计算得到的简正模式是所有原子在笛卡尔坐标下的集体运动，缺乏直观的化学意义。本练习 [@problem_id:2898215] 介绍了一种关键的诠释技术：将抽象的简正模式定量地投影到一组化学家所熟悉的内坐标基底上（如键伸缩、角弯曲等）。通过这种方法，我们可以明确地分析出某个振动模式的成分，例如，“该模式包含80%的C=O伸缩和20%的C-C-O弯曲”，从而将计算结果与化学直觉联系起来。", "problem": "设计并实现一个完整的程序，该程序执行基于基本原理的灵敏度分析，通过将性质导数投影到内坐标方向上，来确定哪些内坐标在给定振动模式的红外（IR）或拉曼（Raman）强度中占主导地位。您的推导和算法必须从量子化学和线性代数的基本原理出发，并且除了标准的、经过充分检验的定义外，不得假定任何特殊公式。对于每个测试用例，程序必须执行以下任务，并返回单个最主要内坐标的索引（从零开始）。\n\n您必须使用的基本出发点：\n- 一个简正模式的红外强度与分子偶极矩沿该模式方向的方向导数的平方成正比。如果 $g \\in \\mathbb{R}^{M}$ 表示一个标量偶极矩分量相对于原子核笛卡尔坐标的笛卡尔梯度，而 $v \\in \\mathbb{R}^{M}$ 是笛卡尔简正模式方向（在此问题中，不一定需经质量加权），那么根据链式法则，方向导数为 $g \\cdot v$，强度则与 $\\left(g \\cdot v\\right)^{2}$ 成正比。\n- 一个简正模式的拉曼活性由极化率导数张量的转动不变量得到。如果 $\\alpha' \\in \\mathbb{R}^{3 \\times 3}$ 是沿该模式的极化率导数张量，则标准的随机取向拉曼活性与 $45\\,a^{2} + 7\\,\\gamma^{2}$ 成正比，其中 $a = \\tfrac{1}{3}\\operatorname{Tr}(\\alpha')$ 是各向同性不变量，而 $\\gamma^{2}$ 是由该张量的对称分量构建的各向异性不变量。张量 $\\alpha'$ 由每个坐标的张量导数 $\\{A_{i}\\}_{i=1}^{M}$ 和模式分量 $\\{v_{i}\\}_{i=1}^{M}$ 线性生成，即 $\\alpha' = \\sum_{i=1}^{M} v_{i} A_{i}$。\n\n您必须实现的投影框架和灵敏度定义：\n- 给定笛卡尔空间中的 $K$ 个内坐标方向向量，它们作为矩阵 $D \\in \\mathbb{R}^{M \\times K}$ 的列 $\\{d_{k}\\}_{k=1}^{K}$ 组合而成。假设 $D$ 是列满秩的。通过求解 $S\\,c = D^{\\top} v$ 来定义格拉姆矩阵 (Gram matrix) $S = D^{\\top} D \\in \\mathbb{R}^{K \\times K}$ 和内坐标分解系数 $c \\in \\mathbb{R}^{K}$。这将在内坐标方向所张成的空间内，产生模式方向 $v$ 的唯一分解：$v = \\sum_{k=1}^{K} c_{k}\\, d_{k}$。\n- 对于红外灵敏度：将内坐标 $k$ 对模式偶极矩方向导数的带符号贡献定义为 $t_{k} = g \\cdot \\left(c_{k} d_{k}\\right)$。使用与强度相关的灵敏度权重 $s_{k} = t_{k}^{2}$ 来对主导性进行排序。占主导地位的内坐标是使 $s_{k}$ 最大化的索引 $k$。\n- 对于拉曼灵敏度：令 $\\alpha' = \\sum_{i=1}^{M} v_{i} A_{i}$，并令 $S_{\\mathrm{R}}(\\alpha')$ 表示从 $\\alpha'$ 构建的、与 $45\\,a^{2} + 7\\,\\gamma^{2}$ 成正比的活性。通过计算张量梯度 $\\nabla_{\\alpha'} S_{\\mathrm{R}}(\\alpha')$ 和带符号的线性贡献 $L_{k} = \\langle \\alpha'_{(k)}, \\nabla_{\\alpha'} S_{\\mathrm{R}}(\\alpha') \\rangle$，使用围绕 $\\alpha'$ 的一阶（线性化）灵敏度，其中 $\\langle X,Y\\rangle = \\sum_{a,b} X_{ab} Y_{ab}$ 是弗罗贝尼乌斯内积（Frobenius inner product）。定义内坐标分辨的张量贡献为 $\\alpha'_{(k)} = \\sum_{i=1}^{M} (c_{k}\\, d_{k,i})\\, A_{i}$。通过最大的线性化贡献绝对值 $\\lvert L_{k} \\rvert$ 来对主导性进行排序。\n\n测试套件的输入数据：\n- 所有数值均解释为无量纲的、以任意一致单位表示。无需进行物理单位转换。\n- 在拉曼案例中，您必须将所有矩阵视为对称的 $3 \\times 3$ 张量。\n\n实现您的程序以处理以下三个测试用例，每个用例由 $(D, v, \\text{type}, \\text{properties})$ 指定：\n\n1) 红外，标准正交内坐标方向：\n- $M = 4$, $K = 3$。\n- $D = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & 0\n\\end{bmatrix}$ 其列为 $d_{1} = (1,0,0,0)^{\\top}$， $d_{2} = (0,1,0,0)^{\\top}$，$d_{3} = (0,0,1,0)^{\\top}$。\n- $v = \\left(\\tfrac{1}{\\sqrt{2}}, \\tfrac{1}{\\sqrt{2}}, 0, 0\\right)^{\\top}$。\n- 红外性质梯度 $g = (2.0, -1.0, 0.5, 3.0)^{\\top}$。\n- 确定具有最大 $s_{k}$ 的索引 $k \\in \\{0,1,2\\}$。\n\n2) 红外，非正交内坐标方向：\n- $M = 3$, $K = 3$。\n- 列 $d_{1} = (1,0,0)^{\\top}$，$d_{2} = (1,1,0)^{\\top}$，$d_{3} = (0,1,1)^{\\top}$，因此按所述列组装后 $D = \\begin{bmatrix}1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 0 & 0 & 1\\end{bmatrix}$（等效于上面列出的三个 $d_{k}$ 向量）。\n- $v = (1,2,1)^{\\top}$。\n- 红外性质梯度 $g = (0.5, -0.2, 0.8)^{\\top}$。\n- 确定具有最大 $s_{k}$ 的索引 $k \\in \\{0,1,2\\}$。\n\n3) 拉曼，线性化灵敏度：\n- $M = 2$, $K = 2$。\n- 列 $d_{1} = (1,0)^{\\top}$，$d_{2} = (1,1)^{\\top}$，因此按所述列组装后 $D = \\begin{bmatrix}1 & 1 \\\\ 0 & 1\\end{bmatrix}$（等效于上面列出的两个 $d_{k}$ 向量）。\n- $v = (2,1)^{\\top}$。\n- 每个坐标的对称极化率导数张量：\n  $A_{1} = \\begin{bmatrix}\n1.0 & 0.2 & 0.0 \\\\\n0.2 & 0.5 & 0.1 \\\\\n0.0 & 0.1 & 0.3\n\\end{bmatrix}$ 和\n  $A_{2} = \\begin{bmatrix}\n0.3 & 0.0 & 0.1 \\\\\n0.0 & 0.7 & 0.2 \\\\\n0.1 & 0.2 & 0.4\n\\end{bmatrix}$。\n- 构建 $\\alpha' = v_{1} A_{1} + v_{2} A_{2}$，计算活性 $S_{\\mathrm{R}}(\\alpha') \\propto 45\\,a^{2} + 7\\,\\gamma^{2}$，形成 $\\nabla_{\\alpha'} S_{\\mathrm{R}}(\\alpha')$，然后从上面定义的投影贡献 $\\alpha'_{(k)}$ 中计算出 $k \\in \\{0,1\\}$ 的 $L_{k}$。确定具有最大 $\\lvert L_{k} \\rvert$ 的索引。\n\n最终输出规范：\n- 您的程序必须按顺序处理所有三个案例，并生成一行输出，其中包含三个从零开始的主导索引，格式为逗号分隔的列表，并用方括号括起来，无空格，例如 $[i_{1},i_{2},i_{3}]$。", "solution": "该问题是计算量子化学中一个有效且定义明确的练习，要求应用线性代数和微分学来分析振动光谱强度。它在科学上植根于红外（IR）和拉曼光谱学的基本原理，并提供了一套完整、自洽的定义和数据。我们现在将进行严谨的、基于第一性原理的推导和算法求解。\n\n核心任务是将一个由笛卡尔位移向量 $v \\in \\mathbb{R}^{M}$ 表示的振动模式的强度，归因于一组 $K$ 个预定义的内坐标。这些内坐标代表物理上直观的运动，如键的伸缩或角的弯曲，并以相同 $M$ 维笛卡尔空间中的方向向量 $\\{d_k\\}_{k=0}^{K-1}$ 给出。它们构成了矩阵 $D \\in \\mathbb{R}^{M \\times K}$ 的列。一个基本步骤是将模式向量 $v$ 分解为沿这些内坐标方向的分量。由于问题规定 $v$ 位于 $D$ 的列所张成的空间内，我们寻求唯一的系数 $c \\in \\mathbb{R}^{K}$，使得 $v = \\sum_{k=0}^{K-1} c_k d_k$，或以矩阵形式表示为 $v = Dc$。\n\n为了找到这些系数，我们采用标准的投影形式。从左侧乘以 $D^\\top$ 得到 $D^\\top v = D^\\top D c$。我们定义格拉姆矩阵 $S = D^\\top D \\in \\mathbb{R}^{K \\times K}$，它编码了内坐标向量之间的重叠。待解的系统是正规方程 $Sc = D^\\top v$。问题陈述保证了 $D$ 是列满秩的，这确保了格拉姆矩阵 $S$ 是对称、正定且因此可逆的。因此，系数的唯一解为 $c = S^{-1}(D^\\top v)$。这个向量 $c$ 提供了模式 $v$ 在内坐标基底下的唯一表示。\n\n有了这个分解，我们就可以分析红外和拉曼强度。\n\n**红外（IR）灵敏度分析**\n\n一个振动模式的红外强度与分子偶极矩沿该模式方向的变化量的平方成正比。给定偶极矩分量相对于笛卡尔坐标的梯度 $g \\in \\mathbb{R}^{M}$ 和模式向量 $v$，方向导数由标量积 $g \\cdot v$ 给出。强度与 $(g \\cdot v)^2$ 成正比。\n\n为了确定每个内坐标的贡献，我们代入 $v$ 的分解：\n$$\ng \\cdot v = g \\cdot \\left(\\sum_{k=0}^{K-1} c_k d_k\\right) = \\sum_{k=0}^{K-1} c_k (g \\cdot d_k)\n$$\n问题将第 $k$ 个内坐标的带符号贡献定义为这个和的第 $k$ 项，即 $t_k = c_k (g \\cdot d_k)$。该项表示梯度 $g$ 在对应于内坐标 $d_k$ 的模式向量 $v$ 的分量上的投影，并由系数 $c_k$ 缩放。总偶极矩导数是这些单独贡献之和，即 $\\sum_k t_k$。\n\n第 $k$ 个坐标的灵敏度权重被定义为 $s_k = t_k^2$。这个量隔离了每一项的平方大小，忽略了交叉项 ($t_j t_k, j \\neq k$)，从而为该坐标对总强度的重要性提供了一个直接的度量。占主导地位的内坐标被确定为具有最大灵敏度权重 $s_k$ 的那一个。\n\n一个红外案例的完整算法如下：\n1.  根据给定数据构建矩阵 $D$、向量 $v$ 和 $g$。\n2.  计算格拉姆矩阵 $S = D^\\top D$。\n3.  计算向量 $b = D^\\top v$。\n4.  求解线性系统 $Sc = b$ 以找到系数向量 $c$。\n5.  对于每个内坐标索引 $k = 0, \\ldots, K-1$，计算灵敏度权重 $s_k = (c_k (g \\cdot d_k))^2$。\n6.  结果是使 $s_k$ 最大化的索引 $k$。\n\n**拉曼灵敏度分析**\n\n拉曼活性源于分子极化率张量 $\\alpha$ 在振动过程中的变化。对于一个模式 $v$，这种变化由极化率导数张量 $\\alpha' = \\sum_{i=0}^{M-1} v_i A_i$ 捕捉，其中 $A_i$ 是极化率张量相对于第 $i$ 个笛卡尔坐标的导数。\n\n对于随机取向的分子，拉曼活性 $S_R$ 与 $45a^2 + 7\\gamma^2$ 成正比，其中 $a$ 是 $\\alpha'$ 的各向同性不变量，$\\gamma^2$ 是其各向异性不变量。我们将活性函数（不计常数因子）定义为 $S_R(\\alpha') = 45a^2 + 7\\gamma^2$。对于一个对称张量 $\\alpha'$，这些不变量由 $a = \\frac{1}{3}\\operatorname{Tr}(\\alpha')$ 和 $\\gamma^2 = \\frac{3}{2}\\operatorname{Tr}(\\alpha'^2) - \\frac{1}{2}(\\operatorname{Tr}(\\alpha'))^2$ 给出。将这些代入活性表达式并简化，得到一个更方便的形式：\n$$\nS_R(\\alpha') = 1.5 (\\operatorname{Tr}(\\alpha'))^2 + 10.5 \\operatorname{Tr}(\\alpha'^2)\n$$\n拉曼案例的灵敏度分析基于一个线性化模型。我们首先计算活性函数 $S_R$ 相对于张量 $\\alpha'$ 的梯度，记为 $\\nabla_{\\alpha'} S_R(\\alpha')$。使用对称矩阵的矩阵微积分标准法则（$\\nabla_X \\operatorname{Tr}(X) = I$ 和 $\\nabla_X \\operatorname{Tr}(X^2) = 2X$），我们得到梯度张量 $G$：\n$$\nG = \\nabla_{\\alpha'} S_R(\\alpha') = 1.5 \\cdot (2 \\operatorname{Tr}(\\alpha') I) + 10.5 \\cdot (2\\alpha') = 3 \\operatorname{Tr}(\\alpha') I + 21 \\alpha'\n$$\n接下来，我们确定由每个内坐标 $k$ 产生的极化率导数张量 $\\alpha'$ 部分。使用分解 $v = \\sum_k c_k d_k$，我们定义分辨的张量贡献：\n$$\n\\alpha'_{(k)} = \\sum_{i=0}^{M-1} (c_k d_{k,i}) A_i\n$$\n其中 $d_{k,i}$ 是向量 $d_k$ 的第 $i$ 个分量。注意这些贡献是可加的：$\\sum_k \\alpha'_{(k)} = \\alpha'$。\n\n坐标 $k$ 的带符号线性贡献 $L_k$ 是通过将其张量贡献 $\\alpha'_{(k)}$ 投影到梯度张量 $G$ 上来定义的。这对应于 $S_R$ 的泰勒展开中的一阶项，并使用弗罗贝尼乌斯内积（Frobenius inner product）$\\langle X, Y \\rangle = \\sum_{a,b} X_{ab} Y_{ab}$ 计算：\n$$\nL_k = \\langle \\alpha'_{(k)}, G \\rangle\n$$\n占主导地位的内坐标是其绝对贡献 $|\\lvert L_k \\rvert|$ 最大的那一个。\n\n一个拉曼案例的完整算法如下：\n1.  构建 $D$、 $v$ 和张量集 $\\{A_i\\}$。\n2.  通过求解 $Sc = D^\\top v$ 来计算系数 $c$，如同红外案例一样。\n3.  计算总极化率导数张量 $\\alpha' = \\sum_{i=0}^{M-1} v_i A_i$。\n4.  计算梯度张量 $G = 3 \\operatorname{Tr}(\\alpha') I + 21 \\alpha'$。\n5.  对于每个索引 $k = 0, \\ldots, K-1$：\n    a. 构建分辨的张量贡献 $\\alpha'_{(k)} = c_k \\sum_{i=0}^{M-1} d_{k,i} A_i$。\n    b. 计算灵敏度 $L_k = \\langle \\alpha'_{(k)}, G \\rangle$。\n6.  结果是使 $|\\lvert L_k \\rvert|$ 最大化的索引 $k$。\n\n这个基于原理的框架提供了一种系统而定量的方法，用于根据化学上直观的内坐标来解释复杂的振动模式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_ir(D, v, g):\n    \"\"\"\n    Performs IR sensitivity analysis for a single vibrational mode.\n\n    Args:\n        D (np.ndarray): Matrix (M x K) of internal coordinate direction vectors.\n        v (np.ndarray): Cartesian normal mode vector (M-dim).\n        g (np.ndarray): Cartesian dipole gradient vector (M-dim).\n\n    Returns:\n        int: The zero-based index of the dominant internal coordinate.\n    \"\"\"\n    M, K = D.shape\n    \n    # Step 1: Solve for internal coordinate coefficients c\n    S = D.T @ D  # Gram matrix S = D^T * D\n    D_T_v = D.T @ v\n    c = np.linalg.solve(S, D_T_v)\n    \n    # Step 2: Calculate sensitivity weights s_k for each coordinate\n    s = np.zeros(K)\n    for k in range(K):\n        d_k = D[:, k]\n        g_dot_d_k = np.dot(g, d_k)\n        t_k = c[k] * g_dot_d_k\n        s[k] = t_k**2\n        \n    # Step 3: Find the index of the maximum sensitivity weight\n    return np.argmax(s)\n\ndef analyze_raman(D, v, A_tensors):\n    \"\"\"\n    Performs Raman sensitivity analysis for a single vibrational mode.\n\n    Args:\n        D (np.ndarray): Matrix (M x K) of internal coordinate direction vectors.\n        v (np.ndarray): Cartesian normal mode vector (M-dim).\n        A_tensors (list of np.ndarray): List of M per-coordinate polarizability\n                                       derivative tensors (3x3).\n\n    Returns:\n        int: The zero-based index of the dominant internal coordinate.\n    \"\"\"\n    M, K = D.shape\n    \n    # Step 1: Solve for internal coordinate coefficients c\n    S = D.T @ D\n    D_T_v = D.T @ v\n    c = np.linalg.solve(S, D_T_v)\n    \n    # Step 2: Compute the total polarizability derivative tensor alpha_prime\n    alpha_prime = np.zeros((3, 3))\n    for i in range(M):\n        alpha_prime += v[i] * A_tensors[i]\n        \n    # Step 3: Compute the gradient tensor G\n    trace_alpha_prime = np.trace(alpha_prime)\n    identity_3x3 = np.eye(3)\n    G = 3 * trace_alpha_prime * identity_3x3 + 21 * alpha_prime\n    \n    # Step 4: Calculate linearized sensitivity L_k for each coordinate\n    L = np.zeros(K)\n    for k in range(K):\n        d_k = D[:, k]\n        \n        # Compute the resolved tensor contribution alpha_prime_(k)\n        alpha_prime_k = np.zeros((3, 3))\n        for i in range(M):\n            alpha_prime_k += d_k[i] * A_tensors[i]\n        alpha_prime_k *= c[k]\n        \n        # Compute the Frobenius inner product <alpha_prime_(k), G>\n        L[k] = np.sum(alpha_prime_k * G)\n        \n    # Step 5: Find the index of the maximum absolute sensitivity |L_k|\n    return np.argmax(np.abs(L))\n\ndef solve():\n    \"\"\"\n    Processes all test cases and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1: IR, orthonormal\n        {\n            \"type\": \"IR\",\n            \"D\": np.array([\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"v\": np.array([1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0, 0.0]),\n            \"properties\": {\"g\": np.array([2.0, -1.0, 0.5, 3.0])}\n        },\n        # Case 2: IR, non-orthogonal\n        {\n            \"type\": \"IR\",\n            \"D\": np.array([\n                [1.0, 1.0, 0.0],\n                [0.0, 1.0, 1.0],\n                [0.0, 0.0, 1.0]\n            ]),\n            \"v\": np.array([1.0, 2.0, 1.0]),\n            \"properties\": {\"g\": np.array([0.5, -0.2, 0.8])}\n        },\n        # Case 3: Raman, linearized\n        {\n            \"type\": \"Raman\",\n            \"D\": np.array([\n                [1.0, 1.0],\n                [0.0, 1.0]\n            ]),\n            \"v\": np.array([2.0, 1.0]),\n            \"properties\": {\"A_tensors\": [\n                np.array([\n                    [1.0, 0.2, 0.0],\n                    [0.2, 0.5, 0.1],\n                    [0.0, 0.1, 0.3]\n                ]),\n                np.array([\n                    [0.3, 0.0, 0.1],\n                    [0.0, 0.7, 0.2],\n                    [0.1, 0.2, 0.4]\n                ])\n            ]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"IR\":\n            result = analyze_ir(case[\"D\"], case[\"v\"], case[\"properties\"][\"g\"])\n        elif case[\"type\"] == \"Raman\":\n            result = analyze_raman(case[\"D\"], case[\"v\"], case[\"properties\"][\"A_tensors\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2898215"}, {"introduction": "理论计算的最终检验标准是其预测与实验结果的吻合程度。然而，将计算得到的“谱线”光谱与实验测量的连续吸收光谱直接比较是过于简化的。我们必须系统地处理理论模型（如谐振子近似）带来的系统性偏差和实验本身的复杂性（如基线漂移、峰展宽）。本练习 [@problem_id:2898174] 要求你编写一个完整的程序化方案，通过频率缩放、基线校正和谱线展宽等步骤，实现理论与实验光谱的稳健拟合与定量评估。这是连接理论模型与真实世界的桥梁，也是验证计算方法有效性的关键一步。", "problem": "您的任务是设计并实现一个方案，用于以定量、可复现和算法化的方式，比较计算出的红外（IR）强度与实验测得的摩尔吸光系数。该方案必须包含谐波频率的缩放、基线校正以及明确定义的符合度量。您的实现必须是一个完整的、可运行的程序，它不接受任何输入，而是评估下面指定的固定测试套件。程序必须根据本问题陈述中的规则，人工合成实验光谱，然后计算最佳拟合参数和符合度量。\n\n从以下基本定义和事实开始：\n\n- Beer–Lambert 定律指出 $A(\\tilde{\\nu}) = \\epsilon(\\tilde{\\nu}) \\, c \\, \\ell$，其中 $A(\\tilde{\\nu})$ 是吸光度，$\\epsilon(\\tilde{\\nu})$ 是以 $\\mathrm{L\\,mol^{-1}\\,cm^{-1}}$ 为单位的摩尔吸光系数，$c$ 是以 $\\mathrm{mol\\,L^{-1}}$ 为单位的浓度，$\\ell$ 是以 $\\mathrm{cm}$ 为单位的光程长度，$\\tilde{\\nu}$ 是以 $\\mathrm{cm^{-1}}$ 为单位的波数。\n- 计算得到的谐波红外光谱表现为一系列位于谐波波数 $\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\}$ 处的谱线，其权重为谱线强度 $\\{I_i\\}$ （例如，单位为 $\\mathrm{km\\,mol^{-1}}$）。\n- 实验光谱包含基线漂移，在一个有限的光谱窗口内，该漂移可以通过线性基线 $b(\\tilde{\\nu}) = \\beta_0 + \\beta_1 \\tilde{\\nu}$ 很好地描述。\n- 根据经验，谐波频率需要一个全局缩放因子 $s$ 来近似非谐的实验峰位。展宽通过与一个宽度（标准差）为 $\\sigma$ （单位为 $\\mathrm{cm^{-1}}$）的高斯函数进行卷积来建模。\n- 为了与摩尔吸光系数进行比较，使用一个未知的比例因子 $\\alpha$ 将谱线光谱转换为吸光系数标度。这避免了对外部校准常数的依赖，并与 Beer–Lambert 定律保持一致。\n\n数学上，定义高斯核函数\n$$\n\\mathcal{G}(\\Delta; \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{\\Delta^2}{2\\sigma^2}\\right),\n$$\n以及模拟光谱\n$$\n\\hat{\\epsilon}(\\tilde{\\nu}; s,\\alpha,\\sigma) = \\alpha \\sum_{i} I_i \\, \\mathcal{G}\\!\\left(\\tilde{\\nu} - s \\tilde{\\nu}_i^{\\mathrm{harm}}; \\sigma\\right).\n$$\n在一个网格 $\\{\\tilde{\\nu}_k\\}$ 上，建模的实验信号为\n$$\ny_{\\mathrm{model}}(\\tilde{\\nu}_k) = \\hat{\\epsilon}(\\tilde{\\nu}_k; s,\\alpha,\\sigma) + \\beta_0 + \\beta_1 \\tilde{\\nu}_k.\n$$\n\n您的程序必须基于上述定义，实现以下方案：\n\n1.  给定集合 $\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\}$ 和 $\\{I_i\\}$、一个波数网格 $\\{\\tilde{\\nu}_k\\}$ 以及一个人工合成的实验光谱 $y_{\\mathrm{exp}}(\\tilde{\\nu}_k)$ （按测试套件中的描述构建），通过最小化残差平方和\n    $$\n    \\Phi(s,\\alpha,\\beta_0,\\beta_1,\\sigma) = \\sum_k \\left[y_{\\mathrm{exp}}(\\tilde{\\nu}_k) - y_{\\mathrm{model}}(\\tilde{\\nu}_k)\\right]^2,\n    $$\n    来计算最佳拟合缩放因子 $s$、振幅因子 $\\alpha$、基线参数 $(\\beta_0,\\beta_1)$，以及一个选定的高斯宽度 $\\sigma$。\n2.  将 $s$ 视为一个约束在 $s \\in [0.94, 1.02]$ 内的连续变量。将 $\\sigma$ 视为从一个离散候选集 $\\{\\sigma_j\\}$ 中选择。对于任何固定的 $s$ 和 $\\sigma$，利用 $y_{\\mathrm{model}}$ 关于 $(\\alpha,\\beta_0,\\beta_1)$ 是线性的这一事实，通过线性最小二乘法确定 $(\\alpha,\\beta_0,\\beta_1)$。\n3.  在获得最小化参数 $(\\hat{s},\\hat{\\sigma},\\hat{\\alpha},\\hat{\\beta}_0,\\hat{\\beta}_1)$ 后，计算以下定量指标：\n    - 经基线校正的实验光谱 $\\tilde{y}(\\tilde{\\nu}_k) = y_{\\mathrm{exp}}(\\tilde{\\nu}_k) - \\hat{\\beta}_0 - \\hat{\\beta}_1 \\tilde{\\nu}_k$ 与模拟吸光系数 $\\hat{\\epsilon}(\\tilde{\\nu}_k; \\hat{s},\\hat{\\alpha},\\hat{\\sigma})$ 之间的皮尔逊相关系数 $r$。\n    - 峰位均方根偏差（RMSD），单位为 $\\mathrm{cm^{-1}}$，通过下文定义的容差 $\\Delta$ 进行最近邻匹配指认后计算。将预测峰位定义为 $\\{\\hat{s}\\,\\tilde{\\nu}_i^{\\mathrm{harm}}\\}$。将实验峰检测为 $\\tilde{y}(\\tilde{\\nu}_k)$ 的局部最大值。将每个预测峰指认给容差 $\\Delta$ 内最近的实验峰，并计算\n      $$\n      \\mathrm{RMSD} = \\sqrt{\\frac{1}{N_{\\mathrm{match}}}\\sum_{m=1}^{N_{\\mathrm{match}}} \\left(\\tilde{\\nu}^{\\mathrm{(pred)}}_m - \\tilde{\\nu}^{\\mathrm{(exp)}}_m\\right)^2}.\n      $$\n      如果 $N_{\\mathrm{match}}=0$，则报告 RMSD 的哨兵值为 $9999.0$。\n    - 归一化 $\\ell_2$ 误差\n      $$\n      E_{\\mathrm{norm}} = \\frac{\\left\\|\\tilde{y} - \\hat{\\epsilon}(\\cdot; \\hat{s},\\hat{\\alpha},\\hat{\\sigma})\\right\\|_2}{\\left\\|\\tilde{y}\\right\\|_2}.\n      $$\n4.  定义一个通过/失败诊断如下：如果 $r \\ge 0.95$、$\\mathrm{RMSD} \\le 12$ （单位为 $\\mathrm{cm^{-1}}$）且 $E_{\\mathrm{norm}} \\le 0.5$，则返回一个通过指示符。否则返回一个失败指示符。\n\n您的程序必须实现稳健的实验峰局部最大值检测，如下所示：如果 $\\tilde{y}(\\tilde{\\nu}_{k-1}) < \\tilde{y}(\\tilde{\\nu}_k)$ 且 $\\tilde{y}(\\tilde{\\nu}_k) > \\tilde{y}(\\tilde{\\nu}_{k+1})$，并且 $\\tilde{y}(\\tilde{\\nu}_k)$ 超过由 $0.1 \\times \\max_k \\tilde{y}(\\tilde{\\nu}_k)$ 给出的凸显阈值，则网格点 $\\tilde{\\nu}_k$ 是一个峰。在容差 $\\Delta = 20\\,\\mathrm{cm^{-1}}$ 内使用最近邻贪婪匹配。\n\n测试套件规范。对于每个测试案例，您将获得以 $\\mathrm{cm^{-1}}$ 为单位的谐波频率、以 $\\mathrm{km\\,mol^{-1}}$ 为单位的强度、以 $\\mathrm{cm^{-1}}$ 为单位的波数网格，以及合成实验光谱的步骤：\n- 计算无噪声的实验信号 $y_0(\\tilde{\\nu}_k) = \\alpha_{\\mathrm{true}}\\sum_i I_i \\,\\mathcal{G}(\\tilde{\\nu}_k - s_{\\mathrm{true}} \\tilde{\\nu}_i^{\\mathrm{harm}};\\sigma_{\\mathrm{true}}) + \\beta_{0,\\mathrm{true}} + \\beta_{1,\\mathrm{true}} \\tilde{\\nu}_k$。\n- 向每个网格点添加零均值和标准差为 $\\eta_{\\mathrm{true}}$ 的独立高斯噪声，以获得 $y_{\\mathrm{exp}}$。\n- 如下文指定，使用固定的随机数生成器种子以保证可复现性。\n\n使用高斯宽度 $\\{\\sigma\\} = \\{5, 8, 10, 12, 15\\}$（单位 $\\mathrm{cm^{-1}}$）的离散候选集。约束 $s \\in [0.94, 1.02]$。使用峰匹配容差 $\\Delta = 20$（单位 $\\mathrm{cm^{-1}}$）。\n\n提供四个测试案例：\n\n- 案例 1：\n  - 谐波频率 $\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\} = \\{1100, 1450, 1750, 2950\\}$。\n  - 强度 $\\{I_i\\} = \\{120, 80, 150, 60\\}$。\n  - 网格 $\\tilde{\\nu}_k$ 从 $800$ 到 $3200$，步长为 $2$ $\\mathrm{cm^{-1}}$。\n  - 合成参数： $s_{\\mathrm{true}} = 0.965$，$\\sigma_{\\mathrm{true}} = 10$，$\\alpha_{\\mathrm{true}} = 1.8\\times 10^{-3}$，$\\beta_{0,\\mathrm{true}} = 0.5$，$\\beta_{1,\\mathrm{true}} = -5\\times 10^{-4}$，$\\eta_{\\mathrm{true}} = 0.03$，随机种子 $12345$。\n\n- 案例 2：\n  - 谐波频率 $\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\} = \\{1000, 1012, 1600, 1615, 3050\\}$。\n  - 强度 $\\{I_i\\} = \\{60, 55, 90, 85, 40\\}$。\n  - 网格 $\\tilde{\\nu}_k$ 从 $900$ 到 $3300$，步长为 $2$ $\\mathrm{cm^{-1}}$。\n  - 合成参数： $s_{\\mathrm{true}} = 0.98$，$\\sigma_{\\mathrm{true}} = 15$，$\\alpha_{\\mathrm{true}} = 2.0\\times 10^{-3}$，$\\beta_{0,\\mathrm{true}} = 0.2$，$\\beta_{1,\\mathrm{true}} = 3\\times 10^{-4}$，$\\eta_{\\mathrm{true}} = 0.02$，随机种子 $67890$。\n\n- 案例 3：\n  - 谐波频率 $\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\} = \\{2100\\}$。\n  - 强度 $\\{I_i\\} = \\{200\\}$。\n  - 网格 $\\tilde{\\nu}_k$ 从 $1800$ 到 $2400$，步长为 $1$ $\\mathrm{cm^{-1}}$。\n  - 合成参数： $s_{\\mathrm{true}} = 1.0$，$\\sigma_{\\mathrm{true}} = 5$，$\\alpha_{\\mathrm{true}} = 1.5\\times 10^{-3}$，$\\beta_{0,\\mathrm{true}} = 0.0$，$\\beta_{1,\\mathrm{true}} = 0.0$，$\\eta_{\\mathrm{true}} = 0.01$，随机种子 $13579$。\n\n- 案例 4：\n  - 谐波频率 $\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\} = \\{900, 1200, 1500, 1800, 2100, 2400, 2700, 3000\\}$。\n  - 强度 $\\{I_i\\} = \\{30, 50, 45, 70, 65, 40, 55, 35\\}$。\n  - 网格 $\\tilde{\\nu}_k$ 从 $800$ 到 $3200$，步长为 $4$ $\\mathrm{cm^{-1}}$。\n  - 合成参数： $s_{\\mathrm{true}} = 0.97$，$\\sigma_{\\mathrm{true}} = 12$，$\\alpha_{\\mathrm{true}} = 1.2\\times 10^{-3}$，$\\beta_{0,\\mathrm{true}} = 0.0$，$\\beta_{1,\\mathrm{true}} = 1\\times 10^{-3}$，$\\eta_{\\mathrm{true}} = 0.05$，随机种子 $24680$。\n\n角度单位不适用。物理单位：波数必须以 $\\mathrm{cm^{-1}}$ 为单位，摩尔吸光系数必须以 $\\mathrm{L\\,mol^{-1}\\,cm^{-1}}$ 为单位。RMSD 必须以 $\\mathrm{cm^{-1}}$ 表示。相关系数和归一化误差是无量纲的。\n\n输出规范。对于每个案例，返回一个包含五个条目的列表：估计的缩放因子 $\\hat{s}$ （四舍五入到 $5$ 位小数）、皮尔逊相关系数 $r$ （四舍五入到 $4$ 位小数）、RMSD（单位 $\\mathrm{cm^{-1}}$，四舍五入到 $2$ 位小数）、归一化误差 $E_{\\mathrm{norm}}$ （四舍五入到 $3$ 位小数），以及一个以整数 $\\{0,1\\}$ 表示的通过/失败指示符（其中 $1$ 表示通过）。您的程序应生成单行输出，其中包含所有四个测试案例的结果，形式为由逗号分隔的各个案例列表，并用方括号括起来。例如：$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$。", "solution": "经严格审查后，所提出的问题被判定为有效。它在科学上基于振动光谱学和数值分析的原理，目标函数和约束条件清晰，问题适定，并以客观、无歧义的语言表述。它概述了一个用于定量比较计算光谱和实验红外光谱的完整、形式化的方案。我们将着手推导解决方案。\n\n问题的核心是找到一组参数 $(s, \\sigma, \\alpha, \\beta_0, \\beta_1)$，以最小化建模光谱与人工合成的实验光谱之间的残差平方和。目标函数由下式给出\n$$\n\\Phi(s, \\alpha, \\beta_0, \\beta_1, \\sigma) = \\sum_k \\left[y_{\\mathrm{exp}}(\\tilde{\\nu}_k) - y_{\\mathrm{model}}(\\tilde{\\nu}_k)\\right]^2,\n$$\n其中模型为\n$$\ny_{\\mathrm{model}}(\\tilde{\\nu}_k) = \\alpha \\left( \\sum_{i} I_i \\, \\mathcal{G}\\!\\left(\\tilde{\\nu}_k - s \\tilde{\\nu}_i^{\\mathrm{harm}}; \\sigma\\right) \\right) + \\beta_0 + \\beta_1 \\tilde{\\nu}_k.\n$$\n此处，$\\mathcal{G}$ 是高斯核函数，$\\{\\tilde{\\nu}_k\\}$ 是波数网格，$\\{\\tilde{\\nu}_i^{\\mathrm{harm}}\\}$ 是谐波频率，$\\{I_i\\}$ 是相应的强度。\n\n该优化问题展现出一种允许参数分离的结构。对于任意固定的非线性参数对，即频率缩放因子 $s$ 和展宽宽度 $\\sigma$，模型 $y_{\\mathrm{model}}$ 关于其余参数（振幅因子 $\\alpha$ 和基线系数 $\\beta_0$ 和 $\\beta_1$）是线性的。这种结构表明可以采用嵌套优化策略。\n\n首先，我们将未缩放、展宽的理论线型定义为\n$$\nS(\\tilde{\\nu}_k; s, \\sigma) = \\sum_{i} I_i \\, \\mathcal{G}\\!\\left(\\tilde{\\nu}_k - s \\tilde{\\nu}_i^{\\mathrm{harm}}; \\sigma\\right).\n$$\n模型可以重写为\n$$\ny_{\\mathrm{model}}(\\tilde{\\nu}_k) = \\alpha S(\\tilde{\\nu}_k; s, \\sigma) + \\beta_0 \\cdot 1 + \\beta_1 \\tilde{\\nu}_k.\n$$\n对于固定的 $(s, \\sigma)$，寻找最优的 $(\\alpha, \\beta_0, \\beta_1)$ 是一个标准的线性最小二乘问题。我们寻求找到参数向量 $\\mathbf{b} = [\\alpha, \\beta_0, \\beta_1]^T$，以最小化 $\\|\\mathbf{y}_{\\mathrm{exp}} - \\mathbf{X}\\mathbf{b}\\|_2^2$。设计矩阵 $\\mathbf{X}$ 的列由在网格 $\\{\\tilde{\\nu}_k\\}$ 上求值的基函数构成：\n$$\n\\mathbf{X} = \n\\begin{bmatrix}\nS(\\tilde{\\nu}_1; s, \\sigma) & 1 & \\tilde{\\nu}_1 \\\\\nS(\\tilde{\\nu}_2; s, \\sigma) & 1 & \\tilde{\\nu}_2 \\\\\n\\vdots & \\vdots & \\vdots \\\\\nS(\\tilde{\\nu}_N; s, \\sigma) & 1 & \\tilde{\\nu}_N\n\\end{bmatrix}.\n$$\n该线性系统的解由 $\\hat{\\mathbf{b}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}_{\\mathrm{exp}}$ 给出。为了稳定性，此解通过数值方法求解，例如，通过标准线性代数库中实现的 QR 分解或奇异值分解。\n\n解决了这个内部优化问题后，问题简化为寻找最优的非线性参数 $(s, \\sigma)$，以最小化由此产生的残差平方和。参数 $\\sigma$ 从一个离散候选集 $\\{\\sigma_j\\} = \\{5, 8, 10, 12, 15\\}\\,\\mathrm{cm^{-1}}$ 中选取。参数 $s$ 是区间 $[0.94, 1.02]$ 内的连续变量。总体优化流程如下：\n1.  对于离散集中的每个候选宽度 $\\sigma_j$：\n    a. 定义一个目标函数 $f(s) = \\Phi(s, \\hat{\\alpha}(s, \\sigma_j), \\hat{\\beta}_0(s, \\sigma_j), \\hat{\\beta}_1(s, \\sigma_j), \\sigma_j)$，其中带帽符号表示对于给定的 $s$ 和 $\\sigma_j$ 通过内部线性最小二乘拟合求得的参数。\n    b. 通过在有界区间 $s \\in [0.94, 1.02]$ 上最小化 $f(s)$ 来找到最优缩放因子 $s_j^*$。这是一个一维数值优化问题。\n    c. 记录达到的最小残差 $\\Phi_j^* = f(s_j^*)$。\n2.  遍历所有 $\\sigma_j$ 后，从所有 $\\{\\Phi_j^*\\}$ 中找到最小值，其对应的 $(\\hat{s}, \\hat{\\sigma})$ 即为全局最优解。\n\n一旦确定了全局最优参数 $(\\hat{s}, \\hat{\\sigma}, \\hat{\\alpha}, \\hat{\\beta}_0, \\hat{\\beta}_1)$，最后一步就是计算指定的质量指标。\n- 经基线校正的实验光谱定义为 $\\tilde{y}(\\tilde{\\nu}_k) = y_{\\mathrm{exp}}(\\tilde{\\nu}_k) - (\\hat{\\beta}_0 + \\hat{\\beta}_1 \\tilde{\\nu}_k)$。\n- 最终的模拟吸光系数光谱为 $\\hat{\\epsilon}(\\tilde{\\nu}_k) = \\hat{\\alpha} S(\\tilde{\\nu}_k; \\hat{s}, \\hat{\\sigma})$。\n- 皮尔逊相关系数 $r$ 在向量 $\\tilde{\\mathbf{y}}$ 和 $\\hat{\\mathbf{\\epsilon}}$ 之间计算。\n- 归一化 $\\ell_2$ 误差为 $E_{\\mathrm{norm}} = \\|\\tilde{\\mathbf{y}} - \\hat{\\mathbf{\\epsilon}}\\|_2 / \\|\\tilde{\\mathbf{y}}\\|_2$。\n- 峰位均方根偏差（RMSD）需要进行峰的识别和匹配。\n    - 实验峰被识别为 $\\tilde{y}(\\tilde{\\nu}_k)$ 中满足 $\\tilde{y}(\\tilde{\\nu}_{k-1}) < \\tilde{y}(\\tilde{\\nu}_k) > \\tilde{y}(\\tilde{\\nu}_{k+1})$ 且超过 $0.1 \\times \\max_k \\tilde{y}(\\tilde{\\nu}_k)$ 凸显阈值的局部最大值。\n    - 预测峰由 $\\{\\hat{s}\\,\\tilde{\\nu}_i^{\\mathrm{harm}}\\}$ 给出。\n    - 采用贪婪匹配算法：对每个预测峰，找到最近的未匹配实验峰。如果距离在容差 $\\Delta = 20\\,\\mathrm{cm^{-1}}$ 之内，则该对被视为一次匹配，并将该实验峰从后续匹配的池中移除。\n    - RMSD 在 $N_{\\mathrm{match}}$ 个匹配对上计算。如果 $N_{\\mathrm{match}} = 0$，则使用哨兵值 $9999.0$。\n最后，如果 $r \\ge 0.95$、$\\mathrm{RMSD} \\le 12\\,\\mathrm{cm^{-1}}$ 且 $E_{\\mathrm{norm}} \\le 0.5$，则诊断标志设为 $1$ (通过)；否则，设为 $0$ (失败)。\n\n对每个提供的测试案例实施这一综合方案。测试数据的人工合成性质，加上指定的真实参数和用于生成噪声的固定随机种子，确保了整个程序的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite for comparing theoretical\n    and experimental infrared spectra.\n    \"\"\"\n    \n    # Test cases as defined in the problem statement.\n    test_cases = [\n        {\n            \"nu_harm\": np.array([1100, 1450, 1750, 2950]),\n            \"I\": np.array([120, 80, 150, 60]),\n            \"grid_params\": (800, 3200, 2),\n            \"synth_params\": {\n                \"s_true\": 0.965, \"sigma_true\": 10, \"alpha_true\": 1.8e-3,\n                \"beta0_true\": 0.5, \"beta1_true\": -5e-4, \"eta_true\": 0.03,\n                \"seed\": 12345\n            }\n        },\n        {\n            \"nu_harm\": np.array([1000, 1012, 1600, 1615, 3050]),\n            \"I\": np.array([60, 55, 90, 85, 40]),\n            \"grid_params\": (900, 3300, 2),\n            \"synth_params\": {\n                \"s_true\": 0.98, \"sigma_true\": 15, \"alpha_true\": 2.0e-3,\n                \"beta0_true\": 0.2, \"beta1_true\": 3e-4, \"eta_true\": 0.02,\n                \"seed\": 67890\n            }\n        },\n        {\n            \"nu_harm\": np.array([2100]),\n            \"I\": np.array([200]),\n            \"grid_params\": (1800, 2400, 1),\n            \"synth_params\": {\n                \"s_true\": 1.0, \"sigma_true\": 5, \"alpha_true\": 1.5e-3,\n                \"beta0_true\": 0.0, \"beta1_true\": 0.0, \"eta_true\": 0.01,\n                \"seed\": 13579\n            }\n        },\n        {\n            \"nu_harm\": np.array([900, 1200, 1500, 1800, 2100, 2400, 2700, 3000]),\n            \"I\": np.array([30, 50, 45, 70, 65, 40, 55, 35]),\n            \"grid_params\": (800, 3200, 4),\n            \"synth_params\": {\n                \"s_true\": 0.97, \"sigma_true\": 12, \"alpha_true\": 1.2e-3,\n                \"beta0_true\": 0.0, \"beta1_true\": 1e-3, \"eta_true\": 0.05,\n                \"seed\": 24680\n            }\n        }\n    ]\n\n    s_bounds = (0.94, 1.02)\n    sigma_candidates = [5, 8, 10, 12, 15]\n    match_tolerance = 20.0\n\n    all_results = []\n    for case in test_cases:\n        # 1. Generate synthetic experimental spectrum\n        nu_grid = np.arange(case[\"grid_params\"][0], case[\"grid_params\"][1] + case[\"grid_params\"][2], case[\"grid_params\"][2])\n        sp = case[\"synth_params\"]\n        \n        # Noise-free spectrum\n        y0_shape = calculate_simulated_shape(nu_grid, case[\"nu_harm\"], case[\"I\"], sp[\"s_true\"], sp[\"sigma_true\"])\n        y0 = sp[\"alpha_true\"] * y0_shape + sp[\"beta0_true\"] + sp[\"beta1_true\"] * nu_grid\n        \n        # Add noise\n        rng = np.random.default_rng(sp[\"seed\"])\n        noise = rng.normal(0, sp[\"eta_true\"], size=nu_grid.shape)\n        y_exp = y0 + noise\n        \n        # 2. Find best fit parameters\n        best_fit = find_best_fit(nu_grid, y_exp, case[\"nu_harm\"], case[\"I\"], s_bounds, sigma_candidates)\n        \n        # 3. Calculate metrics\n        metrics = calculate_metrics(nu_grid, y_exp, case[\"nu_harm\"], case[\"I\"], best_fit, match_tolerance)\n        all_results.append(metrics)\n\n    # Final formatting\n    result_str_list = []\n    for res in all_results:\n        s_hat, r, rmsd, e_norm, flag = res\n        s_str = f\"{s_hat:.5f}\"\n        r_str = f\"{r:.4f}\"\n        rmsd_str = f\"{rmsd:.2f}\"\n        enorm_str = f\"{e_norm:.3f}\"\n        flag_str = str(flag)\n        result_str_list.append(f\"[{s_str},{r_str},{rmsd_str},{enorm_str},{flag_str}]\")\n    \n    print(f\"[{','.join(result_str_list)}]\")\n\ndef gaussian(delta, sigma):\n    \"\"\"Computes the Gaussian kernel.\"\"\"\n    return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * (delta / sigma)**2)\n\ndef calculate_simulated_shape(nu_grid, nu_harm, I, s, sigma):\n    \"\"\"Calculates the unscaled, broadened theoretical spectrum S(nu).\"\"\"\n    shape = np.zeros_like(nu_grid, dtype=float)\n    for nu_i, I_i in zip(nu_harm, I):\n        delta = nu_grid - s * nu_i\n        shape += I_i * gaussian(delta, sigma)\n    return shape\n\ndef find_best_fit(nu_grid, y_exp, nu_harm, I, s_bounds, sigma_candidates):\n    \"\"\"\n    Finds the optimal (s, sigma, alpha, beta0, beta1) by nested optimization.\n    \"\"\"\n    best_s = None\n    best_sigma = None\n    min_residual = np.inf\n\n    def objective_for_s(s, sigma_val):\n        # Calculate theoretical shape S(nu) for given s and sigma\n        sim_shape = calculate_simulated_shape(nu_grid, nu_harm, I, s, sigma_val)\n        \n        # Set up design matrix for linear least squares\n        X = np.vstack([sim_shape, np.ones_like(nu_grid), nu_grid]).T\n        \n        # Solve for linear parameters (alpha, beta0, beta1)\n        params, residuals, _, _ = np.linalg.lstsq(X, y_exp, rcond=None)\n        \n        return residuals[0]\n\n    for sigma in sigma_candidates:\n        res = minimize_scalar(objective_for_s, bounds=s_bounds, method='bounded', args=(sigma,))\n        if res.fun < min_residual:\n            min_residual = res.fun\n            best_s = res.x\n            best_sigma = sigma\n\n    # Re-calculate final optimal linear parameters with best s and sigma\n    final_sim_shape = calculate_simulated_shape(nu_grid, nu_harm, I, best_s, best_sigma)\n    X = np.vstack([final_sim_shape, np.ones_like(nu_grid), nu_grid]).T\n    final_params = np.linalg.lstsq(X, y_exp, rcond=None)[0]\n    \n    best_alpha, best_beta0, best_beta1 = final_params\n    \n    return {\n        \"s\": best_s, \"sigma\": best_sigma, \"alpha\": best_alpha,\n        \"beta0\": best_beta0, \"beta1\": best_beta1\n    }\n\ndef calculate_metrics(nu_grid, y_exp, nu_harm, I, fit_params, match_tolerance):\n    \"\"\"\n    Calculates Pearson r, RMSD, E_norm, and the pass/fail flag.\n    \"\"\"\n    s, sigma, alpha, b0, b1 = fit_params[\"s\"], fit_params[\"sigma\"], fit_params[\"alpha\"], fit_params[\"beta0\"], fit_params[\"beta1\"]\n\n    # Baseline-corrected experimental spectrum\n    y_corrected = y_exp - (b0 + b1 * nu_grid)\n    \n    # Final simulated absorptivity\n    epsilon_sim_shape = calculate_simulated_shape(nu_grid, nu_harm, I, s, sigma)\n    epsilon_sim = alpha * epsilon_sim_shape\n\n    # Pearson correlation coefficient\n    r = np.corrcoef(y_corrected, epsilon_sim)[0, 1]\n\n    # Normalized l2 error\n    norm_diff = np.linalg.norm(y_corrected - epsilon_sim)\n    norm_y = np.linalg.norm(y_corrected)\n    e_norm = norm_diff / norm_y if norm_y > 0 else 0.0\n\n    # RMSD of peak positions\n    # 1. Find experimental peaks\n    prominence_threshold = 0.1 * np.max(y_corrected)\n    exp_peaks_idx = []\n    for k in range(1, len(y_corrected) - 1):\n        if y_corrected[k] > y_corrected[k-1] and y_corrected[k] > y_corrected[k+1]:\n            if y_corrected[k] > prominence_threshold:\n                exp_peaks_idx.append(k)\n    exp_peaks = [nu_grid[i] for i in exp_peaks_idx]\n\n    # 2. Predicted peaks\n    pred_peaks = s * nu_harm\n    \n    # 3. Greedy nearest-neighbor matching\n    matched_pairs = []\n    unmatched_exp_peaks = list(exp_peaks)\n    \n    for p_peak in sorted(pred_peaks):\n        if not unmatched_exp_peaks:\n            break\n        distances = [abs(p_peak - e_peak) for e_peak in unmatched_exp_peaks]\n        min_dist_idx = np.argmin(distances)\n        min_dist = distances[min_dist_idx]\n        \n        if min_dist <= match_tolerance:\n            best_match_exp_peak = unmatched_exp_peaks[min_dist_idx]\n            matched_pairs.append((p_peak, best_match_exp_peak))\n            unmatched_exp_peaks.pop(min_dist_idx)\n    \n    # 4. Calculate RMSD\n    if not matched_pairs:\n        rmsd = 9999.0\n    else:\n        sum_sq_err = sum([(p - e)**2 for p, e in matched_pairs])\n        rmsd = np.sqrt(sum_sq_err / len(matched_pairs))\n\n    # Pass/Fail diagnostic\n    pass_flag = 1 if (r >= 0.95 and rmsd <= 12.0 and e_norm <= 0.5) else 0\n\n    return s, r, rmsd, e_norm, pass_flag\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2898174"}]}