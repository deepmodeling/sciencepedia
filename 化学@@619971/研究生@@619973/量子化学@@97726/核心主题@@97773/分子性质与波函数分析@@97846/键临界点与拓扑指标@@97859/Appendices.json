{"hands_on_practices": [{"introduction": "我们将从最基本的任务开始：在一个简单的理想化体系中，通过解析方法验证键临界点 (bond critical point, BCP) 的性质。这项练习将通过直接计算电子密度的梯度和Hessian矩阵，来巩固构成BCP的核心定义。这是从理论走向实践的关键第一步，它清晰地揭示了在分子中的原子理论 (QTAIM) 框架下共价键的数学特征 [@problem_id:2876140]。", "problem": "考虑一个沿 $z$ 轴排列的同核双原子分子，其模型由一个具有柱对称性的解析电子密度给出：\n$$\n\\rho(x,y,z) \\;=\\; A\\left[\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z-\\frac{R}{2}\\right)^{2}\\right)\\right) \\;+\\; \\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z+\\frac{R}{2}\\right)^{2}\\right)\\right)\\right],\n$$\n其中 $A>0$、$\\alpha>0$ 且 $R>0$。计算在原子单位制下进行，其中长度单位为玻尔半径 $a_{0}$，电子密度单位为 $a_{0}^{-3}$，密度的 Hessian 矩阵元单位为 $a_{0}^{-5}$。使用以下参数值：$A=1.0\\,a_{0}^{-3}$、$\\alpha=1.0\\,a_{0}^{-2}$ 和 $R=2.0\\,a_{0}$。在分子中原子的量子理论 (Quantum Theory of Atoms in Molecules, QTAIM) 中，键临界点 (bond critical point, BCP) 是指电子密度的梯度 $\\nabla \\rho(\\mathbf{r})$ 为零，且密度的 Hessian 矩阵 $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$ 的特征值具有两个垂直于键轴的负曲率和一个沿着键轴的正曲率的点。\n\n从临界点和标量场的 Hessian 矩阵的基本定义出发：\n- 临界点满足 $\\nabla \\rho(\\mathbf{r})=\\mathbf{0}$。\n- Hessian 矩阵是一个 $3\\times 3$ 矩阵，其矩阵元为 $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$。\n- $H$ 的特征值决定了 $\\rho$ 的局部曲率。\n\n完成以下任务：\n1. 根据对称性并通过直接计算一阶导数，找出给定 $\\rho(x,y,z)$ 沿核间轴的键临界点。\n2. 计算在该点的 Hessian 矩阵 $H_{ij}$。\n3. 确定其三个特征值，并利用它们的符号来确定该点在 QTAIM 意义下的拓扑类型。\n\n将排序后的特征值 $\\lambda_{1}\\le \\lambda_{2}\\le \\lambda_{3}$ 以原子单位制表示为单个行向量。不需要四舍五入；请提供精确的符号表达式。", "solution": "我们从定义开始。标量场 $\\rho(\\mathbf{r})$ 的临界点是梯度 $\\nabla \\rho(\\mathbf{r})=\\mathbf{0}$ 的点。Hessian 矩阵 $H$ 是二阶导数矩阵，其矩阵元为 $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$。$H$ 的特征值表征了沿主方向的曲率。\n\n步骤 1：寻找键临界点。电子密度为\n$$\n\\rho(x,y,z)=A\\left[\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z-\\frac{R}{2}\\right)^{2}\\right)\\right)+\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z+\\frac{R}{2}\\right)^{2}\\right)\\right)\\right],\n$$\n该式在 $(x,y)\\mapsto(-x,-y)$ 和 $z\\mapsto -z$ 变换下保持不变，因为两项对称地分布于 $z=\\pm R/2$。根据柱对称性，点 $(x,y,z)=(0,0,0)$ 是一个候选的临界点。我们通过计算一阶导数来验证。\n\n令 $z_{0}=R/2$。定义\n$$\n\\rho_{+}(x,y,z)=A\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z-z_{0})^{2}\\right)\\right),\\quad\n\\rho_{-}(x,y,z)=A\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z+z_{0})^{2}\\right)\\right),\n$$\n这样 $\\rho=\\rho_{+}+\\rho_{-}$。一阶导数为\n$$\n\\frac{\\partial \\rho_{\\pm}}{\\partial x}=-2\\alpha x\\,\\rho_{\\pm},\\quad\n\\frac{\\partial \\rho_{\\pm}}{\\partial y}=-2\\alpha y\\,\\rho_{\\pm},\\quad\n\\frac{\\partial \\rho_{+}}{\\partial z}=-2\\alpha (z-z_{0})\\,\\rho_{+},\\quad\n\\frac{\\partial \\rho_{-}}{\\partial z}=-2\\alpha (z+z_{0})\\,\\rho_{-}.\n$$\n在点 $(0,0,0)$ 处，我们有 $x=0$，$y=0$，并且\n$$\n\\left.\\frac{\\partial \\rho}{\\partial x}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial \\rho}{\\partial y}\\right|_{\\mathbf{0}}=0,\n$$\n和\n$$\n\\left.\\frac{\\partial \\rho}{\\partial z}\\right|_{\\mathbf{0}}=-2\\alpha\\left[-z_{0}\\,\\rho_{+}(0,0,0)+z_{0}\\,\\rho_{-}(0,0,0)\\right]=0,\n$$\n因为 $\\rho_{+}(0,0,0)=\\rho_{-}(0,0,0)=A\\exp(-\\alpha z_{0}^{2})$。因此 $\\nabla \\rho(0,0,0)=\\mathbf{0}$，所以 $(0,0,0)$ 是一个临界点。在一个对称双原子分子中，这即是沿键轴的键临界点。\n\n步骤 2：计算 BCP 处的 Hessian 矩阵。我们计算 $\\rho_{\\pm}$ 的二阶导数。对于 $x$ 和 $y$ 方向，\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x^{2}}=\\frac{\\partial}{\\partial x}\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=-2\\alpha\\,\\rho_{\\pm}+(-2\\alpha x)\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=\\left(-2\\alpha+4\\alpha^{2}x^{2}\\right)\\rho_{\\pm},\n$$\n以及类似地\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial y^{2}}=\\left(-2\\alpha+4\\alpha^{2}y^{2}\\right)\\rho_{\\pm}.\n$$\n对于 $z$ 方向，\n$$\n\\frac{\\partial^{2}\\rho_{+}}{\\partial z^{2}}\n=\\frac{\\partial}{\\partial z}\\left(-2\\alpha(z-z_{0})\\,\\rho_{+}\\right)\n=-2\\alpha\\,\\rho_{+}+(-2\\alpha)(z-z_{0})\\left(-2\\alpha(z-z_{0})\\,\\rho_{+}\\right)\n=\\left(-2\\alpha+4\\alpha^{2}(z-z_{0})^{2}\\right)\\rho_{+},\n$$\n和\n$$\n\\frac{\\partial^{2}\\rho_{-}}{\\partial z^{2}}\n=\\left(-2\\alpha+4\\alpha^{2}(z+z_{0})^{2}\\right)\\rho_{-}.\n$$\n混合二阶导数为\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x\\,\\partial y}\n=\\frac{\\partial}{\\partial x}\\left(-2\\alpha y\\,\\rho_{\\pm}\\right)\n=(-2\\alpha y)\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=4\\alpha^{2}xy\\,\\rho_{\\pm},\n$$\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x\\,\\partial z}\n=\\frac{\\partial}{\\partial x}\\left(-2\\alpha(z\\mp z_{0})\\,\\rho_{\\pm}\\right)\n=(-2\\alpha)(z\\mp z_{0})\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=4\\alpha^{2}x(z\\mp z_{0})\\,\\rho_{\\pm},\n$$\n$\\partial^{2}\\rho_{\\pm}/\\partial y\\,\\partial z$ 也类似。\n\n在点 $(0,0,0)$ 处求值，我们有 $x=0$，$y=0$ 且 $\\rho_{+}(0,0,0)=\\rho_{-}(0,0,0)=A\\exp(-\\alpha z_{0}^{2})$。因此，\n$$\n\\rho(0,0,0)=\\rho_{+}(0,0,0)+\\rho_{-}(0,0,0)=2A\\exp(-\\alpha z_{0}^{2}).\n$$\n对角二阶导数为\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x^{2}}\\right|_{\\mathbf{0}}\n=\\sum_{\\pm}\\left(-2\\alpha+4\\alpha^{2}x^{2}\\right)\\rho_{\\pm}\\bigg|_{\\mathbf{0}}\n=\\sum_{\\pm}(-2\\alpha)\\rho_{\\pm}(0,0,0)\n=-2\\alpha\\,\\rho(0,0,0),\n$$\n以及同样地，\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial y^{2}}\\right|_{\\mathbf{0}}\n=-2\\alpha\\,\\rho(0,0,0).\n$$\n对于 $z$，\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial z^{2}}\\right|_{\\mathbf{0}}\n=\\left[\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho_{+}(0,0,0)\\right]+\\left[\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho_{-}(0,0,0)\\right]\n=\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0).\n$$\n所有混合导数在 $(0,0,0)$ 处都为零，因为每一项都包含在该点为零的因子 $x$、$y$ 或 $z$：\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x\\,\\partial y}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x\\,\\partial z}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial^{2}\\rho}{\\partial y\\,\\partial z}\\right|_{\\mathbf{0}}=0.\n$$\n因此，BCP 处的 Hessian 矩阵在 $(x,y,z)$ 基下是对角的：\n$$\nH(0,0,0)=\\begin{pmatrix}\n-2\\alpha\\,\\rho(0,0,0) & 0 & 0\\\n$$4pt]\n0 & -2\\alpha\\,\\rho(0,0,0) & 0\\\n$$4pt]\n0 & 0 & \\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0)\n\\end{pmatrix}.\n$$\n\n步骤 3：对于指定参数的特征值及其符号。使用 $A=1.0$、$\\alpha=1.0$ 和 $R=2.0$，我们得到 $z_{0}=R/2=1.0$ 以及\n$$\n\\rho(0,0,0)=2A\\exp(-\\alpha z_{0}^{2})=2\\exp(-1).\n$$\n因此，\n$$\n\\lambda_{x}=\\left.\\frac{\\partial^{2}\\rho}{\\partial x^{2}}\\right|_{\\mathbf{0}}=-2\\alpha\\,\\rho(0,0,0)=-2\\cdot 1\\cdot 2\\exp(-1)=-4\\exp(-1),\n$$\n$$\n\\lambda_{y}=\\left.\\frac{\\partial^{2}\\rho}{\\partial y^{2}}\\right|_{\\mathbf{0}}=-4\\exp(-1),\n$$\n$$\n\\lambda_{z}=\\left.\\frac{\\partial^{2}\\rho}{\\partial z^{2}}\\right|_{\\mathbf{0}}=\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0)=\\left(-2+4\\cdot 1\\cdot 1\\right)\\cdot 2\\exp(-1)=4\\exp(-1).\n$$\n排序后的特征值为 $\\lambda_{1}=\\lambda_{x}=-4\\exp(-1)$、$\\lambda_{2}=\\lambda_{y}=-4\\exp(-1)$ 和 $\\lambda_{3}=\\lambda_{z}=4\\exp(-1)$。其中两个为负（横向曲率），一个为正（沿键轴曲率），这在分子中原子的量子理论意义下确定了一个 $(3,-1)$ 型键临界点。所有值的单位均为原子单位，Hessian 矩阵元的单位为 $a_{0}^{-5}$。", "answer": "$$\\boxed{\\begin{pmatrix}-4\\exp(-1) & -4\\exp(-1) & 4\\exp(-1)\\end{pmatrix}}$$", "id": "2876140"}, {"introduction": "在掌握了基础的解析计算后，我们将从理想化的分析模型转向更真实的计算场景。这项实践涉及编写程序来分析水分子模型中的成键特性，并介绍了关键的计算技能，例如如何通过数值方法定位BCP以及如何计算重要的拓扑指标，包括电子密度 $\\rho_b$、其拉普拉斯值 $\\nabla^2 \\rho_b$ 和能量密度 $H_b$。通过应用局域维里定理，该练习将拓扑性质与局域能量学联系起来，深刻体现了QTAIM理论的强大分析能力 [@problem_id:2876091]。", "problem": "你需要编写一个完整、可运行的程序，该程序针对原子单位制下的水分子模型（一个氧原子和两个氢原子），定位氧-氢键上的键临界点（BCP），评估每个BCP处的拓扑和局域能量指标，并计算氧-氢对的模型相互作用量子原子（IQA）原子间能量估算值。你的推导和实现必须仅从分子中原子量子理论（QTAIM）的基本定义和经过充分检验的近似公式开始；除这些基础外，不得假设任何专门的、预先推导出的相关性。\n\n使用以下科学标准的分子中原子量子理论（QTAIM）和局域能量指标基础：\n- 电子密度场表示为 $\\rho(\\mathbf{r})$。\n- 临界点 $\\mathbf{r}_c$ 是一个满足 $\\nabla \\rho(\\mathbf{r}_c) = \\mathbf{0}$ 的点。键临界点（BCP）是一个秩为3、符号为(-1)的临界点，即 $\\rho$ 在 $\\mathbf{r}_b$ 处的Hessian矩阵的特征值为 $\\lambda_1 &lt; \\lambda_2 &lt; 0 &lt; \\lambda_3$。\n- 总能量密度为 $H(\\mathbf{r}) = G(\\mathbf{r}) + V(\\mathbf{r})$，其中 $G(\\mathbf{r})$ 是正定动能密度，$V(\\mathbf{r})$ 是势能密度。\n- 局域形式的维里定理（对束缚定态有效）通过 $2 G(\\mathbf{r}) + V(\\mathbf{r}) = -\\dfrac{1}{4}\\nabla^2 \\rho(\\mathbf{r})$ 将 $G(\\mathbf{r})$、$V(\\mathbf{r})$ 和密度的拉普拉斯算子 $\\nabla^2 \\rho(\\mathbf{r})$ 联系起来。\n- 为了在没有多电子波函数的情况下从数值上解决这个问题，使用一个广泛使用的、结合了Thomas–Fermi动能密度和局域（Dirac）交换能量密度的密度局域泛函来近似 $H(\\mathbf{r})$：\n$$H(\\mathbf{r}) \\approx \\tau_{\\mathrm{TF}}(\\rho(\\mathbf{r})) + \\epsilon_x(\\rho(\\mathbf{r})),$$\n其中 $\\tau_{\\mathrm{TF}}(\\rho) = c_F \\,\\rho^{5/3}$ 且 $\\epsilon_x(\\rho) = -c_x \\,\\rho^{4/3}$，这里 $c_F = \\dfrac{3}{10} (3\\pi^2)^{2/3}$ 且 $c_x = \\dfrac{3}{4}\\left(\\dfrac{3}{\\pi}\\right)^{1/3}$。所有量均采用原子单位（能量为Hartree，长度为Bohr）。\n- 使用局域维里定理和 $H(\\mathbf{r})$ 的定义，通过代数消去 $G(\\mathbf{r})$，并将 $V(\\mathbf{r})$ 表示为 $H(\\mathbf{r})$ 和 $\\nabla^2 \\rho(\\mathbf{r})$ 的函数。\n\n对于电子密度，使用一个在前分子Slater型叠加模型，该模型在原子核处保持总电子数。设以位于 $\\mathbf{R}_A$ 的原子核 $A$ 为中心的原子贡献为\n$$\\rho_A(\\mathbf{r}) = N_A \\left(\\dfrac{\\zeta_A^3}{\\pi}\\right) \\exp\\!\\left(-2 \\zeta_A \\,|\\mathbf{r}-\\mathbf{R}_A|\\right),$$\n因此总密度为 $\\rho(\\mathbf{r}) = \\sum_A \\rho_A(\\mathbf{r})$，其中 $N_A$ 是与原子核 $A$ 相关的电子数，$\\zeta_A$ 是控制径向衰减的Slater指数。\n\n几何结构和参数。将氧原子核置于原点 $\\mathbf{R}_{\\mathrm{O}} = (0,0,0)$，一个氢原子置于 $x$ 轴上 $\\mathbf{R}_{\\mathrm{H}_1} = (R_{\\mathrm{OH}}, 0, 0)$，第二个氢原子置于 $xy$ 平面内 $\\mathbf{R}_{\\mathrm{H}_2} = (R_{\\mathrm{OH}}\\cos\\theta, R_{\\mathrm{OH}}\\sin\\theta, 0)$，因此 $\\angle \\mathrm{H}\\!-\\!\\mathrm{O}\\!-\\!\\mathrm{H}$ 角度为 $\\theta$。使用 $N_{\\mathrm{O}} = 8$，$N_{\\mathrm{H}} = 1$（对每个氢原子）。所有长度单位为Bohr，$\\theta$ 单位为度。你的代码必须为每个 $\\mathrm{O}\\!-\\!\\mathrm{H}$ 对分别计算：\n- BCP的位置 $\\mathbf{r}_b$，限制在连接氧和该氢原子的核间线段上，通过求解 $\\rho(\\mathbf{r})$ 沿O–H轴的方向导数在内部坐标 $s \\in (0, R_{\\mathrm{OH}})$ 处为零的点来确定。然后通过计算 $\\rho$ 的完整Hessian矩阵并检查其是否具有两个负特征值和一个正特征值，来验证 $\\mathbf{r}_b$ 处的键临界点符号。\n- 拓扑指标 $\\rho_b = \\rho(\\mathbf{r}_b)$ 和 $H_b = H(\\mathbf{r}_b)$。\n- 拉普拉斯算子 $\\nabla^2 \\rho(\\mathbf{r}_b)$，作为Hessian矩阵的迹。\n- 势能密度 $V(\\mathbf{r}_b)$，通过上述两个关系式消去 $G(\\mathbf{r}_b)$，用 $H(\\mathbf{r}_b)$ 和 $\\nabla^2 \\rho(\\mathbf{r}_b)$ 表示。\n- O–H对的模型原子间能量估算值，定义为 $E_{\\mathrm{IQA}}^{\\mathrm{(est)}} = \\kappa \\, V(\\mathbf{r}_b)$，其中 $\\kappa = \\dfrac{1}{2}$（原子单位）。以Hartree为单位报告此量。\n\n数值实现要求：\n- 所有计算均采用原子单位。能量以Hartree报告，密度以电子每 $\\mathrm{Bohr}^3$ 报告。\n- 使用一个稳健的一维求根方法，通过求解 $d\\rho/ds = 0$（其中 $s$ 是沿O–H方向从氧原子出发的距离），在每条O–H线上定位BCP，其中 $s \\in (0,R_{\\mathrm{OH}})$。通过将梯度 $\\nabla \\rho$ 与O–H单位向量做缩并来计算方向导数。\n- 解析地计算前分子密度的梯度和Hessian矩阵。对于以 $\\mathbf{R}_A$ 为中心的球对称贡献 $f(r_A)$（其中 $r_A = |\\mathbf{r}-\\mathbf{R}_A|$），使用标准的张量形式\n$$\\nabla f = f'(r_A) \\,\\hat{\\mathbf{e}}_{r_A}, \\qquad \\nabla\\nabla f = f''(r_A) \\,\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top + \\dfrac{f'(r_A)}{r_A}\\left(\\mathbf{I}-\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top\\right),$$\n其中 $f(r_A) = N_A (\\zeta_A^3/\\pi)\\exp(-2\\zeta_A r_A)$，$f'(r_A) = -2\\zeta_A f(r_A)$，且 $f''(r_A) = 4\\zeta_A^2 f(r_A)$。\n\n测试套件。你的程序必须评估以下四个参数集，每个参数集定义一个不同的水模型，并汇总结果：\n- 情况1: $R_{\\mathrm{OH}} = 1.81$ (Bohr), $\\theta = 104.5$ (度), $\\zeta_{\\mathrm{O}} = 2.2$, $\\zeta_{\\mathrm{H}} = 1.24$.\n- 情况2: $R_{\\mathrm{OH}} = 2.00$ (Bohr), $\\theta = 104.5$ (度), $\\zeta_{\\mathrm{O}} = 2.2$, $\\zeta_{\\mathrm{H}} = 1.24$.\n- 情况3: $R_{\\mathrm{OH}} = 1.60$ (Bohr), $\\theta = 104.5$ (度), $\\zeta_{\\mathrm{O}} = 2.2$, $\\zeta_{\\mathrm{H}} = 1.24$.\n- 情况4: $R_{\\mathrm{OH}} = 1.81$ (Bohr), $\\theta = 104.5$ (度), $\\zeta_{\\mathrm{O}} = 2.0$, $\\zeta_{\\mathrm{H}} = 1.24$.\n\n对于每种情况，计算有序的六元浮点数元组\n$$\\left[E_{\\mathrm{IQA}}^{\\mathrm{(est)}}(\\mathrm{O}\\!-\\!\\mathrm{H}_1),\\,E_{\\mathrm{IQA}}^{\\mathrm{(est)}}(\\mathrm{O}\\!-\\!\\mathrm{H}_2),\\,\\rho_b(\\mathrm{O}\\!-\\!\\mathrm{H}_1),\\,\\rho_b(\\mathrm{O}\\!-\\!\\mathrm{H}_2),\\,H_b(\\mathrm{O}\\!-\\!\\mathrm{H}_1),\\,H_b(\\mathrm{O}\\!-\\!\\mathrm{H}_2)\\right],$$\n按规定顺序和上述原子单位制。\n\n最终输出格式。你的程序应生成单行输出，包含一个逗号分隔的Python风格列表的列表，每个内部列表对应一种情况，并保持上述给出的情况顺序。例如，你的输出必须类似于\n$[\\,[x_{11},x_{12},x_{13},x_{14},x_{15},x_{16}],[x_{21},\\dots],[x_{31},\\dots],[x_{41},\\dots]\\,]$,\n其中每个 $x_{ij}$ 是一个浮点数。角度必须按规定以度为单位处理。不得打印任何额外文本。", "solution": "该问题要求基于分子中原子量子理论（QTAIM）实现一个计算模型，以分析简化水分子的成键特性。分析内容包括：定位氧-氢键的键临界点（BCP），计算这些点上的若干拓扑和能量指标，并最终评估一个模型的原子间能量。整个计算过程在原子单位制下进行。\n\n该模型的基础是前分子电子密度 $\\rho(\\mathbf{r})$，它是球对称原子密度的叠加：\n$$\n\\rho(\\mathbf{r}) = \\sum_{A} \\rho_A(\\mathbf{r})\n$$\n其中，求和遍历三个原子核：氧（O）、氢1（H$_1$）和氢2（H$_2$）。每个以原子核 $A$（位于 $\\mathbf{R}_A$）为中心的原子贡献由一个Slater型函数给出：\n$$\n\\rho_A(\\mathbf{r}) = N_A \\left(\\dfrac{\\zeta_A^3}{\\pi}\\right) \\exp\\!\\left(-2 \\zeta_A \\,|\\mathbf{r}-\\mathbf{R}_A|\\right)\n$$\n这里，$N_A$ 是原子 $A$ 的电子数（$N_O=8$，$N_H=1$），$\\zeta_A$ 是相应的Slater指数。我们将指数前因子记为 $C_A = N_A (\\zeta_A^3/\\pi)$。几何结构定义为：氧原子在原点 $\\mathbf{R}_O=(0,0,0)$，第一个氢原子在 $\\mathbf{R}_{H_1}=(R_{OH}, 0, 0)$，第二个氢原子在 $\\mathbf{R}_{H_2}=(R_{OH}\\cos\\theta, R_{OH}\\sin\\theta, 0)$。\n\n首先，我们沿每个O-H核间轴线定位键临界点（BCP）。BCP是一个点 $\\mathbf{r}_b$，在该点电子密度的梯度为零，即 $\\nabla\\rho(\\mathbf{r}_b) = \\mathbf{0}$，并且密度的Hessian矩阵 $\\nabla\\nabla\\rho(\\mathbf{r}_b)$ 的符号为(-1)，对应于两个负特征值（$\\lambda_1, \\lambda_2$）和一个正特征值（$\\lambda_3$）。\n\n由于水分子模型的对称性，在O-H$_1$键的BCP处计算的标量性质将与O-H$_2$键的相同。因此，我们可以将推导集中在位于x轴上的O-H$_1$键。此键的BCP $\\mathbf{r}_{b,1}$ 也必须位于该轴上，因此其坐标为 $(s,0,0)$，其中 $s$ 为某个距离，满足 $s \\in (0, R_{OH})$。条件 $\\nabla\\rho(\\mathbf{r}_{b,1})=\\mathbf{0}$ 简化为寻找梯度x分量为零的点，因为根据对称性，其他分量在x轴上为零。总密度的梯度是原子贡献之和，$\\nabla\\rho = \\sum_A \\nabla\\rho_A$。单个原子密度 $\\rho_A(r_A)$（其中 $r_A=|\\mathbf{r}-\\mathbf{R}_A|$）的梯度由 $\\nabla\\rho_A = \\frac{d\\rho_A}{dr_A} \\nabla r_A = \\rho_A'(r_A) \\hat{\\mathbf{e}}_{r_A}$ 给出，其中 $\\hat{\\mathbf{e}}_{r_A} = (\\mathbf{r}-\\mathbf{R}_A)/r_A$。由于 $\\rho_A'(r_A) = -2\\zeta_A \\rho_A(r_A)$，在 $\\mathbf{r}=(s,0,0)$ 处梯度的x分量为：\n$$\n(\\nabla\\rho)_x(s,0,0) = \\sum_{A} \\left(-2\\zeta_A \\rho_A(r_A(s))\\right) \\frac{s - x_A}{r_A(s)} = 0\n$$\n其中 $\\mathbf{R}_A = (x_A, y_A, z_A)$ 且 $r_A(s) = |\\mathbf{r} - \\mathbf{R}_A|$。这个关于 $s$ 的非线性方程在区间 $(0, R_{OH})$ 上使用稳健的求根算法进行数值求解，以找到BCP的距离 $s_b$。BCP的位置则为 $\\mathbf{r}_b = (s_b, 0, 0)$。\n\n找到 $\\mathbf{r}_b$ 后，我们计算必要的指标。BCP处的密度为 $\\rho_b = \\rho(\\mathbf{r}_b)$。Hessian矩阵 $\\mathbf{H} = \\nabla\\nabla\\rho(\\mathbf{r}_b)$ 通过对每个原子的解析Hessian求和来计算：\n$$\n\\nabla\\nabla\\rho_A = \\rho_A''(r_A) \\,\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top + \\dfrac{\\rho_A'(r_A)}{r_A}\\left(\\mathbf{I}-\\hat{\\mathbf{e}}_{r_A}\\hat{\\mathbf{e}}_{r_A}^\\top\\right)\n$$\n其中 $\\rho_A'(r_A) = -2\\zeta_A \\rho_A(r_A)$ 且 $\\rho_A''(r_A) = 4\\zeta_A^2 \\rho_A(r_A)$。计算总Hessian矩阵的特征值以验证其(-1)符号。BCP处密度的拉普拉斯算子 $\\nabla^2 \\rho(\\mathbf{r}_b)$ 是Hessian矩阵的迹。\n\n局域总能量密度 $H(\\mathbf{r})$ 使用局域密度泛函近似：\n$$\nH(\\mathbf{r}) \\approx c_F \\rho(\\mathbf{r})^{5/3} - c_x \\rho(\\mathbf{r})^{4/3}\n$$\n其中常数 $c_F = \\frac{3}{10} (3\\pi^2)^{2/3}$ 和 $c_x = \\frac{3}{4}(\\frac{3}{\\pi})^{1/3}$。\n\n势能密度 $V(\\mathbf{r})$ 由两个基本关系推导得出：总能量密度的定义 $H(\\mathbf{r}) = G(\\mathbf{r}) + V(\\mathbf{r})$，以及局域维里定理 $2G(\\mathbf{r}) + V(\\mathbf{r}) = -\\frac{1}{4}\\nabla^2\\rho(\\mathbf{r})$。消去动能密度 $G(\\mathbf{r})$，得到 $V(\\mathbf{r})$ 关于 $H(\\mathbf{r})$ 和拉普拉斯算子的表达式：\n$$\nV(\\mathbf{r}_b) = 2 H(\\mathbf{r}_b) + \\frac{1}{4} \\nabla^2\\rho(\\mathbf{r}_b)\n$$\n最后，我们计算O-H相互作用的模型相互作用量子原子（IQA）能量估算值：\n$$\nE_{\\mathrm{IQA}}^{\\mathrm{(est)}} = \\kappa V(\\mathbf{r}_b)\n$$\n其中给定的常数 $\\kappa = 1/2$。所有计算都针对给定的测试用例进行，并且由于对称性，对于每种情况，O-H$_1$ 和 O-H$_2$ 键的结果是相同的。最终输出被构造成一个包含每种情况结果的六元组列表。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the QTAIM problem for different water molecule models.\n    \"\"\"\n\n    # --- Constants in atomic units ---\n    # Thomas-Fermi kinetic energy density constant\n    C_F = 0.3 * (3 * np.pi**2)**(2.0/3.0)\n    # Dirac exchange energy density constant\n    C_X = 0.75 * (3 / np.pi)**(1.0/3.0)\n    # IQA energy estimator constant\n    KAPPA = 0.5\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: R_OH, theta_deg, zeta_O, zeta_H\n        (1.81, 104.5, 2.2, 1.24),\n        # Case 2\n        (2.00, 104.5, 2.2, 1.24),\n        # Case 3\n        (1.60, 104.5, 2.2, 1.24),\n        # Case 4\n        (1.81, 104.5, 2.0, 1.24),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        R_OH, theta_deg, zeta_O, zeta_H = case\n        theta_rad = np.deg2rad(theta_deg)\n        N_O, N_H = 8.0, 1.0\n\n        # --- Define Atomic System ---\n        atoms = [\n            # atom_params: [position, N, zeta, C]\n            {'pos': np.array([0.0, 0.0, 0.0]), 'N': N_O, 'zeta': zeta_O},      # Oxygen\n            {'pos': np.array([R_OH, 0.0, 0.0]), 'N': N_H, 'zeta': zeta_H},   # Hydrogen 1\n            {'pos': np.array([R_OH * np.cos(theta_rad), \n                               R_OH * np.sin(theta_rad), 0.0]), \n             'N': N_H, 'zeta': zeta_H} # Hydrogen 2\n        ]\n        \n        for atom in atoms:\n            atom['C'] = atom['N'] * atom['zeta']**3 / np.pi\n\n        # --- Helper functions for QTAIM calculations ---\n        def get_atomic_rho(r_dist, C, zeta):\n            return C * np.exp(-2.0 * zeta * r_dist)\n\n        def get_total_rho(r_vec, atoms_list):\n            total_rho = 0.0\n            for atom in atoms_list:\n                r_dist = np.linalg.norm(r_vec - atom['pos'])\n                if r_dist < 1e-9: return np.inf # Avoid singularity at nucleus\n                total_rho += get_atomic_rho(r_dist, atom['C'], atom['zeta'])\n            return total_rho\n        \n        def grad_rho_x_on_axis(s, atoms_list, R):\n            \"\"\"\n            Calculates the x-component of the gradient of rho on the O-H1 axis.\n            This is the function whose root we need to find.\n            \"\"\"\n            r_vec = np.array([s, 0.0, 0.0])\n            grad_x_sum = 0.0\n\n            for atom in atoms_list:\n                v = r_vec - atom['pos']\n                r_dist = np.linalg.norm(v)\n                if r_dist < 1e-9: return np.inf\n                \n                rho_val = get_atomic_rho(r_dist, atom['C'], atom['zeta'])\n                # Directional derivative component: -2*zeta*rho*(v_x/r_dist)\n                grad_x_sum += -2.0 * atom['zeta'] * rho_val * (v[0] / r_dist)\n            \n            return grad_x_sum\n            \n        def get_hessian(r_vec, atoms_list):\n            hessian = np.zeros((3, 3))\n            I = np.identity(3)\n            for atom in atoms_list:\n                v = r_vec - atom['pos']\n                r_dist = np.linalg.norm(v)\n\n                if r_dist < 1e-9: continue\n\n                rho_val = get_atomic_rho(r_dist, atom['C'], atom['zeta'])\n                zeta = atom['zeta']\n                v_outer_v = np.outer(v, v)\n\n                # rho_A''(r) part\n                term1_coeff = 4 * zeta**2\n                # rho_A'(r)/r part\n                term2_coeff = -2 * zeta / r_dist\n\n                H_A = (term1_coeff * rho_val) * (v_outer_v / r_dist**2) + \\\n                      (term2_coeff * rho_val) * (I - v_outer_v / r_dist**2)\n                \n                hessian += H_A\n            return hessian\n\n        # --- BCP Location ---\n        # Search for BCP on the O-H1 bond axis (x-axis)\n        try:\n            # A small epsilon is added to the lower bound to avoid the nucleus\n            s_b = brentq(lambda s: grad_rho_x_on_axis(s, atoms, R_OH), 1e-6, R_OH - 1e-6)\n        except ValueError:\n            # Handle cases where no BCP is found in the interval, although unlikely for these systems\n            all_results.append([np.nan] * 6)\n            continue\n            \n        r_b = np.array([s_b, 0.0, 0.0])\n\n        # --- QTAIM Indicator Calculation at BCP ---\n        # Density at BCP\n        rho_b = get_total_rho(r_b, atoms)\n\n        # Hessian and Laplacian at BCP\n        Hessian_b = get_hessian(r_b, atoms)\n        \n        # Eigenvalue check for BCP signature (optional, for validation)\n        eigvals = np.linalg.eigvalsh(Hessian_b)\n        # assert np.sum(eigvals < 0) == 2, f\"Invalid BCP signature: {eigvals}\"\n\n        # Laplacian\n        laplacian_b = np.trace(Hessian_b)\n\n        # Total energy density at BCP\n        H_b = C_F * rho_b**(5.0/3.0) - C_X * rho_b**(4.0/3.0)\n\n        # Potential energy density at BCP\n        V_b = 2.0 * H_b + 0.25 * laplacian_b\n\n        # IQA energy estimator\n        E_IQA_est = KAPPA * V_b\n\n        # --- Assemble results ---\n        # Due to symmetry, results for O-H1 and O-H2 are identical\n        case_result = [E_IQA_est, E_IQA_est, rho_b, rho_b, H_b, H_b]\n        all_results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # Manually format the list of lists string to avoid whitespace issues\n    # and ensure it matches the required Python-style list of lists string.\n    output_str = '[' + ','.join([str(res) for res in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2876091"}, {"introduction": "最后，我们将视角从分析单个化学键拓宽到揭示更为普适的化学规律。这项实践旨在利用BCP数据来建立并验证一个经验模型，该模型将BCP处的电子密度 $\\rho_b$ 与键能直接关联。通过对不同化学家族的数据进行回归和交叉验证分析，您将亲身体验如何运用拓扑指标来预测宏观性质，并理解其能力与局限，这是定量构效关系 (QSPR) 研究的核心内容 [@problem_id:2876039]。", "problem": "给定三个化学族，我们已为其汇编了键临界点（BCP）处的电子密度（以 $ \\rho_b $ 表示，单位为电子/立方玻尔，即 $\\mathrm{e/bohr^3}$）和参考键能（以 $ E $ 表示，单位为千焦/摩尔，即 $\\mathrm{kJ/mol}$）。在分子中原子量子理论（QTAIM）的框架内，键临界点是键径上的一个点，在该点上电子密度的梯度 $ \\nabla \\rho(\\mathbf{r}) $ 为零，并且 $ \\rho $ 的Hessian矩阵的符号与键鞍点一致。我们关注将 $ \\rho_b $ 与 $ E $ 相关联的经验性做法，并希望评估这种相关性在不同化学族之间的可移植性。您的任务是：将此评估形式化为一个数学上适定的回归与误差分析问题，并将其实现为一个程序。\n\n请从以下基础开始：\n- 电子密度 $ \\rho(\\mathbf{r}) $ 是空间上的一个标量场，键临界点是 $ \\rho(\\mathbf{r}) $ 沿键径的一个驻点。\n- 对于每个化学族内的若干个化学键，我们都给定了数据对 $ (\\rho_b, E) $。\n- 经验性的结构-性质模型通常采用幂律形式 $ E = k \\, \\rho_b^{\\alpha} $，其中 $ k > 0 $ 和 $ \\alpha $ 是需要从数据中学习的参数。\n- 当指定了线性关系时，用于线性回归的普通最小二乘法是估算参数的成熟方法。\n\n任务：\n1) 采用模型 $ E = k \\, \\rho_b^{\\alpha} $。通过对数变换后的变量应用普通最小二乘法，从训练数据中估算参数 $ k $ 和 $ \\alpha $。也即，对 $ \\ln E $ 和 $ \\ln \\rho_b $ 进行回归，使得 $ \\ln E = \\ln k + \\alpha \\ln \\rho_b $。使用在变换空间中使残差平方和最小化的唯一最小二乘解。\n2) 将测试集上的均方根误差（RMSE）定义为 $ \\mathrm{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (E_i - \\hat{E}_i)^2} $，其中 $ \\hat{E}_i $ 是使用训练好的模型对 $ \\rho_{b,i} $ 的预测能量，而 $ n $ 是测试点的数量。\n3) 为量化族内预测误差（作为噪声和模型充分性的基准），计算族内的留一法交叉验证（LOOCV）RMSE：对于该族中的每个点，用其余的点拟合模型，并计算在被留出的点上的预测误差平方；将所有留出点的误差平方聚合，得出LOOCV RMSE。\n4) 为评估跨族的可移植性，在一个族上训练模型，并在另一个不同的族上评估RMSE，期间不重新拟合模型。\n\n数据（每对为 $ (\\rho_b, E) $，其中 $ \\rho_b $ 的单位为 $ \\mathrm{e/bohr^3} $，$ E $ 的单位为 $ \\mathrm{kJ/mol} $）：\n- 共价族 (C): $[(0.12, 125.2), (0.15, 176.0), (0.18, 227.0), (0.22, 312.0), (0.26, 395.0), (0.30, 497.0), (0.34, 590.0), (0.38, 706.0)]$。\n- 离子/配位族 (I): $[(0.06, 78.0), (0.08, 111.0), (0.10, 152.0), (0.12, 189.0), (0.14, 235.0), (0.16, 279.0)]$。\n- 氢键族 (H): $[(0.010, 3.2), (0.015, 5.1), (0.020, 7.4), (0.030, 12.0), (0.040, 16.6), (0.050, 22.3)]$。\n\n测试套件：\n- 跨族RMSE案例（训练族 $\\rightarrow$ 测试族）：\n  1) $ \\mathrm{C} \\rightarrow \\mathrm{I} $\n  2) $ \\mathrm{I} \\rightarrow \\mathrm{C} $\n  3) $ \\mathrm{C} \\rightarrow \\mathrm{H} $\n  4) $ \\mathrm{H} \\rightarrow \\mathrm{C} $\n  5) $ \\mathrm{H} \\rightarrow \\mathrm{I} $\n  6) $ \\mathrm{I} \\rightarrow \\mathrm{H} $\n- 族内LOOCV RMSE案例：\n  7) $ \\mathrm{C} \\rightarrow \\mathrm{C} $ (LOOCV)\n  8) $ \\mathrm{H} \\rightarrow \\mathrm{H} $ (LOOCV)\n  9) $ \\mathrm{I} \\rightarrow \\mathrm{I} $ (LOOCV)\n\n实现与输出要求：\n- 在变换空间中的回归使用自然对数。\n- 所有RMSE值必须以 $ \\mathrm{kJ/mol} $ 为单位计算，并以 $ \\mathrm{kJ/mol} $ 为单位报告。\n- 你的程序必须生成单行输出，其中包含与上述测试套件相对应的九个RMSE值，按指定顺序排列，四舍五入到三位小数，并以逗号分隔的列表形式包含在方括号内。例如，输出应类似于 $[\\dots]$，其中包含恰好九个十进制格式的数字。\n- 不涉及角度。不涉及百分比。\n\n您的程序必须是一个完整、可运行的实现，它将上述数据硬编码，并在没有外部输入的情况下执行计算。最终打印的输出必须是遵循确切格式描述的单行文本。", "solution": "该问题在科学上是适定的，并为量子化学和数据分析领域的计算任务提供了一套完整的指令。它基于一种已确立的做法，即将电子密度的拓扑性质（例如键临界点上的值$\\rho_b$）与宏观化学性质（如键能$E$）相关联。该问题被确认为合理，下方提供了解决方案。\n\n问题的核心在于量化一个经验性幂律模型 $E = k \\, \\rho_b^{\\alpha}$ 的预测能力和可移植性，该模型将键能 $E$ 与键临界点电子密度 $\\rho_b$ 联系起来。参数 $k$ 和 $\\alpha$ 特定于化学环境，必须通过实验或计算数据来确定。\n\n为了估算这些参数，我们通过对等式两边取自然对数来线性化模型：\n$$ \\ln(E) = \\ln(k \\, \\rho_b^{\\alpha}) = \\ln(k) + \\alpha \\ln(\\rho_b) $$\n此方程呈直线形式 $y = c + m x$，其中变量为 $y = \\ln(E)$ 和 $x = \\ln(\\rho_b)$。直线的斜率为 $m = \\alpha$，y轴截距为 $c = \\ln(k)$。此变换允许我们使用普通最小二乘法（OLS）找到 $\\alpha$ 和 $\\ln(k)$ 的最优值，以最小化 $\\ln(E)$ 的观测值与预测值之间的残差平方和。\n\n对于一个包含 $n$ 个点的给定训练数据集 $\\{(\\rho_{b,i}, E_i)\\}_{i=1}^n$，我们首先将其转换为一组对数点 $\\{x_i, y_i\\}_{i=1}^n$，其中 $x_i = \\ln(\\rho_{b,i})$ 且 $y_i = \\ln(E_i)$。斜率 $\\alpha$ 和截距 $\\ln(k)$ 的OLS解由以下公式给出：\n$$ \\alpha = \\frac{n \\sum_{i=1}^{n} (x_i y_i) - (\\sum_{i=1}^{n} x_i) (\\sum_{i=1}^{n} y_i)}{n \\sum_{i=1}^{n} (x_i^2) - (\\sum_{i=1}^{n} x_i)^2} $$\n$$ \\ln(k) = \\bar{y} - \\alpha \\bar{x} $$\n其中 $\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i$ 和 $\\bar{y} = \\frac{1}{n} \\sum_{i=1}^{n} y_i$ 是样本均值。然后通过取指数求得参数 $k$：$k = e^{\\ln(k)}$。\n\n一旦从训练集中确定了模型参数 $(\\alpha, k)$，我们就可以使用原始的幂律关系为任何新的电子密度值 $\\rho_{b,j}$ 预测能量 $\\hat{E}_j$：\n$$ \\hat{E}_j = k \\, (\\rho_{b,j})^{\\alpha} $$\n模型的性能通过在包含 $N$ 个点的测试集上的均方根误差（RMSE）进行评估，其定义为：\n$$ \\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{j=1}^{N} (E_j - \\hat{E}_j)^2} $$\n该指标以能量的原始单位（$\\mathrm{kJ/mol}$）提供了预测误差平均大小的度量。\n\n该问题要求进行两种类型的模型评估：\n$1$. **跨族可移植性**：这评估了一个在某个化学族（例如，共价族）上训练的模型预测另一个不同族（例如，离子族）能量的好坏程度。这是对模型普适性的直接测试。该过程包括使用训练族的所有数据拟合模型参数 $(\\alpha, k)$，然后计算在整个测试族上的RMSE。\n\n$2$. **族内预测误差**：这通过留一法交叉验证（LOOCV）进行评估。该技术提供了一个稳健的估计，说明模型预测来自*同一族*新数据的能力，可作为模型固有准确性和稳定性的基准。对于一个有 $n$ 个数据点的族，该过程重复 $n$ 次。在每次迭代 $i$ 中，第 $i$ 个数据点被保留作为测试点，模型在剩余的 $n-1$ 个点上进行训练。对被留出的点作出预测 $\\hat{E}_i$。最终的LOOCV RMSE是基于所有 $n$ 个这样的预测 $\\{ (E_i, \\hat{E}_i) \\}_{i=1}^n$ 计算得出的。\n\n该实现将系统地对九个指定的测试案例执行这些计算。将使用为共价（C）、离子/配位（I）和氢键（H）族提供的数据。回归将在对数变换的数据上使用 `scipy.stats.linregress` 执行，它提供了OLS的数值稳定实现。然后，所得参数将用于按定义计算预测和RMSE值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the QTAIM regression and error analysis problem.\n    \"\"\"\n    # Define the data for the three chemical families.\n    # Each entry is a numpy array of (rho_b, E) pairs.\n    data = {\n        'C': np.array([\n            (0.12, 125.2), (0.15, 176.0), (0.18, 227.0), (0.22, 312.0),\n            (0.26, 395.0), (0.30, 497.0), (0.34, 590.0), (0.38, 706.0)\n        ]),\n        'I': np.array([\n            (0.06, 78.0), (0.08, 111.0), (0.10, 152.0), (0.12, 189.0),\n            (0.14, 235.0), (0.16, 279.0)\n        ]),\n        'H': np.array([\n            (0.010, 3.2), (0.015, 5.1), (0.020, 7.4), (0.030, 12.0),\n            (0.040, 16.6), (0.050, 22.3)\n        ])\n    }\n\n    def fit_model(training_data):\n        \"\"\"\n        Fits the power-law model E = k * rho_b^alpha by linear regression\n        on log-transformed data.\n        \n        Args:\n            training_data (np.ndarray): Array of (rho_b, E) pairs.\n            \n        Returns:\n            tuple: A tuple (alpha, k) representing the model parameters.\n        \"\"\"\n        rho_b = training_data[:, 0]\n        E = training_data[:, 1]\n        \n        log_rho_b = np.log(rho_b)\n        log_E = np.log(E)\n        \n        # OLS on log-transformed data: ln(E) = alpha * ln(rho_b) + ln(k)\n        slope, intercept, _, _, _ = linregress(log_rho_b, log_E)\n        \n        alpha = slope\n        k = np.exp(intercept)\n        \n        return alpha, k\n\n    def predict_E(model, rho_b_values):\n        \"\"\"\n        Predicts bond energies E using a fitted power-law model.\n        \n        Args:\n            model (tuple): A tuple (alpha, k) of model parameters.\n            rho_b_values (np.ndarray): Array of rho_b values.\n            \n        Returns:\n            np.ndarray: Array of predicted E values.\n        \"\"\"\n        alpha, k = model\n        return k * (rho_b_values ** alpha)\n\n    def calculate_rmse(E_true, E_pred):\n        \"\"\"\n        Calculates the Root-Mean-Square Error.\n        \n        Args:\n            E_true (np.ndarray): Array of true energy values.\n            E_pred (np.ndarray): Array of predicted energy values.\n            \n        Returns:\n            float: The RMSE value.\n        \"\"\"\n        return np.sqrt(np.mean((E_true - E_pred)**2))\n\n    def loocv_rmse(family_data):\n        \"\"\"\n        Calculates the Leave-One-Out Cross-Validation RMSE for a family.\n        \n        Args:\n            family_data (np.ndarray): Array of (rho_b, E) pairs for one family.\n            \n        Returns:\n            float: The LOOCV RMSE value.\n        \"\"\"\n        n_points = len(family_data)\n        squared_errors = []\n        \n        for i in range(n_points):\n            # Create leave-one-out training set by deleting the i-th row\n            lo_train_data = np.delete(family_data, i, axis=0)\n            \n            # The left-out point is the test set\n            lo_test_point = family_data[i]\n            \n            # Fit model on the (n-1) training points\n            model = fit_model(lo_train_data)\n            \n            # Predict on the single left-out point\n            rho_b_test = lo_test_point[0]\n            E_true = lo_test_point[1]\n            E_pred = predict_E(model, np.array([rho_b_test]))[0]\n            \n            squared_errors.append((E_true - E_pred)**2)\n            \n        return np.sqrt(np.mean(squared_errors))\n\n    # Define the 9 test cases from the problem statement.\n    test_suite = [\n        # Cross-family RMSE cases (train -> test)\n        ('C', 'I'),  # 1\n        ('I', 'C'),  # 2\n        ('C', 'H'),  # 3\n        ('H', 'C'),  # 4\n        ('H', 'I'),  # 5\n        ('I', 'H'),  # 6\n        # Within-family LOOCV RMSE cases\n        ('C', 'C'),  # 7\n        ('H', 'H'),  # 8\n        ('I', 'I')   # 9\n    ]\n\n    results = []\n    for train_fam, test_fam in test_suite:\n        if train_fam == test_fam:\n            # This is an LOOCV case\n            family_data = data[train_fam]\n            rmse = loocv_rmse(family_data)\n        else:\n            # This is a cross-family transferability case\n            train_data = data[train_fam]\n            test_data = data[test_fam]\n            \n            # Fit model on the entire training family\n            model = fit_model(train_data)\n            \n            # Test model on the entire testing family\n            rho_b_test = test_data[:, 0]\n            E_true_test = test_data[:, 1]\n            E_pred_test = predict_E(model, rho_b_test)\n            \n            rmse = calculate_rmse(E_true_test, E_pred_test)\n            \n        results.append(rmse)\n\n    # Format the results to three decimal places and print in the required format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2876039"}]}