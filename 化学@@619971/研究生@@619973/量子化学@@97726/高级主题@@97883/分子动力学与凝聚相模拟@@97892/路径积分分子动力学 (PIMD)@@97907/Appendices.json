{"hands_on_practices": [{"introduction": "路径积分分子动力学 (PIMD) 的核心在于“经典同构”思想，即将一个量子粒子映射为一个经典的环状聚合物。本实践旨在让您对这一核心思想建立直接、定量的理解。通过计算简谐振子在路径积分表示下的配分函数，并将其与精确的量子结果进行比较，您将亲手验证当珠子数 $P$ 增加时，路径积分表示如何收敛到精确解，从而巩固对PIMD理论基础的认识。[@problem_id:2659206]", "problem": "考虑一个质量为 $m$、角频率为 $\\omega$、处于逆温度 $\\beta$ 下的一维量子谐振子。在约化单位制下进行计算，其中普朗克常数除以 $2\\pi$ 设为 $\\hbar = 1$，玻尔兹曼常数设为 $k_{\\mathrm{B}} = 1$，因此所有量均为无量纲。你的任务是推导、实现并测试精确量子正则配分函数与其虚时路径积分离散化形式之间的比较，并将其表示为 Trotter 数 $P$ 的函数。\n\n从以下基本原理出发：\n- 正则配分函数为 $Z = \\mathrm{Tr}\\left[e^{-\\beta \\hat{H}}\\right]$，其哈密顿量为 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{q}^2$。\n- Trotter 分解和 Feynman 虚时路径积分表示法将 $Z$ 表达为虚时演化算符的 $P$ 重分解的极限。对于有限的 $P$，这会得到一个对 $P$ 珠环状聚合物的经典组态积分，该聚合物具有最近邻谐振子弹簧和珠上势 $V(q) = \\frac{1}{2} m \\omega^2 q^2$。\n- 对于二次型作用量，高斯积分可简化为二次型的行列式。\n\n要求：\n1) 在此单位制下，推导一维谐振子的精确量子配分函数 $Z_{\\mathrm{exact}}(\\beta,\\omega)$。\n2) 从具有 $P$ 个珠子和原始 Trotter 分裂的离散化虚时路径积分出发，推导出一个关于有限 $P$ 的环状聚合物简正模式乘积的显式可计算表达式 $Z_P(\\beta,\\omega)$（这是真实的蒙特卡洛采样会估计的 $P$ 级路径积分蒙特卡洛 (PIMC) 目标；在这里，你将通过等效的高斯积分来确定性地计算它）。\n3) 对于下面指定的每个测试用例，计算当 $P \\in \\{1,2,4,8,16,32,64\\}$ 时，$Z_{\\mathrm{exact}}(\\beta,\\omega)$ 和 $Z_P(\\beta,\\omega)$ 的值。使用这些值计算每个 $P$ 对应的绝对误差 $|Z_P - Z_{\\mathrm{exact}}|$。\n4) 通过对最后四个 $P$ 值（$P \\in \\{8,16,32,64\\}$）的对数-对数数据使用线性最小二乘法，拟合幂律 $|Z_P - Z_{\\mathrm{exact}}| \\approx C P^{-r}$ 来量化收敛速率，并提取指数 $r$。\n5) 将上述步骤实现为一个完整的程序，为给定的测试套件生成所需的输出。\n\n使用以下参数集作为测试套件（在所述单位制 $\\hbar = 1, k_{\\mathrm{B}}=1$ 下均为无量纲）：\n- 用例 1：$(\\beta,\\omega) = (0.5, 1.0)$。\n- 用例 2：$(\\beta,\\omega) = (1.0, 1.0)$。\n- 用例 3：$(\\beta,\\omega) = (3.0, 1.0)$。\n- 用例 4：$(\\beta,\\omega) = (1.0, 0.5)$。\n\n程序输入：无。所有参数均已在上方提供。\n\n程序输出：\n- 对每个用例，输出一个浮点数：从步骤 4 拟合得到的收敛指数 $r$。\n- 你的程序应生成单行输出，其中包含用逗号分隔并用方括号括起来的结果列表，顺序与上面列出的用例相同，例如 $[r_1,r_2,r_3,r_4]$。\n- 每个 $r$ 都必须以浮点数形式报告。由于选择了 $\\hbar = 1, k_{\\mathrm{B}}=1$，所有输出都是无单位的。\n\n数值指导与约束：\n- 为保证数值稳定性，请使用本征模式贡献的对数来计算 $Z_P(\\beta,\\omega)$ 中的乘积。\n- 三角函数中使用的角度必须是弧度。\n- 不允许外部输入或随机性；你的实现必须是确定性且自包含的。", "solution": "问题陈述已经过严格验证，被认为是科学上合理、问题表述清晰且客观的。这是统计力学中的一个标准问题，存在唯一且可验证的解。我们现在按要求进行推导和实现。分析将在约化单位制下进行，其中普朗克常数除以 $2\\pi$ 为 $\\hbar=1$，玻尔兹曼常数为 $k_{\\mathrm{B}}=1$。\n\n首先，我们推导精确的量子正则配分函数 $Z_{\\mathrm{exact}}$。一维量子谐振子的哈密顿量由 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{q}^2$ 给出。该系统的能量本征值是量子化的，由 $E_n = \\hbar \\omega (n + \\frac{1}{2})$ 给出，其中 $n$ 是一个非负整数，$n=0, 1, 2, \\ldots$。在指定的约化单位制中，$\\hbar=1$，能量级为 $E_n = \\omega(n + \\frac{1}{2})$。在逆温度 $\\beta = 1/(k_{\\mathrm{B}}T)$ 下，正则配分函数 $Z$ 定义为玻尔兹曼算符的迹，$Z = \\mathrm{Tr}[e^{-\\beta \\hat{H}}]$。在能量本征基中，这变成对所有态的求和：\n$$Z_{\\mathrm{exact}} = \\sum_{n=0}^{\\infty} e^{-\\beta E_n} = \\sum_{n=0}^{\\infty} e^{-\\beta \\omega (n + 1/2)}$$\n我们可以提出基态贡献的因子，并将剩余的和​​识别为一个几何级数：\n$$Z_{\\mathrm{exact}} = e^{-\\beta \\omega/2} \\sum_{n=0}^{\\infty} (e^{-\\beta \\omega})^n$$\n几何级数 $\\sum_{n=0}^{\\infty} x^n$ 在 $|x|<1$ 时收敛于 $1/(1-x)$。在这里，$x=e^{-\\beta\\omega}$，对于正的 $\\beta$ 和 $\\omega$ 该值恒小于 $1$。因此，该和的计算结果为 $1/(1-e^{-\\beta\\omega})$。将其代回，我们得到：\n$$Z_{\\mathrm{exact}} = \\frac{e^{-\\beta \\omega/2}}{1 - e^{-\\beta \\omega}} = \\frac{1}{e^{\\beta \\omega/2} - e^{-\\beta \\omega/2}}$$\n这个表达式等价于双曲余割函数：\n$$Z_{\\mathrm{exact}}(\\beta, \\omega) = \\frac{1}{2\\sinh(\\beta\\omega/2)}$$\n注意，此表达式与质量 $m$ 无关。\n\n接下来，我们从离散化的虚时路径积分表述推导近似配分函数 $Z_P$。配分函数可以表示为在虚时 $\\tau \\in [0, \\beta\\hbar]$ 上对闭合路径的积分。将这个时间间隔离散化为 $P$ 个步长为 $\\epsilon = \\beta/P$ 的步，并使用原始 Trotter 分解 $e^{-\\beta \\hat{H}} \\approx (e^{-\\epsilon \\hat{V}} e^{-\\epsilon \\hat{T}})^P$，可得到 $Z_P$ 的表达式：\n$$Z_P = \\mathrm{Tr}\\left[ \\left(e^{-\\frac{\\beta}{P}\\hat{T}} e^{-\\frac{\\beta}{P}\\hat{V}}\\right)^P \\right]$$\n在算符之间插入完备的位置本征态集，会得到一个对循环聚合物链（“环状聚合物”）的位置 $q_1, q_2, \\ldots, q_P$ 的类经典组态积分。对于质量为 $m$ 的粒子，表达式为：\n$$Z_P = \\left(\\frac{mP}{2\\pi\\beta\\hbar^2}\\right)^{P/2} \\int_{-\\infty}^{\\infty} \\! \\dots \\! \\int_{-\\infty}^{\\infty} d\\mathbf{q} \\exp\\left(-\\sum_{i=1}^{P} \\left[ \\frac{mP}{2\\beta\\hbar^2}(q_{i+1}-q_i)^2 + \\frac{\\beta}{P}V(q_i) \\right] \\right)$$\n其中 $q_{P+1} \\equiv q_1$ 强制执行环的闭合。在我们的约化单位制（$\\hbar=1$）和简谐势 $V(q) = \\frac{1}{2}m\\omega^2 q^2$ 下，指数的参数变为：\n$$S(\\mathbf{q}) = \\sum_{i=1}^{P} \\left[ \\frac{mP}{2\\beta}(q_{i+1}-q_i)^2 + \\frac{\\beta m\\omega^2}{2P} q_i^2 \\right]$$\n该积分为多维高斯积分。项 $S(\\mathbf{q})$ 可以写成二次型 $S(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^T \\mathbf{A} \\mathbf{q}$，其中 $\\mathbf{q} = (q_1, \\ldots, q_P)^T$ 且 $\\mathbf{A}$ 是一个 $P \\times P$ 的对称矩阵。$\\mathbf{A}$ 的元素可以通过展开求和得到：\n$$A_{ij} = m \\left[ \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right)\\delta_{ij} - \\frac{P}{\\beta}(\\delta_{i,j+1} + \\delta_{i,j-1}) \\right]$$\n其中索引按模 $P$ 计算。这是一个循环矩阵。\n$d$ 维高斯积分的通用公式为 $\\int d^d\\mathbf{x} \\exp(-\\frac{1}{2}\\mathbf{x}^T \\mathbf{M} \\mathbf{x}) = (2\\pi)^{d/2} (\\det \\mathbf{M})^{-1/2}$。将此公式应用于我们对 $Z_P$ 的积分，得到：\n$$Z_P = \\left(\\frac{mP}{2\\pi\\beta}\\right)^{P/2} (2\\pi)^{P/2} (\\det \\mathbf{A})^{-1/2} = \\left(\\frac{mP}{\\beta}\\right)^{P/2} m^{-P/2} (\\det \\mathbf{A}')^{-1/2} = \\left(\\frac{P}{\\beta}\\right)^{P/2} (\\det \\mathbf{A}')^{-1/2}$$\n其中 $\\mathbf{A}' = \\mathbf{A}/m$。质量 $m$ 被消去，与精确结果一致。循环矩阵 $\\mathbf{A}'$ 的本征值 $\\lambda_k$ 由其第一行的离散傅里叶变换给出。对于 $k=0, 1, \\dots, P-1$：\n$$\\lambda_k = \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right) - \\frac{P}{\\beta}e^{2\\pi i k/P} - \\frac{P}{\\beta}e^{-2\\pi i k/P} = \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right) - \\frac{2P}{\\beta}\\cos\\left(\\frac{2\\pi k}{P}\\right)$$\n使用恒等式 $1-\\cos(2\\theta) = 2\\sin^2(\\theta)$，上式可简化为：\n$$\\lambda_k = \\frac{2P}{\\beta} \\left(1 - \\cos\\left(\\frac{2\\pi k}{P}\\right)\\right) + \\frac{\\beta\\omega^2}{P} = \\frac{4P}{\\beta}\\sin^2\\left(\\frac{\\pi k}{P}\\right) + \\frac{\\beta\\omega^2}{P}$$\n行列式是本征值的乘积，即 $\\det \\mathbf{A}' = \\prod_{k=0}^{P-1} \\lambda_k$。将此代入 $Z_P$ 的表达式中，得到最终的可计算公式：\n$$Z_P(\\beta, \\omega) = \\left(\\frac{P}{\\beta}\\right)^{P/2} \\left[ \\prod_{k=0}^{P-1} \\left( \\frac{4P}{\\beta}\\sin^2\\left(\\frac{\\pi k}{P}\\right) + \\frac{\\beta\\omega^2}{P} \\right) \\right]^{-1/2}$$\n为了进行数值计算，特别是对于大的 $P$，计算 $Z_P$ 的对数更为稳定：\n$$\\log Z_P = \\frac{P}{2} \\log\\left(\\frac{P}{\\beta}\\right) - \\frac{1}{2} \\sum_{k=0}^{P-1} \\log(\\lambda_k)$$\n此表达式是路径积分表述的直接结果，并代表了 PIMC 模拟的目标值。\n\n最后的要求是分析当 $P$ 增大时 $Z_P$ 向 $Z_{\\mathrm{exact}}$ 的收敛情况。原始 Trotter 近似引入的误差与珠子数量 $P$ 成比例。我们预期绝对误差存在幂律关系：\n$$|Z_P - Z_{\\mathrm{exact}}| \\approx C P^{-r}$$\n其中 $C$ 是一个常数，$r$ 是收敛指数。为了确定 $r$，我们可以对此方程的对数形式执行线性回归：\n$$\\log|Z_P - Z_{\\mathrm{exact}}| \\approx \\log C - r \\log P$$\n这是一个形如 $y = b + mx$ 的线性方程，其中 $y = \\log|Z_P - Z_{\\mathrm{exact}}|$，$x = \\log P$，斜率 $m = -r$，截距 $b = \\log C$。我们将计算 $P \\in \\{1, 2, 4, 8, 16, 32, 64\\}$ 时的误差，并使用最后四个数据点（$P \\in \\{8, 16, 32, 64\\}$）进行线性最小二乘拟合以提取斜率 $m$。收敛指数即为 $r = -m$。对于此处使用的原始算法，理论考虑预测 $r=2$。实现部分将为每个测试用例计算该指数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing the exact and path-integral discretized\n    partition functions for a quantum harmonic oscillator.\n    \"\"\"\n\n    # Test cases from the problem statement: (beta, omega)\n    test_cases = [\n        (0.5, 1.0),\n        (1.0, 1.0),\n        (3.0, 1.0),\n        (1.0, 0.5),\n    ]\n\n    # Trotter numbers for the analysis\n    P_values = np.array([1, 2, 4, 8, 16, 32, 64])\n\n    # List to store the final convergence exponents r for each test case\n    convergence_exponents = []\n\n    for beta, omega in test_cases:\n        # 1. Calculate the exact partition function Z_exact\n        # Z_exact = 1 / (2 * sinh(beta * omega / 2))\n        z_exact = 1.0 / (2.0 * np.sinh(beta * omega / 2.0))\n\n        errors = []\n        for P in P_values:\n            # 2. Calculate the discretized path integral partition function Z_P\n            # The formula is derived in the solution text. We compute its logarithm\n            # for numerical stability.\n            # log(Z_P) = (P/2)*log(P/beta) - (1/2)*sum_{k=0}^{P-1}log(lambda_k)\n            # lambda_k = (4P/beta)*sin^2(pi*k/P) + (beta*omega^2)/P\n\n            k_vals = np.arange(P)\n            sin_term = np.sin(np.pi * k_vals / P)**2\n            lambda_k = (4.0 * P / beta) * sin_term + (beta * omega**2 / P)\n            \n            # The logarithm of lambda_k can have -inf if lambda_k is 0,\n            # which does not happen for omega > 0.\n            log_lambda_k_sum = np.sum(np.log(lambda_k))\n\n            log_z_p = (P / 2.0) * np.log(P / beta) - 0.5 * log_lambda_k_sum\n            z_p = np.exp(log_z_p)\n\n            # 3. Compute the absolute error\n            error = np.abs(z_p - z_exact)\n            errors.append(error)\n\n        # 4. Fit the convergence rate r from the last four P values\n        # Model: error = C * P^(-r) => log(error) = log(C) - r * log(P)\n        # We perform a linear fit on log-log data.\n        \n        # Use last four points for the fit: P = {8, 16, 32, 64}\n        fit_P_values = P_values[-4:]\n        fit_errors = np.array(errors[-4:])\n        \n        log_P = np.log(fit_P_values)\n        log_error = np.log(fit_errors)\n\n        # Using numpy's polyfit to find the slope of the linear regression\n        # polyfit returns [slope, intercept] for degree 1\n        slope, _ = np.polyfit(log_P, log_error, 1)\n\n        # The convergence exponent r is the negative of the slope\n        r = -slope\n        convergence_exponents.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in convergence_exponents)}]\")\n\nsolve()\n```", "id": "2659206"}, {"introduction": "从上一个练习中我们知道，更大的珠子数 $P$ 会带来更高的精度，但在实际模拟中我们该如何选择 $P$ 呢？本实践将重点从理论收敛性转向实际应用，解决任何PIMD模拟都会面临的关键问题：如何为给定的精度要求选择最合适的珠子数 $P$。您将通过监测一个物理可观测量（势能）的收敛行为，学习一套系统性的方法来确定所需的最小$P$值，这是设计高效模拟的一项核心技能。[@problem_id:2914414]", "problem": "您将实现一个程序，对于一个通过路径积分分子动力学（PIMD）建模的量子谐振子，该程序旨在确定满足势能估计值特定收敛准则所需的最小虚时切片（“珠子”）数量。该谐振子的角频率为 $\\omega$（单位：弧度/秒），系统处于绝对温度 $T$（单位：开尔文）下。请使用约化普朗克常数 $\\hbar$（单位：焦耳·秒）和玻尔兹曼常数 $k_{\\mathrm{B}}$（单位：焦耳/开尔文）。珠子数 $P$ 是一个正整数。\n\n将使用的基本原理和定义：\n- 谐振子势能的精确正则系综量子期望值为\n$$\n\\langle V \\rangle_{\\mathrm{exact}} \\;=\\; \\frac{1}{4}\\,\\hbar\\,\\omega\\,\\coth\\!\\left(\\frac{\\beta\\,\\hbar\\,\\omega}{2}\\right),\n$$\n其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n- 在具有 $P$ 个珠子的原始 Trotter 环状聚合物离散化中，环状聚合物的角频率为 $\\omega_{P} = P/(\\beta \\hbar)$，简正模的本征值为 $\\lambda_{k} = 4 \\sin^{2}(\\pi k / P)$，其中 $k \\in \\{0,1,\\dots,P-1\\}$。对于有限的 $P$，谐振子势能的珠子平均 PIMD 估计量为\n$$\n\\langle V \\rangle_{P} \\;=\\; \\frac{1}{2\\beta}\\,\\frac{\\omega^{2}}{P}\\,\\sum_{k=0}^{P-1}\\,\\frac{1}{\\omega_{P}^{2}\\,\\lambda_{k} \\;+\\; \\omega^{2}/P}.\n$$\n所有三角函数的参数均以弧度为单位。\n\n需要实现的收敛与接受逻辑：\n- 定义相对误差 $e(P) = \\left|\\langle V \\rangle_{P} - \\langle V \\rangle_{\\mathrm{exact}}\\right| / \\left|\\langle V \\rangle_{\\mathrm{exact}}\\right|$。\n- 给定一个目标容差 $\\varepsilon$ 和一个最小缩减因子 $\\rho_{\\min}$，在集合 $\\{1,2,4,8,16,32,64,128,256\\}$ 中按升序搜索珠子数 $P$，并找到满足以下条件的最小 $P$：\n  - 如果 $P = 1$：当 $e(1) \\le \\varepsilon$ 时接受。\n  - 如果 $P \\ge 2$：当 $e(P) \\le \\varepsilon$ 且 $e(P\\!/2)/e(P) \\ge \\rho_{\\min}$ 时接受。\n- 如果集合中没有 $P$ 满足接受条件，则返回 $-1$。\n\n将使用的物理常数：\n- $\\hbar = 1.054571817\\times 10^{-34}$ 焦耳·秒。\n- $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}$ 焦耳/开尔文。\n\n单位和数值要求：\n- 输入参数 $\\omega$ 的单位必须是弧度/秒，$T$ 的单位是开尔文。任何三角函数的角度单位都是弧度。\n- 程序必须使用上述公式进行计算，并以整数形式生成输出。输出中不应打印任何物理单位。\n\n测试套件：\n您的程序必须使用上面给出的常数，评估以下参数集，每个参数集指定为一个元组 $(\\omega, T, \\varepsilon, \\rho_{\\min})$：\n- 情况 1（中等区间，理想路径）：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(2.0\\times 10^{14},\\; 300.0,\\; 1.0\\times 10^{-3},\\; 3.0\\right)$。\n- 情况 2（高温经典极限）：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(1.0\\times 10^{13},\\; 5000.0,\\; 1.0\\times 10^{-3},\\; 3.0\\right)$。\n- 情况 3（量子主导的低温）：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(5.0\\times 10^{14},\\; 50.0,\\; 1.0\\times 10^{-3},\\; 3.0\\right)$。\n- 情况 4（严苛容差，极低温）：$(\\omega, T, \\varepsilon, \\rho_{\\min}) = \\left(1.0\\times 10^{15},\\; 5.0,\\; 1.0\\times 10^{-4},\\; 3.5\\right)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含测试套件的结果，格式为方括号内以逗号分隔的整数列表，顺序与上述情况相同（例如, $[P_{1},P_{2},P_{3},P_{4}]$）。如果某个情况在允许的珠子数范围内未能满足接受标准，则在该位置使用 $-1$。", "solution": "问题陈述已经过严格验证，并被确定为有效。这是一个在计算量子统计力学中表述清晰、有科学依据的问题，没有矛盾、歧义或事实错误。所提供的谐振子精确量子势能 $\\langle V \\rangle_{\\mathrm{exact}}$ 及其路径积分分子动力学（PIMD）估计量 $\\langle V \\rangle_{P}$ 的公式，在指定的理论框架内是正确的表述。任务是基于这些原理实现一个数值算法。\n\n解决方案首先定义必要的物理量，然后构建一个算法来寻找满足双重收敛准则的 PIMD 珠子最小数量 $P$。\n\n首先，我们确立基本物理量。系统处于绝对温度 $T$ 下，我们为此定义了逆热能 $\\beta = 1/(k_{\\mathrm{B}} T)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。量子谐振子的角频率为 $\\omega$。\n\n作为我们基准的势能精确正则期望值由下式给出：\n$$\n\\langle V \\rangle_{\\mathrm{exact}} = \\frac{1}{4}\\hbar\\omega\\coth\\left(\\frac{\\beta\\hbar\\omega}{2}\\right)\n$$\n此处，$\\hbar$ 是约化普朗克常数。该表达式由量子谐振子的正则配分函数推导而来，代表了一次完美模拟应该得出的真实值。\n\n具有 $P$ 个珠子的 PIMD 近似将单个量子粒子建模为一个由 $P$ 个珠子通过谐振弹簧连接而成的经典环状聚合物。使用原始 Trotter 离散化，该模型的势能估计量为：\n$$\n\\langle V \\rangle_{P} = \\frac{1}{2\\beta}\\frac{\\omega^{2}}{P}\\sum_{k=0}^{P-1}\\frac{1}{\\omega_{P}^{2}\\lambda_{k} + \\omega^{2}/P}\n$$\n在此表达式中，$\\omega_{P} = P/(\\beta \\hbar)$ 是环状聚合物弹簧的特征频率，而 $\\lambda_{k} = 4 \\sin^{2}(\\pi k / P)$（其中 $k \\in \\{0, 1, \\dots, P-1\\}$）是与自由聚合物环的振动简正模相关的本征值。$\\langle V \\rangle_{P}$ 的公式正确地表示了同构经典环状聚合物模型中的珠子平均势能。当 $P \\to \\infty$ 时，已知 $\\langle V \\rangle_{P}$ 收敛于 $\\langle V \\rangle_{\\mathrm{exact}}$。此特定估计量的误差按 $O(1/P^2)$ 标度变化。\n\n问题的核心是设计一个算法，从指定的离散集合 $\\{1, 2, 4, 8, 16, 32, 64, 128, 256\\}$ 中找到满足给定收敛准则的最小 $P$。主要准则是相对误差 $e(P)$，定义为：\n$$\ne(P) = \\frac{\\left|\\langle V \\rangle_{P} - \\langle V \\rangle_{\\mathrm{exact}}\\right|}{\\left|\\langle V \\rangle_{\\mathrm{exact}}\\right|}\n$$\n寻找可接受的 $P$ 的过程如下：对于集合中按升序排列的每个 $P$ 值，我们计算 $\\langle V \\rangle_{P}$ 及其对应的误差 $e(P)$。\n如果一个 $P$ 值满足规定的条件，则被认为是可接受的：\n1.  对于 $P=1$：误差必须低于指定的容差，即 $e(1) \\le \\varepsilon$。\n2.  对于 $P \\ge 2$：必须满足一个双重条件。首先，误差必须低于容差，$e(P) \\le \\varepsilon$。其次，收敛必须足够快，这是通过前一步误差与当前误差的比率来衡量的：$e(P/2)/e(P) \\ge \\rho_{\\min}$。这第二个条件确保了增加珠子数量能带来有意义的改进，并与预期的 $O(1/P^2)$ 收敛率一致，对于该收敛率，误差比率预期约为 $(P/(P/2))^2 = 4$。要求该比率大于 $\\rho_{\\min}$（例如 $3.0$或$3.5$）是防止收敛缓慢或不稳定的标准检查方法。\n\n实现将包含一个主循环，用于遍历所提供的测试用例。对于每个用例，一个内循环将遍历允许的 $P$ 值。在此内循环中，将调用计算 $\\langle V \\rangle_{\\mathrm{exact}}$ 和 $\\langle V \\rangle_{P}$ 的函数，计算误差 $e(P)$，并检查接受准则。第一个满足准则的 $P$ 值将被记录为该测试用例的结果。如果内循环结束时仍未找到合适的 $P$ 值，则结果记录为 $-1$，表示在给定约束条件下未能收敛。所有计算都将使用为 $\\hbar$ 和 $k_{\\mathrm{B}}$ 提供的高精度值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants given in the problem statement.\nHB_CONST = 1.054571817e-34  # Joule second\nKB_CONST = 1.380649e-23     # Joule per Kelvin\n\ndef calculate_V_exact(omega, T):\n    \"\"\"\n    Calculates the exact canonical quantum expectation of the harmonic\n    oscillator potential energy.\n    \"\"\"\n    if T <= 0 or omega <= 0:\n        return 0.0\n\n    beta = 1.0 / (KB_CONST * T)\n    arg = (beta * HB_CONST * omega) / 2.0\n\n    # np.tanh is numerically stable. For large arg, tanh(arg) -> 1.\n    # coth(x) = 1 / tanh(x)\n    if arg > 709: # np.tanh(710) is 1.0, avoid overflow in exp(2*arg)\n        coth_val = 1.0\n    else:\n        coth_val = 1.0 / np.tanh(arg)\n    \n    V_exact = (1.0 / 4.0) * HB_CONST * omega * coth_val\n    return V_exact\n\ndef calculate_V_P(P, omega, T):\n    \"\"\"\n    Calculates the bead-averaged PIMD estimator for the potential energy\n    of the harmonic oscillator at finite P.\n    \"\"\"\n    if T <= 0 or omega <= 0:\n        return 0.0\n\n    beta = 1.0 / (KB_CONST * T)\n    omega_P = P / (beta * HB_CONST)\n\n    k_vals = np.arange(P)\n    \n    # lambda_k = 4 * sin^2(pi*k/P)\n    lambda_k = 4.0 * np.sin(np.pi * k_vals / P)**2\n    \n    # Denominator in the summation term\n    denominator_term = omega_P**2 * lambda_k + omega**2 / P\n    \n    # The term for k=0 should be handled carefully if omega=0, but problem\n    # constraints ensure omega is a large positive number.\n    sum_val = np.sum(1.0 / denominator_term)\n    \n    V_P = (1.0 / (2.0 * beta)) * (omega**2 / P) * sum_val\n    return V_P\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (omega, T, epsilon, rho_min)\n        (2.0e14, 300.0, 1.0e-3, 3.0),   # Case 1\n        (1.0e13, 5000.0, 1.0e-3, 3.0),  # Case 2\n        (5.0e14, 50.0, 1.0e-3, 3.0),    # Case 3\n        (1.0e15, 5.0, 1.0e-4, 3.5),     # Case 4\n    ]\n\n    results = []\n    P_values = [1, 2, 4, 8, 16, 32, 64, 128, 256]\n\n    for case in test_cases:\n        omega, T, epsilon, rho_min = case\n        \n        V_exact = calculate_V_exact(omega, T)\n        \n        found_P = -1\n        errors = {}\n\n        for P in P_values:\n            V_P = calculate_V_P(P, omega, T)\n            \n            # V_exact is always positive for T>0, omega>0, so no division by zero.\n            error = abs(V_P - V_exact) / abs(V_exact)\n            errors[P] = error\n\n            # Check acceptance criteria based on P\n            if P == 1:\n                if error <= epsilon:\n                    found_P = P\n                    break\n            else:  # P >= 2\n                prev_error = errors[P // 2]\n                \n                # If current error is zero, convergence is perfect, ratio is effectively infinite\n                # and thus greater than rho_min.\n                ratio_ok = (error == 0.0) or (prev_error / error >= rho_min)\n\n                if error <= epsilon and ratio_ok:\n                    found_P = P\n                    break\n        \n        results.append(found_P)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2914414"}, {"introduction": "在模拟复杂系统时，计算原子间的力往往是PIMD模拟中最耗时的部分，特别是当总作用力可以分解为多个计算成本差异巨大的分量时。本实践将向您介绍一种先进且强大的优化技术——环状聚合物收缩 (Ring Polymer Contraction, RPC)。您将学习如何通过对不同力分量采用不同级别的近似（例如，仅在质心或少数路径积分模式上计算昂贵的力）来显著降低计算成本，这使得PIMD能够被应用于更真实、更复杂的体系。[@problem_id:2914435]", "problem": "实现一个程序，该程序针对路径积分分子动力学 (PIMD) 形式下的一个一维量子粒子，计算完整的多分量力评估与其环状聚合物收缩 (RPC) 近似之间的差异。该 RPC 近似对两个不同的高代价力分量使用了两种不同的收缩策略。请在原子单位下进行计算，因此约化普朗克常数为 $\\hbar = 1$，玻尔兹曼常数为 $k_{\\mathrm{B}} = 1$。能量必须以哈特里 (Hartree) 表示，长度以玻尔 (Bohr) 表示，力以哈特里每玻尔 (Hartree per Bohr) 表示。任何三角函数中使用的角度必须以弧度为单位。\n\n从虚时路径积分离散化为 $P$ 个珠子开始，其中逆温度为 $\\beta$，质量为 $m$，环状聚合物频率为 $\\omega_{P} = \\dfrac{P}{\\beta \\hbar} = \\dfrac{P}{\\beta}$。对于一个构型 $\\mathbf{q} = (q_{0},\\ldots,q_{P-1})$，其环状聚合物哈密顿量为\n$$\nH_{P}(\\mathbf{q},\\mathbf{p}) = \\sum_{j=0}^{P-1} \\left[ \\dfrac{p_{j}^{2}}{2 m} + \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{j} - q_{j+1}\\right)^{2} \\right] + \\sum_{j=0}^{P-1} V(q_{j}),\n$$\n其中存在周期性边界条件 $q_{P} \\equiv q_{0}$。作用在珠子 $j$ 上的力的构型部分为 $- \\dfrac{\\partial}{\\partial q_{j}} \\left[ \\sum_{k} \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{k} - q_{k+1}\\right)^{2} + \\sum_{k} V(q_{k}) \\right]$。\n\n考虑将势能分解为三个分量，\n$$\nV(x) = V_{\\mathrm{L}}(x) + \\Delta V_{\\mathrm{A}}(x) + \\Delta V_{\\mathrm{B}}(x),\n$$\n其定义如下：\n- 应用于完整环状聚合物的低代价分量：\n$$\nV_{\\mathrm{L}}(x) = \\dfrac{1}{2} k_{\\mathrm{L}} x^{2}.\n$$\n- 待收缩至质心的高代价分量 $\\Delta V_{\\mathrm{A}}$（质心收缩）：\n$$\n\\Delta V_{\\mathrm{A}}(x) = \\alpha x^{4}.\n$$\n- 待通过环状聚合物简正模空间中的低通投影算符进行收缩的高代价分量 $\\Delta V_{\\mathrm{B}}$（低通收缩）：\n$$\n\\Delta V_{\\mathrm{B}}(x) = \\dfrac{1}{2} k_{\\mathrm{B}} x^{2}.\n$$\n\n将质心定义为\n$$\nq_{\\mathrm{c}} = \\dfrac{1}{P} \\sum_{j=0}^{P-1} q_{j}.\n$$\n将 $\\mathbb{C}^{P}$ 上的幺正离散傅里叶变换 (DFT) 及其逆变换定义为\n$$\n\\hat{\\mathbf{q}} = \\dfrac{1}{\\sqrt{P}} \\sum_{n=0}^{P-1} q_{n} \\, e^{- 2 \\pi i k n / P}, \\quad\n\\mathbf{q} = \\dfrac{1}{\\sqrt{P}} \\sum_{k=0}^{P-1} \\hat{q}_{k} \\, e^{+ 2 \\pi i k n / P},\n$$\n在数值上通过缩放标准的DFT和逆DFT来实现，以使变换是幺正的。对于一个给定的非负整数截断值 $k_{\\max}$，定义低通投影算符 $\\mathcal{P}_{\\mathrm{L}}$，其作用是保留模式 $k \\in \\{0,1,\\ldots,k_{\\max}\\}$ 及其复共轭配对模式 $P-k$（当不同时），并将所有其他模式置零。投影坐标为\n$$\n\\mathbf{q}^{\\mathrm{low}} = \\mathcal{P}_{\\mathrm{L}} \\mathbf{q}.\n$$\n在对 $\\Delta V_{\\mathrm{A}}$ 进行质心收缩时，用 $P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}})$ 替换 $\\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{A}}(q_{j})$。在对 $\\Delta V_{\\mathrm{B}}$ 进行低通收缩时，用 $\\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j})$ 替换 $\\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q_{j})$。\n\n力必须从这些近似中导出。使用链式法则：\n- 作用在珠子 $j$ 上的弹簧力为\n$$\nF^{\\mathrm{spring}}_{j} = - m \\omega_{P}^{2} \\left(2 q_{j} - q_{j-1} - q_{j+1}\\right).\n$$\n- 作用在珠子 $j$ 上的低代价分量力为\n$$\nF^{\\mathrm{L}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} V_{\\mathrm{L}}(x)\\bigg|_{x=q_{j}} = - k_{\\mathrm{L}} q_{j}.\n$$\n- $\\Delta V_{\\mathrm{A}}$ 的质心收缩力为\n$$\nF^{\\mathrm{A,RPC}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\left[ P \\, \\Delta V_{\\mathrm{A}}(x) \\right]\\bigg|_{x=q_{\\mathrm{c}}} \\cdot \\dfrac{\\partial q_{\\mathrm{c}}}{\\partial q_{j}} = - 4 \\alpha q_{\\mathrm{c}}^{3}.\n$$\n- $\\Delta V_{\\mathrm{B}}$ 的低通收缩力为，其中 $\\mathbf{g}$ 按珠子定义为 $g_{j} = \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\Delta V_{\\mathrm{B}}(x)\\big|_{x=q^{\\mathrm{low}}_{j}} = k_{\\mathrm{B}} q^{\\mathrm{low}}_{j}$，\n$$\n\\mathbf{F}^{\\mathrm{B,RPC}} = - \\mathcal{P}_{\\mathrm{L}} \\, \\mathbf{g}.\n$$\n因为 $\\mathcal{P}_{\\mathrm{L}}$ 是一个由幺正DFT构建的幂等正交投影算符，这可以简化为\n$$\n\\mathbf{F}^{\\mathrm{B,RPC}} = - k_{\\mathrm{B}} \\, \\mathbf{q}^{\\mathrm{low}}.\n$$\n\n为了比较，将完整（未收缩）的势能和力定义为\n$$\nV_{\\mathrm{full}} = \\dfrac{1}{2} m \\omega_{P}^{2} \\sum_{j=0}^{P-1} \\left(q_{j} - q_{j+1}\\right)^{2} + \\sum_{j=0}^{P-1} \\left[ V_{\\mathrm{L}}(q_{j}) + \\Delta V_{\\mathrm{A}}(q_{j}) + \\Delta V_{\\mathrm{B}}(q_{j}) \\right],\n$$\n和\n$$\nF^{\\mathrm{A,full}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\Delta V_{\\mathrm{A}}(x)\\bigg|_{x=q_{j}} = - 4 \\alpha q_{j}^{3}, \\quad\nF^{\\mathrm{B,full}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\Delta V_{\\mathrm{B}}(x)\\bigg|_{x=q_{j}} = - k_{\\mathrm{B}} q_{j}.\n$$\n将 RPC 近似的势能定义为\n$$\nV_{\\mathrm{RPC}} = \\dfrac{1}{2} m \\omega_{P}^{2} \\sum_{j=0}^{P-1} \\left(q_{j} - q_{j+1}\\right)^{2} + \\sum_{j=0}^{P-1} V_{\\mathrm{L}}(q_{j}) + P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j}),\n$$\n其相应的总力为 $\\mathbf{F}_{\\mathrm{RPC}} = \\mathbf{F}^{\\mathrm{spring}} + \\mathbf{F}^{\\mathrm{L}} + \\mathbf{F}^{\\mathrm{A,RPC}} + \\mathbf{F}^{\\mathrm{B,RPC}}$。\n\n您的程序必须对下面列出的每个测试用例计算：\n- 能量差 $\\Delta E = V_{\\mathrm{RPC}} - V_{\\mathrm{full}}$，单位为哈特里。\n- 均方根 (RMS) 力差\n$$\n\\mathrm{RMS} = \\sqrt{ \\dfrac{1}{P} \\sum_{j=0}^{P-1} \\left( F_{\\mathrm{RPC},j} - F_{\\mathrm{full},j} \\right)^{2} }\n$$\n单位为哈特里每玻尔。\n\n测试套件（正弦和余弦函数内的角度以弧度为单位）：\n- 案例 $\\#1$：$P = 8$，$\\beta = 10.0$， $m = 1.0$， $k_{\\mathrm{L}} = 1.5$， $\\alpha = 0.05$， $k_{\\mathrm{B}} = 0.7$， $k_{\\max} = 1$，珠子坐标为\n$$\nq_{j} = 0.3 \\sin\\!\\left( \\dfrac{2 \\pi j}{P} \\right) + 0.1 \\cos\\!\\left( \\dfrac{4 \\pi j}{P} \\right), \\quad j = 0,\\ldots,P-1.\n$$\n- 案例 $\\#2$：$P = 6$，$\\beta = 4.0$， $m = 2.0$， $k_{\\mathrm{L}} = 0.8$， $\\alpha = 0.2$， $k_{\\mathrm{B}} = 1.1$， $k_{\\max} = 2$，且对于所有 $j$， $q_{j} = 0.2$。\n- 案例 $\\#3$：$P = 10$，$\\beta = 2.5$， $m = 1.0$， $k_{\\mathrm{L}} = 0.5$， $\\alpha = 0.1$，$k_{\\mathrm{B}} = 2.0$，$k_{\\max} = 1$，且对于所有 $j$， $q_{j} = 0.3 \\, (-1)^{j}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个扁平列表，内含 $2 \\times 3 = 6$ 个用方括号括起来并以逗号分隔的浮点数。这些数字必须按以下顺序排列：$[\\Delta E_{\\#1}, \\mathrm{RMS}_{\\#1}, \\Delta E_{\\#2}, \\mathrm{RMS}_{\\#2}, \\Delta E_{\\#3}, \\mathrm{RMS}_{\\#3}]$。", "solution": "该问题陈述在科学上是合理的，在计算上是适定的。它要求在一维量子系统的路径积分分子动力学 (PIMD) 形式下，实现环状聚合物收缩 (RPC) 近似，并将其与完整的、未收缩的计算进行比较。我们将为三个特定的测试用例计算势能差 $\\Delta E$ 和力的均方根 (RMS) 差。\n\n目标是计算两个量：\n$1$. 势能差 $\\Delta E = V_{\\mathrm{RPC}} - V_{\\mathrm{full}}$。\n$2$. 均方根力差 $\\mathrm{RMS} = \\sqrt{ \\dfrac{1}{P} \\sum_{j=0}^{P-1} \\left( F_{\\mathrm{RPC},j} - F_{\\mathrm{full},j} \\right)^{2} }$。\n\n总势能由下式给出：\n$$\nV_{\\mathrm{full}} = \\sum_{j=0}^{P-1} \\left[ \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{j} - q_{j+1}\\right)^{2} + V_{\\mathrm{L}}(q_{j}) + \\Delta V_{\\mathrm{A}}(q_{j}) + \\Delta V_{\\mathrm{B}}(q_{j}) \\right]\n$$\n$$\nV_{\\mathrm{RPC}} = \\sum_{j=0}^{P-1} \\left[ \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{j} - q_{j+1}\\right)^{2} + V_{\\mathrm{L}}(q_{j}) \\right] + P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j})\n$$\n能量差 $\\Delta E$ 得以简化，因为谐振弹簧项和低代价势能项 $V_{\\mathrm{L}}$ 在两个表达式中是相同的，因此相互抵消：\n$$\n\\Delta E = \\left( P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j}) \\right) - \\left( \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{A}}(q_{j}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q_{j}) \\right)\n$$\n代入具体的势能形式 $\\Delta V_{\\mathrm{A}}(x) = \\alpha x^{4}$ 和 $\\Delta V_{\\mathrm{B}}(x) = \\dfrac{1}{2} k_{\\mathrm{B}} x^{2}$，我们得到：\n$$\n\\Delta E = \\left( P \\alpha q_{\\mathrm{c}}^{4} + \\sum_{j=0}^{P-1} \\dfrac{1}{2} k_{\\mathrm{B}} (q^{\\mathrm{low}}_{j})^{2} \\right) - \\left( \\sum_{j=0}^{P-1} \\alpha q_{j}^{4} + \\sum_{j=0}^{P-1} \\dfrac{1}{2} k_{\\mathrm{B}} q_{j}^{2} \\right)\n$$\n\n同样，总力为：\n$$\nF_{\\mathrm{full},j} = F^{\\mathrm{spring}}_{j} + F^{\\mathrm{L}}_{j} + F^{\\mathrm{A,full}}_{j} + F^{\\mathrm{B,full}}_{j}\n$$\n$$\nF_{\\mathrm{RPC},j} = F^{\\mathrm{spring}}_{j} + F^{\\mathrm{L}}_{j} + F^{\\mathrm{A,RPC}}_{j} + F^{\\mathrm{B,RPC}}_{j}\n$$\n珠子 $j$ 上的力差 $\\Delta F_{j} = F_{\\mathrm{RPC},j} - F_{\\mathrm{full},j}$ 也得以简化，因为弹簧力和低代价力相互抵消：\n$$\n\\Delta F_{j} = \\left( F^{\\mathrm{A,RPC}}_{j} + F^{\\mathrm{B,RPC}}_{j} \\right) - \\left( F^{\\mathrm{A,full}}_{j} + F^{\\mathrm{B,full}}_{j} \\right)\n$$\n代入力表达式：\n- $F^{\\mathrm{A,RPC}}_{j} = - 4 \\alpha q_{\\mathrm{c}}^{3}$\n- $F^{\\mathrm{B,RPC}}_{j} = - k_{\\mathrm{B}} q^{\\mathrm{low}}_{j}$\n- $F^{\\mathrm{A,full}}_{j} = - 4 \\alpha q_{j}^{3}$\n- $F^{\\mathrm{B,full}}_{j} = - k_{\\mathrm{B}} q_{j}$\n我们得到珠子 $j$ 上的力差表达式：\n$$\n\\Delta F_{j} = \\left( -4 \\alpha q_{\\mathrm{c}}^{3} - k_{\\mathrm{B}} q^{\\mathrm{low}}_{j} \\right) - \\left( -4 \\alpha q_{j}^{3} - k_{\\mathrm{B}} q_{j} \\right) = 4 \\alpha (q_{j}^{3} - q_{\\mathrm{c}}^{3}) + k_{\\mathrm{B}} (q_{j} - q^{\\mathrm{low}}_{j})\n$$\n然后使用此 $\\Delta \\mathbf{F}$ 计算所有珠子的均方根力差。\n\n该算法的核心是计算质心 $q_{\\mathrm{c}}$ 和低通投影坐标 $\\mathbf{q}^{\\mathrm{low}}$。\n给定一个珠子构型向量 $\\mathbf{q} = (q_0, \\dots, q_{P-1})$：\n$1$. 质心就是算术平均值：$q_{\\mathrm{c}} = \\dfrac{1}{P} \\sum_{j=0}^{P-1} q_{j}$。\n$2$. 低通投影 $\\mathbf{q}^{\\mathrm{low}} = \\mathcal{P}_{\\mathrm{L}} \\mathbf{q}$ 是在环状聚合物简正模空间中执行的，该空间通过离散傅里叶变换 (DFT) 等效于频域。步骤如下：\n    a. 计算珠子坐标的幺正DFT：$\\hat{\\mathbf{q}} = \\dfrac{1}{\\sqrt{P}} \\mathrm{DFT}(\\mathbf{q})$。\n    b. 构建一个滤波器（掩码），对于要保留的模式，其值为 $1$，否则为 $0$。要保留的模式是 $k \\in \\{0, 1, \\dots, k_{\\max}\\}$ 及其对于 $k \\in \\{1, \\dots, k_{\\max}\\}$ 的复共轭配对模式 $P-k$。对于 $k=0$，它自身的配对模式就是自己。\n    c. 将滤波器应用于变换后的坐标：$\\hat{\\mathbf{q}}^{\\mathrm{low}}_{k} = \\hat{q}_{k} \\cdot \\mathrm{mask}_{k}$。\n    d. 计算滤波后坐标的逆幺正DFT以获得 $\\mathbf{q}^{\\mathrm{low}}$：$\\mathbf{q}^{\\mathrm{low}} = \\dfrac{1}{1/\\sqrt{P}} \\mathrm{IDFT}(\\hat{\\mathbf{q}}^{\\mathrm{low}}) = \\sqrt{P} \\cdot \\mathrm{IDFT}(\\hat{\\mathbf{q}}^{\\mathrm{low}})$。由于输入 $\\mathbf{q}$ 是实数且滤波器是对称的，$\\mathbf{q}^{\\mathrm{low}}$ 必须是实数。我们取结果的实部以舍弃由浮点不精确性产生的可忽略的虚部。\n\n实现将通过定义一个函数来进行，该函数接收给定测试用例的参数，构建珠子坐标向量 $\\mathbf{q}$，计算 $q_{\\mathrm{c}}$ 和 $\\mathbf{q}^{\\mathrm{low}}$，然后评估 $\\Delta E$ 和 $\\mathrm{RMS}(\\Delta \\mathbf{F})$ 的表达式。这个函数将为所提供的三个测试用例中的每一个都被调用。", "answer": "```python\nimport numpy as np\n\ndef calculate_quantities(P, beta, m, k_L, alpha, k_B, k_max, q_func):\n    \"\"\"\n    Computes the energy and RMS force differences for a given set of PIMD parameters.\n\n    Args:\n        P (int): Number of beads.\n        beta (float): Inverse temperature.\n        m (float): Mass of the particle.\n        k_L (float): Force constant for the cheap potential V_L.\n        alpha (float): Parameter for the expensive potential Delta V_A.\n        k_B (float): Force constant for the expensive potential Delta V_B.\n        k_max (int): Cutoff for the low-pass projector.\n        q_func (function): A function that takes (j, P) and returns the coordinate q_j.\n\n    Returns:\n        tuple[float, float]: A tuple containing (Delta E, RMS_force_diff).\n    \"\"\"\n\n    # 1. Generate bead coordinates\n    j_indices = np.arange(P)\n    q = q_func(j_indices, P)\n\n    # 2. Calculate intermediate quantities: centroid and low-pass coordinates\n    # 2a. Calculate centroid\n    q_c = np.mean(q)\n\n    # 2b. Calculate low-pass projected coordinates q_low\n    # Unitary DFT\n    q_hat = np.fft.fft(q) / np.sqrt(P)\n\n    # Create the low-pass filter mask\n    mask = np.zeros(P)\n    # Keep modes k = 0, 1, ..., k_max\n    mask[0 : k_max + 1] = 1\n    # Keep partner modes P-k for k = 1, ..., k_max\n    if k_max > 0:\n        mask[P - k_max : P] = 1\n\n    # Apply mask\n    q_hat_low = q_hat * mask\n\n    # Unitary inverse DFT\n    q_low = (np.fft.ifft(q_hat_low) * np.sqrt(P)).real\n\n    # 3. Calculate energy difference Delta E = V_RPC - V_full\n    # The spring and V_L terms cancel, so we only need the expensive parts.\n    # V_A_RPC = P * alpha * q_c^4\n    # V_B_RPC = sum(0.5 * k_B * q_low**2)\n    # V_A_full = sum(alpha * q**4)\n    # V_B_full = sum(0.5 * k_B * q**2)\n    \n    V_RPC = P * alpha * q_c**4 + 0.5 * k_B * np.sum(q_low**2)\n    V_full = alpha * np.sum(q**4) + 0.5 * k_B * np.sum(q**2)\n    \n    delta_E = V_RPC - V_full\n\n    # 4. Calculate RMS force difference\n    # Force difference Delta_F_j = (F_A_RPC_j + F_B_RPC_j) - (F_A_full_j + F_B_full_j)\n    # Delta_F_j = (-4*alpha*q_c^3 - k_B*q_low_j) - (-4*alpha*q_j^3 - k_B*q_j)\n    # Delta_F_j = 4*alpha*(q_j^3 - q_c^3) + k_B*(q_j - q_low_j)\n    \n    delta_F = 4.0 * alpha * (q**3 - q_c**3) + k_B * (q - q_low)\n    \n    rms_force_diff = np.sqrt(np.mean(delta_F**2))\n\n    return delta_E, rms_force_diff\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"P\": 8, \"beta\": 10.0, \"m\": 1.0, \"k_L\": 1.5, \"alpha\": 0.05, \"k_B\": 0.7, \"k_max\": 1,\n            \"q_func\": lambda j, P: 0.3 * np.sin(2 * np.pi * j / P) + 0.1 * np.cos(4 * np.pi * j / P)\n        },\n        {\n            \"P\": 6, \"beta\": 4.0, \"m\": 2.0, \"k_L\": 0.8, \"alpha\": 0.2, \"k_B\": 1.1, \"k_max\": 2,\n            \"q_func\": lambda j, P: 0.2 * np.ones_like(j, dtype=float)\n        },\n        {\n            \"P\": 10, \"beta\": 2.5, \"m\": 1.0, \"k_L\": 0.5, \"alpha\": 0.1, \"k_B\": 2.0, \"k_max\": 1,\n            \"q_func\": lambda j, P: 0.3 * (-1)**j\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_E, rms_force_diff = calculate_quantities(\n            P=case[\"P\"],\n            beta=case[\"beta\"],\n            m=case[\"m\"],\n            k_L=case[\"k_L\"],\n            alpha=case[\"alpha\"],\n            k_B=case[\"k_B\"],\n            k_max=case[\"k_max\"],\n            q_func=case[\"q_func\"]\n        )\n        results.extend([delta_E, rms_force_diff])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2914435"}]}