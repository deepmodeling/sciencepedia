{"hands_on_practices": [{"introduction": "玻恩-奥本海默分子动力学 (BOMD) 的核心在于将量子化学计算与经典核动力学相结合。这个练习将引导你构建该过程最基本的组成部分：单个积分时间步。通过为简化的谐振子模型实现Velocity Verlet算法，你将掌握将牛顿运动方程转化为可执行代码的关键技能，并理解“量子化学预言机”在每一步中提供力和能量的作用。[@problem_id:2451186]", "problem": "为一个在牛顿力学下、于电子基态势能面上演化的点核系统，实现 Born-Oppenheimer 分子动力学 (BOMD) 的单个核时间步长。电子势能和力由一个可调用的电子结构预言机（electronic-structure oracle）提供。所有原子均在一个空间维度上运动。使用原子单位：距离单位为玻尔（bohr），质量单位为电子质量，时间单位为原子时间单位，能量单位为哈特里（Hartree）。为每个测试用例返回一个时间步长后的总能量（势能加动能），以哈特里表示并四舍五入到八位小数。\n\n定义与要求：\n- 原子核遵循 Born-Oppenheimer 势能面上的牛顿第二定律：对于原子索引为 $i$，质量为 $m_i$，位置为 $R_i(t)$，速度为 $v_i(t)$，力为 $F_i(\\mathbf{R}) = -\\partial E(\\mathbf{R})/\\partial R_i$ 的原子，其加速度为 $a_i(t) = F_i(\\mathbf{R}(t))/m_i$。\n- 从 $t$ 到 $t+\\Delta t$ 的一个时间步长由以下位置和速度的更新方程定义，其中 $\\Delta t$ 是时间步长，并且必须在步末评估新位置处的力：\n  1. 使用当前位置、速度和加速度更新位置：\n     $$R_i(t+\\Delta t) = R_i(t) + v_i(t)\\,\\Delta t + \\frac{1}{2}a_i(t)\\,\\Delta t^2.$$\n  2. 在更新后的位置 $F_i(\\mathbf{R}(t+\\Delta t))$ 处评估新的力，以及相应的新加速度 $a_i(t+\\Delta t) = F_i(\\mathbf{R}(t+\\Delta t))/m_i$。\n  3. 使用旧加速度和新加速度的平均值更新速度：\n     $$v_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\big(a_i(t) + a_i(t+\\Delta t)\\big)\\,\\Delta t.$$\n- 本问题中使用的电子结构预言机返回以下模型基态势能和力。设键的集合由参数为 $(i,j,k,r_0)$ 的原子对指定。势能是谐振键贡献的总和：\n  $$E(\\mathbf{R}) = \\sum_{\\text{bonds }(i,j)} \\frac{1}{2}k\\left(\\lvert R_j - R_i\\rvert - r_0\\right)^2,$$\n  键 $(i,j)$ 对原子 $i$ 的力是该能量的负梯度。在一维情况下，当 $R_j \\ge R_i$ 时，键对原子 $j$ 的力是 $F_j = -k\\left((R_j-R_i)-r_0\\right)$，对原子 $i$ 的力是 $F_i = -F_j$；当 $R_j < R_i$ 时，用 $\\lvert R_j-R_i\\rvert$ 替换 $(R_j-R_i)$，并根据绝对值的导数给出适当的符号。\n- 在步末需要报告的总能量是\n  $$E_{\\text{tot}}(t+\\Delta t) = E(\\mathbf{R}(t+\\Delta t)) + \\sum_i \\frac{1}{2} m_i\\, v_i(t+\\Delta t)^2.$$\n\n测试套件：\n为以下四个独立的测试用例提供结果。在每个用例中，系统都是一维的，所有数组都按原子索引排序。键列表中的索引是基于零的。\n\n- 测试用例 A（零力，平衡位置静止）：\n  - 原子数：$2$。\n  - 质量：$\\big[m_0, m_1\\big] = \\big[1836, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0)\\big] = \\big[0.0, 1.0\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0)\\big] = \\big[0.0, 0.0\\big]$。\n  - 时间步长：$\\Delta t = 0.05$。\n  - 键：一个键 $(i,j,k,r_0) = (0, 1, 0.5, 1.0)$。\n\n- 测试用例 B（双原子拉伸，从静止释放）：\n  - 原子数：$2$。\n  - 质量：$\\big[m_0, m_1\\big] = \\big[1836, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0)\\big] = \\big[0.0, 1.1\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0)\\big] = \\big[0.0, 0.0\\big]$。\n  - 时间步长：$\\Delta t = 0.05$。\n  - 键：一个键 $(i,j,k,r_0) = (0, 1, 0.5, 1.0)$。\n\n- 测试用例 C（线性三原子，对称伸缩，中间原子更重）：\n  - 原子数：$3$。\n  - 质量：$\\big[m_0, m_1, m_2\\big] = \\big[1836, 3672, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0), R_2(0)\\big] = \\big[0.0, 1.1, 2.2\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0), v_2(0)\\big] = \\big[0.0, 0.0, 0.0\\big]$。\n  - 时间步长：$\\Delta t = 0.05$。\n  - 键：两个键 $(i,j,k,r_0) \\in \\{(0, 1, 0.7, 1.0), (1, 2, 0.7, 1.0)\\}$。\n\n- 测试用例 D（边界情况 $\\Delta t = 0$）：\n  - 原子数：$2$。\n  - 质量：$\\big[m_0, m_1\\big] = \\big[1836, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0)\\big] = \\big[0.0, 1.1\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0)\\big] = \\big[0.01, -0.02\\big]$。\n  - 时间步长：$\\Delta t = 0.0$。\n  - 键：一个键 $(i,j,k,r_0) = (0, 1, 0.5, 1.0)$。\n\n你的程序必须：\n- 完全按照上述说明实现时间步长更新。\n- 对每个测试用例，在初始位置精确调用一次电子结构预言机（以获得 $E(\\mathbf{R}(0))$ 和 $\\mathbf{F}(\\mathbf{R}(0))$），并在更新后的位置精确调用一次（以获得 $E(\\mathbf{R}(\\Delta t))$ 和 $\\mathbf{F}(\\mathbf{R}(\\Delta t))$）。\n- 对每个测试用例，计算 $E_{\\text{tot}}(\\Delta t)$ 并以哈特里为单位四舍五入到八位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含四个结果，形式为方括号括起来的逗号分隔列表，例如 $\\big[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D\\big]$，其中每个条目都是一个浮点数，格式化为小数点后八位，单位为哈特里。", "solution": "该问题已经过验证，被认为是科学上可靠、定义明确且客观的。它代表了理论化学领域中的一个标准计算任务。未发现任何缺陷。因此，兹提供一种解法。\n\n该问题要求实现一维点核系统的单时间步长 Born-Oppenheimer 分子动力学 (BOMD)。动力学过程由电子结构预言机提供的势能面 (PES) 上的经典牛顿力学控制。所有计算均在原子单位下进行。\n\n首先，我们定义物理模型。Born-Oppenheimer 近似假设电子运动与原子核运动是解耦的。这引入了 PES 的概念，$E(\\mathbf{R})$，其中总电子能量是核坐标 $\\mathbf{R} = \\{R_i\\}$ 的函数。原子核被视为经典的质点，其质量为 $\\{m_i\\}$，根据牛顿第二定律运动，其中作用在每个核上的力由 PES 导出：\n$$\n\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} E(\\mathbf{R}) \\implies F_i(\\mathbf{R}) = -\\frac{\\partial E(\\mathbf{R})}{\\partial R_i}\n$$\n每个原子核的加速度则由 $a_i(t) = F_i(\\mathbf{R}(t)) / m_i$ 给出。\n\n本问题中的特定 PES 是谐振子键势的总和：\n$$\nE(\\mathbf{R}) = \\sum_{\\text{bonds }(i,j)} E_{ij}(R_i, R_j) = \\sum_{\\text{bonds }(i,j)} \\frac{1}{2}k\\left(\\lvert R_j - R_i\\rvert - r_0\\right)^2\n$$\n其中对于每个键 $(i, j)$，$k$ 是力常数，$r_0$ 是平衡键长。由于与原子 $i$ 成键，作用在原子 $j$ 上的力是：\n$$\nF_{j \\leftarrow ij} = -\\frac{\\partial E_{ij}}{\\partial R_j} = -k\\left(\\lvert R_j - R_i\\rvert - r_0\\right) \\frac{\\partial \\lvert R_j - R_i\\rvert}{\\partial R_j} = -k\\left(\\lvert R_j - R_i\\rvert - r_0\\right) \\text{sgn}(R_j - R_i)\n$$\n根据牛顿第三定律，该键对原子 $i$ 的作用力为 $F_{i \\leftarrow ij} = -F_{j \\leftarrow ij}$。作用在任何给定原子 $i$ 上的总力 $F_i$ 是其参与的所有键产生的作用力的矢量和。\n\n为了将系统从时间 $t$ 传播到 $t+\\Delta t$，需要一个数值积分方案。问题指定了一种算法，它是著名的 Velocity Verlet 积分器的一种形式。单个时间步长的过程如下：\n\n1.  **给定**：在时间 $t$，位置 $\\mathbf{R}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t)$ 是已知的。加速度由当前位置的力计算得出：$\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{R}(t)) / \\mathbf{m}$。\n\n2.  **位置更新**：使用二阶泰勒展开计算新的位置 $\\mathbf{R}(t+\\Delta t)$：\n    $$\n    R_i(t+\\Delta t) = R_i(t) + v_i(t)\\Delta t + \\frac{1}{2}a_i(t)\\Delta t^2\n    $$\n\n3.  **力/加速度更新**：有了新的位置 $\\mathbf{R}(t+\\Delta t)$，使用电子结构预言机重新评估力 $\\mathbf{F}(\\mathbf{R}(t+\\Delta t))$。然后计算新的加速度 $\\mathbf{a}(t+\\Delta t)$：\n    $$\n    a_i(t+\\Delta t) = F_i(\\mathbf{R}(t+\\Delta t)) / m_i\n    $$\n\n4.  **速度更新**：使用旧加速度和新加速度的平均值来计算新的速度 $\\mathbf{v}(t+\\Delta t)$。这一步是 Velocity Verlet 算法的特点，也是其具有良好能量守恒特性的原因。\n    $$\n    v_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\left(a_i(t) + a_i(t+\\Delta t)\\right)\\Delta t\n    $$\n\n最后，计算时间步长结束时（$t+\\Delta t$）系统的总能量。这是新位置处的势能 $E(\\mathbf{R}(t+\\Delta t))$ 与用新速度计算的动能 $K(\\mathbf{v}(t+\\Delta t))$ 的总和：\n$$\nE_{\\text{tot}}(t+\\Delta t) = E(\\mathbf{R}(t+\\Delta t)) + K(\\mathbf{v}(t+\\Delta t)) = E(\\mathbf{R}(t+\\Delta t)) + \\sum_i \\frac{1}{2} m_i v_i(t+\\Delta t)^2\n$$\n这个量是每个测试用例所需的输出，需要四舍五入到八位小数。实现将包括一个根据给定势能模型来计算能量和力的函数，以及一个执行上述步骤的主传播函数。", "answer": "```python\nimport numpy as np\n\ndef compute_energy_and_forces(positions, bonds):\n    \"\"\"\n    Computes the potential energy and forces for a given set of atomic positions.\n    This function acts as the electronic-structure oracle.\n\n    Args:\n        positions (np.ndarray): 1D array of atomic positions.\n        bonds (list): List of bond tuples (i, j, k, r0).\n\n    Returns:\n        tuple: A tuple containing:\n            - potential_energy (float): The total potential energy in Hartree.\n            - forces (np.ndarray): 1D array of forces on each atom in Hartree/bohr.\n    \"\"\"\n    num_atoms = len(positions)\n    potential_energy = 0.0\n    forces = np.zeros(num_atoms, dtype=np.float64)\n\n    for i, j, k, r0 in bonds:\n        pos_i = positions[i]\n        pos_j = positions[j]\n\n        # Calculate bond vector and distance (scalar in 1D)\n        r_ij_vec = pos_j - pos_i\n        r_ij_mag = np.abs(r_ij_vec)\n\n        # Potential energy contribution\n        displacement = r_ij_mag - r0\n        potential_energy += 0.5 * k * displacement**2\n\n        # Force calculation: F = -grad(E) = -k * ( |r| - r0 ) * grad(|r|)\n        # The term grad_j(|r_j - r_i|) is sgn(r_j - r_i), which is r_ij_vec / r_ij_mag\n        if r_ij_mag > 1e-12:  # Avoid division by zero for coincident atoms\n            force_on_j = -k * displacement * (r_ij_vec / r_ij_mag)\n        else:\n            force_on_j = 0.0\n        \n        forces[j] += force_on_j\n        forces[i] -= force_on_j # Newton's third law\n\n    return potential_energy, forces\n\ndef run_timestep(masses, initial_positions, initial_velocities, bonds, dt):\n    \"\"\"\n    Performs a single time-step of Born-Oppenheimer Molecular Dynamics.\n\n    Args:\n        masses (np.ndarray): Array of atomic masses.\n        initial_positions (np.ndarray): Array of initial atomic positions.\n        initial_velocities (np.ndarray): Array of initial atomic velocities.\n        bonds (list): List of bond tuples.\n        dt (float): The time-step duration.\n\n    Returns:\n        float: The total energy (potential + kinetic) after the time-step.\n    \"\"\"\n    masses_arr = np.array(masses, dtype=np.float64)\n    R_t = np.array(initial_positions, dtype=np.float64)\n    v_t = np.array(initial_velocities, dtype=np.float64)\n\n    # Step 0: Calculate forces and accelerations at time t\n    _, F_t = compute_energy_and_forces(R_t, bonds)\n    a_t = F_t / masses_arr\n\n    # Step 1: Update positions to get R(t + dt)\n    R_t_dt = R_t + v_t * dt + 0.5 * a_t * dt**2\n\n    # Step 2: Calculate forces and accelerations at time t + dt\n    E_t_dt, F_t_dt = compute_energy_and_forces(R_t_dt, bonds)\n    a_t_dt = F_t_dt / masses_arr\n\n    # Step 3: Update velocities to get v(t + dt)\n    v_t_dt = v_t + 0.5 * (a_t + a_t_dt) * dt\n\n    # Step 4: Calculate final total energy at t + dt\n    kinetic_energy_final = 0.5 * np.sum(masses_arr * v_t_dt**2)\n    total_energy_final = E_t_dt + kinetic_energy_final\n\n    return total_energy_final\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        { # Case A\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.0],\n            \"initial_velocities\": [0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        },\n        { # Case B\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.1],\n            \"initial_velocities\": [0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        },\n        { # Case C\n            \"masses\": [1836, 3672, 1836],\n            \"initial_positions\": [0.0, 1.1, 2.2],\n            \"initial_velocities\": [0.0, 0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.7, 1.0), (1, 2, 0.7, 1.0)]\n        },\n        { # Case D\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.1],\n            \"initial_velocities\": [0.01, -0.02],\n            \"dt\": 0.0,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_timestep(\n            case[\"masses\"],\n            case[\"initial_positions\"],\n            case[\"initial_velocities\"],\n            case[\"bonds\"],\n            case[\"dt\"]\n        )\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451186"}, {"introduction": "在掌握了单个时间步的实现后，下一步是将这些步骤串联起来，生成分子的完整运动轨迹。本练习将挑战你模拟一个完整的水分子，使用更真实的莫尔斯势和弯曲势来描述其内部运动。你不仅需要处理从特定温度初始化系统速度的复杂性，还将学习如何分析轨迹以观察像分子解离这样的动态化学事件，从而将抽象的模拟与可观察的物理现象联系起来。[@problem_id:2451198]", "problem": "您需要在一个近似的基态势能面上，实现单个水分子的最小化玻恩-奥本海默分子动力学 (BOMD) 模拟。玻恩-奥本海默近似假定，对于每一种原子核构型，电子都保持在其瞬时基态，这产生了一个势能面，原子核在该势能面上遵循牛顿力学进行运动。您的任务是为一个柔性水分子积分其原子核运动方程，总模拟时间为 $1$ 皮秒，并对每个测试用例确定分子是否在该时间内发生解离。\n\n模型和基本原理：\n- 对每个原子核 $i$ 使用牛顿第二定律：$m_i \\,\\dfrac{d^2 \\mathbf{r}_i}{dt^2} = \\mathbf{F}_i$，其中力 $\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$。\n- 总势能 $U(\\mathbf{r})$ 是两个 O–H 键的 Morse 键势和一个 H–O–H 角的谐振角势之和：\n  - 对每个长度为 $r$ 的 O–H 键，使用 $$U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2,$$ 其中 $D_e$ 是键解离能，$a$ 是范围参数，$r_0$ 是平衡键长。\n  - 对于氧原子处的弯曲角 $\\theta$（其平衡值为 $\\theta_0$），使用 $$U_{\\mathrm{bend}}(\\theta) = \\dfrac{1}{2}\\,k_\\theta\\,(\\theta - \\theta_0)^2.$$\n- 使用速度 Verlet 积分法，该方法由位置和速度的 Taylor 展开推导得出，具体如下\n  $$\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\dfrac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2,$$\n  计算新的力 $\\mathbf{F}(t+\\Delta t)$ 和加速度 $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(t+\\Delta t)/m$，然后\n  $$\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\dfrac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t.$$\n\n物理常数和参数：\n- 玻尔兹曼常数 $k_B = 1.380\\,649\\times 10^{-23}$ 焦耳/开尔文。\n- 一电子伏特 $\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}$ 焦耳。\n- 一原子质量单位 $\\mathrm{amu} = 1.660\\,539\\,066\\,60\\times 10^{-27}$ 千克。\n- 质量：$m_{\\mathrm{O}} = 15.999\\,\\mathrm{amu}$，$m_{\\mathrm{H}} = 1.007\\,84\\,\\mathrm{amu}$。\n- 平衡 O–H 键长 $r_0 = 0.096$ 纳米。\n- 平衡 H–O–H 角度 $\\theta_0 = 104.5$ 度（计算时使用弧度）。\n- Morse 参数：$D_e = 5.5$ 电子伏特，$a = 2.2$ 埃格斯特罗姆⁻¹。\n- 角力常数 $k_\\theta = 75$ 千卡/摩尔/弧度²。使用前将 $k_\\theta$ 转换为焦耳/弧度²/分子。\n- 每个测试中的总模拟时间 $t_{\\mathrm{total}} = 1$ 皮秒。\n- 使用基于键伸长的解离判据：如果在任何时刻任一 O–H 键长超过 $r_{\\mathrm{cut}} = 2.2\\,r_0$，则宣告分子已解离。\n\n初始化：\n- 将氧原子置于原点。将一个氢原子置于 $(r_0,0,0)$，第二个氢原子置于 $(r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$，以使氧原子处的 H–O–H 角等于 $\\theta_0$。\n- 通过从均值为零、方差为 $\\sigma_i^2 = k_B T / m_i$ 的正态分布中抽样，来初始化温度 $T$ 下原子 $i$ 的每个笛卡尔分量速度。然后通过从所有原子中减去质心速度来移除质心线动量。最后，用一个共同的标量重标定所有速度，使得总动能等于均分值 $K_{\\mathrm{target}} = \\dfrac{f}{2} k_B T$，其中 $f = 3N - 3$ 是移除 $N=3$ 个原子的整体平动后的二次自由度数，因此 $f=6$。使用固定的伪随机种子以确保结果的确定性。\n- 内部计算角度时使用弧度。为保证单位一致性，请使用米、千克和秒。对所有参数使用给定的转换关系。\n\n力：\n- 对于从 O 指向 H、长度为 $r=\\|\\mathbf{u}\\|$ 的每个 O–H 键矢量 $\\mathbf{u}$，沿键方向的 Morse 力大小为\n  $$\\dfrac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e\\,a\\,e^{-a(r-r_0)}\\left(1 - e^{-a(r-r_0)}\\right),$$\n  作用在氢原子上的力为 $-\\dfrac{dU_{\\mathrm{Morse}}}{dr}\\,\\dfrac{\\mathbf{u}}{r}$，而作用在氧原子上的力大小相等、方向相反。\n- 对于从 O 指向 H 原子的矢量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 的弯曲项，令 $\\hat{\\mathbf{u}}=\\mathbf{u}/\\|\\mathbf{u}\\|$，$\\hat{\\mathbf{v}}=\\mathbf{v}/\\|\\mathbf{v}\\|$，$\\cos\\theta = \\hat{\\mathbf{u}}\\cdot \\hat{\\mathbf{v}}$，$\\sin\\theta = \\sqrt{1-\\cos^2\\theta}$。$\\theta$ 的梯度为\n  $$\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} = -\\dfrac{1}{\\|\\mathbf{u}\\|}\\,\\dfrac{\\hat{\\mathbf{v}} - \\cos\\theta\\,\\hat{\\mathbf{u}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}} = -\\dfrac{1}{\\|\\mathbf{v}\\|}\\,\\dfrac{\\hat{\\mathbf{u}} - \\cos\\theta\\,\\hat{\\mathbf{v}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_{\\mathrm{O}}} = -\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} - \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}}.$$\n  角力为 $\\mathbf{F}_i^{(\\mathrm{bend})} = -k_\\theta\\,(\\theta - \\theta_0)\\,\\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_i}$，其中 $i\\in\\{\\mathrm{H}_1, \\mathrm{O}, \\mathrm{H}_2\\}$。\n\n数值细节：\n- 使用速度 Verlet 算法，每个测试用例（见下文）指定一个恒定的时间步长 $\\Delta t$。计算步数 $n = t_{\\mathrm{total}}/\\Delta t$ 并精确地积分这么多步。\n- 速度初始化时，使用种子为 $12345$ 的确定性伪随机数生成器。\n\n测试套件：\n对于下面的每个元组 $(T,\\Delta t)$，其中 $T$ 以开尔文为单位，$\\Delta t$ 以飞秒为单位，运行 $1$ 皮秒的模拟，并返回一个布尔值，表示在所述判据下，轨迹中是否发生了离解：\n- 测试 1：$(T=\\;300,\\;\\Delta t=\\;0.2)$。\n- 测试 2：$(T=\\;1000,\\;\\Delta t=\\;0.1)$。\n- 测试 3：$(T=\\;8000,\\;\\Delta t=\\;0.05)$。\n- 测试 4：$(T=\\;20000,\\;\\Delta t=\\;0.05)$。\n- 测试 5：$(T=\\;100000,\\;\\Delta t=\\;0.02)$。\n\n所需输出：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如，“[True,False,False,True,False]”。结果必须与上述测试套件的顺序一致。所有内部计算必须在国际单位制（SI）中进行，角度以弧度为单位。每个测试的最终答案是一个布尔值。每个测试的总模拟时间为 $1$ 皮秒。", "solution": "所提出的问题是计算化学中的一个标准练习：对单个柔性水分子进行玻恩-奥本海默分子动力学 (BOMD) 模拟。该问题是适定的、科学上合理的，并包含得出唯一确定性解所需的所有信息。我们现在将系统地构建此解法。\n\n任务的核心是在给定的势能面 (PES) $U(\\mathbf{r})$ 上，对三个原子核（一个氧，两个氢）积分其牛顿运动方程。原子核被视为经典粒子。每个质量为 $m_i$、位置矢量为 $\\mathbf{r}_i$ 的原子核 $i$ 的基本方程是：\n$$ m_i \\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r}) $$\n其中 $\\mathbf{r}$ 代表所有原子核坐标的集合 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$。\n\n**1. 势能面**\n\n势能面 $U(\\mathbf{r})$ 决定了作用在原子核上的力。它被近似为内坐标势之和：两个键伸缩项和一个角弯曲项。\n$$ U(\\mathbf{r}) = U_{\\mathrm{Morse}}(r_1) + U_{\\mathrm{Morse}}(r_2) + U_{\\mathrm{bend}}(\\theta) $$\n其中 $r_1$ 和 $r_2$ 是两个 O–H 键的长度，$\\theta$ 是 H–O–H 角。\n\n每个 O–H 键的伸缩由 Morse 势描述，这是一种用于键解离的现实模型：\n$$ U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2 $$\n这里，$D_e$ 是键解离能，$r_0$ 是平衡键长，$a$ 控制势阱的宽度。由该势产生的、作用在形成键的两个原子上的力，其方向沿着键矢量。对于长度为 $r = \\|\\mathbf{u}\\|$ 的键矢量 $\\mathbf{u} = \\mathbf{r}_{\\mathrm{H}} - \\mathbf{r}_{\\mathrm{O}}$，作用在氢原子上的力为：\n$$ \\mathbf{F}_{\\mathrm{H, Morse}} = -\\nabla_{\\mathbf{r}_{\\mathrm{H}}} U_{\\mathrm{Morse}}(r) = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\partial r}{\\partial \\mathbf{r}_{\\mathrm{H}}} = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\mathbf{u}}{r} $$\n其中导数为 $\\frac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e a \\left(1 - e^{-a(r - r_0)}\\right) e^{-a(r - r_0)}$。作用在氧原子上的力大小相等、方向相反，满足牛顿第三定律。\n\nH–O–H 角的弯曲由谐振势建模：\n$$ U_{\\mathrm{bend}}(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2 $$\n其中 $k_\\theta$ 是角力常数，$\\theta_0$ 是平衡角。力由该势的梯度推导得出：$\\mathbf{F}_i^{\\mathrm{bend}} = -\\nabla_{\\mathbf{r}_i} U_{\\mathrm{bend}}(\\theta) = -k_\\theta(\\theta - \\theta_0)\\nabla_{\\mathbf{r}_i}\\theta$。问题提供了计算每个原子 $i \\in \\{\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2\\}$ 的角梯度 $\\nabla_{\\mathbf{r}_i}\\theta$ 所需的表达式。这些表达式可直接使用。一个显著的特点是梯度分母中的 $\\sin\\theta$ 项，它会在线性构型（$\\theta=0$ 或 $\\theta=\\pi$）时引入数值奇点。一个鲁棒的实现必须处理或容忍这一点。\n\n**2. 数值积分**\n\n为了求解运动微分方程，我们采用指定的速度 Verlet 算法。这是一种时间可逆的辛积分器，具有良好的长期能量守恒特性。给定时间 $t$ 时的位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(t)/m$，时间 $t+\\Delta t$ 时的状态通过两个阶段计算：\n$$ \\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2 $$\n$$ \\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t $$\n注意，计算新速度 $\\mathbf{v}(t+\\Delta t)$ 需要加速度 $\\mathbf{a}(t+\\Delta t)$，而这又需要在新计算出的位置 $\\mathbf{r}(t+\\Delta t)$ 处计算力 $\\mathbf{F}(t+\\Delta t)$。\n\n**3. 系统初始化**\n\n模拟从一个定义的初始状态开始。\n- **位置**：氧原子位于原点 $(\\mathbf{r}_{\\mathrm{O}} = \\mathbf{0})$。两个氢原子被放置在 $xy$-平面上，以满足平衡键长 $r_0$ 和平衡角 $\\theta_0$：$\\mathbf{r}_{\\mathrm{H}_1} = (r_0, 0, 0)$ 和 $\\mathbf{r}_{\\mathrm{H}_2} = (r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$。\n- **速度**：初始速度被设置为与目标温度 $T$ 相对应。这包括三个步骤：\n    1.  对于每个原子 $i$ 和每个笛卡尔分量，从麦克斯韦-玻尔兹曼分布中抽取一个随机速度，这是一个均值为 $0$、方差为 $\\sigma_i^2 = k_B T / m_i$ 的正态分布。此过程使用一个固定种子（$12345$）的伪随机数生成器以保证可复现性。\n    2.  通过计算质心速度 $\\mathbf{v}_{\\mathrm{CM}} = \\frac{\\sum_i m_i \\mathbf{v}_i}{\\sum_i m_i}$，并从每个原子的速度矢量中减去该速度，将系统的总动量设为零。这确保了分子整体不表现出净平动。\n    3.  总动能 $K = \\sum_i \\frac{1}{2} m_i \\|\\mathbf{v}_i'\\|^2$ 随后被缩放以匹配一个特定的目标值 $K_{\\mathrm{target}}$。问题指定 $K_{\\mathrm{target}} = \\frac{f}{2} k_B T$，其中 $f = 3N-3=6$ 是移除平动后 $N=3$ 个原子的内自由度。所有速度都乘以一个缩放因子 $\\lambda = \\sqrt{K_{\\mathrm{target}}/K}$。这个过程是一种恒温调节形式，用以在期望的温度下开始模拟。\n\n**4. 实现与执行**\n\n整个模拟必须在一致的单位制下进行。国际单位制 (SI)是要求的标准：米 (m)、千克 (kg)、秒 (s) 和焦耳 (J)。所有提供的参数在使用前必须进行相应转换。\n- $m_{\\mathrm{O}}, m_{\\mathrm{H}}$：从 $\\mathrm{amu}$ 转换为 $\\mathrm{kg}$。\n- $r_0$：从 $\\mathrm{nm}$ 转换为 $\\mathrm{m}$。\n- $\\theta_0$：从度转换为弧度。\n- $D_e$：从 $\\mathrm{eV}$ 转换为 $\\mathrm{J}$。\n- $a$：从 $\\mathrm{Å}^{-1}$ 转换为 $\\mathrm{m}^{-1}$。\n- $k_\\theta$：从 $\\mathrm{kcal}\\,\\mathrm{mol}^{-1}\\,\\mathrm{rad}^{-2}$ 转换为 $\\mathrm{J}\\,\\mathrm{rad}^{-2}$。\n- $t_{total}$：从 $\\mathrm{ps}$ 转换为 $\\mathrm{s}$。\n- $\\Delta t$：从 $\\mathrm{fs}$ 转换为 $\\mathrm{s}$。\n\n模拟通过对总步数 $n = t_{\\mathrm{total}}/\\Delta t$ 迭代应用速度 Verlet 算法来进行。每次位置更新后，将 O–H 键长 $r_1$ 和 $r_2$ 与解离判据 $r_{\\mathrm{cut}} = 2.2\\,r_0$ 进行比较。如果任一键长超过此截断值，则认为分子已解离，该测试用例的模拟终止，结果记录为 `True`。如果循环完成而没有发生解离，结果为 `False`。此逻辑应用于问题陈述中指定的每个测试用例。最终输出是这些布尔结果的列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the BOMD problem for a water molecule.\n    \"\"\"\n    \n    # Global constants in SI units\n    KB = 1.380649e-23  # J/K\n    EV = 1.602176634e-19  # J\n    AMU = 1.66053906660e-27  # kg\n    NA = 6.02214076e23  # mol^-1\n    CAL_TO_J = 4.184\n\n    # Model Parameters in SI units\n    M_O = 15.999 * AMU\n    M_H = 1.00784 * AMU\n    MASSES = np.array([M_O, M_H, M_H])[:, np.newaxis] # Shape (3, 1) for broadcasting\n\n    R0 = 0.096e-9  # m\n    THETA0 = 104.5 * np.pi / 180.0  # rad\n\n    DE = 5.5 * EV  # J\n    A = 2.2e10  # m^-1\n\n    # k_theta conversion: 75 kcal/mol/rad^2 -> J/rad^2\n    K_THETA = 75 * 1000 * CAL_TO_J / NA  # J/rad^2\n\n    RCUT = 2.2 * R0\n\n    T_TOTAL = 1.0e-12  # s (1 picosecond)\n    \n    # Nested function to calculate forces for encapsulation\n    def calculate_forces(r):\n        \"\"\"Calculates forces on all atoms given their positions.\"\"\"\n        r_O, r_H1, r_H2 = r[0], r[1], r[2]\n        forces = np.zeros((3, 3))\n        \n        # Bond vectors\n        u1 = r_H1 - r_O\n        u2 = r_H2 - r_O\n        r1 = np.linalg.norm(u1)\n        r2 = np.linalg.norm(u2)\n        \n        # Handle case where atoms might be at the same position\n        if r1 == 0 or r2 == 0:\n            return forces\n\n        u1_hat = u1 / r1\n        u2_hat = u2 / r2\n        \n        # Morse Forces\n        exp_term1 = np.exp(-A * (r1 - R0))\n        dUm_dr1 = 2 * DE * A * exp_term1 * (1 - exp_term1)\n        \n        exp_term2 = np.exp(-A * (r2 - R0))\n        dUm_dr2 = 2 * DE * A * exp_term2 * (1 - exp_term2)\n        \n        F_H1_morse = -dUm_dr1 * u1_hat\n        F_H2_morse = -dUm_dr2 * u2_hat\n        \n        forces[1] += F_H1_morse\n        forces[2] += F_H2_morse\n        forces[0] -= (F_H1_morse + F_H2_morse)\n        \n        # Angle Bending Forces\n        cos_theta = np.dot(u1_hat, u2_hat)\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        sin_theta = np.sqrt(1 - cos_theta**2)\n        if sin_theta < 1e-10:\n            return forces\n\n        dUb_dtheta = K_THETA * (theta - THETA0)\n\n        grad_theta_u1 = (-1.0 / r1) * (u2_hat - cos_theta * u1_hat) / sin_theta\n        grad_theta_u2 = (-1.0 / r2) * (u1_hat - cos_theta * u2_hat) / sin_theta\n        \n        F_H1_bend = -dUb_dtheta * grad_theta_u1\n        F_H2_bend = -dUb_dtheta * grad_theta_u2\n        F_O_bend = -(F_H1_bend + F_H2_bend)\n        \n        forces[0] += F_O_bend\n        forces[1] += F_H1_bend\n        forces[2] += F_H2_bend\n        \n        return forces\n\n    # Nested function to run one simulation\n    def run_simulation(T, dt_fs):\n        \"\"\"Runs one BOMD simulation for given T and dt.\"\"\"\n        dt = dt_fs * 1e-15  # Convert fs to s\n        num_steps = int(round(T_TOTAL / dt))\n        \n        # 1. Initialization\n        r = np.zeros((3, 3))\n        r[1] = [R0, 0, 0]\n        r[2] = [R0 * np.cos(THETA0), R0 * np.sin(THETA0), 0]\n        \n        rng = np.random.default_rng(12345)\n        std_devs = np.sqrt(KB * T / MASSES)\n        v = rng.normal(0, std_devs, size=(3, 3))\n        \n        v_cm = np.sum(v * MASSES, axis=0) / np.sum(MASSES)\n        v -= v_cm\n        \n        K_initial = 0.5 * np.sum(MASSES * v**2)\n        K_target = 0.5 * 6 * KB * T\n        if K_initial > 1e-12: # Avoid division by zero\n            scale_factor = np.sqrt(K_target / K_initial)\n            v *= scale_factor\n            \n        # 2. Dynamics\n        forces = calculate_forces(r)\n        a = forces / MASSES\n        \n        for _ in range(num_steps):\n            r += v * dt + 0.5 * a * dt**2\n            \n            r1 = np.linalg.norm(r[1] - r[0])\n            r2 = np.linalg.norm(r[2] - r[0])\n            if r1 > RCUT or r2 > RCUT:\n                return True\n                \n            forces_new = calculate_forces(r)\n            a_new = forces_new / MASSES\n            \n            v += 0.5 * (a + a_new) * dt\n            \n            a = a_new\n            \n        return False\n\n    test_cases = [\n        (300, 0.2),\n        (1000, 0.1),\n        (8000, 0.05),\n        (20000, 0.05),\n        (100000, 0.02)\n    ]\n    \n    results = []\n    for T, dt_fs in test_cases:\n        result = run_simulation(T, dt_fs)\n        results.append(str(result))\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451198"}, {"introduction": "成功运行模拟并生成轨迹只是研究过程的开始，真正的科学洞见来自于对这些数据的分析。这个高级练习将指导你如何从BOMD轨迹中提取宏观热力学性质，例如温度、压力和热容。通过应用统计力学中的均分定理、维里定理和涨落公式，你将学习如何将微观的原子运动与可测量的宏观量联系起来，并批判性地思考由有限模拟时间带来的统计不确定性。[@problem_id:2877597]", "problem": "针对一个包含$N$个原子的周期性体系，进行了一次有限温度的Born-Oppenheimer分子动力学（BOMD）模拟，在正则系综（粒子数、体积和温度恒定；NVT）下进行采样，并使用一个弱耦合的Nosé–Hoover温控器，该温控器为原子核的坐标和动量生成正则统计。电子结构已收敛，使得Pulay力和Pulay应力可以忽略不计（例如，使用具有足够截断能的平面波基组）。原子核的质心线动量被约束为零。\n\n给定以下统计稳态的轨迹数据和系统参数：\n- 原子数：$N = 20$。\n- 无约束的二次自由度数：$f = 3N - 3$。\n- 周期性晶胞体积：$V = 4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3}$。\n- 时间步长：$\\Delta t = 0.5\\ \\mathrm{fs}$。\n- 保存的步数：$M = 200000$。\n- 原子核的时间平均动能：$\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$。\n- 时间平均维里（构型贡献），定义为 $\\Phi \\equiv \\sum_{i} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i}$，沿轨迹的平均值：$\\langle \\Phi \\rangle = -2.239000 \\times 10^{-19}\\ \\mathrm{J}$。\n- 总能量（原子核动能加势能）的样本方差，从轨迹计算得出：$s_{E}^{2} = 1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}$。\n- 可观测量积分自相关时间（通过分块分析获得）：$\\tau_{K} = 0.20\\ \\mathrm{ps}$，$\\tau_{\\Phi} = 0.50\\ \\mathrm{ps}$，以及 $\\tau_{E} = 0.50\\ \\mathrm{ps}$。\n\n假设原子核是经典的，并且温控器对物理的原子核自由度进行正则分布采样。使用精确的玻尔兹曼常数 $k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n\n任务：\n1) 从经典二次自由度的能量均分定理和热力学温度的定义出发，根据时间平均的原子核动能和无约束的二次自由度数，推导BOMD轨迹中温度$T$的估算量。然后计算$T$的数值（单位为K）。\n\n2) 从维里定理和分子动力学中压强的力学定义出发，根据时间平均动能、时间平均维里$\\langle \\Phi \\rangle$和体积$V$，推导压强$P$的估算量。然后计算$P$的数值（单位为Pa）。\n\n3) 从正则系综中定容热容$C_{V}$的定义出发，推导一个使用总能量涨落的估算量。然后，用样本方差$s_{E}^{2}$和温度$T$来表示以$k_{B}$为单位的单原子热容 $c_{V} \\equiv C_{V}/(N k_{B})$。计算$c_{V}$的无量纲数值。\n\n4) 在不代入数值的情况下，讨论如何通过使用积分自相关时间来确定有效样本量，从而从有限的、时间相关的轨迹中估计第(1)–(3)部分中估算量的标准误差（统计不确定性）。写下您将用于基于均值的估算量和基于方差的估算量的标准误差公式，并解释您将如何传播不确定性以获得$c_{V}$的不确定性。\n\n以$k_{B}$为单位，给出无量纲的单原子热容$c_{V}$作为最终答案，并四舍五入到四位有效数字。不要在最终的方框答案中包含单位；所有中间量必须带有适当的物理单位。", "solution": "所述问题在科学上是合理的、提法恰当，并包含了完整解答所需的所有信息。我们继续进行四个任务的推导和计算。\n\n1) 温度($T$)的推导和计算\n\n该体系由经典力学描述，并在正则系综中采样。根据能量均分定理，每个无约束的二次自由度的平均能量为$\\frac{1}{2} k_{B} T$，其中$k_{B}$是玻尔兹曼常数，$T$是热力学温度。\n\n$N$个原子核的动能是动量二次项的和：$K = \\sum_{i=1}^{N} \\frac{|\\mathbf{p}_{i}|^2}{2m_{i}}$。这类项的总数为$3N$。问题陈述中说明质心动量被约束为零，这移除了3个平移自由度。因此，动能的无约束二次自由度数为$f = 3N - 3$。\n\n时间平均的原子核动能$\\langle K \\rangle$必须等于系综平均值。根据能量均分定理：\n$$\n\\langle K \\rangle = \\frac{f}{2} k_{B} T\n$$\n由此，我们推导出温度$T$的估算量：\n$$\nT = \\frac{2 \\langle K \\rangle}{f k_{B}}\n$$\n我们被给予以下数值：\n- 原子数：$N = 20$。\n- 时间平均动能：$\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$。\n- 玻尔兹曼常数：$k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n\n首先，我们计算自由度数：\n$f = 3N - 3 = 3(20) - 3 = 57$。\n\n现在，我们计算温度：\n$$\nT = \\frac{2 \\times (1.180495 \\times 10^{-19}\\ \\mathrm{J})}{57 \\times (1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1})} = \\frac{2.36099 \\times 10^{-19}\\ \\mathrm{J}}{7.8696993 \\times 10^{-22}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}} \\approx 300.011\\ \\mathrm{K}\n$$\n\n2) 压强($P$)的推导和计算\n\n周期性体系中的力学压强$P$由系综平均压强张量$\\langle \\boldsymbol{\\sigma} \\rangle$的迹给出。瞬时压强张量定义为：\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{V} \\left( \\sum_{i=1}^{N} m_{i} \\mathbf{v}_{i} \\otimes \\mathbf{v}_{i} + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\otimes \\mathbf{F}_{i} \\right)\n$$\n其中$V$是体积，$m_i$、$\\mathbf{v}_i$和$\\mathbf{r}_i$分别是原子$i$的质量、速度和位置，$\\mathbf{F}_i$是作用在原子$i$上来自所有其他原子的总力。符号$\\otimes$表示张量积。\n\n静水压强为$P = \\frac{1}{3} \\mathrm{Tr}(\\langle \\boldsymbol{\\sigma} \\rangle)$。取瞬时张量的迹：\n$$\n\\mathrm{Tr}(\\boldsymbol{\\sigma}) = \\frac{1}{V} \\left( \\sum_{i=1}^{N} m_{i} |\\mathbf{v}_{i}|^2 + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i} \\right)\n$$\n第一项是总动能的两倍，$\\sum_{i} m_{i} |\\mathbf{v}_{i}|^2 = 2K$。第二项是力的维里，给定为$\\Phi = \\sum_{i} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i}$。因此，压强的估算量是此表达式的时间平均：\n$$\nP = \\frac{1}{3V} \\langle 2K + \\Phi \\rangle = \\frac{2\\langle K \\rangle + \\langle \\Phi \\rangle}{3V}\n$$\n我们被给予：\n- $\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$。\n- 时间平均维里：$\\langle \\Phi \\rangle = -2.239000 \\times 10^{-19}\\ \\mathrm{J}$。\n- 体积：$V = 4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3}$。\n\n代入这些数值：\n$$\nP = \\frac{2(1.180495 \\times 10^{-19}\\ \\mathrm{J}) + (-2.239000 \\times 10^{-19}\\ \\mathrm{J})}{3 \\times (4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3})} = \\frac{1.2199 \\times 10^{-20}\\ \\mathrm{J}}{1.20000 \\times 10^{-25}\\ \\mathrm{m}^{3}} \\approx 1.0166 \\times 10^5\\ \\mathrm{Pa}\n$$\n\n3) 热容($c_{V}$)的推导和计算\n\n定容热容$C_{V}$定义为平均总能量$\\langle E \\rangle$对温度$T$在恒定体积$V$下的偏导数：\n$$\nC_{V} = \\left( \\frac{\\partial \\langle E \\rangle}{\\partial T} \\right)_{V}\n$$\n在正则(NVT)系综中，该导数可以表示为能量涨落的形式。使用$\\langle E \\rangle$的统计力学定义和关系$\\beta = (k_{B}T)^{-1}$：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial T} = \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\frac{d\\beta}{dT} = \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\left( -\\frac{1}{k_{B}T^2} \\right)\n$$\n$\\langle E \\rangle$对$\\beta$的导数是一个标准结果：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -(\\langle E^2 \\rangle - \\langle E \\rangle^2) = -\\mathrm{Var}(E)\n$$\n结合这些，得到热容的涨落公式：\n$$\nC_{V} = \\frac{\\mathrm{Var}(E)}{k_{B} T^2}\n$$\n问题提供了总能量的样本方差$s_{E}^{2}$，这是我们对$\\mathrm{Var}(E)$的估算量。因此，$C_{V}$的估算量为：\n$$\nC_{V} \\approx \\frac{s_{E}^{2}}{k_{B} T^2}\n$$\n题目要求的是以$k_{B}$为单位的单原子热容，定义为$c_{V} \\equiv C_{V}/(N k_{B})$。代入我们对$C_V$的表达式：\n$$\nc_{V} = \\frac{1}{N k_{B}} \\left( \\frac{s_{E}^{2}}{k_{B} T^2} \\right) = \\frac{s_{E}^{2}}{N k_{B}^2 T^2}\n$$\n我们被给予：\n- 总能量的样本方差：$s_{E}^{2} = 1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}$。\n- $N = 20$，$k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n- 以及从第1部分得到的，$T \\approx 300.011\\ \\mathrm{K}$。\n\n我们计算分母 $N k_{B}^2 T^2$：\n$$\nN k_{B}^2 T^2 = 20 \\times (1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1})^2 \\times (300.011\\ \\mathrm{K})^2 \\approx 3.43138 \\times 10^{-40}\\ \\mathrm{J}^2\n$$\n现在我们计算$c_{V}$的无量纲值：\n$$\nc_{V} = \\frac{1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}}{3.43138 \\times 10^{-40}\\ \\mathrm{J}^2} \\approx 2.9986\n$$\n\n4) 统计误差估计的讨论\n\n$T$、$P$和$C_V$的估算量是从有限的、时间相关的轨迹中计算出来的。要估计这些量的标准误差(SE)，必须考虑这种相关性。这里使用有效样本量$N_{\\text{eff}}$的概念。对于一个积分自相关时间为$\\tau_A$的可观测量$A$，在总模拟时间$T_{\\text{sim}} = M \\Delta t$内采样，有效独立样本数为$N_{\\text{eff}} = T_{\\text{sim}} / (2\\tau_A)$。\n\n对于基于可观测量$A$的均值的估算量（例如，从$\\langle K \\rangle$得到的$T$和从$\\langle 2K+\\Phi \\rangle$得到的$P$），均值的标准误差为：\n$$\n\\mathrm{SE}(\\langle A \\rangle) = \\sqrt{\\frac{\\mathrm{Var}(A)}{N_{\\text{eff}}}} = \\sqrt{\\frac{2\\tau_A}{T_{\\text{sim}}}\\mathrm{Var}(A)}\n$$\n其中$\\mathrm{Var}(A)$是可观测量$A$在轨迹上的方差。\n\n- 对于温度，$T = \\frac{2\\langle K \\rangle}{f k_{B}}$，不确定性从$\\langle K \\rangle$传播而来：\n$\\mathrm{SE}(T) = \\frac{2}{f k_{B}} \\mathrm{SE}(\\langle K \\rangle)$，其中$\\mathrm{SE}(\\langle K \\rangle) = \\sqrt{\\frac{2\\tau_K}{T_{\\text{sim}}}\\mathrm{Var}(K)}$。\n\n- 对于压强，$P = \\frac{\\langle 2K+\\Phi \\rangle}{3V}$，最好定义一个新的可观测量$\\Pi = 2K+\\Phi$，并计算其自相关时间$\\tau_{\\Pi}$和方差$\\mathrm{Var}(\\Pi)$。不确定性则为：\n$\\mathrm{SE}(P) = \\frac{1}{3V} \\mathrm{SE}(\\langle \\Pi \\rangle)$，其中$\\mathrm{SE}(\\langle \\Pi \\rangle) = \\sqrt{\\frac{2\\tau_{\\Pi}}{T_{\\text{sim}}}\\mathrm{Var}(\\Pi)}$。\n\n对于基于方差的估算量（例如，来自$s_E^2$的$C_V$），误差分析更为复杂。样本方差$s_E^2$的标准误差可以近似为（假设$E$的分布接近高斯分布）：\n$$\n\\mathrm{SE}(s_E^2) \\approx s_E^2 \\sqrt{\\frac{2}{N_{\\text{eff},E}-1}}\n$$\n其中$N_{\\text{eff},E} = T_{\\text{sim}} / (2\\tau_E)$。\n\n为了找到$c_V = \\frac{s_{E}^{2}}{N k_{B}^2 T^2}$的标准误差，必须传播来自$s_E^2$和$T$两者的不确定性：\n$$\n\\left(\\frac{\\mathrm{SE}(c_V)}{c_V}\\right)^2 = \\left(\\frac{\\mathrm{SE}(s_E^2)}{s_E^2}\\right)^2 + \\left(-2 \\frac{\\mathrm{SE}(T)}{T}\\right)^2 + 2 \\frac{(-2)}{T s_E^2} \\mathrm{Cov}(s_E^2, T)\n$$\n假设$T$和$s_E^2$的估算量之间的协方差可以忽略不计，相对误差简化为：\n$$\n\\frac{\\mathrm{SE}(c_V)}{c_V} \\approx \\sqrt{\\left(\\frac{\\mathrm{SE}(s_E^2)}{s_E^2}\\right)^2 + 4\\left(\\frac{\\mathrm{SE}(T)}{T}\\right)^2}\n$$\n此公式结合了能量方差和温度的相对不确定性，以估计无量纲热容的最终不确定性。", "answer": "$$\\boxed{2.999}$$", "id": "2877597"}]}