{"hands_on_practices": [{"introduction": "局域相关方法的第一步是将离域的、符合分子对称性的正则分子轨道（canonical molecular orbitals）转化为在空间上紧凑且化学直观的局域分子轨道（Localized Molecular Orbitals, LMOs）。这个练习将指导你亲手实现经典的 Foster–Boys 局域化方案，通过最小化轨道扩展泛函来获得局域轨道。通过这个实践，你将深入理解将离域电子图像转变为局域化学键和孤对电子图像背后的数学优化过程 [@problem_id:2903150]。", "problem": "对于一些小型模型体系，您将获得规范正交原子轨道 (AO) 基组和若干组正则占据轨道。您需要在占据空间内通过幺正旋转构建 Boys 局域化占据轨道，并使用 Foster–Boys 展形泛函来量化其局域化程度。所有算符和坐标均以原子单位表示；距离单位为玻尔 (Bohr)，展形单位为平方玻尔 (Bohr squared)。角度必须使用弧度。\n\n使用的基本原理和定义：\n- 占据分子轨道 (MO) 由 AO 系数矩阵 $C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}$ 表示，其列是规范正交的。其中 $N_\\mathrm{AO}$ 是 AO 的数量，$N_\\mathrm{occ}$ 是占据轨道的数量。规范正交性是相对于 AO 重叠矩阵 $S$ 而言，此处取为单位矩阵 $S = I$。\n- 占据空间内的一个幺正变换由矩阵 $U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}$ 表示，满足 $U^\\top U = I$，得到变换后的轨道 $C' = C U$。\n- Boys 局域化的目标是最小化 Foster–Boys 展形\n$$\n\\Omega(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle - \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right)\n$$\n其中 $\\phi_i$ 是第 $i$ 个占据轨道，$\\hat{\\mathbf{r}} = (\\hat{x},\\hat{y},\\hat{z})$ 是位置算符，且 $\\hat{\\mathbf{r}}^2 = \\hat{x}^2 + \\hat{y}^2 + \\hat{z}^2$。\n- 在一个由中心位于 $\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)$ 的高度局域化且规范正交的函数构成的 AO 基组中，使用对角积分近似\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}}),\\quad\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2).\n$$\n- 对于 AO 基中代表一个 MO 的任意列向量 $v$，其质心分量和半径平方计算如下：\n$$\nm_\\alpha(v) = v^\\top R_\\alpha v \\quad (\\alpha \\in \\{x,y,z\\}), \\qquad\nr^2(v) = v^\\top R_2 v\n$$\n轨道对展形的贡献为 $r^2(v) - (m_x(v)^2 + m_y(v)^2 + m_z(v)^2)$。\n\n您的任务是编写一个程序，对下方的每个测试用例，在占据空间内执行迭代的 Jacobi 配对幺正旋转以最小化 $\\Omega(C')$，并遵循以下要求：\n- 从给定的正则占据轨道 $C$ 开始。\n- 在每次扫描中，考虑所有满足 $p  q$ 的不同占据轨道对 $(p,q)$，并选择一个旋转角 $\\theta$（以弧度为单位）来局部优化该轨道对的 Boys 目标函数。将此 $2\\times 2$ 正交旋转应用于 $C$ 的第 $p$ 列和第 $q$ 列。\n- 迭代进行扫描，直到收敛。收敛标准为：某次扫描中应用的最大旋转角的绝对值小于 $\\varepsilon = 10^{-10}$，或者达到最大扫描次数 $K = 1000$，以先满足的条件为准。\n- 收敛后，计算最终的展形 $\\Omega(C')$，单位为平方玻尔。\n\n测试套件：\n为以下三种情况实现上述过程。在每种情况下，AO 坐标以列表 $[(x_\\mu,y_\\mu,z_\\mu)]$（$\\mu = 1,\\dots,N_\\mathrm{AO}$）的形式给出，正则占据轨道 $C$ 以一个 $N_\\mathrm{AO} \\times N_\\mathrm{occ}$ 的、具有规范正交列的实数矩阵形式给出。\n\n- 情况 A (理想情况，在直链三原子上离域):\n  - $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$.\n  - AO 坐标：\n    $[(-1, 0, 0), (0, 0, 0), (1, 0, 0)]$.\n  - 正则占据轨道 $C$:\n    第 1 列：$\\left[ \\frac{1}{\\sqrt{2}}, 0, \\frac{1}{\\sqrt{2}} \\right]^\\top$,\n    第 2 列：$\\left[ \\frac{1}{2}, \\frac{1}{\\sqrt{2}}, -\\frac{1}{2} \\right]^\\top$.\n\n- 情况 B (边界情况，单个占据轨道):\n  - $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$.\n  - AO 坐标：\n    $[(-\\frac{1}{2}, 0, 0), (\\frac{1}{2}, 0, 0)]$.\n  - 正则占据轨道 $C$:\n    第 1 列：$\\left[ \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}} \\right]^\\top$.\n\n- 情况 C (边缘情况，十字形结构上的对称性和近简并):\n  - $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$.\n  - AO 坐标：\n    $[(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0)]$.\n  - 正则占据轨道 $C$:\n    第 1 列：$\\left[ \\frac{1}{\\sqrt{2}}, 0, 0, \\frac{1}{\\sqrt{2}} \\right]^\\top$,\n    第 2 列：$\\left[ 0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}, 0 \\right]^\\top$.\n\n程序要求：\n- 根据上述说明，从 AO 坐标构建 $R_x, R_y, R_z$ 和 $R_2$。\n- 在占据空间上实现 Jacobi 旋转过程以最小化 $\\Omega$，收敛参数为 $\\varepsilon = 10^{-10}$ 和 $K = 1000$。\n- 对于每种情况，以平方玻尔为单位，将最终的 $\\Omega$ 值报告为浮点数。以十进制数形式表示输出，并精确到小数点后六位。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含按情况 A、情况 B、情况 C 顺序排列的结果，形式为方括号括起来的逗号分隔列表。例如，输出格式必须为\n$[r_A,r_B,r_C]$,\n其中 $r_A,r_B,r_C$ 均为最终的 $\\Omega$ 值，四舍五入到六位小数，且行中不含任何空格。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **模型：** 规范正交原子轨道 (AO) 基组 ($S = I$)，正则占据分子轨道 (MO) 的 Boys 局域化。\n- **MO 系数矩阵：** $C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}$，其列规范正交。\n- **幺正变换：** $C' = C U$，其中 $U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}$ 是一个正交矩阵 ($U^\\top U = I$)。\n- **Foster–Boys 展形泛函：** $\\Omega(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle - \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right)$。\n- **对角积分近似：** 在 AO 基中，位置算符 $\\hat{x},\\hat{y},\\hat{z}$ 和平方位置算符 $\\hat{\\mathbf{r}}^2$ 的矩阵表示是从 AO 中心坐标 $\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)$ 导出的对角矩阵：\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}})\n$$\n$$\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2)\n$$\n- **轨道性质：** 对于 MO 列向量 $v$，其质心分量为 $m_\\alpha(v) = v^\\top R_\\alpha v$，半径平方为 $r^2(v) = v^\\top R_2 v$。\n- **优化过程：** 对 $C$ 的列进行迭代的 Jacobi 配对旋转。\n- **收敛标准：** 一次扫描中的最大绝对旋转角 $|\\theta|_{\\max}  \\varepsilon = 10^{-10}$，或最大扫描次数 $K = 1000$。\n- **测试用例：**\n  - **情况 A：** $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$。AO 坐标：$[(-1, 0, 0), (0, 0, 0), (1, 0, 0)]$。$C$ 的列：$c_1 = [\\frac{1}{\\sqrt{2}}, 0, \\frac{1}{\\sqrt{2}}]^\\top$, $c_2 = [\\frac{1}{2}, \\frac{1}{\\sqrt{2}}, -\\frac{1}{2}]^\\top$。\n  - **情况 B：** $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$。AO 坐标：$[(-\\frac{1}{2}, 0, 0), (\\frac{1}{2}, 0, 0)]$。$C$ 的列：$c_1 = [\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}]^\\top$。\n  - **情况 C：** $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$。AO 坐标：$[(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0)]$。$C$ 的列：$c_1 = [\\frac{1}{\\sqrt{2}}, 0, 0, \\frac{1}{\\sqrt{2}}]^\\top$, $c_2 = [0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}, 0]^\\top$。\n\n**第 2 步：使用提取的已知条件进行验证**\n问题陈述具有科学依据，描述了在指定对角积分近似下的标准 Boys-Foster 局域化方法。该方法是量子化学中的基础方法，用于将离域的正则轨道转换为化学上直观的局域化轨道，是许多局域电子相关方法的前导步骤。问题是良构的，提供了所有必要的矩阵、参数以及一个明确定义的收敛算法（Jacobi 扫描）。初始 MO 系数矩阵已验证为规范正交。问题是客观、定量、无歧义或矛盾的。它完全属于指定领域。\n\n**第 3 步：结论与行动**\n问题被判定为有效。将构建一个解决方案。\n\n**求解推导**\n目标是最小化 Foster-Boys 展形 $\\Omega(C')$。该展形由两项组成：半径平方和与质心范数平方和。\n半径平方和 $\\sum_i \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle = \\mathrm{Tr}(C'^\\top R_2 C')$ 在正交变换 $C' = CU$ 下是不变的：\n$$\n\\mathrm{Tr}((CU)^\\top R_2 (CU)) = \\mathrm{Tr}(U^\\top C^\\top R_2 C U) = \\mathrm{Tr}(C^\\top R_2 C U U^\\top) = \\mathrm{Tr}(C^\\top R_2 C)\n$$\n因此，最小化展形 $\\Omega$ 等价于最大化轨道质心范数的平方和：\n$$\nL(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\lVert \\langle \\phi'_i | \\hat{\\mathbf{r}} | \\phi'_i \\rangle \\rVert^2 = \\sum_{i=1}^{N_\\mathrm{occ}} \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2\n$$\nJacobi 方法通过依次优化轨道对来解决这个最大化问题。对于一对轨道 $(\\phi_p, \\phi_q)$，我们应用一个旋转：\n$$\n\\begin{pmatrix} \\phi'_p \\\\ \\phi'_q \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\phi_p \\\\ \\phi_q \\end{pmatrix}\n$$\n此旋转只影响包含轨道 $p$ 和 $q$ 的项。我们必须找到使 $\\|\\langle \\phi'_p | \\hat{\\mathbf{r}} | \\phi'_p \\rangle\\|^2 + \\|\\langle \\phi'_q | \\hat{\\mathbf{r}} | \\phi'_q \\rangle\\|^2$ 最大化的角度 $\\theta$。\n\n令 $\\mathbf{A}_{ij}$ 为轨道 $i$ 和 $j$ 之间的偶极矩矩阵元向量：\n$$\n\\mathbf{A}_{ij} = (\\langle \\phi_i | \\hat{x} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{y} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{z} | \\phi_j \\rangle) = (c_i^\\top R_x c_j, c_i^\\top R_y c_j, c_i^\\top R_z c_j)\n$$\n注意，由于算符是实数且对称的，因此 $\\mathbf{A}_{ij} = \\mathbf{A}_{ji}$。对 $(p,q)$ 对的最大化问题简化为找到使 $\\|\\mathbf{A}'_{pp}\\|^2 + \\|\\mathbf{A}'_{qq}\\|^2$ 最大化的 $\\theta$。\n变换后的质心 $\\mathbf{A}'_{pp}$ 和 $\\mathbf{A}'_{qq}$ 用原始矩阵元和旋转角 $\\theta$ 表示：\n$$\n\\mathbf{A}'_{pp} = \\mathbf{A}_{pp}\\cos^2\\theta + \\mathbf{A}_{qq}\\sin^2\\theta + 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\n$$\n\\mathbf{A}'_{qq} = \\mathbf{A}_{pp}\\sin^2\\theta + \\mathbf{A}_{qq}\\cos^2\\theta - 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\n令 $\\mathbf{D} = \\mathbf{A}_{pp} - \\mathbf{A}_{qq}$ 且 $\\gamma = 2\\theta$。待最大化的和可以写成：\n$$\nL(\\theta) = \\text{const} + \\frac{1}{2} \\left[ \\left(\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2\\right) \\cos^2\\gamma + 4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})\\sin\\gamma\\cos\\gamma \\right]\n$$\n将关于 $\\gamma$ 的导数设为零，得到最优角的条件：\n$$\n\\tan(2\\gamma) = \\tan(4\\theta) = \\frac{4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})}{\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2}\n$$\n令分子为 $X = 4(\\mathbf{A}_{pp} - \\mathbf{A}_{qq})\\cdot\\mathbf{A}_{pq}$，分母为 $Y = \\|\\mathbf{A}_{pp} - \\mathbf{A}_{qq}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2$。使目标函数最大化的最优角通过以下方式找到：\n$$\n\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)\n$$\n这里使用 $\\mathrm{atan2}(Y,X)$ 函数（在我的约定中是 $\\mathrm{atan2}(y,x)$）来正确确定 $4\\theta$ 的象限，确保向最大值移动。在代码中，使用的 `numpy.arctan2(X, Y)` 与此形式相对应。\n\n**算法**\n对于每个测试用例：\n1.  从给定的 AO 坐标构建对角矩阵 $R_x, R_y, R_z$ 和 $R_2$。\n2.  初始化 MO 系数矩阵 $C$ 并设置扫描计数器和收敛标志。\n3.  开始迭代扫描。在每次扫描中：\n    a. 将当前扫描的最大角度 $|\\theta|_{\\max}^{\\text{sweep}}$ 初始化为零。\n    b. 对于每个不同的占据轨道对 $(p, q)$（其中 $p  q$）：\n        i.   使用当前的 $c_p$ 和 $c_q$ 计算偶极矩矩阵元向量 $\\mathbf{A}_{pp}$、$\\mathbf{A}_{qq}$ 和 $\\mathbf{A}_{pq}$。\n        ii.  计算 $\\tan(4\\theta)$ 表达式的分子 $X$ 和分母 $Y$。\n        iii. 确定旋转角 $\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)$。\n        iv.  更新扫描中最大角度的记录：$|\\theta|_{\\max}^{\\text{sweep}} = \\max(|\\theta|_{\\max}^{\\text{sweep}}, |\\theta|)$。\n        v.   应用旋转来更新矩阵 $C$ 的列 $c_p$ 和 $c_q$：\n             $$\n             \\begin{pmatrix} c'_p  c'_q \\end{pmatrix} = \\begin{pmatrix} c_p  c_q \\end{pmatrix} \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n             $$\n    c. 遍历所有对后，检查收敛性。如果 $|\\theta|_{\\max}^{\\text{sweep}}  \\varepsilon$，或达到最大扫描次数 $K$，则终止迭代。\n4.  收敛后，使用最终的局域化轨道矩阵 $C'$ 计算最终的总展形 $\\Omega$：\n    $$\n    \\Omega = \\sum_{i=0}^{N_\\mathrm{occ}-1} \\left[ (c'_i)^\\top R_2 c'_i - \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2 \\right]\n    $$\n5. 报告最终的 $\\Omega$ 值。对于 $N_\\mathrm{occ} \\le 1$ 的情况，无法进行旋转；初始展形即为最终展形。\n\n对指定的三个测试用例均执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Define convergence parameters from the problem statement.\n    EPSILON = 1e-10\n    MAX_SWEEPS = 1000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 1.0/2.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), -1.0/2.0]\n            ])\n        },\n        {\n            \"name\": \"Case B\",\n            \"ao_coords\": np.array([\n                [-0.5, 0.0, 0.0],\n                [0.5, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0)]\n            ])\n        },\n        {\n            \"name\": \"Case C\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 0.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), 0.0]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_localization(\n            case[\"ao_coords\"],\n            case[\"C_initial\"],\n            MAX_SWEEPS,\n            EPSILON\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef run_localization(ao_coords, C_initial, max_sweeps, epsilon):\n    \"\"\"\n    Performs Boys localization for a single case and returns the final spread.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C_initial (np.ndarray): Initial MO coefficient matrix, shape (N_AO, N_occ).\n        max_sweeps (int): Maximum number of sweeps.\n        epsilon (float): Convergence threshold for the maximum rotation angle.\n        \n    Returns:\n        float: The final minimized Foster-Boys spread.\n    \"\"\"\n    n_ao, n_occ = C_initial.shape\n    C = C_initial.copy()\n\n    # If N_occ = 1, no localization is possible or needed.\n    if n_occ = 1:\n        return calculate_spread(ao_coords, C)\n\n    # Construct the diagonal operator matrices R_x, R_y, R_z, R_2\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    \n    for sweep in range(max_sweeps):\n        max_angle_in_sweep = 0.0\n        \n        # Iterate over all distinct pairs of occupied orbitals (p, q)\n        for p in range(n_occ):\n            for q in range(p + 1, n_occ):\n                cp = C[:, p]\n                cq = C[:, q]\n\n                # Compute dipole matrix element vectors A_pp, A_qq, A_pq\n                A_pp = np.array([cp.T @ Rx @ cp, cp.T @ Ry @ cp, cp.T @ Rz @ cp])\n                A_qq = np.array([cq.T @ Rx @ cq, cq.T @ Ry @ cq, cq.T @ Rz @ cq])\n                A_pq = np.array([cp.T @ Rx @ cq, cp.T @ Ry @ cq, cp.T @ Rz @ cq])\n\n                # Calculate numerator and denominator for tan(4*theta)\n                D_vec = A_pp - A_qq\n                X_num = 4.0 * np.dot(D_vec, A_pq)\n                Y_den = np.dot(D_vec, D_vec) - 4.0 * np.dot(A_pq, A_pq)\n                \n                # Avoid division by zero when orbitals are already localized\n                if np.isclose(X_num, 0.0) and np.isclose(Y_den, 0.0):\n                    theta = 0.0\n                else:\n                    theta = 0.25 * np.arctan2(X_num, Y_den)\n\n                max_angle_in_sweep = max(max_angle_in_sweep, abs(theta))\n                \n                # Apply the rotation if the angle is significant\n                if abs(theta)  1e-15: # A small threshold to avoid no-op\n                    c_theta = np.cos(theta)\n                    s_theta = np.sin(theta)\n                    \n                    # Original columns p and q\n                    cp_orig = C[:, p].copy()\n                    cq_orig = C[:, q].copy()\n                    \n                    # Update columns C_p and C_q\n                    C[:, p] = cp_orig * c_theta + cq_orig * s_theta\n                    C[:, q] = -cp_orig * s_theta + cq_orig * c_theta\n\n        # Check for convergence\n        if max_angle_in_sweep  epsilon:\n            break\n            \n    return calculate_spread(ao_coords, C)\n\n\ndef calculate_spread(ao_coords, C):\n    \"\"\"\n    Calculates the total Foster-Boys spread for a given set of orbitals.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C (np.ndarray): MO coefficient matrix, shape (N_AO, N_occ).\n        \n    Returns:\n        float: The total spread.\n    \"\"\"\n    n_ao, n_occ = C.shape\n\n    # Construct operator matrices\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    R2 = np.diag(r_a**2 + r_b**2 + r_c**2)\n\n    total_spread = 0.0\n    for i in range(n_occ):\n        ci = C[:, i]\n        \n        # Squared radius: phi_i | r^2 | phi_i\n        r2_i = ci.T @ R2 @ ci\n        \n        # Centroid components: phi_i | r_alpha | phi_i\n        mx_i = ci.T @ Rx @ ci\n        my_i = ci.T @ Ry @ ci\n        mz_i = ci.T @ Rz @ ci\n        \n        # Orbital spread contribution\n        orbital_spread = r2_i - (mx_i**2 + my_i**2 + mz_i**2)\n        total_spread += orbital_spread\n        \n    return total_spread\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903150"}, {"introduction": "在获得局域分子轨道（LMOs）之后，下一步是为每一对 LMO 定义一个局域的虚轨道空间，即“电子对域”（pair domain）。这个练习基于一个简单而有效的距离截断标准，让你构建这些域并计算其大小。通过这个实践，你将具体地体会到电子相关作用的“短视性”（nearsightedness）原理是如何被利用来将庞大的虚轨道空间缩减为一个个可控的、与特定 LMO 对相关的子空间 [@problem_id:2903203]。", "problem": "在量子化学的基于域的局域相关近似中，我们假设局域分子轨道 (Localized Molecular Orbitals, LMO) 在空间上是紧凑的，并且一个 LMO 或一个 LMO 对的相关空间，可以用位于该 LMO 显著区域附近的虚轨道子集来近似。一种简单且广泛使用的域构建方法是基于距离的规则：对于每个 LMO，包含所有其投影原子轨道 (projected atomic orbital, PAO) 虚轨道所在的原子，只要这些原子的原子核位置处于以 LMO 空间中心为球心、半径等于一个截断值的球体内。然后，两个 LMO 的轨道对域被定义为它们各自域的并集。基于此原理和欧几里得几何，实现一个程序来构建此类域，并计算每个 LMO 对产生的虚轨道数，将其作为截断值的函数。\n\n本问题的基本原理：\n- 三维空间中的欧几里得距离：对于位置向量为 $\\mathbf{r}$ 的点和位置向量为 $\\mathbf{R}$ 的点，其距离为 $d = \\lVert \\mathbf{r} - \\mathbf{R} \\rVert_2 = \\sqrt{(x_r - x_R)^2 + (y_r - y_R)^2 + (z_r - z_R)^2}$。\n- 集合并集：对于集合 $\\mathcal{A}$ 和 $\\mathcal{B}$，其并集为 $\\mathcal{A} \\cup \\mathcal{B} = \\{ x \\mid x \\in \\mathcal{A} \\text{ or } x \\in \\mathcal{B} \\}$。\n- 通过求和计数：如果每个原子 $a$ 贡献 $n_a$ 个虚轨道，且一个域包含原子集合 $\\mathcal{D}$，那么该域中的总虚轨道数为 $N = \\sum_{a \\in \\mathcal{D}} n_a$。\n\n设置：\n- 给定 $5$ 个原子，其原子核坐标固定，单位为埃 (Å)：\n  - 原子 $0$：$(0.0, 0.0, 0.0)$ Å\n  - 原子 $1$：$(1.5, 0.0, 0.0)$ Å\n  - 原子 $2$：$(3.0, 0.0, 0.0)$ Å\n  - 原子 $3$：$(4.5, 0.0, 0.0)$ Å\n  - 原子 $4$：$(3.0, 1.2, 0.0)$ Å\n- 与每个原子关联的虚轨道数（例如 PAO）为：\n  - 原子 $0$：$3$\n  - 原子 $1$：$2$\n  - 原子 $2$：$4$\n  - 原子 $3$：$1$\n  - 原子 $4$：$3$\n- 给定 $3$ 个 LMO，其中心由原子坐标定义：\n  - LMO $0$：以原子 $0$ 为中心。\n  - LMO $1$：以原子 $1$ 和原子 $2$ 的中点为中心。\n  - LMO $2$：以原子 $2$ 和原子 $4$ 的中点为中心。\n- 基于距离的域规则（闭球）：对于一个截断半径 $R_c$（单位为 Å），LMO $i$ 的域是所有满足 $d_{ia} \\le R_c$ 的原子 $a$ 的集合，其中 $d_{ia}$ 是 LMO 中心到原子位置的距离。LMO $i$ 和 $j$ 的轨道对域是它们各自域的集合论并集。该轨道对的虚轨道数是并集上每个原子虚轨道数的总和（每个原子的虚轨道最多计数一次）。\n\n任务：\n- 对于下面测试套件中的每个截断值 $R_c$，严格按照 $(0,1)$、$(0,2)$ 和 $(1,2)$ 的顺序，计算无序 LMO 对的轨道对域中的虚轨道数。\n-所有距离的单位均为埃 (Å)。输出是无量纲的整数计数；不要给输出数字附加任何单位。\n\n测试套件（截断值 $R_c$，单位为 Å）：\n- $0.6$\n- $1.2$\n- $2.25$\n- $3.5$\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个以逗号分隔的列表的列表，其中不含空格。对于按给定顺序的每个截断值，输出一个包含三个整数的列表，分别对应于对 $(0,1)$、$(0,2)$ 和 $(1,2)$。将这些每个截断值的列表聚合到一个外部列表中。例如，格式必须严格如 $[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]$，任何地方都不能有空格。", "solution": "我们从电子相关的局域性原理出发：在基于域的局域相关方案中，与一个局域化的已占实体相关的虚轨道空间被限制在一个空间邻域内。为对此建模，我们使用局域分子轨道（LMO）中心周围的距离阈值，并将轨道对域定义为各个 LMO 域的并集。计数过程可简化为欧几里得距离计算和集合求并。\n\n数据：\n- 原子 $0$ 到 $4$ 的坐标（单位为埃，Å）：\n  - $\\mathbf{R}_0 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_1 = (1.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_2 = (3.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_3 = (4.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (3.0, 1.2, 0.0)$.\n- 每个原子的虚轨道数：$n_0 = 3$, $n_1 = 2$, $n_2 = 4$, $n_3 = 1$, $n_4 = 3$。\n- LMO 中心：\n  - $\\mathbf{r}_0 = \\mathbf{R}_0$。\n  - $\\mathbf{r}_1 = \\dfrac{\\mathbf{R}_1 + \\mathbf{R}_2}{2} = (2.25, 0.0, 0.0)$。\n  - $\\mathbf{r}_2 = \\dfrac{\\mathbf{R}_2 + \\mathbf{R}_4}{2} = (3.0, 0.6, 0.0)$。\n\n对于任意 LMO $i$ 和原子 $a$，欧几里得距离为\n$$\nd_{ia} = \\lVert \\mathbf{r}_i - \\mathbf{R}_a \\rVert_2 = \\sqrt{(x_i - x_a)^2 + (y_i - y_a)^2 + (z_i - z_a)^2}.\n$$\n对于给定的截断值 $R_c$，单个 LMO 域是原子索引集\n$$\n\\mathcal{D}_i(R_c) = \\{ a \\in \\{0,1,2,3,4\\} \\mid d_{ia} \\le R_c \\}.\n$$\nLMO $i$ 和 $j$ 的轨道对域是其并集\n$$\n\\mathcal{D}_{ij}(R_c) = \\mathcal{D}_i(R_c) \\cup \\mathcal{D}_j(R_c).\n$$\n轨道对域中的虚轨道数为\n$$\nN_{ij}(R_c) = \\sum_{a \\in \\mathcal{D}_{ij}(R_c)} n_a.\n$$\n\n我们计算相关距离：\n\n对于 $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$：\n- $d_{0,0} = 0.0$,\n- $d_{0,1} = 1.5$,\n- $d_{0,2} = 3.0$,\n- $d_{0,3} = 4.5$,\n- $d_{0,4} = \\sqrt{3.0^2 + 1.2^2} = \\sqrt{9 + 1.44} = \\sqrt{10.44} \\approx 3.231$。\n\n对于 $\\mathbf{r}_1 = (2.25, 0.0, 0.0)$：\n- $d_{1,0} = 2.25$,\n- $d_{1,1} = 0.75$,\n- $d_{1,2} = 0.75$,\n- $d_{1,3} = 2.25$,\n- $d_{1,4} = \\sqrt{0.75^2 + 1.2^2} = \\sqrt{0.5625 + 1.44} = \\sqrt{2.0025} \\approx 1.415$。\n\n对于 $\\mathbf{r}_2 = (3.0, 0.6, 0.0)$：\n- $d_{2,0} = \\sqrt{3.0^2 + 0.6^2} = \\sqrt{9 + 0.36} = \\sqrt{9.36} \\approx 3.059$,\n- $d_{2,1} = \\sqrt{1.5^2 + 0.6^2} = \\sqrt{2.25 + 0.36} = \\sqrt{2.61} \\approx 1.616$,\n- $d_{2,2} = 0.6$,\n- $d_{2,3} = \\sqrt{1.5^2 + 0.6^2} \\approx 1.616$,\n- $d_{2,4} = 0.6$。\n\n我们采用闭球规则 $d_{ia} \\le R_c$。现在为每个截断值评估域和计数。\n\n截断值 $R_c = 0.6$：\n- $\\mathcal{D}_0(0.6) = \\{0\\}$,\n- $\\mathcal{D}_1(0.6) = \\varnothing$,\n- $\\mathcal{D}_2(0.6) = \\{2,4\\}$。\n轨道对并集：\n- $\\mathcal{D}_{0,1}(0.6) = \\{0\\}$ 得到 $N_{0,1}(0.6) = n_0 = 3$。\n- $\\mathcal{D}_{0,2}(0.6) = \\{0,2,4\\}$ 得到 $N_{0,2}(0.6) = n_0 + n_2 + n_4 = 3 + 4 + 3 = 10$。\n- $\\mathcal{D}_{1,2}(0.6) = \\{2,4\\}$ 得到 $N_{1,2}(0.6) = n_2 + n_4 = 4 + 3 = 7$。\n此截断值的结果列表：$[3, 10, 7]$。\n\n截断值 $R_c = 1.2$：\n- $\\mathcal{D}_0(1.2) = \\{0\\}$,\n- $\\mathcal{D}_1(1.2) = \\{1,2\\}$,\n- $\\mathcal{D}_2(1.2) = \\{2,4\\}$。\n轨道对并集：\n- $\\mathcal{D}_{0,1}(1.2) = \\{0,1,2\\}$ 得到 $N_{0,1}(1.2) = 3 + 2 + 4 = 9$。\n- $\\mathcal{D}_{0,2}(1.2) = \\{0,2,4\\}$ 得到 $N_{0,2}(1.2) = 3 + 4 + 3 = 10$。\n- $\\mathcal{D}_{1,2}(1.2) = \\{1,2,4\\}$ 得到 $N_{1,2}(1.2) = 2 + 4 + 3 = 9$。\n结果列表：$[9, 10, 9]$。\n\n截断值 $R_c = 2.25$：\n- $\\mathcal{D}_0(2.25) = \\{0,1\\}$,\n- $\\mathcal{D}_1(2.25) = \\{0,1,2,3,4\\}$（所有原子，因其距离均小于或等于 2.25），\n- $\\mathcal{D}_2(2.25) = \\{1,2,3,4\\}$。\n轨道对并集：\n- $\\mathcal{D}_{0,1}(2.25) = \\{0,1,2,3,4\\}$ 得到 $N_{0,1}(2.25) = 3 + 2 + 4 + 1 + 3 = 13$。\n- $\\mathcal{D}_{0,2}(2.25) = \\{0,1,2,3,4\\}$ 得到 $N_{0,2}(2.25) = 13$。\n- $\\mathcal{D}_{1,2}(2.25) = \\{0,1,2,3,4\\}$ 得到 $N_{1,2}(2.25) = 13$。\n结果列表：$[13, 13, 13]$。\n\n截断值 $R_c = 3.5$：\n- $\\mathcal{D}_0(3.5) = \\{0,1,2,4\\}$（原子 3 的距离为 4.5，被排除），\n- $\\mathcal{D}_1(3.5) = \\{0,1,2,3,4\\}$,\n- $\\mathcal{D}_2(3.5) = \\{0,1,2,3,4\\}$（原子 0 的距离约为 3.059，被包含）。\n轨道对并集：\n- $\\mathcal{D}_{0,1}(3.5) = \\{0,1,2,3,4\\}$ 得到 $N_{0,1}(3.5) = 13$。\n- $\\mathcal{D}_{0,2}(3.5) = \\{0,1,2,3,4\\}$ 得到 $N_{0,2}(3.5) = 13$。\n- $\\mathcal{D}_{1,2}(3.5) = \\{0,1,2,3,4\\}$ 得到 $N_{1,2}(3.5) = 13$。\n结果列表：$[13, 13, 13]$。\n\n按截断值 $[0.6, 1.2, 2.25, 3.5]$ 和轨道对 $(0,1)$、$(0,2)$、$(1,2)$ 的顺序汇总这三对的列表，预期的单行输出（无空格）为：\n$$\n[[3,10,7],[9,10,9],[13,13,13],[13,13,13]].\n$$\n\n程序应通过以下方式通用地实现此逻辑：\n- 从给定的原子坐标计算 LMO 中心，\n- 计算所有距离 $d_{ia}$，\n- 通过阈值 $d_{ia} \\le R_c$ 形成域，\n- 对给定的 LMO 对进行集合求并，\n- 对并集上的每个原子虚轨道数求和，\n- 并以指定的精确格式打印嵌套列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pair_virtual_counts(atom_positions, virtuals_per_atom, lmo_centers, cutoff):\n    \"\"\"\n    Compute number of virtuals per LMO pair at a given cutoff.\n    Unordered pairs considered: (0,1), (0,2), (1,2) for three LMOs.\n    \"\"\"\n    atom_positions = np.asarray(atom_positions, dtype=float)  # shape (A, 3)\n    lmo_centers = np.asarray(lmo_centers, dtype=float)        # shape (L, 3)\n    virtuals_per_atom = np.asarray(virtuals_per_atom, dtype=int)\n\n    # Distances: shape (L, A)\n    diff = lmo_centers[:, None, :] - atom_positions[None, :, :]\n    dists = np.linalg.norm(diff, axis=2)\n\n    # Domains: atoms within cutoff (inclusive)\n    domains = [set(np.nonzero(dists[i] = cutoff)[0].tolist()) for i in range(lmo_centers.shape[0])]\n\n    # Unordered pairs in lex order\n    pairs = [(0,1), (0,2), (1,2)]\n    counts = []\n    for i, j in pairs:\n        union_atoms = domains[i] | domains[j]\n        count = int(np.sum(virtuals_per_atom[list(union_atoms)])) if union_atoms else 0\n        counts.append(count)\n    return counts\n\ndef solve():\n    # Atomic coordinates (Å)\n    atoms = np.array([\n        [0.0, 0.0, 0.0],  # Atom 0\n        [1.5, 0.0, 0.0],  # Atom 1\n        [3.0, 0.0, 0.0],  # Atom 2\n        [4.5, 0.0, 0.0],  # Atom 3\n        [3.0, 1.2, 0.0],  # Atom 4\n    ], dtype=float)\n\n    # Virtual orbitals per atom (e.g., number of PAOs per atom)\n    v_per_atom = np.array([3, 2, 4, 1, 3], dtype=int)\n\n    # LMO centers:\n    # LMO 0 at atom 0\n    r0 = atoms[0]\n    # LMO 1 at midpoint of atoms 1 and 2\n    r1 = 0.5 * (atoms[1] + atoms[2])\n    # LMO 2 at midpoint of atoms 2 and 4\n    r2 = 0.5 * (atoms[2] + atoms[4])\n    lmo_centers = np.vstack([r0, r1, r2])\n\n    # Test suite of cutoffs (Å)\n    test_cases = [0.6, 1.2, 2.25, 3.5]\n\n    results = []\n    for cutoff in test_cases:\n        counts = compute_pair_virtual_counts(atoms, v_per_atom, lmo_centers, cutoff)\n        results.append(counts)\n\n    # Format nested list without spaces: [[a,b,c],[d,e,f],...]\n    outer = []\n    for inner in results:\n        inner_str = \"[\" + \",\".join(str(int(x)) for x in inner) + \"]\"\n        outer.append(inner_str)\n    print(\"[\" + \",\".join(outer) + \"]\")\n\nsolve()\n```", "id": "2903203"}, {"introduction": "即使在为电子对 $(i,j)$ 定义的局域虚轨道域内，不同虚轨道的贡献也存在巨大差异。为了实现极致的计算效率，现代局域相关方法引入了电子对自然轨道（Pair Natural Orbitals, PNOs）进行二次截断。这个练习将引导你从一个简化的双电子激发振幅矩阵出发，计算 PNO 的本征值（占据数），并由此决定需要保留的 PNO 数量以达到特定的能量恢复阈值。这个过程完美地揭示了 DLPNO-CCSD 这类方法高效的根源：仅用极少数的 PNO 就足以精确地描述单个电子对的绝大部分相关能 [@problem_id:2903183]。", "problem": "在采用对自然轨道（PNO）的局域相关理论中，例如基于域的局域对自然轨道耦合簇（DLPNO-CCSD），一个占据-占据对 $\\{i,j\\}$ 的PNO被定义为由对双激发振幅构建的虚-虚对密度矩阵的本征向量。考虑一个闭壳层体系和一个占据对 $\\{i,j\\}$，其自旋匹配的实双激发振幅 $t_{ij}^{ab}$ （在正交归一的正则虚轨道基中）由一个 $4 \\times 4$ 矩阵 $\\mathbf{T}$ 给出，其行由虚轨道 $a \\in \\{1,2,3,4\\}$ 索引，列由虚轨道 $b \\in \\{1,2,3,4\\}$ 索引：\n$$\n\\mathbf{T} \\equiv \\big(t_{ij}^{ab}\\big) =\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}.\n$$\n采用标准模型，其中虚空间中的对密度定义为\n$$\n\\mathbf{D} \\equiv \\big(D_{ac}\\big) = \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb} = \\mathbf{T}\\,\\mathbf{T}^{\\top},\n$$\nPNO占据数是 $\\mathbf{D}$ 的本征值 $\\{\\lambda_p\\}$。进一步假设一个常见近似，即可恢复的对相关能与 $\\mathrm{tr}(\\mathbf{D})$ 成正比，并且保留 $k$ 个最大的PNO所恢复的能量分数等于\n$$\nf_k = \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}.\n$$\n任务：\n1. 计算 $\\mathbf{D}$ 的PNO本征值 $\\{\\lambda_p\\}$ 并将其按降序排列。\n2. 确定所需的最小PNO数量 $k_{\\min}$，使得 $f_{k_{\\min}} \\ge 0.999$。\n\n仅报告最小数量 $k_{\\min}$ 作为最终答案。无需单位。", "solution": "首先对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- **体系：** 闭壳层体系。\n- **对：** 单个占据对 $\\{i,j\\}$。\n- **振幅：** 一个 $4 \\times 4$ 的自旋匹配实双激发振幅矩阵 $\\mathbf{T} \\equiv (t_{ij}^{ab})$ 如下：\n$$\n\\mathbf{T} =\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}\n$$\n- **对密度矩阵定义：** 虚-虚对密度矩阵 $\\mathbf{D}$ 被定义为 $\\mathbf{D} \\equiv (D_{ac}) = \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb}$，用矩阵表示为 $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$。\n- **PNO占据数：** $\\mathbf{D}$ 的本征值 $\\{\\lambda_p\\}$。\n- **能量恢复分数：** 前 $k$ 个PNO恢复的对相关能分数为 $f_k = \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}$。\n- **目标：** 找到最小整数 $k_{\\min}$，使得 $f_{k_{\\min}} \\ge 0.999$。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它采用了量子化学中局域相关方法理论（特别是基于PNO的方法）的标准定义和近似。对密度矩阵、PNO占据数和能量恢复分数的定义在该理论框架内都是常规的。该问题提法严谨，提供了所有必要信息，其数学结构保证了唯一且有意义的解的存在。不存在矛盾、歧义或事实错误。这是一个计算化学理论中有效的、形式化的练习。\n\n**第3步：结论与行动**\n问题有效。将推导解答。\n\n**解题过程**\n主要任务是求出对密度矩阵 $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$ 的本征值，然后确定满足给定阈值所需的最小本征值数量。\n\n首先，我们计算矩阵 $\\mathbf{D}$。给定的振幅矩阵 $\\mathbf{T}$ 为：\n$$\n\\mathbf{T} =\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}\n$$\n该矩阵具有块对角结构：\n$$\n\\mathbf{T} = \\begin{pmatrix} \\mathbf{A}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B} \\end{pmatrix}, \\quad \\text{其中 } \\mathbf{A} = \\begin{pmatrix} 0  1 \\\\ 10^{-3/2}  0 \\end{pmatrix} \\text{ 且 } \\mathbf{B} = \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix}\n$$\n$\\mathbf{T}$ 的转置是 $\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}^{\\top}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B}^{\\top} \\end{pmatrix}$。\n因此，密度矩阵 $\\mathbf{D}$ 也是块对角的：\n$$\n\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}\\mathbf{A}^{\\top}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B}\\mathbf{B}^{\\top} \\end{pmatrix}\n$$\n我们分别计算块 $\\mathbf{A}\\mathbf{A}^{\\top}$ 和 $\\mathbf{B}\\mathbf{B}^{\\top}$。\n对于第一个块：\n$$\n\\mathbf{A}\\mathbf{A}^{\\top} = \\begin{pmatrix} 0  1 \\\\ 10^{-3/2}  0 \\end{pmatrix} \\begin{pmatrix} 0  10^{-3/2} \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} (0)(0) + (1)(1)  (0)(10^{-3/2}) + (1)(0) \\\\ (10^{-3/2})(0) + (0)(1)  (10^{-3/2})(10^{-3/2}) + (0)(0) \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  10^{-3} \\end{pmatrix}\n$$\n对于第二个块，注意到 $\\mathbf{B}$ 是一个对称矩阵，所以 $\\mathbf{B}^{\\top} = \\mathbf{B}$。\n$$\n\\mathbf{B}\\mathbf{B}^{\\top} = \\mathbf{B}^2 = \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix} \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix} = \\begin{pmatrix} (10^{-3})^2  0 \\\\ 0  (10^{-3})^2 \\end{pmatrix} = \\begin{pmatrix} 10^{-6}  0 \\\\ 0  10^{-6} \\end{pmatrix}\n$$\n合并这些块，完整的密度矩阵 $\\mathbf{D}$ 是：\n$$\n\\mathbf{D} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  10^{-3}  0  0\\\\\n0  0  10^{-6}  0\\\\\n0  0  0  10^{-6}\n\\end{pmatrix}\n$$\nPNO占据数 $\\{\\lambda_p\\}$ 是 $\\mathbf{D}$ 的本征值。由于 $\\mathbf{D}$ 是一个对角矩阵，其本征值就是其对角元。\n本征值为 $\\{1, 10^{-3}, 10^{-6}, 10^{-6}\\}$。\n将这些值按降序排列得到：\n$\\lambda_1 = 1$\n$\\lambda_2 = 10^{-3}$\n$\\lambda_3 = 10^{-6}$\n$\\lambda_4 = 10^{-6}$\n\n接下来，我们必须找到最小整数 $k_{\\min}$，使得恢复分数 $f_{k_{\\min}} \\ge 0.999$。\n本征值的总和，即 $\\mathbf{D}$ 的迹，为：\n$$\n\\sum_{p=1}^{4} \\lambda_p = 1 + 10^{-3} + 10^{-6} + 10^{-6} = 1 + 0.001 + 2 \\times 10^{-6} = 1.001002\n$$\n我们对递增的 $k$ 值检验分数 $f_k$。\n对于 $k=1$：\n$$\nf_1 = \\frac{\\lambda_1}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1}{1.001002}\n$$\n我们检验条件 $f_1 \\ge 0.999$：\n$$\n\\frac{1}{1.001002} \\ge 0.999 \\iff 1 \\ge 0.999 \\times 1.001002\n$$\n$0.999 \\times 1.001002 = (1 - 10^{-3})(1 + 10^{-3} + 2 \\times 10^{-6}) = 1 + 10^{-3} + 2 \\times 10^{-6} - 10^{-3} - 10^{-6} - 2 \\times 10^{-9} = 1 + 10^{-6} - 2 \\times 10^{-9} = 1.000000998$。\n检验结果为 $1 \\ge 1.000000998$，这是错误的。因此，$k=1$ 是不够的。另一种计算方法得到 $f_1 \\approx 0.998999$，小于 $0.999$。\n\n对于 $k=2$：\n$$\nf_2 = \\frac{\\lambda_1 + \\lambda_2}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1 + 10^{-3}}{1.001002} = \\frac{1.001}{1.001002}\n$$\n我们检验条件 $f_2 \\ge 0.999$：\n$$\n\\frac{1.001}{1.001002} \\ge 0.999 \\iff 1.001 \\ge 0.999 \\times 1.001002\n$$\n使用之前的结果，$0.999 \\times 1.001002 = 0.999990998$。\n检验结果为 $1.001 \\ge 0.999990998$。这个不等式是成立的。\n因为条件对于 $k=2$ 满足但对于 $k=1$ 不满足，所以所需的最小PNO数量是 2。\n因此，$k_{\\min} = 2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "2903183"}]}