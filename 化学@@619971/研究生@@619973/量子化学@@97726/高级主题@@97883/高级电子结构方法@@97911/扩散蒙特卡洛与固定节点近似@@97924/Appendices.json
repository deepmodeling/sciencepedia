{"hands_on_practices": [{"introduction": "本练习旨在巩固扩散蒙特卡洛（DMC）方法的核心概念：虚时投影。通过一个精确可解的一维谐振子模型，我们将直接观察一个任意的初始波函数如何随着虚时演化，逐渐“纯化”为系统的基态。这个过程是DMC方法能够找到基态能量的根本原因。此外，本练习还演示了如何通过施加一个精确的节面约束（即要求波函数具有奇宇称），来计算系统的第一激发态，从而揭示固定节面近似在计算激发态中的应用。[@problem_id:2885586]", "problem": "您的任务是将作为扩散蒙特卡罗（DMC）核心的虚时投影原理与一个精确可解的基准问题联系起来。考虑原子单位下的一维谐振子哈密顿量，其中约化普朗克常数和电子质量均设为1。哈密顿量为 $H = -\\tfrac{1}{2}\\tfrac{d^2}{dx^2} + \\tfrac{1}{2}\\,\\omega^2 x^2$，频率参数 $\\omega \\gt 0$。虚时演化算符为 $e^{-\\tau H}$（虚时 $\\tau \\ge 0$），相应的虚时传播子（欧几里得核）$K(x,x';\\tau)$ 由 $\\psi(x,\\tau) = \\int_{-\\infty}^{\\infty} K(x,x';\\tau)\\,\\psi(x',0)\\,dx'$ 定义。\n\n您的任务如下，请从基本定律和核心定义出发：\n\n- 从含时薛定谔方程和 $H$ 的谱分解开始。利用已知的谐振子本征函数和本征值（这些是经过充分检验的事实），将精确的虚时传播子 $K(x,x';\\tau)$ 推导为求和形式 $\\sum_{n=0}^{\\infty} \\psi_n(x)\\psi_n(x') e^{-\\tau E_n}$，然后进行求和，得到用双曲函数表示的闭式核。不要预设核的最终形式；应从谱表示和厄米多项式的生成函数出发进行推导。\n\n- 解释为何对于任何不与基态正交的平方可积初始函数 $\\psi(x,0)$，投影 $\\psi(x,\\tau) = \\left(e^{-\\tau H}\\psi\\right)(x)$ 会在 $\\tau \\to \\infty$ 时收敛到基态。将此与扩散蒙特卡罗方法中使用的原理联系起来。然后，将DMC中的固定节点约束解释为强制施加一个选定节面的边界条件。对于一维谐振子，施加一个奇宇称子空间（在 $x=0$ 处有一个节点）是获取第一激发态的一个精确的固定节点约束。\n\n- 实现一个数值模拟，将精确的虚时传播子应用于指定的初始函数，并测量其收敛性。在均匀网格上对空间进行离散化，并使用梯形法则近似计算积分。在离散网格上使用 $L^2$ 范数对波函数进行归一化。\n\n- 全程使用原子单位。最终的数值答案无需报告物理单位。不使用角度。所有报告的数字必须四舍五入到六位小数。\n\n测试套件和要求输出：\n\n使用以下固定参数和定义进行计算。\n\n- 频率：$\\omega = 1$。\n\n- 空间网格：$x \\in [-L,L]$，其中 $L = \\tfrac{6}{\\sqrt{\\omega}}$。使用 $N = 1201$ 个均匀间隔的点，因此网格间距为 $\\Delta x = \\tfrac{2L}{N-1}$。\n\n- 网格上的精确参考本征函数（通过离散归一化在网格上归一）：\n  - 基态：$\\psi_0(x) = \\left(\\tfrac{\\omega}{\\pi}\\right)^{1/4} e^{-\\tfrac{1}{2}\\omega x^2}$。\n  - 第一激发态：$\\psi_1(x) = \\sqrt{2\\omega}\\,x\\,\\psi_0(x)$。\n  - 精确能量：$E_0 = \\tfrac{1}{2}\\omega$ 和 $E_1 = \\tfrac{3}{2}\\omega$。\n\n- 初始函数：\n  - 通用初始函数（无固定节点）：$\\psi_{\\mathrm{g}}(x) = e^{-\\tfrac{1}{2}(x-1)^2} + 0.6\\,e^{-\\tfrac{1}{2}(x+1.5)^2}$。\n  - 节点约束初始函数（奇宇称；第一激发态的精确固定节点）：$\\psi_{\\mathrm{n}}(x) = x\\,e^{-x^2}$。\n\n- 通过精确核 $K(x,x';\\tau)$ 进行传播以获得 $\\psi(x,\\tau) = \\int K(x,x';\\tau)\\,\\psi(x',0)\\,dx'$，使用梯形法则进行离散化。传播后，在网格上将 $\\psi(x,\\tau)$ 归一化至单位 $L^2$ 范数。对于节点约束情况，请注意奇宇称初始函数在偶宇称核的传播下保持奇宇称，从而保留了 $x=0$ 处的节点；无需额外强制执行。\n\n- 能量估计量：对于网格上的归一化实波函数 $\\psi(x)$，计算能量估计值\n  $$\n  E[\\psi] \\approx \\frac{\\int \\left[\\tfrac{1}{2} \\left(\\tfrac{d\\psi}{dx}\\right)^2 + \\tfrac{1}{2}\\omega^2 x^2 \\psi(x)^2\\right] dx}{\\int \\psi(x)^2 dx},\n  $$\n  其中导数由中心差分近似，积分由梯形法则近似。\n\n计算以下六个量，并按指定顺序将它们作为单个列表输出，每个条目四舍五入到六位小数：\n\n1. 将 $\\psi_{\\mathrm{g}}$ 用 $\\tau = 0.25$ 投影后与基态的 $L^2$ 误差：\n   $$\n   \\left\\|\\psi(\\cdot,\\tau) - \\psi_0(\\cdot)\\right\\|_2 \\equiv \\left(\\int \\left[\\psi(x,\\tau) - \\psi_0(x)\\right]^2 dx\\right)^{1/2}.\n   $$\n\n2. 将 $\\psi_{\\mathrm{g}}$ 用 $\\tau = 1.0$ 投影后与基态的 $L^2$ 误差。\n\n3. 将 $\\psi_{\\mathrm{g}}$ 用 $\\tau = 3.0$ 投影后与基态的 $L^2$ 误差。\n\n4. 将 $\\psi_{\\mathrm{g}}$ 用 $\\tau = 3.0$ 投影后相对于 $E_0$ 的绝对能量误差：\n   $$\n   \\left|E[\\psi(\\cdot,\\tau)] - E_0\\right|.\n   $$\n\n5. 将 $\\psi_{\\mathrm{n}}$ 用 $\\tau = 1.0$ 投影后与第一激发态的 $L^2$ 误差。\n\n6. 将 $\\psi_{\\mathrm{n}}$ 用 $\\tau = 3.0$ 投影后相对于 $E_1$ 的绝对能量误差。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，[$r_1,r_2,r_3,r_4,r_5,r_6$]），其中包含六个结果，每个条目四舍五入到六位小数。不应打印其他任何文本。", "solution": "该问题是有效的，因为它在科学上基于量子力学原理，在数学上是适定的，并且客观地陈述了所有必要的参数和定义。我们将按要求进行推导和计算。\n\n首先，我们推导一维量子谐振子的精确虚时传播子。在原子单位（$m=1$, $\\hbar=1$）下，哈密顿量由 $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$ 给出。虚时传播子或核 $K(x,x';\\tau)$，根据 $\\psi(x,\\tau) = \\int_{-\\infty}^{\\infty} K(x,x';\\tau)\\,\\psi(x',0)\\,dx'$ 在虚时 $\\tau \\ge 0$ 内演化波函数 $\\psi(x,0)$。该核可以通过对哈密顿量 $H$ 的完备本征态集合 $\\{\\psi_n(x)\\}$ 和本征值 $\\{E_n\\}$ 进行谱分解来表示：\n$$\nK(x,x';\\tau) = \\langle x| e^{-\\tau H} |x' \\rangle = \\sum_{n=0}^{\\infty} \\langle x|e^{-\\tau H}|\\psi_n\\rangle\\langle\\psi_n|x'\\rangle = \\sum_{n=0}^{\\infty} \\psi_n(x)\\psi_n^*(x') e^{-\\tau E_n}\n$$\n对于谐振子，本征函数是实函数，因此 $\\psi_n^*(x') = \\psi_n(x')$。本征值为 $E_n = \\omega(n + \\frac{1}{2})$，归一化本征函数为 $\\psi_n(x) = \\left(\\frac{\\sqrt{\\omega/\\pi}}{2^n n!}\\right)^{1/2} H_n(\\sqrt{\\omega}x) e^{-\\frac{1}{2}\\omega x^2}$，其中 $H_n(y)$ 是物理学家定义的厄米多项式。将这些代入求和式中：\n$$\nK(x,x';\\tau) = \\sum_{n=0}^{\\infty} \\left[\\left(\\frac{\\sqrt{\\omega/\\pi}}{2^n n!}\\right)^{1/2} H_n(\\sqrt{\\omega}x) e^{-\\frac{1}{2}\\omega x^2}\\right] \\left[\\left(\\frac{\\sqrt{\\omega/\\pi}}{2^n n!}\\right)^{1/2} H_n(\\sqrt{\\omega}x') e^{-\\frac{1}{2}\\omega x'^2}\\right] e^{-\\omega(n+1/2)\\tau}\n$$\n我们定义无量纲坐标 $y = \\sqrt{\\omega}x$ 和 $y' = \\sqrt{\\omega}x'$，并令 $z = e^{-\\omega\\tau}$。表达式简化为：\n$$\nK(x,x';\\tau) = \\sqrt{\\frac{\\omega}{\\pi}} e^{-\\frac{\\omega\\tau}{2}} e^{-\\frac{1}{2}(y^2+y'^2)} \\sum_{n=0}^{\\infty} \\frac{H_n(y) H_n(y')}{2^n n!} z^n\n$$\n这个求和是一个已知的恒等式，称为厄米多项式的梅勒公式：\n$$\n\\sum_{n=0}^{\\infty} \\frac{H_n(y) H_n(y')}{2^n n!} z^n = (1-z^2)^{-1/2} \\exp\\left[\\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right]\n$$\n将此代回核的表达式中：\n$$\nK(x,x';\\tau) = \\sqrt{\\frac{\\omega}{\\pi}} e^{-\\frac{\\omega\\tau}{2}} e^{-\\frac{1}{2}(y^2+y'^2)} (1-z^2)^{-1/2} \\exp\\left[\\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right]\n$$\n我们合并指数项。总指数的参数变为：\n$$\n-\\frac{\\omega\\tau}{2} - \\frac{1}{2}(y^2+y'^2) + \\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2} = -\\frac{\\omega\\tau}{2} + \\frac{-\\frac{1}{2}(y^2+y'^2)(1-z^2) + 2yy'z - (y^2+y'^2)z^2}{1-z^2}\n$$\n$$\n= -\\frac{\\omega\\tau}{2} + \\frac{-\\frac{1}{2}(y^2+y'^2)(1+z^2) + 2yy'z}{1-z^2}\n$$\n现在，我们用双曲函数表示 $z=e^{-\\omega\\tau}$：$1-z^2 = 1 - e^{-2\\omega\\tau} = 2e^{-\\omega\\tau}\\sinh(\\omega\\tau)$，以及 $1+z^2 = 1 + e^{-2\\omega\\tau} = 2e^{-\\omega\\tau}\\cosh(\\omega\\tau)$。系数变为 $\\sqrt{\\frac{\\omega}{\\pi(1-z^2)}} e^{-\\omega\\tau/2} = \\sqrt{\\frac{\\omega}{2\\pi \\sinh(\\omega\\tau)}}$。指数部分变为：\n$$\n-\\frac{\\omega\\tau}{2} + \\frac{-\\frac{1}{2}(y^2+y'^2) 2e^{-\\omega\\tau}\\cosh(\\omega\\tau) + 2yy'e^{-\\omega\\tau}}{2e^{-\\omega\\tau}\\sinh(\\omega\\tau)} = -\\frac{\\omega\\tau}{2} - \\frac{(y^2+y'^2)\\cosh(\\omega\\tau) - 2yy'}{2\\sinh(\\omega\\tau)}\n$$\n这似乎过于复杂。让我们对指数采用另一种更直接地导出最终形式的简化路径。我们将梅勒公式中的指数项与 $e^{-\\frac{1}{2}(y^2+y'^2)}$ 项合并：\n$$\n\\exp\\left(-\\frac{1}{2}(y^2+y'^2)\\right) \\exp\\left(\\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right) = \\exp\\left(\\frac{-\\frac{1}{2}(y^2+y'^2)(1-z^2) + 2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right)\n$$\n$$\n= \\exp\\left(\\frac{-\\frac{1}{2}(y^2+y'^2) - \\frac{1}{2}(y^2+y'^2)z^2 + 2yy'z}{1-z^2}\\right) = \\exp\\left(\\frac{-\\frac{1}{2}(y^2+y'^2)(1+z^2)+2yy'z}{1-z^2}\\right)\n$$\n代入 $y=\\sqrt{\\omega}x$, $y'=\\sqrt{\\omega}x'$, $z=e^{-\\omega\\tau}$, $1-z^2=e^{-\\omega\\tau}(e^{\\omega\\tau}-e^{-\\omega\\tau})=2e^{-\\omega\\tau}\\sinh(\\omega\\tau)$，以及 $1+z^2=2e^{-\\omega\\tau}\\cosh(\\omega\\tau)$，指数变为：\n$$\n\\frac{-\\frac{1}{2}\\omega(x^2+x'^2)(2e^{-\\omega\\tau}\\cosh(\\omega\\tau))+2\\omega xx'e^{-\\omega\\tau}}{2e^{-\\omega\\tau}\\sinh(\\omega\\tau)} = -\\frac{\\omega}{2\\sinh(\\omega\\tau)}\\left[(x^2+x'^2)\\cosh(\\omega\\tau) - 2xx'\\right]\n$$\n与系数 $\\sqrt{\\frac{\\omega}{2\\pi \\sinh(\\omega\\tau)}}$ 合并，我们得到闭式传播子：\n$$\nK(x,x';\\tau) = \\left[\\frac{\\omega}{2\\pi \\sinh(\\omega\\tau)}\\right]^{1/2} \\exp\\left\\{ -\\frac{\\omega}{2 \\sinh(\\omega\\tau)} \\left[ (x^2+x'^2)\\cosh(\\omega\\tau) - 2xx' \\right] \\right\\}\n$$\n推导至此完成。\n\n接下来，我们讨论基态投影原理。任何平方可积的初始态 $\\psi(x,0)$ 均可在 $H$ 的本征基上展开：$\\psi(x,0) = \\sum_{n=0}^{\\infty} c_n \\psi_n(x)$，其中 $c_n = \\int \\psi_n(x)\\psi(x,0)dx$。应用虚时演化算符得到：\n$$\n\\psi(x,\\tau) = e^{-\\tau H} \\psi(x,0) = \\sum_{n=0}^{\\infty} c_n e^{-\\tau E_n} \\psi_n(x) = e^{-\\tau E_0}\\left[c_0\\psi_0(x) + c_1 e^{-\\tau(E_1-E_0)}\\psi_1(x) + \\dots\\right]\n$$\n由于能量本征值是排序的 $E_0 < E_1 < E_2 < \\dots$，对于 $n>0$ 的指数项 $(E_n - E_0)$ 均为严格正值。当 $\\tau \\to \\infty$ 时，所有 $e^{-\\tau(E_n-E_0)}$ 项都衰减至零，只留下 $n=0$ 的项。因此，对于任何不与基态正交的初始态（即 $c_0 \\neq 0$），传播后的波函数将收敛到基态：$\\lim_{\\tau\\to\\infty} \\psi(x,\\tau) \\propto \\psi_0(x)$。扩散蒙特卡罗（DMC）是一种模拟这一过程的随机方法。虚时薛定谔方程类似于一个扩散-反应方程，其中波函数由一群“行走子”表示。这些行走子进行扩散（由于动能项）并被产生或湮灭（由于势能项）。经过足够长的虚时，行走子的分布会收敛到基态波函数的抽样。对于费米子体系，波函数必须是反对称的，这意味着它必须有节面（即 $\\psi=0$ 的曲面）。标准的DMC无法正确处理这些节面，这导致了“费米子符号问题”。固定节点近似通过将一个引导试探波函数的节点作为无限势垒来解决这个问题。任何试图穿越节点的行走子都会被移除。此过程会找到与所施加的节面结构兼容的最低能量状态。对于一维谐振子，其真实基态 $\\psi_0$ 是无节点的。第一激发态 $\\psi_1$ 在 $x=0$ 处有一个节点。通过将系统限制在奇宇称函数（所有这些函数都在 $x=0$ 处有节点）的空间中，虚时投影将收敛到能量最低的奇宇称态，即 $\\psi_1$。这是一个*精确的*固定节点计算的实例。\n\n最后，数值实现部分将问题离散化。空间由在区间 $x \\in [-L, L]$（其中 $L=6.0$）内的 $N=1201$ 个均匀网格点表示。传播积分 $\\psi(x_i, \\tau) = \\int K(x_i,x';\\tau)\\psi(x',0)dx'$ 使用梯形法则进行数值计算，这可以表示为对离散化的波函数和核矩阵 $K_{ij}=K(x_i,x_j;\\tau)$ 的矩阵-向量运算。在每个传播步骤之后，得到的波函数在网格上归一化，使得 $\\int |\\psi(x,\\tau)|^2 dx \\approx \\sum_i |\\psi(x_i,\\tau)|^2 \\Delta x = 1.0$。能量是通过哈密顿量的期望值来估计的，其中动能项 $\\int \\psi (-\\frac{1}{2}\\nabla^2) \\psi dx = \\frac{1}{2}\\int (\\nabla \\psi)^2 dx$ 使用中心差分计算导数 $\\nabla\\psi$，并使用梯形法则计算积分。这个设置允许对理论原理进行直接的数值检验。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum harmonic oscillator problem using the exact imaginary-time propagator.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    omega = 1.0\n    L = 6.0 / np.sqrt(omega)\n    N = 1201\n    \n    # Exact energies for reference\n    E0_exact = 0.5 * omega\n    E1_exact = 1.5 * omega\n\n    # Discretize the spatial domain\n    x_grid = np.linspace(-L, L, N)\n    dx = (2 * L) / (N - 1)\n\n    # --- Helper functions ---\n    \n    def normalize(psi, dx_val):\n        \"\"\"Normalizes a wavefunction on the grid using the trapezoidal rule for the L2 norm.\"\"\"\n        norm_sq = np.trapz(psi**2, dx=dx_val)\n        return psi / np.sqrt(norm_sq)\n\n    def l2_error(psi_a, psi_b, dx_val):\n        \"\"\"Calculates the L2 error between two wavefunctions on the grid.\"\"\"\n        return np.sqrt(np.trapz((psi_a - psi_b)**2, dx=dx_val))\n\n    def calculate_energy(psi, x_vals, dx_val, omega_val):\n        \"\"\"Calculates the energy expectation value for a normalized wavefunction.\"\"\"\n        # Use central differences for the derivative\n        dpsi_dx = np.gradient(psi, dx_val)\n        \n        # Kinetic and potential energy integrands\n        kinetic_integrand = 0.5 * dpsi_dx**2\n        potential_integrand = 0.5 * (omega_val**2) * (x_vals**2) * (psi**2)\n        \n        # Calculate total energy using trapezoidal rule\n        energy = np.trapz(kinetic_integrand + potential_integrand, dx=dx_val)\n        return energy\n        \n    def get_propagator_matrix(tau, x_vals, omega_val):\n        \"\"\"Computes the exact propagator matrix K(x_i, x_j; tau).\"\"\"\n        if tau == 0:\n            # Propagator is a Dirac delta, discretized form is 1/dx at i=j\n            return np.identity(len(x_vals)) / dx\n            \n        arg_sinh = omega_val * tau\n        prefactor = np.sqrt(omega_val / (2 * np.pi * np.sinh(arg_sinh)))\n        \n        # Create meshgrid for vectorized calculation\n        # xp_mesh for output coordinate x_i, x_mesh for input coordinate x_j\n        xp_mesh, x_mesh = np.meshgrid(x_vals, x_vals, indexing='ij')\n\n        cosh_term = np.cosh(arg_sinh)\n        \n        exponent = -omega_val / (2 * np.sinh(arg_sinh)) * \\\n                   ((xp_mesh**2 + x_mesh**2) * cosh_term - 2 * xp_mesh * x_mesh)\n        \n        K = prefactor * np.exp(exponent)\n        return K\n\n    def propagate(psi_initial, K_matrix, x_vals):\n        \"\"\"Propagates a wavefunction using the kernel matrix and trapezoidal rule.\"\"\"\n        # Integrand for each output point x_i is K(x_i, x_j)*psi(x_j)\n        integrand = K_matrix * psi_initial[None, :]\n        psi_final = np.trapz(integrand, x=x_vals, axis=1)\n        return psi_final\n\n    # --- Setup of reference and initial states ---\n\n    # Reference eigenfunctions (normalized on the grid)\n    psi0_unnorm = (omega / np.pi)**0.25 * np.exp(-0.5 * omega * x_grid**2)\n    psi0_ref = normalize(psi0_unnorm, dx)\n\n    psi1_unnorm = np.sqrt(2 * omega) * x_grid * psi0_unnorm\n    psi1_ref = normalize(psi1_unnorm, dx)\n\n    # Initial functions\n    psi_g_initial = np.exp(-0.5 * (x_grid - 1.0)**2) + 0.6 * np.exp(-0.5 * (x_grid + 1.5)**2)\n    psi_n_initial = x_grid * np.exp(-x_grid**2)\n\n    results = []\n    \n    # --- Perform calculations for the generic initial function psi_g ---\n    \n    # Task 1: L2 error for psi_g with tau = 0.25\n    tau_g1 = 0.25\n    K_g1 = get_propagator_matrix(tau_g1, x_grid, omega)\n    psi_g_tau1 = propagate(psi_g_initial, K_g1, x_grid)\n    psi_g_tau1_norm = normalize(psi_g_tau1, dx)\n    results.append(l2_error(psi_g_tau1_norm, psi0_ref, dx))\n\n    # Task 2: L2 error for psi_g with tau = 1.0\n    tau_g2 = 1.0\n    K_g2 = get_propagator_matrix(tau_g2, x_grid, omega)\n    psi_g_tau2 = propagate(psi_g_initial, K_g2, x_grid)\n    psi_g_tau2_norm = normalize(psi_g_tau2, dx)\n    results.append(l2_error(psi_g_tau2_norm, psi0_ref, dx))\n\n    # Task 3: L2 error for psi_g with tau = 3.0\n    tau_g3 = 3.0\n    K_g3 = get_propagator_matrix(tau_g3, x_grid, omega)\n    psi_g_tau3 = propagate(psi_g_initial, K_g3, x_grid)\n    psi_g_tau3_norm = normalize(psi_g_tau3, dx)\n    results.append(l2_error(psi_g_tau3_norm, psi0_ref, dx))\n\n    # Task 4: Absolute energy error for psi_g with tau = 3.0\n    energy_g3 = calculate_energy(psi_g_tau3_norm, x_grid, dx, omega)\n    results.append(abs(energy_g3 - E0_exact))\n\n    # --- Perform calculations for the nodal-constrained function psi_n ---\n    \n    # Task 5: L2 error for psi_n with tau = 1.0\n    tau_n1 = 1.0\n    K_n1 = get_propagator_matrix(tau_n1, x_grid, omega)\n    psi_n_tau1 = propagate(psi_n_initial, K_n1, x_grid)\n    psi_n_tau1_norm = normalize(psi_n_tau1, dx)\n    results.append(l2_error(psi_n_tau1_norm, psi1_ref, dx))\n    \n    # Task 6: Absolute energy error for psi_n with tau = 3.0\n    tau_n2 = 3.0\n    K_n2 = get_propagator_matrix(tau_n2, x_grid, omega)\n    psi_n_tau2 = propagate(psi_n_initial, K_n2, x_grid)\n    psi_n_tau2_norm = normalize(psi_n_tau2, dx)\n    energy_n2 = calculate_energy(psi_n_tau2_norm, x_grid, dx, omega)\n    results.append(abs(energy_n2 - E1_exact))\n\n    # Print results in the required format\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2885586"}, {"introduction": "在理解了虚时投影的原理之后，下一个关键步骤是掌握其在算法层面的具体实现。扩散蒙特卡洛方法将波函数用一系列“行走者”（walkers）的分布来表示，而固定节面约束则通过在节面上设置“吸收边界”来实现。本练习将通过一个简化的二维扩散模拟，让您亲手实现这一核心算法机制：任何试图穿越预设节面的行走者都将被从模拟中移除。通过对比吸收边界存在与否两种情况，您将深刻理解固定节面条件在DMC模拟中的实际作用。[@problem_id:2885522]", "problem": "要求您在一个带有平面节点的简单二维情况下，演示扩散蒙特卡罗 (DMC) 中的固定节点边界条件。请使用原子单位，因此扩散常数为 $D = 1/2$。考虑一个在二维空间中没有外势的自由粒子，其在虚时间中的行为由扩散方程描述，该方程源于分布 $f(\\mathbf{R},\\tau)$ 的虚时间薛定谔方程，其中 $\\mathbf{R} = (x,y)$ 且 $\\tau$ 是虚时间。固定节点近似在节点流形上施加了狄利克雷边界条件，此处该节点流形取为平面 $x=0$，对应于试探波函数 $\\psi_{\\mathrm{T}}(x,y) = x$。在这种设置中，固定节点边界被实现为一个吸收边界：任何试图从 $x>0$ 跨越到 $x\\le 0$ 的扩散轨迹都将被移除。\n\n您的任务是：\n- 从虚时间薛定谔方程与扩散之间的基本映射关系出发，证明独立的行走子在每个时间步长上经历高斯位移。\n- 具体到自由粒子情况，其中 $D=1/2$，没有漂移也没有分支，并证明时间步长为 $\\Delta \\tau$ 的离散化通过以下公式更新位置\n$$\n\\mathbf{R}_{t+1} = \\mathbf{R}_t + \\sqrt{2D\\,\\Delta \\tau}\\,\\boldsymbol{\\xi}_t,\n$$\n其中 $\\boldsymbol{\\xi}_t$ 具有独立的标准正态分量。\n- 解释 $x=0$ 处的固定节点吸收边界如何映射到以下规则：如果一个当前位于 $x_t>0$ 的行走子，其提议的移动导致 $x_{t+1}\\le 0$，那么该行走子将从模拟中被移除，并且不再随时间演化。\n- 对多种时间步长，数值验证当施加吸收边界时，没有存活的行走子会处于禁区 $x\\le 0$。同时验证，在没有吸收的情况下，一些行走子确实会最终进入禁区。\n\n数学和算法规范：\n- 使用自由粒子的虚时间演化，在原子单位下这简化为 $D=1/2$ 的扩散，并忽略漂移和分支。所有行走子都独立移动。\n- 将所有行走子初始化在 $\\mathbf{R}_0 = (x_0,y_0)$，其中 $x_0=1$ 和 $y_0=0$，以便所有行走子都从允许的半平面 $x>0$ 开始。\n- 对于 $x=0$ 处的吸收节点：如果一个提议的移动在单一步长内从 $x>0$ 跨入 $x\\le 0$，立即移除该行走子，并将其从后续步骤中排除。\n- 对于非吸收的对照运行：允许相同的移动提议，但从不移除行走子。\n\n每个测试用例需要计算的量：\n- 演化结束时存活的行走子数量 $N_{\\mathrm{surv}}$。\n- 位于禁区的存活者数量 $N_{\\mathrm{forb}} = \\#\\{ \\text{存活者 } i : x_i \\le 0\\}$。\n- 在吸收动力学下被移除的行走子数量 $N_{\\mathrm{kill}}$。\n- 尝试穿越的次数 $N_{\\mathrm{cross}}$，定义为提议的步数中 $x_t>0$ 且 $x_{t+1}\\le 0$ 的计数。对于非吸收的对照组，您仍然检测 $N_{\\mathrm{cross}}$ 但不移除行走子。\n\n每个测试用例需要输出的验证条件：\n- 带有中等时间步长的吸收边界：验证 $N_{\\mathrm{forb}}=0$。\n- 具有相同参数的非吸收对照组：验证 $N_{\\mathrm{forb}}>0$。\n- 带有大时间步长的吸收边界：验证 $N_{\\mathrm{forb}}=0$ 且 $N_{\\mathrm{surv}}<N_{\\mathrm{w}}$，其中 $N_{\\mathrm{w}}$ 是初始行走子数量。\n- $\\Delta \\tau=0$ 的吸收边界：验证 $N_{\\mathrm{forb}}=0$ 且 $N_{\\mathrm{surv}}=N_{\\mathrm{w}}$。\n\n单位：\n- 使用原子单位，因此 $D=1/2$，时间单位为哈特里能量的倒数。数值输出是无量纲的布尔值。\n\n测试套件：\n- 所有测试用例均使用 $D = 1/2$ 和初始位置 $(x_0,y_0)=(1,0)$。\n- 每个测试用例由一个元组 $(N_{\\mathrm{w}}, N_{\\mathrm{steps}}, \\Delta \\tau, D, \\text{absorbing}, \\text{seed})$ 指定：\n    - 测试 $1$：$(N_{\\mathrm{w}}=5000, N_{\\mathrm{steps}}=200, \\Delta \\tau=0.05, D=1/2, \\text{absorbing}=\\text{True}, \\text{seed}=2024)$。\n    - 测试 $2$：$(N_{\\mathrm{w}}=5000, N_{\\mathrm{steps}}=200, \\Delta \\tau=0.05, D=1/2, \\text{absorbing}=\\text{False}, \\text{seed}=2024)$。\n    - 测试 $3$：$(N_{\\mathrm{w}}=5000, N_{\\mathrm{steps}}=60, \\Delta \\tau=0.5, D=1/2, \\text{absorbing}=\\text{True}, \\text{seed}=2025)$。\n    - 测试 $4$：$(N_{\\mathrm{w}}=5000, N_{\\mathrm{steps}}=100, \\Delta \\tau=0, D=1/2, \\text{absorbing}=\\text{True}, \\text{seed}=2026)$。\n\n要求的程序行为：\n- 对于每个测试用例，根据上述规则模拟二维扩散。\n- 按顺序为每个用例计算上述的布尔验证：\n    - 测试 $1$：如果 $N_{\\mathrm{forb}}=0$ 则输出 $\\text{True}$，否则输出 $\\text{False}$。\n    - 测试 $2$：如果 $N_{\\mathrm{forb}}>0$ 则输出 $\\text{True}$，否则输出 $\\text{False}$。\n    - 测试 $3$：如果 $N_{\\mathrm{forb}}=0$ 且 $N_{\\mathrm{surv}}<N_{\\mathrm{w}}$ 则输出 $\\text{True}$，否则输出 $\\text{False}$。\n    - 测试 $4$：如果 $N_{\\mathrm{forb}}=0$ 且 $N_{\\mathrm{surv}}=N_{\\mathrm{w}}$ 则输出 $\\text{True}$，否则输出 $\\text{False}$。\n- 您的程序应该生成单行输出，其中包含按上述测试用例顺序列出的结果，格式为方括号括起来的逗号分隔列表（例如，“[True,True,False,True]”）。", "solution": "问题陈述已经过分析并被确定为有效。它具有科学依据，提法恰当，客观，并包含构建唯一、可验证解决方案所需的所有必要信息。该问题使用一个典型示例，正确地构建了固定节点扩散蒙特卡罗方法的基本演示。我们现在将进行正式的解答。\n\n该问题要求对自由粒子的扩散蒙特卡罗算法进行论证，并对固定节点边界条件进行数值演示。陈述组织如下：首先，建立从虚时间薛定谔方程到扩散方程的映射。其次，推导出行走子位置的离散时间更新规则。第三，解释了固定节点边界条件作为吸收壁垒的实现方式。最后，详细说明了数值验证的逻辑。\n\n波函数 $\\Psi(\\mathbf{R}, \\tau)$ 的虚时间薛定谔方程 (ITSE) 是\n$$\n-\\frac{\\partial \\Psi(\\mathbf{R}, \\tau)}{\\partial \\tau} = \\hat{H} \\Psi(\\mathbf{R}, \\tau)\n$$\n其中 $\\mathbf{R}$ 代表所有粒子的坐标，$\\tau$ 是虚时间，$\\hat{H}$ 是哈密顿算符。对于二维空间中质量为 $m$ 的单个自由粒子，$\\mathbf{R}=(x,y)$，在没有势的情况下，哈密顿量纯粹是动能：$\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2$。在原子单位中，$\\hbar=1$ 且电子质量 $m_e=1$。该问题指定了一个类似于电子的体系，因此我们设定 $m=1$。ITSE 因此变为：\n$$\n\\frac{\\partial \\Psi}{\\partial \\tau} = \\frac{1}{2}\\nabla^2\\Psi\n$$\n该方程在数学上与经典扩散方程相同：\n$$\n\\frac{\\partial \\phi}{\\partial t} = D \\nabla^2\\phi\n$$\n通过直接比较，波函数 $\\Psi$ 可以解释为浓度或概率密度 $\\phi$，虚时间 $\\tau$ 可以解释为实时间 $t$，并且扩散常数 $D$ 被确定为 $D = 1/2$。问题陈述我们应该忽略漂移和分支项，这些项会因非恒定势或使用重要性抽样试探函数而产生。在这里，我们模拟的是与自由粒子 ITSE 相对应的原始扩散过程，其中行走子的分布 $f(\\mathbf{R}, \\tau)$ 直接代表波函数 $\\Psi(\\mathbf{R}, \\tau)$。\n\n对于一个初始位置在 $\\mathbf{R}_t$ 的粒子，在小时间步长 $\\Delta \\tau$ 上的扩散方程的解可以使用其格林函数找到。在时间 $\\tau + \\Delta \\tau$ 时，在位置 $\\mathbf{R}_{t+1}$ 找到该粒子的概率由一个高斯分布给出：\n$$\nP(\\mathbf{R}_{t+1} | \\mathbf{R}_t) = \\frac{1}{4\\pi D \\Delta \\tau} \\exp\\left(-\\frac{|\\mathbf{R}_{t+1} - \\mathbf{R}_t|^2}{4D\\Delta\\tau}\\right)\n$$\n这意味着位移矢量 $\\mathbf{R}_{t+1} - \\mathbf{R}_t$ 是一个二维高斯随机变量。位移的每个分量 $\\Delta x$ 和 $\\Delta y$ 都是从均值为 $0$、方差为 $\\sigma^2 = 2D\\Delta\\tau$ 的正态分布中独立抽取的。可以通过取一个标准正态变量 $\\xi$（均值为 $0$，方差为 $1$）并将其乘以标准差 $\\sigma = \\sqrt{2D\\Delta\\tau}$ 来从此类分布中生成一个随机变量。\n因此，位置矢量 $\\mathbf{R}_t$ 在一个时间步长 $\\Delta \\tau$ 内的更新规则是：\n$$\n\\mathbf{R}_{t+1} = \\mathbf{R}_t + \\sqrt{2D\\Delta\\tau} \\, \\boldsymbol{\\xi}_t\n$$\n其中 $\\boldsymbol{\\xi}_t = (\\xi_x, \\xi_y)$ 是从标准正态分布中抽取的两个独立随机数组成的矢量。这证实了问题陈述中提供的随机更新方程。\n\n固定节点近似是解决量子蒙特卡罗中费米子符号问题的一种方法。它将模拟波函数 $\\Psi$ 的节面约束为与所选试探波函数 $\\psi_{\\mathrm{T}}$ 的节面相匹配。节面是波函数为零的点集。对于给定的试探函数 $\\psi_{\\mathrm{T}}(x,y) = x$，节面是平面 $x=0$。然后，模拟被限制在 $\\psi_{\\mathrm{T}}$ 符号恒定的一个区域内，例如区域 $x>0$。在节点上施加的边界条件是，对于所有时间 $\\tau$，都有 $\\Psi(x=0, y, \\tau) = 0$。在扩散过程的背景下，这种狄利克雷边界条件对应于一个完美的吸收边界。任何试图穿过此边界的行走子（代表我们系综中分布的一个点）都必须从模拟中移除。\n在离散时间模拟中，当一个位于位置 $\\mathbf{R}_t$（其中 $x_t > 0$）的行走子提议移动到 $\\mathbf{R}_{t+1}$（使得 $x_{t+1} \\le 0$）时，就发生了一次穿越事件。算法规则是检测到此类事件并立即移除该行走子。该行走子在任何后续时间步长中都不会对总体做出贡献。此过程确保了存活的行走子总体 $N_{\\mathrm{surv}}$ 始终位于允许的区域 $x>0$ 内。因此，根据构造，禁区内的存活行走子数量 $N_{\\mathrm{forb}}$ 必须为零，即 $N_{\\mathrm{forb}} = \\#\\{ \\text{存活者 } i : x_i \\le 0\\} = 0$。\n\n数值测试旨在验证以下这些属性：\n- 测试 $1$：在 $x=0$ 处设置吸收边界，并使用中等大小的时间步长 $\\Delta \\tau = 0.05$，行走子将会扩散。一些行走子会尝试穿越 $x=0$ 并被移除。吸收边界的核心原则要求没有存活的行走子能最终进入 $x \\le 0$ 区域。因此，我们必须验证 $N_{\\mathrm{forb}} = 0$。\n- 测试 $2$：这是一个对照实验。参数与测试 $1$ 相同，但关闭了吸收。行走子可以自由地穿过 $x=0$ 这条线。由于初始位置是 $(x_0, y_0)=(1,0)$ 且扩散是无偏的，因此在 $N_{\\mathrm{steps}}=200$ 步之后，统计上预期会有一部分行走子扩散到 $x \\le 0$ 区域。因此，我们必须验证 $N_{\\mathrm{forb}} > 0$。\n- 测试 $3$：此测试使用一个大的时间步长 $\\Delta \\tau = 0.5$。在 $x$ 方向上单步的标准差为 $\\sigma_x = \\sqrt{2D\\Delta\\tau} = \\sqrt{2(1/2)(0.5)} = \\sqrt{0.5} \\approx 0.707$。由于行走子从 $x_0=1$ 开始，一步之内很可能导致穿越。这将导致大量行走子被移除。我们必须验证两个条件：吸收边界仍然正常工作（$N_{\\mathrm{forb}}=0$），以及存活者的数量小于初始行走子的数量（$N_{\\mathrm{surv}} < N_{\\mathrm{w}}$）。\n- 测试 $4$：这是一个时间步长为 $\\Delta \\tau = 0$ 的健全性检查。每一步的位移为 $\\sqrt{2D\\Delta\\tau}\\,\\boldsymbol{\\xi}_t = 0$。在所有 $100$ 步中，所有行走子都停留在其初始位置 $(1,0)$。没有行走子移动，因此没有行走子能穿过边界。因此，没有行走子被移除，所有行走子都停留在 $x=1$ 处。我们必须验证 $N_{\\mathrm{forb}}=0$ 且 $N_{\\mathrm{surv}} = N_{\\mathrm{w}}$。\n\n所提供的参数和验证条件是合乎逻辑的，可作为对所实现的固定节点扩散算法的稳健测试。实现将直接遵循这些原则。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(n_w, n_steps, dt, D, absorbing, seed):\n    \"\"\"\n    Runs a 2D diffusion simulation with an optional absorbing boundary at x=0.\n    \"\"\"\n    np.random.seed(seed)\n\n    # All walkers start at (1.0, 0.0)\n    walkers = np.full((n_w, 2), [1.0, 0.0], dtype=np.float64)\n    is_alive = np.ones(n_w, dtype=bool)\n\n    n_kill = 0\n    n_cross = 0\n    \n    # Check for trivial case dt=0 to avoid unnecessary computation\n    if dt == 0:\n        n_surv = n_w\n        # No walkers moved, all are at x=1, so none are in the forbidden region\n        n_forb = 0\n        return n_surv, n_forb, n_kill, n_cross\n\n    step_std_dev = np.sqrt(2 * D * dt)\n\n    for _ in range(n_steps):\n        alive_indices = np.where(is_alive)[0]\n        n_alive_now = len(alive_indices)\n\n        if n_alive_now == 0:\n            break\n\n        # Generate displacements only for living walkers\n        displacements = np.random.standard_normal(size=(n_alive_now, 2)) * step_std_dev\n        \n        # Get old and new positions for currently alive walkers\n        old_positions = walkers[alive_indices]\n        new_positions = old_positions + displacements\n\n        # Detect any attempted crossings from the allowed region (x>0)\n        # to the forbidden region (x<=0).\n        # This check is performed for both absorbing and non-absorbing simulations\n        # to consistently count n_cross.\n        crossing_mask = (old_positions[:, 0] > 0) & (new_positions[:, 0] <= 0)\n        n_cross += np.sum(crossing_mask)\n\n        if absorbing:\n            # Identify which of the currently alive walkers crossed the boundary\n            walkers_to_kill_indices = alive_indices[crossing_mask]\n            if walkers_to_kill_indices.size > 0:\n                is_alive[walkers_to_kill_indices] = False\n                n_kill += len(walkers_to_kill_indices)\n        \n        # Update positions of all walkers that were alive at the start of the step.\n        # For killed walkers, their positions are updated but they will be\n        # ignored in subsequent steps because is_alive is now False.\n        walkers[alive_indices] = new_positions\n\n    n_surv = np.sum(is_alive)\n    \n    if n_surv > 0:\n        final_survivors_positions = walkers[is_alive]\n        # Count survivors in the forbidden zone x <= 0\n        n_forb = np.sum(final_survivors_positions[:, 0] <= 0)\n    else:\n        n_forb = 0\n\n    return n_surv, n_forb, n_kill, n_cross\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs simulations, and prints verification results.\n    \"\"\"\n    test_cases = [\n        # (N_w, N_steps, dt, D, absorbing, seed)\n        (5000, 200, 0.05, 0.5, True, 2024),\n        (5000, 200, 0.05, 0.5, False, 2024),\n        (5000, 60, 0.5, 0.5, True, 2025),\n        (5000, 100, 0.0, 0.5, True, 2026),\n    ]\n\n    results = []\n\n    # Test 1: Absorbing boundary, moderate time step\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[0]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb == 0)\n\n    # Test 2: Non-absorbing control\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[1]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb > 0)\n\n    # Test 3: Absorbing boundary, large time step\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[2]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb == 0 and n_surv < n_w)\n\n    # Test 4: Absorbing boundary, zero time step\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[3]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb == 0 and n_surv == n_w)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2885522"}, {"introduction": "固定节面扩散蒙特卡洛（FN-DMC）计算的精度完全取决于所选试探波函数节面的质量。这个高级实践将深入探讨能量对节面形貌的依赖关系。您将通过系统地改变一个简单的双费米子体系的节面形状，并使用有限差分法精确计算相应的固定节面能量，从而绘制出能量景观。这项实践不仅能让您掌握一种评估节面质量的数值方法，更能够直观地揭示节面优化的重要性，这是量子蒙特卡洛方法研究中的一个前沿领域。[@problem_id:2885514]", "problem": "考虑两个相同的自旋极化费米子，被限制在一维谐振子势阱中，其角频率为 $\\omega$。在原子单位制中，$\\hbar = 1$ 且 $m = 1$。在粒子坐标 $(x_1,x_2)$ 下，哈密顿量为\n$$\n\\hat{H} = -\\frac{1}{2}\\left(\\frac{\\partial^2}{\\partial x_1^2}+\\frac{\\partial^2}{\\partial x_2^2}\\right) + \\frac{1}{2}\\omega^2\\left(x_1^2 + x_2^2\\right).\n$$\n精确的费米子基态是反对称的，其精确节面位于 $x_1 - x_2 = 0$。在扩散蒙特卡洛（DMC）方法中使用的固定节面近似中，投影解被约束在指定的节面上为零。由此得到的固定节面基态能量 $E_{\\mathrm{FN}}$ 是哈密顿量 $\\hat{H}$ 在单个节面单元内的最低本征值，其中节面和计算域的外部边界均采用狄利克雷边界条件。\n\n你将通过定义一个函数的零水平集来研究一种简单的参数化节面形变，从而定义一族节面\n$$\ng_{\\theta,\\kappa}(x_1,x_2) \\equiv (x_1 - x_2) + \\theta\\,(x_1 + x_2) + \\kappa\\,\\frac{x_1^2 - x_2^2}{L},\n$$\n其中 $\\theta \\in \\mathbb{R}$ 和 $\\kappa \\in \\mathbb{R}$ 是小的形变参数，而 $L>0$ 是方形计算盒子的半宽度。节面由 $g_{\\theta,\\kappa}(x_1,x_2)=0$ 给出，计算域被限制在节面单元 $g_{\\theta,\\kappa}(x_1,x_2) > 0$ 内，狄利克雷边界条件同时施加在节面和外部盒子边界 $|x_1| \\le L$、$|x_2| \\le L$ 上。\n\n任务：编写一个程序，对于一组给定的 $(\\theta,\\kappa)$ 对，在 $[-L,L] \\times [-L,L]$ 区域上，使用每个坐标 $N$ 个点的均匀网格，构建哈密顿量的有限差分方法离散化；通过将计算限制在节面单元 $g_{\\theta,\\kappa} > 0$ 内，并在其边界和外部盒子上施加狄利克雷条件来强制执行固定节面约束；使用拉普拉斯算子的标准五点模板来构建得到的稀疏哈密顿矩阵；并计算最低本征值 $E_{\\mathrm{FN}}(\\theta,\\kappa)$。\n\n你必须使用的基本原理：\n- 不含时薛定谔方程 $\\hat{H}\\Psi = E\\Psi$，其中 $\\hat{H}$ 如上文所述。\n- 固定节面近似：在指定节面上施加狄利克雷边界条件的节面单元内的基态，即为该节面的固定节面能量。\n- 均匀网格上拉普拉斯算子的有限差分近似：对于网格间距 $h$，离散拉普拉斯算子近似为\n$$\n\\nabla^2 \\Psi(x_i,y_j) \\approx \\frac{\\Psi_{i+1,j} + \\Psi_{i-1,j} + \\Psi_{i,j+1} + \\Psi_{i,j-1} - 4\\Psi_{i,j}}{h^2}.\n$$\n\n实现要求：\n- 使用 $\\omega = 1$，因此能量单位为 $\\hbar\\omega$。\n- 使用半宽度为 $L = 4$ 的方形盒子和每个坐标有 $N = 41$ 个点的均匀网格。\n- 在节面单元 $g_{\\theta,\\kappa} > 0$ 内，通过忽略位于节面单元之外或盒子之外的邻居点，来构建同时在外部边界和节面上具有狄利克雷边界条件的稀疏哈密顿量；将这些缺失的邻居点视为固定为零（狄利克雷）。\n- 计算所得哈密顿矩阵的最小代数本征值，以获得 $E_{\\mathrm{FN}}(\\theta,\\kappa)$。\n- 所有能量必须以 $\\hbar\\omega$ 为单位报告，形式为十进制浮点数，并四舍五入到小数点后六位。\n\n灵敏度分析要求：\n- 在未形变节面 $(\\theta,\\kappa) = (0,0)$ 周围，通过构建 $2\\times 2$ 的海森矩阵来估计 $E_{\\mathrm{FN}}$ 的局部二次灵敏度。\n$$\nH = \\begin{pmatrix}\n\\frac{\\partial^2 E}{\\partial \\theta^2} & \\frac{\\partial^2 E}{\\partial \\theta \\partial \\kappa} \\\\\n\\frac{\\partial^2 E}{\\partial \\kappa \\partial \\theta} & \\frac{\\partial^2 E}{\\partial \\kappa^2}\n\\end{pmatrix}\\Bigg|_{(\\theta,\\kappa)=(0,0)}\n$$\n使用中心差分法，步长为 $\\delta_\\theta = 0.08$ 和 $\\delta_\\kappa = 0.10$：\n$$\n\\frac{\\partial^2 E}{\\partial \\theta^2} \\approx \\frac{E(\\delta_\\theta,0) - 2E(0,0) + E(-\\delta_\\theta,0)}{\\delta_\\theta^2},\n$$\n$$\n\\frac{\\partial^2 E}{\\partial \\kappa^2} \\approx \\frac{E(0,\\delta_\\kappa) - 2E(0,0) + E(0,-\\delta_\\kappa)}{\\delta_\\kappa^2},\n$$\n$$\n\\frac{\\partial^2 E}{\\partial \\theta \\partial \\kappa} \\approx \\frac{E(\\delta_\\theta,\\delta_\\kappa) - E(\\delta_\\theta,-\\delta_\\kappa) - E(-\\delta_\\theta,\\delta_\\kappa) + E(-\\delta_\\theta,-\\delta_\\kappa)}{4\\,\\delta_\\theta\\,\\delta_\\kappa}.\n$$\n报告 $H$ 的两个本征值，按从大到小排序。同时报告与最大本征值对应的单位本征向量的分量 $(v_\\theta, v_\\kappa)$，并使用约定 $v_\\theta \\ge 0$ 来消除符号不确定性。\n\n测试集：\n为以下 $(\\theta,\\kappa)$ 对计算 $E_{\\mathrm{FN}}(\\theta,\\kappa)$：\n- $(0.0, 0.0)$ [理想情况；精确节面]。\n- $(0.10, 0.00)$ 和 $(-0.10, 0.00)$ [小倾斜]。\n- $(0.00, 0.10)$ 和 $(0.00, -0.10)$ [小曲率]。\n- $(0.10, 0.10)$ 和 $(-0.10, 0.10)$ [组合小形变]。\n- $(0.35, 0.00)$ [较大倾斜边缘情况]。\n- $(0.00, 0.25)$ [较大曲率边缘情况]。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表。该列表必须按顺序包含：\n- 上述测试集 $(\\theta,\\kappa)$ 对的九个能量 $E_{\\mathrm{FN}}$，顺序完全一致。\n- 两个海森本征值（最大值在前）。\n- 与最大本征值对应的单位本征向量的两个分量 $(v_\\theta, v_\\kappa)$，其中 $v_\\theta \\ge 0$。\n\n所有数字必须是十进制浮点数，并四舍五入到小数点后六位。例如：\n\"[2.000000,2.010000, ... , 0.123456,0.012345,0.965926,0.258819]\".", "solution": "该问题要求计算在一维谐振子势阱中两个相同自旋极化费米子系统的固定节面基态能量 $E_{\\mathrm{FN}}$。计算必须针对节面的几种形变进行，然后对能量相对于形变参数进行灵敏度分析。\n\n该系统由原子单位制（$\\hbar = 1$, $m=1$）下的双粒子哈密顿量描述：\n$$\n\\hat{H} = -\\frac{1}{2}\\left(\\frac{\\partial^2}{\\partial x_1^2}+\\frac{\\partial^2}{\\partial x_2^2}\\right) + \\frac{1}{2}\\omega^2\\left(x_1^2 + x_2^2\\right)\n$$\n在指定的角频率 $\\omega=1$ 下，势能为 $V(x_1, x_2) = \\frac{1}{2}(x_1^2 + x_2^2)$。问题是在固定节面约束下求解不含时薛定谔方程 $\\hat{H}\\Psi(x_1, x_2) = E\\Psi(x_1, x_2)$。\n\n固定节面近似在指定的节面上施加狄利克雷边界条件 $\\Psi=0$。此处，节面由以下函数的零水平集定义：\n$$\ng_{\\theta,\\kappa}(x_1,x_2) = (x_1 - x_2) + \\theta(x_1 + x_2) + \\kappa\\,\\frac{x_1^2 - x_2^2}{L} = 0\n$$\n其中 $\\theta$ 和 $\\kappa$ 是形变参数。解在其中一个节面单元内寻找，特别是在 $g_{\\theta,\\kappa}(x_1,x_2) > 0$ 的区域。固定节面能量 $E_{\\mathrm{FN}}(\\theta, \\kappa)$ 是哈密顿量在该区域内的最低本征值。\n\n为了数值求解此问题，我们采用有限差分法。连续的二维空间 $(x_1, x_2)$ 在方形域 $[-L, L] \\times [-L, L]$ 上被离散化为一个均匀网格。给定每个维度 $N=41$ 个点和半宽度 $L=4$，网格间距为 $h = \\frac{2L}{N-1} = \\frac{8}{40} = 0.2$。网格点为 $(x_{1,i}, x_{2,j})$，其中对于 $i,j \\in \\{0, 1, \\dots, N-1\\}$，$x_{1,i} = -L + i \\cdot h$ 且 $x_{2,j} = -L + j \\cdot h$。\n\n拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x_1^2}+\\frac{\\partial^2}{\\partial x_2^2}$在每个网格点上使用标准的五点模板进行近似：\n$$\n\\nabla^2 \\Psi_{i,j} \\approx \\frac{\\Psi_{i+1,j} + \\Psi_{i-1,j} + \\Psi_{i,j+1} + \\Psi_{i,j-1} - 4\\Psi_{i,j}}{h^2}\n$$\n将此近似代入薛定谔方程，我们得到一个离散的本征值问题，可以表示为矩阵形式 $H_{\\text{matrix}} \\vec{\\Psi} = E \\vec{\\Psi}$。向量 $\\vec{\\Psi}$ 包含了位于指定节面单元内的网格点上的波函数值。\n\n哈密顿矩阵 $H_{\\text{matrix}}$ 的构建过程如下。首先，我们识别出所有满足 $g_{\\theta,\\kappa}(x_{1,i}, x_{2,j}) > 0$ 的“活动”网格点 $(i, j)$。假设这样的点有 $N_{\\text{active}}$ 个。我们创建一个从活动点的二维网格索引 $(i, j)$ 到一维索引 $p \\in \\{0, 1, \\dots, N_{\\text{active}}-1\\}$ 的映射。矩阵 $H_{\\text{matrix}}$ 的维度将是 $N_{\\text{active}} \\times N_{\\text{active}}$。\n\n$H_{\\text{matrix}}$ 的元素，记作 $H_{pq}$，由离散化的哈密顿量确定。对于与网格位置 $(i,j)$ 对应的给定活动点 $p$：\n对角元素 $H_{pp}$ 由下式给出：\n$$\nH_{pp} = -\\frac{1}{2h^2}(-4) + V(x_{1,i}, x_{2,j}) = \\frac{2}{h^2} + \\frac{1}{2}(x_{1,i}^2 + x_{2,j}^2)\n$$\n仅当点 $q$ 对应于网格上点 $p$ 的直接邻居时，非对角元素 $H_{pq}$ 才非零。如果点 $q$ 对应于 $(i, j)$ 的邻居 $(i', j')$，则该元素为：\n$$\nH_{pq} = -\\frac{1}{2h^2}\n$$\n对所有活动点都执行此构建过程。如果一个活动点的邻居不是活动点（即，它位于节面上或节面外，或者位于盒子边界 $|x_k| \\le L$ 之外），则它服从狄利克雷边界条件 $\\Psi=0$。因此，不会为这个邻居生成矩阵元素，从而正确地实现了边界条件。得到的矩阵是一个稀疏、实对称矩阵。\n\n固定节面能量 $E_{\\mathrm{FN}}(\\theta, \\kappa)$ 是该矩阵的最小代数本征值。我们使用一个数值本征求解器，特别是 `scipy.sparse.linalg.eigsh`，它被设计用于求解大型稀疏厄米矩阵，来找到这个最低本征值。\n\n整个过程被封装在一个函数中，该函数以 $(\\theta, \\kappa)$ 作为输入并返回 $E_{\\mathrm{FN}}$。然后使用该函数计算九个指定测试用例的能量。\n\n最后，我们通过在精确节面 $(\\theta, \\kappa) = (0, 0)$ 处计算能量的 $2 \\times 2$ 海森矩阵 $H$ 来执行局部灵敏度分析。二阶导数使用中心差分公式进行近似，步长为 $\\delta_\\theta = 0.08$ 和 $\\delta_\\kappa = 0.10$。\n对角元素为：\n$$\n\\frac{\\partial^2 E}{\\partial \\theta^2} \\approx \\frac{E(\\delta_\\theta,0) - 2E(0,0) + E(-\\delta_\\theta,0)}{\\delta_\\theta^2}\n$$\n$$\n\\frac{\\partial^2 E}{\\partial \\kappa^2} \\approx \\frac{E(0,\\delta_\\kappa) - 2E(0,0) + E(0,-\\delta_\\kappa)}{\\delta_\\kappa^2}\n$$\n混合偏导数为：\n$$\n\\frac{\\partial^2 E}{\\partial \\theta \\partial \\kappa} \\approx \\frac{E(\\delta_\\theta,\\delta_\\kappa) - E(\\delta_\\theta,-\\delta_\\kappa) - E(-\\delta_\\theta,\\delta_\\kappa) + E(-\\delta_\\theta,-\\delta_\\kappa)}{4\\,\\delta_\\theta\\,\\delta_\\kappa}\n$$\n为了计算这些导数，我们需要评估 $(0,0)$ 周围九个点的能量。组装海森矩阵 $H$ 后，我们计算其本征值和与最大本征值对应的本征向量。本征值按降序排序，本征向量 $(v_\\theta, v_\\kappa)$ 被归一化，并根据约定 $v_\\theta \\ge 0$ 来固定其符号。这些结果量化了能量如何随节面的小形变而变化。海森矩阵的最大本征值指出了在 $(\\theta, \\kappa)$ 空间中能量对节面形变最敏感的方向。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import eigsh\n\n# Define global parameters for the simulation\nL = 4.0\nN = 41\nOMEGA = 1.0\n\n# Define Hessian calculation parameters\nD_THETA = 0.08\nD_KAPPA = 0.10\n\ndef compute_energy(theta, kappa, memo):\n    \"\"\"\n    Computes the fixed-node ground state energy for given nodal parameters.\n    It uses a finite-difference discretization of the Hamiltonian.\n    \"\"\"\n    # Check cache first to avoid re-computation\n    if (theta, kappa) in memo:\n        return memo[(theta, kappa)]\n\n    h = 2 * L / (N - 1)\n    coords = np.linspace(-L, L, N)\n    x1_grid, x2_grid = np.meshgrid(coords, coords, indexing='ij')\n\n    # Define the nodal surface function and identify the nodal cell\n    g_val = (x1_grid - x2_grid) + theta * (x1_grid + x2_grid) + kappa * (x1_grid**2 - x2_grid**2) / L\n    \n    # Identify active grid points inside the nodal cell (g > 0)\n    active_mask = g_val > 0\n    num_active = np.sum(active_mask)\n\n    if num_active == 0:\n        return np.inf  # No valid region\n\n    # Create a map from 2D grid indices to 1D sparse matrix indices\n    map_2d_to_1d = -np.ones((N, N), dtype=int)\n    map_2d_to_1d[active_mask] = np.arange(num_active)\n\n    # Assemble the Hamiltonian matrix using a list-of-lists sparse format\n    H_matrix = lil_matrix((num_active, num_active), dtype=np.float64)\n    \n    # Constants from the finite-difference stencil for the kinetic operator\n    T_diag = 2.0 / h**2\n    T_off_diag = -0.5 / h**2\n\n    active_indices = np.argwhere(active_mask)\n\n    for p, (i, j) in enumerate(active_indices):\n        # Diagonal part: Kinetic + Potential\n        x1 = coords[i]\n        x2 = coords[j]\n        potential = 0.5 * OMEGA**2 * (x1**2 + x2**2)\n        H_matrix[p, p] = T_diag + potential\n\n        # Off-diagonal part: Kinetic (coupling to neighbors)\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n\n            # Check if neighbor is within grid bounds AND is an active point\n            if 0 <= ni < N and 0 <= nj < N and active_mask[ni, nj]:\n                q = map_2d_to_1d[ni, nj]\n                H_matrix[p, q] = T_off_diag\n    \n    # Convert to CSC format for efficient eigenvalue computation\n    H_csc = H_matrix.tocsc()\n\n    # Find the smallest algebraic eigenvalue\n    eigenvalues, _ = eigsh(H_csc, k=1, which='SA')\n    \n    # Cache and return the result\n    result = eigenvalues[0]\n    memo[(theta, kappa)] = result\n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite, perform the Hessian analysis,\n    and print the final formatted output.\n    \"\"\"\n    test_cases = [\n        (0.0, 0.0),\n        (0.10, 0.00), (-0.10, 0.00),\n        (0.00, 0.10), (0.00, -0.10),\n        (0.10, 0.10), (-0.10, 0.10),\n        (0.35, 0.00),\n        (0.00, 0.25)\n    ]\n\n    memo = {}  # Memoization cache for energy calculations\n    energies = [compute_energy(theta, kappa, memo) for theta, kappa in test_cases]\n    \n    # Points needed for Hessian calculation\n    e_00 = memo.get((0.0, 0.0))\n    \n    e_pt_0 = compute_energy(D_THETA, 0.0, memo)\n    e_nt_0 = compute_energy(-D_THETA, 0.0, memo)\n    \n    e_0_pk = compute_energy(0.0, D_KAPPA, memo)\n    e_0_nk = compute_energy(0.0, -D_KAPPA, memo)\n\n    e_pt_pk = compute_energy(D_THETA, D_KAPPA, memo)\n    e_pt_nk = compute_energy(D_THETA, -D_KAPPA, memo)\n    e_nt_pk = compute_energy(-D_THETA, D_KAPPA, memo)\n    e_nt_nk = compute_energy(-D_THETA, -D_KAPPA, memo)\n    \n    # Calculate Hessian components using centered finite differences\n    H11 = (e_pt_0 - 2 * e_00 + e_nt_0) / (D_THETA**2)\n    H22 = (e_0_pk - 2 * e_00 + e_0_nk) / (D_KAPPA**2)\n    H12 = (e_pt_pk - e_pt_nk - e_nt_pk + e_nt_nk) / (4 * D_THETA * D_KAPPA)\n\n    Hessian = np.array([[H11, H12], [H12, H22]])\n    \n    # np.linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n    hess_eigvals, hess_eigvecs = np.linalg.eigh(Hessian)\n\n    # Sort eigenvalues largest to smallest\n    sorted_hess_eigvals = hess_eigvals[::-1]\n    \n    # Eigenvector for the largest eigenvalue is the last column\n    eigvec_largest = hess_eigvecs[:, 1]\n    \n    v_theta, v_kappa = eigvec_largest\n    \n    # Enforce sign convention v_theta >= 0\n    if v_theta < 0:\n        v_theta *= -1\n        v_kappa *= -1\n    \n    # Assemble all results for printing\n    all_results = energies + list(sorted_hess_eigvals) + [v_theta, v_kappa]\n\n    # Format the final output string as required\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2885514"}]}