{"hands_on_practices": [{"introduction": "将量子化学问题转化为量子计算机能够处理的形式，是应用量子算法的第一步。本练习将引导你完成这一关键的转换过程：从给定的电子哈密顿量出发，通过Jordan-Wigner变换，为简单的氢分子模型构建其对应的量子比特哈密顿量。通过这个实践，你将具体地理解化学积分如何映射为泡利算符的线性组合，从而为更复杂的算法打下坚实基础。[@problem_id:2917703]", "id": "2917703", "problem": "考虑二氢分子 $\\mathrm{H}_2$，使用一个最小基组，该基组包含两个空间分子轨道，即成键轨道 $g$ 和反键轨道 $u$。在自旋轨道基中进行计算，其顺序为 $0 \\equiv g\\alpha$，$1 \\equiv g\\beta$，$2 \\equiv u\\alpha$，$3 \\equiv u\\beta$。假设给定以下数据，并且分子轨道是正则的，因此单电子积分在此基中是对角的。\n\n1. 核排斥能：$E_{\\mathrm{N}}$ (Hartree)。\n2. 单电子积分：$h_{00} = h_{11} = \\varepsilon_{g}$，$h_{22} = h_{33} = \\varepsilon_{u}$，且当 $p \\neq q$ 时，$h_{pq} = 0$。\n3. 唯一非零的反对称化双电子积分 $\\langle pq \\| rs \\rangle$ (均以 Hartree 为单位) 是那些满足 $p=r$ 和 $q=s$ 的积分，其不同值如下：\n   - $\\langle 0\\,1 \\| 0\\,1 \\rangle = J_{gg}$，\n   - $\\langle 2\\,3 \\| 2\\,3 \\rangle = J_{uu}$，\n   - $\\langle 0\\,2 \\| 0\\,2 \\rangle = \\langle 1\\,3 \\| 1\\,3 \\rangle = J_{gu} - K_{gu}$，\n   - $\\langle 0\\,3 \\| 0\\,3 \\rangle = \\langle 1\\,2 \\| 1\\,2 \\rangle = J_{gu}$。\n\n从第二量子化电子哈密顿量出发，使用 Jordan–Wigner 变换（量子比特 $i$ 编码自旋轨道 $i$，顺序如上），构建显式的 4 量子比特哈密顿量，形式为泡利算符张量积的线性组合。列举出所有出现的不同泡利串，并用 $E_{\\mathrm{N}}$、$\\varepsilon_{g}$、$\\varepsilon_{u}$、$J_{gg}$、$J_{uu}$、$J_{gu}$ 和 $K_{gu}$ 符号化地给出它们的系数。所有能量系数均以 Hartree 为单位表示。您的最终答案必须是作用于给定顺序的四个量子比特上的、写成泡利串线性组合的量子比特哈密顿量的单个闭式解析表达式。不要代入数值，也不要利用对称性减少量子比特的数量。", "solution": "该问题要求为最小基组中的 $\\mathrm{H}_2$ 分子构建一个 4 量子比特哈密顿量，其出发点是第二量子化电子哈密顿量，并使用 Jordan-Wigner 变换。\n\n首先，对问题陈述进行验证。\n已知条件：\n1.  系统：$\\mathrm{H}_2$ 分子，由两个空间分子轨道（成键轨道 $g$ 和反键轨道 $u$）构成的最小基组。\n2.  自旋轨道基：四个自旋轨道，索引为 $0, 1, 2, 3$，分别对应 $g\\alpha, g\\beta, u\\alpha, u\\beta$。\n3.  核排斥能：$E_{\\mathrm{N}}$。\n4.  单电子积分：$h_{00} = h_{11} = \\varepsilon_{g}$，$h_{22} = h_{33} = \\varepsilon_{u}$，且当 $p \\neq q$ 时，$h_{pq} = 0$。\n5.  双电子积分：唯一非零的反对称化积分 $\\langle pq \\| rs \\rangle$ 是那些满足 $p=r$ 和 $q=s$ 的积分。给出的具体非零值如下：\n    $\\langle 0\\,1 \\| 0\\,1 \\rangle = J_{gg}$\n    $\\langle 2\\,3 \\| 2\\,3 \\rangle = J_{uu}$\n    $\\langle 0\\,2 \\| 0\\,2 \\rangle = \\langle 1\\,3 \\| 1\\,3 \\rangle = J_{gu} - K_{gu}$\n    $\\langle 0\\,3 \\| 0\\,3 \\rangle = \\langle 1\\,2 \\| 1\\,2 \\rangle = J_{gu}$\n\n验证结论：\n该问题具有科学依据，提法明确且客观。它提供了一套完整的符号参数，用于为量子化学中的一个标准模型系统构建哈密顿量。关键的简化在于对双电子积分的约束。“唯一非零的反对称化双电子积分 $\\langle pq \\| rs \\rangle$ 是那些满足 $p=r$ 和 $q=s$ 的积分”这一字面解释严重限制了双电子算符的形式。这是一个很强但语法清晰的前提。因此，该问题被认为是**有效的**，可以基于此前提构建解答。\n\n第二量子化中的电子哈密顿量由下式给出\n$$ \\hat{H} = E_{\\mathrm{N}} + \\sum_{p,q} h_{pq} \\hat{a}_p^\\dagger \\hat{a}_q + \\frac{1}{4} \\sum_{p,q,r,s} \\langle pq \\| rs \\rangle \\hat{a}_p^\\dagger \\hat{a}_q^\\dagger \\hat{a}_s \\hat{a}_r $$\n其中 $\\hat{a}_p^\\dagger$ 和 $\\hat{a}_p$ 分别是自旋轨道 $p$ 的费米子产生和湮灭算符。\n\n由于 $h_{pq}$ 的对角性，单电子项得以简化：\n$$ \\hat{H}^{(1)} = \\sum_{p} h_{pp} \\hat{a}_p^\\dagger \\hat{a}_p = \\sum_{p} \\varepsilon_p \\hat{n}_p = \\varepsilon_g(\\hat{n}_0 + \\hat{n}_1) + \\varepsilon_u(\\hat{n}_2 + \\hat{n}_3) $$\n其中 $\\hat{n}_p = \\hat{a}_p^\\dagger \\hat{a}_p$ 是自旋轨道 $p$ 的数算符。\n\n对于双电子项，问题陈述指出非零积分 $\\langle pq \\| rs \\rangle$ 仅在 $p=r$ 和 $q=s$ 时存在。求和变为：\n$$ \\hat{H}^{(2)} = \\frac{1}{4} \\sum_{p, q} \\langle pq \\| pq \\rangle \\hat{a}_p^\\dagger \\hat{a}_q^\\dagger \\hat{a}_q \\hat{a}_p $$\n我们必须考虑索引的排列。对 $p$ 和 $q$ 的完整求和包括了 $(p,q)$ 和 $(q,p)$ 的项。\n$$ \\hat{H}^{(2)} = \\frac{1}{4} \\sum_{p<q} \\left( \\langle pq \\| pq \\rangle \\hat{a}_p^\\dagger \\hat{a}_q^\\dagger \\hat{a}_q \\hat{a}_p + \\langle qp \\| qp \\rangle \\hat{a}_q^\\dagger \\hat{a}_p^\\dagger \\hat{a}_p \\hat{a}_q + \\langle pq \\| qp \\rangle \\hat{a}_p^\\dagger \\hat{a}_q^\\dagger \\hat{a}_p \\hat{a}_q + \\langle qp \\| pq \\rangle \\hat{a}_q^\\dagger \\hat{a}_p^\\dagger \\hat{a}_q \\hat{a}_p \\right) $$\n利用反对称性 $\\langle pq \\| rs \\rangle = -\\langle qp \\| rs \\rangle = -\\langle pq \\| sr \\rangle = \\langle qp \\| sr \\rangle$，我们有 $\\langle qp \\| qp \\rangle = \\langle pq \\| pq \\rangle$ 和 $\\langle pq \\| qp \\rangle = \\langle qp \\| pq \\rangle = -\\langle pq \\| pq \\rangle$。算符为 $\\hat{a}_p^\\dagger \\hat{a}_q^\\dagger \\hat{a}_q \\hat{a}_p = \\hat{n}_p \\hat{n}_q$ 和 $\\hat{a}_p^\\dagger \\hat{a}_q^\\dagger \\hat{a}_p \\hat{a}_q = -\\hat{a}_p^\\dagger \\hat{a}_p \\hat{a}_q^\\dagger \\hat{a}_q = -\\hat{n}_p\\hat{n}_q$（当 $p \\neq q$ 时）。\n对于一对 $(p,q)$ 的项变为：\n$$ \\frac{1}{4} \\langle pq \\| pq \\rangle \\left( \\hat{n}_p \\hat{n}_q + \\hat{n}_q \\hat{n}_p - (-\\hat{n}_p \\hat{n}_q) - (-\\hat{n}_q \\hat{n}_p) \\right) = \\frac{1}{4} \\langle pq \\| pq \\rangle (4 \\hat{n}_p \\hat{n}_q) = \\langle pq \\| pq \\rangle \\hat{n}_p \\hat{n}_q $$\n因此，双电子哈密顿量简化为对所有对的求和：\n$$ \\hat{H}^{(2)} = \\sum_{p<q} \\langle pq \\| pq \\rangle \\hat{n}_p \\hat{n}_q $$\n代入给定的积分值：\n$$ \\hat{H}^{(2)} = J_{gg}\\hat{n}_0\\hat{n}_1 + J_{uu}\\hat{n}_2\\hat{n}_3 + (J_{gu}-K_{gu})(\\hat{n}_0\\hat{n}_2 + \\hat{n}_1\\hat{n}_3) + J_{gu}(\\hat{n}_0\\hat{n}_3 + \\hat{n}_1\\hat{n}_2) $$\n第二量子化中的总哈密顿量为：\n$$ \\hat{H} = E_{\\mathrm{N}} + \\varepsilon_g(\\hat{n}_0+\\hat{n}_1) + \\varepsilon_u(\\hat{n}_2+\\hat{n}_3) + J_{gg}\\hat{n}_0\\hat{n}_1 + J_{uu}\\hat{n}_2\\hat{n}_3 + (J_{gu}-K_{gu})(\\hat{n}_0\\hat{n}_2 + \\hat{n}_1\\hat{n}_3) + J_{gu}(\\hat{n}_0\\hat{n}_3 + \\hat{n}_1\\hat{n}_2) $$\n接下来，我们应用 Jordan-Wigner 变换。对于一个量子比特寄存器，其中量子比特 $j$ 编码自旋轨道 $j$，数算符变换如下：\n$$ \\hat{n}_j = \\frac{1}{2}(I_j - Z_j) $$\n其中 $I_j$是单位算符，$Z_j$是作用于量子比特 $j$ 上的泡利-Z 算符。我们将此代入哈密顿量并展开。为清晰起见，张量积符号 $\\otimes$ 和作用于其他量子比特上的单位算符被省略（例如，$Z_0$ 意味着 $Z_0 \\otimes I_1 \\otimes I_2 \\otimes I_3$）。\n\n单电子部分变为：\n$$ \\hat{H}^{(1)} = \\varepsilon_g\\left(\\frac{I-Z_0}{2} + \\frac{I-Z_1}{2}\\right) + \\varepsilon_u\\left(\\frac{I-Z_2}{2} + \\frac{I-Z_3}{2}\\right) = (\\varepsilon_g + \\varepsilon_u)I - \\frac{\\varepsilon_g}{2}(Z_0+Z_1) - \\frac{\\varepsilon_u}{2}(Z_2+Z_3) $$\n双电子部分包含数算符的乘积：\n$$ \\hat{n}_p\\hat{n}_q = \\frac{1}{4}(I - Z_p)(I - Z_q) = \\frac{1}{4}(I - Z_p - Z_q + Z_p Z_q) $$\n将此代入 $\\hat{H}^{(2)}$ 中的每一项，并对每个泡利串的所有贡献求和：\n\n1.  **常数项 ($I$):**\n    来自 $E_{\\mathrm{N}}$：$E_{\\mathrm{N}}$\n    来自 $\\hat{H}^{(1)}$：$\\varepsilon_g + \\varepsilon_u$\n    来自 $\\hat{H}^{(2)}$：$\\frac{1}{4}J_{gg} + \\frac{1}{4}J_{uu} + \\frac{1}{4}(J_{gu}-K_{gu})\\times 2 + \\frac{1}{4}J_{gu}\\times 2 = \\frac{1}{4}(J_{gg} + J_{uu} + 4J_{gu} - 2K_{gu})$\n    总常数项 $c_I = E_{\\mathrm{N}} + \\varepsilon_g + \\varepsilon_u + \\frac{1}{4}(J_{gg} + J_{uu} + 4J_{gu} - 2K_{gu})$。\n\n2.  **单-Z 项 ($Z_j$):**\n    - $Z_0$: 来自 $\\hat{H}^{(1)}$：$-\\frac{\\varepsilon_g}{2}$。来自 $\\hat{H}^{(2)}$ 中涉及 $n_0$ 的项：$-\\frac{1}{4}J_{gg} - \\frac{1}{4}(J_{gu}-K_{gu}) - \\frac{1}{4}J_{gu}$。\n      系数 $c_0 = -\\frac{\\varepsilon_g}{2} - \\frac{1}{4}(J_{gg} + 2J_{gu} - K_{gu})$。\n    - $Z_1$: 通过与 $Z_0$ 的对称性可知，$c_1 = -\\frac{\\varepsilon_g}{2} - \\frac{1}{4}(J_{gg} + 2J_{gu} - K_{gu})$。\n    - $Z_2$: 来自 $\\hat{H}^{(1)}$：$-\\frac{\\varepsilon_u}{2}$。来自 $\\hat{H}^{(2)}$ 中涉及 $n_2$ 的项：$-\\frac{1}{4}J_{uu} - \\frac{1}{4}(J_{gu}-K_{gu}) - \\frac{1}{4}J_{gu}$。\n      系数 $c_2 = -\\frac{\\varepsilon_u}{2} - \\frac{1}{4}(J_{uu} + 2J_{gu} - K_{gu})$。\n    - $Z_3$: 通过与 $Z_2$ 的对称性可知，$c_3 = -\\frac{\\varepsilon_u}{2} - \\frac{1}{4}(J_{uu} + 2J_{gu} - K_{gu})$。\n\n3.  **双-Z 项 ($Z_p Z_q$):**\n    $Z_p Z_q$ 的系数是相应 $\\hat{n}_p\\hat{n}_q$ 项系数的 $\\frac{1}{4}$。\n    - $Z_0 Z_1$: $c_{01} = \\frac{1}{4}J_{gg}$。\n    - $Z_2 Z_3$: $c_{23} = \\frac{1}{4}J_{uu}$。\n    - $Z_0 Z_2$: $c_{02} = \\frac{1}{4}(J_{gu}-K_{gu})$。\n    - $Z_1 Z_3$: $c_{13} = \\frac{1}{4}(J_{gu}-K_{gu})$。\n    - $Z_0 Z_3$: $c_{03} = \\frac{1}{4}J_{gu}$。\n    - $Z_1 Z_2$: $c_{12} = \\frac{1}{4}J_{gu}$。\n\n没有出现其他泡利串（例如，涉及 X 或 Y 的），因为在这个简化模型中，哈密顿量在 Fock 基中是对角的。\n\n最终的量子比特哈密顿量是所有泡利串乘以其导出系数的总和：\n$$ \\hat{H} = c_I I + c_0 Z_0 + c_1 Z_1 + c_2 Z_2 + c_3 Z_3 + c_{01}Z_0Z_1 + c_{23}Z_2Z_3 + c_{02}Z_0Z_2 + c_{13}Z_1Z_3 + c_{03}Z_0Z_3 + c_{12}Z_1Z_2 $$\n代入符号系数即可得到完整的表达式。", "answer": "$$\n\\boxed{\n\\begin{aligned}\n\\hat{H} = & \\left(E_{\\mathrm{N}} + \\varepsilon_g + \\varepsilon_u + \\frac{1}{4}(J_{gg} + J_{uu} + 4J_{gu} - 2K_{gu})\\right) I \\\\\n& - \\left(\\frac{\\varepsilon_g}{2} + \\frac{1}{4}(J_{gg} + 2J_{gu} - K_{gu})\\right) (Z_0 + Z_1) \\\\\n& - \\left(\\frac{\\varepsilon_u}{2} + \\frac{1}{4}(J_{uu} + 2J_{gu} - K_{gu})\\right) (Z_2 + Z_3) \\\\\n& + \\frac{1}{4}J_{gg} Z_0 Z_1 + \\frac{1}{4}J_{uu} Z_2 Z_3 + \\frac{1}{4}(J_{gu}-K_{gu}) (Z_0 Z_2 + Z_1 Z_3) + \\frac{1}{4}J_{gu} (Z_0 Z_3 + Z_1 Z_2)\n\\end{aligned}\n}\n$$"}, {"introduction": "在拥有了量子比特哈密顿量之后，我们如何在近期量子设备上求解其基态能量？变分量子求解器（VQE）是一种主要方法，但其精度受到实际资源的限制。本练习模拟了一个真实世界中的优化挑战：如何在有限的测量次数（统计误差）和有限的 ansatz 线路深度（系统误差）之间进行权衡，从而以最小的计算代价达到目标精度。这个练习将培养你在设计实用量子算法时进行资源优化的关键能力。[@problem_id:2917691]", "id": "2917691", "problem": "变分量子特征求解器 (VQE) 通过在参数化量子线路上对泡利算符的期望值进行采样，来估计分子电子哈密顿量的基态能量。考虑一个VQE实现，其中两种独立的误差来源主导了最终的能量误差：有限采样（测量）误差和拟设截断误差。假设存在以下具有物理动机的模型。\n\n1. 测量误差：如果在所有算符组中，（经过任何经典后处理和测量分组后）总共执行了 $N$ 次独立的线路执行（shots），则能量估计量的标准差按 $\\epsilon_{m} = \\kappa / \\sqrt{N}$ 的关系进行缩放，其中 $\\kappa$ 汇总了哈密顿量的有效分组后方差。取 $\\kappa = 5.0 \\times 10^{-2}$ Hartree$\\cdot\\sqrt{\\text{shot}}$。\n\n2. 拟设截断误差：对于一个在 $r$ 层（视为连续正变量）后截断的算符池或分层激发拟设，假设系统能量偏差按 $\\epsilon_{t}(r) = \\alpha \\exp(-\\beta r)$ 指数级衰减，其中 $\\alpha = 1.0 \\times 10^{-1}$ Hartree，$\\beta = 5.0 \\times 10^{-1}$ 每层。\n\n3. 资源模型：每次线路执行的双量子比特门数随拟设深度 $r$ 线性增长，关系为 $g(r) = g_{0} + g_{1} r$，其中 $g_{0} = 2.0 \\times 10^{2}$，$g_{1} = 4.0 \\times 10^{1}$。所需的总双量子比特门执行次数为 $C = N \\, g(r)$。\n\n您的目标是在 $\\epsilon_{m}$ 和 $\\epsilon_{t}$ 之间分配误差预算，以保证总能量误差满足 $\\epsilon_{m} + \\epsilon_{t} \\le E_{\\text{tol}}$，同时使 $C$ 最小化，其中容差为 $E_{\\text{tol}} = 1$ 毫哈特里 $= 1.0 \\times 10^{-3}$ Hartree。在优化过程中，对 $r$ 和 $N$ 使用连续近似，但使用给定的参数计算最终的实值 $C$。\n\n从基本统计缩放关系 $\\epsilon_{m} = \\kappa / \\sqrt{N}$ 和指数截断模型 $\\epsilon_{t}(r) = \\alpha \\exp(-\\beta r)$ 出发，并且不引入任何未提供的额外公式，确定满足 $\\epsilon_{m} + \\epsilon_{t} \\le E_{\\text{tol}}$ 的最小可实现总双量子比特门执行次数 $C_{\\min}$。\n\n将您关于 $C_{\\min}$ 的最终答案四舍五入到三位有效数字。将最终结果表示为一个纯数（即双量子比特门执行的次数）。最终答案中不需要其他任何量。", "solution": "所提出的问题是一个约束优化任务。我们需要在总能量误差的约束下，找到总双量子比特门执行次数 $C$ 的最小值。在变分量子算法的资源估算背景下，该问题是适定的且具有科学依据。\n\n需要最小化的目标函数是总双量子比特门数 $C$：\n$$C(N, r) = N \\cdot g(r) = N (g_{0} + g_{1} r)$$\n其中 $N$ 是总测量次数（shots），$r$ 是拟设层数。\n\n最小化受到一个约束条件的限制，即测量误差 $\\epsilon_{m}$ 和拟设截断误差 $\\epsilon_{t}$ 的总和不超过指定的容差 $E_{\\text{tol}}$。成本函数 $C(N, r)$ 对于 $r > 0$ 是 $N$ 和 $r$ 的单调递增函数。因此，当误差约束被激活时，即总误差恰好等于容差时，将实现最小成本：\n$$\\epsilon_{m} + \\epsilon_{t} = E_{\\text{tol}}$$\n将给定的误差项模型代入，约束条件变为：\n$$\\frac{\\kappa}{\\sqrt{N}} + \\alpha \\exp(-\\beta r) = E_{\\text{tol}}$$\n\n这是一个在约束条件 $\\Phi(N, r) = \\frac{\\kappa}{\\sqrt{N}} + \\alpha \\exp(-\\beta r) - E_{\\text{tol}} = 0$下最小化$C(N, r)$的问题。我们将使用拉格朗日乘子法。拉格朗日量 $\\mathcal{L}$ 定义为：\n$$\\mathcal{L}(N, r, \\lambda) = C(N, r) - \\lambda \\Phi(N, r)$$\n$$\\mathcal{L}(N, r, \\lambda) = N(g_{0} + g_{1} r) - \\lambda \\left( \\frac{\\kappa}{\\sqrt{N}} + \\alpha \\exp(-\\beta r) - E_{\\text{tol}} \\right)$$\n\n为了找到极值，我们将 $\\mathcal{L}$ 对 $N$、$r$ 和 $\\lambda$ 的偏导数设为零。\n关于 $N$ 的偏导数为：\n$$\\frac{\\partial \\mathcal{L}}{\\partial N} = (g_{0} + g_{1} r) - \\lambda \\left(-\\frac{1}{2}\\kappa N^{-3/2}\\right) = g(r) + \\frac{\\lambda \\kappa}{2 N^{3/2}} = 0 \\quad (1)$$\n关于 $r$ 的偏导数为：\n$$\\frac{\\partial \\mathcal{L}}{\\partial r} = N g_{1} - \\lambda \\left(-\\alpha \\beta \\exp(-\\beta r)\\right) = N g_{1} + \\lambda \\alpha \\beta \\exp(-\\beta r) = 0 \\quad (2)$$\n关于 $\\lambda$ 的偏导数恢复了约束方程。\n\n从方程（1），我们求解拉格朗日乘子 $\\lambda$：\n$$\\lambda = -\\frac{2 N^{3/2} g(r)}{\\kappa}$$\n从方程（2），我们也求解 $\\lambda$：\n$$\\lambda = -\\frac{N g_{1}}{\\alpha \\beta \\exp(-\\beta r)}$$\n\n将这两个关于 $\\lambda$ 的表达式相等，得到最优性条件：\n$$-\\frac{2 N^{3/2} g(r)}{\\kappa} = -\\frac{N g_{1}}{\\alpha \\beta \\exp(-\\beta r)}$$\n$$\\frac{2 \\sqrt{N} g(r)}{\\kappa} = \\frac{g_{1}}{\\alpha \\beta \\exp(-\\beta r)}$$\n我们识别出误差项 $\\epsilon_{m} = \\kappa/\\sqrt{N}$ 和 $\\epsilon_{t} = \\alpha \\exp(-\\beta r)$。将它们代入最优性条件，得出了误差贡献和资源成本之间的简洁关系：\n$$\\frac{2 g(r)}{\\epsilon_{m}} = \\frac{g_{1}}{\\beta \\epsilon_{t}} \\quad \\implies \\quad 2 \\beta g(r) \\epsilon_{t} = g_{1} \\epsilon_{m}$$\n该方程给出了总误差预算 $E_{\\text{tol}}$ 在测量误差和截断误差之间的最优划分。\n\n我们现在有一个关于最优误差值 $\\epsilon_{m}^*$ 和 $\\epsilon_{t}^*$ 的双方程系统：\n$$1) \\quad \\epsilon_{m}^* + \\epsilon_{t}^* = E_{\\text{tol}}$$\n$$2) \\quad 2 \\beta \\left(g_{0} + g_{1} r^*\\right) \\epsilon_{t}^* = g_{1} \\epsilon_{m}^*$$\n最优深度 $r^*$ 本身是 $\\epsilon_{t}^*$ 的函数，通过关系 $\\epsilon_{t}^* = \\alpha \\exp(-\\beta r^*)$，这意味着 $r^* = \\frac{1}{\\beta} \\ln\\left(\\frac{\\alpha}{\\epsilon_{t}^*}\\right)$。将此代入第二个方程：\n$$2 \\beta \\left(g_{0} + \\frac{g_{1}}{\\beta} \\ln\\left(\\frac{\\alpha}{\\epsilon_{t}^*}\\right)\\right) \\epsilon_{t}^* = g_{1} \\left(E_{\\text{tol}} - \\epsilon_{t}^*\\right)$$\n$$2 \\beta g_{0} \\epsilon_{t}^* + 2 g_{1} \\epsilon_{t}^* \\ln\\left(\\frac{\\alpha}{\\epsilon_{t}^*}\\right) = g_{1} E_{\\text{tol}} - g_{1} \\epsilon_{t}^*$$\n整理各项，我们得到一个关于最优截断误差 $\\epsilon_{t}^*$ 的单一超越方程：\n$$\\left(2 \\beta g_{0} + g_{1}\\right) \\epsilon_{t}^* + 2 g_{1} \\epsilon_{t}^* \\left(\\ln(\\alpha) - \\ln(\\epsilon_{t}^*)\\right) = g_{1} E_{\\text{tol}}$$\n$$\\epsilon_{t}^* \\left[ (2 \\beta g_{0} + g_{1} + 2 g_{1} \\ln \\alpha) - 2 g_{1} \\ln \\epsilon_{t}^* \\right] = g_{1} E_{\\text{tol}}$$\n\n现在，我们代入给定的数值：\n$\\alpha = 1.0 \\times 10^{-1}$ Hartree\n$\\beta = 5.0 \\times 10^{-1}$ 每层\n$g_{0} = 2.0 \\times 10^{2}$\n$g_{1} = 4.0 \\times 10^{1}$\n$E_{\\text{tol}} = 1.0 \\times 10^{-3}$ Hartree\n\n系数为：\n$2 \\beta g_{0} + g_{1} = 2(0.5)(200) + 40 = 240$\n$2 g_{1} = 2(40) = 80$\n$\\ln \\alpha = \\ln(0.1) \\approx -2.302585$\n$g_{1} E_{\\text{tol}} = 40 \\times (1.0 \\times 10^{-3}) = 0.04$\n\n关于 $\\epsilon_{t}^*$ 的方程（令 $x = \\epsilon_{t}^*$）变为：\n$$x [ (240 + 80 \\times (-2.302585)) - 80 \\ln x ] = 0.04$$\n$$x [ (240 - 184.2068) - 80 \\ln x ] = 0.04$$\n$$x [ 55.7932 - 80 \\ln x ] = 0.04$$\n\n这个方程必须通过数值方法求解 $x = \\epsilon_{t}^*$。使用数值求根方法（例如牛顿法或简单地测试数值），我们发现解大约为 $\\epsilon_{t}^* \\approx 4.688 \\times 10^{-5}$ Hartree。\n\n利用 $\\epsilon_{t}^*$ 的这个最优值，我们可以确定所有其他量：\n1.  最优测量误差：\n    $$\\epsilon_{m}^* = E_{\\text{tol}} - \\epsilon_{t}^* = 1.0 \\times 10^{-3} - 4.688 \\times 10^{-5} = 9.5312 \\times 10^{-4} \\text{ Hartree}$$\n2.  最优拟设层数：\n    $$r^* = \\frac{1}{\\beta} \\ln\\left(\\frac{\\alpha}{\\epsilon_{t}^*}\\right) = \\frac{1}{0.5} \\ln\\left(\\frac{0.1}{4.688 \\times 10^{-5}}\\right) = 2 \\ln(2133.1) \\approx 2 \\times 7.6654 = 15.3308$$\n3.  最优执行次数（shots）：\n    $$N^* = \\left(\\frac{\\kappa}{\\epsilon_{m}^*}\\right)^2 = \\left(\\frac{5.0 \\times 10^{-2}}{9.5312 \\times 10^{-4}}\\right)^2 \\approx (52.459)^2 \\approx 2751.9$$\n4.  在最优深度下每次线路执行的门数：\n    $$g(r^*) = g_{0} + g_{1} r^* = 200 + 40 \\times 15.3308 = 200 + 613.232 = 813.232$$\n5.  最小总双量子比特门执行次数：\n    $$C_{\\min} = N^* \\cdot g(r^*) = 2751.9 \\times 813.232 \\approx 2238064$$\n\n问题要求将最终答案四舍五入到三位有效数字。\n$$C_{\\min} \\approx 2.24 \\times 10^6$$\n这表示在给定的误差和资源模型下，达到所需精度所需的最小计算成本。", "answer": "$$\n\\boxed{2.24 \\times 10^{6}}\n$$"}, {"introduction": "将目光投向超越近期设备的未来，容错量子计算是实现精确化学模拟的最终目标。本练习将带你进入这一前沿领域，通过一个高层次的资源估算模型，让你亲身体会实现化学精度所需的巨大计算资源。你将学习如何将算法需求（如 $T$ 门数量）与物理硬件参数（如物理错误率和纠错码距离）联系起来，从而对实现可扩展量子优势的挑战与路径形成一个全面而深刻的认识。[@problem_id:2917706]", "id": "2917706", "problem": "构造一个程序，针对下面测试套件中的每一组参数，估算使用表面码保护的量子算法计算电子基态能量至化学精度所需的资源。目标精度固定为 $\\delta E = 1$ milliHartree，即 $\\delta E_{\\mathrm{H}} = 10^{-3}$ Hartree。该程序必须为每个测试用例计算以下四个输出：逻辑量子比特总数、表面码距离、$T$ 门数量，以及在一天内完成计算所需的并行魔法态工厂数量。所有测试用例的最终输出必须是单行，包含一个列表的列表，其中每个内部列表的顺序为 $[Q_{\\mathrm{tot}}, d, T, F]$。\n\n使用以下基本基准和建模假设，其表达方式独立于任何特定的化学实例，同时在科学上对电子结构的量子算法保持现实性：\n\n- 用于本征值解析的相位估计算法，其绝对精度为 $\\delta E_{\\mathrm{H}}$，所需时间与 $1/\\delta E_{\\mathrm{H}}$ 成正比。对于基于哈密顿量模拟或量子比特化的方法，假设非 Clifford $T$ 门计数遵循一个保守的、参数化的缩放关系：\n  $$ T = \\left\\lceil \\frac{c_T \\, N_{\\mathrm{so}}^3}{\\delta E_{\\mathrm{H}}} \\right\\rceil, $$\n  其中 $N_{\\mathrm{so}}$ 是自旋轨道数，$c_T$ 是每个测试用例中提供的无量纲常数，它聚合了依赖于算法的常数，如块编码成本、反射成本和相位估算重复开销。\n\n- 分配一个总算法失败预算 $\\epsilon_{\\mathrm{tot}}$（无量纲）。将此预算的一部分 $f_T$ 分配给因消耗用于 $T$ 门的蒸馏魔法态而产生的失败，得到\n  $$ \\epsilon_T = f_T \\, \\epsilon_{\\mathrm{tot}}, \\qquad p_{L,\\mathrm{target}} = \\frac{\\epsilon_T}{T}. $$\n  此处 $p_{L,\\mathrm{target}}$ 是每个消耗的 $T$ 态所要求的逻辑错误概率。所有符号均为无量纲。\n\n- 将每个表面码逻辑操作的逻辑错误率建模为随距离 $d$ 指数抑制，\n  $$ p_L(d) = A \\left(\\frac{p}{p_{\\mathrm{th}}}\\right)^{(d+1)/2}, $$\n  其中 $p$ 是每个编码周期的物理错误率，$p_{\\mathrm{th}}$ 是表面码阈值，$A$ 是一个无量纲的校准前置因子。假设 $0 &lt; p &lt; p_{\\mathrm{th}}$。选择最小的奇数编码距离 $d \\ge 3$，以满足 $p_L(d) \\le p_{L,\\mathrm{target}}$。\n\n- 建模一个魔法态工厂，它在以下时间内产生一个蒸馏的 $T$ 态\n  $$ t_{\\mathrm{fac}}(d) = \\tau_{\\mathrm{cyc}} \\, c_{\\mathrm{fac}} \\, d, $$\n  其中 $\\tau_{\\mathrm{cyc}}$ 是以秒为单位的表面码周期时间，$c_{\\mathrm{fac}}$ 是一个无量纲的“每距离周期数”常数。对于 $F$ 个并行的相同工厂，$T$ 态的生产速率为 $F/t_{\\mathrm{fac}}(d)$。为强制执行一天的时间限制，\n  $$ T_{\\mathrm{lim}} = 86400 \\ \\mathrm{s}, \\qquad\n     F = \\max\\!\\left(1,\\ \\left\\lceil \\frac{T \\, t_{\\mathrm{fac}}(d)}{T_{\\mathrm{lim}}} \\right\\rceil \\right). $$\n\n- 逻辑量子比特数计算为算法逻辑量子比特和工厂逻辑量子比特之和：\n  $$ Q_{\\mathrm{alg}} = \\left\\lceil c_q \\, N_{\\mathrm{so}} + q_0 \\right\\rceil, \\qquad\n     Q_{\\mathrm{fac}}(d) = \\left\\lceil c_{\\mathrm{area}} \\, d^2 \\right\\rceil, \\qquad\n     Q_{\\mathrm{tot}} = Q_{\\mathrm{alg}} + F \\, Q_{\\mathrm{fac}}(d). $$\n  此处 $c_q$（无量纲）和 $q_0$（无量纲）参数化了算法寄存器的大小，而 $c_{\\mathrm{area}}$（无量纲）为单个工厂设定了一个表面码面积代理，其大小按 $d^2$ 缩放。\n\n所有计算必须使用上述无角度的量和标准算术。时间约束以秒表示，能量精度以 Hartree 表示。所有输出均为整数。\n\n测试套件。请精确使用以下四个参数集：\n\n- 测试用例 A（理想情况，快速周期，中等规模）：\n  - $N_{\\mathrm{so}} = 32$, $c_T = 2.0$, $\\delta E_{\\mathrm{mHa}} = 1$, 因此 $\\delta E_{\\mathrm{H}} = 10^{-3}$,\n  - $\\epsilon_{\\mathrm{tot}} = 0.01$, $f_T = 0.5$,\n  - $p = 10^{-3}$, $p_{\\mathrm{th}} = 10^{-2}$, $A = 0.1$,\n  - $c_{\\mathrm{fac}} = 50$, $\\tau_{\\mathrm{cyc}} = 10^{-6} \\ \\mathrm{s}$,\n  - $c_{\\mathrm{area}} = 100$, $c_q = 2$, $q_0 = 4$,\n  - $T_{\\mathrm{lim}} = 86400 \\ \\mathrm{s}$.\n\n- 测试用例 B（近阈值设备，更高的 $T$ 门计数）：\n  - $N_{\\mathrm{so}} = 32$, $c_T = 3.0$, $\\delta E_{\\mathrm{mHa}} = 1$, 因此 $\\delta E_{\\mathrm{H}} = 10^{-3}$,\n  - $\\epsilon_{\\mathrm{tot}} = 0.01$, $f_T = 0.5$,\n  - $p = 5 \\times 10^{-3}$, $p_{\\mathrm{th}} = 10^{-2}$, $A = 0.1$,\n  - $c_{\\mathrm{fac}} = 50$, $\\tau_{\\mathrm{cyc}} = 10^{-6} \\ \\mathrm{s}$,\n  - $c_{\\mathrm{area}} = 100$, $c_q = 2$, $q_0 = 4$,\n  - $T_{\\mathrm{lim}} = 86400 \\ \\mathrm{s}$.\n\n- 测试用例 C（更大系统，更快周期）：\n  - $N_{\\mathrm{so}} = 64$, $c_T = 1.0$, $\\delta E_{\\mathrm{mHa}} = 1$, 因此 $\\delta E_{\\mathrm{H}} = 10^{-3}$,\n  - $\\epsilon_{\\mathrm{tot}} = 0.01$, $f_T = 0.5$,\n  - $p = 10^{-3}$, $p_{\\mathrm{th}} = 10^{-2}$, $A = 0.1$,\n  - $c_{\\mathrm{fac}} = 50$, $\\tau_{\\mathrm{cyc}} = 5 \\times 10^{-7} \\ \\mathrm{s}$,\n  - $c_{\\mathrm{area}} = 100$, $c_q = 2$, $q_0 = 4$,\n  - $T_{\\mathrm{lim}} = 86400 \\ \\mathrm{s}$.\n\n- 测试用例 D（小系统，极低物理错误，较慢周期）：\n  - $N_{\\mathrm{so}} = 8$, $c_T = 1.0$, $\\delta E_{\\mathrm{mHa}} = 1$, 因此 $\\delta E_{\\mathrm{H}} = 10^{-3}$,\n  - $\\epsilon_{\\mathrm{tot}} = 0.01$, $f_T = 0.5$,\n  - $p = 10^{-4}$, $p_{\\mathrm{th}} = 10^{-2}$, $A = 0.1$,\n  - $c_{\\mathrm{fac}} = 30$, $\\tau_{\\mathrm{cyc}} = 2 \\times 10^{-6} \\ \\mathrm{s}$,\n  - $c_{\\mathrm{area}} = 80$, $c_q = 2$, $q_0 = 4$,\n  - $T_{\\mathrm{lim}} = 86400 \\ \\mathrm{s}$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的结果列表，每个结果本身是一个按 $[Q_{\\mathrm{tot}}, d, T, F]$ 顺序排列的列表，所有值均为整数，并用方括号括起来。例如，其形状应为\n$$ [[Q_{\\mathrm{tot},1}, d_1, T_1, F_1],[Q_{\\mathrm{tot},2}, d_2, T_2, F_2],[Q_{\\mathrm{tot},3}, d_3, T_3, F_3],[Q_{\\mathrm{tot},4}, d_4, T_4, F_4]]. $$\n不应打印任何其他文本。", "solution": "对问题陈述进行了解析和验证。该问题被认为是科学基础扎实、定义明确且内容自洽的，它为估算电子结构问题的量子计算资源成本提供了一个简化但标准的模型。未发现任何缺陷。因此，有必要提供一个解决方案。\n\n解决方案通过对每个测试用例系统地应用所提供的公式来展开。目标是计算四个整数值：逻辑量子比特总数 ($Q_{\\mathrm{tot}}$)、表面码距离 ($d$)、总 $T$ 门计数 ($T$)，以及并行魔法态工厂的数量 ($F$)。\n\n对每组参数集，计算按以下顺序执行：\n\n1.  **计算总 $T$ 门计数 ($T$)**：非 Clifford $T$ 门的总数由问题规模（以自旋轨道数 $N_{\\mathrm{so}}$ 表示）和所需的能量精度 ($\\delta E_{\\mathrm{H}}$) 决定。模型由下式给出：\n    $$ T = \\left\\lceil \\frac{c_T \\, N_{\\mathrm{so}}^3}{\\delta E_{\\mathrm{H}}} \\right\\rceil $$\n    所有输入（$c_T$、$N_{\\mathrm{so}}$、$\\delta E_{\\mathrm{H}}$）在每个用例中均已提供。向上取整函数 $\\lceil \\cdot \\rceil$ 确保结果为整数。\n\n2.  **确定每个 $T$ 门的目标逻辑错误率 ($p_{L,\\mathrm{target}}$)**：总算法失败概率 ($\\epsilon_{\\mathrm{tot}}$) 被预算。其中一部分 $f_T$ 分配给由 $T$ 门引起的错误。此预算在所有 $T$ 门之间均匀分配。\n    $$ \\epsilon_T = f_T \\, \\epsilon_{\\mathrm{tot}} $$\n    $$ p_{L,\\mathrm{target}} = \\frac{\\epsilon_T}{T} $$\n\n3.  **计算所需的表面码距离 ($d$)**：表面码距离 $d$ 必须足以将物理错误率 $p$ 抑制到低于目标 $p_{L,\\mathrm{target}}$ 的逻辑错误率 $p_L(d)$。逻辑错误率的模型为：\n    $$ p_L(d) = A \\left(\\frac{p}{p_{\\mathrm{th}}}\\right)^{(d+1)/2} $$\n    我们必须找到最小的奇数整数 $d \\ge 3$ 使得 $p_L(d) \\le p_{L,\\mathrm{target}}$。这个不等式可以求解 $d$。由于 $0 < p/p_{\\mathrm{th}} < 1$，其对数为负。对两边取自然对数并整理不等式（这会反转其方向）得出：\n    $$ A \\left(\\frac{p}{p_{\\mathrm{th}}}\\right)^{(d+1)/2} \\le p_{L,\\mathrm{target}} \\implies \\frac{d+1}{2} \\ge \\frac{\\ln(p_{L,\\mathrm{target}}/A)}{\\ln(p/p_{\\mathrm{th}})} $$\n    这给出了 $d$ 的一个下界：\n    $$ d \\ge 2 \\frac{\\ln(p_{L,\\mathrm{target}}/A)}{\\ln(p/p_{\\mathrm{th}})} - 1 $$\n    设 $d_{\\mathrm{bound}}$ 为该不等式的右侧。编码距离 $d$ 必须是一个满足 $d \\ge \\max(3, d_{\\mathrm{bound}})$ 的奇数整数。我们找到满足此条件的最小整数，如果它是偶数，则加一。\n\n4.  **计算魔法态工厂的数量 ($F$)**：执行算法的总时间被限制在不超过 $T_{\\mathrm{lim}} = 86400$ 秒。在单个魔法态工厂中生产一个纯化的 $T$ 态所需的时间取决于编码距离 $d$：\n    $$ t_{\\mathrm{fac}}(d) = \\tau_{\\mathrm{cyc}} \\, c_{\\mathrm{fac}} \\, d $$\n    为了在时间限制 $T_{\\mathrm{lim}}$ 内执行 $T$ 个门，必须有一定数量的工厂 $F$ 并行运作。总吞吐量必须至少为 $T/T_{\\mathrm{lim}}$。因此，工厂数量由关系 $F \\cdot (1/t_{\\mathrm{fac}}(d)) \\ge T/T_{\\mathrm{lim}}$ 导出，这导致：\n    $$ F = \\max\\!\\left(1,\\ \\left\\lceil \\frac{T \\, t_{\\mathrm{fac}}(d)}{T_{\\mathrm{lim}}} \\right\\rceil \\right) $$\n    使用 $\\max(1, \\dots)$ 确保至少配置一个工厂。\n\n5.  **计算逻辑量子比特总数 ($Q_{\\mathrm{tot}}$)**：总逻辑量子比特数是主算法数据寄存器所需的量子比特 ($Q_{\\mathrm{alg}}$) 与所有并行魔法态工厂所需量子比特之和。\n    算法量子比特的数量随问题规模 $N_{\\mathrm{so}}$ 缩放：\n    $$ Q_{\\mathrm{alg}} = \\left\\lceil c_q \\, N_{\\mathrm{so}} + q_0 \\right\\rceil $$\n    单个工厂的逻辑量子比特足迹被假定与表面码片的面积成比例，即与 $d^2$ 成比例：\n    $$ Q_{\\mathrm{fac}}(d) = \\left\\lceil c_{\\mathrm{area}} \\, d^2 \\right\\rceil $$\n    总数则为：\n    $$ Q_{\\mathrm{tot}} = Q_{\\mathrm{alg}} + F \\cdot Q_{\\mathrm{fac}}(d) $$\n\n使用指定的参数，对四个测试用例中的每一个执行此计算序列。最终结果 $[Q_{\\mathrm{tot}}, d, T, F]$ 被收集并格式化为整数，构成一个列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes quantum resource estimates for electronic structure calculations\n    based on a provided model and test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {\n            \"N_so\": 32, \"c_T\": 2.0, \"delta_E_H\": 1e-3,\n            \"epsilon_tot\": 0.01, \"f_T\": 0.5,\n            \"p\": 1e-3, \"p_th\": 1e-2, \"A\": 0.1,\n            \"c_fac\": 50, \"tau_cyc\": 1e-6,\n            \"c_area\": 100, \"c_q\": 2, \"q_0\": 4,\n            \"T_lim\": 86400\n        },\n        # Test case B\n        {\n            \"N_so\": 32, \"c_T\": 3.0, \"delta_E_H\": 1e-3,\n            \"epsilon_tot\": 0.01, \"f_T\": 0.5,\n            \"p\": 5e-3, \"p_th\": 1e-2, \"A\": 0.1,\n            \"c_fac\": 50, \"tau_cyc\": 1e-6,\n            \"c_area\": 100, \"c_q\": 2, \"q_0\": 4,\n            \"T_lim\": 86400\n        },\n        # Test case C\n        {\n            \"N_so\": 64, \"c_T\": 1.0, \"delta_E_H\": 1e-3,\n            \"epsilon_tot\": 0.01, \"f_T\": 0.5,\n            \"p\": 1e-3, \"p_th\": 1e-2, \"A\": 0.1,\n            \"c_fac\": 50, \"tau_cyc\": 5e-7,\n            \"c_area\": 100, \"c_q\": 2, \"q_0\": 4,\n            \"T_lim\": 86400\n        },\n        # Test case D\n        {\n            \"N_so\": 8, \"c_T\": 1.0, \"delta_E_H\": 1e-3,\n            \"epsilon_tot\": 0.01, \"f_T\": 0.5,\n            \"p\": 1e-4, \"p_th\": 1e-2, \"A\": 0.1,\n            \"c_fac\": 30, \"tau_cyc\": 2e-6,\n            \"c_area\": 80, \"c_q\": 2, \"q_0\": 4,\n            \"T_lim\": 86400\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        # Step 1: Calculate T-count\n        T_float = (params[\"c_T\"] * params[\"N_so\"]**3) / params[\"delta_E_H\"]\n        T = int(np.ceil(T_float))\n\n        # Step 2: Calculate target logical error rate\n        epsilon_T = params[\"f_T\"] * params[\"epsilon_tot\"]\n        p_L_target = epsilon_T / T\n\n        # Step 3: Calculate code distance d\n        log_term_numerator = np.log(p_L_target / params[\"A\"])\n        log_term_denominator = np.log(params[\"p\"] / params[\"p_th\"])\n        d_bound_float = 2 * (log_term_numerator / log_term_denominator) - 1\n        \n        d_lower_bound = max(3.0, d_bound_float)\n        d_int = int(np.ceil(d_lower_bound))\n        if d_int % 2 == 0:\n            d = d_int + 1\n        else:\n            d = d_int\n\n        # Step 4: Calculate factory time\n        t_fac_d = params[\"tau_cyc\"] * params[\"c_fac\"] * d\n\n        # Step 5: Calculate number of factories F\n        F_float = (T * t_fac_d) / params[\"T_lim\"]\n        F = int(max(1, np.ceil(F_float)))\n        \n        # Step 6: Calculate total logical qubits Q_tot\n        Q_alg_float = params[\"c_q\"] * params[\"N_so\"] + params[\"q_0\"]\n        Q_alg = int(np.ceil(Q_alg_float))\n        \n        Q_fac_d_float = params[\"c_area\"] * d**2\n        Q_fac_d = int(np.ceil(Q_fac_d_float))\n        \n        Q_tot = Q_alg + F * Q_fac_d\n\n        # Assemble results for this case\n        results.append([Q_tot, d, T, F])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces inside the inner lists.\n    inner_results_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\nsolve()\n```"}]}