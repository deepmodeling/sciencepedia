{"hands_on_practices": [{"introduction": "将机器学习应用于量子化学的首要步骤是将原子构型转化为机器学习模型能够理解的数值表示，即所谓的“分子描述符”。库仑矩阵 (Coulomb matrix) 是一种早期的、物理直觉清晰的分子描述符，它将分子的三维几何结构和原子身份编码为一个固定大小的矩阵。通过本练习，您将亲手为一个水分子构建库仑矩阵，并分析其本征谱，从而深入理解如何将对称性等物理原理融入表示中，这是解决等价原子排列问题的关键一步 [@problem_id:2903789]。", "problem": "在原子系统的监督学习中，库仑矩阵 (CM) 是一种广泛使用的表示方法，它将原子核间的库仑相互作用编码成一个固定大小的对称矩阵，适用于机器学习 (ML) 模型。对于一个分子，其原子核由 $i$ 和 $j$ 索引，核电荷为 $Z_i$，位置为 $\\mathbf{R}_i$，CM 定义如下\n- $C_{ii} = \\frac{1}{2} Z_i^{2.4}$，\n- $C_{ij} = \\frac{Z_i Z_j}{|\\mathbf{R}_i - \\mathbf{R}_j|}$ 对于 $i \\ne j$，\n其中距离以玻尔 (bohr) 为单位。假设使用原子单位制，能量单位为哈特里 (Hartree)，距离单位为玻尔 (bohr)。使用换算关系 $1\\,\\text{\\AA} = 1.889726125\\,\\text{bohr}$。\n\n考虑水分子 $\\mathrm{H_2O}$，其气相几何构型如下：两个 $\\mathrm{O-H}$ 键的键长为 $r_{\\mathrm{OH}} = 0.9584\\,\\text{\\AA}$，$\\angle \\mathrm{HOH}$ 键角为 $\\theta = 104.45^\\circ$。将该分子置于 $x$-$z$ 平面内，氧原子位于原点，角平分线沿 $+z$ 轴方向：\n- $\\mathbf{R}_{\\mathrm{O}} = (0, 0, 0)$,\n- $\\mathbf{R}_{\\mathrm{H}_1} = (r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$,\n- $\\mathbf{R}_{\\mathrm{H}_2} = (-r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$.\n使用 $Z_{\\mathrm{O}} = 8$ and $Z_{\\mathrm{H}} = 1$。\n\n任务：\n1) 计算该几何构型在原子单位制下的显式 $3 \\times 3$ 库仑矩阵 $C$。展示如何根据给定的几何构型和换算因子得到距离 $r_{\\mathrm{OH}}$ 和 $r_{\\mathrm{HH}}$。\n2) 根据对称矩阵的线性代数第一性原理以及由两个相同氢原子诱导的结构，用 $a = \\frac{1}{2} Z_{\\mathrm{O}}^{2.4}$、 $d = \\frac{1}{2} Z_{\\mathrm{H}}^{2.4}$、 $b = \\frac{Z_{\\mathrm{O}} Z_{\\mathrm{H}}}{r_{\\mathrm{OH}}}$ 和 $e = \\frac{Z_{\\mathrm{H}} Z_{\\mathrm{H}}}{r_{\\mathrm{HH}}}$ 解析地推导出 $C$ 的特征值。确定与两个氢原子的反对称组合相关联的特征向量及其特征值。\n3) 计算给定几何构型的数值特征值。讨论能谱的哪些方面在两个氢原子的置换下保持不变，并解释由于相同原子可能引起的任何精确或近似简并的来源。\n\n给出 $C$ 的最小特征值（单位为哈特里），四舍五入到四位有效数字，作为你的最终答案。在最终的方框答案中不要包含单位。", "solution": "我们从机器学习中用于原子系统的库仑矩阵的定义开始，它是一个固定大小的对称矩阵，编码了成对的原子核库仑相互作用，并采用对角线启发式规则 $C_{ii} = \\frac{1}{2} Z_i^{2.4}$。对于 $\\mathrm{H_2O}$，我们有三个原子：一个氧原子 ($Z_{\\mathrm{O}} = 8$) 和两个氢原子 ($Z_{\\mathrm{H}} = 1$)。假设使用原子单位制，能量单位为哈特里 (Hartree)，距离单位为玻尔 (bohr)。从埃到玻尔的换算因子为 $1\\,\\text{\\AA} = 1.889726125\\,\\text{bohr}$。\n\n步骤1：几何构型、距离和库仑矩阵元。\n- 给定 $r_{\\mathrm{OH}} = 0.9584\\,\\text{\\AA}$ 和 $\\theta = 104.45^\\circ$，原子位置如下\n  - $\\mathbf{R}_{\\mathrm{O}} = (0, 0, 0)$,\n  - $\\mathbf{R}_{\\mathrm{H}_1} = (r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$,\n  - $\\mathbf{R}_{\\mathrm{H}_2} = (-r_{\\mathrm{OH}}\\sin(\\theta/2), 0, r_{\\mathrm{OH}}\\cos(\\theta/2))$.\n- 将 $\\mathrm{O-H}$ 键长转换为玻尔：\n  $$r_{\\mathrm{OH}}^{\\mathrm{(bohr)}} = (0.9584)\\times(1.889726125) \\approx 1.8111135182.$$\n- $\\mathrm{H-H}$ 间距可以从几何关系中得出，它是在半径为 $r_{\\mathrm{OH}}$ 的圆上，夹角为 $\\theta$ 的两点之间的弦长：\n  $$r_{\\mathrm{HH}} = 2 r_{\\mathrm{OH}} \\sin\\left(\\frac{\\theta}{2}\\right).$$\n  当 $\\theta/2 = 52.225^\\circ$ 且 $\\sin(52.225^\\circ) \\approx 0.7904224066$ 时，我们得到\n  $$r_{\\mathrm{HH}}^{\\mathrm{(bohr)}} = 2 \\times (1.8111135182) \\times (0.7904224066) \\approx 2.8630894114.$$\n- 定义库仑矩阵参数：\n  $$a = \\frac{1}{2} Z_{\\mathrm{O}}^{2.4} = \\frac{1}{2} \\times 8^{2.4} = \\frac{1}{2} \\times 2^{7.2} = \\frac{1}{2} \\times 147.0333894396 \\approx 73.5166947198,$$\n  $$d = \\frac{1}{2} Z_{\\mathrm{H}}^{2.4} = \\frac{1}{2} \\times 1^{2.4} = 0.5,$$\n  $$b = \\frac{Z_{\\mathrm{O}} Z_{\\mathrm{H}}}{r_{\\mathrm{OH}}} = \\frac{8 \\times 1}{1.8111135182} \\approx 4.4171720400,$$\n  $$e = \\frac{Z_{\\mathrm{H}} Z_{\\mathrm{H}}}{r_{\\mathrm{HH}}} = \\frac{1 \\times 1}{2.8630894114} \\approx 0.3492730600.$$\n- 按照 $(\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2)$ 的原子排序，CM 具有以下结构化形式\n  $$C = \\begin{pmatrix}\n  a  b  b \\\\\n  b  d  e \\\\\n  b  e  d\n  \\end{pmatrix} = \\begin{pmatrix}\n  73.5166947198  4.4171720400  4.4171720400 \\\\\n  4.4171720400  0.5  0.3492730600 \\\\\n  4.4171720400  0.3492730600  0.5\n  \\end{pmatrix}.$$\n\n步骤2：利用对称性和线性代数求解解析特征值。\n由于两个氢原子相同且对称放置，$C$ 的第2行和第3行除了 $(2,3)$ 和 $(3,2)$ 元素（均为 $e$）之外是相同的。这种块结构允许相对于两个氢原子的交换，将矩阵分解到对称和反对称子空间中。\n\n- 考虑氢子空间上的反对称向量，\n  $$\\mathbf{v}_{\\mathrm{as}} = \\frac{1}{\\sqrt{2}}(0, 1, -1).$$\n  将 $C$ 作用于 $\\mathbf{v}_{\\mathrm{as}}$ 得到\n  $$C \\mathbf{v}_{\\mathrm{as}} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} b - b \\\\ d - e \\\\ e - d \\end{pmatrix} = (d - e)\\,\\mathbf{v}_{\\mathrm{as}},$$\n  因此反对称特征值为\n  $$\\lambda_{\\mathrm{as}} = d - e.$$\n  注意，氧原子不与此反对称组合耦合，因为位置 $(1,2)$ 和 $(1,3)$ 处的 $\\mathrm{O-H}$ 相互作用相等并相互抵消。\n\n- 对称子空间由氧原子的基向量和对称的氢原子组合张成\n  $$\\mathbf{u}_1 = (1, 0, 0), \\quad \\mathbf{u}_2 = \\frac{1}{\\sqrt{2}}(0, 1, 1).$$\n  在此基下，有效的 $2 \\times 2$ 投影矩阵为\n  $$M = \\begin{pmatrix}\n  \\langle \\mathbf{u}_1 | C | \\mathbf{u}_1 \\rangle  \\langle \\mathbf{u}_1 | C | \\mathbf{u}_2 \\rangle \\\\\n  \\langle \\mathbf{u}_2 | C | \\mathbf{u}_1 \\rangle  \\langle \\mathbf{u}_2 | C | \\mathbf{u}_2 \\rangle\n  \\end{pmatrix} = \\begin{pmatrix}\n  a  \\sqrt{2}\\,b \\\\\n  \\sqrt{2}\\,b  d + e\n  \\end{pmatrix}.$$\n  因此，两个对称子空间的特征值为\n  $$\\lambda_{\\pm} = \\frac{1}{2}\\left[(a + d + e) \\pm \\sqrt{(a - d - e)^{2} + 8 b^{2}}\\right].$$\n\n因此，完整的特征谱为 $\\{\\lambda_{+}, \\lambda_{-}, \\lambda_{\\mathrm{as}}\\}$，其中\n$$\\lambda_{\\mathrm{as}} = d - e, \\quad \\lambda_{\\pm} = \\frac{1}{2}\\left[(a + d + e) \\pm \\sqrt{(a - d - e)^{2} + 8 b^{2}}\\right].$$\n\n步骤3：数值计算以及关于置换不变性和简并的讨论。\n使用上面计算的数值，\n- $a \\approx 73.5166947198$,\n- $d \\approx 0.5$,\n- $b \\approx 4.4171720400$,\n- $e \\approx 0.3492730600$,\n我们得到\n$$\\lambda_{\\mathrm{as}} = d - e \\approx 0.5 - 0.3492730600 \\approx 0.1507269400.$$\n对于对称子空间，\n$$(a - d - e) \\approx 73.5166947198 - 0.8492730600 \\approx 72.6674216598,$$\n$$(a - d - e)^{2} \\approx 5280.5541700,$$\n$$8 b^{2} \\approx 8 \\times (4.4171720400)^{2} \\approx 156.0912706,$$\n所以\n$$\\sqrt{(a - d - e)^{2} + 8 b^{2}} \\approx \\sqrt{5436.6454406} \\approx 73.7336190,$$\n$$(a + d + e) \\approx 73.5166947198 + 0.8492730600 \\approx 74.3659677798,$$\n因此\n$$\\lambda_{+} \\approx \\frac{74.3659677798 + 73.7336190}{2} \\approx 74.04979339,$$\n$$\\lambda_{-} \\approx \\frac{74.3659677798 - 73.7336190}{2} \\approx 0.31617439.$$\n\n将特征值按升序排列，约得到\n$$\\{\\lambda_{\\min}, \\lambda_{\\mathrm{mid}}, \\lambda_{\\max}\\} \\approx \\{0.15072694, 0.31617439, 74.04979339\\}.$$\n\n关于置换和简并的讨论：\n- 置换两个相同氢原子的标签，相当于交换 $C$ 的第2行和第3行以及对应的列。这种置换保持特征值不变，因为矩阵的谱在行和列的同时置换下是不变的。\n- 因为两个氢原子在化学上是相同的，并且在此几何构型中对称相关，所以 $C$ 有两个相同的非对角 $\\mathrm{O-H}$ 元和相同的氢对角元，这导致在氢子空间上存在精确的反对称特征向量和精确的特征值 $\\lambda_{\\mathrm{as}} = d - e$。这并非与其他特征值的简并；它是一个由对称性产生的精确特征值，该对称性将反对称的氢模式与氧原子解耦。\n- 真正的特征值简并需要一个额外的约束条件，例如 $a = d + e$（此处不满足），在这种情况下 $\\lambda_{-}$ 可能与 $\\lambda_{\\mathrm{as}}$ 重合。总的来说，虽然行/列置换在原始CM表示空间中會引起简并（多个矩阵对应同一个分子），但特征谱通过其构造消除了这种置换简并，是一种置换不变的表示。\n\n最后，最小的特征值是 $\\lambda_{\\mathrm{as}} \\approx 0.15072694$ 哈特里。按要求四舍五入到四位有效数字，即为 $0.1507$ 哈特里。", "answer": "$$\\boxed{0.1507}$$", "id": "2903789"}, {"introduction": "在拥有了分子的数值表示后，下一步便是训练模型来学习势能面。量子化学计算可以为我们提供两种关键的标签数据：体系的总能量和作用在原子上的力（即能量梯度）。本实践将引导您通过一个编程练习，定量地比较仅使用能量标签和仅使用力标签进行训练时的“数据效率”，这是训练机器学习势函数时的一个核心且实际的问题。通过构建和分析学习曲线，您将直接体验到选择不同训练标签对模型泛化能力和样本需求量的深远影响 [@problem_id:2903774]。", "problem": "要求您设计并实现一个程序，通过分析学习曲线，比较在一维势能面 (PES) 模型下，固定模型容量时，力匹配和能量匹配的数据效率。该场景构建于量子化学的背景下，并使用原子单位：能量单位为Hartree，距离单位为bohr。所有学习和评估都必须在原子单位下进行。最终程序必须输出本问题末尾指定的所需结果。\n\n您必须使用的基本原理如下。势能面 (PES) 是核坐标 $x$ 的函数 $E_{\\mathrm{true}}(x)$，其负梯度定义了力 $F_{\\mathrm{true}}(x)$，即 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x)$。一个参数化的能量模型定义为 $E_{w}(x) = \\sum_{k=1}^{M} w_k \\,\\phi_k(x)$，其中 $M$ 是模型容量（基函数的数量），$w \\in \\mathbb{R}^{M}$ 是参数，$\\{\\phi_k\\}_{k=1}^M$ 是固定的、可微的基函数。能量匹配通过最小化能量标签的正则化平方误差和来训练 $w$，而力匹配则通过最小化由模型力 $F_w(x) = -\\frac{d}{dx}E_w(x)$ 计算出的力标签的正则化平方误差和来训练 $w$。具体来说，给定训练输入 $\\{x_i\\}_{i=1}^{N}$、能量 $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$ 和力 $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$，这两个优化问题分别是\n$$\n\\min_{w \\in \\mathbb{R}^{M}} \\left[ \\sum_{i=1}^{N} \\left( E_w(x_i) - y^{(E)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2 \\right],\n\\qquad\n\\min_{w \\in \\mathbb{R}^{M}} \\left[ \\sum_{i=1}^{N} \\left( F_w(x_i) - y^{(F)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2 \\right],\n$$\n其中岭参数 $\\lambda > 0$。这些问题会产生闭式解的正规方程。对于能量匹配，如果 $\\Phi \\in \\mathbb{R}^{N \\times M}$ 的行是 $\\Phi_{i,:} = \\big(\\phi_1(x_i),\\ldots,\\phi_M(x_i)\\big)$ 并且 $y^{(E)} \\in \\mathbb{R}^N$，则\n$$\nw_{\\mathrm{E}} = \\arg\\min_w \\lVert \\Phi w - y^{(E)} \\rVert_2^2 + \\lambda \\lVert w \\rVert_2^2\n= \\left( \\Phi^\\top \\Phi + \\lambda I \\right)^{-1} \\Phi^\\top y^{(E)}.\n$$\n对于力匹配，如果 $G \\in \\mathbb{R}^{N \\times M}$ 的行是 $G_{i,:} = \\big(-\\tfrac{d}{dx}\\phi_1(x_i),\\ldots,-\\tfrac{d}{dx}\\phi_M(x_i)\\big)$ 并且 $y^{(F)} \\in \\mathbb{R}^N$，则\n$$\nw_{\\mathrm{F}} = \\arg\\min_w \\lVert G w - y^{(F)} \\rVert_2^2 + \\lambda \\lVert w \\rVert_2^2\n= \\left( G^\\top G + \\lambda I \\right)^{-1} G^\\top y^{(F)}.\n$$\n\n在每个测试中，对于所有训练集大小，您都必须使用一个固定容量的模型，其基函数如下。设 $M$ 为基函数的总数，由一个常数基 $\\phi_1(x) = 1$ 和 $M-1$ 个高斯函数 $\\phi_k(x) = \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\frac{x-c_{k}}{\\sigma}\\right)^2\\right)$ 组成，其中 $k \\in \\{2,\\ldots,M\\}$。$\\{c_k\\}$ 是在定义域上均匀间隔的中心点，$\\sigma$ 是一个由定义域和 $M$ 决定的固定宽度。对于每个测试，中心点应在指定的定义域上均匀分布，宽度应为 $\\sigma = 1.5\\,\\Delta$，其中 $\\Delta$ 是相邻中心点之间的间距。对于每个测试用例，总容量 $M$ 固定为 $M=20$；因此必须使用一个常数基函数加上 $M-1=19$ 个高斯函数。\n\n对于给定的测试，训练输入必须是指定定义域上的 $N$ 个均匀间隔的点，测试网格必须是同一域上的 $T$ 个均匀间隔的点，其中 $T=1000$。对于每个模型（$w_{\\mathrm{E}}$ 和 $w_{\\mathrm{F}}$），其性能必须通过测试网格上的能量平均绝对误差 (MAE) 来衡量：\n$$\n\\mathrm{MAE}(w) = \\frac{1}{T}\\sum_{j=1}^{T} \\left| E_w(x^{\\mathrm{test}}_j) - E_{\\mathrm{true}}(x^{\\mathrm{test}}_j) \\right| \\quad \\text{单位为 Hartree}。\n$$\n对于任一训练策略，其学习曲线是将训练规模 $N$ 映射到 $\\mathrm{MAE}(w(N))$ 的函数，其中所有其他要素均保持不变。数据效率被量化为达到目标MAE阈值 $\\varepsilon$ 所需的最小训练规模 $N_{\\min}$：\n$$\nN_{\\min}(\\varepsilon) = \\min \\left\\{ N \\in \\mathcal{N} \\,:\\, \\mathrm{MAE}(w(N)) \\le \\varepsilon \\right\\},\n$$\n其中 $\\mathcal{N}$ 是一个预定义的候选训练规模集合。如果对于任何 $N \\in \\mathcal{N}$ 都未达到该阈值，则 $N_{\\min}(\\varepsilon)$ 返回 $-1$。\n\n您必须使用以下固定的要素来实施上述所有测试：\n- 原子单位：能量单位为Hartree，距离单位为bohr。所有中间和最终计算都必须使用这些单位。任何最终的样本复杂度输出都是无单位整数。\n- 基函数规格如前所述，$M=20$。\n- 岭参数 $\\lambda = 10^{-8}$。\n- 候选训练规模 $\\mathcal{N} = [\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96,\\,128\\,]$。\n- 测试网格大小 $T=1000$ 个点，分布在测试的定义域上。\n\n定义三个科学上真实的测试用例。在每个用例中，距离单位为bohr，能量单位为Hartree：\n\n- 测试用例 $1$ (带倾斜的双势阱):\n  - 定义域 $[x_{\\min},x_{\\max}] = [-1.5,\\,1.5]$。\n  - 真实PES $E_{\\mathrm{true}}(x) = a\\,(x^2 - b^2)^2 + d\\,x$，其中 $a=0.02$, $b=1.0$, $d=0.005$。\n  - 目标阈值 $\\varepsilon = 4 \\times 10^{-3}$。\n\n- 测试用例 $2$ (类 Morse 键):\n  - 定义域 $[x_{\\min},x_{\\max}] = [0.5,\\,3.0]$。\n  - 真实PES $E_{\\mathrm{true}}(x) = D\\,\\big(1 - e^{-a(x-x_0)}\\big)^2 - D$，其中 $D=0.02$, $a=1.5$, $x_0=1.5$。\n  - 目标阈值 $\\varepsilon = 3 \\times 10^{-3}$。\n\n- 测试用例 $3$ (单势阱非谐性):\n  - 定义域 $[x_{\\min},x_{\\max}] = [-1.2,\\,1.2]$。\n  - 真实PES $E_{\\mathrm{true}}(x) = k_4 x^4 + k_2 x^2 + k_1 x$，其中 $k_4=0.01$, $k_2=0.02$, $k_1=0.005$。\n  - 目标阈值 $\\varepsilon = 5 \\times 10^{-3}$。\n\n对于每个测试用例，您必须：\n- 按照规定构建包含 $M=20$ 个基函数的高斯基，其中中心点在定义域上均匀分布，宽度 $\\sigma$ 为中心点间距的 1.5 倍，并包含一个常数基。\n- 对于每个 $N \\in \\mathcal{N}$，通过求解相应的正则化正规方程来计算 $w_{\\mathrm{E}}(N)$ 和 $w_{\\mathrm{F}}(N)$，方程中使用的能量和力在 $N$ 个训练点上精确计算。\n- 通过在测试网格上计算 $\\mathrm{MAE}(w_{\\mathrm{E}}(N))$ 和 $\\mathrm{MAE}(w_{\\mathrm{F}}(N))$ 来评估学习曲线。\n- 分别确定能量匹配和力匹配达到测试用例阈值 $\\varepsilon$ 的最小 $N \\in \\mathcal{N}$，记为 $N^{(\\mathrm{E})}_{\\min}$ 和 $N^{(\\mathrm{F})}_{\\min}$。\n- 如果 $N^{(\\mathrm{E})}_{\\min}$ 和 $N^{(\\mathrm{F})}_{\\min}$ 均为正数，则计算数据效率比率 $r = \\frac{N^{(\\mathrm{E})}_{\\min}}{N^{(\\mathrm{F})}_{\\min}}$，结果为浮点数；否则，令 $r=-1.0$。\n\n角度单位不适用。不使用百分比。\n\n您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为用方括号括起来的逗号分隔列表。每个测试用例的结果必须是长度为三的列表，包含 $[N^{(\\mathrm{E})}_{\\min}, N^{(\\mathrm{F})}_{\\min}, r]$。例如，输出格式必须与\n\"[ [NE1,NF1,r1],[NE2,NF2,r2],[NE3,NF3,r3] ]\"\n完全一样，除了示例中显示的空格外，不需要其他空格。程序不得读取任何输入。\n\n请根据这些规范提供一个完整且可运行的解决方案。", "solution": "我们通过构建和分析学习曲线，比较在固定模型容量下，使用能量匹配和力匹配拟合势能面 (PES) 的数据效率。基本原理始于物理定义：对于一维PES，力是能量的负导数，即 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x)$。我们使用参数化能量模型 $E_w(x) = \\sum_{k=1}^{M} w_k \\phi_k(x)$，其中 $M$ 在所有训练规模中都保持固定，以确保模型容量恒定。\n\n训练策略由正则化最小二乘问题定义。对于能量匹配，给定训练输入 $\\{x_i\\}_{i=1}^{N}$ 和能量标签 $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$，我们最小化经验风险加上岭惩罚\n$$\nJ_{\\mathrm{E}}(w) = \\sum_{i=1}^{N} \\left( E_w(x_i) - y^{(E)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2.\n$$\n设 $\\Phi \\in \\mathbb{R}^{N \\times M}$ 是设计矩阵，其元素为 $\\Phi_{ik} = \\phi_k(x_i)$，设 $y^{(E)} \\in \\mathbb{R}^N$ 是目标向量。最小化器满足正规方程\n$$\n\\frac{\\partial J_{\\mathrm{E}}}{\\partial w} = 2\\Phi^\\top(\\Phi w - y^{(E)}) + 2\\lambda w = 0 \\quad \\Longrightarrow \\quad (\\Phi^\\top \\Phi + \\lambda I) w = \\Phi^\\top y^{(E)},\n$$\n因此\n$$\nw_{\\mathrm{E}} = (\\Phi^\\top \\Phi + \\lambda I)^{-1} \\Phi^\\top y^{(E)}.\n$$\n\n对于力匹配，我们使用力标签 $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$ 并最小化\n$$\nJ_{\\mathrm{F}}(w) = \\sum_{i=1}^{N} \\left( F_w(x_i) - y^{(F)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2,\n$$\n其中 $F_w(x) = -\\frac{d}{dx}E_w(x) = -\\sum_{k=1}^{M} w_k \\frac{d}{dx}\\phi_k(x)$。定义 $G \\in \\mathbb{R}^{N \\times M}$，其元素为 $G_{ik} = -\\frac{d}{dx}\\phi_k(x_i)$，并定义 $y^{(F)} \\in \\mathbb{R}^N$，则正规方程为\n$$\n\\frac{\\partial J_{\\mathrm{F}}}{\\partial w} = 2G^\\top(G w - y^{(F)}) + 2\\lambda w = 0 \\quad \\Longrightarrow \\quad (G^\\top G + \\lambda I) w = G^\\top y^{(F)},\n$$\n所以\n$$\nw_{\\mathrm{F}} = (G^\\top G + \\lambda I)^{-1} G^\\top y^{(F)}.\n$$\n\n我们采用带有常数项的高斯基，以确保模型能够拟合任意的能量偏移，这在物理上是有意义的，因为不同系统的绝对能量零点可能不同。基函数规格如下：\n- $\\phi_1(x) = 1$，\n- 对于 $k \\in \\{2,\\ldots,M\\}$，$\\phi_k(x) = \\exp\\!\\left( -\\frac{1}{2} \\left( \\frac{x - c_k}{\\sigma} \\right)^2 \\right)$,\n其中中心点 $\\{c_k\\}$ 在定义域上均匀分布，宽度 $\\sigma$ 与中心点间距成正比。力匹配中使用的导数是\n$$\n\\frac{d}{dx}\\phi_k(x) = -\\frac{x - c_k}{\\sigma^2} \\, \\phi_k(x), \\quad \\text{所以} \\quad G_{ik} = -\\frac{d}{dx}\\phi_k(x_i) = \\frac{x_i - c_k}{\\sigma^2} \\phi_k(x_i),\n$$\n而对于常数基，$\\frac{d}{dx}\\phi_1(x) = 0$，因此 $G$ 中对应的列为零。由于包含了岭项 $\\lambda \\lVert w \\rVert_2^2$ 且 $\\lambda = 10^{-8}$，$(\\Phi^\\top \\Phi + \\lambda I)$ 和 $(G^\\top G + \\lambda I)$ 均为正定矩阵，因此是可逆的，从而确保了适定解。\n\n学习曲线是为一系列候选训练规模 $\\mathcal{N} = [\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96,\\,128\\,]$ 构建的。对于 $\\mathcal{N}$ 中的每个 $N$，我们在定义域上放置 $N$ 个均匀间隔的训练点，并从给定的真实 PES 中计算精确的标签 $(y^{(E)}, y^{(F)})$。我们求解出 $w_{\\mathrm{E}}(N)$ 和 $w_{\\mathrm{F}}(N)$，然后在包含 $T=1000$ 个均匀间隔点的测试网格上评估能量的平均绝对误差 (MAE)：\n$$\n\\mathrm{MAE}(w) = \\frac{1}{T} \\sum_{j=1}^{T} \\left| E_w(x^{\\mathrm{test}}_j) - E_{\\mathrm{true}}(x^{\\mathrm{test}}_j) \\right|, \\quad \\text{单位为 Hartree}。\n$$\n\n目标精度为 $\\varepsilon$ 时的数据效率被量化为 $N_{\\min}(\\varepsilon)$，即满足 MAE 不超过 $\\varepsilon$ 的最小 $N \\in \\mathcal{N}$。如果不存在这样的 $N$，我们设 $N_{\\min}(\\varepsilon) = -1$。我们报告 $N^{(\\mathrm{E})}_{\\min}$ 和 $N^{(\\mathrm{F})}_{\\min}$ 以及它们的比率\n$$\nr = \\begin{cases}\n\\frac{N^{(\\mathrm{E})}_{\\min}}{N^{(\\mathrm{F})}_{\\min}},  \\text{若 } N^{(\\mathrm{E})}_{\\min} > 0 \\text{ 且 } N^{(\\mathrm{F})}_{\\min} > 0,\\\\\n-1.0,  \\text{其他情况}。\n\\end{cases}\n$$\n\n我们对三个测试用例执行上述过程，每个用例都具有科学上合理的PES和原子单位下的定义域：\n- 测试 $1$：带倾斜的双势阱，$E_{\\mathrm{true}}(x) = a(x^2 - b^2)^2 + d x$，其中 $a=0.02$, $b=1.0$, $d=0.005$，定义域 $[-1.5, 1.5]$，目标 $\\varepsilon = 4\\times 10^{-3}$。\n  力为 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -4 a x (x^2 - b^2) - d$。\n- 测试 $2$：类 Morse 键，$E_{\\mathrm{true}}(x) = D (1 - e^{-a(x-x_0)})^2 - D$，其中 $D=0.02$, $a=1.5$, $x_0=1.5$，定义域 $[0.5, 3.0]$，目标 $\\varepsilon = 3\\times 10^{-3}$。\n  设 $u(x) = e^{-a(x-x_0)}$。那么 $\\frac{d}{dx}E_{\\mathrm{true}}(x) = 2 D (1 - u) (a u)$，因此 $F_{\\mathrm{true}}(x) = - 2 D a u (1 - u)$。\n- 测试 $3$：单势阱非谐性，$E_{\\mathrm{true}}(x) = k_4 x^4 + k_2 x^2 + k_1 x$，其中 $k_4=0.01$, $k_2=0.02$, $k_1=0.005$，定义域 $[-1.2, 1.2]$，目标 $\\varepsilon = 5\\times 10^{-3}$。\n  力为 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -(4k_4 x^3 + 2k_2 x + k_1)$。\n\n算法步骤：\n1. 对于给定的测试，构建 $M=20$ 的基函数，其中中心点在定义域上均匀分布，宽度 $\\sigma$ 为中心点间距的 1.5 倍。将常数基包含为 $\\phi_1(x)=1$。\n2. 对于每个 $N \\in \\mathcal{N}$，在定义域上创建 $N$ 个均匀间隔的训练点 $x_i$，计算标签 $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$ 和 $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$。\n3. 使用基函数及其导数构建能量设计矩阵 $\\Phi$ 和力设计矩阵 $G$，其中常数基的导数列设为零。\n4. 通过对 $(\\Phi^\\top \\Phi + \\lambda I) w = \\Phi^\\top y^{(E)}$ 和 $(G^\\top G + \\lambda I) w = G^\\top y^{(F)}$ 使用线性求解器来求解岭正则化正规方程，从而得到 $w_{\\mathrm{E}}(N)$ 和 $w_{\\mathrm{F}}(N)$，而无需显式构造矩阵的逆。\n5. 在 $T=1000$ 个点的测试网格上评估 $\\mathrm{MAE}(w_{\\mathrm{E}}(N))$ 和 $\\mathrm{MAE}(w_{\\mathrm{F}}(N))$，并确定每种方法满足测试 $\\varepsilon$ 的最小 $N$。如果没有满足的，则该方法输出 $-1$。\n6. 按定义计算比率 $r$ 并报告 $[N^{(\\mathrm{E})}_{\\min}, N^{(\\mathrm{F})}_{\\min}, r]$。\n\n该方法论直接源自保守系统中能量与力之间的基本关系，以及正则化最小二乘法（岭回归）的成熟公式。它还确保在不同训练规模下模型容量保持固定，从而将样本大小对泛化能力的影响分离开来。最终输出将三个测试用例的结果汇总到一行，并遵循指定的格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian_basis_and_derivative(x, centers, sigma):\n    \"\"\"\n    Compute Gaussian RBF basis values and their spatial derivatives for a 1D input array x.\n    Includes constant basis as the first column, whose derivative is zero.\n    Parameters:\n        x: shape (n,)\n        centers: shape (m,) for Gaussian centers (does not include constant basis)\n        sigma: scalar width\n    Returns:\n        Phi: shape (n, M) with M = 1 + m (constant + Gaussians)\n        dPhi_dx: shape (n, M) derivatives; first column is zeros\n    \"\"\"\n    x = np.asarray(x).reshape(-1, 1)         # (n,1)\n    centers = np.asarray(centers).reshape(1, -1)  # (1,m)\n    # Gaussian values for each x against each center\n    # G[i,k] = exp(-0.5 * ((x_i - c_k)/sigma)^2)\n    diff = (x - centers) / sigma\n    G = np.exp(-0.5 * diff**2)               # (n,m)\n    # Derivative of Gaussian wrt x: d/dx exp(-0.5 t^2) = exp(-0.5 t^2) * (-t) * (1/sigma)\n    # But since t = (x - c)/sigma, d/dx t = 1/sigma, so d/dx = -(x-c)/sigma^2 * G\n    dGdx = -(x - centers) / (sigma**2) * G   # (n,m)\n    # Assemble with constant basis\n    n = x.shape[0]\n    const = np.ones((n, 1))\n    dconst = np.zeros((n, 1))\n    Phi = np.concatenate([const, G], axis=1)        # (n, 1+m)\n    dPhi_dx = np.concatenate([dconst, dGdx], axis=1)\n    return Phi, dPhi_dx\n\ndef solve_ridge(A, b, lam):\n    # Solve (A^T A + lam I) w = A^T b robustly without explicit inversion.\n    ATA = A.T @ A\n    ATb = A.T @ b\n    M = ATA.shape[0]\n    reg = lam * np.eye(M)\n    w = np.linalg.solve(ATA + reg, ATb)\n    return w\n\ndef make_basis(domain, M_total):\n    \"\"\"\n    Construct centers and sigma for Gaussian basis with constant term included.\n    Returns:\n        centers: (M_total-1,) for Gaussians (excludes constant basis)\n        sigma: scalar width\n    \"\"\"\n    x_min, x_max = domain\n    m = M_total - 1\n    centers = np.linspace(x_min, x_max, m)\n    if m > 1:\n        delta = centers[1] - centers[0]\n    else:\n        delta = (x_max - x_min)\n    sigma = 1.5 * delta\n    return centers, sigma\n\ndef build_design_matrices(x_train, centers, sigma):\n    Phi, dPhi_dx = gaussian_basis_and_derivative(x_train, centers, sigma)\n    # For force matching, model force is F_w(x) = -d/dx E_w(x) = -(dPhi_dx @ w),\n    # so the design matrix that maps w to F is G = -dPhi_dx.\n    G = -dPhi_dx\n    return Phi, G\n\ndef eval_energy_model(x, w, centers, sigma):\n    Phi, _ = gaussian_basis_and_derivative(x, centers, sigma)\n    return Phi @ w\n\n# True PES and forces for test cases\ndef pes_double_well(x, a=0.02, b=1.0, d=0.005):\n    # E(x) = a (x^2 - b^2)^2 + d x\n    x = np.asarray(x)\n    E = a * (x**2 - b**2)**2 + d * x\n    F = - (4.0 * a * x * (x**2 - b**2) + d)\n    return E, F\n\ndef pes_morse(x, D=0.02, a=1.5, x0=1.5):\n    # E(x) = D (1 - exp(-a (x - x0)))^2 - D\n    x = np.asarray(x)\n    u = np.exp(-a * (x - x0))\n    E = D * (1.0 - u)**2 - D\n    dE_dx = 2.0 * D * (1.0 - u) * (a * u)  # derivative of E wrt x\n    F = -dE_dx\n    return E, F\n\ndef pes_anharmonic(x, k4=0.01, k2=0.02, k1=0.005):\n    # E(x) = k4 x^4 + k2 x^2 + k1 x\n    x = np.asarray(x)\n    E = k4 * x**4 + k2 * x**2 + k1 * x\n    dE_dx = 4.0 * k4 * x**3 + 2.0 * k2 * x + k1\n    F = -dE_dx\n    return E, F\n\ndef learning_curve_min_N(domain, E_F_func, epsilon, N_candidates, M_total=20, lam=1e-8, T=1000):\n    # Construct basis\n    centers, sigma = make_basis(domain, M_total)\n    # Test grid\n    x_test = np.linspace(domain[0], domain[1], T)\n    E_true_test, _ = E_F_func(x_test)\n    # Iterate over candidate N\n    N_min_E = -1\n    N_min_F = -1\n    for N in N_candidates:\n        x_train = np.linspace(domain[0], domain[1], N)\n        E_train, F_train = E_F_func(x_train)\n        Phi, G = build_design_matrices(x_train, centers, sigma)\n        # Solve ridge for energies\n        w_E = solve_ridge(Phi, E_train, lam)\n        # Solve ridge for forces\n        w_F = solve_ridge(G, F_train, lam)\n        # Evaluate MAE on test\n        E_pred_E = eval_energy_model(x_test, w_E, centers, sigma)\n        E_pred_F = eval_energy_model(x_test, w_F, centers, sigma)\n        mae_E = np.mean(np.abs(E_pred_E - E_true_test))\n        mae_F = np.mean(np.abs(E_pred_F - E_true_test))\n        if N_min_E == -1 and mae_E = epsilon:\n            N_min_E = N\n        if N_min_F == -1 and mae_F = epsilon:\n            N_min_F = N\n        # Early stop if both found\n        if (N_min_E != -1) and (N_min_F != -1):\n            break\n    # Ratio\n    if N_min_E > 0 and N_min_F > 0:\n        r = float(N_min_E) / float(N_min_F)\n    else:\n        r = -1.0\n    return N_min_E, N_min_F, r\n\ndef solve():\n    # Define test cases as specified\n    N_candidates = [8, 12, 16, 24, 32, 48, 64, 96, 128]\n    tests = [\n        # Test 1: Double well with tilt\n        {\n            \"domain\": (-1.5, 1.5),\n            \"E_F_func\": pes_double_well,\n            \"epsilon\": 4e-3\n        },\n        # Test 2: Morse-like bond\n        {\n            \"domain\": (0.5, 3.0),\n            \"E_F_func\": pes_morse,\n            \"epsilon\": 3e-3\n        },\n        # Test 3: Single-well anharmonic\n        {\n            \"domain\": (-1.2, 1.2),\n            \"E_F_func\": pes_anharmonic,\n            \"epsilon\": 5e-3\n        }\n    ]\n    results = []\n    for t in tests:\n        NE, NF, r = learning_curve_min_N(\n            domain=t[\"domain\"],\n            E_F_func=t[\"E_F_func\"],\n            epsilon=t[\"epsilon\"],\n            N_candidates=N_candidates,\n            M_total=20,\n            lam=1e-8,\n            T=1000\n        )\n        # Round ratio for cleaner output while keeping as float\n        if r >= 0:\n            r_out = round(r, 6)\n        else:\n            r_out = -1.0\n        results.append([NE, NF, r_out])\n    # Final print statement in the exact required format.\n    # Format as a single-line list of lists.\n    # Example format: [[NE1,NF1,r1],[NE2,NF2,r2],[NE3,NF3,r3]]\n    # Avoid spaces to match strict parsing; but problem allows spaces as in example.\n    # We'll include minimal spaces as shown.\n    inner = \",\".join(\"[\" + \",\".join(str(x) for x in triplet) + \"]\" for triplet in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903774"}, {"introduction": "一个训练好的机器学习势函数若要具备实用价值，其预测结果必须遵循基本的物理学定律。在经典力学和 Born-Oppenheimer 近似下，源于标量势能面的力场必须是保守的，这意味着其旋度处处为零。本练习将指导您设计一个数值测试，通过计算预测力场沿闭合路径的环路积分来检验其保守性，这不仅是验证模型物理真实性的重要手段，也是诊断和理解模型误差来源的有力工具，对于确保分子动力学模拟等应用的能量守恒至关重要 [@problem_id:2903810]。", "problem": "考虑一个在 Born–Oppenheimer 势能面 (PES) 上训练的机器学习 (ML) 模型所预测的二维构型空间中的原子间力场。在 Born–Oppenheimer 近似中，核力是标量势能的负梯度，因此精确的力场是保守的：对于任何闭合回路，力的环路积分为零。你需要设计一个保守性数值测试，通过计算预测力沿闭合回路的环路积分，并通过环流-面积关系量化旋度误差。\n\n对于每个测试用例，你的程序必须执行以下操作：\n- 使用 $N$ 个均匀间隔的采样点，在 $[0,2\\pi]$ 区间内以角度 $\\theta$（单位为弧度）参数化一个以原点为中心、半径为 $R$ 的圆形回路。参数化形式为 $r(\\theta) = \\big(R\\cos\\theta, R\\sin\\theta\\big)$，其微分为 $dr = r'(\\theta)\\,d\\theta = \\big(-R\\sin\\theta, R\\cos\\theta\\big)\\,d\\theta$。\n- 通过对被积函数 $g(\\theta) = \\mathbf{F}\\big(r(\\theta)\\big)\\cdot r'(\\theta)$ 应用关于 $\\theta$ 的复合梯形法则，数值近似计算环路积分（功）$W = \\oint_{\\mathcal{C}} \\mathbf{F}(\\mathbf{r})\\cdot d\\mathbf{l}$。\n- 计算面积平均标量旋度（z 分量）$\\bar{\\omega}_z = \\dfrac{1}{A}\\oint_{\\mathcal{C}} \\mathbf{F}\\cdot d\\mathbf{l}$，其中 $A = \\pi R^2$ 是回路面积。将 $W$ 解释为能量（单位为 Hartree），将 $\\bar{\\omega}_z$ 解释为 Hartree 每平方 Bohr，二者均使用原子单位，并报告这两个量。角度必须以弧度为单位。\n\n使用以下 ML 预测的力场。设保守参考势为\n$$\nE(x,y) = \\tfrac{1}{2}k(x^2+y^2) + a\\,x\\,y,\n$$\n其中 $k = 1.0$，$a = 0.3$（在原子单位中为无量纲）。定义保守力 $\\mathbf{F}_{\\mathrm{cons}}(x,y) = -\\nabla E(x,y)$，因此\n$$\nF_{x,\\mathrm{cons}}(x,y) = -k\\,x - a\\,y,\\quad F_{y,\\mathrm{cons}}(x,y) = -k\\,y - a\\,x.\n$$\n定义两个旨在模拟 ML 模型误差的非保守微扰：\n- 均匀旋转分量 $\\mathbf{R}_1(x,y) = \\big(-y,\\; x\\big)$，强度 $\\varepsilon = 10^{-3}$。\n- 空间变化的旋转分量 $\\mathbf{R}_2(x,y) = \\big(-y\\,(1+\\beta x^2),\\; x\\,(1+\\beta y^2)\\big)$，强度 $\\varepsilon = 5\\times 10^{-4}$，$\\beta = 0.4$。\n\n构建以下预测力场：\n- $\\mathcal{F}_1(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y)$\n- $\\mathcal{F}_2(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) + \\varepsilon\\,\\mathbf{R}_1(x,y)$\n- $\\mathcal{F}_4(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) + \\varepsilon\\,\\mathbf{R}_2(x,y)$\n\n你的程序必须为以下这套回路半径和采样点数的测试用例评估这些量：\n- 测试用例 1：力场 $\\mathcal{F}_1$，$R = 0.5$ Bohr，$N = 4096$ 个采样点。\n- 测试用例 2：力场 $\\mathcal{F}_2$，$R = 1.0$ Bohr，$N = 8192$ 个采样点。\n- 测试用例 3：力场 $\\mathcal{F}_2$，$R = 2.0$ Bohr，$N = 8192$ 个采样点。\n- 测试用例 4：力场 $\\mathcal{F}_4$，$R = 1.5$ Bohr，$N = 16384$ 个采样点。\n\n对于每个测试用例，计算：\n- 环路积分 $W$（单位为 Hartree）。\n- 面积平均旋度 $\\bar{\\omega}_z$（单位为 Hartree 每平方 Bohr）。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，各项按顺序为 $[W_1,\\bar{\\omega}_{z,1},W_2,\\bar{\\omega}_{z,2},W_3,\\bar{\\omega}_{z,3},W_4,\\bar{\\omega}_{z,4}]$。所有角度必须以弧度为单位，能量必须以 Hartree 表示。不应打印任何额外文本。", "solution": "目标是量化几种模型力场的非保守特性。一个力场 $\\mathbf{F}$ 是保守的，当且仅当它是一个标量势的梯度，$\\mathbf{F} = -\\nabla E$。一个直接的推论是其旋度为零，$\\nabla \\times \\mathbf{F} = \\mathbf{0}$。对于一个二维场 $\\mathbf{F}(x,y) = (F_x(x,y), F_y(x,y))$，其旋度是一个只有 z 分量的矢量，$(\\nabla \\times \\mathbf{F})_z = \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y}$。\n\n斯托克斯定理将矢量场沿简单闭合曲线 $\\mathcal{C}$ 的环路积分（环流）与该场的旋度在曲线所围面积 $A$ 上的面积分联系起来：\n$$\nW = \\oint_{\\mathcal{C}} \\mathbf{F} \\cdot d\\mathbf{l} = \\iint_{A} (\\nabla \\times \\mathbf{F}) \\cdot d\\mathbf{A} = \\iint_{A} (\\nabla \\times \\mathbf{F})_z \\,dx\\,dy\n$$\n对于保守场，$W=0$。非零的 $W$ 值表示这是一个非保守场。待计算的量，即面积平均标量旋度 $\\bar{\\omega}_z$，就是根据此定理定义的：\n$$\n\\bar{\\omega}_z = \\frac{1}{A} \\oint_{\\mathcal{C}} \\mathbf{F} \\cdot d\\mathbf{l}\n$$\n这提供了一个直接衡量力场在所围面积上平均非保守旋转特性的指标。\n\n问题要求对环路积分进行数值计算。路径 $\\mathcal{C}$ 是一个以原点为中心、半径为 $R$ 的圆，由角度 $\\theta \\in [0, 2\\pi]$ 参数化：\n$$\n\\mathbf{r}(\\theta) = (x(\\theta), y(\\theta)) = (R\\cos\\theta, R\\sin\\theta)\n$$\n微分线元为：\n$$\nd\\mathbf{l} = \\mathbf{r}'(\\theta) d\\theta = (-R\\sin\\theta, R\\cos\\theta) d\\theta\n$$\n因此，环路积分被转换为关于 $\\theta$ 的定积分：\n$$\nW = \\int_{0}^{2\\pi} \\mathbf{F}(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta) \\, d\\theta\n$$\n设被积函数为 $g(\\theta) = \\mathbf{F}(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$。我们需要使用复合梯形法则和 $N$ 个采样点来近似计算 $W = \\int_{0}^{2\\pi} g(\\theta) d\\theta$。对于一个周期函数在其周期上的积分，该法则简化为对均匀间隔点 $\\theta_i = i \\cdot \\Delta\\theta$ 的求和，其中 $\\Delta\\theta = 2\\pi/N$，$i=0, 1, \\dots, N-1$。\n$$\nW \\approx \\Delta\\theta \\sum_{i=0}^{N-1} g(\\theta_i) = \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} g(\\theta_i)\n$$\n我们现在为每个特定的力场定义被积函数 $g(\\theta)$。常数为 $k=1.0$ 和 $a=0.3$。\n\n**力场 $\\mathcal{F}_1$**：该力场根据定义是保守的。\n$\\mathcal{F}_1(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) = (-kx - ay, -ky - ax)$。\n代入参数化 $x=R\\cos\\theta, y=R\\sin\\theta$ 并与 $\\mathbf{r}'(\\theta) = (-R\\sin\\theta, R\\cos\\theta)$ 作点积：\n$$\n\\begin{align*}\ng_1(\\theta) = (-kR\\cos\\theta - aR\\sin\\theta)(-R\\sin\\theta) + (-kR\\sin\\theta - aR\\cos\\theta)(R\\cos\\theta) \\\\\n= R^2(k\\cos\\theta\\sin\\theta + a\\sin^2\\theta) - R^2(k\\sin\\theta\\cos\\theta + a\\cos^2\\theta) \\\\\n= aR^2(\\sin^2\\theta - \\cos^2\\theta) = -aR^2\\cos(2\\theta)\n\\end{align*}\n$$\n解析积分为 $\\int_0^{2\\pi} -aR^2\\cos(2\\theta) \\,d\\theta = 0$。数值计算结果应接近机器精度。\n\n**力场 $\\mathcal{F}_2$**：该力场包含一个均匀旋转微扰。$\\mathcal{F}_2 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon_1 \\mathbf{R}_1$，其中 $\\varepsilon_1 = 10^{-3}$。\n环路积分是线性的，所以 $W_2 = \\oint \\mathbf{F}_{\\mathrm{cons}} \\cdot d\\mathbf{l} + \\varepsilon_1 \\oint \\mathbf{R}_1 \\cdot d\\mathbf{l}$。第一项为零。\n微扰的被积函数是 $\\varepsilon_1 \\mathbf{R}_1(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$。\n对于 $\\mathbf{R}_1(x,y) = (-y, x)$，在路径上我们有 $\\mathbf{R}_1(\\mathbf{r}(\\theta)) = (-R\\sin\\theta, R\\cos\\theta) = \\mathbf{r}'(\\theta)$。\n因此，被积函数是 $\\varepsilon_1 \\mathbf{r}'(\\theta) \\cdot \\mathbf{r}'(\\theta) = \\varepsilon_1 |\\mathbf{r}'(\\theta)|^2 = \\varepsilon_1 R^2$。\n总被积函数是 $g_2(\\theta) = -aR^2\\cos(2\\theta) + \\varepsilon_1 R^2$。解析积分为 $W_2 = 2\\pi\\varepsilon_1 R^2$。\n面积平均旋度为 $\\bar{\\omega}_{z,2} = W_2 / (\\pi R^2) = 2\\varepsilon_1$。\n\n**力场 $\\mathcal{F}_4$**：该力场包含一个空间变化的旋转微扰。$\\mathcal{F}_4 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon_2 \\mathbf{R}_2$，其中 $\\varepsilon_2 = 5 \\times 10^{-4}, \\beta=0.4$。\n同样，我们关注微扰项的积分。被积函数是 $\\varepsilon_2 \\mathbf{R}_2(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$。\n$\\mathbf{R}_2(x,y) = (-y(1+\\beta x^2), x(1+\\beta y^2))$。\n$$\n\\begin{align*}\n\\mathbf{R}_2 \\cdot \\mathbf{r}' = \\varepsilon_2 [ (-y(1+\\beta x^2))(-R\\sin\\theta) + (x(1+\\beta y^2))(R\\cos\\theta) ] \\\\\n= \\varepsilon_2 [ (R\\sin\\theta(1+\\beta R^2\\cos^2\\theta))(R\\sin\\theta) + (R\\cos\\theta(1+\\beta R^2\\sin^2\\theta))(R\\cos\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ \\sin^2\\theta(1+\\beta R^2\\cos^2\\theta) + \\cos^2\\theta(1+\\beta R^2\\sin^2\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ \\sin^2\\theta+\\cos^2\\theta + \\beta R^2(\\sin^2\\theta\\cos^2\\theta + \\cos^2\\theta\\sin^2\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ 1 + 2\\beta R^2 \\sin^2\\theta\\cos^2\\theta ] = \\varepsilon_2 R^2 [ 1 + \\frac{1}{2}\\beta R^2 \\sin^2(2\\theta) ]\n\\end{align*}\n$$\n总被积函数是 $g_4(\\theta) = -aR^2\\cos(2\\theta) + \\varepsilon_2 R^2 [ 1 + \\frac{1}{2}\\beta R^2 \\sin^2(2\\theta) ]$。\n解析上，使用 $\\int_0^{2\\pi} \\sin^2(2\\theta)d\\theta = \\pi$，积分为 $W_4 = \\varepsilon_2 R^2 [ 2\\pi + \\frac{1}{2}\\beta R^2 \\pi ] = 2\\pi\\varepsilon_2 R^2 (1 + \\frac{1}{4}\\beta R^2)$。\n面积平均旋度为 $\\bar{\\omega}_{z,4} = W_4 / (\\pi R^2) = 2\\varepsilon_2(1 + \\frac{1}{4}\\beta R^2)$。\n\n数值代码将为每个指定的测试用例实现这些被积函数的梯形法则求和，然后计算面积平均旋度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the line integral of model force fields around a circular loop\n    to test for non-conservative character.\n    \"\"\"\n\n    # --- Define Constants and Force Fields ---\n\n    # Physical constants in atomic units\n    K_CONST = 1.0\n    A_CONST = 0.3\n    \n    # Perturbation parameters\n    EPS1 = 1e-3\n    EPS2 = 5e-4\n    BETA = 0.4\n\n    def f1_field(x, y):\n        \"\"\"Conservative reference force field F_cons.\"\"\"\n        fx = -K_CONST * x - A_CONST * y\n        fy = -K_CONST * y - A_CONST * x\n        return fx, fy\n\n    def f2_field(x, y):\n        \"\"\"F_cons + uniform rotational perturbation.\"\"\"\n        fx_cons = -K_CONST * x - A_CONST * y\n        fy_cons = -K_CONST * y - A_CONST * x\n        \n        # Perturbation R1 = (-y, x)\n        fx_pert = -y\n        fy_pert = x\n        \n        return fx_cons + EPS1 * fx_pert, fy_cons + EPS1 * fy_pert\n\n    def f4_field(x, y):\n        \"\"\"F_cons + spatially varying rotational perturbation.\"\"\"\n        fx_cons = -K_CONST * x - A_CONST * y\n        fy_cons = -K_CONST * y - A_CONST * x\n        \n        # Perturbation R2 = (-y(1+beta*x^2), x(1+beta*y^2))\n        fx_pert = -y * (1 + BETA * x**2)\n        fy_pert = x * (1 + BETA * y**2)\n        \n        return fx_cons + EPS2 * fx_pert, fy_cons + EPS2 * fy_pert\n    \n    # --- Define Test Cases ---\n\n    test_cases = [\n        {'field_func': f1_field, 'R': 0.5, 'N': 4096, 'label': 'F1'},\n        {'field_func': f2_field, 'R': 1.0, 'N': 8192, 'label': 'F2_R1'},\n        {'field_func': f2_field, 'R': 2.0, 'N': 8192, 'label': 'F2_R2'},\n        {'field_func': f4_field, 'R': 1.5, 'N': 16384, 'label': 'F4'},\n    ]\n\n    all_results = []\n    \n    # --- Execute Calculations for Each Case ---\n\n    for case in test_cases:\n        field_func = case['field_func']\n        R = case['R']\n        N = case['N']\n\n        # 1. Parameterize the circular loop with N samples\n        # The composite trapezoidal rule for a periodic function is a simple sum\n        # over N points.\n        d_theta = 2.0 * np.pi / N\n        thetas = np.arange(0.0, 2.0 * np.pi, d_theta)\n\n        # Path coordinates r(theta) = (x(theta), y(theta))\n        x_coords = R * np.cos(thetas)\n        y_coords = R * np.sin(thetas)\n\n        # Path derivative r'(theta) = (dx/dtheta, dy/dtheta)\n        dr_x = -R * np.sin(thetas)\n        dr_y = R * np.cos(thetas)\n\n        # 2. Evaluate the force field F(r(theta)) on the path\n        fx_vals, fy_vals = field_func(x_coords, y_coords)\n\n        # 3. Compute the integrand g(theta) = F(r(theta)) . r'(theta)\n        integrand = fx_vals * dr_x + fy_vals * dr_y\n\n        # 4. Numerically approximate the line integral W using the trapezoidal rule\n        # W = integral from 0 to 2pi of g(theta) dtheta\n        W = np.sum(integrand) * d_theta\n        \n        # 5. Compute the area-averaged scalar curl\n        A = np.pi * R**2\n        omega_z = W / A\n\n        all_results.extend([W, omega_z])\n\n    # --- Format and Print Final Output ---\n    \n    # Format the results into a single string as specified.\n    # [W_1, omega_z_1, W_2, omega_z_2, ...]\n    formatted_results = f\"[{','.join(f'{r:.10f}' for r in all_results)}]\"\n    print(formatted_results)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903810"}]}