{"hands_on_practices": [{"introduction": "埃伦费斯特定理建立了量子期望值与经典运动定律之间的深刻联系。然而，对于非谐势，力的期望值 $\\langle F(\\hat{x}) \\rangle$ 与波包中心的经典力 $F(\\langle \\hat{x} \\rangle)$ 并不相同。本练习 [@problem_id:437308] 让你能够亲手计算这个关键的差异——即主导阶的量子修正——从而揭示波包的有限尺寸如何探测势能的曲率，并导致其轨迹偏离纯粹的经典路径。", "problem": "在对应原理的框架下，埃伦费斯特定理保证了对于一个足够局域的波包，量子算符的期望值会遵循经典运动方程演化。对于一个质量为 $m$ 的粒子在一维势 $V(x)$ 中运动，其动量演化的定理为 $\\frac{d\\langle \\hat{p} \\rangle}{dt} = \\langle F(\\hat{x}) \\rangle$，其中 $F(x) = -dV/dx$ 是经典力函数。\n\n对于一个一般的非谐势，力的期望值 $\\langle F(\\hat{x}) \\rangle$ 不等于在波包中心处计算的经典力 $F_{cl} = F(\\langle \\hat{x} \\rangle)$。这种差异产生了量子修正，它会修正波包中心的经典轨道。\n\n考虑一个质量为 $m$ 的粒子，被制备在一个固有频率为 $\\omega_0$ 的简谐振子的相干态上。在某一特定时刻，该状态由一个位置期望值为 $\\langle \\hat{x} \\rangle = x_0$ 的波包所描述。该粒子处在一个由下式给出的外加非谐势中：\n$$V(x) = c_2 x^2 + c_3 x^3 + c_4 x^4$$\n其中 $c_2, c_3,$ 和 $c_4$ 是常数。\n\n计算对经典力的领头阶量子修正，其定义为 $\\delta F = \\langle F(\\hat{x}) \\rangle - F_{cl}$。请用 $m, \\hbar, \\omega_0, c_3, c_4,$ 和 $x_0$ 来表示你的答案。", "solution": "1. 动量的埃伦费斯特定理：\n$$\\frac{d\\langle \\hat p\\rangle}{dt}=\\langle F(\\hat x)\\rangle,\\quad F(x)=-\\frac{dV}{dx}.$$\n\n2. 对于 $V(x)=c_2x^2+c_3x^3+c_4x^4$,\n$$F(\\hat x)=-\\bigl(2c_2\\hat x+3c_3\\hat x^2+4c_4\\hat x^3\\bigr).$$\n在 $\\langle\\hat x\\rangle=x_0$ 处的经典力：\n$$F_{cl}=-\\bigl(2c_2x_0+3c_3x_0^2+4c_4x_0^3\\bigr).$$\n\n3. 量子修正：\n$$\\delta F=\\langle F(\\hat x)\\rangle-F_{cl}\n=-3c_3\\bigl(\\langle\\hat x^2\\rangle-x_0^2\\bigr)\n-4c_4\\bigl(\\langle\\hat x^3\\rangle-x_0^3\\bigr).$$\n\n4. 对于频率为 $\\omega_0$ 的简谐振子的相干态，\n$\\text{Var}(x)=\\langle(\\hat x-x_0)^2\\rangle=\\frac{\\hbar}{2m\\omega_0}$，\n并且 $\\langle\\hat x^3\\rangle-x_0^3=3x_0\\,\\text{Var}(x)$。\n因此\n$$\\delta F\n=-3c_3\\frac{\\hbar}{2m\\omega_0}\n-4c_4\\bigl(3x_0\\frac{\\hbar}{2m\\omega_0}\\bigr)\n=-\\frac{\\hbar}{2m\\omega_0}\\bigl(3c_3+12c_4x_0\\bigr)\n=-\\frac{3\\hbar}{2m\\omega_0}(c_3+4c_4x_0).$$", "answer": "$$\\boxed{-\\frac{3\\hbar}{2m\\omega_0}\\bigl(c_3+4c_4x_0\\bigr)}$$", "id": "437308"}, {"introduction": "既然我们已经看到在任何给定时刻都存在对经典力的量子修正，一个自然的问题是：这种偏差随时间累积的效应是什么？本实践问题 [@problem_id:2879554] 将指导你通过微扰分析，在一个简单的非谐势中，计算量子波包中心与其经典对应物之间长期存在的、非振荡的（或“久期”）漂移。通过解决这个问题，你将更深入地理解量子效应如何导致在宏观时间尺度上与经典预测的系统性偏离。", "problem": "一个质量为 $m$ 的非相对论粒子在一维势 $V(x)=\\tfrac{1}{2}m\\omega^{2}x^{2}+\\lambda x^{3}$ 中运动，其中 $|\\lambda|$ 足够小以至于关于 $\\lambda$ 的微扰理论是有效的。在 $t=0$ 时，其量子态是一个中心位于位置 $x_{0}$、平均动量为 $p_{0}$ 的最小不确定性高斯波包（谐振子的相干态），其位置方差为 $\\Delta x^{2}=\\hbar/(2m\\omega)$。考虑一个从相同初始条件 $x_{\\mathrm{cl}}(0)=x_{0}$ 和 $p_{\\mathrm{cl}}(0)=p_{0}$ 出发，并根据 Newton 第二定律演化的相应经典粒子。\n\n从含时 Schrödinger 方程以及 $\\hat{x}$ 和 $\\hat{p}$ 的正则对易关系出发，并且仅使用关于 $\\lambda$ 的一阶微扰理论，推导量子期望值 $\\langle \\hat{x}(t)\\rangle$ 的运动方程，并将其与经典轨迹 $x_{\\mathrm{cl}}(t)$ 进行比较。定义偏差 $\\delta(t)\\equiv\\langle \\hat{x}(t)\\rangle-x_{\\mathrm{cl}}(t)$，并将领头阶长期漂移 $\\delta_{\\mathrm{sec}}$ 定义为在仅保留 $\\lambda$ 的领头项的极限下，对 $\\delta(t)$ 在一个周期 $T=2\\pi/\\omega$ 内取平均得到的非振荡部分。\n\n对指定的初始高斯波包，计算 $\\delta_{\\mathrm{sec}}$ 到 $\\lambda$ 的一阶，并将最终结果表示为包含 $\\lambda$、$\\hbar$、$m$ 和 $\\omega$ 的闭合形式解析表达式。无需进行数值计算，也无需四舍五入。最终答案必须是单一的解析表达式。", "solution": "算符 $\\hat{A}$ 期望值的时间演化由 Ehrenfest 定理决定，该定理从含时 Schrödinger 方程推导而来。对于一个没有显含时依赖的算符，其运动方程为：\n$$ \\frac{d}{dt}\\langle \\hat{A} \\rangle = \\frac{i}{\\hbar} \\langle [\\hat{H}, \\hat{A}] \\rangle $$\n系统的哈密顿量由 $\\hat{H} = \\frac{\\hat{p}^{2}}{2m} + V(\\hat{x})$ 给出，其中 $V(\\hat{x}) = \\frac{1}{2}m\\omega^{2}\\hat{x}^{2} + \\lambda\\hat{x}^{3}$。我们使用正则对易关系 $[\\hat{x}, \\hat{p}] = i\\hbar$。\n\n首先，我们求出位置期望值 $\\langle \\hat{x} \\rangle$ 的运动方程：\n$$ \\frac{d}{dt}\\langle \\hat{x} \\rangle = \\frac{i}{\\hbar} \\langle [\\hat{H}, \\hat{x}] \\rangle = \\frac{i}{\\hbar} \\left\\langle \\left[\\frac{\\hat{p}^{2}}{2m}, \\hat{x}\\right] \\right\\rangle = \\frac{i}{2m\\hbar} \\langle \\hat{p}[\\hat{p}, \\hat{x}] + [\\hat{p}, \\hat{x}]\\hat{p} \\rangle = \\frac{i}{2m\\hbar} \\langle \\hat{p}(-i\\hbar) + (-i\\hbar)\\hat{p} \\rangle = \\frac{\\langle \\hat{p} \\rangle}{m} $$\n这个结果是精确的，并且对任何势都成立。\n\n接着，我们求出动量期望值 $\\langle \\hat{p} \\rangle$ 的运动方程：\n$$ \\frac{d}{dt}\\langle \\hat{p} \\rangle = \\frac{i}{\\hbar} \\langle [\\hat{H}, \\hat{p}] \\rangle = \\frac{i}{\\hbar} \\langle [V(\\hat{x}), \\hat{p}] \\rangle $$\n使用恒等式 $[f(\\hat{x}), \\hat{p}] = i\\hbar \\frac{\\partial f}{\\partial \\hat{x}}$，我们得到：\n$$ \\frac{d}{dt}\\langle \\hat{p} \\rangle = \\left\\langle -\\frac{\\partial V}{\\partial \\hat{x}} \\right\\rangle = \\langle -m\\omega^{2}\\hat{x} - 3\\lambda\\hat{x}^{2} \\rangle = -m\\omega^{2}\\langle \\hat{x} \\rangle - 3\\lambda\\langle \\hat{x}^{2} \\rangle $$\n通过对 $\\langle \\hat{x} \\rangle$ 的方程求时间导数，我们将两个一阶方程结合起来：\n$$ m\\frac{d^{2}}{dt^{2}}\\langle \\hat{x} \\rangle = \\frac{d}{dt}\\langle \\hat{p} \\rangle = -m\\omega^{2}\\langle \\hat{x} \\rangle - 3\\lambda\\langle \\hat{x}^{2} \\rangle $$\n这给出了 $\\langle\\hat{x}\\rangle$ 的精确量子运动方程：\n$$ \\frac{d^{2}}{dt^{2}}\\langle \\hat{x} \\rangle + \\omega^{2}\\langle \\hat{x} \\rangle = -\\frac{3\\lambda}{m}\\langle \\hat{x}^{2} \\rangle $$\n我们使用位置方差 $(\\Delta x)^{2} = \\langle \\hat{x}^{2} \\rangle - \\langle \\hat{x} \\rangle^{2}$ 来关联 $\\langle \\hat{x}^{2} \\rangle$ 和 $\\langle \\hat{x} \\rangle$：\n$$ \\frac{d^{2}}{dt^{2}}\\langle \\hat{x} \\rangle + \\omega^{2}\\langle \\hat{x} \\rangle = -\\frac{3\\lambda}{m} \\left( \\langle \\hat{x} \\rangle^{2} + (\\Delta x)^{2} \\right) $$\n\n作为比较，经典运动方程由 Newton 第二定律 $F = -\\frac{dV}{dx}$ 推导得出：\n$$ m\\frac{d^{2}x_{\\mathrm{cl}}}{dt^{2}} = -m\\omega^{2}x_{\\mathrm{cl}} - 3\\lambda x_{\\mathrm{cl}}^{2} $$\n因此，经典方程为：\n$$ \\frac{d^{2}x_{\\mathrm{cl}}}{dt^{2}} + \\omega^{2}x_{\\mathrm{cl}} = -\\frac{3\\lambda}{m}x_{\\mathrm{cl}}^{2} $$\n\n为了求出偏差 $\\delta(t) = \\langle \\hat{x}(t) \\rangle - x_{\\mathrm{cl}}(t)$ 到 $\\lambda$ 的一阶，我们使用微扰理论。设 $\\langle \\hat{x}(t) \\rangle = x_{q}^{(0)}(t) + \\lambda x_{q}^{(1)}(t) + O(\\lambda^{2})$ 以及 $x_{\\mathrm{cl}}(t) = x_{c}^{(0)}(t) + \\lambda x_{c}^{(1)}(t) + O(\\lambda^{2})$。\n\n在零阶（$\\lambda=0$）时，量子期望值和经典位置的方程是相同的：\n$$ \\frac{d^{2}x^{(0)}}{dt^{2}} + \\omega^{2}x^{(0)} = 0 $$\n在相同的初始条件 $x(0)=x_{0}$ 和 $\\dot{x}(0)=p_{0}/m$ 下，零阶解是相同的：$x_{q}^{(0)}(t) = x_{c}^{(0)}(t)$。让我们将这个共同解表示为 $x^{(0)}(t) = x_{0}\\cos(\\omega t) + \\frac{p_{0}}{m\\omega}\\sin(\\omega t)$。\n对于未受微扰的谐振子，初始态是一个相干态，在时间演化下它仍然保持为相干态。相干态的一个定义性属性是其方差是恒定且最小的：对于所有时间 $t$，$(\\Delta x(t))^{2} = (\\Delta x(0))^{2} = \\frac{\\hbar}{2m\\omega}$。到 $\\lambda$ 的一阶，我们用这个零阶结果来近似 $(\\Delta x(t))^{2}$。\n\n现在我们收集 $\\lambda$ 的一阶项。\n对于量子方程：\n$$ \\lambda\\frac{d^{2}x_{q}^{(1)}}{dt^{2}} + \\lambda\\omega^{2}x_{q}^{(1)} = -\\frac{3\\lambda}{m} \\left( (x_{q}^{(0)})^{2} + \\frac{\\hbar}{2m\\omega} \\right) $$\n对于经典方程：\n$$ \\lambda\\frac{d^{2}x_{c}^{(1)}}{dt^{2}} + \\lambda\\omega^{2}x_{c}^{(1)} = -\\frac{3\\lambda}{m}(x_{c}^{(0)})^{2} $$\n一阶偏差为 $\\delta^{(1)}(t) = \\lambda(x_{q}^{(1)}(t) - x_{c}^{(1)}(t))$。从量子方程中减去经典方程（并使用 $x_{q}^{(0)} = x_{c}^{(0)}$）得到 $\\delta^{(1)}(t)$ 的方程：\n$$ \\frac{d^{2}\\delta^{(1)}}{dt^{2}} + \\omega^{2}\\delta^{(1)} = -\\frac{3\\lambda}{m} \\left(\\frac{\\hbar}{2m\\omega}\\right) = -\\frac{3\\lambda\\hbar}{2m^{2}\\omega} $$\n这是一个带有常数驱动项的二阶非齐次微分方程。初始条件为 $\\delta(0) = \\langle \\hat{x}(0) \\rangle - x_{\\mathrm{cl}}(0) = x_{0} - x_{0} = 0$ 和 $\\dot{\\delta}(0) = \\frac{\\langle \\hat{p}(0) \\rangle}{m} - \\frac{p_{\\mathrm{cl}}(0)}{m} = \\frac{p_{0}}{m} - \\frac{p_{0}}{m} = 0$。这些零初始条件也适用于 $\\delta^{(1)}(t)$。\n通解的形式为 $\\delta^{(1)}(t) = A\\cos(\\omega t) + B\\sin(\\omega t) + \\delta_{p}$，其中 $\\delta_{p}$ 是一个特解。对于常数驱动项，特解本身也是一个常数：\n$$ \\delta_{p} = \\frac{1}{\\omega^{2}} \\left(-\\frac{3\\lambda\\hbar}{2m^{2}\\omega}\\right) = -\\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}} $$\n应用初始条件 $\\delta^{(1)}(0) = 0$：\n$$ A + \\delta_{p} = 0 \\implies A = -\\delta_{p} = \\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}} $$\n应用初始条件 $\\dot{\\delta}^{(1)}(0) = 0$：\n$$ \\dot{\\delta}^{(1)}(t) = -A\\omega\\sin(\\omega t) + B\\omega\\cos(\\omega t) \\implies \\dot{\\delta}^{(1)}(0) = B\\omega = 0 \\implies B=0 $$\n因此，到 $\\lambda$ 一阶的偏差为：\n$$ \\delta(t) \\approx \\delta^{(1)}(t) = \\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}}\\cos(\\omega t) - \\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}} $$\n长期漂移 $\\delta_{\\mathrm{sec}}$ 定义为此表达式的非振荡部分。这就是常数项。或者，可以在一个周期 $T=2\\pi/\\omega$ 内对 $\\delta(t)$ 进行平均：\n$$ \\delta_{\\mathrm{sec}} = \\frac{1}{T}\\int_{0}^{T} \\delta^{(1)}(t) dt = \\frac{1}{T}\\int_{0}^{T} \\left( -\\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}} + \\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}}\\cos(\\omega t) \\right) dt $$\n$\\cos(\\omega t)$ 在一个周期内的积分为零，剩下：\n$$ \\delta_{\\mathrm{sec}} = \\frac{1}{T} \\left( -\\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}} \\right) T = -\\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}} $$\n这就是位置的量子期望值相对于经典轨迹的领头阶长期漂移。", "answer": "$$\\boxed{-\\frac{3\\lambda\\hbar}{2m^{2}\\omega^{3}}}$$", "id": "2879554"}, {"introduction": "经典对应原理构成了诸如*从头算*分子动力学（AIMD）等强大模拟方法的基石，在这些方法中，原子核被当作在量子力学计算出的力场中运动的经典粒子。本计算练习 [@problem_id:2879538] 探讨了一个关键的实际问题：当这些力被近似计算时（特别是忽略了因基组的位置依赖性而产生的普莱力），会导致能量不守恒。通过实现一个玩具模型，你将用数值方法验证这种能量漂移，并检验一个基于维里定理的诊断方法，从而将抽象的埃伦费斯特定理与现代计算化学中的具体挑战和质量控制联系起来。", "problem": "考虑一个一维从头算分子动力学（AIMD）玩具模型，旨在测试在基组不完备性存在的情况下，经典对应和 Ehrenfest 定理。核自由度是一个单一坐标 $R(t)$，质量为 $M$，根据牛顿第二定律 $M \\ddot{R}(t) = F(R(t))$ 进行传播。势能面由一个谐振核项和一个依赖于位置的基组参数的近似电子项之和构成。具体而言：\n- 核项为 $V_{\\mathrm{nuc}}(R) = \\tfrac{1}{2} k R^2$。\n- 电子项为 $E_{\\mathrm{el}}(R) = A \\exp(-b(R)) + B R^2 \\exp(-2 b(R))$。\n- 基组参数随位置变化，其关系为 $b(R) = b_0 + b_1 R^2$。\n- 总势能为 $U(R) = V_{\\mathrm{nuc}}(R) + E_{\\mathrm{el}}(R)$。\n\n将使用两种不同的力模型：\n- 完整的保守力 $F_{\\mathrm{full}}(R) = - \\dfrac{dU}{dR}$，它包括所有导数贡献，包括通过 $b(R)$ 产生的隐式 $R$-依赖性。\n- 忽略 Pulay 力的力 $F_{\\mathrm{noP}}(R) = - \\left.\\dfrac{\\partial U}{\\partial R}\\right|_{b(R)\\ \\mathrm{frozen}}$，它在求导时将 $b(R)$ 视为与 $R$ 无关，从而忽略了 Pulay 贡献。\n\n运动方程将使用速度-Verlet方案以固定的时间步长 $dt$ 进行积分。在每个时间步，计算总能量 $E(t) = \\tfrac{1}{2} M \\dot{R}(t)^2 + U(R(t))$。为了量化长时程的能量行为，通过以最小二乘法拟合一条直线 $E(t) \\approx m t + c$ 来提取能量漂移率，并报告拟合的斜率 $m$。\n\n为了提出并测试一个基于经典维里定理的诊断方法，使用保守力作用下束缚运动的时间平均关系，在一维情况下表示为 $2 \\langle T \\rangle + \\langle R F(R) \\rangle = 0$，其中 $T = \\tfrac{1}{2} M \\dot{R}^2$ 是动能。当使用任何力模型 $F_{\\ast}$ 时，定义以下基于维里的诊断量：\n$$\\Delta_{\\mathrm{vir}} = \\left| \\dfrac{\\overline{2 T + R F_{\\ast}}}{\\overline{2 T}} \\right|,$$\n其中上划线表示沿轨迹的简单时间平均。在谐振势中进行精确的保守动力学模拟时，$\\Delta_{\\mathrm{vir}}$ 应接近于零。偏差表明经典对应诊断的失效，例如由忽略 Pulay 力引起的失效。\n\n实现一个程序，该程序：\n- 对每个测试用例进行两次动力学积分，一次使用 $F_{\\mathrm{full}}$，一次使用 $F_{\\mathrm{noP}}$。\n- 计算使用 $F_{\\mathrm{full}}$ 时的能量漂移率 $m_{\\mathrm{full}}$ 和使用 $F_{\\mathrm{noP}}$ 时的能量漂移率 $m_{\\mathrm{noP}}$。\n- 使用由 $F_{\\mathrm{noP}}$ 生成的轨迹计算维里诊断量 $\\Delta_{\\mathrm{vir}}$。\n\n所有模拟都将在无量纲单位下进行。所有输出均报告为四舍五入到六位有效数字的十进制浮点数。\n\n你的推理和实现应仅基于基本原理：用于原子核的牛顿第二定律，证明使用经典轨迹处理与平均电子力耦合的核期望值是合理的 Ehrenfest 定理，以及经典维里定理。除上述定义外，不要假设任何额外的专门公式。\n\n测试套件（无量纲单位）：\n- 用例 $\\mathrm{A}$（预期无 Pulay 力）：$M = 1.0$, $k = 1.0$, $A = 0.10$, $B = 0.05$, $b_0 = 1.0$, $b_1 = 0.0$, $dt = 0.01$, 步数 $N = 20000$, 初始位置 $R(0) = 0.2$, 初始速度 $\\dot{R}(0) = 0.0$。\n- 用例 $\\mathrm{B}$（中等 Pulay 力）：$M = 1.0$, $k = 1.0$, $A = 0.10$, $B = 0.05$, $b_0 = 1.0$, $b_1 = 0.5$, $dt = 0.01$, 步数 $N = 20000$, 初始位置 $R(0) = 0.2$, 初始速度 $\\dot{R}(0) = 0.0$。\n- 用例 $\\mathrm{C}$（更强的 Pulay 力和更大的时间步长）：$M = 1.0$, $k = 1.0$, $A = 0.10$, $B = 0.05$, $b_0 = 1.0$, $b_1 = 1.2$, $dt = 0.02$, 步数 $N = 20000$, 初始位置 $R(0) = 0.2$, 初始速度 $\\dot{R}(0) = 0.0$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，包含一个由三个内部列表组成的列表，每个测试用例一个，顺序为 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$。每个内部列表必须按 $[m_{\\mathrm{noP}}, m_{\\mathrm{full}}, \\Delta_{\\mathrm{vir}}]$ 的顺序包含三个四舍五入到六位有效数字的浮点数。总格式必须严格为\n\"[[mA_noP,mA_full,DeltaA],[mB_noP,mB_full,DeltaB],[mC_noP,mC_full,DeltaC]]\"\n，位于单行上，无任何额外字符或空白。", "solution": "解决方案将基于问题陈述中概述的基本原理来构建。这包括推导必要的解析表达式，描述数值积分方案，并定义要计算的诊断指标。\n\n首先，我们将一维系统的总势能 $U(R)$ 定义为一个核谐振项 $V_{\\mathrm{nuc}}(R)$ 和一个电子项 $E_{\\mathrm{el}}(R)$ 的和：\n$$U(R) = V_{\\mathrm{nuc}}(R) + E_{\\mathrm{el}}(R) = \\frac{1}{2} k R^2 + A e^{-b(R)} + B R^2 e^{-2b(R)}$$\n依赖于位置的基组参数 $b(R)$ 由下式给出：\n$$b(R) = b_0 + b_1 R^2$$\n\n接下来，我们推导用于根据牛顿第二定律 $M\\ddot{R}(t) = F(R(t))$ 传播质量为 $M$ 的原子核的两种力模型。\n\n第一个模型是完整的保守力 $F_{\\mathrm{full}}(R)$，通过对势能 $U(R)$ 关于核坐标 $R$ 求负全导数得到。由于 $U$ 通过 $b(R)$ 隐式地依赖于 $R$，这需要应用链式法则。\n$b(R)$ 的导数是：\n$$\\frac{db}{dR} = \\frac{d}{dR}(b_0 + b_1 R^2) = 2 b_1 R$$\n总势能 $U(R)$ 的导数是：\n\\begin{align*}\n\\frac{dU}{dR} &= \\frac{d}{dR} \\left( \\frac{1}{2} k R^2 + A e^{-b(R)} + B R^2 e^{-2b(R)} \\right) \\\\\n&= kR + A e^{-b(R)} \\left(-\\frac{db}{dR}\\right) + \\left(2BR\\right)e^{-2b(R)} + B R^2 e^{-2b(R)} \\left(-2\\frac{db}{dR}\\right) \\\\\n&= kR - A(2b_1R)e^{-b(R)} + 2BR e^{-2b(R)} - 2BR^2(2b_1R)e^{-2b(R)} \\\\\n&= kR - 2Ab_1R e^{-b(R)} + 2BR e^{-2b(R)} - 4Bb_1R^3 e^{-2b(R)}\n\\end{align*}\n因此，完整的力是：\n$$F_{\\mathrm{full}}(R) = -\\frac{dU}{dR} = -kR + 2Ab_1R e^{-b(R)} - 2BR e^{-2b(R)} + 4Bb_1R^3 e^{-2b(R)}$$\n这个力是保守的，因为它是势能函数 $U(R)$ 的真实梯度。\n\n第二个模型是忽略 Pulay 力的力 $F_{\\mathrm{noP}}(R)$，它在从头算分子动力学中出现，当计算力时刻意忽略基组对核坐标的依赖性时。它被定义为 $U(R)$ 对 $R$ 的负偏导数，在微分过程中将 $b(R)$ 视为一个常数参数。\n$$\\left.\\frac{\\partial U}{\\partial R}\\right|_{b(R)\\ \\mathrm{frozen}} = \\frac{\\partial}{\\partial R} \\left( \\frac{1}{2} k R^2 + A e^{-b(R)} + B R^2 e^{-2b(R)} \\right) = kR + 2BR e^{-2b(R)}$$\n由此产生的力是：\n$$F_{\\mathrm{noP}}(R) = - \\left( kR + 2BR e^{-2b(R)} \\right)$$\n当 $b_1 \\neq 0$ 时，这个力是非保守的，因为它不是势能 $U(R)$ 的梯度。在 $F_{\\mathrm{full}}(R)$ 中存在的包含 $b_1$ 的项被称为 Pulay 力。忽略它们预计将导致总能量不守恒。\n\n运动方程使用速度-Verlet算法进行积分。给定在时间 $t$ 的位置 $R(t)$、速度 $\\dot{R}(t)$ 和加速度 $a(t) = F(R(t))/M$，在时间 $t+dt$ 的状态通过以下方式找到：\n1.  $\\dot{R}(t + dt/2) = \\dot{R}(t) + a(t) \\cdot (dt/2)$\n2.  $R(t+dt) = R(t) + \\dot{R}(t + dt/2) \\cdot dt$\n3.  $a(t+dt) = F(R(t+dt))/M$\n4.  $\\dot{R}(t+dt) = \\dot{R}(t + dt/2) + a(t+dt) \\cdot (dt/2)$\n\n为了分析模拟结果，我们计算三个诊断量。\n在任何时间 $t$ 的总能量是：\n$$E(t) = \\frac{1}{2} M \\dot{R}(t)^2 + U(R(t))$$\n能量漂移率 $m$ 是通过对总能量的时间序列进行线性最小二乘拟合 $E(t) = mt + c$ 来确定的。这为能量不守恒提供了一个定量的度量。我们根据使用 $F_{\\mathrm{full}}$ 的轨迹计算 $m_{\\mathrm{full}}$，根据使用 $F_{\\mathrm{noP}}$ 的轨迹计算 $m_{\\mathrm{noP}}$。在两种计算中，都使用相同的总能量函数 $U(R)$。\n\n基于维里的诊断量 $\\Delta_{\\mathrm{vir}}$ 基于经典维里定理，该定理对于一维束缚系统在保守力 $F$ 作用下，其时间平均值 $\\langle 2T + R F(R) \\rangle = 0$，其中 $T=\\frac{1}{2} M \\dot{R}^2$ 是动能。该诊断量是为使用（可能非保守的）力 $F_{\\mathrm{noP}}$ 生成的轨迹定义的：\n$$\\Delta_{\\mathrm{vir}} = \\left| \\frac{\\overline{2T + R F_{\\mathrm{noP}}}}{\\overline{2T}} \\right| = \\left| \\frac{\\frac{1}{N+1}\\sum_{i=0}^{N}(M\\dot{R}_i^2 + R_i F_{\\mathrm{noP}}(R_i))}{\\frac{1}{N+1}\\sum_{i=0}^{N} M\\dot{R}_i^2} \\right|$$\n其中，上划线表示在轨迹的 $N+1$ 个点上的时间平均。显著偏离零表示经典对应诊断的失效，这是使用非物理（非保守）力的症状。\n\n每个测试用例的计算过程如下：\n1.  对于给定的一组参数 $\\{M, k, A, B, b_0, b_1, dt, N, R(0), \\dot{R}(0)\\}$，进行两次独立的、各包含 $N$ 步的模拟。\n2.  第一次模拟使用 $F_{\\mathrm{full}}(R)$，生成轨迹 $\\{t_i, R_i, \\dot{R}_i\\}_{\\mathrm{full}}$。在每个步骤计算总能量 $E_{\\mathrm{full}}(t_i)$，并通过线性回归提取能量漂移率 $m_{\\mathrm{full}}$。\n3.  第二次模拟使用 $F_{\\mathrm{noP}}(R)$，生成轨迹 $\\{t_i, R_i, \\dot{R}_i\\}_{\\mathrm{noP}}$。同样，计算能量漂移率 $m_{\\mathrm{noP}}$。\n4.  使用第二次模拟的数据，计算维里诊断所需的各项时间平均值，从而得到 $\\Delta_{\\mathrm{vir}}$。\n5.  对每个测试用例，收集这三个结果值 $[m_{\\mathrm{noP}}, m_{\\mathrm{full}}, \\Delta_{\\mathrm{vir}}]$。\n实现将使用 Python 语言，借助 NumPy 库进行数值运算，并使用 SciPy 进行线性回归。", "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the AIMD toy model problem for three test cases, calculating energy drift\n    rates and a virial diagnostic.\n    \"\"\"\n    test_cases = [\n        # Case A: M, k, A, B, b0, b1, dt, N, R0, V0\n        (1.0, 1.0, 0.10, 0.05, 1.0, 0.0, 0.01, 20000, 0.2, 0.0),\n        # Case B\n        (1.0, 1.0, 0.10, 0.05, 1.0, 0.5, 0.01, 20000, 0.2, 0.0),\n        # Case C\n        (1.0, 1.0, 0.10, 0.05, 1.0, 1.2, 0.02, 20000, 0.2, 0.0),\n    ]\n\n    # This list will store the string representation of each case's results\n    # e.g., \"[-1.23e-5,4.56e-9,0.123]\"\n    all_results_strings = []\n\n    for case_params in test_cases:\n        M, k, A, B, b0, b1, dt, N, R0, V0 = case_params\n        N = int(N)\n\n        # --- Define physical model functions (vectorized with numpy) ---\n        def b_func(R):\n            return b0 + b1 * R**2\n\n        def U_func(R):\n            b_val = b_func(R)\n            V_nuc = 0.5 * k * R**2\n            E_el = A * np.exp(-b_val) + B * R**2 * np.exp(-2 * b_val)\n            return V_nuc + E_el\n\n        def F_full(R):\n            b_val = b_func(R)\n            term1 = -k * R\n            term2 = 2 * A * b1 * R * np.exp(-b_val)\n            term3 = -2 * B * R * np.exp(-2 * b_val)\n            term4 = 4 * B * b1 * R**3 * np.exp(-2 * b_val)\n            return term1 + term2 + term3 + term4\n\n        def F_noP(R):\n            b_val = b_func(R)\n            return -(k * R + 2 * B * R * np.exp(-2 * b_val))\n\n        force_models = {'full': F_full, 'noP': F_noP}\n        results_cache = {}\n\n        # --- Run simulations for both force models ---\n        for force_name, force_func in force_models.items():\n            \n            # --- Initialize trajectory storage ---\n            t_traj = np.linspace(0, N * dt, N + 1)\n            R_traj = np.zeros(N + 1)\n            V_traj = np.zeros(N + 1)\n            \n            R_traj[0] = R0\n            V_traj[0] = V0\n\n            # --- Velocity-Verlet Integration ---\n            R_curr = R0\n            V_curr = V0\n            F_curr = force_func(R_curr)\n            \n            for i in range(N):\n                A_curr = F_curr / M\n                V_half = V_curr + 0.5 * A_curr * dt\n                R_next = R_curr + V_half * dt\n                \n                F_next = force_func(R_next)\n                A_next = F_next / M\n                V_next = V_half + 0.5 * A_next * dt\n\n                # Store new state and update current state\n                R_traj[i + 1] = R_next\n                V_traj[i + 1] = V_next\n                R_curr, V_curr, F_curr = R_next, V_next, F_next\n\n            # --- Analyze Trajectory ---\n            # 1. Total Energy and Drift Rate\n            T_traj = 0.5 * M * V_traj**2\n            U_traj_vals = U_func(R_traj)\n            E_traj = T_traj + U_traj_vals\n            \n            # Using scipy.stats.linregress for slope\n            slope, _, _, _, _ = stats.linregress(t_traj, E_traj)\n            results_cache[f'm_{force_name}'] = slope\n\n            # 2. Virial Diagnostic (only for 'noP' case)\n            if force_name == 'noP':\n                # F_noP values already computed during integration, but recalculating is cleaner\n                F_noP_traj = F_noP(R_traj)\n                \n                # Using 2*T_traj for M*V^2\n                two_T_term = 2 * T_traj \n                virial_term = R_traj * F_noP_traj\n                \n                avg_two_T = np.mean(two_T_term)\n                avg_virial = np.mean(virial_term)\n                \n                # Avoid division by zero if avg_two_T is zero (unlikely but safe)\n                if avg_two_T != 0:\n                    delta_vir = np.abs((avg_two_T + avg_virial) / avg_two_T)\n                else:\n                    delta_vir = 0.0\n\n                results_cache['Delta_vir'] = delta_vir\n        \n        # --- Format and collect results for the current test case ---\n        m_noP = results_cache['m_noP']\n        m_full = results_cache['m_full']\n        delta_vir_val = results_cache['Delta_vir']\n        \n        # Format each number to 6 significant figures\n        case_result_vals = [m_noP, m_full, delta_vir_val]\n        formatted_strings = [f\"{val:.6g}\" for val in case_result_vals]\n        \n        all_results_strings.append(f\"[{','.join(formatted_strings)}]\")\n\n    # --- Final Print Statement ---\n    # Construct final output string in the exact format \"[[...],[...],[...]]\"\n    final_output = f\"[{','.join(all_results_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2879538"}]}