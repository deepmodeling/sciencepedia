{"hands_on_practices": [{"introduction": "拓扑缠结的概念植根于严格的数学。高斯环绕积分是量化两个闭合环如何相互缠绕的基石，为我们提供了一个整数值的拓扑不变量。这个练习将通过电磁学中的一个经典类比，从第一性原理推导出这个积分，并将其应用于一个简单的霍普夫环，从而加深对拓扑不变量的理解。[@problem_id:2930867]", "problem": "一位高分子物理学家将两个不相交的环状聚合物建模为嵌入三维欧几里得空间中的光滑闭合曲线。这两个环构成一个霍普夫(Hopf)环链，这是最简单的非平凡拓扑纠缠。考虑两条光滑闭合曲线 $C_1$ 和 $C_2$，它们代表了这两个环的中心线。我们可以通过一个在避免交叉的光滑形变下保持不变的双重线积分来定义一个整数，该整数计算了 $C_1$ 与 $C_2$ 环绕的次数。\n\n从静磁学和矢量微积分出发，并且不预先假设任何目标公式，完成以下任务：\n\n1. 使用毕奥-萨伐尔(Biot–Savart)定律（用于描述沿$C_1$流动的稳恒电流$I$产生的磁场），结合斯托克斯(Stokes)定理，并通过识别$C_1$穿过以$C_2$为边界的有向曲面的代数次数，导出一个表示环绕数的、在$C_1$和$C_2$上的双重线积分表达式。你的推导必须从经过充分检验的公式开始，即毕奥-萨伐尔(Biot–Savart)定律和斯托克斯(Stokes)定理，并说明为什么所得积分是在保持曲线不相交的光滑形变下的一个整数量拓扑不变量。\n\n2. 对于由两个位于相互垂直平面上的圆构成的霍普夫(Hopf)环链，其半径均为 $R$，参数满足 $R>a>0$，计算上述双重线积分。这两个圆由以下参数方程给出：\n   - $C_1$: $\\mathbf{r}_1(t) = \\big(a + R\\cos t,\\; R\\sin t,\\; 0\\big)$ for $t \\in [0,2\\pi)$,\n   - $C_2$: $\\mathbf{r}_2(s) = \\big(0,\\; a + R\\cos s,\\; -R\\sin s\\big)$ for $s \\in [0,2\\pi)$,\n   其方向对应于 $t$ 和 $s$ 增大的方向。请通过第一性原理来证明你的计算：可以直接计算该双重积分，或者利用它与 $C_2$ 和一个以 $C_1$ 为边界的有向张曲面的代数交点数（结合光滑形变不变性）的等价性，将计算简化为对带符号交点的计数。将环绕数 $Lk$ 的最终值以单个精确整数的形式给出。\n\n无需四舍五入。最终答案必须以一个不带单位的纯整数形式给出。", "solution": "所提出的问题是数学物理和拓扑学中一个有效练习。它问题明确，具有科学依据，并包含了得到唯一解所需的所有必要信息。我们将按要求进行推导和计算。\n\n该问题分为两部分。第一部分，从静磁学原理推导高斯(Gauss)环绕积分。第二部分，应用此结果或其拓扑等价形式，计算特定霍普夫(Hopf)环链构型的环绕数。\n\n第一部分：环绕数积分的推导\n\n在三维欧几里得空间 $\\mathbb{R}^3$ 中，两条不相交、有向的闭合曲线 $C_1$ 和 $C_2$ 的环绕数 $Lk(C_1, C_2)$ 在拓扑上定义为一条曲线穿过以另一条曲线为边界的有向曲面的净次数。为了推导该积分表达式，我们采用静磁学中的一个类比。\n\n假设曲线 $C_2$ 上有稳恒电流 $I_2$。根据安培(Ampere)环路定律，所产生的磁场 $\\mathbf{B}_2$ 沿闭合回路 $C_1$ 的线积分，正比于穿过以 $C_1$ 为边界的任意曲面 $S_1$ 的总电流。穿过 $S_1$ 的总电流是电流 $I_2$ 乘以曲线 $C_2$ 穿过曲面 $S_1$ 的整数次数。这个整数恰好是环绕数 $Lk(C_2, C_1)$，它是对称的，即 $Lk(C_2, C_1) = Lk(C_1, C_2)$。\n用数学语言表达，安培定律为：\n$$ \\oint_{C_1} \\mathbf{B}_2 \\cdot d\\mathbf{l}_1 = \\mu_0 I_{\\text{enclosed}} = \\mu_0 I_2 Lk(C_1, C_2) $$\n其中 $d\\mathbf{l}_1$ 是沿 $C_1$ 的线元，$\\mu_0$ 是真空磁导率。为了简化表达式并专注于其几何方面，我们可以采用一个单位制，其中 $\\mu_0=1$ 且单位电流 $I_2=1$。这样可得：\n$$ Lk(C_1, C_2) = \\oint_{C_1} \\mathbf{B}_2 \\cdot d\\mathbf{l}_1 $$\n这个关系表明环绕数必须是一个整数，因为它源于对离散穿越事件的计数。\n\n现在，我们引入毕奥-萨伐尔(Biot-Savart)定律来表示由回路 $C_2$ 中的电流产生的磁场 $\\mathbf{B}_2$。位于曲线 $C_2$ 上位置 $\\mathbf{r}_2$ 处的线元 $d\\mathbf{l}_2$ 在曲线 $C_1$ 上位置 $\\mathbf{r}_1$ 处产生的磁场为：\n$$ d\\mathbf{B}_2(\\mathbf{r}_1) = \\frac{\\mu_0 I_2}{4\\pi} \\frac{d\\mathbf{l}_2 \\times (\\mathbf{r}_1 - \\mathbf{r}_2)}{|\\mathbf{r}_1 - \\mathbf{r}_2|^3} $$\n将此表达式沿整个回路 $C_2$ 积分，得到在 $\\mathbf{r}_1$ 处的总磁场：\n$$ \\mathbf{B}_2(\\mathbf{r}_1) = \\frac{\\mu_0 I_2}{4\\pi} \\oint_{C_2} \\frac{d\\mathbf{l}_2 \\times (\\mathbf{r}_1 - \\mathbf{r}_2)}{|\\mathbf{r}_1 - \\mathbf{r}_2|^3} $$\n将这个 $\\mathbf{B}_2$ 的表达式代入我们的环绕数方程中，我们得到一个双重线积分：\n$$ Lk(C_1, C_2) = \\frac{1}{\\mu_0 I_2} \\oint_{C_1} \\left( \\frac{\\mu_0 I_2}{4\\pi} \\oint_{C_2} \\frac{d\\mathbf{l}_2 \\times (\\mathbf{r}_1 - \\mathbf{r}_2)}{|\\mathbf{r}_1 - \\mathbf{r}_2|^3} \\right) \\cdot d\\mathbf{l}_1 $$\n常数 $\\mu_0$ 和 $I_2$ 相消，留下一个纯粹的几何表达式：\n$$ Lk(C_1, C_2) = \\frac{1}{4\\pi} \\oint_{C_1} \\oint_{C_2} \\frac{(d\\mathbf{l}_2 \\times (\\mathbf{r}_1 - \\mathbf{r}_2)) \\cdot d\\mathbf{l}_1}{|\\mathbf{r}_1 - \\mathbf{r}_2|^3} $$\n利用标量三重积的性质，$(A \\times B) \\cdot C = (C \\times A) \\cdot B = A \\cdot (B \\times C)$，我们可以重排被积函数：\n$$ (d\\mathbf{l}_2 \\times (\\mathbf{r}_1 - \\mathbf{r}_2)) \\cdot d\\mathbf{l}_1 = (\\mathbf{r}_1 - \\mathbf{r}_2) \\cdot (d\\mathbf{l}_1 \\times d\\mathbf{l}_2) $$\n这就得到了高斯(Gauss)环绕积分的最终形式：\n$$ Lk(C_1, C_2) = \\frac{1}{4\\pi} \\oint_{C_1} \\oint_{C_2} \\frac{(\\mathbf{r}_1 - \\mathbf{r}_2) \\cdot (d\\mathbf{l}_1 \\times d\\mathbf{l}_2)}{|\\mathbf{r}_1 - \\mathbf{r}_2|^3} $$\n这个积分是一个整数，因为它是由计算离散电流穿透的安培定律推导出来的。它是一个拓扑不变量，因为任何避免自相交或曲线间相交的对曲线 $C_1$ 或 $C_2$ 的光滑形变（同痕）都会使积分值连续变化。由于该积分的值必须始终为整数，它不能在不同值之间跳跃，因此在整个形变过程中必须保持恒定。问题陈述本身提到了斯托克斯(Stokes)定理；它的作用隐含在安培定律中，后者可以通过对微分形式 $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$ 在曲面 $S_1$ 上积分并应用斯托克斯定理来推导。\n\n第二部分：对特定霍普夫(Hopf)环链的计算\n\n我们被要求为以下曲线计算此积分：\n- $C_1$: $\\mathbf{r}_1(t) = (a + R\\cos t, R\\sin t, 0)$ for $t \\in [0, 2\\pi)$\n- $C_2$: $\\mathbf{r}_2(s) = (0, a + R\\cos s, -R\\sin s)$ for $s \\in [0, 2\\pi)$\n\n直接计算该双重积分非常繁琐。一个更有效的方法，正如题目所建议的，是使用环绕数的拓扑定义：$Lk(C_1, C_2)$ 是 $C_2$ 与一个以 $C_1$ 为有向边界的曲面 $S_1$ 相交次数的代数和。\n\n曲线 $C_1$ 是位于 $z=0$ 平面内、以 $(a, 0, 0)$ 为中心、半径为 $R$ 的圆。最简单的张曲面 $S_1$ 选择是由该圆所包围的平坦圆盘：\n$$ S_1 = \\{ (x, y, z) \\in \\mathbb{R}^3 \\mid (x-a)^2 + y^2 \\leq R^2, z=0 \\} $$\n$C_1$ 的方向对应于 $t$ 的增加。在 $t=0$ 时，$\\mathbf{r}_1(0)=(a+R,0,0)$；在 $t=\\pi/2$ 时，$\\mathbf{r}_1(\\pi/2)=(a,R,0)$。这描述了在 $xy$ 平面内的一次逆时针遍历。根据右手定则，曲面 $S_1$ 的法向量 $\\mathbf{n}$ 指向正 $z$ 方向，因此 $\\mathbf{n} = (0, 0, 1)$。\n\n接下来，我们找出曲线 $C_2$ 与包含 $S_1$ 的平面（即 $z=0$ 平面）的交点。对于 $C_2$ 上的点 $\\mathbf{r}_2(s)$，其 $z$ 坐标为 $-R\\sin s$。令其为零：\n$$ -R\\sin s = 0 $$\n因为 $R > 0$，这意味着 $\\sin s = 0$。在区间 $s \\in [0, 2\\pi)$ 内，解为 $s=0$ 和 $s=\\pi$。\n\n我们必须检验这两个潜在的交点是否位于圆盘 $S_1$ 的边界之内。\n情况1：$s=0$。\n$C_2$ 上的点为 $\\mathbf{r}_2(0) = (0, a + R\\cos 0, -R\\sin 0) = (0, a+R, 0)$。\n我们检查该点是否满足不等式 $(x-a)^2 + y^2 \\leq R^2$：\n$$ (0-a)^2 + (a+R)^2 = a^2 + (a^2 + 2aR + R^2) = 2a^2 + 2aR + R^2 $$\n由于给定 $R > a > 0$，项 $2a^2 + 2aR$ 严格为正。因此，$2a^2 + 2aR + R^2 > R^2$。该点位于圆盘 $S_1$ 之外。此处没有交点。\n\n情况2：$s=\\pi$。\n$C_2$ 上的点为 $\\mathbf{r}_2(\\pi) = (0, a + R\\cos\\pi, -R\\sin\\pi) = (0, a-R, 0)$。\n我们检查该不等式：\n$$ (0-a)^2 + (a-R)^2 = a^2 + (a^2 - 2aR + R^2) = 2a^2 - 2aR + R^2 $$\n我们检验是否 $2a^2 - 2aR + R^2 \\leq R^2$，这可简化为 $2a^2 - 2aR \\leq 0$，或 $2a(a-R) \\leq 0$。\n由于 $a>0$ 且 $R>a$，项 $(a-R)$ 为负。因此，$2a(a-R)$ 为负，该不等式成立。此点位于圆盘 $S_1$ 之内。\n\n我们找到了恰好一个交点。为了求出环绕数，我们必须确定这个交点的符号。符号由 $C_2$ 在交点处的切向量与 $S_1$ 的法向量的点积的符号给出。\n$C_2$ 的切向量为 $\\mathbf{v}_2(s) = \\frac{d\\mathbf{r}_2}{ds} = (0, -R\\sin s, -R\\cos s)$。\n在交点 $s=\\pi$ 处：\n$$ \\mathbf{v}_2(\\pi) = (0, -R\\sin\\pi, -R\\cos\\pi) = (0, 0, -R(-1)) = (0, 0, R) $$\n$S_1$ 的法向量是 $\\mathbf{n} = (0, 0, 1)$。\n点积为：\n$$ \\mathbf{v}_2(\\pi) \\cdot \\mathbf{n} = (0, 0, R) \\cdot (0, 0, 1) = R $$\n由于 $R>0$，点积为正。该交点的符号为 $+1$。\n\n环绕数是所有带符号交点的总和。由于只有一个符号为 $+1$ 的交点，所以环绕数为 $1$。\n$$ Lk(C_1, C_2) = +1 $$\n这个整数值与 $R$ 和 $a$ 的具体值无关，只要条件 $R>a>0$ 成立，这证实了它是一个拓扑性质。", "answer": "$$\\boxed{1}$$", "id": "2930867"}, {"introduction": "从理想化的环转移到真实的聚合物熔体，我们需要一种方法来量化长链的缠结程度。这个练习将引导你实现一个简化的原始路径分析，通过识别链上的“滑环”约束来计算关键的材料参数——缠结长度 $N_e$。通过这个编码实践，你将学习如何处理周期性边界条件，并将抽象的拓扑概念转化为一个具体的、可计算的物理量。[@problem_id:2930833]", "problem": "你的任务是构建一个完整、可运行的程序，该程序利用单帧珠簧高分子链在周期性边界条件下的分子动力学构象来估算纠缠长度 $N_e$。其目标是使用一种基于原始路径的估算方法来计算 $N_e$，该方法能防止链交叉并最小化末端效应。你的程序必须实现以下基于基本原理和标准惯例的、有物理基础的工作流程：\n\n1. 定义与建模假设：\n   - 一条高分子链是由 $N$ 个珠子组成的序列，其位置为 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，位于边长为 $L$ 的立方周期性盒子中。距离的计算必须遵循周期性边界条件的最小镜像约定。\n   - 一组钉扎单体索引（滑环）$\\mathcal{P} \\subset \\{0,\\dots,N-1\\}$ 用于模拟防止链交叉的拓扑约束。这些钉扎点被视为原始路径必须穿过的固定拓扑约束。\n   - 为了最小化末端效应，你将忽略每条链两端的 $s$ 个珠子。定义内部索引 $i_0 = s$ 和 $i_1 = N-1-s$，其中 $i_0 \\le i_1$。有效钉扎点集合为\n     $$\\mathcal{P}_{\\mathrm{eff}} = \\big(\\mathcal{P} \\cup \\{i_0, i_1\\}\\big) \\cap \\{i_0,i_0+1,\\dots,i_1\\}.$$\n     将 $\\mathcal{P}_{\\mathrm{eff}}$ 按升序排序并移除重复项。\n   - 在滑环表示法以及珠子顺序和钉扎点固定的轮廓长度最小化条件下，内部区间的原始路径在连续的钉扎点之间是分段笔直的。内部区间的原始路径轮廓长度为\n     $$L_{\\mathrm{pp}} = \\sum_{j=0}^{K-2} \\left\\| \\mathbf{r}_{p_{j+1}} - \\mathbf{r}_{p_j} \\right\\|_{\\mathrm{mic}},$$\n     其中 $\\{p_0,\\dots,p_{K-1}\\} = \\mathrm{sorted}(\\mathcal{P}_{\\mathrm{eff}})$，且 $\\|\\cdot\\|_{\\mathrm{mic}}$ 表示在周期性盒子中经过最小镜像约定处理后的矢量范数。\n   - 内部区间的端到端矢量是 $\\mathbf{R}_{\\mathrm{int}} = \\mathbf{r}_{i_1} - \\mathbf{r}_{i_0}$（经过最小镜像约定处理），且 $R_{\\mathrm{int}}^2 = \\|\\mathbf{R}_{\\mathrm{int}}\\|^2$。\n   - 所考虑的内部化学键数量为\n     $$N_{\\mathrm{eff}} = (N-1) - 2s.$$\n   - 每条链的拓扑纠缠数可通过管状模型关系式 $Z = L_{\\mathrm{pp}}^2 / R_{\\mathrm{int}}^2$ 来近似，从而得到纠缠长度\n     $$N_e = \\frac{N_{\\mathrm{eff}}}{Z} = N_{\\mathrm{eff}} \\frac{R_{\\mathrm{int}}^2}{L_{\\mathrm{pp}}^2}.$$\n\n2. 计算要求：\n   - 针对边长为 $L$ 的立方盒子，按如下方式实现最小镜像约定。对于位移矢量 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$，\n     $$\\Delta \\mathbf{r}_{\\mathrm{mic}} = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta \\mathbf{r}}{L}\\right),$$\n     其中除法和四舍五入是逐分量应用的。\n   - 对每个测试用例，使用上述公式计算 $N_e$，所有距离单位均为纳米。最终的 $N_e$ 是无量纲的。\n\n3. 测试套件：\n   你的程序必须为以下三个测试用例分别计算 $N_e$。每个测试用例使用单条链（$M=1$）。所有坐标单位均为纳米，立方周期性盒子的边长 $L$ 单位也为纳米。\n\n   - 测试用例 1（理想路径，直链，无内部滑环）：\n     - $L = 10$。\n     - $N = 6$ 个珠子，坐标为\n       $$\\big[(1,5,5),(2,5,5),(3,5,5),(4,5,5),(5,5,5),(6,5,5)\\big].$$\n     - 钉扎点索引 $\\mathcal{P} = \\varnothing$。\n     - 末端削减 $s = 1$。\n     - 说明：有效钉扎点为 $i_0=1$ 和 $i_1=4$，因此原始路径是珠子 1 和 4 之间的直线段。\n\n   - 测试用例 2（内部滑环导致绕行；非共线的钉扎点）：\n     - $L = 20$。\n     - $N = 10$ 个珠子，坐标为\n       $$\\big[(1,1,5),(3,2,5),(5,5,5),(6,6,5),(7,7,5),(8,9,5),(10,7,5),(12,5,5),(15,4,5),(18,3,5)\\big].$$\n     - 钉扎点索引 $\\mathcal{P} = \\{5\\}$。\n     - 末端削减 $s = 2$。\n     - 说明：有效钉扎点为 $i_0 = 2$、索引 $5$ 和 $i_1 = 7$，形成一条穿过索引 $2 \\to 5 \\to 7$ 的分段笔直的原始路径。\n\n   - 测试用例 3（周期性边界缠绕；跨越边界的非共线钉扎点）：\n     - $L = 10$。\n     - $N = 8$ 个珠子，坐标为\n       $$\\big[(0.5,1,1),(9,1,1),(9.5,2,1),(0,5,1),(1.5,3,1),(1.8,2,1),(2,1,1),(2.5,0.5,1)\\big].$$\n     - 钉扎点索引 $\\mathcal{P} = \\{3\\}$。\n     - 末端削减 $s = 1$。\n     - 说明：有效钉扎点为 $i_0=1$、索引 $3$ 和 $i_1=6$，形成一条使用最小镜像约定跨越周期性边界的分段笔直路径。\n\n4. 输出规格：\n   - 对每个测试用例，将 $N_e$ 作为浮点数计算，并四舍五入到六位小数。\n   - 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项按测试用例 1、测试用例 2、测试用例 3 的顺序排列。例如，输出格式为：\n     $$[x_1,x_2,x_3],$$\n     其中每个 $x_j$ 是测试用例 $j$ 中 $N_e$ 的四舍五入到六位小数的值。\n   - $N_e$ 是无量纲的；不要包含任何单位或额外文本。\n\n请严格按照上述描述实现算法。仅使用指定的库和版本。不应从标准输入读取任何数据；所有数据都必须在程序中硬编码。", "solution": "对问题陈述进行验证。\n\n逐字提取已知条件。\n1. 一条高分子链是由 $N$ 个珠子组成的序列，其位置为 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，位于边长为 $L$ 的立方周期性盒子中。\n2. 距离使用最小镜像约定 (MIC)。\n3. 钉扎单体索引集合为 $\\mathcal{P} \\subset \\{0,\\dots,N-1\\}$。\n4. 为最小化末端效应，每条链两端的 $s$ 个珠子被忽略。内部索引为 $i_0 = s$ 和 $i_1 = N-1-s$。\n5. 有效钉扎点集合为 $\\mathcal{P}_{\\mathrm{eff}} = \\big(\\mathcal{P} \\cup \\{i_0, i_1\\}\\big) \\cap \\{i_0,i_0+1,\\dots,i_1\\}$，按升序排序并移除重复项。\n6. 原始路径轮廓长度为 $L_{\\mathrm{pp}} = \\sum_{j=0}^{K-2} \\left\\| \\mathbf{r}_{p_{j+1}} - \\mathbf{r}_{p_j} \\right\\|_{\\mathrm{mic}}$，其中 $\\{p_0,\\dots,p_{K-1}\\} = \\mathrm{sorted}(\\mathcal{P}_{\\mathrm{eff}})$。\n7. 内部端到端矢量是 $\\mathbf{R}_{\\mathrm{int}} = \\mathbf{r}_{i_1} - \\mathbf{r}_{i_0}$（经MIC处理），且 $R_{\\mathrm{int}}^2 = \\|\\mathbf{R}_{\\mathrm{int}}\\|^2$。\n8. 内部化学键的数量为 $N_{\\mathrm{eff}} = (N-1) - 2s$。\n9. 纠缠长度为 $N_e = N_{\\mathrm{eff}} \\frac{R_{\\mathrm{int}}^2}{L_{\\mathrm{pp}}^2}$。\n10. 位移矢量 $\\Delta \\mathbf{r}$ 的 MIC 公式为 $\\Delta \\mathbf{r}_{\\mathrm{mic}} = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta \\mathbf{r}}{L}\\right)$。\n11. 提供了三个测试用例，包含 $L$、$N$、珠子坐标、$\\mathcal{P}$ 和 $s$ 的具体值。\n12. 最终输出必须为单行，包含每个测试用例的 $N_e$ 值，四舍五入到六位小数，格式为 $[x_1,x_2,x_3]$。\n\n根据验证标准对问题进行评估。结论是该问题是**有效的**。它具有科学依据，采用了高分子物理中的标准（尽管是简化的）模型，例如用于估算拓扑纠缠的原始路径分析和管状模型。该问题是适定的，为每个测试用例提供了计算唯一结果所需的所有数据、定义和明确公式。其语言客观而精确。该问题是一个自包含的、算法上可解的任务，既不琐碎也非定义不清。其中没有矛盾、歧义或事实错误。\n\n求解过程如下。目标是计算纠缠长度 $N_e$，它量化了高分子链中拓扑约束之间的平均单体数。所提供的方法是基于高分子构象的静态快照的计算估算。\n\n基本原理是原始路径的概念。对于给定的链，其原始路径是在假设它不能穿过周围拓扑障碍的情况下的最短可能轮廓。这些障碍在此被建模为一组离散的钉扎点或滑环，链必须穿过这些点。因此，原始路径被近似为连接这些连续钉扎点的一系列直线段。\n\n计算 $N_e$ 的算法是通过严格遵循问题陈述中提供的定义来构建的。\n\n首先，我们建立计算工具集。系统处于边长为 $L$ 的立方盒子中的周期性边界条件下。所有距离和矢量计算都必须遵循最小镜像约定 (MIC)。对于任何位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$，其经 MIC 处理后的形式由以下逐分量操作给出：\n$$\n\\Delta \\mathbf{r}_{\\mathrm{mic}} = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta \\mathbf{r}}{L}\\right)\n$$\n该矢量的范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{mic}}\\|$，是在周期性空间中点 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 之间的最短距离。\n\n对于每个测试用例，计算遵循以下步骤：\n1.  识别参数：链长 $N$、盒子大小 $L$、珠子坐标 $\\{\\mathbf{r}_i\\}$、初始钉扎点集合 $\\mathcal{P}$ 和末端削减参数 $s$。\n2.  确定链的内部段。为减轻因约束较少的链末端所引入的假象，我们从每端排除 $s$ 个珠子。链的内部部分由从 $i_0 = s$到 $i_1 = N-1-s$ 的珠子索引定义。\n3.  构建有效钉扎点集合 $\\mathcal{P}_{\\mathrm{eff}}$。该集合定义了原始路径的顶点。其构成方法是：取所提供的集合 $\\mathcal{P}$，加入内部段的起始和末尾索引（$i_0$ 和 $i_1$），然后只保留位于内部段（索引从 $i_0$到 $i_1$）内的钉扎点。将得到的索引集合进行排序并去除重复项，以确保路径的唯一性和有序性。设排序后的唯一钉扎点为 $\\{p_0, p_1, \\dots, p_{K-1}\\}$。\n4.  计算原始路径轮廓长度 $L_{\\mathrm{pp}}$。这是穿过有效钉扎点的分段线性路径的总长度。它是连续钉扎点之间 MIC 距离的总和：\n$$\nL_{\\mathrm{pp}} = \\sum_{j=0}^{K-2} \\|\\mathbf{r}_{p_{j+1}} - \\mathbf{r}_{p_j}\\|_{\\mathrm{mic}}\n$$\n当 $L_{\\mathrm{pp}} = R_{\\mathrm{int}}$ 时会出现一种特殊情况，这对应于没有绕行的直线路径，此时纠缠数 $Z$ 为 $1$。如果路径是直线，那么 $\\mathcal{P}_{\\mathrm{eff}}$ 只包含两个点 $i_0$ 和 $i_1$。在这种情况下，$L_{\\mathrm{pp}}$ 就是 $\\mathbf{r}_{i_0}$ 和 $\\mathbf{r}_{i_1}$ 之间的 MIC 距离。\n5.  计算内部段两端之间直接距离的平方 $R_{\\mathrm{int}}^2$。这代表原始路径跨度的平方。\n$$\n\\mathbf{R}_{\\mathrm{int}} = \\text{mic}(\\mathbf{r}_{i_1} - \\mathbf{r}_{i_0}, L)\n$$\n$$\nR_{\\mathrm{int}}^2 = \\mathbf{R}_{\\mathrm{int}} \\cdot \\mathbf{R}_{\\mathrm{int}}\n$$\n6.  计算内部区域的有效库恩链段（或化学键）数量 $N_{\\mathrm{eff}}$。它由整条链的化学键数 $N-1$ 减去被裁剪部分中的化学键数 $2s$ 得出。\n$$\nN_{\\mathrm{eff}} = (N-1) - 2s\n$$\n7.  最后，计算纠缠长度 $N_e$。纠缠数 $Z$ 根据管状模型估算为轮廓长度平方与跨度平方之比，即 $Z = L_{\\mathrm{pp}}^2 / R_{\\mathrm{int}}^2$。纠缠长度是每个纠缠所包含的单体数，因此 $N_e = N_{\\mathrm{eff}} / Z$。\n$$\nN_e = N_{\\mathrm{eff}} \\frac{R_{\\mathrm{int}}^2}{L_{\\mathrm{pp}}^2}\n$$\n对每个测试用例实现此公式。结果按要求四舍五入到六位小数。如果 $L_{\\mathrm{pp}} = 0$ 可能会发生除以零的情况。这意味着所有钉扎点都位于同一空间位置，也即 $R_{\\mathrm{int}} = 0$，从而导致 $0/0$ 的不定形式。在物理上，这对应于一个未纠缠的、塌缩的状态。然而，对于给定的测试用例，$L_{\\mathrm{pp}}$ 始终非零。\n\n所提供的 Python 代码实现了此逻辑。它定义了测试用例数据，遍历这些数据，并使用 `numpy` 库中用于矢量运算的函数来应用所述的计算序列。MIC 计算被封装在一个辅助函数中，以提高清晰度和可复用性。最终结果被收集并格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the entanglement length Ne for a set of polymer configurations.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 10.0,\n            \"N\": 6,\n            \"coords\": np.array([\n                [1.0, 5.0, 5.0], [2.0, 5.0, 5.0], [3.0, 5.0, 5.0],\n                [4.0, 5.0, 5.0], [5.0, 5.0, 5.0], [6.0, 5.0, 5.0]\n            ]),\n            \"P\": set(),\n            \"s\": 1\n        },\n        {\n            \"L\": 20.0,\n            \"N\": 10,\n            \"coords\": np.array([\n                [1.0, 1.0, 5.0], [3.0, 2.0, 5.0], [5.0, 5.0, 5.0],\n                [6.0, 6.0, 5.0], [7.0, 7.0, 5.0], [8.0, 9.0, 5.0],\n                [10.0, 7.0, 5.0], [12.0, 5.0, 5.0], [15.0, 4.0, 5.0],\n                [18.0, 3.0, 5.0]\n            ]),\n            \"P\": {5},\n            \"s\": 2\n        },\n        {\n            \"L\": 10.0,\n            \"N\": 8,\n            \"coords\": np.array([\n                [0.5, 1.0, 1.0], [9.0, 1.0, 1.0], [9.5, 2.0, 1.0],\n                [0.0, 5.0, 1.0], [1.5, 3.0, 1.0], [1.8, 2.0, 1.0],\n                [2.0, 1.0, 1.0], [2.5, 0.5, 1.0]\n            ]),\n            \"P\": {3},\n            \"s\": 1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        coords = case[\"coords\"]\n        P = case[\"P\"]\n        s = case[\"s\"]\n\n        def mic_vector(dr, box_L):\n            \"\"\"Applies minimum image convention to a displacement vector.\"\"\"\n            return dr - box_L * np.round(dr / box_L)\n\n        # Step 1: Define interior indices and effective pin set\n        i0 = s\n        i1 = N - 1 - s\n        \n        # P_eff = (P U {i0, i1}) intersect {i0, ..., i1}\n        P_eff_set = (P.union({i0, i1})).intersection(set(range(i0, i1 + 1)))\n        P_eff_sorted = sorted(list(P_eff_set))\n\n        # Step 2: Calculate R_int^2\n        r_i0 = coords[i0]\n        r_i1 = coords[i1]\n        R_int_vec = mic_vector(r_i1 - r_i0, L)\n        R_int_sq = np.dot(R_int_vec, R_int_vec)\n\n        # Step 3: Calculate L_pp\n        L_pp = 0.0\n        if len(P_eff_sorted) > 1:\n            for j in range(len(P_eff_sorted) - 1):\n                p_curr = P_eff_sorted[j]\n                p_next = P_eff_sorted[j+1]\n                \n                r_curr = coords[p_curr]\n                r_next = coords[p_next]\n                \n                dr_segment = mic_vector(r_next - r_curr, L)\n                L_pp += np.linalg.norm(dr_segment)\n\n        # Step 4: Calculate N_eff\n        N_eff = (N - 1) - 2 * s\n        \n        # Step 5: Calculate Ne\n        if L_pp == 0:\n            # This case implies R_int_sq is also 0, an unentangled chain.\n            # The formula would be 0/0. Physical interpretation yields Z=1 for an ideal chain.\n            # If L_pp = 0, R must be 0, so L_pp^2/R_int^2 is ill-defined.\n            # For a straight chain with no detours, L_pp = R_int, Z=1, Ne = N_eff.\n            # If L_pp is 0, the path has zero length, so it's a point. R_int is 0.\n            # Let's assume based on problem context that L_pp > 0 for all valid cases.\n            if R_int_sq > 0:\n                # Infinite entanglements, Ne = 0 (a collapsed loop).\n                Ne = 0.0\n            else: # R_int_sq = 0 as well.\n                # Corresponds to a single point. No length, no entanglements.\n                # Or a straight line. If Lpp = R_int, Z=1.\n                # In Case 1, L_pp=3, R_int=3, so Z=1. Ne = N_eff = 3.\n                # If L_pp==0 because there's only one pin, Lpp should be taken as R_int for consistency? No.\n                # The sum for L_pp runs up to K-2. If K=1, L_pp=0.\n                # In the problem, K is at least 2 due to i0, i1.\n                Ne = float('inf') # Or some other indicator of an issue.\n        else:\n            Ne = N_eff * (R_int_sq / (L_pp * L_pp))\n            \n        results.append(round(Ne, 6))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2930833"}, {"introduction": "在计算聚合物科学中，一个核心任务是验证粗粒化模型的准确性。这个练习模拟了一个真实的研究场景，你将通过比较模型预测与“精确”的原子模拟参考数据，来量化一个滑环模型的性能。你将学习计算和综合评估来自结构（如缠结数 $Z$）和动力学（如剪切模量 $G(t)$）两方面的误差指标，这是连接微观拓扑与宏观材料响应的关键一步。[@problem_id:2930842]", "problem": "您获得了一项针对纠缠聚合物熔体的滑移链接粗粒化模型的验证任务。目标是量化模型预测值与通过原子模拟进行原始路径分析 (PPA) 所得参考值之间的一致性。比较必须基于三个可观测量进行：作为时间函数的剪切弛豫模量、每条链的纠缠数以及平均原始路径长度。\n\n背景与核心定义：\n- 剪切弛豫模量，记为 $G(t)$，是对应力单位阶跃应变的响应。对于聚合物熔体，一个经过充分检验、可用于表示跨越多个时间数量级的 $G(t)$ 的方法是多模式麦克斯韦谱：\n$$\nG(t) = \\sum_{k=1}^{M} g_k \\, \\exp\\!\\bigl(-t/\\tau_k\\bigr),\n$$\n其中 $M$ 是模式数量，$g_k$ 是模式振幅（单位为帕斯卡），$\\tau_k$ 是模式弛豫时间（单位为秒）。\n- 滑移链接模型将拓扑纠缠表示为约束，这些约束限制了链的运动，同时允许在约束点发生滑移。对原子模拟进行原始路径分析 (PPA) 可得出结构度量的参考值，包括每条链的纠缠数 $Z$（无量纲）和平均原始路径长度 $\\langle L_{\\mathrm{pp}} \\rangle$（单位为长度）。\n\n定义以下验证指标：\n1. 用于模量轨迹的对数时间加权、对数模量均方根偏差：\n$$\nE_G = \\left( \\frac{\\int_{\\ln t_{\\min}}^{\\ln t_{\\max}} \\left[ \\ln G_{\\mathrm{model}}(t) - \\ln G_{\\mathrm{ref}}(t) \\right]^2 \\, \\mathrm{d}(\\ln t)}{\\int_{\\ln t_{\\min}}^{\\ln t_{\\max}} \\mathrm{d}(\\ln t)} \\right)^{1/2}.\n$$\n在所有 $\\ln(\\cdot)$ 出现之处均使用自然对数，并假设对于所有时间 $G(t) > 0$。\n2. 纠缠数的相对绝对误差：\n$$\nE_Z = \\frac{\\left| Z_{\\mathrm{model}} - Z_{\\mathrm{ref}} \\right|}{Z_{\\mathrm{ref}}}.\n$$\n3. 平均原始路径长度的相对绝对误差：\n$$\nE_L = \\frac{\\left| \\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}} - \\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}} \\right|}{\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}}}.\n$$\n4. 汇总三个指标的综合得分：\n$$\nQ = \\sqrt{E_G^2 + E_Z^2 + E_L^2}.\n$$\n该综合得分 $Q$ 是无量纲的。\n\n数值离散化规则：\n- 在一个对数均匀间隔的时间网格 $\\{ t_i \\}_{i=0}^{N-1}$ 上评估 $E_G$，该网格包含从 $t_{\\min} = 10^{-6} \\,\\mathrm{s}$ 到 $t_{\\max} = 10^{2} \\,\\mathrm{s}$ 的 $N = 31$ 个点，定义为\n$$\nt_i = 10^{\\, -6 + i \\cdot \\frac{2 - (-6)}{30} } \\,\\mathrm{s}, \\quad i = 0,1,\\dots,30.\n$$\n- 使用在 $\\ln t$ 上的梯形法则对 $E_G$ 中的积分进行离散化。令 $\\ell_i = \\ln t_i$。定义非负权重 $\\{ w_i \\}$ 如下：\n$$\nw_0 = \\tfrac{1}{2}(\\ell_{1} - \\ell_{0}), \\quad\nw_{i} = \\tfrac{1}{2}(\\ell_{i+1} - \\ell_{i-1}) \\text{ for } i=1,\\dots,N-2, \\quad\nw_{N-1} = \\tfrac{1}{2}(\\ell_{N-1} - \\ell_{N-2}).\n$$\n则近似为\n$$\nE_G \\approx \\left( \\frac{\\sum_{i=0}^{N-1} w_i \\left[ \\ln G_{\\mathrm{model}}(t_i) - \\ln G_{\\mathrm{ref}}(t_i) \\right]^2}{\\sum_{i=0}^{N-1} w_i} \\right)^{1/2}.\n$$\n\n测试套件：\n对于每个测试用例，您将获得一个参考多模式麦克斯韦谱 $(\\{ g^{\\mathrm{ref}}_k \\}, \\{ \\tau^{\\mathrm{ref}}_k \\})$、一个模型谱 $(\\{ g^{\\mathrm{model}}_k \\}, \\{ \\tau^{\\mathrm{model}}_k \\})$，以及标量结构值 $Z_{\\mathrm{ref}}$、$Z_{\\mathrm{model}}$、$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}}$ 和 $\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}}$。所有模量 $g_k$ 的单位均为帕斯卡（内部计算结果时使用帕斯卡，但指标是无量纲的），所有时间 $\\tau_k$ 的单位均为秒，所有原始路径长度 $\\langle L_{\\mathrm{pp}} \\rangle$ 的单位均为纳米。纠缠数 $Z$ 是无量纲的。\n\n- 测试用例 A（一般情况）：\n  - 参考谱：$M=3$，其中 $\\{ g^{\\mathrm{ref}}_k \\} = \\{ 1.5 \\times 10^{5},\\, 8.0 \\times 10^{4},\\, 3.0 \\times 10^{4} \\}$ 且 $\\{ \\tau^{\\mathrm{ref}}_k \\} = \\{ 1.0 \\times 10^{-4},\\, 1.0 \\times 10^{-1},\\, 1.0 \\times 10^{1} \\}$。\n  - 模型谱：$M=3$，其中 $\\{ g^{\\mathrm{model}}_k \\} = \\{ 1.4 \\times 10^{5},\\, 8.5 \\times 10^{4},\\, 2.8 \\times 10^{4} \\}$ 且 $\\{ \\tau^{\\mathrm{model}}_k \\} = \\{ 1.2 \\times 10^{-4},\\, 8.0 \\times 10^{-2},\\, 1.2 \\times 10^{1} \\}$。\n  - 纠缠数：$Z_{\\mathrm{ref}} = 20$， $Z_{\\mathrm{model}} = 19$。\n  - 平均原始路径长度：$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}} = 120 \\,\\mathrm{nm}$，$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}} = 118 \\,\\mathrm{nm}$。\n\n- 测试用例 B（完全一致边界）：\n  - 参考谱：$M=3$，其中 $\\{ g^{\\mathrm{ref}}_k \\} = \\{ 1.5 \\times 10^{5},\\, 8.0 \\times 10^{4},\\, 3.0 \\times 10^{4} \\}$ 且 $\\{ \\tau^{\\mathrm{ref}}_k \\} = \\{ 1.0 \\times 10^{-4},\\, 1.0 \\times 10^{-1},\\, 1.0 \\times 10^{1} \\}$。\n  - 模型谱：与参考谱相同。\n  - 纠缠数：$Z_{\\mathrm{ref}} = 20$， $Z_{\\mathrm{model}} = 20$。\n  - 平均原始路径长度：$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}} = 120 \\,\\mathrm{nm}$，$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}} = 120 \\,\\mathrm{nm}$。\n\n- 测试用例 C（不匹配边缘情况）：\n  - 参考谱：$M=3$，其中 $\\{ g^{\\mathrm{ref}}_k \\} = \\{ 1.5 \\times 10^{5},\\, 8.0 \\times 10^{4},\\, 3.0 \\times 10^{4} \\}$ 且 $\\{ \\tau^{\\mathrm{ref}}_k \\} = \\{ 1.0 \\times 10^{-4},\\, 1.0 \\times 10^{-1},\\, 1.0 \\times 10^{1} \\}$。\n  - 模型谱：$M=3$，其中 $\\{ g^{\\mathrm{model}}_k \\} = \\{ 7.5 \\times 10^{4},\\, 4.0 \\times 10^{4},\\, 1.5 \\times 10^{4} \\}$ 且 $\\{ \\tau^{\\mathrm{model}}_k \\} = \\{ 5.0 \\times 10^{-5},\\, 5.0 \\times 10^{-2},\\, 5.0 \\times 10^{0} \\}$。\n  - 纠缠数：$Z_{\\mathrm{ref}} = 20$， $Z_{\\mathrm{model}} = 10$。\n  - 平均原始路径长度：$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}} = 120 \\,\\mathrm{nm}$，$\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}} = 200 \\,\\mathrm{nm}$。\n\n编程任务：\n- 对于每个测试用例，在指定的时间网格上使用给定的多模式麦克斯韦谱构建 $G_{\\mathrm{ref}}(t_i)$ 和 $G_{\\mathrm{model}}(t_i)$，然后使用上述定义和对数梯形法则计算 $E_G$、$E_Z$、$E_L$ 和 $Q$。\n- 所有三个指标和综合得分都是无量纲的。不涉及角度单位。不需要额外的物理常数。\n- 您的程序应生成单行输出，其中包含一个列表的列表，每个内部列表对应一个测试用例（按 A、B、C 的顺序）。每个内部列表必须包含四个数字 $[E_G, E_Z, E_L, Q]$，每个数字四舍五入到六位小数。确切的输出格式必须是单行形式，例如 `[ [eG_A,eZ_A,eL_A,Q_A], [eG_B,eZ_B,eL_B,Q_B], [eG_C,eZ_C,eL_C,Q_C] ]`，不含任何空格，但条目之间用逗号分隔，即 `[[eG_A,eZ_A,eL_A,Q_A],[eG_B,eZ_B,eL_B,Q_B],[eG_C,eZ_C,eL_C,Q_C]]`。", "solution": "问题陈述经过了严格的验证。\n\n步骤 1：提取已知条件。\n问题提供了以下量和定义：\n- 剪切弛豫模量 $G(t)$ 由一个多模式麦克斯韦谱给出：\n$$G(t) = \\sum_{k=1}^{M} g_k \\, \\exp\\!\\bigl(-t/\\tau_k\\bigr)$$\n- 用于比较的可观测量：剪切弛豫模量 $G(t)$、每条链的纠缠数 $Z$ 和平均原始路径长度 $\\langle L_{\\mathrm{pp}} \\rangle$。\n- 验证指标定义为：\n  1. 模量的均方根偏差，$E_G$：\n  $$E_G = \\left( \\frac{\\int_{\\ln t_{\\min}}^{\\ln t_{\\max}} \\left[ \\ln G_{\\mathrm{model}}(t) - \\ln G_{\\mathrm{ref}}(t) \\right]^2 \\, \\mathrm{d}(\\ln t)}{\\int_{\\ln t_{\\min}}^{\\ln t_{\\max}} \\mathrm{d}(\\ln t)} \\right)^{1/2}$$\n  2. 纠缠数的相对误差，$E_Z$：\n  $$E_Z = \\frac{\\left| Z_{\\mathrm{model}} - Z_{\\mathrm{ref}} \\right|}{Z_{\\mathrm{ref}}}$$\n  3. 原始路径长度的相对误差，$E_L$：\n  $$E_L = \\frac{\\left| \\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}} - \\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}} \\right|}{\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}}}$$\n  4. 综合得分，$Q$：\n  $$Q = \\sqrt{E_G^2 + E_Z^2 + E_L^2}$$\n- $E_G$ 的数值积分规定如下：\n  - 时间网格：从 $t_{\\min} = 10^{-6}$ s 到 $t_{\\max} = 10^{2}$ s 的 $N = 31$ 个点，定义为 $t_i = 10^{\\, -6 + i \\cdot \\frac{8}{30} }$ s，其中 $i = 0, \\dots, 30$。\n  - 离散化方法：对数时间上的梯形法则，$\\ell_i = \\ln t_i$，权重为 $w_0 = \\tfrac{1}{2}(\\ell_{1} - \\ell_{0})$，$w_{i} = \\tfrac{1}{2}(\\ell_{i+1} - \\ell_{i-1})$（对于 $i=1, \\dots, N-2$），以及 $w_{N-1} = \\tfrac{1}{2}(\\ell_{N-1} - \\ell_{N-2})$。\n  - 近似式为：\n  $$E_G \\approx \\left( \\frac{\\sum_{i=0}^{N-1} w_i \\left[ \\ln G_{\\mathrm{model}}(t_i) - \\ln G_{\\mathrm{ref}}(t_i) \\right]^2}{\\sum_{i=0}^{N-1} w_i} \\right)^{1/2}$$\n- 提供了三个测试用例（A、B、C），包含完整的参考和模型参数集，用于 $(\\{g_k\\}, \\{\\tau_k\\})$、$Z$ 和 $\\langle L_{\\mathrm{pp}} \\rangle$。\n\n步骤 2：已知条件的验证。\n问题根据验证标准进行了评估：\n- **科学依据**：该问题植根于高分子物理和流变学，利用了标准模型（$G(t)$ 作为麦克斯韦谱）和分析技术（原始路径分析）。所定义的指标是用于模型验证的合理定量度量。提供的物理参数是符合实际的。\n- **适定性**：该问题以数学精度进行了规定。所有函数、参数、数值方法和数据都得到了明确定义，从而可以计算出唯一的解。\n- **客观性**：语言正式，没有任何主观论断。该任务是基于客观数据和公式的纯计算任务。\n- **无缺陷**：该问题不违反任何基本原则。它在计算上是可行的，自成体系，并且没有矛盾、模糊或琐碎之处（测试用例B除外，它是一个有效的零情况测试）。在对数网格上指定梯形法则是连贯且定义明确的。\n\n步骤 3：结论与行动。\n该问题是 **有效的**。将提供一个完整的、有理有据的解决方案。\n\n**解题步骤**\n\n任务是为三个不同的测试用例计算四个验证指标 $E_G$、$E_Z$、$E_L$ 和 $Q$。该过程的结构如下：\n\n1.  **定义时间网格**：生成一个包含 $N=31$ 个点的对数时间网格 $\\{t_i\\}$，范围从 $t_{\\min} = 10^{-6}$ s 到 $t_{\\max} = 10^2$ s。网格点由 $t_i = 10^{-6 + i \\cdot (8/30)}$（其中 $i = 0, \\dots, 30$）给出。这对应于对数时间上的均匀网格。\n\n2.  **计算剪切模量 $G(t)$**：对于每个测试用例，在时间网格的每个点 $t_i$ 上，使用提供的多模式麦克斯韦谱计算参考模量 $G_{\\mathrm{ref}}(t)$ 和模型模量 $G_{\\mathrm{model}}(t)$：\n    $$G(t_i) = \\sum_{k=1}^{M} g_k \\exp(-t_i/\\tau_k)$$\n    此计算分别针对参考和模型参数集执行。\n\n3.  **计算模量误差 $E_G$**：使用指定的离散近似计算误差指标 $E_G$。\n    - 首先，计算对数时间点 $\\ell_i = \\ln t_i$。\n    - 由于 $\\{t_i\\}$ 的对数间隔是均匀的，对数时间步长 $\\Delta\\ell = \\ell_{i+1} - \\ell_i$ 是恒定的。$\\Delta\\ell = \\frac{\\ln(t_{\\max}) - \\ln(t_{\\min})}{N-1} = \\frac{(2 - (-6))\\ln 10}{30} = \\frac{8}{30}\\ln 10$。\n    - 计算梯形法则的权重 $\\{w_i\\}$。对于 $\\ell$ 上的均匀网格，权重简化为 $w_0 = w_{N-1} = \\frac{1}{2}\\Delta\\ell$ 和 $w_i = \\Delta\\ell$（对于 $i=1, \\dots, N-2$）。\n    - 权重之和为 $\\sum_{i=0}^{N-1} w_i = (N-1)\\Delta\\ell = \\ln(t_{\\max}/\\t_{\\min})$。\n    - 对每个点 $t_i$ 计算对数模量的平方差 $(\\ln G_{\\mathrm{model}}(t_i) - \\ln G_{\\mathrm{ref}}(t_i))^2$。\n    - 然后，$E_G$ 是这些平方差的加权平均值的平方根：\n    $$E_G = \\sqrt{\\frac{\\sum_{i=0}^{N-1} w_i (\\ln G_{\\mathrm{model}}(t_i) - \\ln G_{\\mathrm{ref}}(t_i))^2}{\\sum_{i=0}^{N-1} w_i}}$$\n\n4.  **计算标量误差 $E_Z$ 和 $E_L$**：纠缠数和原始路径长度的相对误差直接根据其定义计算：\n    $$E_Z = \\frac{| Z_{\\mathrm{model}} - Z_{\\mathrm{ref}} |}{Z_{\\mathrm{ref}}}$$\n    $$E_L = \\frac{| \\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{model}} - \\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}} |}{\\langle L_{\\mathrm{pp}} \\rangle_{\\mathrm{ref}}}$$\n\n5.  **计算综合得分 $Q$**：将各个误差指标组合成综合得分 $Q$：\n    $$Q = \\sqrt{E_G^2 + E_Z^2 + E_L^2}$$\n\n整个过程在一个计算机程序中实现，该程序遍历三个测试用例（A、B和 C），计算四个指标 $[E_G, E_Z, E_L, Q]$，并按规定格式化结果。\n\n例如，在测试用例 A 中：\n- $E_Z = \\frac{|19 - 20|}{20} = 0.05$。\n- $E_L = \\frac{|118 - 120|}{120} = \\frac{2}{120} \\approx 0.016667$。\n- $E_G$ 需要上述完整的数值计算过程。一旦找到 $E_G$，即可计算 $Q$。\n\n对于测试用例B，其中模型和参考数据完全相同，所有误差指标（$E_G$、$E_Z$、$E_L$）和综合得分 $Q$ 都将恰好为零，这为验证实现的正确性提供了一个有用的方法。\n最终的程序为所有测试用例实现了这些步骤，并生成所需的输出格式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates slip-link model predictions against reference data by computing\n    error metrics EG, EZ, EL, and a composite score Q.\n    \"\"\"\n\n    test_cases = [\n        # Test case A (general case)\n        {\n            \"ref\": {\"g\": [1.5e5, 8.0e4, 3.0e4], \"tau\": [1.0e-4, 1.0e-1, 1.0e1], \"Z\": 20.0, \"L\": 120.0},\n            \"model\": {\"g\": [1.4e5, 8.5e4, 2.8e4], \"tau\": [1.2e-4, 8.0e-2, 1.2e1], \"Z\": 19.0, \"L\": 118.0},\n        },\n        # Test case B (perfect agreement boundary)\n        {\n            \"ref\": {\"g\": [1.5e5, 8.0e4, 3.0e4], \"tau\": [1.0e-4, 1.0e-1, 1.0e1], \"Z\": 20.0, \"L\": 120.0},\n            \"model\": {\"g\": [1.5e5, 8.0e4, 3.0e4], \"tau\": [1.0e-4, 1.0e-1, 1.0e1], \"Z\": 20.0, \"L\": 120.0},\n        },\n        # Test case C (mismatch edge case)\n        {\n            \"ref\": {\"g\": [1.5e5, 8.0e4, 3.0e4], \"tau\": [1.0e-4, 1.0e-1, 1.0e1], \"Z\": 20.0, \"L\": 120.0},\n            \"model\": {\"g\": [7.5e4, 4.0e4, 1.5e4], \"tau\": [5.0e-5, 5.0e-2, 5.0e0], \"Z\": 10.0, \"L\": 200.0},\n        },\n    ]\n\n    def calculate_g_t(t_grid, g_k, tau_k):\n        \"\"\"Calculates the shear modulus G(t) over a time grid.\"\"\"\n        g_t = np.zeros_like(t_grid, dtype=np.float64)\n        for g, tau in zip(g_k, tau_k):\n            g_t += g * np.exp(-t_grid / tau)\n        return g_t\n\n    def compute_metrics(case):\n        \"\"\"Computes all four metrics for a single test case.\"\"\"\n        # Unpack reference and model data\n        ref_data = case[\"ref\"]\n        model_data = case[\"model\"]\n\n        # Calculate E_Z\n        if ref_data[\"Z\"] == 0:\n            e_z = np.inf if model_data[\"Z\"] != 0 else 0.0\n        else:\n            e_z = np.abs(model_data[\"Z\"] - ref_data[\"Z\"]) / ref_data[\"Z\"]\n\n        # Calculate E_L\n        if ref_data[\"L\"] == 0:\n            e_l = np.inf if model_data[\"L\"] != 0 else 0.0\n        else:\n            e_l = np.abs(model_data[\"L\"] - ref_data[\"L\"]) / ref_data[\"L\"]\n\n        # Setup for E_G calculation\n        N = 31\n        t_min, t_max = 1e-6, 1e2\n        t_grid = np.logspace(np.log10(t_min), np.log10(t_max), num=N, dtype=np.float64)\n\n        g_ref = calculate_g_t(t_grid, ref_data[\"g\"], ref_data[\"tau\"])\n        g_model = calculate_g_t(t_grid, model_data[\"g\"], model_data[\"tau\"])\n\n        # Prevent log(0) issues, although problem states G(t) > 0.\n        if np.any(g_ref = 0) or np.any(g_model = 0):\n            # This case should not be reached according to problem statement\n            return [np.nan, e_z, e_l, np.nan]\n\n        ln_g_ref = np.log(g_ref)\n        ln_g_model = np.log(g_model)\n        \n        # Calculate E_G using trapezoidal rule in log-time\n        ln_t_grid = np.log(t_grid)\n        \n        # Trapezoidal weights calculation\n        delta_ln_t = ln_t_grid[1:] - ln_t_grid[:-1]\n        \n        weights = np.zeros(N, dtype=np.float64)\n        weights[0] = 0.5 * delta_ln_t[0]\n        weights[1:-1] = 0.5 * (delta_ln_t[1:] + delta_ln_t[:-1])\n        weights[-1] = 0.5 * delta_ln_t[-1]\n\n        # Since the grid is uniform in log-space, the calculation simplifies,\n        # but the general form is used for correctness.\n        \n        sum_weights = np.sum(weights)\n        \n        # Sum of weighted squared differences\n        integrand = (ln_g_model - ln_g_ref)**2\n        integral_val = np.sum(weights * integrand)\n        \n        if sum_weights > 0:\n            e_g = np.sqrt(integral_val / sum_weights)\n        else:\n            e_g = 0.0\n\n        # Calculate composite score Q\n        q_score = np.sqrt(e_g**2 + e_z**2 + e_l**2)\n        \n        return [e_g, e_z, e_l, q_score]\n\n    all_results = []\n    for case in test_cases:\n        results = compute_metrics(case)\n        all_results.append(results)\n\n    # Format the output string as per the strict requirement\n    outer_parts = []\n    for res_list in all_results:\n        inner_parts = [f\"{x:.6f}\" for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2930842"}]}