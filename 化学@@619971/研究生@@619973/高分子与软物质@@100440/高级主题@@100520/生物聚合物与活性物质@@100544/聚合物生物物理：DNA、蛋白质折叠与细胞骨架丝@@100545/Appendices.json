{"hands_on_practices": [{"introduction": "双链DNA等生物聚合物是带电的，其刚度或持续长度受到周围离子环境的显著影响。本练习将引导你应用经典的Odijk-Skolnick-Fixman (OSF) 理论，该理论将持续长度 $\\ell_p$ 分解为固有的机械部分和依赖于盐浓度的静电部分。通过将理论模型与（假设的）实验数据进行拟合，你将能够量化DNA的内在刚度以及静电相互作用的强度，从而掌握将物理模型与实验测量联系起来的核心研究技能。[@problem_id:2907118]", "problem": "一种半柔性聚电解质，如双链脱氧核糖核酸 (DNA)，可以被建模为一个蠕虫状链。其持续长度由一个短程（力学）部分和一个长程（静电）部分组成，后者源于被屏蔽的库仑相互作用。从以下基本依据出发：(i) 蠕虫状链持续长度的定义，即弯曲模量与热能之比；(ii) 适用于电解质的线性化 Debye–Hückel 理论，其中德拜屏蔽参数与离子强度 $I$ 的关系为 $\\kappa \\propto I^{1/2}$；以及 (iii) Odijk–Skolnick–Fixman 论证，即对于均匀带电的圆柱体，对弯曲模量的静电贡献与 $\\kappa^{-2}$ 成正比。请推导出一个最小双参数模型，用于描述总持续长度作为离子强度的函数，该模型需与这些标度关系一致，并满足总持续长度在高离子强度下趋近于一个有限常数的要求。然后，实现一个程序，根据给定的离子强度和持续长度的测量值，通过普通最小二乘法拟合此双参数模型，并返回最佳拟合参数及其解释。\n\n您的程序必须：\n- 推导并拟合由上述约束所隐含的、唯一的参数线性模型，使用一个由 $I$ 构建的设计变量，该变量强制静电项与离子强度成反比。\n- 使用普通最小二乘法，通过最小化残差平方和，从数据 $\\{(I_i,\\ell_{p,i})\\}$ 中估计这两个参数。算法上要求以矩阵形式求解线性正规方程组。\n- 解释拟合的参数：确定哪个参数是持续长度在高离子强度下的渐近值（单位为纳米），哪个参数量化了与离子强度倒数相乘的静电强度因子（单位为纳米-摩尔）。\n\n物理单位和输出规范：\n- 离子强度 $I$ 必须以 $\\mathrm{mol\\cdot L^{-1}}$ 为单位处理。\n- 持续长度 $\\ell_p$ 必须以 $\\mathrm{nm}$ 为单位处理。\n- 两个输出参数必须报告为 $\\ell_p^0$（单位 $\\mathrm{nm}$）和 $a$（单位 $\\mathrm{nm\\cdot M}$）。\n- 将每个报告的参数四舍五入到恰好三位小数。\n\n测试套件：\n- 情况 A（从低盐到高盐的平衡情况）：\n  - $I$ (单位 $\\mathrm{M}$): $[0.001,\\,0.003,\\,0.01,\\,0.03,\\,0.1]$\n  - $\\ell_p$ (单位 $\\mathrm{nm}$): $[95.3,\\,61.4666667,\\,50.1,\\,46.5666667,\\,45.5]$\n- 情况 B（高盐，变化微弱）：\n  - $I$ (单位 $\\mathrm{M}$): $[0.2,\\,0.3,\\,0.5,\\,1.0]$\n  - $\\ell_p$ (单位 $\\mathrm{nm}$): $[45.3,\\,45.1466667,\\,45.1,\\,45.06]$\n- 情况 C（极低盐，强静电作用）：\n  - $I$ (单位 $\\mathrm{M}$): $[0.0005,\\,0.001,\\,0.002,\\,0.005]$\n  - $\\ell_p$ (单位 $\\mathrm{nm}$): $[144.5,\\,95.0,\\,70.1,\\,54.8]$\n- 情况 D（具有更强基线和静电作用的不同聚合物或缓冲液）：\n  - $I$ (单位 $\\mathrm{M}$): $[0.002,\\,0.005,\\,0.02,\\,0.2]$\n  - $\\ell_p$ (单位 $\\mathrm{nm}$): $[92.2,\\,67.9,\\,56.0,\\,52.45]$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个结果列表，每个情况一个结果。每个情况报告为一个双元素列表 $[\\ell_p^0,\\,a]$，其中每个数字四舍五入到三位小数并以上述单位表示。因此，完整输出必须是一个包含四个双元素列表的单一列表，例如 $[[\\ell_p^0,\\,a],[\\ell_p^0,\\,a],[\\ell_p^0,\\,a],[\\ell_p^0,\\,a]]$，打印在单行上，无额外文本。", "solution": "该问题要求推导并应用一个物理模型，该模型描述了半柔性聚电解质（如双链DNA）的持续长度如何随周围电解质的离子强度变化。该模型必须从基本原理中推导出来，其参数必须通过普通最小二乘法对所提供的实验数据进行拟合。\n\n分析分两个阶段进行：首先，从给定的物理论证中推导出数学模型；其次，构建并求解线性回归问题以确定模型参数。\n\n**1. 双参数模型的推导**\n\n问题指出，总持续长度 $\\ell_p$ 是短程力学贡献 $\\ell_p^{mech}$ 和长程静电贡献 $\\ell_p^{elec}$ 的和。\n$$\n\\ell_p = \\ell_p^{mech} + \\ell_p^{elec}\n$$\n力学部分 $\\ell_p^{mech}$ 源于聚合物骨架的内在刚度，与离子强度 $I$ 无关。问题包含一个约束条件，即在高离子强度下 ($I \\to \\infty$)，总持续长度趋于一个有限常数。在此极限下，静电相互作用被完全屏蔽，导致静电贡献消失，$\\ell_p^{elec} \\to 0$。因此，持续长度的高盐极限就是力学贡献。我们将此常数定义为 $\\ell_p^0$。\n$$\n\\lim_{I \\to \\infty} \\ell_p(I) = \\ell_p^{mech} = \\ell_p^0\n$$\n因此，模型可以写成：\n$$\n\\ell_p(I) = \\ell_p^0 + \\ell_p^{elec}(I)\n$$\n为了确定 $\\ell_p^{elec}(I)$ 的函数形式，我们遵循给定的物理论证：\n\n(i) 持续长度是弯曲模量 $K$ 与热能 $k_B T$ 的比值。这分别适用于每个贡献部分。\n$$\n\\ell_p^{elec} = \\frac{K_{elec}}{k_B T}\n$$\n其中 $K_{elec}$ 是对弯曲模量的静电贡献。\n\n(ii) 根据 Odijk–Skolnick–Fixman (OSF) 论证，对于一个均匀带电的圆柱体，静电弯曲模量与德拜屏蔽参数 $\\kappa$ 的平方成反比。\n$$\nK_{elec} \\propto \\kappa^{-2}\n$$\n将两者结合，得到 $\\ell_p^{elec} \\propto \\kappa^{-2}$。\n\n(iii) 根据线性化 Debye–Hückel 理论，代表逆屏蔽长度的德拜参数与离子强度的平方根成正比。\n$$\n\\kappa \\propto I^{1/2}\n$$\n因此，$\\kappa^2 \\propto I$。\n\n将此标度关系代入 $\\ell_p^{elec}$ 的表达式中，我们发现静电持续长度与离子强度成反比。\n$$\n\\ell_p^{elec} \\propto (I^{1/2})^{-2} \\implies \\ell_p^{elec} \\propto I^{-1}\n$$\n我们引入一个比例常数 $a$，它整合了各种物理因素，如热能、溶剂介电常数和聚合物的线性电荷密度。由此得到静电贡献的表达式：\n$$\n\\ell_p^{elec}(I) = \\frac{a}{I}\n$$\n结合力学和静电部分，我们得到了描述总持续长度作为离子强度函数的最小化双参数模型：\n$$\n\\ell_p(I) = \\ell_p^0 + \\frac{a}{I}\n$$\n此模型与所有前提一致。待确定的两个参数是 $\\ell_p^0$（内在持续长度）和 $a$（一个量化静电效应强度的参数）。\n\n**2. 通过普通最小二乘法 (OLS) 进行参数估计**\n\n推导出的模型在其参数 $\\ell_p^0$ 和 $a$ 上是线性的。对于一组 $n$ 个测量值 $(I_i, \\ell_{p,i})$，我们可以为每个数据点 $i$ 写出模型：\n$$\n\\ell_{p,i} = \\ell_p^0 + a \\left(\\frac{1}{I_i}\\right) + \\varepsilon_i\n$$\n其中 $\\varepsilon_i$ 是第 $i$ 次测量的残差。这是一个简单的线性回归问题。令因变量为 $y_i = \\ell_{p,i}$，并定义一个设计变量 $x_i = 1/I_i$。模型变为：\n$$\ny_i = \\ell_p^0 \\cdot 1 + a \\cdot x_i + \\varepsilon_i\n$$\n这个包含 $n$ 个方程的系统可以用矩阵形式表示为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$，其中：\n- $\\mathbf{y}$ 是 $n \\times 1$ 的观测持续长度向量：$\\mathbf{y} = [\\ell_{p,1}, \\ell_{p,2}, \\dots, \\ell_{p,n}]^T$。\n- $\\mathbf{X}$ 是 $n \\times 2$ 的设计矩阵，其第一列是全为1的向量（用于截距项），第二列是设计变量值的向量：\n$$\n\\mathbf{X} = \\begin{pmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\vdots & \\vdots \\\\ 1 & x_n \\end{pmatrix} = \\begin{pmatrix} 1 & 1/I_1 \\\\ 1 & 1/I_2 \\\\ \\vdots & \\vdots \\\\ 1 & 1/I_n \\end{pmatrix}\n$$\n- $\\boldsymbol{\\beta}$ 是 $2 \\times 1$ 的待估计参数向量：$\\boldsymbol{\\beta} = [\\ell_p^0, a]^T$。\n- $\\boldsymbol{\\varepsilon}$ 是 $n \\times 1$ 的残差向量。\n\n普通最小二乘法找到的参数向量 $\\hat{\\boldsymbol{\\beta}}$ 能使残差平方和 $S = \\boldsymbol{\\varepsilon}^T \\boldsymbol{\\varepsilon} = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})$ 最小化。这个最小化问题的解由正规方程组给出：\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的（只要不是所有的 $I_i$ 值都相同，这个条件就成立），$\\boldsymbol{\\beta}$ 的 OLS 估计量为：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n程序将实现此矩阵方程，为每个给定的数据集找到 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\ell}_p^0, \\hat{a}]^T$ 的值。\n\n**3. 参数解释**\n\n- $\\hat{\\ell}_p^0$: $\\hat{\\boldsymbol{\\beta}}$ 的第一个元素是 $\\ell_p$ 对 $1/I$ 回归的截距。它代表了在无限离子强度下（$1/I \\to 0$）的持续长度，对应于聚合物的内在力学刚度。其单位是纳米（$\\mathrm{nm}$）。\n- $\\hat{a}$: $\\hat{\\boldsymbol{\\beta}}$ 的第二个元素是回归的斜率。它量化了静电贡献对持续长度的大小。根据模型 $\\ell_p(I) = \\ell_p^0 + a/I$，要使 $\\ell_p$ 的单位是 $\\mathrm{nm}$ 而 $I$ 的单位是摩尔浓度（$\\mathrm{M}$ 或 $\\mathrm{mol \\cdot L^{-1}}$），参数 $a$ 的单位必须是 $\\mathrm{nm \\cdot M}$。\n\n该实现将根据输入数据构建矩阵 $\\mathbf{X}$ 和 $\\mathbf{y}$，使用矩阵代数求解 $\\hat{\\boldsymbol{\\beta}}$，并报告保留三位小数的两个参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and fits a two-parameter model for polyelectrolyte persistence length\n    to experimental data using ordinary least squares.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (balanced low-to-high salt)\n        (\n            [0.001, 0.003, 0.01, 0.03, 0.1],\n            [95.3, 61.4666667, 50.1, 46.5666667, 45.5]\n        ),\n        # Case B (high salt, weak variation)\n        (\n            [0.2, 0.3, 0.5, 1.0],\n            [45.3, 45.1466667, 45.1, 45.06]\n        ),\n        # Case C (very low salt, strong electrostatics)\n        (\n            [0.0005, 0.001, 0.002, 0.005],\n            [144.5, 95.0, 70.1, 54.8]\n        ),\n        # Case D (different polymer or buffer)\n        (\n            [0.002, 0.005, 0.02, 0.2],\n            [92.2, 67.9, 56.0, 52.45]\n        ),\n    ]\n\n    # Store results for all cases\n    all_results = []\n\n    for i_vals, lp_vals in test_cases:\n        # Convert data to numpy arrays for vectorization\n        I = np.array(i_vals)\n        lp = np.array(lp_vals)\n\n        # The model is lp = lp_0 + a * (1/I).\n        # This is a linear model y = beta_0 + beta_1 * x,\n        # with y = lp, x = 1/I, beta_0 = lp_0, beta_1 = a.\n        \n        # Construct the design matrix X.\n        # The first column is for the intercept (lp_0), so it's all ones.\n        # The second column is the independent variable, 1/I.\n        design_variable = 1.0 / I\n        X = np.c_[np.ones(len(I)), design_variable]\n\n        # The vector of observations y is the persistence length data.\n        y = lp\n\n        # Solve the normal equations for the parameters beta = [lp_0, a]:\n        # (X^T * X) * beta = X^T * y\n        # beta = (X^T * X)^-1 * X^T * y\n        \n        try:\n            # Calculate (X^T * X)\n            XTX = X.T @ X\n            # Calculate its inverse\n            XTX_inv = np.linalg.inv(XTX)\n            # Calculate X^T * y\n            XTy = X.T @ y\n            # Solve for the parameter vector beta_hat\n            beta_hat = XTX_inv @ XTy\n        except np.linalg.LinAlgError:\n            # In case of a singular matrix, which shouldn't happen for valid input.\n            beta_hat = [np.nan, np.nan]\n\n        # The parameters are lp_0 (intercept) and a (slope).\n        lp0_fit = beta_hat[0]\n        a_fit = beta_hat[1]\n\n        # Store the results for this case.\n        all_results.append((lp0_fit, a_fit))\n\n    # Format the final output string as a list of two-element lists,\n    # with each parameter rounded to exactly three decimal places.\n    # The format specifier ':.3f' ensures trailing zeros are included.\n    # The construction avoids spaces that Python's default list-to-string\n    # conversion would add, matching the implicit formatting of the prompt.\n    output_parts = []\n    for lp0, a in all_results:\n        output_parts.append(f\"[{lp0:.3f},{a:.3f}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2907118"}, {"introduction": "细胞骨架丝（如肌动蛋白）的聚合如何在细胞内产生推动力，例如在细胞迁移过程中推动细胞膜？本练习将带你探索这一基本问题的核心机制——布朗棘轮模型。你将从统计力学的基本原理出发，推导出聚合速度 $v$ 与其所对抗的阻力 $f$ 之间的关系。这个推导过程将使你深刻理解细胞如何利用热涨落和单体聚合的化学能来完成机械功，这是生物物理学中一个优雅而深刻的范例。[@problem_id:2907121]", "problem": "一根单独的肌动蛋白丝（actin filament）生长时顶着一个施加恒定阻力的刚性平面障碍物。该蛋白丝通过沿其轴线方向增加大小为 $a$ 的单体来伸长。设蛋白丝尖端与障碍物之间的间隙为 $z \\ge 0$。假设在温度 $T$ 下，障碍物在恒定阻力 $f$ 的作用下处于准静态热平衡状态，因此间隙的玻尔兹曼权重由势能 $U(z) = f z$ 决定。单体的增加需要间隙大于单体大小，即 $z > a$。与单体增加相比，忽略单体的解离。当满足几何约束 $z > a$ 时，单体的增加是一个泊松过程（Poisson process），其尝试速率为 $k_{\\mathrm{on}} c$，其中 $k_{\\mathrm{on}}$ 是聚合速率常数， $c$ 是单体浓度。\n\n1. 从势能 $U(z) = fz$ 下 $z$ 的玻尔兹曼分布以及上述动力学图像出发，推导蛋白丝尖端的力-速度关系 $v(f)$。\n\n2. 在温度 $T = 300\\,\\mathrm{K}$ 下，对负载下蛋白丝的生长速度进行了以下实验测量：\n   - 在 $f = 0.0\\,\\mathrm{pN}$ 时，$v = 130\\,\\mathrm{nm\\,s^{-1}}$。\n   - 在 $f = 2.0\\,\\mathrm{pN}$ 时，$v = 35.3\\,\\mathrm{nm\\,s^{-1}}$。\n   \n   利用您推导的关系，将数据视为表现出指数级负载依赖性，并求出单体大小 $a$。您可以取玻尔兹曼常数 $k_B = 1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$ 并使用 $1\\,\\mathrm{J} = 10^{21}\\,\\mathrm{pN\\,nm}$。将最终结果四舍五入至三位有效数字。以纳米为单位表示最终答案。", "solution": "该问题陈述构成了统计生物物理学中一个适定问题，特别涉及通过聚合蛋白丝产生力的布朗棘轮模型。所有提供的信息都具有科学依据、相互一致，并且足以进行推导和计算。因此，该问题被认为是有效的。\n\n根据要求，解答分为两部分：首先，推导力-速度关系；其次，根据提供的实验数据计算单体大小。\n\n第1部分：推导力-速度关系 $v(f)$。\n\n蛋白丝的平均生长速度 $v$ 是每次单体增加事件所增加的长度 $a$ 与这些事件的平均速率 $\\langle R \\rangle$ 的乘积。\n$$\nv = a \\langle R \\rangle\n$$\n问题陈述指出，单体增加是一个泊松过程，其尝试速率为 $k_{\\mathrm{on}}c$，且只有在蛋白丝尖端与障碍物之间的间隙 $z$ 大于单体大小 $a$ 时才能成功。因此，对于给定的间隙 $z$，瞬时增加速率为：\n$$\nR(z) = \\begin{cases} k_{\\mathrm{on}}c & \\text{if } z > a \\\\ 0 & \\text{if } z \\le a \\end{cases}\n$$\n平均速率 $\\langle R \\rangle$ 是通过对间隙大小 $z$ 的概率分布求 $R(z)$ 的平均值得到的。\n$$\n\\langle R \\rangle = \\int_0^\\infty R(z) p(z) dz\n$$\n其中 $p(z)$ 是间隙大小 $z$ 的概率密度函数。问题指明，在温度 $T$ 下，间隙在势能 $U(z) = fz$ 的作用下处于准静态热平衡状态。概率密度遵循玻尔兹曼分布：\n$$\np(z) = \\frac{\\exp\\left(-\\frac{U(z)}{k_B T}\\right)}{Z} = \\frac{\\exp\\left(-\\frac{fz}{k_B T}\\right)}{Z}\n$$\n其中 $k_B$ 是玻尔兹曼常数，$Z$ 是配分函数。配分函数是归一化常数，通过对所有可能的状态（即所有 $z \\ge 0$）积分玻尔兹曼因子获得。\n$$\nZ = \\int_0^\\infty \\exp\\left(-\\frac{fz}{k_B T}\\right) dz\n$$\n对于 $f > 0$，该积分收敛：\n$$\nZ = \\left[ -\\frac{k_B T}{f} \\exp\\left(-\\frac{fz}{k_B T}\\right) \\right]_0^\\infty = 0 - \\left(-\\frac{k_B T}{f} \\exp(0)\\right) = \\frac{k_B T}{f}\n$$\n现在我们可以计算平均速率 $\\langle R \\rangle$：\n$$\n\\langle R \\rangle = \\int_0^\\infty R(z) p(z) dz = \\int_a^\\infty (k_{\\mathrm{on}}c) \\frac{\\exp\\left(-\\frac{fz}{k_B T}\\right)}{Z} dz\n$$\n代入 $Z$ 的表达式：\n$$\n\\langle R \\rangle = (k_{\\mathrm{on}}c) \\frac{f}{k_B T} \\int_a^\\infty \\exp\\left(-\\frac{fz}{k_B T}\\right) dz\n$$\n我们计算该积分：\n$$\n\\int_a^\\infty \\exp\\left(-\\frac{fz}{k_B T}\\right) dz = \\left[ -\\frac{k_B T}{f} \\exp\\left(-\\frac{fz}{k_B T}\\right) \\right]_a^\\infty = 0 - \\left(-\\frac{k_B T}{f} \\exp\\left(-\\frac{fa}{k_B T}\\right)\\right) = \\frac{k_B T}{f} \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n将此结果代回 $\\langle R \\rangle$ 的表达式中：\n$$\n\\langle R \\rangle = (k_{\\mathrm{on}}c) \\frac{f}{k_B T} \\left( \\frac{k_B T}{f} \\exp\\left(-\\frac{fa}{k_B T}\\right) \\right) = k_{\\mathrm{on}}c \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n最后，速度 $v(f)$ 为：\n$$\nv(f) = a \\langle R \\rangle = a k_{\\mathrm{on}}c \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n零力下的速度 $v_0 = v(f=0)$ 为 $v_0 = a k_{\\mathrm{on}}c$。因此，力-速度关系可以写成：\n$$\nv(f) = v_0 \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n这就是所求的力-速度关系，它表明速度随着阻力的增加而呈指数衰减。\n\n第2部分：计算单体大小 $a$。\n\n我们得到两个数据点：\n1. $f_1 = 0.0\\,\\mathrm{pN}$，$v_1 = 130\\,\\mathrm{nm\\,s^{-1}}$\n2. $f_2 = 2.0\\,\\mathrm{pN}$，$v_2 = 35.3\\,\\mathrm{nm\\,s^{-1}}$\n\n从第一个数据点，我们确定零力速度为：$v_0 = v(f_1) = v_1 = 130\\,\\mathrm{nm\\,s^{-1}}$。\n\n使用第二个数据点，我们可以写出：\n$$\nv_2 = v_0 \\exp\\left(-\\frac{f_2 a}{k_B T}\\right)\n$$\n为了求解 $a$，我们首先整理方程：\n$$\n\\frac{v_2}{v_0} = \\exp\\left(-\\frac{f_2 a}{k_B T}\\right)\n$$\n对两边取自然对数：\n$$\n\\ln\\left(\\frac{v_2}{v_0}\\right) = -\\frac{f_2 a}{k_B T}\n$$\n分离出 $a$，我们得到：\n$$\na = -\\frac{k_B T}{f_2} \\ln\\left(\\frac{v_2}{v_0}\\right)\n$$\n现在，我们必须计算数值。首先，我们以与所提供的力和距离单位（$\\mathrm{pN}$ 和 $\\mathrm{nm}$）兼容的单位来计算热能 $k_B T$。\n$T = 300\\,\\mathrm{K}$\n$k_B = 1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$\n换算关系为 $1\\,\\mathrm{J} = 10^{21}\\,\\mathrm{pN\\,nm}$。\n$$\nk_B T = (1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}) \\times (300\\,\\mathrm{K}) = 4.141947 \\times 10^{-21}\\,\\mathrm{J}\n$$\n$$\nk_B T = (4.141947 \\times 10^{-21}\\,\\mathrm{J}) \\times \\left(\\frac{10^{21}\\,\\mathrm{pN\\,nm}}{1\\,\\mathrm{J}}\\right) = 4.141947\\,\\mathrm{pN\\,nm}\n$$\n现在我们将这些值代入 $a$ 的表达式中：\n$f_2 = 2.0\\,\\mathrm{pN}$\n$v_0 = 130\\,\\mathrm{nm\\,s^{-1}}$\n$v_2 = 35.3\\,\\mathrm{nm\\,s^{-1}}$\n$$\na = -\\frac{4.141947\\,\\mathrm{pN\\,nm}}{2.0\\,\\mathrm{pN}} \\ln\\left(\\frac{35.3}{130}\\right)\n$$\n$$\na = -2.0709735\\,\\mathrm{nm} \\times \\ln(0.271538...)\n$$\n$$\na = -2.0709735\\,\\mathrm{nm} \\times (-1.30351...)\n$$\n$$\na \\approx 2.7001\\,\\mathrm{nm}\n$$\n根据要求，将结果四舍五入至三位有效数字，我们得到：\n$$\na = 2.70\\,\\mathrm{nm}\n$$\n该值与肌动蛋白丝中每个单体所对应的已知结构参数（上升高度）非常吻合。", "answer": "$$\\boxed{2.70}$$", "id": "2907121"}, {"introduction": "单分子力谱实验，例如用原子力显微镜拉伸单个蛋白质，为我们提供了探索生物分子能量图景的强大工具，但这些过程本质上是非平衡的。如何从非平衡的拉伸功 $W$ 的测量值中精确提取出平衡态的自由能差 $\\Delta F$ 呢？本练习将指导你应用Jarzynski恒等式这一非平衡统计力学中的里程碑式成果来解决此问题。你不仅需要从（假设的）实验数据中估算自由能，还将通过推导和实现一种偏差校正方法，来处理有限样本数带来的统计偏差，这正是该领域研究前沿的核心挑战之一。[@problem_id:2907045]", "problem": "给定通过原子力显微镜拉伸和解折叠单个蛋白质结构域所获得的重复性非平衡功测量值。这些功值是从由固定拉伸方案产生的未知非平衡功分布中进行的独立同分布抽样。假设所有的功都以热能为单位表示，即以玻尔兹曼常数乘以温度 ($k_{\\mathrm{B}}T$) 的倍数表示。在这些单位中，逆热能为 $\\beta = 1$。您的任务是，使用从非平衡功关系推导出的偏差校正估计量，根据这些非平衡功值估计折叠态和解折叠态之间的平衡态自由能差 $\\Delta F$，并评估估计量的收敛性。\n\n以 Jarzynski 等式为基本依据，这是一个经过充分检验的非平衡统计力学结果：\n$$\n\\left\\langle e^{-\\beta W} \\right\\rangle = e^{-\\beta \\Delta F},\n$$\n其中 $W$ 是功随机变量，$\\beta$ 是逆温度，$\\langle \\cdot \\rangle$ 表示对相同协议的重复实现的系综平均。\n\n设 $\\{W_i\\}_{i=1}^N$ 为功值的样本。定义 $Y_i = e^{-\\beta W_i}$，样本均值 $\\bar{Y}_N = \\frac{1}{N}\\sum_{i=1}^N Y_i$，以及无偏样本方差 $s_Y^2 = \\frac{1}{N-1}\\sum_{i=1}^N (Y_i - \\bar{Y}_N)^2$。朴素 Jarzynski 估计量使用 $\\bar{Y}_N$ 将 $\\Delta F$ 估计为 $-\\beta^{-1}\\ln \\bar{Y}_N$。然而，由于对数的凹性，该估计量在有限的 $N$ 下是有偏的。从 Jarzynski 等式出发，并围绕 $Y$ 的总体均值使用对数的二阶泰勒（delta 方法）展开，推导出一个偏差校正估计量，该估计量在期望中消除了主导的 $\\mathcal{O}(1/N)$ 偏差项。然后实现此估计量和收敛性评估，如下所示。\n\n收敛性评估要求：对于给定的容差 $\\varepsilon > 0$，计算数据长度为 $n = 3, 4, \\dots, N$ 的前缀的运行偏差校正估计值 $\\widehat{\\Delta F}_{\\mathrm{bc}}(n)$。将收敛指数 $n^\\star$ 定义为 $\\{3,\\dots,N\\}$ 中的最小 $n$，使得对于所有 $m \\in \\{n+1,\\dots,N\\}$，\n$$\n\\left| \\widehat{\\Delta F}_{\\mathrm{bc}}(m) - \\widehat{\\Delta F}_{\\mathrm{bc}}(m-1) \\right| \\le \\varepsilon.\n$$\n如果不存在这样的 $n$，则收敛指数返回 $-1$。\n\n实现要求：\n- 所有的功都以 $k_{\\mathrm{B}}T$ 为单位，因此设置 $\\beta = 1$。您最终的自由能估计值以 $k_{\\mathrm{B}}T$ 为单位表示。\n- 对于偏差校正中的方差估计，使用除数为 $N-1$ 的无偏样本方差 $s_Y^2$。\n- 对于收敛性扫描，从 $n=3$ 开始，以确保方差有明确定义，并且不会因极小的样本量而产生无关紧要的主导。\n- 将所有报告的自由能估计值四舍五入到 $6$ 位小数。\n- 最终程序必须为每个测试用例生成单行输出，该行包含一个由方括号括起来的逗号分隔列表，序列如下：使用所有数据的朴素 Jarzynski 估计值、使用所有数据的偏差校正估计值，以及收敛指数 $n^\\star$。总输出是所有测试用例的这些三元组按下列顺序列出的串联。\n\n测试套件：\n- 案例 A（中等耗散）：$N = 30$, $\\varepsilon = 0.1$, $\\beta = 1$，功列表为\n  $$\n  W = [\\, 6.2,\\, 6.8,\\, 8.1,\\, 7.5,\\, 6.9,\\, 7.2,\\, 7.8,\\, 6.4,\\, 5.9,\\, 8.3,\\, 7.0,\\, 7.1,\\, 6.6,\\, 8.0,\\, 7.4,\\, 6.5,\\, 7.6,\\, 8.2,\\, 6.7,\\, 7.3,\\, 7.9,\\, 6.3,\\, 5.8,\\, 8.4,\\, 6.1,\\, 7.7,\\, 8.5,\\, 5.7,\\, 6.0,\\, 7.0 \\,].\n  $$\n- 案例 B（近平衡）：$N = 20$, $\\varepsilon = 0.05$, $\\beta = 1$，功列表为\n  $$\n  W = [\\, 3.4,\\, 3.6,\\, 3.7,\\, 3.3,\\, 3.5,\\, 3.6,\\, 3.2,\\, 3.8,\\, 3.5,\\, 3.4,\\, 3.6,\\, 3.5,\\, 3.7,\\, 3.3,\\, 3.4,\\, 3.6,\\, 3.5,\\, 3.7,\\, 3.3,\\, 3.4 \\,].\n  $$\n- 案例 C（远非平衡，宽分布）：$N = 50$, $\\varepsilon = 0.1$, $\\beta = 1$，功列表为\n  $$\n  W = [\\, 12.7,\\, 13.1,\\, 12.5,\\, 13.8,\\, 12.9,\\, 14.2,\\, 12.3,\\, 13.5,\\, 12.8,\\, 14.0,\\, 13.2,\\, 12.6,\\, 13.9,\\, 12.4,\\, 13.3,\\, 12.7,\\, 14.1,\\, 12.2,\\, 13.6,\\, 12.9,\\, 13.0,\\, 14.3,\\, 12.1,\\, 13.4,\\, 12.8,\\, 13.7,\\, 12.0,\\, 13.5,\\, 11.9,\\, 14.4,\\, 12.6,\\, 13.8,\\, 12.7,\\, 13.1,\\, 12.5,\\, 14.0,\\, 13.2,\\, 11.8,\\, 13.6,\\, 12.4,\\, 13.3,\\, 12.7,\\, 13.9,\\, 12.3,\\, 13.5,\\, 11.7,\\, 14.1,\\, 12.2,\\, 13.4,\\, 11.6 \\,].\n  $$\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，顺序如下\n$$\n[\\, \\widehat{\\Delta F}_{\\mathrm{J}}^{(A)},\\, \\widehat{\\Delta F}_{\\mathrm{bc}}^{(A)},\\, n_\\star^{(A)},\\, \\widehat{\\Delta F}_{\\mathrm{J}}^{(B)},\\, \\widehat{\\Delta F}_{\\mathrm{bc}}^{(B)},\\, n_\\star^{(B)},\\, \\widehat{\\Delta F}_{\\mathrm{J}}^{(C)},\\, \\widehat{\\Delta F}_{\\mathrm{bc}}^{(C)},\\, n_\\star^{(C)} \\,],\n$$\n其中上标 $(A)$、$(B)$ 和 $(C)$ 分别指案例 A、B 和 C。报告所有 $\\Delta F$ 值，单位为 $k_{\\mathrm{B}}T$ 并四舍五入到 $6$ 位小数；将每个 $n_\\star$ 报告为整数。", "solution": "该问题陈述经评估在科学上是合理的、定义明确且客观的。它基于非平衡统计力学中已确立的原理，特别是 Jarzynski 等式，并涉及单分子生物物理学中的一个标准应用。所提供的数据和要求的计算是现实的且定义清晰。\n\n收敛指数 $n^\\star$ 的问题定义中存在一个微小的歧义。其定义为：“$n^\\star$ 是 $\\{3,\\dots,N\\}$ 中满足对于所有 $m \\in \\{n+1,\\dots,N\\}$ 都有 $|\\widehat{\\Delta F}_{\\mathrm{bc}}(m) - \\widehat{\\Delta F}_{\\mathrm{bc}}(m-1)| \\le \\varepsilon$ 的最小 $n$。” 对于 $n=N$ 的情况，条件“对于所有 $m \\in \\{N+1,\\dots,N\\}$”是空洞为真（vacuously true），因为 $m$ 的取值集合是空集。这意味着 $n^\\star$ 的解总是在 $\\{3,\\dots,N\\}$ 范围内存在，这与后续指令“如果不存在这样的 $n$，则收敛指数返回 $-1$”相矛盾。这表明，在给定约束（所有 $N \\ge 3$）下，关于返回 $-1$ 的条款可能是多余的，或者出题者意图采用一种对空集上量词的非标准解释。我将采用标准的数学解释继续进行。由此得出的用于寻找 $n^\\star$ 的算法是稳健且明确的：如果估计值序列在数据结束时已经稳定，则会找到一个有限的收敛指数；否则，该指数将对应于最后一个出现显著波动的点。这种方法在科学上是合理的，并且在所有 $N \\ge 3$ 的情况下都能为 $n^\\star$ 提供一个确定的值。\n\n解决方案分两步进行：首先，推导自由能差 $\\Delta F$ 的偏差校正估计量；其次，实现计算和收敛性分析。\n\n**1. 偏差校正估计量的推导**\n\n目标是使用 Jarzynski 等式估计平衡态自由能差 $\\Delta F$：\n$$\n\\left\\langle e^{-\\beta W} \\right\\rangle = e^{-\\beta \\Delta F}\n$$\n其中 $W$ 是在非平衡过程中所做的功，$\\beta = (k_{\\mathrm{B}}T)^{-1}$ 是逆热能，$\\langle \\cdot \\rangle$ 是系综平均。给定一组 $N$ 个功测量值 $\\{W_i\\}_{i=1}^N$，我们定义量 $Y_i = e^{-\\beta W_i}$。$Y$ 的总体均值是 $\\mu_Y = E[Y_i] = \\langle e^{-\\beta W} \\rangle$。真实的自由能差由 $\\Delta F = -\\beta^{-1}\\ln(\\mu_Y)$ 给出。\n\n$\\Delta F$ 的一个朴素估计量是通过用样本均值 $\\bar{Y}_N = \\frac{1}{N}\\sum_{i=1}^N Y_i$ 替换总体均值 $\\mu_Y$ 来构建的：\n$$\n\\widehat{\\Delta F}_{\\mathrm{J}} = -\\beta^{-1}\\ln(\\bar{Y}_N)\n$$\n由于对数是一个凹函数，该估计量对于有限的 $N$ 是有偏的。为了找到主阶偏差，我们对函数 $f(x) = \\ln(x)$ 在总体均值 $\\mu_Y$ 附近进行二阶泰勒展开，并代入样本均值 $\\bar{Y}_N$：\n$$\n\\ln(\\bar{Y}_N) \\approx \\ln(\\mu_Y) + (\\bar{Y}_N - \\mu_Y)f'(\\mu_Y) + \\frac{1}{2}(\\bar{Y}_N - \\mu_Y)^2 f''(\\mu_Y)\n$$\n导数为 $f'(x) = 1/x$ 和 $f''(x) = -1/x^2$。代入这些可得：\n$$\n\\ln(\\bar{Y}_N) \\approx \\ln(\\mu_Y) + \\frac{\\bar{Y}_N - \\mu_Y}{\\mu_Y} - \\frac{(\\bar{Y}_N - \\mu_Y)^2}{2\\mu_Y^2}\n$$\n取两边的期望：\n$$\nE[\\ln(\\bar{Y}_N)] \\approx E[\\ln(\\mu_Y)] + \\frac{E[\\bar{Y}_N - \\mu_Y]}{\\mu_Y} - \\frac{E[(\\bar{Y}_N - \\mu_Y)^2]}{2\\mu_Y^2}\n$$\n我们知道 $E[\\bar{Y}_N] = \\mu_Y$，所以 $E[\\bar{Y}_N - \\mu_Y] = 0$。项 $E[(\\bar{Y}_N - \\mu_Y)^2]$ 是样本均值的方差，即 $\\text{Var}(\\bar{Y}_N)$。对于独立同分布的 $Y_i$，$\\text{Var}(\\bar{Y}_N) = \\sigma_Y^2/N$，其中 $\\sigma_Y^2 = \\text{Var}(Y_i)$ 是 $Y$ 的总体方差。\n因此，对数的期望值为：\n$$\nE[\\ln(\\bar{Y}_N)] \\approx \\ln(\\mu_Y) - \\frac{\\sigma_Y^2}{2N\\mu_Y^2}\n$$\n现在，我们求朴素估计量 $\\widehat{\\Delta F}_{\\mathrm{J}}$ 的期望：\n$$\nE[\\widehat{\\Delta F}_{\\mathrm{J}}] = E[-\\beta^{-1}\\ln(\\bar{Y}_N)] = -\\beta^{-1}E[\\ln(\\bar{Y}_N)] \\approx -\\beta^{-1}\\left(\\ln(\\mu_Y) - \\frac{\\sigma_Y^2}{2N\\mu_Y^2}\\right)\n$$\n$$\nE[\\widehat{\\Delta F}_{\\mathrm{J}}] \\approx -\\beta^{-1}\\ln(\\mu_Y) + \\frac{\\beta^{-1}\\sigma_Y^2}{2N\\mu_Y^2} = \\Delta F + \\frac{\\beta^{-1}\\sigma_Y^2}{2N\\mu_Y^2}\n$$\n主阶偏差是第二项，$\\text{Bias}(\\widehat{\\Delta F}_{\\mathrm{J}}) \\approx \\frac{\\beta^{-1}\\sigma_Y^2}{2N\\mu_Y^2}$。偏差校正估计量 $\\widehat{\\Delta F}_{\\mathrm{bc}}$ 是通过从朴素估计量中减去此偏差的估计值来构建的：\n$$\n\\widehat{\\Delta F}_{\\mathrm{bc}} = \\widehat{\\Delta F}_{\\mathrm{J}} - \\widehat{\\text{Bias}}\n$$\n为了估计偏差，我们用它们的样本估计量替换总体参数 $\\mu_Y$ 和 $\\sigma_Y^2$：用 $\\bar{Y}_N$ 替换 $\\mu_Y$，用无偏样本方差 $s_Y^2 = \\frac{1}{N-1}\\sum_{i=1}^N (Y_i - \\bar{Y}_N)^2$ 替换 $\\sigma_Y^2$。这产生了偏差校正估计量：\n$$\n\\widehat{\\Delta F}_{\\mathrm{bc}} = -\\beta^{-1}\\ln(\\bar{Y}_N) - \\frac{\\beta^{-1}s_Y^2}{2N\\bar{Y}_N^2}\n$$\n鉴于所有计算都以 $k_{\\mathrm{B}}T$ 为单位进行，我们设置 $\\beta=1$：\n$$\n\\widehat{\\Delta F}_{\\mathrm{bc}} = -\\ln(\\bar{Y}_N) - \\frac{s_Y^2}{2N\\bar{Y}_N^2}\n$$\n\n**2. 计算和收敛性算法**\n\n实现过程如下：\n首先，对于每个测试用例，使用完整数据集 $\\{W_i\\}_{i=1}^N$ 来计算朴素估计值 $\\widehat{\\Delta F}_{\\mathrm{J}}(N)$ 和使用推导公式计算的偏差校正估计值 $\\widehat{\\Delta F}_{\\mathrm{bc}}(N)$。\n\n其次，评估偏差校正估计量的收敛性。这涉及为从 $n=3$到 $n=N$ 的递增大小 $n$ 的数据前缀计算一系列估计值 $\\widehat{\\Delta F}_{\\mathrm{bc}}(n)$。\n\n收敛指数 $n^\\star$ 是根据这一系列估计值的稳定性来确定的。具体来说，我们确定估计值的变化超过容差 $\\varepsilon$ 的最后一个样本大小 $m$：令 $S = \\{m \\in \\{4, \\dots, N\\} \\mid |\\widehat{\\Delta F}_{\\mathrm{bc}}(m) - \\widehat{\\Delta F}_{\\mathrm{bc}}(m-1)| > \\varepsilon \\}$。\n- 如果集合 $S$ 为空，这意味着估计值在整个过程（对于 $n \\ge 3$）中都是稳定的，所以我们定义 $n^\\star = 3$。\n- 如果 $S$ 不为空，则最后一次显著波动的点发生在 $m_{\\text{max}} = \\max S$。对于任何 $n < m_{\\text{max}}$，收敛准则都被违反。因此，序列尾部开始稳定的最小 $n$ 值为 $n=m_{\\text{max}}$。因此，我们设置 $n^\\star = m_{\\text{max}}$。\n\n对于任何给定的 $N \\ge 3$ 的数据集，此过程为 $n^\\star \\in \\{3, \\dots, N\\}$ 提供了一个唯一的、明确定义的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final formatted output.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"W\": [6.2, 6.8, 8.1, 7.5, 6.9, 7.2, 7.8, 6.4, 5.9, 8.3, 7.0, 7.1, 6.6, 8.0, 7.4, 6.5, 7.6, 8.2, 6.7, 7.3, 7.9, 6.3, 5.8, 8.4, 6.1, 7.7, 8.5, 5.7, 6.0, 7.0],\n            \"N\": 30,\n            \"epsilon\": 0.1,\n            \"beta\": 1.0\n        },\n        {\n            \"name\": \"Case B\",\n            \"W\": [3.4, 3.6, 3.7, 3.3, 3.5, 3.6, 3.2, 3.8, 3.5, 3.4, 3.6, 3.5, 3.7, 3.3, 3.4, 3.6, 3.5, 3.7, 3.3, 3.4],\n            \"N\": 20,\n            \"epsilon\": 0.05,\n            \"beta\": 1.0\n        },\n        {\n            \"name\": \"Case C\",\n            \"W\": [12.7, 13.1, 12.5, 13.8, 12.9, 14.2, 12.3, 13.5, 12.8, 14.0, 13.2, 12.6, 13.9, 12.4, 13.3, 12.7, 14.1, 12.2, 13.6, 12.9, 13.0, 14.3, 12.1, 13.4, 12.8, 13.7, 12.0, 13.5, 11.9, 14.4, 12.6, 13.8, 12.7, 13.1, 12.5, 14.0, 13.2, 11.8, 13.6, 12.4, 13.3, 12.7, 13.9, 12.3, 13.5, 11.7, 14.1, 12.2, 13.4, 11.6],\n            \"N\": 50,\n            \"epsilon\": 0.1,\n            \"beta\": 1.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        W_list = case[\"W\"]\n        N = case[\"N\"]\n        epsilon = case[\"epsilon\"]\n        beta = case[\"beta\"]\n\n        W = np.array(W_list)\n        \n        # 1. Calculate estimators for the full dataset.\n        Y = np.exp(-beta * W)\n        Y_bar = np.mean(Y)\n        \n        # Naive Jarzynski estimator\n        delta_F_J_full = -1/beta * np.log(Y_bar)\n        \n        # Unbiased sample variance with N-1 denominator\n        s_Y_sq = np.var(Y, ddof=1)\n        \n        # Bias correction term and final corrected estimator\n        bias_correction = (s_Y_sq / beta) / (2 * N * Y_bar**2)\n        delta_F_bc_full = delta_F_J_full - bias_correction\n\n        # 2. Convergence analysis\n        # Calculate running bias-corrected estimates for n = 3, 4, ..., N\n        running_bc_estimates = []\n        for n in range(3, N + 1):\n            W_prefix = W[:n]\n            Y_prefix = np.exp(-beta * W_prefix)\n            Y_bar_n = np.mean(Y_prefix)\n            \n            # Naive estimator for prefix\n            delta_F_J_n = -1/beta * np.log(Y_bar_n)\n            \n            # Unbiased variance for prefix\n            s_Y_sq_n = np.var(Y_prefix, ddof=1)\n            \n            # Bias correction for prefix\n            bias_corr_n = (s_Y_sq_n / beta) / (2 * n * Y_bar_n**2)\n            delta_F_bc_n = delta_F_J_n - bias_corr_n\n            running_bc_estimates.append(delta_F_bc_n)\n\n        # Determine the convergence index n_star.\n        # It is the smallest n in {3..N} such that for all m > n,\n        # the change is less than or equal to epsilon.\n        # This is equivalent to finding the last m where the change > epsilon.\n        # That m is the new convergence index n_star. If no such m exists, n_star = 3.\n        \n        m_max_instability = -1\n        # The list running_bc_estimates is indexed 0 to N-3.\n        # The estimate for sample size n is at index n-3.\n        # We are calculating differences for m from 4 to N.\n        for m in range(4, N + 1):\n            # Difference between estimate at m and m-1\n            # Index for m is m-3, for m-1 is m-4\n            diff = abs(running_bc_estimates[m-3] - running_bc_estimates[m-4])\n            if diff > epsilon:\n                m_max_instability = m\n\n        if m_max_instability == -1:\n            # No instability was found for m >= 4, so the sequence is stable from n=3.\n            n_star = 3\n        else:\n            # The last point of instability determines the convergence index.\n            n_star = m_max_instability\n            \n        # Append results for this case.\n        # Free energy values are rounded to 6 decimal places.\n        all_results.append(f\"{delta_F_J_full:.6f}\")\n        all_results.append(f\"{delta_F_bc_full:.6f}\")\n        all_results.append(str(n_star))\n\n    # Print all results in the required single-line format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2907045"}]}