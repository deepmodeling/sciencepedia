{"hands_on_practices": [{"introduction": "在计算聚合物科学中，一个核心挑战是建立能够准确捕捉宏观物理性质的简化模型。这个练习将指导你完成一个关键的多尺度建模任务：参数化一个粗粒化珠簧模型 [@problem_id:2909623]。你将学习如何通过统计力学原理，将模型的微观参数（如键合与非键合相互作用的强度）与从更精细的原子模拟或实验中获得的目标可观测量（如均方端到端距离 $\\langle R^2 \\rangle$ 和等温压缩率 $\\kappa_T$）联系起来。这个实践对于弥合不同时空尺度模型之间的差距至关重要。", "problem": "您将获得一个用于分子动力学 (MD) 或蒙特卡洛 (MC) 模拟的线性均聚物的粗粒化珠簧模型。每条链有 $N$ 个珠子和 $M = N-1$ 个键。键合相互作用由有限可伸展非线性弹性 (FENE) 势建模，其参数为弹簧常数 $k$ 和最大键伸长量 $R_0$。珠子之间的非键相互作用由 Lennard-Jones (LJ) 势的 Weeks-Chandler-Andersen (WCA) 截断建模，其能量标度为 $\\epsilon$，LJ 长度为 $\\sigma$。您的任务是校准参数 $k$、$R_0$ 和 $\\epsilon$，使得该模型能够再现链的目标均方端到端距离 $\\langle R^2 \\rangle$ 和在原子模拟中测得的目标等温压缩系数 $\\kappa_T$，校准过程需使用源于统计力学的原理性推导。\n\n本问题中所有量均在固定温度下以约化 Lennard-Jones 单位表示。具体而言：长度以 $\\sigma$ 为单位（因此任何长度 $x$ 都无量纲化为 $x^\\star = x / \\sigma$），能量以 $k_{\\mathrm{B}} T$ 为单位（因此任何能量 $E$ 都无量纲化为 $E^\\star = E / (k_{\\mathrm{B}} T)$），数密度以 $\\sigma^{-3}$ 为单位（因此 $\\rho^\\star = \\rho \\, \\sigma^3$），等温压缩系数以 $\\sigma^3 / (k_{\\mathrm{B}} T)$ 为单位（因此 $\\kappa_T^\\star = \\kappa_T \\, k_{\\mathrm{B}} T / \\sigma^3$）。在这些约化单位中，将无量纲参数表示为 $k^\\star = k \\, \\sigma^2 / (k_{\\mathrm{B}} T)$、$R_0^\\star = R_0 / \\sigma$ 和 $\\epsilon^\\star = \\epsilon / (k_{\\mathrm{B}} T)$；目标可观测量是在数密度 $\\rho^\\star$ 下的 $\\langle R^2 \\rangle^\\star = \\langle R^2 \\rangle / \\sigma^2$ 和 $\\kappa_T^\\star$。\n\n基本依据和假设：\n- 单键 FENE 势为 $U_{\\mathrm{FENE}}(r) = -\\tfrac{1}{2} k R_0^2 \\ln\\!\\left(1 - \\frac{r^2}{R_0^2}\\right)$（其中 $0 \\le r < R_0$，$r$ 是键长）。玻尔兹曼权重 $e^{-\\beta U}$ 决定了键长的统计特性，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n- 三维空间中单个 FENE 键的配分函数给出了一个在 $0 \\le r < R_0$ 范围内与 $r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r))$ 成正比的径向概率密度。通过使用代换 $x = r^2/R_0^2$ 以及贝塔函数的性质，可以在平衡状态下精确计算出单键均方长度。\n- 在理想链极限下（无角度相关性且无排除体积效应），均方端到端距离满足 $\\langle R^2 \\rangle = \\sum_{i=1}^{M} \\langle \\mathbf{b}_i^2 \\rangle = M \\langle r^2 \\rangle$，其中 $\\mathbf{b}_i$ 是第 $i$ 个键矢量，$r = \\|\\mathbf{b}_i\\|$。\n- 等温压缩系数遵循压缩性方程 $S(0) = \\rho \\, k_{\\mathrm{B}} T \\, \\kappa_T$，其中 $S(0)$ 是零波矢静态结构因子。在双体相互作用占主导地位的稀疏体系中（与场论处理中的第二维里近似或随机相近似 (RPA) 的低波矢极限一致），$S(0)$ 和第二维里系数 $B_2$ 满足\n$$\n\\frac{1}{S(0)} = 1 + 2 B_2 \\rho + \\mathcal{O}(\\rho^2).\n$$\n因此，在约化单位中，\n$$\n\\rho^\\star \\, \\kappa_T^\\star \\approx \\frac{1}{1 + 2 B_2^\\star \\rho^\\star},\n$$\n其中 $B_2^\\star = B_2 / \\sigma^3$。第二维里系数由 Mayer 积分给出\n$$\nB_2 = -2\\pi \\int_0^\\infty \\left(e^{-\\beta u(r)} - 1\\right) r^2 \\, dr.\n$$\n- Lennard-Jones 势的 Weeks-Chandler-Andersen 截断为 $u_{\\mathrm{WCA}}(r) = 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] + \\epsilon$（对于 $0 \\le r \\le r_c$，其中 $r_c = 2^{1/6}\\sigma$），且当 $r > r_c$ 时 $u_{\\mathrm{WCA}}(r) = 0$。\n\n需要推导和实现的任务：\n1) 从玻尔兹曼分布和三维空间中单个 FENE 键的精确积分出发，推导出单键均方长度的约化单位闭式表达式：\n$$\n\\langle r^2 \\rangle^\\star = R_0^{\\star 2} \\, \\frac{3}{k^\\star R_0^{\\star 2} + 5}.\n$$\n然后，引用理想链的可加性 $\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star$，展示如何在给定 $R_0^\\star$、$M$ 和 $\\langle R^2 \\rangle^\\star$ 的情况下计算 $k^\\star$。\n2) 通过以下公式将约化压缩系数 $\\kappa_T^\\star$ 与约化第二维里系数 $B_2^\\star$ 联系起来：\n$$\nB_2^\\star = \\frac{1}{2\\rho^\\star}\\left(\\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1\\right),\n$$\n并通过对下式进行数值积分来从 WCA 势计算 $B_2^\\star$：\n$$\nB_2^\\star(\\epsilon^\\star) = -2\\pi \\int_0^{r_c^\\star} \\left[\\exp\\!\\left(-u^\\star(r^\\star)\\right) - 1 \\right] r^{\\star 2} \\, dr^\\star,\n$$\n其中 $u^\\star(r^\\star) = 4 \\epsilon^\\star \\left[\\left(\\frac{1}{r^\\star}\\right)^{12} - \\left(\\frac{1}{r^\\star}\\right)^6\\right] + \\epsilon^\\star$（对于 $0 \\le r^\\star \\le r_c^\\star$），否则 $u^\\star(r^\\star) = 0$，且 $r_c^\\star = 2^{1/6}$。使用单调求根法来反演 $B_2^\\star(\\epsilon^\\star)$，并根据从 $\\rho^\\star$ 和 $\\kappa_T^\\star$ 计算出的目标 $B_2^\\star$ 获得 $\\epsilon^\\star$。\n3) 为封闭该系统，假定原子模拟提供了链的轮廓长度 $L_c$（完全伸展时的最大端到端长度）。在约化单位中，施加有限可伸展性约束 $L_c^\\star = M \\, R_0^\\star$ 来设定 $R_0^\\star = L_c^\\star / M$。\n\n您的程序必须接受一个预定义的测试套件的目标值，并为每种情况计算并返回 $k^\\star$、$R_0^\\star$ 和 $\\epsilon^\\star$。您必须使用上述的约化单位框架，并如下表示输出：$k^\\star$ 为无量纲，对应于 $k \\, \\sigma^2 / (k_{\\mathrm{B}} T)$；$R_0^\\star$ 为无量纲，如 $R_0 / \\sigma$；$\\epsilon^\\star$ 为无量纲，如 $\\epsilon / (k_{\\mathrm{B}} T)$。\n\n硬编码在程序中的输入参数集 $(N, \\langle R^2 \\rangle^\\star, \\rho^\\star, \\kappa_T^\\star, L_c^\\star)$ 测试套件：\n- 情况 A（一般情况）：$(20, 200.0, 0.1, 8.0, 95.0)$。\n- 情况 B（压缩系数的理想气体极限）：$(10, 50.0, 0.05, 20.0, 30.0)$。\n- 情况 C（短链，中等密度）：$(5, 9.0, 0.2, 4.0, 8.0)$。\n- 情况 D（长链，极低密度）：$(50, 200.0, 0.01, 99.0, 147.0)$。\n\n边界和验证考虑：\n- 为确保 FENE 校准的物理一致性，目标必须满足 $\\langle R^2 \\rangle^\\star < \\frac{3}{5} M R_0^{\\star 2}$；否则推断出的 $k^\\star$ 将为非正值。您的程序应假定所提供的测试套件遵守此界限。\n- 对于 WCA 势，约化第二维里系数的上限为 $B_{2,\\max}^\\star = \\frac{2\\pi}{3} r_c^{\\star 3} = \\frac{2\\pi}{3} 2^{1/2}$。程序应使用区间限定和二分法求解 $\\epsilon^\\star$；如果目标 $B_2^\\star$ 为非正值，则设置 $\\epsilon^\\star = 0$；如果目标超过了在一个非常大的 $\\epsilon^\\star$ 下达到的数值，则返回该大值作为近似。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中按 A、B、C、D 的顺序包含每种情况下的三个校准参数列表 $[k^\\star, R_0^\\star, \\epsilon^\\star]$。将这些列表聚合成一个单一列表，并以如下格式精确打印一行：\n\"[ [kA,R0A,epsA],[kB,R0B,epsB],[kC,R0C,epsC],[kD,R0D,epsD] ]\"\n除了语法正确性外，没有额外的空格要求。\n\n所有角度均与此任务无关。所有物理量均按定义以约化 Lennard-Jones 单位表示，因此不需要额外的单位转换。输出条目应为浮点数。", "solution": "所提出的问题是一项参数化粗粒化聚合物模型的任务。其目标是确定珠簧链的参数，特别是 FENE 键参数 $k^\\star$ 和 $R_0^\\star$，以及 WCA 非键相互作用参数 $\\epsilon^\\star$，从而使模型能再现目标均方端到端距离 $\\langle R^2 \\rangle^\\star$ 和等温压缩系数 $\\kappa_T^\\star$。该问题是适定的，其科学基础在于统计力学原理，并为校准提供了清晰的、分步的程序。因此，该问题被认为是有效的。我们着手进行求解。\n\n总体策略是将问题解耦。首先，我们通过将键合相互作用参数（$k^\\star, R_0^\\star$）与链的结构特性（$\\langle R^2 \\rangle^\\star, L_c^\\star$）相关联来确定它们。其次，我们通过将非键相互作用参数（$\\epsilon^\\star$）与体系的宏观热力学性质（$\\kappa_T^\\star, \\rho^\\star$）相关联来确定它。所有计算都将在指定的约化单位中进行。\n\n**1. 键合相互作用参数（$R_0^\\star$ 和 $k^\\star$）的校准**\n\n问题指定了两个与单链结构相关的输入：轮廓长度 $L_c^\\star$ 和均方端到端距离 $\\langle R^2 \\rangle^\\star$。\n\n首先，我们确定最大键伸长量 $R_0^\\star$。对于一个有 $M = N-1$ 个键，每个键最大长度为 $R_0$ 的链，其轮廓长度 $L_c = M R_0$。在约化单位中，这变为 $L_c^\\star = M R_0^\\star$。这为 $R_0^\\star$ 提供了一个直接的表达式：\n$$\nR_0^\\star = \\frac{L_c^\\star}{M} = \\frac{L_c^\\star}{N-1}\n$$\n\n接下来，我们建立 FENE 弹簧常数 $k^\\star$ 与均方端到端距离 $\\langle R^2 \\rangle^\\star$ 之间的关系。问题指出，在理想链极限下，即键矢量之间没有相关性，总的均方端到端距离是各个均方键长的总和：\n$$\n\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star\n$$\n其中 $\\langle r^2 \\rangle^\\star$ 是单个键的均方长度。我们必须推导单个 FENE 键的 $\\langle r^2 \\rangle^\\star$ 表达式。\n\n键长 $r$ 的概率分布由玻尔兹曼因子决定。在三维空间中，找到长度为 $r$ 的键的归一化概率密度为 $P(r) = (4\\pi/Z) r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r))$，其中 $Z$ 是单键配分函数。均方键长由下式给出：\n$$\n\\langle r^2 \\rangle = \\int_0^{R_0} r^2 P(r) dr = \\frac{\\int_0^{R_0} r^4 \\exp(-\\beta U_{\\mathrm{FENE}}(r)) dr}{\\int_0^{R_0} r^2 \\exp(-\\beta U_{\\mathrm{FENE}}(r)) dr}\n$$\nFENE 势为 $U_{\\mathrm{FENE}}(r) = -\\frac{1}{2} k R_0^2 \\ln(1 - r^2/R_0^2)$。将其代入玻尔兹曼因子中得到：\n$$\n\\exp(-\\beta U_{\\mathrm{FENE}}(r)) = \\exp\\left(\\frac{1}{2}\\beta k R_0^2 \\ln\\left(1 - \\frac{r^2}{R_0^2}\\right)\\right) = \\left(1 - \\frac{r^2}{R_0^2}\\right)^{\\frac{1}{2}\\beta k R_0^2}\n$$\n我们进行变量代换，令 $x = (r/R_0)^2$，因此 $r = R_0 x^{1/2}$ 且 $dr = \\frac{1}{2} R_0 x^{-1/2} dx$。积分变为：\n$$\n\\int_0^{R_0} r^n \\left(1 - \\frac{r^2}{R_0^2}\\right)^{\\alpha} dr = \\int_0^1 (R_0 x^{1/2})^n (1-x)^\\alpha \\left(\\frac{1}{2} R_0 x^{-1/2} dx\\right) = \\frac{R_0^{n+1}}{2} \\int_0^1 x^{(n-1)/2} (1-x)^\\alpha dx\n$$\n其中 $\\alpha = \\frac{1}{2}\\beta k R_0^2$。该积分与贝塔函数 $B(p,q) = \\int_0^1 t^{p-1}(1-t)^{q-1}dt$ 有关。\n\n对于分母（$n=2$）：$p-1 = (2-1)/2 = 1/2 \\implies p=3/2$。$q-1=\\alpha \\implies q=\\alpha+1$。积分为 $\\frac{R_0^3}{2} B(3/2, \\alpha+1)$。\n对于分子（$n=4$）：$p-1 = (4-1)/2 = 3/2 \\implies p=5/2$。$q-1=\\alpha \\implies q=\\alpha+1$。积分为 $\\frac{R_0^5}{2} B(5/2, \\alpha+1)$。\n\n因此，均方长度为：\n$$\n\\langle r^2 \\rangle = \\frac{\\frac{R_0^5}{2} B(5/2, \\alpha+1)}{\\frac{R_0^3}{2} B(3/2, \\alpha+1)} = R_0^2 \\frac{B(5/2, \\alpha+1)}{B(3/2, \\alpha+1)}\n$$\n使用恒等式 $B(p,q) = \\frac{\\Gamma(p)\\Gamma(q)}{\\Gamma(p+q)}$ 和性质 $\\Gamma(z+1) = z\\Gamma(z)$，我们有：\n$$\n\\frac{B(5/2, q)}{B(3/2, q)} = \\frac{\\Gamma(5/2)/\\Gamma(3/2)}{\\Gamma(5/2+q)/\\Gamma(3/2+q)} = \\frac{3/2}{3/2+q}\n$$\n代入 $q = \\alpha+1 = \\frac{1}{2}\\beta k R_0^2 + 1$：\n$$\n\\langle r^2 \\rangle = R_0^2 \\frac{3/2}{3/2 + (\\frac{1}{2}\\beta k R_0^2+1)} = R_0^2 \\frac{3/2}{5/2 + \\frac{1}{2}\\beta k R_0^2} = R_0^2 \\frac{3}{5 + \\beta k R_0^2}\n$$\n在约化单位中，$\\beta k R_0^2 = (\\beta k \\sigma^2)(R_0/\\sigma)^2 = k^\\star R_0^{\\star 2}$。这得出了问题陈述中提供的表达式：\n$$\n\\langle r^2 \\rangle^\\star = \\frac{\\langle r^2 \\rangle}{\\sigma^2} = \\frac{R_0^2}{\\sigma^2} \\frac{3}{5 + k^\\star R_0^{\\star 2}} = R_0^{\\star 2} \\frac{3}{k^\\star R_0^{\\star 2} + 5}\n$$\n现在我们可以求解 $k^\\star$。将此代入理想链关系式：\n$$\n\\langle R^2 \\rangle^\\star = M \\langle r^2 \\rangle^\\star = M R_0^{\\star 2} \\frac{3}{k^\\star R_0^{\\star 2} + 5}\n$$\n重新整理以求解 $k^\\star$：\n$$\nk^\\star R_0^{\\star 2} + 5 = \\frac{3 M R_0^{\\star 2}}{\\langle R^2 \\rangle^\\star} \\implies k^\\star = \\frac{1}{R_0^{\\star 2}} \\left( \\frac{3 M R_0^{\\star 2}}{\\langle R^2 \\rangle^\\star} - 5 \\right) = \\frac{3M}{\\langle R^2 \\rangle^\\star} - \\frac{5}{R_0^{\\star 2}}\n$$\n在已知 $R_0^\\star$ 的情况下，此方程可确定 $k^\\star$。\n\n**2. 非键相互作用参数（$\\epsilon^\\star$）的校准**\n\n非键 WCA 势的参数 $\\epsilon^\\star$ 是根据宏观等温压缩系数 $\\kappa_T^\\star$ 确定的。问题通过低密度极限下的压缩性方程提供了这一联系，该方程将 $\\kappa_T$ 与第二维里系数 $B_2$ 相关联。在约化单位中：\n$$\n\\rho^\\star \\kappa_T^\\star \\approx \\frac{1}{1 + 2 B_2^\\star \\rho^\\star}\n$$\n我们反转这个方程以求得约化第二维里系数的目标值 $B_{2,\\text{target}}^\\star$：\n$$\n1 + 2 B_2^\\star \\rho^\\star = \\frac{1}{\\rho^\\star \\kappa_T^\\star} \\implies B_{2,\\text{target}}^\\star = \\frac{1}{2\\rho^\\star} \\left( \\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1 \\right)\n$$\n第二维里系数由对偶势 $u(r)$ 的 Mayer 积分定义：\n$$\nB_2 = -2\\pi \\int_0^\\infty \\left(e^{-\\beta u(r)} - 1\\right) r^2 dr\n$$\n对于 WCA 势，$u(r) = 0$（当 $r > r_c = 2^{1/6}\\sigma$），因此积分在 $r_c$ 处被截断。在约化单位中，$B_2^\\star = B_2 / \\sigma^3$ 的表达式变为：\n$$\nB_2^\\star(\\epsilon^\\star) = -2\\pi \\int_0^{r_c^\\star} \\left[ \\exp\\left(-u^\\star(r^\\star; \\epsilon^\\star)\\right) - 1 \\right] r^{\\star 2} dr^\\star\n$$\n其中 $r_c^\\star = 2^{1/6}$，约化 WCA 势为：\n$$\nu^\\star(r^\\star; \\epsilon^\\star) = 4 \\epsilon^\\star \\left[ \\left(\\frac{1}{r^\\star}\\right)^{12} - \\left(\\frac{1}{r^\\star}\\right)^6 \\right] + \\epsilon^\\star\n$$\n（对于 $0 \\le r^\\star \\le r_c^\\star$）。函数 $B_2^\\star(\\epsilon^\\star)$ 是单调的，从 $B_2^\\star(0) = 0$ 增加到最大值 $B_{2, \\text{max}}^\\star = \\frac{2\\pi}{3} (r_c^\\star)^3 = \\frac{2\\pi\\sqrt{2}}{3}$（当 $\\epsilon^\\star \\to \\infty$ 时）。这对应于硬球极限，其中当 $r^\\star < r_c^\\star$ 时势能为无穷大。\n\n为了找到所需的 $\\epsilon^\\star$，我们必须解方程 $B_2^\\star(\\epsilon^\\star) = B_{2,\\text{target}}^\\star$。由于没有解析解，我们使用数值方法。我们首先根据输入数据计算 $B_{2,\\text{target}}^\\star$。\n- 如果 $B_{2,\\text{target}}^\\star \\le 0$，这意味着非排斥性或理想气体行为，在 WCA 模型中对应于 $\\epsilon^\\star = 0$。\n- 如果 $0 < B_{2,\\text{target}}^\\star < B_{2, \\text{max}}^\\star$，我们必须找到函数 $f(\\epsilon^\\star) = B_2^\\star(\\epsilon^\\star) - B_{2,\\text{target}}^\\star$ 的根。这将通过数值求根算法（如二分法或 Brent 方法）来完成，这需要在每一步数值计算 $B_2^\\star(\\epsilon^\\star)$ 的积分。\n\n**完整流程总结：**\n对于每个给定的测试用例 $(N, \\langle R^2 \\rangle^\\star, \\rho^\\star, \\kappa_T^\\star, L_c^\\star)$：\n1.  计算键的数量 $M = N-1$。\n2.  计算约化的最大键长：$R_0^\\star = L_c^\\star / M$。\n3.  计算约化的弹簧常数：$k^\\star = \\frac{3M}{\\langle R^2 \\rangle^\\star} - \\frac{5}{R_0^{\\star 2}}$。\n4.  计算目标约化第二维里系数：$B_{2,\\text{target}}^\\star = \\frac{1}{2\\rho^\\star}(\\frac{1}{\\rho^\\star \\kappa_T^\\star} - 1)$。\n5.  如果 $B_{2,\\text{target}}^\\star \\le 0$，则设置 $\\epsilon^\\star = 0$。否则，通过反演 $B_2^\\star$ 的积分表达式，数值求解 $B_2^\\star(\\epsilon^\\star) = B_{2,\\text{target}}^\\star$ 以获得 $\\epsilon^\\star$。这将使用数值积分和求根算法来实现。\n最终得到的三元组 $[k^\\star, R_0^\\star, \\epsilon^\\star]$ 即为校准后的模型参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Solves for the coarse-grained polymer model parameters based on target\n    observables, following the derivations from statistical mechanics.\n    \"\"\"\n    # Test suite of input parameter sets:\n    # (N, <R^2>*, rho*, kappa_T*, L_c*)\n    test_cases = [\n        (20, 200.0, 0.1, 8.0, 95.0),    # Case A\n        (10, 50.0, 0.05, 20.0, 30.0),   # Case B\n        (5, 9.0, 0.2, 4.0, 8.0),       # Case C\n        (50, 200.0, 0.01, 99.0, 147.0), # Case D\n    ]\n\n    # WCA potential constants\n    r_c_star = 2**(1/6)\n    \n    # Store results for all cases\n    results = []\n\n    for case in test_cases:\n        N, R2_star_target, rho_star, kappa_T_star, Lc_star = case\n        \n        # --- 1. Calibrate Bonded Interaction Parameters (k_star, R0_star) ---\n        \n        M = N - 1\n        \n        # Calculate R0_star from the contour length\n        R0_star = Lc_star / M\n        \n        # Calculate k_star from the mean-square end-to-end distance\n        # k_star = 3*M / <R^2>* - 5 / R0*^2\n        # A check for physical consistency is assumed to pass based on problem statement\n        k_star = (3 * M / R2_star_target) - (5 / R0_star**2)\n        \n        # --- 2. Calibrate Non-Bonded Interaction Parameter (epsilon_star) ---\n\n        # Calculate the target reduced second virial coefficient B2_star\n        # Handle the ideal gas case where rho* * kappa_T* = 1\n        if np.isclose(rho_star * kappa_T_star, 1.0):\n            B2_star_target = 0.0\n        else:\n            B2_star_target = (1 / (2 * rho_star)) * ((1 / (rho_star * kappa_T_star)) - 1)\n\n        epsilon_star = 0.0\n        if B2_star_target > 0:\n            # Define the WCA potential u*(r*, epsilon*)\n            def u_wca_star(r_star, eps_star):\n                inv_r6 = (1 / r_star)**6\n                inv_r12 = inv_r6**2\n                return 4 * eps_star * (inv_r12 - inv_r6) + eps_star\n\n            # Define the integrand for B2*\n            def b2_integrand(r_star, eps_star):\n                potential = u_wca_star(r_star, eps_star)\n                return -2 * np.pi * (np.exp(-potential) - 1) * r_star**2\n\n            # Define a function to compute B2* for a given epsilon*\n            def compute_B2_star(eps_star):\n                val, _ = integrate.quad(b2_integrand, 0, r_c_star, args=(eps_star,))\n                return val\n\n            # Check if target is beyond the physical maximum for WCA\n            B2_max_star = (2 * np.pi / 3) * r_c_star**3\n            if B2_star_target >= B2_max_star:\n                # Approximate with a large value for epsilon_star\n                epsilon_star = 100.0  \n            else:\n                # Define the objective function for the root finder\n                def objective_func(eps_star):\n                    return compute_B2_star(eps_star) - B2_star_target\n\n                # Use a robust root-finding algorithm (Brent's method)\n                try:\n                    # Bracket the root. We know B2*(eps*) is monotonic from 0 upwards.\n                    # A sufficiently large upper bound like 100 should be safe.\n                    epsilon_star = optimize.brentq(objective_func, 0.0, 100.0, xtol=1e-9, rtol=1e-9)\n                except ValueError:\n                    # This might happen if the target is out of bounds, though we check for it.\n                    # As a safeguard, if brentq fails, we handle it gracefully.\n                    if objective_func(0.0) * objective_func(100.0) > 0:\n                        # Both ends have same sign, implies target is outside range [B2(0), B2(100)]\n                        if B2_star_target > compute_B2_star(100.0):\n                             epsilon_star = 100.0\n                        else:\n                             epsilon_star = 0.0\n                    else:\n                        # Some other numerical issue\n                        epsilon_star = np.nan # Should not happen with this problem\n        \n        # Store the calibrated parameter set\n        results.append([k_star, R0_star, epsilon_star])\n\n    # Final print statement in the exact required format\n    # Using repr().replace(\" \", \"\") to match the example format exactly\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2909623"}, {"introduction": "一个参数化好的模型需要一个高效且稳定的算法来模拟其时间演化。由于聚合物体系中不同运动模式的时间尺度差异巨大（例如，快速的键振动与缓慢的链扩散），标准积分算法的效率低下 [@problem_id:2909650]。本练习将引导你从第一性原理出发，推导并实现可逆的参考系统传播算法（RESPA），这是一种先进的多时间步积分方法。通过实践，你将掌握如何利用哈密顿力学和算符分裂技术来显著提高模拟效率，同时确保能量的长期守恒和模拟的稳定性。", "problem": "考虑一个经典的聚合物熔体，该熔体被建模为一个三维珠簧系统，在周期性边界条件下，具有成对的非键相互作用和最近邻的键合相互作用。设哈密顿量被分解为一个动能项和两个势能项，\n$$\nH = T(\\{\\mathbf{p}_i\\}) + U_{\\text{fast}}(\\{\\mathbf{r}_i\\}) + U_{\\text{slow}}(\\{\\mathbf{r}_i\\}),\n$$\n其中 $T = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2 m}$，$U_{\\text{fast}}$ 代表在快速时间尺度上变化的键合相互作用，而 $U_{\\text{slow}}$ 代表在较慢时间尺度上变化的非键相互作用。目标是为这个分解的系统构建一个时间可逆的参考系传播子算法（Reference System Propagator Algorithm, RESPA）多时间步积分器，并评估其对于珠簧熔体系统的稳定性。\n\n您必须从适用于分子动力学的第一性原理出发：以牛顿第二定律、哈密顿方程和刘维尔算子形式体系，以及传播子的二阶对称Trotter分解作为基本依据。在未从这些基础推导的情况下，不得假设任何算法更新规则。系统定义如下。\n\n- 珠子：$N$个质量为$m$的相同粒子，其位置为$\\{\\mathbf{r}_i\\}$，速度为$\\{\\mathbf{v}_i\\}$，存在于边长为$L$的立方周期性盒子中。\n- 键合相互作用（快速）：每条链是由通过谐振子键连接的珠子序列组成，其势能为\n$$\nU_{\\text{bond}} = \\sum_{\\langle i,j \\rangle} \\frac{1}{2} k_{\\text{b}} \\left(r_{ij} - b_0\\right)^2,\n$$\n其中 $\\langle i,j \\rangle$ 表示沿每条链的最近邻珠子对，$r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ 使用最小镜像约定进行测量，$k_{\\text{b}}$ 是键刚度，$b_0$ 是平衡键长。定义 $U_{\\text{fast}} \\equiv U_{\\text{bond}}$。\n- 非键相互作用（慢速）：所有非键合的珠子对通过Weeks-Chandler-Andersen（WCA）势相互作用，\n$$\nU_{\\text{WCA}}(r) = \n\\begin{cases}\n4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] + \\varepsilon, & \\text{if } r \\le r_c,\\\\\n0, & \\text{if } r > r_c,\n\\end{cases}\n$$\n截断半径为 $r_c = 2^{1/6}\\sigma$，其中 $r$ 是通过最小镜像约定计算的对间距离。定义 $U_{\\text{slow}} \\equiv \\sum_{i<j,\\, \\langle i,j \\rangle \\text{ excluded}} U_{\\text{WCA}}(r_{ij})$。从 $U_{\\text{slow}}$ 中排除直接键合的邻居。\n\n所有量都采用简化的Lennard-Jones单位制，其中 $m = 1$，$\\varepsilon = 1$，$\\sigma = 1$。无需报告物理单位；因此所有输出都必须是无单位的。\n\n任务：\n1. 从刘维尔算子分解出发，推导一个可逆的二阶RESPA（参考系传播子算法）方案。该方案使用一个外层时间步长 $\\Delta t_{\\text{slow}}$ 演化慢力，并使用一个内层时间步长 $\\Delta t_{\\text{fast}} = \\Delta t_{\\text{slow}}/m_{\\text{sub}}$ 演化快力，其中每个外层步骤包含 $m_{\\text{sub}} \\in \\mathbb{N}$ 个内层子步骤。明确陈述并论证在此分解下确保时间可逆性和二阶精度的速度与位置更新序列。\n2. 在一个完整的、可运行的程序中实现推导出的可逆RESPA积分器，该程序对珠簧熔体进行微正则（恒定总能量）动力学模拟，并采用以下固定的系统规格：\n   - 链数 $N_{\\text{chains}} = 3$，链长 $N_{\\text{ch}} = 9$，总珠子数 $N = 27$。\n   - 数密度 $\\rho = 0.7$，因此 $L = (N/\\rho)^{1/3}$。\n   - 谐振子键参数为 $k_{\\text{b}} = 1000$ 和 $b_0 = 0.96$。\n   - Weeks-Chandler-Andersen非键参数为 $\\varepsilon = 1$，$\\sigma = 1$，$r_c = 2^{1/6}$。\n   - 在边长为 $L$ 的立方体中使用最小镜像约定的周期性边界条件。\n   - 初始位置：将所有 $N$ 个珠子放置在跨越盒子的均匀 $3 \\times 3 \\times 3$ 网格上，然后分配连续的索引以形成线性链，通过索引将每条链内的最近邻连接起来。这确保了初始没有重叠。\n   - 初始速度：从温度为 $T_0 = 0.1$（玻尔兹曼常数 $k_{\\text{B}} = 1$）的麦克斯韦-玻尔兹曼分布中抽样，并移除质心漂移。\n3. 稳定性评估：对于每次模拟，计算总能量\n$$\nE(t) = \\sum_{i=1}^{N} \\frac{1}{2} m \\|\\mathbf{v}_i(t)\\|^2 + U_{\\text{bond}}(t) + U_{\\text{WCA}}(t),\n$$\n并评估整个轨迹上的最大相对漂移，\n$$\n\\delta_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{|E(n\\Delta t_{\\text{slow}}) - E(0)|}{|E(0)|}.\n$$\n如果 $\\delta_{\\max} \\le 0.05$，则定义一个模拟为“稳定”，否则为“不稳定”。所有输出都是无量纲的。\n4. 测试套件：使用以下时间步长参数和轨迹长度集来探测不同的稳定性区域，包括一个正常路径、接近边界的条件和一个不稳定的情况。对于每种情况，仅报告一个根据上述标准指示稳定性的布尔值。\n   - 情况A：$\\Delta t_{\\text{slow}} = 0.01$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$。\n   - 情况B：$\\Delta t_{\\text{slow}} = 0.02$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$。\n   - 情况C：$\\Delta t_{\\text{slow}} = 0.04$, $m_{\\text{sub}} = 2$, $N_{\\text{steps}} = 2000$。\n   - 情况D：$\\Delta t_{\\text{slow}} = 0.08$, $m_{\\text{sub}} = 2$, $N_{\\text{steps}} = 2000$。\n   - 情况E：$\\Delta t_{\\text{slow}} = 0.06$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$。\n   - 情况F：$\\Delta t_{\\text{slow}} = 0.10$, $m_{\\text{sub}} = 1$, $N_{\\text{steps}} = 2000$。\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中每个 $result_i$ 是一个对应于情况A到F稳定性的布尔值。\n\n您的推导必须从哈密顿方程和刘维尔算子结构开始，使用对称Trotter分解来获得一个时间可逆的多时间步方案。您不能假设任何预先存在的更新公式；相反，您必须逻辑地推导出算法然后实现它。以上所有参数都是无量纲的；只报告布尔值，不带单位。", "solution": "我们从哈密顿方程开始，\n$$\n\\dot{\\mathbf{r}}_i = \\frac{\\partial H}{\\partial \\mathbf{p}_i} = \\frac{\\mathbf{p}_i}{m}, \\quad\n\\dot{\\mathbf{p}}_i = -\\frac{\\partial H}{\\partial \\mathbf{r}_i} = \\mathbf{F}^{\\text{fast}}_i(\\{\\mathbf{r}\\}) + \\mathbf{F}^{\\text{slow}}_i(\\{\\mathbf{r}\\}),\n$$\n其中 $\\mathbf{F}^{\\text{fast}}_i = -\\partial U_{\\text{fast}}/\\partial \\mathbf{r}_i$ 且 $\\mathbf{F}^{\\text{slow}}_i = -\\partial U_{\\text{slow}}/\\partial \\mathbf{r}_i$。为动能部分引入刘维尔算子 $i\\mathcal{L}_T$，为快势能和慢势能部分引入 $i\\mathcal{L}_{U_{\\text{fast}}}$ 和 $i\\mathcal{L}_{U_{\\text{slow}}}$，则在时间 $\\Delta t$ 内的完整时间演化算子为\n$$\ne^{\\Delta t\\, i\\mathcal{L}}, \\quad i\\mathcal{L} = i\\mathcal{L}_T + i\\mathcal{L}_{U_{\\text{fast}}} + i\\mathcal{L}_{U_{\\text{slow}}}.\n$$\n算子 $i\\mathcal{L}_T$ 在动量固定的情况下通过自由流更新位置，而 $i\\mathcal{L}_{U_{\\text{fast}}}$ 和 $i\\mathcal{L}_{U_{\\text{slow}}}$ 在位置固定的情况下更新动量（速度）。\n\n一个二阶时间可逆的多时间步方案可以从对称的Trotter分解（Strang分解）中得到。对于一个外层慢时间步长 $\\Delta t_{\\text{slow}}$ 和 $m_{\\text{sub}}$ 个内层快子步骤（步长为 $\\Delta t_{\\text{fast}} = \\Delta t_{\\text{slow}}/m_{\\text{sub}}$），应用\n$$\ne^{\\Delta t_{\\text{slow}}\\, i\\mathcal{L}} \\approx e^{\\frac{\\Delta t_{\\text{slow}}}{2}\\, i\\mathcal{L}_{U_{\\text{slow}}}}\n\\left[\ne^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}\ne^{\\Delta t_{\\text{fast}}\\, i\\mathcal{L}_T}\ne^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}\n\\right]^{m_{\\text{sub}}}\ne^{\\frac{\\Delta t_{\\text{slow}}}{2}\\, i\\mathcal{L}_{U_{\\text{slow}}}}.\n$$\n这是时间可逆的，因为它在 $\\Delta t \\to -\\Delta t$ 的变换下是对称的。将这些算子映射到更新步骤，便可得到可逆的RESPA速度Verlet结构：\n\n- “慢半踢”：用 $\\frac{\\Delta t_{\\text{slow}}}{2 m}\\,\\mathbf{F}^{\\text{slow}}(\\{\\mathbf{r}\\})$ 更新速度。\n- 重复 $m_{\\text{sub}}$ 次内层“快速速度Verlet”步骤，步长为 $\\Delta t_{\\text{fast}}$：\n  - 快半踢：$\\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t_{\\text{fast}}}{2 m}\\,\\mathbf{F}^{\\text{fast}}(\\{\\mathbf{r}\\})$。\n  - 漂移：$\\mathbf{r} \\leftarrow \\mathbf{r} + \\Delta t_{\\text{fast}}\\, \\mathbf{v}$（使用周期性边界条件）。\n  - 重新计算 $\\mathbf{F}^{\\text{fast}}(\\{\\mathbf{r}\\})$ 并应用另一次快半踢。\n- 重新计算 $\\mathbf{F}^{\\text{slow}}(\\{\\mathbf{r}\\})$ 并应用最终的慢半踢。\n\n以上是算子分解的直接结果：$e^{\\frac{\\Delta t_{\\text{fast}}}{2}\\, i\\mathcal{L}_{U_{\\text{fast}}}}$ 映射到固定位置下的半个动量更新，$e^{\\Delta t_{\\text{fast}}\\, i\\mathcal{L}_T}$ 映射到固定动量下的漂移更新，慢分量在外层也类似。由于对称组合，该算法对于分解后的刘维尔算子是二阶精确的。\n\n对于特定的珠簧模型：\n\n- 位置和速度遵循牛顿方程，力被分解为键合和非键合部分。键合力来自谐振子键：\n$$\nU_{\\text{bond}} = \\sum_{\\langle i,j\\rangle} \\frac{1}{2} k_{\\text{b}} \\left(r_{ij} - b_0\\right)^2,\\quad\n\\mathbf{F}^{\\text{bond}}_{i} = -\\sum_{j \\in \\mathcal{N}(i)} k_{\\text{b}} \\left(1 - \\frac{b_0}{r_{ij}}\\right) (\\mathbf{r}_i - \\mathbf{r}_j)_{\\text{MIC}},\n$$\n其中 $(\\cdot)_{\\text{MIC}}$ 应用周期性盒子中的最小镜像约定，$\\mathcal{N}(i)$ 是键合邻居。我们设定 $U_{\\text{fast}} \\equiv U_{\\text{bond}}$ 和 $\\mathbf{F}^{\\text{fast}} \\equiv \\mathbf{F}^{\\text{bond}}$。\n- 非键WCA力，不包括直接键合的邻居，为\n$$\nU_{\\text{WCA}}(r) =\n\\begin{cases}\n4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] + \\varepsilon, & r \\le r_c,\\\\\n0, & r > r_c,\n\\end{cases}\n$$\n一对粒子间对应的力为\n$$\n\\mathbf{F}_{ij}^{\\text{WCA}} =\n\\begin{cases}\n24 \\varepsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}_{ij}}{r^2}, & r \\le r_c,\\\\\n\\mathbf{0}, & r > r_c,\n\\end{cases}\n$$\n其中 $\\mathbf{r}_{ij}$ 是最小镜像位移。我们设定 $U_{\\text{slow}} \\equiv \\sum_{i<j,\\, \\langle i,j \\rangle \\text{ excluded}} U_{\\text{WCA}}(r_{ij})$ and $\\mathbf{F}^{\\text{slow}}_i = \\sum_{j \\ne i} \\mathbf{F}^{\\text{WCA}}_{ij}$，不包括键合对。\n\n实现细节和算法设计：\n- 初始化一个边长为 $L = (N/\\rho)^{1/3}$ 的立方周期性盒子，其中 $N = 27$ 个珠子放置在 $3 \\times 3 \\times 3$ 的网格上。通过连续索引分配 $N_{\\text{chains}} = 3$ 条长度为 $N_{\\text{ch}} = 9$ 的链。键连接每条链内的连续索引。\n- 速度从温度为 $T_0 = 0.1$ 的麦克斯韦-玻尔兹曼分布中抽样，分量标准差为 $\\sqrt{T_0/m}$，并移除质心速度以强制净动量为零。\n- 力在最小镜像约定下使用向量化操作计算：\n  - 对于非键WCA，构建成对位移张量，并应用掩码以排除键合邻居并应用截断半径 $r_c = 2^{1/6}$。使用 $\\mathrm{add.at}$ 将力累加到每个粒子的数组中，以确保正确的反对称性 $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$，并通过对 $i<j$ 求和来计算对能量。\n  - 对于键合力，计算每个键的位移向量，并评估谐振子力和能量。\n- 可逆RESPA积分器按推导进行：对于每个大小为 $\\Delta t_{\\text{slow}}$ 的外层步骤，一个慢半踢用 $\\mathbf{F}^{\\text{slow}}$ 更新速度，然后是 $m_{\\text{sub}}$ 个大小为 $\\Delta t_{\\text{fast}}$ 的内层快速速度Verlet步骤，仅使用 $\\mathbf{F}^{\\text{fast}}$ 更新位置和速度，接着重新计算 $\\mathbf{F}^{\\text{slow}}$ 并进行最后的慢半踢。\n- 稳定性评估使用每个外层步骤的能量 $E(t)$ 来计算最大相对漂移\n$$\n\\delta_{\\max} = \\max_{n} \\frac{|E(n\\Delta t_{\\text{slow}}) - E(0)|}{|E(0)|}.\n$$\n如果 $\\delta_{\\max} \\le 0.05$，则模拟是稳定的。\n\n有原则的稳定性推理：\n- 对于一个等效角频率 $\\omega_{\\text{bond}} \\approx \\sqrt{k_{\\text{b}}/m}$ 的谐振子键自由度，内层快速速度Verlet步骤在线性上是稳定的，条件是 $\\Delta t_{\\text{fast}} < \\frac{2}{\\omega_{\\text{max}}}$，其中 $\\omega_{\\text{max}}$ 是最大的相关频率。当 $k_{\\text{b}} = 1000$ 和 $m = 1$ 时，$\\omega_{\\text{bond}} \\approx \\sqrt{1000} \\approx 31.62$，这意味着一个必要条件是 $\\Delta t_{\\text{fast}} \\lesssim \\frac{2}{31.62} \\approx 0.063$。测试套件包括将 $\\Delta t_{\\text{fast}}$ 安全地保持在此界限以下的情况（正常路径）、接近界限的情况（边界情况）以及超过界限的情况（不稳定）。\n- 此外，当 $\\Delta t_{\\text{slow}}$ 与快速振动周期成公约数时，多时间步积分器可能会出现共振不稳定性。对称的RESPA构造可以减轻但不能消除这种共振；测试套件通过在固定的 $\\Delta t_{\\text{fast}}$ 下探索更大的 $\\Delta t_{\\text{slow}}$ 值来探测这种效应。\n\n程序输出：\n- 对于每种情况 A–F，其参数 $\\left(\\Delta t_{\\text{slow}}, m_{\\text{sub}}, N_{\\text{steps}}\\right)$ 分别等于 $\\left(0.01, 1, 2000\\right)$、$\\left(0.02, 1, 2000\\right)$、$\\left(0.04, 2, 2000\\right)$、$\\left(0.08, 2, 2000\\right)$、$\\left(0.06, 1, 2000\\right)$ 和 $\\left(0.10, 1, 2000\\right)$，程序计算 $\\delta_{\\max}$ 并报告一个布尔值，表示在 $\\delta_{\\max} \\le 0.05$ 标准下的稳定性。\n- 最终输出是包含列表 $[b_A,b_B,b_C,b_D,b_E,b_F]$ 的单行，其中每个 $b_\\cdot$ 是 $\\text{True}$ 或 $\\text{False}$，不带单位。\n\n这个设计将基本原理（哈密顿动力学和算子分解）与可实现的算法（周期性边界条件下的力计算和对称可逆RESPA方案）相结合，以在聚合物熔体模型中测试跨多个时间尺度的稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_system(N_chains=3, chain_len=9, rho=0.7, kbond=1000.0, b0=0.96, eps=1.0, sigma=1.0):\n    \"\"\"\n    Construct initial positions on a 3x3x3 grid and linear chains by consecutive indices.\n    Returns positions (N,3), velocities (N,3), box length L, bonds list (M,2), parameters dict.\n    \"\"\"\n    N = N_chains * chain_len\n    assert N == 27, \"This initializer assumes a 3x3x3 grid (N=27).\"\n    L = (N / rho) ** (1.0 / 3.0)\n    # Grid positions centered within each cell\n    grid_pts = []\n    ngrid = 3\n    cell = L / ngrid\n    for ix in range(ngrid):\n        for iy in range(ngrid):\n            for iz in range(ngrid):\n                grid_pts.append([(ix + 0.5) * cell, (iy + 0.5) * cell, (iz + 0.5) * cell])\n    R = np.array(grid_pts[:N], dtype=np.float64)\n    # Velocities: Maxwell-Boltzmann at T0, remove COM velocity\n    T0 = 0.1\n    mass = 1.0\n    v_std = np.sqrt(T0 / mass)\n    rng = np.random.default_rng(seed=12345)\n    V = rng.normal(0.0, v_std, size=(N, 3))\n    V -= V.mean(axis=0, keepdims=True)\n\n    # Bonds: consecutive indices per chain\n    bonds = []\n    for c in range(N_chains):\n        start = c * chain_len\n        for i in range(chain_len - 1):\n            bonds.append((start + i, start + i + 1))\n    bonds = np.array(bonds, dtype=np.int64)\n\n    params = {\n        \"N\": N,\n        \"L\": L,\n        \"rho\": rho,\n        \"mass\": mass,\n        \"kbond\": kbond,\n        \"b0\": b0,\n        \"eps\": eps,\n        \"sigma\": sigma,\n        \"rc\": 2 ** (1.0 / 6.0) * sigma,\n        \"T0\": T0,\n        \"ngr\": ngrid,\n    }\n    return R, V, L, bonds, params\n\ndef minimum_image(dr, L):\n    # Apply minimum image convention to displacement vectors\n    return dr - L * np.round(dr / L)\n\ndef bonded_forces_energy(R, bonds, L, kbond, b0):\n    \"\"\"\n    Compute harmonic bonded forces and energy.\n    R: (N,3) positions, bonds: (M,2) index pairs\n    Returns Fb: (N,3), Ub: float\n    \"\"\"\n    N = R.shape[0]\n    Fb = np.zeros_like(R)\n    if bonds.shape[0] == 0:\n        return Fb, 0.0\n    i = bonds[:, 0]\n    j = bonds[:, 1]\n    rij = minimum_image(R[i] - R[j], L)\n    r = np.linalg.norm(rij, axis=1)\n    # Avoid division by zero\n    r_safe = np.where(r > 1e-12, r, 1e-12)\n    # Force on i due to j\n    coeff = -kbond * (1.0 - b0 / r_safe)\n    fij = (coeff[:, None]) * rij  # shape (M,3)\n    # Accumulate\n    np.add.at(Fb, i, fij)\n    np.add.at(Fb, j, -fij)\n    # Energy\n    Ub = 0.5 * kbond * np.sum((r - b0) ** 2)\n    return Fb, Ub\n\ndef wca_forces_energy(R, L, eps, sigma, rc, bonded_pairs_mask):\n    \"\"\"\n    Compute WCA nonbonded forces and energy using vectorized pair operations.\n    bonded_pairs_mask: (N,N) boolean matrix True for bonded pairs to exclude\n    Returns Fnb: (N,3), Unb: float\n    \"\"\"\n    N = R.shape[0]\n    F = np.zeros_like(R)\n    # Pairwise displacements\n    dR = R[:, None, :] - R[None, :, :]\n    dR = minimum_image(dR, L)\n    r2 = np.einsum('ijk,ijk->ij', dR, dR)\n    # Masks\n    iu = np.triu_indices(N, k=1)\n    mask = np.ones((N, N), dtype=bool)\n    mask[~np.triu(np.ones((N, N), dtype=bool), k=1)] = False  # ensure upper triangle only\n    mask &= (~bonded_pairs_mask)\n    mask &= (r2 <= rc * rc)\n    # Selected pairs\n    I, J = np.where(mask)\n    if I.size == 0:\n        return F, 0.0\n    rij = dR[I, J, :]\n    r2_sel = r2[I, J]\n    r_sel = np.sqrt(r2_sel)\n    inv_r = 1.0 / np.where(r_sel > 1e-12, r_sel, 1e-12)\n    sr = sigma * inv_r\n    sr6 = sr ** 6\n    sr12 = sr6 ** 2\n    # Force vector contribution: 24*eps*(2*sr12 - sr6) * (rij / r^2)\n    fcoef = 24.0 * eps * (2.0 * sr12 - sr6) / r2_sel\n    fij = (fcoef[:, None]) * rij\n    # Accumulate forces\n    np.add.at(F, I, fij)\n    np.add.at(F, J, -fij)\n    # Energy per pair: 4*eps*(sr12 - sr6) + eps\n    U_pairs = 4.0 * eps * (sr12 - sr6) + eps\n    U = np.sum(U_pairs)\n    return F, U\n\ndef kinetic_energy(V, mass):\n    return 0.5 * mass * np.sum(V * V)\n\ndef total_energy(R, V, L, bonds, params, bonded_pairs_mask):\n    Fb, Ub = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n    Fn, Un = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_pairs_mask)\n    Ek = kinetic_energy(V, params[\"mass\"])\n    return Ek + Ub + Un\n\ndef build_bonded_mask(N, bonds):\n    mask = np.zeros((N, N), dtype=bool)\n    for i, j in bonds:\n        mask[i, j] = True\n        mask[j, i] = True\n    return mask\n\ndef respa_simulation(dt_slow, m_sub, n_steps, stability_threshold=0.05):\n    # System\n    R, V, L, bonds, params = make_system()\n    N = params[\"N\"]\n    mass = params[\"mass\"]\n    # Precompute bonded adjacency mask\n    bonded_mask = build_bonded_mask(N, bonds)\n    # Initial slow force\n    F_slow, _ = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_mask)\n    # Energy initial\n    E0 = total_energy(R, V, L, bonds, params, bonded_mask)\n    if not np.isfinite(E0) or E0 == 0.0:\n        return False, np.inf  # safeguard\n    max_rel_drift = 0.0\n    dt_fast = dt_slow / float(m_sub)\n\n    # Run outer steps\n    for step in range(n_steps):\n        # Slow half-kick\n        V += 0.5 * dt_slow * F_slow / mass\n        # Inner fast steps\n        for _ in range(m_sub):\n            F_fast, _ = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n            V += 0.5 * dt_fast * F_fast / mass\n            # Drift with PBC\n            R += dt_fast * V\n            R %= L  # wrap into box\n            F_fast, _ = bonded_forces_energy(R, bonds, L, params[\"kbond\"], params[\"b0\"])\n            V += 0.5 * dt_fast * F_fast / mass\n        # Slow half-kick\n        F_slow, _ = wca_forces_energy(R, L, params[\"eps\"], params[\"sigma\"], params[\"rc\"], bonded_mask)\n        V += 0.5 * dt_slow * F_slow / mass\n\n        # Energy monitoring\n        E = total_energy(R, V, L, bonds, params, bonded_mask)\n        if not np.isfinite(E):\n            max_rel_drift = np.inf\n            break\n        rel_drift = abs(E - E0) / abs(E0)\n        if rel_drift > max_rel_drift:\n            max_rel_drift = rel_drift\n\n    stable = (max_rel_drift <= stability_threshold)\n    return stable, max_rel_drift\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Delta t_slow, m_sub, N_steps)\n    test_cases = [\n        (0.01, 1, 2000),  # Case A\n        (0.02, 1, 2000),  # Case B\n        (0.04, 2, 2000),  # Case C\n        (0.08, 2, 2000),  # Case D\n        (0.06, 1, 2000),  # Case E (near stability limit)\n        (0.10, 1, 2000),  # Case F (expected unstable)\n    ]\n\n    results = []\n    # Run each case and append only the stability boolean as required\n    for dt_slow, m_sub, n_steps in test_cases:\n        stable, _ = respa_simulation(dt_slow, m_sub, n_steps, stability_threshold=0.05)\n        results.append(stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2909650"}, {"introduction": "分子动力学或蒙特卡洛模拟产生的轨迹数据在时间上是相关的，这意味着直接计算统计平均值的标准误差会严重低估真实的不确定性 [@problem_id:2909657]。这个练习将介绍一种处理此问题的标准且稳健的技术：分块平均法（blocking method）。你将推导该方法的理论基础，理解块的大小如何影响误差估计的偏差和方差，并学会如何从相关的时间序列中获得可靠的误差棒。这是确保计算结果具有统计严谨性的基本技能。", "problem": "在聚合物熔体的分子动力学 (MD) 或马尔可夫链蒙特卡洛 (MCMC) 模拟中，假设你以均匀采样间隔 $\\Delta t$ 记录了一个标量可观测量（例如，压强或端到端距离）的平稳、遍历的时间序列 $\\{X_t\\}_{t=1}^N$。设该过程的均值为 $\\mu$，方差为 $\\sigma^2 = \\gamma(0)$，自协方差函数为 $\\gamma(k) = \\mathrm{Cov}(X_t, X_{t+k})$，自相关函数为 $\\rho(k) = \\gamma(k)/\\gamma(0)$。尽管存在时间相关性，你希望估计样本均值 $\\bar X = \\frac{1}{N}\\sum_{t=1}^N X_t$ 的标准误差。\n\n你应用分块（批次均值）方法：将轨迹划分为 $m$ 个长度相等（为 $b$）的连续、不重叠的块，使得 $N = m b$；定义块均值 $Y_j = \\frac{1}{b}\\sum_{t=(j-1)b+1}^{j b} X_t$，$j=1,\\dots,m$；计算块间的样本方差 $s_Y^2 = \\frac{1}{m-1}\\sum_{j=1}^m (Y_j - \\bar Y)^2$，其中 $\\bar Y = \\frac{1}{m}\\sum_{j=1}^m Y_j = \\bar X$；并将 $\\bar X$ 的批次均值方差估计量取为 $\\widehat{\\mathrm{Var}}(\\bar X) = s_Y^2/m$。\n\n仅从方差和协方差的定义以及 $\\{X_t\\}$ 的平稳性出发，推导 $\\mathrm{Var}(Y_j)$ 关于 $\\gamma(k)$ 和 $b$ 的精确表达式，并展示当 $b$ 增加而 $N$ 很大时，这如何导出 $\\mathbb{E}[s_Y^2/m]$ 的渐近行为。特别地，当级数绝对收敛时，使用积分自相关时间 $\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^\\infty \\rho(k)$。\n\n哪个选项最好地刻画了批次均值方差估计量的大-$b$ 行为及其收敛性？\n\nA. 在 $\\sum_{k=0}^\\infty |\\rho(k)|$ 和 $\\sum_{k=1}^\\infty k\\,|\\rho(k)|$ 绝对可和的条件下，对于大的 $b$，我们有 $\\mathbb{E}[s_Y^2] = \\frac{1}{b}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right) + \\mathcal{O}\\!\\left(\\frac{1}{b^2}\\right)$，因此当 $b\\to\\infty$、$m\\to\\infty$ 且 $N=mb$ 时，$\\mathbb{E}[s_Y^2/m] \\to \\frac{1}{N}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$。作为 $\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$ 的估计量，$b\\,s_Y^2$ 的偏差以 $\\mathcal{O}\\!\\left(\\frac{1}{b}\\right)$ 的速度衰减，且 $\\mathrm{Var}(s_Y^2)$ 按 $\\mathcal{O}\\!\\left(\\frac{1}{m}\\right)$ 的比例缩放。\n\nB. 对于大的 $b$，$\\mathbb{E}[s_Y^2] \\sim \\frac{\\sigma^2}{b^2}$，因此 $\\mathbb{E}[s_Y^2/m] \\sim \\frac{\\sigma^2}{N b} \\to 0$，这意味着随着 $b$ 的增长，分块法会系统性地低估 $\\mathrm{Var}(\\bar X)$。\n\nC. 一旦 $b$ 超过积分自相关时间 $\\tau_{\\mathrm{int}}$，块均值 $Y_j$ 就会变得精确独立，因此对于任何 $m \\ge 2$，$s_Y^2/m$ 都等于 $\\mathrm{Var}(\\bar X)$ 的精确值。\n\nD. 对于大的 $b$，期望值 $\\mathbb{E}[s_Y^2/m]$ 随 $b$ 线性增加，因为块内平均抑制了块内相关性并放大了块间变异性，从而 $\\mathbb{E}[s_Y^2/m] \\propto b/N$。", "solution": "问题陈述是对计算物理模拟中相关时间序列数据统计分析问题的一种有效且标准的表述。它有科学依据、提法明确且客观。我将开始进行推导。\n\n**第一部分：$\\mathrm{Var}(Y_j)$ 的推导**\n\n根据定义，块均值为 $Y_j = \\frac{1}{b}\\sum_{t=(j-1)b+1}^{j b} X_t$。过程 $\\{X_t\\}$ 是平稳的，这意味着 $\\mathrm{Var}(Y_j)$ 与块索引 $j$ 无关。因此，我们可以不失一般性地计算 $\\mathrm{Var}(Y_1)$。\n$$ Y_1 = \\frac{1}{b}\\sum_{t=1}^b X_t $$\n$Y_1$ 的方差由下式给出：\n$$ \\mathrm{Var}(Y_1) = \\mathrm{Var}\\left(\\frac{1}{b}\\sum_{t=1}^b X_t\\right) = \\frac{1}{b^2} \\mathrm{Var}\\left(\\sum_{t=1}^b X_t\\right) $$\n相关随机变量之和的方差是其协方差矩阵中所有元素的总和：\n$$ \\mathrm{Var}\\left(\\sum_{t=1}^b X_t\\right) = \\sum_{t=1}^b \\sum_{s=1}^b \\mathrm{Cov}(X_t, X_s) $$\n由于平稳性，协方差仅取决于时间延迟，$\\mathrm{Cov}(X_t, X_s) = \\gamma(s-t)$。\n$$ \\mathrm{Var}(Y_1) = \\frac{1}{b^2} \\sum_{t=1}^b \\sum_{s=1}^b \\gamma(s-t) $$\n我们可以通过延迟 $k = s-t$ 对此双重求和重新索引。延迟 $k$ 的范围从 $-(b-1)$ 到 $b-1$。对于给定的延迟 $k$，求和中满足 $1 \\le t, s \\le b$ 和 $s-t=k$ 的对 $(t, s)$ 的数量为 $b - |k|$。\n$$ \\sum_{t=1}^b \\sum_{s=1}^b \\gamma(s-t) = \\sum_{k=-(b-1)}^{b-1} (b-|k|)\\gamma(k) $$\n由于自协方差函数是偶函数，$\\gamma(k) = \\gamma(-k)$，我们可以将和式拆分为：\n$$ \\sum_{k=-(b-1)}^{b-1} (b-|k|)\\gamma(k) = (b-0)\\gamma(0) + \\sum_{k=1}^{b-1} (b-k)\\gamma(k) + \\sum_{k=-(b-1)}^{-1} (b-|k|)\\gamma(k) $$\n$$ = b\\gamma(0) + 2\\sum_{k=1}^{b-1} (b-k)\\gamma(k) $$\n将此代回 $\\mathrm{Var}(Y_1)$ 的表达式中：\n$$ \\mathrm{Var}(Y_j) = \\frac{1}{b^2} \\left[ b\\gamma(0) + 2\\sum_{k=1}^{b-1} (b-k)\\gamma(k) \\right] $$\n提出公因子 $\\gamma(0) = \\sigma^2$ 和 $b$，并使用自相关函数 $\\rho(k) = \\gamma(k)/\\gamma(0)$ 的定义：\n$$ \\mathrm{Var}(Y_j) = \\frac{\\sigma^2}{b} \\left[ 1 + 2\\sum_{k=1}^{b-1} \\left(1 - \\frac{k}{b}\\right)\\rho(k) \\right] $$\n这就是块均值方差的精确表达式。\n\n**第二部分：大块尺寸 $b$ 的渐近行为**\n\n我们现在分析当 $b \\to \\infty$ 时 $\\mathrm{Var}(Y_j)$ 的行为。表达式为：\n$$ b\\,\\mathrm{Var}(Y_j) = \\sigma^2 \\left[ 1 + 2\\sum_{k=1}^{b-1} \\rho(k) - \\frac{2}{b}\\sum_{k=1}^{b-1} k\\rho(k) \\right] $$\n问题陈述指出级数 $\\sum_{k=0}^\\infty |\\rho(k)|$ 和 $\\sum_{k=1}^\\infty k\\,|\\rho(k)|$ 是绝对收敛的。这使我们可以取 $b \\to \\infty$ 的极限。\n设 $S_\\rho = \\sum_{k=1}^{\\infty} \\rho(k)$ 和 $S_{k\\rho} = \\sum_{k=1}^{\\infty} k\\rho(k)$。当 $b \\to \\infty$ 时：\n$$ \\sum_{k=1}^{b-1} \\rho(k) \\to S_\\rho $$\n$$ \\sum_{k=1}^{b-1} k\\rho(k) \\to S_{k\\rho} $$\n积分自相关时间定义为 $\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^\\infty \\rho(k) = \\frac{1}{2} + S_\\rho$。因此，$2S_\\rho = 2\\tau_{\\mathrm{int}} - 1$。\n对 $b\\,\\mathrm{Var}(Y_j)$ 取极限：\n$$ \\lim_{b\\to\\infty} b\\,\\mathrm{Var}(Y_j) = \\sigma^2 \\left[ 1 + 2S_\\rho - \\lim_{b\\to\\infty}\\frac{2S_{k\\rho}}{b} \\right] = \\sigma^2(1 + 2\\tau_{\\mathrm{int}} - 1) = \\sigma^2(2\\tau_{\\mathrm{int}}) $$\n对于大而有限的 $b$，我们有：\n$$ b\\,\\mathrm{Var}(Y_j) \\approx \\sigma^2 \\left[ (1+2S_\\rho) - \\frac{2S_{k\\rho}}{b} \\right] = \\sigma^2(2\\tau_{\\mathrm{int}}) - \\frac{2\\sigma^2 S_{k\\rho}}{b} $$\n所以，$b\\,\\mathrm{Var}(Y_j) = \\sigma^2(2\\tau_{\\mathrm{int}}) + \\mathcal{O}(1/b)$。这意味着：\n$$ \\mathrm{Var}(Y_j) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} + \\mathcal{O}\\left(\\frac{1}{b^2}\\right) $$\n\n**第三部分：批次均值估计量的分析**\n\n均值 $\\bar{X}$ 的批次均值方差估计量为 $\\widehat{\\mathrm{Var}}(\\bar X) = s_Y^2/m$。我们关心它的期望值 $\\mathbb{E}[s_Y^2/m]$。\n块均值的样本方差为 $s_Y^2 = \\frac{1}{m-1}\\sum_{j=1}^m(Y_j - \\bar Y)^2$。\n期望值为 $\\mathbb{E}[s_Y^2] = \\mathrm{Var}(Y_j) - \\frac{2}{m-1}\\sum_{p=1}^{m-1} (m-p)\\mathrm{Cov}(Y_j, Y_{j+p})$。\n对于大的块尺寸 $b$，块均值 $Y_j$ 和 $Y_{j+p}$ 变得越来越不相关，因为 $\\mathrm{Cov}(Y_j, Y_{j+p})$ 涉及到大延迟 $k \\ge (p-1)b+1$ 的相关性 $\\gamma(k)$。由于 $\\sum |\\gamma(k)|$ 收敛，当 $b \\to \\infty$ 时这些协方差项会消失。因此，对于大的 $b$，修正项很小，且 $\\mathbb{E}[s_Y^2] \\approx \\mathrm{Var}(Y_j)$。\n因此，对于大的 $b$：\n$$ \\mathbb{E}[s_Y^2] \\approx \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} + \\mathcal{O}\\left(\\frac{1}{b^2}\\right) $$\n$\\mathrm{Var}(\\bar X)$ 的估计量的期望为：\n$$ \\mathbb{E}[\\widehat{\\mathrm{Var}}(\\bar X)] = \\mathbb{E}[s_Y^2/m] \\approx \\frac{1}{m} \\left( \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} \\right) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{mb} = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{N} $$\n对于大的 $N$，样本均值 $\\bar X$ 的真实方差为 $\\mathrm{Var}(\\bar X) \\approx \\frac{\\sigma^2}{N}(1 + 2\\sum_{k=1}^\\infty \\rho(k)) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{N}$。因此，批次均值估计量是渐近无偏的。\n\n**选项评估**\n\nA. 在 $\\sum_{k=0}^\\infty |\\rho(k)|$ 和 $\\sum_{k=1}^\\infty k\\,|\\rho(k)|$ 绝对可和的条件下，对于大的 $b$，我们有 $\\mathbb{E}[s_Y^2] = \\frac{1}{b}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right) + \\mathcal{O}\\!\\left(\\frac{1}{b^2}\\right)$，因此当 $b\\to\\infty$、$m\\to\\infty$ 且 $N=mb$ 时，$\\mathbb{E}[s_Y^2/m] \\to \\frac{1}{N}\\,\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$。作为 $\\sigma^2\\left(2\\tau_{\\mathrm{int}}\\right)$ 的估计量，$b\\,s_Y^2$ 的偏差以 $\\mathcal{O}\\!\\left(\\frac{1}{b}\\right)$ 的速度衰减，且 $\\mathrm{Var}(s_Y^2)$ 按 $\\mathcal{O}\\!\\left(\\frac{1}{m}\\right)$ 的比例缩放。\n- **分析**:\n    - $\\mathbb{E}[s_Y^2] \\approx \\mathrm{Var}(Y_j) = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{b} + \\mathcal{O}(1/b^2)$。这是正确的。\n    - $\\mathbb{E}[s_Y^2/m] = \\frac{1}{m} \\mathbb{E}[s_Y^2] \\approx \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{mb} = \\frac{\\sigma^2(2\\tau_{\\mathrm{int}})}{N}$。在极限情况下，这与均值的真实方差相匹配。这是正确的。\n    - $b\\,s_Y^2$ 的偏差：$\\mathbb{E}[b\\,s_Y^2] - \\sigma^2(2\\tau_{\\mathrm{int}}) \\approx b\\,\\mathrm{Var}(Y_j) - \\sigma^2(2\\tau_{\\mathrm{int}})$。根据我们的推导，这个偏差约为 $-\\frac{2\\sigma^2 S_{k\\rho}}{b}$，即 $\\mathcal{O}(1/b)$。这是正确的。\n    - 估计量 $s_Y^2$ 的方差：对于大的 $b$，块均值 $Y_j$ 近似独立。$s_Y^2$ 是 $m$ 个此类变量的样本方差。样本方差的方差与 $1/(m-1)$ 成比例。所以，$\\mathrm{Var}(s_Y^2) \\sim \\mathcal{O}(1/m)$。这是正确的。\n- **结论**: **正确**。\n\nB. 对于大的 $b$，$\\mathbb{E}[s_Y^2] \\sim \\frac{\\sigma^2}{b^2}$，因此 $\\mathbb{E}[s_Y^2/m] \\sim \\frac{\\sigma^2}{N b} \\to 0$，这意味着随着 $b$ 的增长，分块法会系统性地低估 $\\mathrm{Var}(\\bar X)$。\n- **分析**: $\\mathbb{E}[s_Y^2]$ 的首项与 $1/b$ 而非 $1/b^2$ 成比例。推导证明了这一点。关于估计量系统性地将方差低估至零的结论是错误的；它是渐近无偏的。\n- **结论**: **不正确**。\n\nC. 一旦 $b$ 超过积分自相关时间 $\\tau_{\\mathrm{int}}$，块均值 $Y_j$ 就会变得精确独立，因此对于任何 $m \\ge 2$，$s_Y^2/m$ 都等于 $\\mathrm{Var}(\\bar X)$ 的精确值。\n- **分析**: 这个陈述包含两个根本性错误。首先，对于一个自相关函数不具有限支撑的过程，块均值永远不会精确独立。$\\tau_{\\mathrm{int}}$ 值是一个有效的时间尺度，而不是一个明确的截断点。其次，$s_Y^2/m$ 是一个统计估计量，一个随机变量。它在其均值附近波动，并不等于真实参数 $\\mathrm{Var}(\\bar X)$。\n- **结论**: **不正确**。\n\nD. 对于大的 $b$，期望值 $\\mathbb{E}[s_Y^2/m]$ 随 $b$ 线性增加，因为块内平均抑制了块内相关性并放大了块间变异性，从而 $\\mathbb{E}[s_Y^2/m] \\propto b/N$。\n- **分析**: 对于固定的总数据量 $N$，我们的推导表明 $\\mathbb{E}[s_Y^2/m] \\approx \\sigma^2(2\\tau_{\\mathrm{int}})/N$，它作为 $b$ 的函数是渐近常数。它不随 $b$ 线性增加。虽然 $\\mathbb{E}[b s_Y^2]$ 作为 $b$ 的函数会增加然后达到平台期，但 $\\mathbb{E}[s_Y^2/m] = \\mathbb{E}[b s_Y^2] / N$ 也会达到平台期。线性增长的说法是不正确的。关于放大变异性的推理也是错误的。\n- **结论**: **不正确**。\n\n总之，选项A对批次均值法的渐近性质给出了一个全面而准确的总结。", "answer": "$$\\boxed{A}$$", "id": "2909657"}]}