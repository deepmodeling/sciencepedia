{"hands_on_practices": [{"introduction": "Flory-Stockmayer 理论为凝胶化过程提供了经典的平均场描述。第一个动手实践将此理论应用于一个基础但非平凡的系统：双官能度 ($f=2$) 和三官能度 ($f=3$) 单体的混合物。通过这个练习，你将从第一性原理推导凝胶点，这需要正确应用分支过程理论，并理解平均官能度如何决定无限网络形成的临界条件 [@problem_id:2916994]。", "problem": "考虑一个理想的逐步增长网络形成缩聚反应，其中大量单体各自携带整数个相同的同官能反应基团，这些基团彼此成对反应。该体系是官能度为 $f=3$（三官能）和 $f=2$（二官能）的单体的二元混合物。令 $x$ 表示三官能单体的初始摩尔分数（数量分数），因此二官能单体的分数为 $1 - x$。假设满足以下理想条件：(i) 所有官能团在任何时候都具有相等的反应活性，(ii) 在凝胶前状态下，分子内环化可以忽略不计，因此团簇是局部树状的，以及 (iii) 反应在所有未反应的官能团之间随机进行。令 $p$ 为反应程度，定义为已反应官能团占所有官能团的分数。\n\n应用分支过程和逾渗理论的第一性原理到这个理想无规网络上，推导凝胶化判据，该判据需用以下方式表示：当沿着一个已反应的化学键追踪到一个新的单体时，所产生的新反应键的平均数。然后，对于上述指定的二元混合物，计算凝胶首次出现时的临界反应程度 $p_c$，并将其表示为 $x$ 的显式函数。将您的最终结果表示为关于 $x$ 的单个简化解析表达式。最终答案无需四舍五入，也无需报告单位。", "solution": "该问题要求推导官能度为 $f=3$ 和 $f=2$ 的单体二元混合物在理想逐步增长聚合反应中的凝胶化判据。最终目标是将凝胶化的临界反应程度 $p_c$ 表示为三官能单体初始摩尔分数 $x$ 的函数。\n\n问题陈述已经过验证，具有科学依据，问题定义明确、客观且内部一致。这是一个基于 Flory-Stockmayer 凝胶理论的聚合物统计力学中的标准问题，该理论是逾渗理论在化学反应网络上的一个平均场应用。给定的假设——官能团等反应活性、无分子内环化以及随机反应——是该模型的标准理想条件。我们可以开始求解。\n\n凝胶化的开始对应于一个无限的、贯穿空间的聚合物网络的形成。用分支过程的语言来说，这是分支级联无限延续的概率变为非零的点。此转变的判据是分支参数 $\\alpha$ 必须等于或大于 $1$。分支参数 $\\alpha$ 定义为：沿着一个随机选择的已反应化学键到达下一个单体，然后从该单体分支出来所遇到的新反应键的平均数。凝胶化发生在临界点 $\\alpha = 1$ 处。\n\n让我们为给定体系构建 $\\alpha$ 的表达式。我们有一个二元单体混合物：\n1.  官能度为 $f_1=3$、摩尔分数为 $x$ 的三官能单体。\n2.  官能度为 $f_2=2$、摩尔分数为 $1-x$ 的二官能单体。\n\n反应程度 $p$ 是任何随机选择的官能团已发生反应的概率。\n\n为了计算 $\\alpha$，我们进行一个两步的统计平均。首先，我们必须确定沿着一个随机选择的化学键到达某一特定官能度单体的概率。这个概率不是该单体的摩尔分数，而是属于该类型单体的官能团占所有官能团的分数。\n\n体系中官能团的总数与数均官能度 $\\langle f \\rangle$ 成正比。\n$$ \\langle f \\rangle = \\sum_{i} x_i f_i = x \\cdot 3 + (1-x) \\cdot 2 = 3x + 2 - 2x = x + 2 $$\n属于三官能单体的官能团分数为：\n$$ P(f=3)_{\\text{group}} = \\frac{x \\cdot f_1}{\\langle f \\rangle} = \\frac{3x}{x+2} $$\n属于二官能单体的官能团分数为：\n$$ P(f=2)_{\\text{group}} = \\frac{(1-x) \\cdot f_2}{\\langle f \\rangle} = \\frac{2(1-x)}{x+2} $$\n注意，$P(f=3)_{\\text{group}} + P(f=2)_{\\text{group}} = \\frac{3x + 2 - 2x}{x+2} = \\frac{x+2}{x+2} = 1$，符合要求。\n\n现在，考虑一个随机选择的已反应化学键并沿着它到达一个单体单元。该单体是三官能的概率为 $P(f=3)_{\\text{group}}$，是二官能的概率为 $P(f=2)_{\\text{group}}$。一旦我们到达这个单体，它的一个官能团就被我们所跟随的化学键占据了。一个官能度为 $f$ 的单体有 $f-1$ 个其他的“出射”官能团可用于形成新的分支。\n- 对于三官能单体（$f=3$），有 $3-1 = 2$ 个出射基团。\n- 对于二官能单体（$f=2$），有 $2-1 = 1$ 个出射基团。\n\n通过一个化学键到达的单体所具有的出射官能团的平均数是 $(f-1)$ 的基团加权平均值：\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\sum_{i} P(f=f_i)_{\\text{group}} \\cdot (f_i - 1) $$\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\left(\\frac{3x}{x+2}\\right)(3-1) + \\left(\\frac{2(1-x)}{x+2}\\right)(2-1) $$\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\frac{3x \\cdot 2}{x+2} + \\frac{2(1-x) \\cdot 1}{x+2} $$\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\frac{6x + 2 - 2x}{x+2} = \\frac{4x+2}{x+2} $$\n这个量代表了从该单体出发的潜在路径的平均数。\n\n分支参数 $\\alpha$ 是这些出射路径中实际连接到其他单体的路径的平均数。由于任何给定的官能团已反应的概率是 $p$，因此新反应键的平均数是 $p$ 与出射基团平均数的乘积。\n$$ \\alpha = p \\cdot \\langle f-1 \\rangle_{\\text{group-weighted}} = p \\left(\\frac{4x+2}{x+2}\\right) $$\n凝胶化的临界条件是 $\\alpha = 1$。令 $p_c$ 为凝胶点的临界反应程度。\n$$ 1 = p_c \\left(\\frac{4x+2}{x+2}\\right) $$\n求解 $p_c$ 得到凝胶点的最终表达式：\n$$ p_c = \\frac{x+2}{4x+2} $$\n这就是所求的结果。它将临界反应程度表示为单体混合物初始组成的函数。该表达式正确地恢复了已知的极限情况：对于纯二官能体系（$x=0$），$p_c = \\frac{2}{2} = 1$，这表明不会发生凝胶化（网络形成），尽管重均摩尔质量会发散。对于纯三官能体系（$x=1$），$p_c = \\frac{1+2}{4+2} = \\frac{3}{6} = \\frac{1}{2}$，这是经典的 Flory-Stockmayer 对于 $f=3$ 单体的结果，即 $p_c = 1/(f-1)$。", "answer": "$$ \\boxed{\\frac{x+2}{4x+2}} $$", "id": "2916994"}, {"introduction": "在第一个练习的基础上，我们现在考虑一个更复杂且在化学合成中更常见的情况：两种不同的官能团 (A和B) 之间的逐步聚合反应。这个实践探讨了化学计量不平衡（一个关键的实验控制参数）如何改变凝胶点。你将通过将系统建模为双组分分支过程来推导凝胶化发生的条件，从而加深对控制网络形成的物理原理的理解 [@problem_id:2917066]。", "problem": "一个逐步增长网络是通过两种互补类型的多官能单体（标记为A和B）反应形成的，其中只形成A-B键。设A和B官能团的初始总数分别为$N_{A,0}$和$N_{B,0}$，并将化学计量不平衡定义为$r = N_{B,0}/N_{A,0}$。设$p_A$和$p_B$分别表示A和B官能团的反应程度，定义为相应官能团已反应的比例。假设所有同类型官能团具有相等的反应活性，在凝胶化之前进行随机成键且不发生分子内环化，并且没有副反应。A型单体的官能度为$f_A$，B型单体的官能度为$f_B$（两者均被视为与转化率无关的整数常数）。\n\n- 仅使用已反应官能团守恒原理，构建函数$p_B(p_A, r)$。\n- 使用“在此类随机二分网络中的凝胶化等同于相关双类型支化过程的再生因子达到1”这一原理，求出凝胶点，即临界A官能团转化率$p_{A,\\mathrm{c}}$关于$r$、$f_A$和$f_B$的闭合形式解析表达式。\n\n将最终答案表示为一个单行矩阵中的两个元素：第一个是$p_B(p_A,r)$，第二个是$p_{A,\\mathrm{c}}(r,f_A,f_B)$。无需进行数值计算，也无需四舍五入。最终表达式是无量纲的，应不带单位报告。", "solution": "所给问题是关于逐步增长聚合凝胶化的Flory-Stockmayer理论的一个标准练习。该问题具有科学依据，提法恰当，并包含了求解所需的所有信息。因此，该问题被认为是有效的。\n\n该问题包括两个部分。首先，我们必须建立两种官能团A和B的反应程度之间的关系。其次，我们必须推导出凝胶点时A官能团的临界反应程度$p_{A,\\mathrm{c}}$。\n\n第1部分：$p_A$和$p_B$之间的关系\n\n聚合物网络的形成完全通过A型官能团与B型官能团的反应进行。这意味着已反应的A官能团和已反应的B官能团之间存在一一对应关系。这就是已反应官能团守恒原理。\n\n设$N_{A,0}$为A官能团的初始数量，$N_{B,0}$为B官能团的初始数量。A官能团的反应程度$p_A$定义为已反应的A官能团的比例。因此，已反应的A官能团总数为$p_A N_{A,0}$。类似地，已反应的B官能团总数为$p_B N_{B,0}$，其中$p_B$是B官能团的反应程度。\n\n根据守恒原理：\n$$p_A N_{A,0} = p_B N_{B,0}$$\n问题将化学计量不平衡定义为$r = \\frac{N_{B,0}}{N_{A,0}}$。我们可以重排守恒方程来解出$p_B$：\n$$p_B = p_A \\frac{N_{A,0}}{N_{B,0}}$$\n代入$r$的定义，我们发现$\\frac{N_{A,0}}{N_{B,0}} = \\frac{1}{r}$。因此，函数$p_B(p_A, r)$是：\n$$p_B = \\frac{p_A}{r}$$\n\n第2部分：凝胶点条件的推导\n\n问题要求将凝胶化建模为相关双类型支化过程的再生因子达到1的点。这对应于无限分子网络形成的开始。该网络是一个随机二分图，其节点代表单体，边代表A-B键。\n\n考虑沿着聚合物主链的一条路径。我们通过化学键从一个单体移动到另一个单体来追踪该路径。让我们定义，在通过一个键到达某个单体后，从该单体发出的新分支的期望数。\n\nA型单体的官能度为$f_A$。如果我们通过其一个已反应的官能团到达这个单体，那么还有$f_A - 1$个其他官能团可用于形成其他分支。假设反应活性相等且无分子内反应，这些A官能团中任意一个已反应形成新键的概率是$p_A$。因此，从这个A单体延伸出的新分支的期望数是：\n$$E_{A \\to B} = p_A (f_A - 1)$$\n这些新分支连接到B型单体。\n\n类似地，B型单体的官能度为$f_B$。通过一个键到达这个单体后，剩下$f_B - 1$个其他官能团。这些B官能团中任意一个已反应的概率是$p_B$。从这个B单体延伸出的新分支的期望数是：\n$$E_{B \\to A} = p_B (f_B - 1)$$\n这些新分支连接到A型单体。\n\n在这个二分网络中，支化级联的传播涉及从A单体到B单体，再从B单体到A单体的交替步骤。一个完整周期（例如，从一代A单体通过中间一代B单体到下一代A单体）的再生因子是每一步分支期望数的乘积。\n$$R = E_{A \\to B} \\times E_{B \\to A} = p_A (f_A - 1) p_B (f_B - 1)$$\n当再生因子$R$等于1时，在临界点发生凝胶化。在这一点，反应程度用临界值$p_{A,\\mathrm{c}}$和$p_{B,\\mathrm{c}}$表示。因此，凝胶化的条件是：\n$$p_{A,\\mathrm{c}} (f_A - 1) p_{B,\\mathrm{c}} (f_B - 1) = 1$$\n我们现在将第一部分推导出的关系式$p_{B,\\mathrm{c}} = \\frac{p_{A,\\mathrm{c}}}{r}$代入这个凝胶化判据中：\n$$p_{A,\\mathrm{c}} (f_A - 1) \\left(\\frac{p_{A,\\mathrm{c}}}{r}\\right) (f_B - 1) = 1$$\n我们继续求解$p_{A,\\mathrm{c}}$：\n$$(p_{A,\\mathrm{c}})^2 \\frac{(f_A - 1)(f_B - 1)}{r} = 1$$\n$$(p_{A,\\mathrm{c}})^2 = \\frac{r}{(f_A - 1)(f_B - 1)}$$\n由于反应程度必须是非负的，取正平方根，得到A官能团临界转化率的最终表达式：\n$$p_{A,\\mathrm{c}} = \\sqrt{\\frac{r}{(f_A - 1)(f_B - 1)}}$$\n这个推导依赖于$f_A > 1$且$f_B > 1$的假设，这是网络形成的必要条件。\n\n这样，两个所需的表达式就确定了。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{p_A}{r} & \\sqrt{\\frac{r}{(f_A - 1)(f_B - 1)}}\n\\end{pmatrix}\n}\n$$", "id": "2917066"}, {"introduction": "从解析性的平均场模型转向基于格点的计算逾渗理论，我们可以更直观地研究凝胶簇的结构。这个实践的核心是“骨架”的概念——逾渗簇中能够承载负荷或传导电流的结构核心部分。通过这个编码练习，你将实现一个“叶剥离”算法来识别和量化这个骨架的大小，从而将抽象的逾渗理论与具体可测的结构特性联系起来 [@problem_id:2916990]。", "problem": "考虑有限方格格点上的独立键渗流。设 $L \\in \\mathbb{N}$ 为线性系统尺寸。定义具有开放边界的底层确定性网格图 $G_L = (V,E)$，其中 $V = \\{(i,j) \\mid i \\in \\{0,\\dots,L-1\\}, j \\in \\{0,\\dots,L-1\\}\\}$，$E$ 包含所有在 $(i,j)$ 和 $(i,j+1)$ 之间（对所有 $j \\in \\{0,\\dots,L-2\\}$）以及在 $(i,j)$ 和 $(i+1,j)$ 之间（对所有 $i \\in \\{0,\\dots,L-2\\}$）的无向边。对于键占据概率 $p \\in [0,1]$ 和伪随机种子 $s \\in \\mathbb{N}$，使用由 $s$ 初始化的伪随机数生成器，以概率 $p$ 独立地保留 $E$ 中的每条边，从而形成一个随机子图 $G = (V, E_{\\mathrm{open}})$。\n\n定义顶部边界集 $T = \\{(0,j) \\mid j \\in \\{0,\\dots,L-1\\}\\}$ 和底部边界集 $B = \\{(L-1,j) \\mid j \\in \\{0,\\dots,L-1\\}\\}$。$G$ 的一个连通分量 $C$ 如果同时与 $T$ 和 $B$ 相交，则称其为贯穿的。如果不存在这样的 $C$，则定义贯穿主干长度 $\\ell$ 为 $0$。\n\n否则，在所有贯穿分量中，为避免歧义，通过以下确定性规则选择 $C^\\star$：最大化 $|V(C)|$；若出现平局，则最大化 $|E(C)|$；若仍有平局，则在索引映射 $\\varphi: V \\to \\{0,\\dots,L^2-1\\}$（由 $\\varphi(i,j) = iL + j$ 给出）下，最小化最小的顶点索引。\n\n对于选定的 $C^\\star$，定义其导出子图 $H^\\star$，其顶点集为 $V^\\star = V(C^\\star)$，边集为 $E_{\\mathrm{open}}$ 中两个端点均在 $V^\\star$ 内的所有开边。定义顶点 $v \\in V^\\star$ 的度 $d_{H^\\star}(v)$ 为 $v$ 在 $H^\\star$ 中的邻居数量。叶剥离（也称为迭代剪枝）过程通过重复移除所有度 $d_{H^\\star}(v) < 2$ 的顶点 $v$ 及其关联边，并在每次移除后更新度，直到不存在此类顶点为止，从而构建 $H^\\star$ 的 $2$-核。设得到的剪枝后的子图为 $K^\\star$。定义贯穿主干长度 $\\ell$ 为 $K^\\star$ 中无向边的数量。\n\n您的任务是实现一个程序，对于每个给定的参数三元组 $(L,p,s)$，生成 $G$，找到存在的 $C^\\star$，通过叶剥离计算 $2$-核 $K^\\star$，并输出如上定义的整数 $\\ell$。如果不存在贯穿分量，则对该情况输出整数 $0$。\n\n需要在您的设计中使用并论证的算法约束和基础：\n- 仅使用图连通性、度、导出子图的定义，以及基于度阈值 $2$ 的迭代剪枝规则来获得 $2$-核，该过程移除了所有不可能位于 $T$ 和 $B$ 之间任何简单路径上的悬挂树。\n- 为寻找连通分量，您可以使用广度优先搜索 (BFS)，该算法按边数表示的非递减距离系统地探索顶点。\n- 根据指定的 $p$，渗流在各边上是独立同分布的，由 $s$ 播种的伪随机生成器确保了可复现性。\n\n测试套件：\n为以下参数元组 $(L,p,s)$ 提供输出：\n- 情况 1: $(L,p,s) = (2, 1.0, 0)$。\n- 情况 2: $(L,p,s) = (3, 1.0, 0)$。\n- 情况 3: $(L,p,s) = (30, 0.4, 7)$。\n- 情况 4: $(L,p,s) = (50, 0.6, 12345)$。\n- 情况 5: $(L,p,s) = (50, 0.55, 999)$。\n\n所有输出均为整数，不涉及物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），结果顺序与上述情况的顺序相同。", "solution": "所述问题是有效的。它在科学上和数学上是适定的，其基础是渗流理论（统计力学和概率论的一个分支）的既定原理。该问题是自洽的，其定义是精确的，并且用于生成随机图和打破平局的确定性程序确保了每组参数都存在唯一的、可验证的解。我们将着手构建解决方案。\n\n该问题要求计算有限 $L \\times L$ 方格格点上键渗流模型中贯穿团簇的“主干”大小。主干被正式定义为贯穿团簇的 $2$-核。步骤如下：\n\n首先，对于给定的系统尺寸 $L$、键占据概率 $p$ 和伪随机种子 $s$，我们构建随机图 $G = (V, E_{\\mathrm{open}})$ 的具体实现。顶点集 $V$ 对应于方格格点的格点，为便于计算，我们通过映射 $\\varphi(i,j) = iL + j$ 将位于第 $i$ 行和第 $j$ 列（其中 $i, j \\in \\{0, \\dots, L-1\\}$）的格点索引为单个整数 $v \\in \\{0, \\dots, L^2-1\\}$。底层网格图 $G_L$ 在相邻顶点之间有边。每条边以概率 $p$ 被独立地包含在开边集 $E_{\\mathrm{open}}$ 中。为确保可复现性，使用种子 $s$ 初始化伪随机数生成器。我们通过遍历网格的每个潜在边，为每条边抽取一个伪随机数，如果该数小于 $p$，则将该边添加到邻接表中，从而生成 $G$ 的邻接表表示。\n\n其次，我们必须识别图 $G$ 的所有连通分量。这是一个标准的图遍历问题，广度优先搜索 (BFS) 算法是解决此问题的适用且高效的方法。我们维护一个布尔数组来跟踪已访问的顶点。遍历所有顶点，如果发现未访问的顶点，则从该顶点开始启动新的 BFS，以找到属于其分量的所有顶点。\n\n第三，对于找到的每个分量，我们判断它是否为“贯穿”分量。如果一个分量 $C$ 的顶点集 $V(C)$ 与顶部边界集 $T = \\{v \\mid 0 \\le v < L\\}$ 和底部边界集 $B = \\{v \\mid L(L-1) \\le v < L^2\\}$ 都有非空交集，则定义其为贯穿的。如果不存在这样的贯穿分量，问题定义主干长度 $\\ell$ 为 $0$，该情况下的流程终止。\n\n第四，如果存在一个或多个贯穿分量，我们必须根据指定的确定性规则选择一个唯一的分量 $C^\\star$。该规则是基于层级标准的字典序比较：\n1. 具有最大顶点数 $|V(C)|$ 的分量。\n2. 在最大 $|V(C)|$ 平局的分量中，选择具有最大边数 $|E(C)|$ 的分量。\n3. 如果仍然存在平局，则选择其最小顶点索引值最小的分量。\n此过程保证了唯一的 $C^\\star$。\n\n第五，我们计算 $C^\\star$ 的 $2$-核，记为 $K^\\star$。图的 $2$-核是其最小度至少为 $2$ 的最大导出子图。它通过迭代剪枝算法（也称为叶剥离）找到。算法流程如下：\n1. 我们首先计算所有顶点 $v \\in V(C^\\star)$ 的度 $d_{C^\\star}(v)$。度是 $v$ 的邻居中也属于 $V(C^\\star)$ 的数量。\n2. 所有度 $d_{C^\\star}(v) < 2$ 的顶点被识别出来并放入一个队列中。根据定义，这些顶点不能是任何环路的一部分，因此被视为结构的“叶子”。\n3. 我们迭代处理队列。当一个顶点 $u$ 从队列中移除时，它就从图中被剪枝。对于被剪枝顶点 $u$ 的每个邻居 $v$，其度减 1。如果邻居 $v$ 的度降至 1，它就成为了一个新的叶子，并被添加到队列中。\n4. 这个过程持续进行，直到队列为空。未被剪枝的顶点集合构成了 $2$-核的顶点集 $V(K^\\star)$。在物理上，这个核代表了团簇的弹性部分，包含了所有对于鲁棒输运至关重要的循环路径。\n\n最后，所需贯穿主干长度 $\\ell$ 是最终得到的 $2$-核 $K^\\star$ 中的边数。这可以通过将核内所有顶点的度相加再除以二（即 $\\ell = \\frac{1}{2} \\sum_{v \\in V(K^\\star)} d_{K^\\star}(v)$）来计算，或者直接计算两个端点均在 $V(K^\\star)$ 内的边数。至此，所需的计算完成。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the percolation backbone problem for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        (2, 1.0, 0),\n        (3, 1.0, 0),\n        (30, 0.4, 7),\n        (50, 0.6, 12345),\n        (50, 0.55, 999),\n    ]\n\n    results = []\n    for L, p, s in test_cases:\n        result = calculate_backbone_length(L, p, s)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_backbone_length(L, p, s):\n    \"\"\"\n    Calculates the spanning backbone length for a given (L, p, s) triple.\n    \"\"\"\n    if L  2 and p > 0: # Spanning is not possible for L=1\n        return 0\n\n    N = L * L\n    rng = np.random.default_rng(s)\n    \n    # 1. Generate the random graph G = (V, E_open)\n    adj = {i: [] for i in range(N)}\n    for i in range(L):\n        for j in range(L):\n            u = i * L + j\n            # Edge to the right neighbor\n            if j  L - 1:\n                v = i * L + (j + 1)\n                if rng.random()  p:\n                    adj[u].append(v)\n                    adj[v].append(u)\n            # Edge to the bottom neighbor\n            if i  L - 1:\n                v = (i + 1) * L + j\n                if rng.random()  p:\n                    adj[u].append(v)\n                    adj[v].append(u)\n\n    # 2. Find all connected components and identify spanning ones\n    visited = np.zeros(N, dtype=bool)\n    spanning_components = []\n    for i in range(N):\n        if not visited[i]:\n            component_nodes = set()\n            q = deque([i])\n            visited[i] = True\n            is_top_connected = False\n            is_bottom_connected = False\n            min_v_idx = i\n\n            # BFS to find one component\n            while q:\n                u = q.popleft()\n                component_nodes.add(u)\n                min_v_idx = min(min_v_idx, u)\n                \n                if u  L:\n                    is_top_connected = True\n                if u >= L * (L - 1):\n                    is_bottom_connected = True\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            \n            if is_top_connected and is_bottom_connected:\n                num_vertices = len(component_nodes)\n                num_edges = sum(len(adj[u]) for u in component_nodes) // 2\n                spanning_components.append((-num_vertices, -num_edges, min_v_idx, component_nodes))\n\n    # 3. Select the primary spanning component C_star\n    if not spanning_components:\n        return 0\n\n    spanning_components.sort()\n    C_star_nodes = spanning_components[0][3]\n\n    # 4. Compute the 2-core of C_star using leaf-stripping\n    \n    # Create subgraph representation for C_star\n    subgraph_adj = {u: [v for v in adj[u] if v in C_star_nodes] for u in C_star_nodes}\n    degrees = {u: len(v) for u, v in subgraph_adj.items()}\n\n    # Queue for leaf-stripping\n    q = deque([u for u, d in degrees.items() if d  2])\n    \n    while q:\n        u = q.popleft()\n        \n        # u is pruned. Update its neighbors' degrees.\n        for v in subgraph_adj[u]:\n            if v in degrees:  # Check if neighbor has not been pruned yet\n                degrees[v] -= 1\n                if degrees[v] == 1:\n                    q.append(v)\n        \n        # Remove u from the graph\n        del degrees[u]\n\n    core_nodes = set(degrees.keys())\n\n    # 5. Calculate the backbone length (number of edges in the 2-core)\n    if not core_nodes:\n        return 0\n\n    backbone_len = sum(1 for u in core_nodes for v in subgraph_adj[u] if v in core_nodes and v > u)\n    \n    return backbone_len\n\nsolve()\n```", "id": "2916990"}]}