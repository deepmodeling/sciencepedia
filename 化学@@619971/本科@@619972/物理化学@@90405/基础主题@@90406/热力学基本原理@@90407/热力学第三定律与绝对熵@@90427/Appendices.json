{"hands_on_practices": [{"introduction": "热力学第三定律指出，完美晶体的熵在温度趋于绝对零度时趋近于零。然而，一些物质由于“冻结”的无序状态，在绝对零度下仍保留着非零的熵，即所谓的“残余熵”。这个练习提供了一个绝佳的机会，让我们从一个可测量的宏观量——残余熵——出发，反向推导导致这种无序的微观构型数量，这直接应用了连接熵与概率的玻尔兹曼公式。[@problem_id:2022089]", "problem": "正在研究亚硝酰氟（NOF）晶体在低温下的热力学性质。根据热力学第三定律，当温度趋近于绝对零度（$T \\to 0$ K）时，完美晶体的熵应趋近于零。然而，实验测量表明，固态 NOF 在此极限下具有非零的摩尔熵，这种现象被称为残余熵。这归因于极性 NOF 分子的随机取向，这些分子在晶格中被“冻结”了。\n\n已知实验测定的 NOF 晶体残余摩尔熵为 $S_{m, \\text{res}} = 5.76 \\text{ J} \\cdot \\text{K}^{-1} \\cdot \\text{mol}^{-1}$，请计算在绝对零度下，每个 NOF 分子在晶格中可以采用的、能量上等效的不同取向数（$w$）。假设理想气体常数为 $R = 8.314 \\text{ J} \\cdot \\text{K}^{-1} \\cdot \\text{mol}^{-1}$。你的答案应该是 $w$ 的一个具有物理意义的整数值。", "solution": "残余熵源于在 $T \\to 0$ 时被冻结的构型简并度。对于一个晶体，其中每个分子有 $w$ 个能量上等效的取向，且这些取向在分子间是独立的，则一摩尔物质的总微观状态数为 $\\Omega = w^{N_{A}}$，其中 $N_{A}$ 是阿伏伽德罗常数。根据玻尔兹曼公式，熵为\n$$\nS = k_{B} \\ln \\Omega = k_{B} \\ln\\left(w^{N_{A}}\\right) = k_{B} N_{A} \\ln w = R \\ln w,\n$$\n其中 $R = N_{A} k_{B}$ 是摩尔气体常数。因此，残余摩尔熵为\n$$\nS_{m,\\text{res}} = R \\ln w.\n$$\n求解 $w$ 可得\n$$\nw = \\exp\\!\\left(\\frac{S_{m,\\text{res}}}{R}\\right).\n$$\n代入给定值，\n$$\nw = \\exp\\!\\left(\\frac{5.76}{8.314}\\right) \\approx \\exp(0.693) \\approx 2.\n$$\n由于 $w$ 必须是一个表示取向数量且具有物理意义的整数，并且 $5.76 \\text{ J} \\cdot \\text{K}^{-1} \\cdot \\text{mol}^{-1}$ 在实验精度范围内等于 $R \\ln 2$，因此等效取向的数量为 $w = 2$。", "answer": "$$\\boxed{2}$$", "id": "2022089"}, {"introduction": "残余熵处理的是在 $T = 0$ K 时被冻结的无序，而计算标准温度下的绝对熵则需要对所有可及的能态贡献进行求和。对于大多数分子，电子运动对熵的贡献可以忽略不计或非常简单，但一氧化氮 (NO) 是一个经典的例外，因为它有一个能量很低的电子激发态。这个练习将演示如何运用统计力学的配分函数来计算这些电子能级对总熵的贡献，它精彩地将光谱数据与热力学性质联系了起来。[@problem_id:2022085]", "problem": "一氧化氮（NO）是一种双原子分子，由于其电子结构而表现出非寻常的热力学性质。其电子基态是一个双重态，通常标记为 ${}^2\\Pi_{1/2}$。独特的是，它拥有一个能量非常低的第一电子激发态 ${}^2\\Pi_{3/2}$，这也是一个双重态。这两个能态之间的能量差对应于一个波数 $\\Delta \\tilde{\\nu}$，其值为 $121.1 \\text{ cm}^{-1}$。为解决此问题，假设基态和第一激发电子态都是二重简并的。\n\n计算在温度 $T = 298.0 \\text{ K}$ 时，这些电子能级对气态一氧化氮绝对摩尔熵的贡献。\n\n使用以下物理常数值：\n- 摩尔气体常数, $R = 8.3145 \\text{ J mol}^{-1} \\text{ K}^{-1}$\n- 普朗克常数, $h = 6.6261 \\times 10^{-34} \\text{ J s}$\n- 光速, $c = 2.9979 \\times 10^{10} \\text{ cm s}^{-1}$\n- 玻尔兹曼常数, $k_B = 1.3807 \\times 10^{-23} \\text{ J K}^{-1}$\n\n以 J mol$^{-1}$ K$^{-1}$ 为单位表示你的答案，并四舍五入到三位有效数字。", "solution": "对于一组能量为 $\\{\\epsilon_{i}\\}$、简并度为 $\\{g_{i}\\}$ 的电子能级，其电子配分函数为\n$$\nq_{\\mathrm{el}}=\\sum_{i} g_{i}\\exp\\!\\left(-\\frac{\\epsilon_{i}}{k_{B}T}\\right).\n$$\n对于具有两个能级的一氧化氮，基态能量为 $\\epsilon_{0}=0$，激发态能量为 $\\epsilon_{1}=\\Delta E$，且二者简并度均为 $g_{0}=g_{1}=2$，我们有\n$$\nq_{\\mathrm{el}}=2\\left[1+\\exp\\!\\left(-\\frac{\\Delta E}{k_{B}T}\\right)\\right].\n$$\n这些能级对摩尔熵的贡献为\n$$\nS_{\\mathrm{el}}=R\\left[\\ln q_{\\mathrm{el}}+T\\left(\\frac{\\partial \\ln q_{\\mathrm{el}}}{\\partial T}\\right)_{V}\\right].\n$$\n令 $x=\\exp\\!\\left(-\\frac{\\Delta E}{k_{B}T}\\right)$。则 $q_{\\mathrm{el}}=2(1+x)$ 且\n$$\n\\frac{dq_{\\mathrm{el}}}{dT}=2\\frac{dx}{dT},\\quad \\frac{dx}{dT}=x\\,\\frac{\\Delta E}{k_{B}T^{2}},\n$$\n所以\n$$\nT\\frac{\\partial \\ln q_{\\mathrm{el}}}{\\partial T}\n=T\\frac{1}{q_{\\mathrm{el}}}\\frac{dq_{\\mathrm{el}}}{dT}\n=\\frac{\\Delta E}{k_{B}T}\\,\\frac{x}{1+x}.\n$$\n因此，\n$$\nS_{\\mathrm{el}}=R\\left[\\ln\\!\\big(2(1+x)\\big)+\\frac{\\Delta E}{k_{B}T}\\,\\frac{x}{1+x}\\right],\\quad x=\\exp\\!\\left(-\\frac{\\Delta E}{k_{B}T}\\right).\n$$\n\n能级间距由波数 $\\Delta\\tilde{\\nu}$ 通过以下公式给出\n$$\n\\Delta E=h\\,c\\,\\Delta\\tilde{\\nu}.\n$$\n使用所提供的常数，\n$$\n\\Delta E=(6.6261\\times 10^{-34}\\,\\text{J s})(2.9979\\times 10^{10}\\,\\text{cm s}^{-1})(121.1\\,\\text{cm}^{-1})\n\\approx 2.40558\\times 10^{-21}\\,\\text{J}.\n$$\n然后\n$$\n\\frac{\\Delta E}{k_{B}}=\\frac{2.40558\\times 10^{-21}\\,\\text{J}}{1.3807\\times 10^{-23}\\,\\text{J K}^{-1}}\\approx 1.74229\\times 10^{2}\\,\\text{K},\n$$\n在 $T=298.0\\,\\text{K}$ 时，\n$$\n\\frac{\\Delta E}{k_{B}T}\\approx \\frac{174.229}{298.0}\\approx 0.58466,\\qquad\nx=\\exp(-0.58466)\\approx 0.55729.\n$$\n因此\n$$\nq_{\\mathrm{el}}=2(1+x)\\approx 3.11458,\\quad \\ln q_{\\mathrm{el}}\\approx 1.13608,\n$$\n$$\n\\frac{x}{1+x}\\approx \\frac{0.55729}{1.55729}\\approx 0.35789,\\quad\n\\frac{\\Delta E}{k_{B}T}\\frac{x}{1+x}\\approx 0.58466\\times 0.35789\\approx 0.20924,\n$$\n所以方括号中的项为\n$$\n\\ln q_{\\mathrm{el}}+\\frac{\\Delta E}{k_{B}T}\\frac{x}{1+x}\\approx 1.13608+0.20924=1.34532.\n$$\n最后，\n$$\nS_{\\mathrm{el}}=R\\times 1.34532\\approx (8.3145\\,\\text{J mol}^{-1}\\text{K}^{-1})\\times 1.34532\\approx 11.186\\,\\text{J mol}^{-1}\\text{K}^{-1}.\n$$\n四舍五入到三位有效数字，结果为 $11.2\\,\\text{J mol}^{-1}\\text{K}^{-1}$。", "answer": "$$\\boxed{11.2}$$", "id": "2022085"}, {"introduction": "在探讨了微观状态如何贡献于熵之后，我们现在转向测定绝对熵值的基本实验方法。这个综合性练习模拟了真实世界中的量热学过程：通过对测得的热容数据进行积分，并计入相变时的熵变（$\\Delta S_\\text{tr} = L_\\text{tr}/T_\\text{tr}$），从绝对零度开始逐步建立起绝对熵。这个实践揭示了你在热力学数据表中看到的数值是如何获得的，并强化了熵作为状态函数的概念。[@problem_id:2680899]", "problem": "给定一种假设的晶体物质，其在恒定压力下的测得摩尔等压热容（Cp）由连续温度区间上的分段多项式表示，并存在两次一级相变。目标是仅使用平衡热力学的基础定律和定义，计算作为温度函数的绝对摩尔熵，并将其计算过程在一个程序中实现，该程序能在各个区间和相变温度下产生数值上稳定的值。假设在零温度下为完美晶体，因此热力学第三定律适用，无残余熵。\n\n该物质的数据：\n- 分段 Cp 拟合（每个多项式是关于温度 $T$ 的幂，系数按 $\\{a_0,a_1,a_2,\\dots\\}$ 顺序排列，使得 $C_p(T)=\\sum_{k=0}^{n} a_k T^k$）：\n  1. 区间 $\\left[0.0,50.0\\right)$ 开尔文，系数为 $\\{0.0,0.0,0.0,1.5\\times 10^{-4}\\}$。\n  2. 区间 $\\left[50.0,150.0\\right)$ 开尔文，系数为 $\\{12.0,0.02,1.0\\times 10^{-4}\\}$。\n  3. 区间 $\\left[150.0,400.0\\right)$ 开尔文，系数为 $\\{20.0,0.015,2.0\\times 10^{-5}\\}$。\n  4. 区间 $\\left[400.0,800.0\\right]$ 开尔文，系数为 $\\{30.0,0.005\\}$。\n\n- 由温度和摩尔潜热表征的一级相变：\n  1. 固-固相变，温度 $T=\\;150.0$ 开尔文，潜热 $L=\\;500.0$ 焦耳/摩尔。\n  2. 熔化，温度 $T=\\;400.0$ 开尔文，潜热 $L=\\;10000.0$ 焦耳/摩尔。\n\n假设和要求：\n- 将每个多项式区间视为仅在其指定温度范围内有效的独立拟合。\n- 在 $T=\\;150.0$ 开尔文和 $T=\\;400.0$ 开尔文的相变必须被纳入计算，以使绝对熵沿从 $T=\\;0.0$ 开尔文向上的平衡路径相对于温度是连续的。将“等于或高于”相变温度解释为包含潜热的贡献。\n- 从适用于恒压可逆加热的第一性原理定义和热力学第三定律出发；不使用任何其他唯象学的简化方法。\n- 所有积分和求和必须以在 $T=\\;0.0$ 开尔文和分段边界处都是良定义的方式进行计算。数据所蕴含的被积函数结构使得这成为可能，而无需引入任何非物理行为。\n\n单位：\n- 温度单位必须是开尔文。\n- 热容单位是焦耳/摩尔·开尔文。\n- 潜热单位是焦耳/摩尔。\n- 报告的绝对摩尔熵单位为焦耳/摩尔·开尔文，四舍五入到六位小数。\n\n测试集：\n计算以下温度（单位：开尔文）下的绝对摩尔熵：$\\{0.0,\\;25.0,\\;50.0,\\;150.0,\\;200.0,\\;333.33,\\;400.0,\\;600.0\\}$。\n\n程序输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$，其中每个 $\\text{result}_i$ 是一个四舍五入到六位小数的浮点数，顺序与测试集中的温度相同。", "solution": "问题陈述有效。这是一个适定 (well-posed) 的物理化学问题，其基础是热力学的基本原理，并为获得唯一解提供了所有必要的数据。在区间边界处，所提供的分段热容函数存在不连续性，这是经验模型的普遍特征，但这并不会使熵的热力学计算失效，因为熵是一个状态函数。我们将着手求解。\n\n物质在温度 $T$ 下的绝对摩尔熵 $S(T)$ 由热力学第三定律和熵变的定义决定。第三定律指出，完美晶体在绝对零度时的熵为零。\n$$S(T=0 \\text{ K}) = 0$$\n对于恒定压强 $P$ 下的可逆过程，无穷小熵变 $dS$ 与恒压热容 $C_p$ 的关系如下：\n$$dS = \\frac{dq_{\\text{rev}}}{T} = \\frac{C_p(T) dT}{T}$$\n假设在此范围内没有相变发生，将此式从 $0$ K 积分到温度 $T$，即可得到绝对熵：\n$$S(T) = S(0) + \\int_{0}^{T} \\frac{C_p(T')}{T'} dT' = \\int_{0}^{T} \\frac{C_p(T')}{T'} dT'$$\n如果物质在温度 $T_{\\text{tr}}$ 时经历一级相变，其摩尔相变潜热为 $L_{\\text{tr}}$，则会产生一个额外的熵变，由下式给出：\n$$\\Delta S_{\\text{tr}} = \\frac{L_{\\text{tr}}}{T_{\\text{tr}}}$$\n因此，温度 $T$ 下的绝对熵是所有由加热引起的熵增以及在低于或等于 $T$ 时发生的相变所引起的熵变的总和。\n$$S(T) = \\int_{0}^{T} \\frac{C_p(T')}{T'} dT' + \\sum_{T_{\\text{tr},i} \\le T} \\frac{L_{\\text{tr},i}}{T_{\\text{tr},i}}$$\n热容 $C_p(T)$ 以分段多项式函数 $C_p(T) = \\sum_{k=0}^{n} a_k T^k$ 的形式给出。必须对每个分段计算 $\\frac{C_p(T)}{T}$ 的积分。对于一个通用的多项式分段，其积分为：\n$$\\int \\frac{\\sum_{k=0}^{n} a_k (T')^k}{T'} dT' = \\int \\left( \\frac{a_0}{T'} + a_1 + a_2 T' + \\dots + a_n (T')^{n-1} \\right) dT' = a_0 \\ln(T') + a_1 T' + \\frac{a_2}{2}(T')^2 + \\dots + \\frac{a_n}{n}(T')^n$$\n我们必须在给定的温度区间和相变点上累积应用此过程。我们定义变化点：$T_1 = 50.0$ K（函数改变），$T_2 = 150.0$ K（函数改变且发生相变），以及 $T_3 = 400.0$ K（函数改变且发生相变）。\n\n**1. 区间 1：$T \\in [0.0, 50.0)$ K**\n$C_{p,1}(T) = 1.5 \\times 10^{-4} T^3$。此形式与低温下的 Debye $T^3$ 定律一致。\n$$S(T) = \\int_{0}^{T} \\frac{1.5 \\times 10^{-4} (T')^3}{T'} dT' = \\int_{0}^{T} 1.5 \\times 10^{-4} (T')^2 dT' = \\left[ \\frac{1.5 \\times 10^{-4}}{3} (T')^3 \\right]_0^T = \\frac{1.5 \\times 10^{-4}}{3} T^3$$\n在边界 $T_1 = 50.0$ K 处，熵为：\n$$S(50.0) = \\frac{1.5 \\times 10^{-4} \\times (50.0)^3}{3} = 6.25 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n**2. 区间 2：$T \\in [50.0, 150.0)$ K**\n$C_{p,2}(T) = 12.0 + 0.02T + 1.0 \\times 10^{-4} T^2$。对于该区间内的温度 $T$，熵为：\n$$S(T) = S(50.0) + \\int_{50.0}^{T} \\frac{C_{p,2}(T')}{T'} dT'$$\n在第一次相变（$T_2 = 150.0$ K）发生前的熵为：\n$$S(150.0^{-}) = S(50.0) + \\int_{50.0}^{150.0} \\left( \\frac{12.0}{T'} + 0.02 + 1.0 \\times 10^{-4} T' \\right) dT'$$\n$$S(150.0^{-}) = 6.25 + \\left[ 12.0 \\ln(T') + 0.02 T' + \\frac{1.0 \\times 10^{-4}}{2}(T')^2 \\right]_{50.0}^{150.0} \\approx 6.25 + 16.183347 = 22.433347 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n在 $T_2 = 150.0$ K 时，发生固-固相变，潜热 $L_1 = 500.0$ J mol$^{-1}$。相变熵为 $\\Delta S_{\\text{tr},1} = \\frac{500.0}{150.0} = \\frac{10}{3} \\text{ J mol}^{-1} \\text{K}^{-1}$。\n在 $150.0$ K 时，包含相变在内的熵为：\n$$S(150.0) = S(150.0^{-}) + \\Delta S_{\\text{tr},1} \\approx 22.433347 + 3.333333 = 25.766681 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n**3. 区间 3：$T \\in [150.0, 400.0)$ K**\n$C_{p,3}(T) = 20.0 + 0.015T + 2.0 \\times 10^{-5} T^2$。对于该区间内的温度 $T$：\n$$S(T) = S(150.0) + \\int_{150.0}^{T} \\frac{C_{p,3}(T')}{T'} dT'$$\n在熔化温度 $T_3 = 400.0$ K 之前的熵为：\n$$S(400.0^{-}) = S(150.0) + \\int_{150.0}^{400.0} \\left( \\frac{20.0}{T'} + 0.015 + 2.0 \\times 10^{-5} T' \\right) dT'$$\n$$S(400.0^{-}) \\approx 25.766681 + \\left[ 20.0 \\ln(T') + 0.015 T' + \\frac{2.0 \\times 10^{-5}}{2}(T')^2 \\right]_{150.0}^{400.0} \\approx 25.766681 + 24.741585 = 50.508266 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n在 $T_3 = 400.0$ K 时发生熔化，潜热 $L_2 = 10000.0$ J mol$^{-1}$。熔化熵为 $\\Delta S_{\\text{tr},2} = \\frac{10000.0}{400.0} = 25.0 \\text{ J mol}^{-1} \\text{K}^{-1}$。\n在 $400.0$ K 时的熵为：\n$$S(400.0) = S(400.0^{-}) + \\Delta S_{\\text{tr},2} \\approx 50.508266 + 25.0 = 75.508266 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n**4. 区间 4：$T \\in [400.0, 800.0]$ K**\n$C_{p,4}(T) = 30.0 + 0.005T$。对于该区间内的温度 $T$：\n$$S(T) = S(400.0) + \\int_{400.0}^{T} \\frac{C_{p,4}(T')}{T'} dT' = S(400.0) + \\int_{400.0}^{T} \\left( \\frac{30.0}{T'} + 0.005 \\right) dT'$$\n例如，在 $T = 600.0$ K 时：\n$$S(600.0) = S(400.0) + \\left[ 30.0 \\ln(T') + 0.005 T' \\right]_{400.0}^{600.0} \\approx 75.508266 + 13.163953 = 88.672219 \\text{ J mol}^{-1} \\text{K}^{-1}$$\n\n该实现将包含一个函数，该函数为给定的温度 $T$ 确定其所在的温度区间，并通过累加所有先前区间和相变的贡献，再加上当前区间内的贡献，来计算熵。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute molar entropy for a hypothetical substance at various temperatures.\n    The calculation is based on piecewise polynomial fits for heat capacity (Cp) and\n    includes entropy changes from two first-order phase transitions, adhering to the\n    Third Law of Thermodynamics.\n    \"\"\"\n\n    # Test temperatures in Kelvin\n    test_temperatures = [0.0, 25.0, 50.0, 150.0, 200.0, 333.33, 400.0, 600.0]\n\n    # Model parameters\n    # Cp(T) = sum(a_k * T^k)\n    # Coefficients {a0, a1, a2, ...} for each segment\n    cp_coeffs = {\n        1: [0.0, 0.0, 0.0, 1.5e-4],       # T in [0, 50)\n        2: [12.0, 0.02, 1.0e-4],         # T in [50, 150)\n        3: [20.0, 0.015, 2.0e-5],        # T in [150, 400)\n        4: [30.0, 0.005]                 # T in [400, 800]\n    }\n    \n    # Phase transitions\n    transitions = {\n        150.0: 500.0,   # T_tr in K, Latent heat L in J/mol\n        400.0: 10000.0\n    }\n    \n    # Temperature boundaries for Cp segments\n    T_boundaries = [0.0, 50.0, 150.0, 400.0, 800.0]\n\n    def integral_cp_over_t(coeffs, T_low, T_high):\n        \"\"\"\n        Calculates the definite integral of Cp(T)/T from T_low to T_high for a given polynomial.\n        int( (a0/T + a1 + a2*T + ...) dT ) = a0*ln(T) + a1*T + (a2/2)*T^2 + ...\n        \"\"\"\n        if T_high = T_low:\n            return 0.0\n\n        def antiderivative(T):\n            if T == 0: return 0.0\n            val = 0.0\n            # a0*ln(T) term\n            if len(coeffs) > 0 and coeffs[0] != 0.0:\n                val += coeffs[0] * np.log(T)\n            # Higher order terms: (a_k / k) * T^k for k>=1\n            for k in range(1, len(coeffs)):\n                val += (coeffs[k] / k) * T**k\n            return val\n            \n        return antiderivative(T_high) - antiderivative(T_low)\n\n    # Pre-calculate entropy at boundary points for efficiency\n    s_boundaries = {}\n    s_boundaries[T_boundaries[0]] = 0.0\n    \n    # S at 50K\n    s_50 = integral_cp_over_t(cp_coeffs[1], T_boundaries[0], T_boundaries[1])\n    s_boundaries[T_boundaries[1]] = s_50\n    \n    # S at 150K\n    s_150_pre = s_50 + integral_cp_over_t(cp_coeffs[2], T_boundaries[1], T_boundaries[2])\n    s_150_post = s_150_pre + transitions[T_boundaries[2]] / T_boundaries[2]\n    s_boundaries[T_boundaries[2]] = s_150_post\n\n    # S at 400K\n    s_400_pre = s_150_post + integral_cp_over_t(cp_coeffs[3], T_boundaries[2], T_boundaries[3])\n    s_400_post = s_400_pre + transitions[T_boundaries[3]] / T_boundaries[3]\n    s_boundaries[T_boundaries[3]] = s_400_post\n\n    def calculate_entropy(T):\n        \"\"\"\n        Calculates absolute molar entropy at a specific temperature T.\n        \"\"\"\n        if T  0.0:\n            raise ValueError(\"Temperature must be non-negative.\")\n        \n        if T  T_boundaries[1]: # T in [0, 50)\n            return s_boundaries[T_boundaries[0]] + integral_cp_over_t(cp_coeffs[1], T_boundaries[0], T)\n        \n        elif T  T_boundaries[2]: # T in [50, 150)\n            return s_boundaries[T_boundaries[1]] + integral_cp_over_t(cp_coeffs[2], T_boundaries[1], T)\n        \n        elif T == T_boundaries[2]: # T = 150\n            return s_boundaries[T_boundaries[2]] # Includes transition\n        \n        elif T  T_boundaries[3]: # T in (150, 400)\n            return s_boundaries[T_boundaries[2]] + integral_cp_over_t(cp_coeffs[3], T_boundaries[2], T)\n        \n        elif T == T_boundaries[3]: # T = 400\n            return s_boundaries[T_boundaries[3]] # Includes transition\n        \n        elif T = T_boundaries[4]: # T in (400, 800]\n            return s_boundaries[T_boundaries[3]] + integral_cp_over_t(cp_coeffs[4], T_boundaries[3], T)\n        \n        else: # T > 800\n            # Problem data does not cover this range, but can extrapolate if needed.\n            # As per problem, assume T = 800.\n            raise ValueError(f\"Temperature {T}K is outside the valid range [0, 800].\")\n\n    results = [calculate_entropy(T) for T in test_temperatures]\n    \n    # Format output as a list of strings with 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    # print(f\"[{','.join(formatted_results)}]\") # This is for generating the answer\n    return formatted_results\n\n# The function call is commented out to prevent execution in this context.\n# solve()\n```", "answer": "[0.000000,0.781250,6.250000,25.766681,31.961311,45.418292,75.508266,88.672219]", "id": "2680899"}]}